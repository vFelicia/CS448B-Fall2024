How's everyone doing, this is Carlos here with Codecademy with another lesson on Visual Studio and Razor Pages. Now creating an application from start to finish and expecting it to compile without any errors is extremely unlikely. Making mistakes when programming is simply part of the process. Today, we're going to learn different ways to detect and remove existing potential errors in your code. Now when it comes to debugging, Visual Studio shines with its lengthy list of tools that we can use to track and remove any bugs in our code. Today, we'll be exploring how to use breakpoints, how to step into, over, and out of functions, and how to quickly navigate around our project. We'll also be taking a look at different kind of debugger windows that provide us with very useful information. So without further ado, let's go ahead and get started. Okay, so I have a small application here, and the first thing we're gonna do before we start diving into the code is to check what version of Visual Studio we're running. We can do this simply by clicking on the visual studio tab on the upperleft corner, and then going into about Visual Studio. Here, you'll see the information about the Visual Studio that you're running, you can see in my case, I'm using the Visual Studio for Mac Community Edition and I'm using the latest build at this moment, which is built 7 or version 8 point 5 point 5. Now if you want more details you can click on show details, which will give you more information on what frameworks and runtimes were installed. You can see how the dot net core runtime and the SDK installed. And if you're in a Windows machine, you can check the information about Visual Studio by clicking on help, and then going down to about Microsoft Visual Studio, and you'll find information about the Visual Studio version, and other tools and frameworks you have installed. Back in our application, you'll see I have the generated pages and other folders and files that were created when we created a Razor Pages application. So you'll see I have an About page along with the page model for it, and inside the page model, we'll see a few functions that I wrote that we'll be working with. We'll be moving around these functions using Visual Studios tools, like the breakpoints, but we need our application to run first before we do so. This means our app needs to be compiled and built in order to actually run. So let's take a look at what it means to actually build a project and the different ways we can build in Visual Studio. With Visual Studio, we're able to build, rebuild, and clean a project. Now with building, this means that we compile the source code to produce dot exe and dot dll assembly files, which we'll look into in a minute. So we can build a project by clicking on the build tab, and then selecting build all. This will compile our humanreadable code into machinereadable code, so that our computers can run it. The machinereadable code is organized into files called process assembly files, which have a dot exe file extension, and library assembly files, which have a dot dll extension. So if we open up our project in our finder, and navigate into the project directory, we'll see that we have a bin and an object folder created for us. And if we take a look at the bin folder, and navigate into the project, and into netcore app 3.1, we'll see the library assembly files created for us. Now if you're using Windows, you will also find the executable files, which have a dot exe extension. In this case, we'll find dot dll files along with some dot json files that contain some configuration for our project, and we'll also find pdb files, which stand for program database files. And pdb files, essentially, contain information for the debugger to work with. So initially, for the first build, the entire project is built. All consecutive builds are treated as incremental builds, meaning that code is compiled, and if any changes are found in the file, the ID is smart enough to know to only build that file instead of building everything again. Now we can also clean our project. Cleaning the project removes intermediate and output files from the object in bin project folders. Let's say we want to clean our project. So we can take a look at the current files found in our bin folder netcore app 3.1, we'll see that we have our json files, our dll files, and our pdb files. So if we go to build, and then Clean our DebugApp, and then go back into our actual project directory, and then navigate straight into our bin folder, debug netcore app 3.1, we'll see that all our files have been removed. Lastly, you can also rebuild a project. The way rebuild works is we first clean the project, and then build a solution from scratch, and it says the project is cleaned prior to running the build command, and all intermediate and output files are removed prior to the build. We end up building the project from scratch with this one rebuild command. And rebuilding a project is very useful when we want to preserve the integrity of the build and ensure that no output files are stale, if we introduce multiple dependencies over an extended period of time. So hopefully that gave you a better understanding of what happens when we run our application. Okay, so before we start debugging our app, let's take a quick look at our About page model, and see what functions we have created, and what we'll be doing here. First, we'll see here on line 13 that I have a public property of data type string called Message with a getter and setter. Inside our on get method here, we're assigning "Hello" to that same property. And right after assigning "Hello" to it, we're reassigning a new value to it using the add to message function. The AddToMessage function takes an array of three elements, and then returns a new value from it. So if we jump to the AddToMessage function, we'll see what's happening with that method. AddToMessage is a private method that takes in a string array and creates a new string called result. So you'll see we start out with an empty string assigned to result, then we loop over the array that's passed into the method, and append each element from the array to that result variable, which it starts out as an empty string, then after the first iteration, it will add the first element with a new line, then the second element with another line, and then the third element with another line. Once the loop is done, we're using a function created, ReplaceToUpper, that takes in that string and we can look down here on line 41 that it converts the whole string into uppercase. Lastly, we have a divide by 0 method. In this method, we have a try and catch statement, where it attempts to divide by 0 in the try clause, and the catch clause simply logs a message into the debugger. So now we can get into the meat of the video. We're going to start by looking into Breakpoints. Now a Breakpoint indicates where Visual Studio should suspend your running code, so you can take a look at the values of variables, or the behavior of memory, or whether or not a branch of code is getting run. We can place a Breakpoint right next to a line number. So in our application, I'm going to go ahead and add a breakpoint in our on get function, where I assign the string "Hello" to the property message. From here, we have a few options on how to run our application with debugger, we can go to run and select start debugging, you can also click the play button here, which has a debugger that will open and launch our application on a Google Chrome tab. So I'm going to go ahead and click the play button here, and this should run a build, and then run and execute our application. Once the build is successful, our application should be launched in a new Google Chrome tab. And a shortcut on a Mac to run the app with the debugger would be alt and command and enter. On a Windows machine, there are a few ways you can start your application with a debugger, you can go to the debug tab up here, and select start debugging, the shortcut for it would also be f5, or you could click on the play button here on the upperright corner. So once we've run the application with a debugger, we can navigate to the About page, and from there, we'll be taken to our breakpoint location. So I'm going to go ahead and click on About, and we'll be taken to the breakpoint location where our code has been suspended. Once we're here, we'll see that a few windows have popped up for us. You have the locals error, breakpoints to watch, and the threads window. So if we go into the locals window, we'll see some information displayed on local variables and objects based on the current context or the local scope. Since we're in the About model, we'll see variables from that model, and the model it inherits, which is the Page model. So the keyword this is in context to that actual model. So if we open up this dropdown, we'll see a bunch of properties and builtin functions that belong to the About model and the Page model class. The second line here will see our property message, which has a value of null, which makes sense because our code has suspended, so this line 17, where we assigned the string "Hello" to Message, hasn't been actually executed yet. Now when it comes to Breakpoints, Visual Studio is very useful in providing us with three different types of actions that we can use on Breakpoints. First thing we could do is step into which runs the next statement so if the current line contains a function call step into steps into that function the shortcut for this command on a Mac is shift command and I and on Windows it is f11 we could also step over which runs the next statement without stepping into functions or methods in the shortcut for this on a Mac is shift command and o and on Windows it is f10 and lastly we could step out of which advances the debugger all the way through the current function and it continues running code and suspense execution when the current function returns the shortcut for this on Apple is shift command in U and on Windows it is Shift + f11 back in our application we can find options for these commands here at the top of our tab so let's go ahead and jump over into the next statement which is found here on line 19 where we reassign message so next to the play button I'm gonna go ahead and click on step over which will direct us to the next statement here on line 19 and now if we take a look at our locals windows we'll see that message now has a value of hello because a line on line 17 was actually executed now here on line 19 were making a call to the function add to message so we want to take a look at what's happening in there we could step into that function so let's click on the step into action button and then we'll be taken to the function definition you can see by our cursor here indicated that we're now in this code lock since the method now has actual scope we could also click on the parameter to see what values were passed in so we click here on text we'll see a little drop down of text that contains an array containing three string elements so we can actually open it up and see the values that were passed into that method and now that we have local scope in this function we can actually go into our locals window and find the variable text in there with some information regarding its value we could also find it here on our watch window so we'll be going to this watch window we'll be able to track down any variables that we care about and see how they change while we're debugging our application so we can add any kind of variable or i10 that we'd like so I can double click here and that message and you'll see the value being populated so I can also add another one I'll add text to see what the value of it is and you'll see that it's actually an array containing three string elements so the watch window is very useful in letting us track how these variables change or even seeing any expression being generated you can actually type in any kind of expression here and it will return us a value so let's write out a string that displays the first element in the text array so we'll type in tuck 0 is and then I'll type out and access the first element in the text array and then we'll see that the value has been populated for us it's also useful to point out if you're on a Windows machine you can simply highlight and drag the variable into your watch window so now let's take a look at the call stack now the call stack shows the order in which methods and functions are getting called and it's a good way to examine and understand the execution flow of an app so if you place a breakpoint in a replace to upper method here where we return text dot to upper we can actually continue this and see the call stack now you won't see the call stack here and if you by any chance closed any of these tabs you can find them like going on to view going to debug pads and then you'll see the windows that are useful for debugging so I'm gonna go ahead and click the call stack and it should show up here so I'm gonna head expand this a little bit more scroll down so now if we continue and I click on run well we take in and shown the call stack which is basically either line of execution so we start here on line 19 as indicated where we make a call to add to message then we're taken to the add to message function and then from here you can see that it's highlighted we're making another call to another method called replace to upper which starts out here and a function definition and then finally it returns the text in uppercase so our code is suspended here at the moment meaning it hasn't returned anything but if I click run again our call stack should be cleared since or returning a value from that method so let's take another look at how the call stack actually worked so we started our on get method within that method we're making a call to add to message so the add to message function call is added to the call stack within the apt in message method were actually making another call to a method called replace to upper so from there replace to upper is added to the call stack as well and once a value is returned from replace to upper our call stack is clear so we're essentially three lines deep into our line of execution before we return a value so I'm going to go ahead and close the call stack window and now we can look at the output window now the output window displays status messages for various features and IDE and it helps us track of what's happening while the application is running well find certain logs of applications running what port were running our application on or packages being installed or updated but we can use it ourselves to actually log out certain information whenever we hit a line of code if we take a look at our divide by zero method call here we're attempting to divide an integer by zero which throws an exception we can then cast the exception and write to the line a custom message so when we continue the application if we look on our on get method we notice that we made a call to divide by zero on line 24 since we know it's not possible to divide by zero we caught the error the exception and send a custom message to our output window as you can see we're using string interpolation to actually display the message and you can see that it's out put it here in our output window where it says oops attempted to divide by zero so one other a handy tool we can use is to set conditionals and our breakpoints so instead of hitting a specific break on every time we run our application we can create a condition to only hit it if a certain expression is true so let's say we only want to stop at this breakpoint if the string argument your text contains a word first I can do that by right clicking on the breakpoint and then editing the breakpoint from here we can specify that the variable text should contain the word first well have some other options provided for us but we want to place an advanced condition to only stop at this breakpoint if the text contains the word first so we can click on apply and now that condition should be applied to the breakpoint so let's go over ahead and go through the process of debugging our application again and let's see if we actually land on that breakpoint now so this should launch our application once more we go ahead and click on about well land on the first one where we have the message equal to hello and we'll continue to the next one and you'll see that we actually land on that breakpoint now if I were to actually change the condition for that breakpoint where it contains something that is not in that so I'll type in second and apply that condition and then we go over the process again let's go ahead and launch your application going to about since that condition will be equal to false then we should not land on that breakpoint let's go to about well land on the first breakpoint and if we click run and continue you'll notice that we actually don't we skip that breakpoint and we go straight and to divide by zero which logs out the message oops attempted to divide by zero now let's take a quick look and see how we would do this on Windows on a Windows machine sending a conditional on a breakpoint is a little bit different let's go ahead and place a breakpoint where we returned the text and upper case and right click then you go to conditions and from here we can set any kind of condition that we like so let's add a condition where we only want to hit the breakpoint if the text contains the keyword first and then you'll see some configurations on the breakpoint and you'll also notice a plus sign and the breakpoint indicating that a conditional has been applied to it so this feature is specially useful when one is trying to catch a condition that may only occur once out of many passes and where we want to save time and not break on each pass to check for a value that we're looking for okay now let's move on to the error window now csharp is very specific with the syntax so let's say we forget to add a semicolon I'm gonna remove the one here on line 17 where we assign the string to message and we try to run our application our application will fail to build as indicated here at the top so we can actually open the errors window and see where the error actually false so you'll see we have it really nicely formatted for us we have basically a table that displays what the error is for the description which filed in which line so we'll see that on line 17 after about CSS HTML dot C as file we forgot to actually add a semicolon since it was expected here so I'll go ahead and add it back in there so let's make another mistake here that's very common let's scroll down into our / 0 method now in order to actually use the debug object here and make a call with right line on it we need to import the correct library namespace now I already have it added at the top here on line 3 where we specify that correct namespace which is system dot Diagnostics but let's pretend we forgot to add it so I'll remove it and then we'll run our application and see what error is actually being displayed this time so our build was not successful and we'll see in the description that the name debug does not exist in the current context now one thing we could do now is simply look up online where debug comes from and at the proper namespace but there is a handy tool we can use called quick fix so you'll see a red underline where the bug is located and if we right click on it and select quick fix will be provided with a few options on how to actually fix this bug so you can see that we're missing an actual namespace and visual studio is smart enough to let us know which one it is so we can actually click on using system diagnostics and it will automatically add to our actual code so you'll see on line three it's been added now and the red squiggly line has disappeared quick actions are extremely useful and not only at using statements but help us easily refactor or generate or otherwise modify code with a single action and as you continue your coding journey in asp.net you'll see how quick actions may come up with solutions for other types of errors let's take a look at how we can actually navigate a bit more around or methods and properties so we can actually right click on methods and we'll be provided with a few options so if you right click on add to message and we want to know where exactly the function was declared we can go into go to declaration this will take us exactly to where the actual method was declared as you can see by the screwdriver here on line 28 we can also see where a method was referred so we scroll down here and 2/0 and we right click here and we go to find references will be given a search results window where we find all the references to that method so we'll see our search results we are declaring it here on line 46 and I'm making a call here on line 24 finally let's assume our project is huge and we're working with a large number of folders and files imagine we want to look up where a certain function is called or what files are using it we could search for that method with a search functionality so if we click on the search tab and go down into finding files we be able to search any methods or variables that we want so let's go ahead and search for add to message and we'll look in our current project and let's click on find and here you go you should get the search results at the bottom here where we're actually making function call on line 19 and the definition on line 28 so this covers a large chunk of the available tools that Visual Studio provides for building and debugging an application we saw how to build clean and rebuilt works we also saw how useful breakpoints are in order to suspend the application in certain sections and navigate around it in the state's debugger windows were extremely useful and we looked at a couple of them we looked into the call stack which is extremely useful in seeing the flow of how methods are called and which methods are being trickled down into other ones which is very useful to track where your application could be breaking we use the output window in order to log certain messages from within the application and then we look into the error window which provides us a more detailed information regarding any errors found on our code by displaying the line a description and what possible solutions we can actually give lastly we took a look at some useful quick action features like quick fix in order to modify our code with a few simple clicks and finally we looked into how to find method declarations or references by simply rightclicking on them and selecting jump to definitions or find references now these tools are extremely valuable in helping solving issues around the application but most importantly remember to read the error messages oftentimes our application could be breaking because we forgot to add a comma somewhere so error messages could save us a lot of time by letting us know on what line and arrow was found in a description of it so hope this video gave you a good understanding on how to debug your application Thanks to everyone who watched and I'll see you all next time