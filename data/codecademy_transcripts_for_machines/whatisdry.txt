hi my name is Stephanie I am a software developer based in Baltimore and in this video we're gonna go over the what's the whys and some clarifications of DRI DRI is also known as that don't repeat yourself principle it's a common practice developers use when they're writing code to make sure they don't have multiple pieces of code doing the same thing will spend the rest of the video going over three big takeaways of dry when developers follow dry they will isolate a piece of logic and read the code for it in one place where it will be accessible to whatever else needs the logic this means that any other place that needs the same logic can reuse that code without rewriting the code kind of like when you have a menu instead of distributing an individual copy to everyone just put it up on the wall and let everyone order from there say for example I have this bank account and I'm writing a function to deposit any amount of money in my account hold on I think I've seen this somewhere before yeah I'm going through some old code and I see that I've already written the same deposit logic for two other accounts one for Catherine's account and one for Michael's account this would be a perfect opportunity to use a dry principal we'll need to consolidate the logic in one place add some abstraction and make a reference to where our logic is held so in our case this would mean consolidating the bank account creation and deposit logic into a class and now when we want to create an account that can deposit we just need a reference the bank account class so here we're making Stephanie's Michaels and Catherine's account using our new bank account class and they can deposit using the function that belongs to the class without rewriting the logic for it three other times just as DRI saves you from having to rewrite logic when it appears in other places it saves you from rewriting code when you want to make changes you'll also avoid errors as you'll only need to modify one piece of code instead of ten say now from our previous example we instead want to make each deposit return the new balance then we would only have to do that in one place instead of four drag can also make the codebase easier to read because the layers of abstraction simplify what the code is trying to do so you get a general idea what's happening for example looking at the first function here I can see that it makes T and as we read through the function we know that it makes T by getting a cup of water and adding leaves this is because the get cup and add functions are added layers of abstraction that hide away how the cup is retrieved and how the leaves are added so we can focus on the end result that there's a cup with water and that leaves for added now using our DRI compliant functions I can also make hot cocoa in the second function here and I already know what this functions do without seeing the implementation of the get cup and add functions it can be pretty exciting when you go back through your code and start to form some ideas on how to remove duplicate code but there's a difference between removing duplicate code and using dry removing duplicate code can be good but the driving force behind DRI is to reduce repeated logic when you remove too much code it's possible to go overboard as you're simplifying you may need to make an exception in order to make it work to show you what I mean let's continue our bank account example we could also use the deposit function for withdrawals and rename it to reflect something that adjusts the balance so now our deposit function can be renamed to address balance to reflect the expanded functionality and now any deposits will be represented by positive numbers passes arguments to the adjust balance function and withdrawals will be represented by negative numbers seems pretty straightforward right but we all know that people can't withdraw if their balance dips below zero so here enters our first exception if the new calculated balance is less than zero we should return an error message to let the user know they can't withdraw any more and then we need to update the balance for when the deposit or withdrawal is valid now you might be thinking what's the big deal it's just one exception right well not quite we haven't considered overdrafts yet so now we'll have to expand our function to accommodate overdrafts and let the user withdrawal the funds even when the balance is negative so we'll want to charge the user $35 for the overdraft and update the balance to allow the withdrawal to go through Oh we'll also need a send back a proper error message and a new balance and we should consider waiving the overdraft fee of the users the first time offender woo but what about interest and now we've fallen into this rabbit hole of making exception after exception just to make this function work for every scenario we've gone from this deposit function here to this monster right here and you can see how much more difficult it is to read this is something that I still have to keep myself in check about when I look over my own code that's why coming back to the purpose of dry to eliminate logic duplication helps me answer the question should I remove the duplicate code here so back in our example we can ask ourselves will removing duplicate code make it dry compliant is their logic duplication here and the answer is no deposits and withdrawals are two separate pieces of logic dries a very powerful concept that can strengthen your code and make it versatile not all situations will be black and white and may take a bit of creativity but if you're ever in doubt just ask yourself is this duplicate code or is this duplicate logic thanks so much for watching I hope you enjoyed this video feel free to subscribe to this channel and drop a comment below and if you're ready to take your skills to the next level you can start learning on coke atom II today