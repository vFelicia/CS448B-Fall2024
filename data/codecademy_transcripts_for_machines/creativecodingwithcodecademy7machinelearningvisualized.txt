how's it going good how are you i'm good uh let's let's wait a couple of seconds here before we get started to just confirm that we're live think all right yeah i think we are good to go um so hello everyone uh my name is alex this is another edition of creative coding with codecademy i'm here again with g1 juwon how's it going good uh everything's going well this is already um session seven which is actually um amazing that we've made it all whole way this far but yeah we got one more uh next week is going to be our last session but for today's session what we're going to be doing is we are going to be looking at a machine learning algorithm visualized using p5 so again uh i i led the session last week which was very much focused on like let's learn this core let's learn about objectoriented programming through the lens of p5 similarly this lesson is going to be let's learn about the knearest neighbor algorithm through p5 and so again g1 you're really the p5 expert i think that as we're doing this uh i'm sure you will have lots of input onto different ways that i could make this prettier and more artistic um but for the most part what we're going to be doing is you're going to be seeing my very unartistic brain just coding out this algorithm and explaining the algorithm um as always we've got the chat open on youtube so if you want to talk with us there or ask questions there um very happy to chat with you there and then uh anything else from eugene before we get started no i'm excited cool let's do it so i'm gonna share my screen here all right um first thing that i want to say is before we get started i've linked in the youtube description uh a link to our knearest neighbor course um so if you want to dive deeper into this and go through the whole course um that's available to you and then the other thing that i've linked is the solution code which i'm going to walk through here so before we get started coding this thing let's actually talk about what this algorithm is doing and so this is a supervised machine learning algorithm which essentially means that we are uh given some data which in this case is going to be these dots on the screen we're going to try to predict something about a new piece of data let me actually randomize my points yet more okay more even split so the k nearest neighbor algorithm first i'm going to talk about it just as these dots and colors and then we can talk about okay what does this actually mean for a real application because who cares about dots and colors but for now let's just look at the dots and colors so right now what the k nearest neighbor algorithm does is it says okay we have all of this existing data we have dark blue and light green data that each have an x and y position and so we can draw them on a map and now if i come in with a new piece of data if i have something if i have a new dot that doesn't have a color but it has an x or y position the thing that we want to do is assign it a color and the way that we do that is by looking at its nearest neighbors so if i start to mouse over the um the canvas here you'll see that it kind of looks like i'm painting um different colors and so what's happening here is that each time i move my mouse i'm saying okay i have a new piece of data that i don't know the answer to i don't know if you're green or blue and so what we're doing right now and you can even see uh the three the three dots highlighted in yellow those are my three nearest neighbors and since they are all uh light green i'm gonna say okay if i had a if i had a uh unknown point where my mouse is that's also gonna be green if i move up here now where my mouse is again that unknown point two of those neighbors are blue and one of them is green and so we're gonna say okay we're gonna classify that unknown point as dark blue so that's that's really the the essence of the algorithm is we have known points we have points where the class is known and this is why it's a supervised machine learning algorithm we have a data set where we know things about it already we're saying we're going to use that information to try to classify unknown points and it's kind of cool you can see we can uh kind of paint the decision space here and we can see okay where where would things be classified as green versus where would things be classified as blue interesting so it's not just about the distance of the the new data point between uh between the existing points it's also about how many of those near points are for one category versus another yeah exactly and that's actually where the k in k nearest neighbor um comes from right now k is three and so you could think of that as okay i'm looking at my three nearest neighbors so again when my mouse let me rerandomize it to clear it off when my mouse is right here my three nearest neighbors are uh you know those three three points that are highlighted in yellow but if i move down here it's three different points i can also then change k and see okay if k is seven the decision space is gonna look different right uh things are gonna be classified differently because um we're looking at a wider section of the original data so what what would be some of the use cases like real life usage use cases where you would apply this algorithm to then yeah so so right so this is um uh points floating in space with colors the thing that we're trying to classify as a color the example that i always like to use is um classifying like movie ratings um and so you could think of something like uh light green is a thumbs up and dark blue is a thumbs down so let's say you've seen 20 movies or however many dots there are here yeah i believe there's 20. you've seen 20 movies already you've given some of them a thumbs up and some of them a thumbs down and now you can use that existing data to say okay this movie that i haven't seen uh am i gonna like it or not and i'm gonna figure that out by look by taking a look at the movies that i have seen and seeing which movie you know how similar my unseen movie is to the movies that i have seen so thinking about that you you might say okay then what are my two dimensions right i have uh all these points have two dimensions they have an x coordinate and a y coordinate you could say the x coordinate of the of the point is maybe um the year it was released and the y coordinate of the point is how many minutes long it is and so you can plot out all your movies where okay something that's way over on the right if i said x was when it was released maybe that's released in 2020 and if it's way over on the left that's released in 1920 or whenever the first movies were and then uh the y dimension if that's movie length something near the bottom might be a really short 60 minute movie something near the top might be a long fourhour movie and so you can start to say okay let me take all the movies that i've seen and rated put them into this gra you know plot them like this and now any movie that i haven't seen i can find it the year it came out and i can find how long it is and then i can say okay if my point were there would you be light green or would you be dark blue so it's a it's a way to classify things that um classify movies that you haven't seen before based on the movies that you've already seen cool interesting um another really common uh or really an example that's kind of easy to wrap your mind around is looking for apartments so you can think of the features of your apartments could be okay uh um price and square footage and then again the thing that you're the thing that you're determining is whether or not i might be interested in buying that and so you go and see 20 apartments you get your data set you say oh i i was interested in these i wasn't interested in these and then you can use that existing data set to then say okay this apartment that i haven't seen do i think i'm going to like it or not based on those those apartments i did see it could also be interesting to do to have like a plotted um points of you know like price could be on the xaxis and square footage going to be on the white axis and the color could be coordinated into manhattan versus brooklyn and you could make a guess um if the point was on there is it more likely to be a brooklyn apartment or a manhattan apartment that could be interesting thing to figure out totally and and i guess like a couple of things to talk about before we get into this is right now in all of these examples we've dealt with two features um looking to classify one thing so right movie release year and length uh trying to classify whether or not we like it the thing is that you can expand that to three dimensions so you can imagine plotting these points in threedimensional space and then finding the distance between them so that would be like you know release year um price or release year length and production budget yeah budget exactly you can even do booleans like is you know tom cruise in this movie or something that could be a feature um so you can do that in three dimensions and then the really crazy thing is um you can do that in n dimensions so you can do it in four dimensions five dimensions and obviously that becomes really difficult to visualize but it's the same principle of i have this unknown point that's floating in you know ten dimensional space let me compare let me find its nearest neighbors in 10 dimensional space and see what class there they are so you can uh you know you can add more and more features um if you have those features to play around with interesting so you can get more and more complex as as complex as you want it to be yeah exactly and there's lots of i mean this this then starts to really get into machine learning um and like good machine learning principles of which features do you use which one shouldn't you be using um an interesting example that you gave of like budget is you have to think about the scale of your features so for example if um if one feature is in the scale of the millions and the other features in the scale of the tens then that feature that's in the scale of the millions is just gonna totally dominate in terms of distance right because like you know these two points might be a million units apart in this dimension and one unit apart in that other dimension and so you know your distance calculation gets it's a little bit hazy there so there might be things that you want to do to normalize your features um so tons of ways that you can dive even deeper into it but yeah that's the that's the main concept is that we have points in space and we're going to find the k closest points in space and uh and look at the class of those points cool cool cool okay folks in chat if you have any questions about the algorithm itself happy to answer it but for now let me let's go ahead and try to code this up um cool let me also pull this to the side just so i can have my solution code up in case i screw something up um cool so let me get my chat window all right um okay cool so i think the best way to start this project is to first of all make it object oriented so our last session is very relevant to this let's define what a point is and so let me go ahead and do that juwon what are the features of these points do you think first i guess there like you said there needs to be some sort of an x and y position right so that we're gonna need a um a attribute for x and y yeah and we can i guess that's that's something that we haven't talked about which is to um provide arguments as constructor i can't remember if we did that or not but that's something worth mentioning that we can talk about later oh yeah and in fact we did we what we're going to do for our uh for our version here is we're just going to like randomize the x and y points so we almost don't even need attributes we could just make them random right here um but yeah actually let's do that so we're gonna need x and y and then one other thing what else do these points all have color yeah color so that is the class of the point right so um yeah that's the class and eventually that class is going to be represented as a color but internally let's just represent that class as a one or a zero okay so cool let's do a little bit of setup here of just giving it random x and y uh values and let me find so if i do what was the p5 function for getting something random do you want it was like random [Laughter] so when we create a point we're going to give it a random x value between zero and the width of the canvas and uh same thing for the height and then for the class what we want is we want just one of two numbers right we want it to either be a one or a two um there's a couple of ways that you can do this i'm gonna i'm gonna do the way that i did this when i was coding this up but you want i bet you have a better way to do it so i did math.random which you can replace by random yep so yeah let me just do that's a that's a random number between zero and one right excluding one right uh so if i do random two that's between zero and two and actually two and these are all decimals right so now if i floor that i believe this will give me either zero or one right yeah i think so i think that's what we'll get is there a better way in p5 to just say i want a random number between zero and one or either zero or one um i think that's that's exactly how i would do it to be honest okay cool yeah so again if you uh this random number is going to be a random decimal between 0 and 2. so that might be 0.075 and then floor says just cut off the decimal basically round down so if i get .05 that's going to become a zero if i get 1.99999 that's going to become a 1. so the only things this is ever going to be is a 0 or a 1. cool all right let's also quickly write something to draw the points so i'm going to call this just yeah display i guess i'm going to draw an ellipse at this dot x this dot y i'm gonna make it uh 20 by 20. i think i only need one parameter there but and so that'll draw draw on ellipse we can even run this and of course it doesn't run anything yet because we haven't actually created points um let's go ahead and do that so in setup we can say all right let me create i'm going to create this as a global variable again something that's like maybe not great uh you want to use let instead of bar thank you um so i'm going to assign points to be an empty array um let's also have num points let's just code that in as a variable so i can not hard code that everywhere and now i'm going to uh add 20 points to this array so for um uh so i'm going to do 20 4 loops running 20 times um what am i going to do i need to push a new point into points so points dot push new point cool and then so that's creating the points and in terms of drawing the points i'm going to do the exact same thing i'm going to have a loop and instead of pushing a point to points i'm going to grab the point from my array and tell it to draw itself which i called display all right let's see excellent there are my points so we haven't done anything with the color yet so that would be something that is responsible in uh display so let's say um if this dot class oops sorry if it's uh zero for now let's just do fill red 255.00 and then in javascript is it no just else or unless are you going to do one or the other are you going to also check if the class is something else i mean i guess we could do else because we know it's either gonna be zero or one i was gonna do an else if just to just that way if somehow it we screwed it up and it wasn't zero or one then it would be i guess you could do elsif yeah let me let me do lsf so else if this dot class is one then let me do red this one will be green also one more note um in javascript you want to make sure that there are you know equal regardless of type so you want to do three equals cool yeah so again this is my kind of lack of javascript knowledge so is that like if if this dot class were a float and this is an int then those wouldn't actually be equal okay cool all right so we've got our points they're being randomly generated each time we run this they are being redrawn which is great so now we can actually dive into writing the k nearest neighbor algorithm so what do we want to do we want to say wherever my mouse point pointer is i want to find the k nearest points and so to do that we're going to need to have some measure of distance there's a lot of different ways that you could measure distance um the most kind of common one is just the straight line distance so that's using some you know pythagorean theorem stuff uh a squared plus b squared equals c squared there are other distance metrics that you could use one is called um manhattan distance so rather than looking at like the diagonal from my mouse to this point it says how far over are you and how far up are you so it's kind of taking the two other sides of the triangle rather than the diagonal of the triangle um it's called manhattan distance because it's um like street blocks where i'm like oh i'm i'm 10 points over and 15 points up interesting and so i'm 25 points over so again this is kind of something that we go go through in the class itself but there are different reasons why you might want to use different district district distance metrics but for this let's just say we are going to use the straight line point between the between the two points um cool so we want to do that and then really what we want to do is we want to compare our distance to every point that exists um because we don't know which which point is going to be the closest right visually you and i can say okay my mouse is here the closest three points are like that one that one and that one but the computer can't just like look at it and see that so what the computer has to do is it has to look at every single point and say which are the three that i'm closest to so let's start trying to write that up um i'm gonna do that i'm gonna make it a separate function called classify mouse and um yeah we can give it no parameter for now um so again just saying maybe we should give it a parameter uh so we let's give it a parameter of k so given k where again that's the number of neighbors how is my mouse gonna be classified so right uh g1 where my mouse is right now um if k were actually let me go here am i uh that's still even gonna be hard uh okay if my mouse were here and k were three what would my what would the classification be i think it would be green because there's a green one on the left corner there and then the green one on the bottom right corner there and there's one red one but because there's two green ones it would also be green yep totally um and then if if k were four the fourth closest point is probably that one and so we have a tie we'll have to think about what we do in ties if it were five looks like it would be green again it would be three versus two if it's if it were six it's back to a tie this one might start getting in the mix that one might not be closer or not but so that's kind of what we what we have to think about we're given k our classification might change from from green to red so we're going to need to know how many neighbors we actually care about okay cool cool so like i said we want to look at every point and find the distance from that point so let's do that by just creating a list so let distance is it's an empty list i'm going to grab my for loop for all of my points all right so what do we want to do in this for loop we want to say i want to add to distances the distance between my mouse and the point itself so g1 i had in my solution code i had written up a big nasty function so like doing the pythagorean theorem a squared plus b squared equals c squared you said hey there's a a p5 function that does exactly that for you um so we don't have to do that ourselves so do you know what that function is yeah there's a function of if i just called this so like short for distance and you give it um a set of four arguments first two for the first endpoint and then the other two for the second end point and um yeah it's generally mp5.js it's used to measure the distance between your mouse and an existing element and shape element in canvas so you can most common use of that would be like to detect whether the mouse is on an element or not so we can i think we can use that um this function instead of doing the it does behind the scenes exactly what you're saying the measuring the pythagorean distance between the two points the straight distance to between the two points but i think we can save everyone from the actual mathematics of it and just use the function yeah for sure um okay cool so i actually changed my the name of my rated distances because we're going to be storing multiple distances in there and let me first just save this as a variable as distance equals um okay so calling the dist function i need to give it four values now i can give it my mouse x my mouse y and now the x position and the y position of the point that i'm looking at so the point that i'm looking at is what did i call this points are sort of oops points are stored in the array called points points of i is the point that i'm looking at and then i want that points x value and then that points y value um cool and then that's the distance and so let me just push that on to distances so distances dot push um did i screw something up why is that not blue um i think it's just because it's a local variable i don't think there's anything wrong with it but you might want to put a let before distance even though you know javascript is fluid and that will work but yeah cool and so now actually what i'm going to do just to see if this is going to work i'm going to console.log distances and then i need to call this function somewhere so i'm going to say okay in the draw loop after i've drawn all my points let me call classify mouse with uh some parameter of k i'll say for right now k is three even though we're not doing anything with that yet and so we should see a bunch of things continue um so let me actually stop this before my computer overheats but so what that was doing was every every frame of the p5 loop which again is happening 60 frames per second um it's looking at where my mouse is and then it's comparing it to every other point so this is what our array looks like my mouse was 216 um units yeah pixels away from uh one of the points 247 away from another one of the points so and there's all 20 points so cool um in theory now we could say uh let's or let's sort this list from lowest to highest and then just grab our k closest points um juwan do you see an issue with that what are we missing if we just say let me sort these uh these distances and grab the three lowest ones how are we gonna tell which um index that would be the top three would be if that makes sense because right now we have it per index right and if we shuffle them um in the order that we want we're going to lose the order yeah exactly so if we were to sort this great it's it's awesome that there's a point 56 pixels away but as soon as i start reordering this list i'm going to lose which pixel or which point that was connected with and the whole point of doing this is we need to see okay what it what were the classes of those points right we need to say were you red or green in order to make our um in order to classify our unknown point so juwon what would you do to fix that how would you uh because i think there are a couple of different things that you can do here um how would you kind of keep track of what distance is connected to which point um i think there could be a number of things um i don't know if my answer is going to complicate things but you could we could create what's called a um you know 2d array so to speak and so that we could sort based on one number in that one array so that so okay backtracking a little bit we could have one mega array and in it with individual elements could be another array that is a pair of index number and the value itself and then we could sort it based on the value itself and then so then you you reorder the arrays inside of the bigger array rather than moving around the h just the value itself that makes sense yeah totally so instead of pushing on just the distance what we're going to do is we're going to push on an array of distance and then let's say i just the the index of that distance was at so now if i run this code oh we haven't oh we are calling it okay and we look again i stopped it just because it keeps running forever if we look at one of these now we can say okay the yeah uh 318 was connected to um uh the point at index zero uh 190 was connected to the point at index one and so now if we shuffle up this uh if we shuffle up this list if we sort by this first number we will hopefully uh be able to reference back okay you were connected to point number one or you were connected to point number zero cool this is like maybe one of the trickier parts of of doing this is now we have to write kind of our own custom sorting function and i'm actually curious to see what happens if i just tell it to sort so if i do uh distances dot sort let's see what happens i don't know what's gonna happen here i don't think is it gonna work i don't think it's going to work yeah so let's see oh okay so it's sorting i always run into this in in javascript when i'm trying to sort and honestly i don't know uh how to get around it i believe it's sorted as if this were a string so the ones came first then the twos if i scroll all the way to the bottom uh you know the eights and nines are towards the bottom um so yeah that didn't quite work yeah so it says it's comparing i'm looking quickly looking up the mdn box but it's comparing their sequences to the utf16 code units value so yeah it's checking it as like a string value as if the this was um that the the number that we have is a string so basically the ones come first and then the twos will come and then the threes will come so it doesn't matter if it's 200 or 2. yeah exactly and so i got to feel like there's a better way to sort a list of numbers in javascript but i don't know it um and so what i did is i wrote my own custom sort function so the way that that looks is you can pass and and again i think i'm probably gonna like have the terminology wrong here um as a parameter i can pass a function that takes two values and so it's saying okay if i'm sorting thing a and thing b if a of uh if the so thing a and thing b are one of these sub arrays of distance and i so a of zero is the first thing that we're comparing its distance if a's uh distance is greater than b's distance um then i'm going to return 1 meaning a was greater and then otherwise i'm going to return zero uh sorry return negative one meaning b was greater um now if i do this now let's see if this works seems good so far yeah i do have to say i would probably have done exactly the same thing as you did alex in javascript just because um so sort is an array method right and we are able to use this sort method because distances is a an array and there are a number of um javascript functions that you can use that is specific to method called method array methods because array in javascript is also kind of considered as an um javascript builtin object and that uh when we create arrays it kind of is a the same way as looking at it as if we're creating an instance of the array object and so in this way there are a number of um different methods that we can use that you can only use for um array objects and in javascript that can be a little bit confusing because javascript's not supposed to have a data type but um yeah this is where it gets a little bit tricky but the sort fun method can take in what's called a function expression as an argument of the sort method which is what alex has done in there and if we take a look at the mdn um documentation which i will post very soon into the chat this is basically what they recommend you do in the end on documentation that if you want to sort between two numbers and basically what happens in here is that even though i was returning um a one or a minus one depending on whether one is greater than the other what that will do is that the sort method will do it apply for all the other things and it will um go in like a loop so sort function behind the scenes will be running a loop and do all of these comparisons between all the numbers in the e um or the elements i guess all the elements inside of the distances um array and this particular one because you want to compare you know whether one one numeric value is greater than the other numeric value that we're referencing because um our distance is uh array is a nested array in an array in an array you have to specify which element in that one element area limit you wanted to compare it to and then it will do it for the whole loop and then order it so in a way you can think that this is actually quite a short a short way of doing it really yeah and so uh to be clear if i if i reverse the order here if i put the index first and then the distance second uh i would then say okay the thing that i want to sort based off of whenever i'm comparing two things in the distances list i don't care about i don't wanna sort by i right i wanna sort by uh the distance which now because i've reversed it is a of one and b is one and so if i run this again we should hopefully see um same thing yeah my mouse was like right on top of some uh five pixels away um there's some implement uh implications of ties right so if if my mouse is exactly the same distance away from two points um it's going to return so if if a of 1 and b of 1 are equal it's going to return negative 1 meaning b was actually greater so again it's i guess it's not really it'd be really hard to even demonstrate this but i suppose be aware that if two if two points are exactly the same distance away from uh uh from your mouse you have to choose one to be closer than the other right you can't say both are equally close i suppose you could but then things would get very complicated um and so it basically kind of it kind of arbitrarily picks b to be the one that's closer um but it is gonna be really hard to demonstrate because as you can see in the um the first element of the arrays they go up to i don't know how many number of the decimal points that is but um you will have to be really really accurate and it's not something that i guess we don't have to worry too much about because we're demonstrating this in p5 but it could potentially be a little bit of like a edge case scenario because if you have like you know like very specific scientific points between one or the other and if there is a chance where these two could be you know exactly the same then it would arbitrarily choose b over a yeah same thing with uh whatever distance function you chose to use could affect this where again the thing that we're using is just the straight line distance which results in these decimals but if you did something like manhattan distance which is how many pixels over and how many pixels up are you away from uh from the point then we're not really going to have these decimals so still pretty unlikely that you would have that you'd be exactly the same distance away from two points but i guess slightly more likely than uh than using um straight line distance cool um where are we so we've got our point of let me just okay we've got our sorted list of distances and furthermore we have the uh index associated with those closest points so now what we want to do is we want to say let's grab those k closest points and see if though if red or green wins right or are there more red close red points or more close green points so let's do another for loop so let me even um grab my for loop because i'm lazy um let me also set a global variable for k uh no we don't even want a global variable for k we're using just though three yeah uh so i want this loop to happen three times and what i want to do is i want to let's set up two counter variables so class one um probably uh other clever ways to compare these two things um but i can say okay let me now go through my sorted array so i want distances of i i already used i so let me i don't know if that matters or not but let me use j here it shouldn't matter but yeah yeah um okay so let me go through my sorted array let me grab the k closest point so this point i want to look at its class so that was the points class and now i want to say if its class was zero there's my python trying to use colons uh if it's class with 0 0 let's do class i'll name these 0 and 1 class zero uh does plus plus exists in javascript yep yep it does and then if it was one then uh class one but alex i'm thinking this might create an error though because the distances um array is now in each of the elements is an array right so if we refer to all of that what we're saying is that we're expecting the elect the array that has a pair of eye and distance to have a class called or sorry an attribute called class which it doesn't so we're going to have to recall yeah so in fact let's let's run this code and see the error that that happens um which we're not gonna get an actual error c because i guess it can it just neither of these happen right uh i'm asking for the class of of something that looks like this um which i guess it's just like that's undefined or something yeah it will return a null yeah yeah so in fact i can just to demonstrate this let me log that grab my consoles yeah so there's the the undefined because i screwed this up so we don't want to compare that what we want to do is we want to say distances of j of zero that's this variable but this variable is just a number right that's that was the zeroth element or the first element or whatever it was so we can't ask for the class of a number we want to ask for the point at that number which looks really ugly and so again let me uh let me log just this points of distances of j of zero [Laughter] right which is so now we're logging the points and the thing that we want to grab from the point is the class which is either one or zero so now this if statement should be working and we got to make sure to do that for the second if statement good catch i uh definitely wasn't even thinking that cool all right what what next you want what's the what's the next point so we've got um we've now counted our neighbors whether they're of class zero or class one um what should we do with that now well now we gotta see which one wins right we gotta see if class zero has a greater number than class class one yeah and again there's gonna be an interesting yeah thank you uh there's going to be an interesting tie breaker here um because if class 0 is greater than class 1 then something happens otherwise something else is going to happen um let's see 0 was red so i'm going to say if class 0 is greater than class 1 i'm going to draw a red circle otherwise i'm going to draw a green circle and then finally i want to actually you know color in my my background where my mouse is so i want to draw an ellipse at mouse x mouse y and then let's make it 10 by 10 or maybe even smaller than that five by five and okay cool so it's kind of working uh uh something is happening with the background where actually this might even be a better representation where i'm not possibly drawing it over and over and over again um cool so yeah i think i think that this is the part that's doing the classification is just setting the fill which is a little bit uh it feels a little anticlimactic right we do like all of this work we like we compare all of the distances we sort our lists we then count up the neighbors and all we do at the end of the day is choose what color to draw our mouse but again that's kind of the point of all of this where we want to classify our mouse point um all right do you want what's the implication of the tie here with um what if there are uh four if i look at my four nearest neighbors and to our green and to our red the way that we've coded it right now who wins the way that we've coded it it's going to be green that will always win right because we class zero has to be has to be greater than class one so the only way that class zero will win is if it's three if there are three uh neighbors that are red um but if it's two then it's gonna think that it's gonna be green right and if i if we change this if i said if class zero is greater than or equal to class one now if it's two two then we've then we're classifying our mouse pointer as um red rather than green but i see that it's like a really interesting opportunity to do um a interesting visualization here for me in my perspective because you know for me i care a little less about the exactness of this um science and i'm like oh this is gonna be an interesting place where we could do if class 0 is greater than class 1 then we could have it red if it's less than class 1 then we could have it green but if it's equal to each other then we could have it colored a mix of green and red right cool yeah um class one is greater than class zero and then else meaning they're equal then we could fill uh 255 255 0. and so let's see again we're going to have to make sure that we're comparing an even number of neighbors just so we get the opportunity for them to be tied um and then let's see if we can find a uh all right can we eyeball a tie uh let's see think like here there we go it's yellow um i think before i take the take the background off it would be easier to see yeah and this will let me uh let me make that my mouse pointer uh slightly bigger just because it is hard to see and then what is white is it uh 255 but we might want to move that to setup so that we can just draw on top of it sure yeah there's some yeah so i'm just going to draw the background at the start so now as i mouse over it'll look like i'm uh yeah the the yellow is interesting uh in in most in most machine learning algorithms you're not going to want a tie because it's uh you don't know what to do with that so again there's like lots of different strategies on how to break the tie um i mean one of the most simple ones is just randomly picking one of the classes um and that way you can get like a definitive answer because um yeah sometimes you don't you don't really know what to do with uh with a tie right which is why i'm saying that if you were going if you were using this algorithm for straight up machine learning algorithm you wouldn't want to do that but i'm like putting in a bit of like a twist from my perspective where i only care about creating you know beautiful looking things then i think this is like a great opportunity to allow for that tie um and create um to me kind of is this this sort of algorithm the way that i see it um we could create like a really interesting gradient visualization so if we were to actually you know remove that display in draw um so that we don't actually draw the points and then you could just have you know users just play around with the mouse so they don't really know um what kind of a color that they're gonna get but this is like um basically like a pain tool that you don't know what area is gonna be colored and what but it's totally decided um yeah based on the kenya's algorithm that's super clever where now i just have a uh a blank slate but there are those points in the background that um that are determining the color interesting it's so hard to get red i know and now it's like it's hard to debug now so we don't see it but [Laughter] here if we run it again i'm sure we will uh yeah cause the thing is that remember we're randomizing the class of every point when we hit the run button and so it's possible that um we're just not getting a lot of red although two in a row now there we go there's some red so there's probably a cluster of red points you know right in this area yeah um cool any other ideas that you have to to make this kind of visually interesting to you on um the other thing i think would be really cool is if we had like you know obviously having more than one class is going to be interesting but if we were to also not just use um the mouse but we could also randomly select different things so we could have like scattered almost like um you know like paint falling on the paper but then the color of the paint depends on where it falls on the paint a paper so we could um instead of using mouse but then i don't know if it's going to be something that could be easily doable let's i think we can do it so yeah i think we put a random instead of mouse x and mouse y yep exactly so let's do classify we'll keep calling it classify mouse but we'll say x and y so this now takes three points and we want the distance from x and y to the points in our array and then we use the mouse anywhere else and then we want to draw the the thing at x and y rather than our mouse and then when we call it um let's do classify mouse we can we can stick we can still use four neighbors but we want random um width and random height and then let's even make these dots a little bit bigger just so it fills up quicker totally overheating good call yeah uh i probably could just put it at the top but um nice and you can like obviously hone in on it you can put it in like um so opacity and all the fills and you can put in like um you know you can even create another class on top of this so that basically the way that you draw it would be drawing an instance of a new class so then you could decide on like the different shape of different sizes for each of these drops as well all that sorts of things and um you could do even further things like um i don't know i think this this is like a really interesting like like a pattern making almost yeah it's cool oh my god look at that um yeah when i when i first made this uh it's the original thing is at the end of the um my computer is like totally overheating from from printing all of those arrays but um the original is at the very end of the knearest neighbor course um let it load again this is the uh i've put this solution code to this exact thing in the youtube description um it was just like captivating to like draw this out and then it's like a rorschach test of like oh what like what uh what image do you see you and uh when you do knearest neighbor here um but you can see some of the other details that i added were i highlight which um which neighbors are the closest neighbors um and then i also added some uh some abilities for you to play with the inputs so you can rerandomize the points which just kind of like refreshes everything um but then i can say okay this is what the space looks like with three neighbors if i kick that up to five or six this space is gonna look look slightly differently yeah i'm also like almost getting like an inspiration of creating like um abstract pointillism um visualization by you know putting in more classes in there so you could you could use you know a gradient of five five different colors and like create all these like pointless pointless and things for like a bigger canvas with like smaller points that's gonna make it a little you know the points a lot more finer i think yeah interesting that's a cool idea let me find um man let me find another course that we have on codecademy because it speaks to what you were talking about a little bit um so what we just did was classification where the final output of our thing is your unclassified point is either um zero or one right it's either red or green another thing that you can do with k nearest neighbor is g1 like you said if you have kind of multiple classes what you can do is you can um run a regression on it where the output of that isn't just zero or one it's some point along a spectrum so like zero and five um and again kind of really similar um really similar concept of you're comparing points but then at the end of the day you know this point had a had a value of zero that point had a value of five your third neighbor had a value of three you know you average those values together or you do something with those values together to get a final uh a final answer of like 2.5 um another idea that i had um was we could do a thing where you know similar to the one one that we had before we use the mouse and if you click on it it gets attract you could um code it with a little bit more physics in there and you could have that point attracted to one classification category versus another that could be really interesting kind of reminds me of like the pinball machiney sort of aspect where you drop a bowl in and you could it could go to one side versus the other based on which category yeah that could be also a really fun thing to create try to create too if anyone wants to take up the challenge yeah i would love to see if if folks have been have watched through this whole thing and you're interested in it i would love to see kind of what variations you can make of this yeah what it could be really really cool if like anyone creates like a you know a remix of the p5.js sketch that we post as a web editor if you want to like drop in your own web editor links as like comments in the video that will be really cool to see yeah that would be that would be awesome um so this is an example again using movie uh movie stuff um this is an example of regression where now we're not it's not a binary thing of yes i liked it or no i didn't like it this is something where um i'm going to go ahead and rate there has to be at least 5 because right now k is five i'm going to rate five movies and now that those are in all of the ones that i haven't rated um are recommend uh recommended and again you have to think to yourself okay what are the features of these points that like you can picture the you can picture the visual visualization right as dots in some space and again i think let's see if we say it in here um um man i don't know if i uh man yeah i don't know what uh what features um we're actually running this on i think it's like release year length and budget or something like that and that's that's how the points are being drawn in the space and then we find our nearest neighbors and so as you you know if i go ahead and uh start rating old movies really low you'll find that like the other old movies will also start to drop compared to the the recent movies or something something like that um that's fun yeah like if i wanted to do like more than one gradient i guess this is sort of like the algorithm that we'll take a look at to apply behind the scenes yeah exactly um a couple more little like machine learning tidbits or things to uh think about this for this algorithm is right one of the things that comes up with algorithms like this is the idea of a column start problem where again this algorithm is kind of useless if i don't have a bunch of existing data and so it's great that this exact algorithm exists behind the scenes but in order for it to be useful i have to actually start giving it some of my own data right i have to start rating movies myself um so that's an example of the cone start problem of it takes some time for this algorithm to actually be useful because you need to give it um some base points yeah some some starting point um and then the the final thing that i want to say about this algorithm is that this is an example of a lazy algorithm which means um let me actually go to um the final version so this is a lazy algorithm because it doesn't do any work until you show up with a new point so the moment i show up with an unclassified point it has to do all of the work right then right the points are just sitting in space i show up with a new point and it compares uh it compares that point to every point in the space and so you could you could imagine if there's you know a hundred thousand points in the space that's a lot of work that it has to do it has to make a hundred thousand comparisons um that's in contrast to i think it's called eager learner learning algorithms where these other algorithms they kind of do the preprocessing ahead of time where they have a sense of the decision space they have a sense of where things are going to turn green versus where things are going to turn blue and in those algorithms you show up with a new point and it doesn't have to do all the math then it just says hey you fell in this space and i earlier i calculated that that space should be green versus this lazy approach which it doesn't know anything about the space it just knows it knows where the points are and when a new point shows up it has to do all of the math um yeah so kind of two different styles of algorithms almost makes me um think that we could do the eager version as a grid and then we could have all the points in each of the grid cells calculated if the mouse is over then it changes the color of the grid too that could be fun too yeah that's kind of um yeah that's kind of how some of those algorithms work where um yeah it's like yeah you can visualize it as already the thing that you see is already kind of like the filmed in version of this picture where you already see like the boundaries and so then when a point lands it just kind of classifies it as one or the other cool it's super interesting yeah um yeah i love uh i love p5 because you're able to like this is a complicated algorithm right i didn't learn this until like well into college and so being able to like super quickly right we did that in under an hour of being able to visualize it and kind of get a a good conceptual understanding of what the algorithm does i think it's i love p5 for it because it just makes stuff like that so fun yeah cool um cool g1 do you want to plug what we're doing next week yeah next week is going to be our final live stream series for um creative coding with kirk academy and what we're going to do next week is i'm personally really really a huge fan of you know these things but we're going to be basically creating a visualization that's driven by audio so what we're going to do is we're going to learn how to import in a audio file inside of our p5.js sketch we're going to learn how to play it we're going to also learn how to analyze the music data itself um program click a probe inter using programming and we're going to use specifically what's called an fft or fast fourier transform algorithm it sounds really complicated but the thing with b5.js is that you you don't have to know too much about it there's already a class built in for you there's already a function built in for you and we're going to use that and make things move based on the frequency and the beats in a music so that's gonna be hopefully really interesting to the end thing for a lot of people and so it's kind of also like a boom at the end being like like a really interesting thing that you can create using music and also visualization so we're going to be doing that next week and yeah and you're doing that with nick right yeah nice cool all right well i think that is all for us for today so yeah thank you uh thank you for watching and we'll see you next