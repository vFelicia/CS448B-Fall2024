00:05 - introduce some Concepts and talk about
00:07 - what we mean about computer security and
00:10 - network security because we're going to
00:11 - focus this topic more on network
00:13 - security we'll try and explain the
00:15 - difference
00:19 - what is security or here's a definition
00:22 - of computer security
00:26 - the protection afforded to an automated
00:28 - information system in order to attain
00:31 - the applicable objectives in preserving
00:34 - Integrity availability and
00:35 - confidentiality of information system
00:38 - resources
00:39 - so here's one definition coming from the
00:43 - National Institute of Standards nists an
00:45 - organization in the U.S that among other
00:48 - things
00:48 - creates a lot of Standards about
00:50 - security protocols and techniques and
00:53 - their view of what they mean by computer
00:54 - security
00:56 - so
00:58 - an automated information system think of
01:01 - a computer system
01:02 - whether it's one computer
01:04 - or many computers connected together
01:07 - some computer system we want to protect
01:09 - it
01:11 - to achieve some objectives
01:14 - and their objectives are preserving
01:16 - Integrity availability and
01:19 - confidentiality
01:20 - of some resources
01:23 - okay so protect our system to uh make
01:28 - sure
01:29 - well we preserve Integrity availability
01:31 - and confidentiality we need to define
01:33 - those three
01:34 - objectives and we'll do that on the next
01:36 - slide talk about what they mean
01:40 - here's another definition actually from
01:43 - the textbook by Stallings about network
01:45 - security
01:46 - measures to deter prevent detect correct
01:51 - security violations that involve the
01:53 - transmission of information
01:55 - so network security is about when we're
01:58 - sending information across some Network
02:01 - some computer network
02:03 - computer security is more General
02:06 - computer security includes network
02:08 - security
02:09 - but computer security also includes the
02:12 - security of the actual PC or computer
02:14 - itself
02:16 - okay so we can have computer security
02:18 - issues without having a network at all
02:22 - I need my own laptop I need to protect
02:24 - uh the files on it I may want to encrypt
02:28 - they are issues of computer security but
02:30 - not network security
02:32 - network security is when we want to send
02:34 - data between two computers or between
02:36 - many computers
02:39 - so we're going to focus in this course
02:41 - mainly on network security so some
02:44 - aspects of computer security will skip
02:46 - over or not cover
02:49 - and what's the main Network that we use
02:51 - every day the internet so sometimes
02:53 - referred to as net internet security
02:59 - but the first definition mentioned these
03:02 - three things confidentiality integrity
03:04 - and availability
03:06 - CIA
03:07 - the trial Triad of CIA as some people
03:11 - refers to it
03:12 - the most important objectives in
03:14 - securing a system
03:19 - we'll see some definitions a little bit
03:21 - later of those three again but
03:23 - confidentiality keeping things secret
03:27 - keeping information Secret
03:30 - a common objective is if I send
03:33 - information from one computer to another
03:38 - and
03:40 - that information is authorized for use
03:43 - only by that other computer or the user
03:46 - of the other computer
03:48 - I don't want someone else as I send it
03:51 - across the network to be able to
03:52 - intercept and read that information
03:55 - I want to keep that information
03:57 - confidential
03:58 - okay so that's the idea of
04:00 - confidentiality
04:01 - Keep information private or secret or
04:04 - confidential
04:07 - Integrity is making sure the information
04:09 - is not changed
04:12 - so it's related to confidentiality but
04:15 - we also want to make sure if I send
04:17 - information from one computer to another
04:21 - then
04:22 - the information received by the
04:25 - destination computer is exactly the same
04:28 - as what was sent by The Source computer
04:32 - it would be bad if I have an email
04:35 - message
04:37 - and I'm saying sending an email to
04:40 - someone uh what's an example I'm sending
04:44 - an email to the secretary saying
04:46 - change this student's grade from A to B
04:52 - no no that's a bad example change your
04:54 - student's grade from B to C okay I made
04:58 - a mistake with marking so I sent an
04:59 - email to the secretary saying this
05:01 - student needs their grade change from B
05:03 - to C
05:06 - but one of the students and that one
05:09 - uh that the email is about somehow
05:12 - intercepts the message on the network
05:14 - and modifies the message and changes the
05:17 - message to say change the grade from B
05:20 - to a
05:21 - it's received by the secretary the
05:24 - secretary thinks it came from me it did
05:26 - originally but it's been modified along
05:28 - the way
05:30 - that's what we don't want Integrity is
05:32 - about not allowing that to happen
05:34 - maintain the Integrity of the data
05:37 - that's a common requirement or objective
05:40 - of security
05:41 - and availability is the other common
05:44 - objective of security
05:47 - we have a network and we have a computer
05:49 - system which has normal users
05:54 - we want to make sure that Network and
05:56 - computer system is available to those
05:58 - normal users
06:00 - it would be bad if that Network becomes
06:03 - unavailable due to some malicious
06:05 - actions
06:07 - so an example is a web server web server
06:11 - is part of our Network or an entity in
06:12 - our Network it has the role of say the
06:17 - Amazon web server right it's just spread
06:19 - across many web servers but think of
06:21 - Amazon the company they sell many things
06:24 - via their web server they make billions
06:26 - of dollars by people going to their
06:28 - website and ordering products
06:32 - what if the Amazon web server was not
06:34 - available for 24 hours
06:37 - something happened there was an attack
06:39 - on the web server which mean it was down
06:42 - well I'm sure the company Amazon would
06:44 - lose millions of dollars
06:46 - in Lost sales if the web server was down
06:49 - for a day if no one could access access
06:51 - Amazon for a day then that would be a
06:54 - financial loss to the company
06:56 - so some security attacks try to make the
07:00 - service unavailable
07:02 - availability is the objective okay our
07:05 - system must be available to the intended
07:07 - users
07:08 - we shouldn't allow it to become
07:10 - unavailable
07:12 - another three key objectives of securing
07:16 - Networks
07:19 - some related ones or other ones which
07:21 - are also considered important this was
07:23 - one of the earlier
07:24 - um Concepts that people arrived at these
07:27 - three but they later added talking about
07:29 - authenticity
07:32 - make sure that the data you receive is
07:35 - authentic
07:36 - is genuine
07:38 - it's coming from a genuine user
07:42 - it's not coming from someone who's
07:44 - pretending to be someone else
07:47 - and accountability
07:50 - make sure that if something goes wrong
07:52 - we can track what went wrong
07:55 - and make someone accountable for what
07:57 - went wrong
07:58 - for example
08:00 - a student
08:02 - breaks into the ICT server and
08:07 - gets all the answers to the quizzes for
08:09 - this course so you can do the quizzes on
08:11 - Moodle and get 100 all the time
08:14 - okay if that happens what I would like
08:18 - to be able to do is to detect that it
08:20 - happened
08:21 - and even better Trace back to which
08:24 - student did it
08:26 - and then I can take action on that
08:29 - student outside of the network I can
08:31 - take other action like give them some
08:33 - penalty so accountability is the ability
08:35 - to uh
08:37 - detect things going wrong keep traces
08:40 - and logs of what happens so that later
08:43 - on you can respond and take action if
08:47 - things do go wrong in a network
08:51 - so some of the objectives of securing
08:54 - computer systems and computer networks
09:00 - what happens if something does go wrong
09:03 - what if we have a security breach
09:07 - how does it impact upon the users or an
09:10 - organization
09:12 - there are different
09:15 - different classifications to look at
09:17 - okay when we're planning this the
09:20 - security for our organization we'd like
09:22 - to predict in advance
09:25 - what if this goes wrong what are the
09:27 - consequences
09:30 - here's some of the most common impacts
09:34 - of security breaches
09:38 - the effectiveness of primary operations
09:40 - are reduced that means if you think of
09:42 - an organization a company
09:44 - a university
09:46 - sit what happens if someone
09:50 - breaks the security of our network of
09:52 - our databases of our service
09:55 - well one thing that can go wrong is that
09:58 - we have to spend a lot of time fixing
10:00 - and we waste time fixing what went wrong
10:03 - as opposed to providing the normal
10:06 - service to students and others that is
10:10 - the organization does not work as well
10:12 - if things go wrong
10:15 - a simple example
10:19 - I create an exam for this course I store
10:21 - it on my office computer before the exam
10:24 - you take before you take a midterm exam
10:26 - I created a week before and I've
10:29 - prepared it it's stored on my office
10:31 - computer
10:33 - what happens if a student accesses that
10:36 - exam one week before the time for the
10:39 - exam
10:40 - if I detect that
10:42 - what happens well it means I have to
10:44 - recreate the exam
10:46 - I must rewrite the exam because I know
10:48 - if some students got the exam most
10:50 - likely every student will have the
10:52 - answers by the time you sit the exam
10:55 - that reduces my Effectiveness that is I
10:57 - have to now rewrite the exam wasting my
11:00 - time rewriting a second exam
11:03 - I can spend less time doing other things
11:05 - that I should be doing so the effective
11:08 - effectiveness of my operations are
11:10 - reduced in that case
11:13 - other impacts may be a financial loss we
11:15 - lose money
11:17 - the example for Amazon
11:19 - if the Amazon web server goes down for a
11:22 - day because of some attack on the Amazon
11:24 - web server
11:25 - the company will lose money
11:27 - okay so that's a potential breach a
11:30 - potential impact
11:33 - damage to assets damage to hardware
11:37 - damage to software for example someone
11:40 - gets access to
11:42 - uh the source code of Microsoft Windows
11:45 - they break into the Microsoft network
11:48 - and gets access to the original source
11:51 - code
11:52 - and
11:54 - they make changes to the source code
11:55 - without people detecting so we can think
11:57 - that that's going to potentially damage
11:59 - the the software product that's produced
12:03 - you can have damage to computer hardware
12:07 - and the example I was recent is uh the
12:12 - stuff stuxnet worm was a worm one or two
12:16 - years ago which was distributed by
12:19 - usually by USB keys and it was a worm
12:23 - and we talk about worms in one of our
12:24 - topics actually no I've removed that
12:26 - course we may mention it I've removed
12:30 - the topic
12:31 - but some malicious software such that it
12:34 - was carried on a USB key and when people
12:36 - plugged it into the computer it
12:38 - distributed onto the network
12:40 - and the target of this malicious
12:42 - software was the I think the centrifuges
12:45 - in a
12:46 - nuclear power reactor
12:49 - okay
12:50 - and people think the target was one in
12:52 - Iran where this malicious software made
12:56 - this the hardware the centrifuge operate
12:59 - in an uh abnormal way
13:02 - for example make it
13:04 - go fast faster than it should go
13:07 - and which caused the hardware to break
13:10 - down
13:10 - which had the effect of then they cannot
13:13 - process the material that they wanted to
13:15 - process so that was a case of a soft
13:18 - malicious software
13:20 - which is part of a security attack that
13:23 - damaged some Assets in this case
13:25 - Hardware assets
13:28 - you've seen on movies or TV shows maybe
13:30 - that people can break into the heart
13:33 - monitors and the the uh the heart
13:37 - right controllers
13:39 - that people wear
13:41 - and in theory if you could
13:45 - attack that and make it do something
13:46 - that it's not supposed to do you could
13:48 - have a impact on someone and harm
13:51 - individuals
13:52 - okay
13:53 - so the
13:54 - impacts of security breaches may be very
13:57 - small I have to rewrite an exam to be
14:00 - very serious Financial human loss of
14:04 - life and damage to assets
14:09 - there are different approaches to from
14:11 - an organization's perspective to think
14:13 - okay
14:14 - in advance
14:16 - what are the potential breaches that can
14:19 - occur what are the likely impacts and to
14:22 - give some ratings to look at well what
14:25 - actions should I take to make sure those
14:26 - impacts are minimized
14:29 - and there are some standards that we
14:32 - won't go through that talk about that
14:35 - we need to treat security uh
14:39 - importantly we need to consider it
14:43 - carefully because the impacts may be
14:45 - large
14:46 - okay
14:50 - let's look at
14:52 - a a view of or a perspective of network
14:57 - security and the components of securing
15:00 - computer networks
15:03 - and this perspective comes from itu
15:07 - the international telecommunications
15:09 - Union they create standards about
15:11 - telecommunications including securing
15:14 - computer networks
15:15 - we don't care so much about that they
15:17 - created it and how the standard is uh
15:20 - there's some document that describes
15:23 - security aspects from their perspective
15:25 - we're going to use the notation and
15:28 - terminology that they introduce to talk
15:31 - about what we require for computer
15:32 - security
15:34 - and the main things that they introduced
15:36 - that we'll we'll use is that they
15:39 - talk about security aspects attacks
15:42 - mechanisms and services so we'll Define
15:45 - those three over the next few slides
15:47 - different types of security attacks
15:49 - mechanisms and services
15:52 - and some terminology we'll use as we'll
15:54 - talk about a threat
15:58 - and an attack
16:02 - we have some desire for operating our
16:06 - organization Network or computer system
16:08 - in some way and we usually Define some
16:11 - policy that we'd like
16:13 - for example a policy should be no
16:16 - student can access the exam on my
16:18 - computer
16:19 - okay that's obvious a simple policy from
16:22 - my perspective of who can access that
16:25 - information
16:28 - a threat is a potential violation of
16:31 - some security policy
16:33 - so my policy or my aim no student can
16:36 - access
16:37 - the
16:38 - exam on my computer
16:41 - there are some threats
16:42 - one threat is that a student walks into
16:45 - my office and takes my computer and then
16:47 - they can access the exam
16:49 - another threat potentially is that they
16:51 - can get remote access over a network to
16:53 - my computer
16:55 - okay so there are multiple threats
16:58 - that are potential violations of my
17:00 - policy in that case
17:03 - an attack
17:05 - is an assault on a system
17:08 - that comes from a threat
17:11 - in simple terms an attack is a threat
17:13 - carried out
17:14 - so the threat is that someone takes my
17:18 - computer and reads the exam well an
17:20 - attack would be if someone actually
17:21 - comes and grabs my computer and reads
17:24 - the exam so an attack is an actual
17:26 - implementation of a threat
17:33 - who performs attacks I'm not sure if
17:35 - there's a slide about this maybe later
17:37 - but
17:38 - some terminology for what do we call
17:40 - someone who performs an attack sometimes
17:43 - we'll talk about
17:44 - an attacker
17:47 - maybe a malicious user
17:49 - uh
17:51 - an adversary is another word used
17:54 - sometimes you'll hear a hacker someone
17:57 - hacks into the network
17:59 - okay I'll usually use malicious user or
18:01 - an attacker
18:03 - but when we talk about all the
18:04 - techniques through this course when we
18:06 - talk about the attacker or malicious
18:07 - user they don't necessarily have to be a
18:10 - bad person
18:12 - sometimes the attack may be coming from
18:14 - someone who's doing something good or
18:16 - something legal
18:18 - okay
18:19 - uh law enforcement agencies may use
18:23 - legal techniques to intercept other
18:26 - people's messages and read other
18:27 - people's messages
18:29 - from the perspective of the security
18:31 - technique they are the attacker or
18:32 - malicious user
18:34 - but they may be doing something good or
18:36 - legal
18:37 - so when I say malicious user I don't
18:39 - always mean someone who's bad
18:45 - often the case
18:47 - let's look at those three aspects what
18:49 - is a security attack mechanism and
18:52 - service
18:58 - an attack an action that attempts to
19:01 - compromise the security of information
19:03 - or facilities information or facilities
19:06 - so information data
19:08 - facilities think of Hardware or software
19:11 - or even communication lines
19:15 - compromise them to get access to
19:17 - information that they shouldn't be
19:18 - allowed to to modify information to make
19:21 - the system unavailable for example
19:26 - a threat is a potential violation of
19:28 - security
19:29 - an attack is an actual violation
19:33 - we usually analyze the threats look at
19:36 - what are the possible threats
19:38 - and try and Implement measures so that
19:40 - the attacks cannot occur
19:42 - or successful attacks cannot occur
19:46 - a security mechanism is a method for
19:48 - preventing detecting or recovering from
19:50 - an attack right I'd like to prevent
19:53 - attacks
19:55 - so if I know of some threat
19:57 - I would apply some mechanism to prevent
19:59 - an attack from being successful
20:03 - I know the threat for someone accessing
20:06 - the exam on my computer
20:08 - one threat is they take the laptop
20:13 - and then just read the file from my
20:15 - computer
20:16 - well what mechanism could I use in that
20:18 - case
20:19 - to prevent that attack what could I use
20:25 - sorry
20:27 - guessing
20:31 - yeah
20:32 - okay all right physical locks on the on
20:35 - the laptop
20:37 - what else yeah correct
20:41 - I I can't
20:42 - I can't uh
20:45 - secure my computer all the time
20:46 - physically
20:48 - what else could I do such that
20:52 - even if someone steals my laptop they
20:55 - cannot read the exam on my laptop
21:01 - encrypted password I hear okay some some
21:05 - basic techniques and we'll through this
21:07 - course we'll look at how effective they
21:09 - may be but okay if I have a password to
21:13 - log into my laptop
21:15 - such that if I leave it for five minutes
21:17 - I need to type a password again then
21:20 - that may provide some primitive
21:21 - protection
21:23 - we may see how effective it is later or
21:26 - I could make sure the file is encrypted
21:29 - so that
21:30 - to unencrypt to decrypt I need again
21:33 - some password or special key to read it
21:36 - more generally encrypt the hard disk
21:39 - even if someone can
21:41 - steal my hard disk access the computer
21:43 - log into the computer they still need
21:45 - some password to decrypt the hard disks
21:47 - so there may be ways to prevent or to
21:50 - they may be mechanisms
21:54 - there's a threat
21:56 - and we can apply mechanisms to try and
21:59 - prevent an attack
22:02 - but sometimes we cannot prevent an
22:03 - attack
22:05 - so the next best thing is try and detect
22:07 - if an attack has or is occurring
22:11 - uh maybe hard on the laptop but in some
22:14 - other cases we can detect that
22:16 - something's uh some attack is occurring
22:20 - and if we can detect
22:23 - either we can quickly try and respond or
22:25 - we can take other means to try and
22:27 - recover
22:29 - again if I detect
22:32 - if I could detect
22:34 - that if someone got hold of the exam I
22:37 - could trace it back to you then that
22:40 - acts as a good deterrence from you
22:42 - trying to access the exam
22:44 - because if you know
22:46 - it's very easy to steal my laptop but if
22:49 - you steal a laptop and read the exam if
22:51 - you knew I could trace that back to you
22:53 - as an individual
22:55 - then unlikely you're going to do it
22:56 - through that I know no one's going to
22:58 - steal my laptop anyway but if we had a
23:00 - malicious user
23:01 - there's active or the deterrence is also
23:04 - a good mechanism
23:06 - because if I can trace back to you I can
23:08 - take other action
23:12 - so there are different mechanisms for
23:14 - doing this for detecting preventing
23:16 - recovering
23:17 - and in fact
23:19 - this course is about those mechanisms
23:21 - we'll look at those mechanisms in this
23:23 - course
23:27 - security service
23:29 - we use the mechanisms
23:32 - to improve or enhance the security of
23:34 - our information and Facilities
23:37 - so we stop attacks
23:39 - we can think of the services as some
23:41 - requirements
23:42 - what we'd like to achieve
23:44 - so the next few slides go through
23:46 - services
23:49 - tax then Services let's go through a tax
23:51 - first
23:55 - now my example of the laptop is maybe
23:58 - not the best one for this course because
23:59 - we're going to focus on network
24:01 - communication so we're not going to deal
24:02 - with okay what if someone should uh
24:06 - steals my laptop
24:07 - but we're going to deal with the cases
24:09 - all right what if I send the exam in an
24:12 - email to the secretary to print
24:15 - can someone intercept across the network
24:17 - and steal the exam that way
24:20 - let's look at
24:22 - Security tax and classify them
24:25 - first classification of security attacks
24:28 - on networks passive and active
24:33 - a passive attack
24:37 - makes use of some information
24:40 - to perform the attack
24:41 - but it doesn't affect the system
24:43 - resources so the system consists of the
24:47 - users the computers and the network
24:52 - a passive attack doesn't modify how the
24:55 - system operates
24:57 - it just observes
25:00 - but still performs an attack
25:03 - uh all right we'll Define active and
25:06 - then we'll compare them in a moment
25:09 - an active attack somehow modifies or
25:12 - Alters how the system works the
25:14 - resources are operations
25:19 - yeah
25:21 - let's come back and talk about them
25:22 - after we go through some specific
25:24 - instances so with passive attack there
25:27 - are two types we'll talk about releasing
25:29 - the message contents and traffic
25:30 - analysis and then with active four types
25:34 - so I'm going to go through those six
25:35 - specific attacks and then we'll come
25:38 - back and explain again what we mean by
25:40 - passive and active you'll become clearer
25:42 - and we'll compare them
25:45 - so now let's go through six attacks
25:48 - and these nice pictures from the
25:50 - textbook I'm going to use to illustrate
25:58 - so we have a Communications network with
26:00 - some users
26:01 - this picture shows okay as the blue
26:03 - cloud as the network
26:06 - whether it's some link where it's the
26:08 - entire internet but some Network that
26:10 - users use to communicate with each other
26:13 - and in this example we have Alice and
26:15 - Bob
26:16 - to
26:18 - normal users of the network
26:20 - they're not malicious they're just
26:21 - normal users
26:23 - and Bob sends information to Alice
26:26 - that's the normal operation
26:28 - it sends emails or messages to Alice
26:32 - for example
26:34 - um
26:37 - Bob and Alice work in the same company
26:39 - and Bob is sending some
26:42 - secrets of the company to Alice
26:45 - some Secret Designs of their new product
26:48 - that they're going to build and sell
26:49 - okay
26:51 - now an attack where we release the
26:54 - message contents is one of the most
26:56 - obvious ones the one that most people
26:58 - think about when we talk about
26:59 - cryptography is that we have some
27:01 - malicious user da in this example
27:05 - that somehow as Bob sends messages to
27:08 - Alice's to Alice
27:11 - gets
27:13 - gets that message and is able to read
27:16 - the contents of that message
27:17 - so we show it as the message going to
27:20 - Alice and also going to Darth and Darth
27:23 - can read the contents of the message if
27:24 - the message is some Secret Designs of
27:27 - their up and coming product and if Darth
27:30 - is a competitor then he can go and build
27:32 - the product and sell it first so this is
27:35 - the case of an attack where we release
27:36 - the message contents
27:38 - same as of I send
27:41 - the exam to the secretary to print
27:44 - I'm Bob Alice is the secretary
27:47 - and some student intercepts
27:50 - somehow on the network
27:52 - and reads the exam then that's an attack
27:54 - that releases the message contents
27:57 - okay
27:59 - this is the case where we'd like to keep
28:01 - that message confidential
28:10 - note that
28:12 - and let's try and explain an active and
28:14 - passive this is an example of a passive
28:16 - attack
28:17 - imagine there's no attack Darth is not
28:20 - there
28:22 - then what happens Bob has a message and
28:24 - sends it across the network to Alice
28:28 - that is Bob sends one message
28:31 - Alice receives that same message
28:34 - no identical message if there was no
28:35 - attack in that case
28:37 - now we introduced the attack Bob sends
28:40 - the same message
28:42 - Alice receives that message
28:44 - but with the attack Darth also receives
28:47 - the message
28:48 - but from the perspective of Bob and
28:51 - Alice nothing has changed
28:53 - whether there's an attack or no attack
28:55 - from the normal user's perspective from
28:58 - the system's perspective
29:00 - nothing's changed
29:03 - and that's why it's called a passive
29:04 - attack
29:05 - nothing has been altered from the normal
29:07 - system operation
29:09 - but still one attackers occurred
29:20 - here's another passive attack traffic
29:22 - analysis
29:23 - Bob sends messages to Alice in the
29:26 - normal operation
29:27 - in this attack while Bob is sending
29:30 - messages to Alice Darth a malicious user
29:33 - somehow intercepts those messages
29:36 - may not be able to read the contents of
29:39 - those messages
29:40 - but can make some conclusions based upon
29:43 - observing the messages being sent
29:46 - the time when they're sent
29:48 - the frequency that they're saying for
29:50 - example
29:51 - so by analyzing the messages being sent
29:54 - by analyzing the traffic on the network
29:57 - the attacker the malicious user may be
29:59 - able to make some conclusions which they
30:01 - couldn't make without analyzing them
30:08 - an example
30:10 - uh
30:15 - uh Bob
30:16 - is let's say
30:20 - Bob is
30:23 - a
30:25 - a known terrorist
30:27 - okay law enforcement agency uh know that
30:31 - Bob is some terrorist there's some done
30:33 - some illegal things in the past
30:37 - and they're monitoring what Bob is
30:39 - sending
30:41 - and it turns out they also know Alice is
30:45 - at some potential terrorist
30:49 - and
30:51 - malicious user Darth here is the law
30:53 - enforcement agency that monitors how
30:55 - these two entities are communicating and
30:58 - by monitoring as to how many messages
31:01 - are sent at what time of day uh from
31:04 - what
31:05 - computer addresses they're being sent
31:07 - from they may be able to make
31:09 - observations about what potentially may
31:11 - happen
31:12 - for example they see that over a period
31:15 - of one month there are no messages
31:18 - and then on one day there's a lot of
31:20 - messages from Bob to Alice and they make
31:22 - the conclusion or they infer that that
31:25 - may mean that some attack is about to
31:28 - occur
31:30 - so by analyzing the frequency of
31:33 - communication
31:35 - the malicious user can make some
31:36 - observations
31:38 - even without seeing the contents of the
31:41 - messages
31:42 - even if they cannot see what's inside
31:44 - the messages just seeing that there are
31:46 - messages sent can be an attack
31:52 - and
31:54 - I think most of you heard about Snowden
31:57 - and the NSA and and what's happening
32:00 - with uh the the Revelation the NSA are
32:04 - monitoring many U.S citizens well it was
32:07 - revealed that they are monitoring not
32:10 - the actual phone calls not the contents
32:12 - of what people are saying on the phones
32:14 - but just monitoring who you're calling
32:17 - and when you're calling
32:19 - so that would be considered a traffic
32:21 - analysis attack to be able to make
32:23 - observations not based on the contents
32:26 - of the message but just off on
32:29 - who the messages are going to how often
32:32 - when they're going to people is some
32:34 - form of an attack
32:37 - it's still a passive attack
32:40 - with no attack
32:42 - Bob sends messages to Alice
32:45 - with the attack from Bob and Alice's
32:47 - perspective nothing changes
32:49 - so the system resources have not been
32:52 - modified
32:59 - going back to the first one how do we
33:01 - protect protect
33:03 - what's a security mechanism to stop the
33:05 - release of message contacts
33:12 - what's a mechanism we can use
33:15 - I send
33:16 - the exam to the secretary across the
33:19 - Wi-Fi network and SRT
33:22 - I wanted to print it
33:24 - how can I stop someone from receiving
33:27 - the message and reading the exam
33:30 - contents
33:33 - what's a mechanism we can use I'm sure
33:35 - you know of of something you've probably
33:37 - used it in many cases
33:44 - anyone
33:46 - I could encrypt the message encrypt the
33:50 - file
33:52 - what I do is I take the exam file I
33:55 - encrypt it using some software
33:59 - and I don't send the original exam file
34:02 - I send the encrypted form of that exam
34:04 - across the network
34:07 - from Bob to Alice
34:09 - it's encrypted
34:11 - and what happens even though the
34:13 - malicious user may receive that message
34:17 - the encrypt encryption should be done
34:20 - such that without having some special
34:23 - secret a key or a password
34:26 - if you receive the message you cannot
34:27 - get the original contents back
34:30 - okay so even though the malicious user
34:32 - receives the message they cannot see the
34:35 - contents of the message
34:36 - so encryption is a common mechanism used
34:39 - to prevent
34:42 - such attacks
34:44 - and in a lot of this course we'll talk
34:46 - about well what is encryption and and
34:48 - what are the algorithms that can be used
34:49 - for encryption
34:52 - what about traffic analysis how do I
34:56 - stop some malicious user from analyzing
34:59 - the patterns of communications between
35:01 - Bob and Alice
35:04 - does encryption help
35:08 - encryption doesn't help in this case
35:10 - because
35:12 - Darth is not cat does not care
35:14 - necessarily about the contents of the
35:16 - messages even if they are encrypted he
35:19 - still sees that Bob is sending messages
35:21 - to Alice still knows the time of day how
35:24 - often
35:25 - how could I
35:27 - stop that attack
35:28 - stop someone from analyzing the traffic
35:33 - any ideas
35:40 - send send some flight messages
35:43 - change the pattern of communication so
35:45 - let's say normally Bob sends uh
35:50 - was is going to send three messages to
35:52 - Alice so I won every minute
35:55 - then
35:56 - and from that pattern of one every
35:58 - minute Darth makes some observations
36:00 - then what Bob can do is change the
36:03 - pattern in which they communicate by
36:04 - sending some fake messages in there
36:07 - uh standing at different times at
36:09 - different frequencies so by changing the
36:11 - pattern you may be able to hide your
36:14 - communication patterns
36:16 - not easy though okay and changing your
36:19 - patterns or Communications is a
36:21 - inconvenience as well
36:22 - it introduce introduces some overhead
36:26 - and some inconvenience for the users
36:33 - keep going another attack an active
36:35 - attack masquerade masquerade means
36:37 - pretend to be someone else
36:41 - Bob and Alice normal users
36:45 - Alice is the the finance officer for the
36:49 - organization Bob is the the CEO or the
36:52 - director of sit
36:55 - and normally what happens is that the
36:57 - end of the financial year Bob sends a
36:59 - message to Alice saying potentially
37:02 - about increasing or decreasing the
37:04 - salary of employees
37:07 - and when Alice receives a message from
37:09 - Bob she changes the the salaries in in
37:12 - the database
37:13 - well what happens in this case is Darth
37:16 - a malicious user pretends to be Bob
37:19 - sends Alice an email saying from Bob
37:23 - I am Bob please increase the salary of
37:26 - Steve by 10 000 baht okay so or in
37:30 - salary of Darth in this case
37:33 - one user pretends to be another user to
37:37 - do something malicious
37:42 - how do we stop that
37:46 - foreign
37:47 - how how can we stop some malicious user
37:51 - from sending messages pretended
37:54 - pretending to be from ball
38:02 - use some kind of digital signature
38:05 - signature
38:08 - all right correct and let's step back oh
38:12 - first we cannot stop Darth from sending
38:15 - messages to Alice normally okay so we
38:19 - cannot stop Darth from sending him to
38:20 - Alice what we want to do is make sure
38:22 - Alice can detect if it's from Bob
38:25 - or if it's from someone pretending to be
38:27 - for involved
38:29 - that's what we need to do the receiver
38:31 - needs to be able to verify the message
38:34 - that they receive who did it really come
38:37 - from
38:38 - and the concept is called Authentication
38:41 - the receiver wants to be able to
38:42 - authenticate who is the original source
38:46 - and one mechanism is using digital
38:48 - signatures will see other mechanisms in
38:51 - this course
38:56 - and that's related to this one of these
38:58 - famous comic on the internet nobody
39:00 - knows you're a dog because
39:02 - when someone posts something on the
39:05 - Internet or you visit a website you
39:08 - don't know what's at the other endpoint
39:10 - in the internet there's no inbuilt
39:13 - mechanism for authenticating users
39:16 - so it's very hard to trust what you
39:18 - receive on the internet
39:25 - a replay attack
39:28 - here
39:31 - Bob the director
39:34 - or the the boss
39:36 - normally no attack normally sends a
39:39 - message to Alice
39:41 - please increase the salary of Da by ten
39:44 - thousand baht
39:46 - okay that's the typical message because
39:48 - Darth did some good work
39:50 - celery rise
39:52 - one month later
39:55 - no when that normal message was sent
39:58 - Darth intercepted and took a copy of
40:00 - that message
40:01 - it was from Bob it had Bob's signature
40:05 - one month later Darth replays that same
40:08 - message sends it to Alice Alice receives
40:11 - a message from Bob signed by Bob
40:14 - increased the salary of Darth by ten
40:16 - thousand baht
40:18 - so now she's received two messages
40:19 - saying increase the salary of Darth by
40:23 - ten thousand Baht so it's now up twenty
40:25 - thousand Baht okay the first month and
40:27 - the second month so in this case the
40:30 - malicious user intercepts a message a
40:33 - normal message
40:34 - and at some time later resends or
40:37 - replays that message to achieve some
40:39 - outcome
40:41 - so a replay attack
40:44 - how do we stop that
40:51 - same message yes replay exact same
40:53 - message not modified
40:56 - and we need to keep track of time
41:00 - okay in the first message that Bob sends
41:05 - he dates this the message saying this is
41:07 - on the the 12th of November 2013. please
41:11 - increase the the salary by ten thousand
41:14 - if Darth replays that exact same message
41:18 - one month later
41:20 - Alice receives it in December but it
41:22 - says it's in November hopefully Alice is
41:25 - smart enough to realize that okay this
41:26 - something's gone wrong here let's take
41:28 - some action okay and of course this is
41:31 - just a simplistic example in
41:34 - Network protocols we can automate those
41:36 - techniques use timestamps
41:41 - still
41:42 - not easy
41:46 - modification attack Darth intercepts a
41:50 - message Bob sends a message
41:52 - please decrease the salary of Darth by
41:55 - 10 000 Baht that's what Bob sends to
41:58 - Alice but Darth intercepts changes
42:01 - decrease to increase
42:05 - and folds on the Alice Alice receives
42:08 - the message and it has increased the
42:11 - salary so here the malicious user
42:13 - modifies the message along the way
42:16 - replay
42:18 - the message is not modified it's an
42:20 - exact copy of a previous one
42:26 - another one which is different than the
42:28 - others denial of service attack
42:31 - we have some web server
42:35 - uh
42:36 - Bob normally accesses that web server to
42:39 - get his job done okay he needs access to
42:41 - the web server every day
42:43 - if you can't access the server then he
42:46 - cannot do his normal job and we start to
42:48 - lose money in the company what Darth
42:50 - does is sends many
42:52 - packets a lot of data to the server to
42:54 - overload the server
42:56 - once the server is overloaded no one
42:58 - else can access the server
43:00 - including Bob and Bob has been denied
43:03 - service
43:05 - the normal user is denied access to the
43:08 - the server in this case so a denial of
43:10 - service attack
43:14 - there are the six main classifications
43:16 - of attacks there are some other
43:17 - exceptions but these are common ones
43:19 - that we'll see
43:22 - the first two we were
43:24 - classified as passive attacks and the
43:28 - last four active attacks
43:30 - active because the best way to think is
43:33 - if there was no attack
43:36 - versus if there is an attack
43:39 - from the normal user's perspective does
43:41 - something change
43:43 - if yes then it's an active attack if no
43:46 - passive so in this case if there's no
43:49 - attack then Bob sends nothing
43:52 - and the server receives nothing but with
43:54 - an attack
43:55 - Darth sends something and importantly
43:57 - the server receives something so
43:59 - something's changed from the service
44:01 - perspective when the attack has taken
44:03 - place so we consider that active
44:07 - similar here
44:09 - modification attack Bob sends message a
44:14 - in the normal operation and Alice would
44:18 - receive message a in the normal
44:20 - operation but with an attack Bob sends
44:23 - message a Darth changes that to message
44:26 - B
44:27 - and Alice receives message B
44:29 - so from the perspective of Alice and Bob
44:32 - something has changed
44:34 - because with no attack Alice receives
44:37 - message a
44:39 - but with an attack Alice receives
44:41 - message B it's changed it's an active
44:43 - attack
44:45 - and you can look at replay and
44:48 - masquerade and see that they are active
44:50 - attacks as well
45:02 - so passive attacks don't modify the
45:06 - system resources
45:08 - the messages sent the contents of those
45:10 - messages
45:12 - an active attack does
45:17 - passive attacks are relatively hard to
45:19 - detect because they don't modify
45:21 - anything it's hard to detect that
45:23 - they're taking place
45:25 - but they're relatively easy to prevent
45:29 - by using encryption and time stamps we
45:32 - can see compared to the others easy to
45:34 - prevent those attacks
45:37 - active attacks
45:39 - harder to prevent it's harder to stop
45:42 - someone from sending the message you
45:44 - can't in fact normally
45:47 - but easy to detect
45:50 - even though I cannot stop
45:53 - I cannot stop Darth sending messages to
45:55 - Alice
45:57 - I can detect it using security
45:59 - mechanisms I can usually detect
46:01 - something's happening here using some of
46:04 - the security mechanisms we'll go through
46:12 - so six types of attacks and
46:14 - classification into active and passive
46:19 - so we said there are three aspects of
46:21 - security
46:22 - services are tax mechanisms we've gone
46:25 - through attacks let's look at services
46:35 - and different people have tried to to
46:37 - list the main Services needed in network
46:40 - security
46:42 - and
46:44 - itu is one organization ietf is another
46:47 - they've given definitions of what is a
46:49 - security service
46:50 - but let's go straight to a list which is
46:52 - one of the most common lists there are
46:54 - some variations some people divide it
46:56 - into six Services some
46:59 - more or less or use different names but
47:02 - you'll see that these are common
47:03 - Security Services in most Network
47:05 - systems
47:11 - authentication so these are the things
47:13 - that we want to achieve in a network
47:16 - to prevent the attacks
47:21 - Authentication
47:23 - make sure that the communicating entity
47:25 - is the one that it claims to be
47:30 - someone sends you a message
47:33 - you want to authenticate that message
47:35 - you want to make sure that the message
47:37 - you receive came from the person who
47:39 - claims to be the sender
47:42 - this was uh
47:45 - going back
47:48 - the Masquerade attack for example
47:51 - what we want is a server such that
47:54 - Alice when she receives a message can
47:57 - verify that that message came from Bob
48:00 - or not
48:02 - so that if we had such a service
48:05 - if she receives from Darth saying it's
48:07 - from Bob she can verify and see ah
48:10 - there's something wrong here this
48:12 - message didn't come from Bob
48:14 - so authentication is this service to
48:17 - make sure that we can verify where did
48:19 - the message really come from
48:22 - such that a masquerade attack cannot be
48:24 - performed
48:26 - or can can be detected at least
48:34 - sometimes we split authentication into
48:37 - peer entity authentication and data
48:39 - origin an example
48:42 - peer entities like making sure the
48:44 - person that send it is the the right
48:46 - person
48:49 - data origin Authentication
48:53 - uh
48:55 - make sure the data
48:58 - comes from
49:00 - a valid origin a valid entity
49:04 - not necessarily carrying which one in
49:07 - that case
49:13 - Access Control
49:15 - another service it's common that we want
49:18 - to control who can access particular
49:21 - resources on our Network in our computer
49:23 - system
49:25 - okay I sit has a as a network
49:29 - covering the the campus here we want to
49:32 - control who from outside in the internet
49:34 - can access the servers can access the
49:37 - Wi-Fi can access the data in our Network
49:42 - so we need some Access Control
49:44 - mechanisms
49:45 - so the service is to prevent
49:47 - unauthorized use of some resource
49:50 - software resource Hardware resource data
49:53 - or some Communications Network
49:57 - an example of an access control
49:59 - mechanism is a firewall
50:03 - so sit has a firewall that sits between
50:06 - our intern our internal Network and the
50:09 - rest of the world
50:11 - and it has the role of stopping what
50:13 - data comes into our Network and also
50:15 - what goes out so it controls the access
50:18 - to resources inside our Network
50:21 - so that's another desired service in
50:24 - security systems
50:28 - data confidentiality this is one of the
50:31 - more obvious ones protect data from
50:33 - unauthorized disclosure okay I want to
50:35 - keep my data secret confidential
50:39 - it's a common service is I have my
50:42 - exam
50:44 - I don't want others to read it who are
50:46 - not authorized to read it so the service
50:48 - of providing confidentiality of the data
50:56 - data integrity
50:58 - make sure that the data received is the
51:00 - same as what was sent
51:04 - so
51:05 - I send a message
51:08 - the receiver should be able to confirm
51:10 - that what's received is exactly the same
51:12 - as what was sent it hasn't been modified
51:15 - along the way
51:17 - so if a modification attack is
51:20 - successful then it means we don't have
51:23 - the data Integrity service
51:27 - maintain the Integrity of the data being
51:29 - communicated
51:32 - availability skip five availability
51:36 - make sure the system is accessible for
51:39 - the normal users
51:40 - so think of the denial of service attack
51:42 - one of the last attacks there the
51:45 - service which we usually want is to make
51:47 - sure the servers the data the resources
51:50 - in general are available to the users
51:54 - as they're intended
51:59 - and the one we skipped
52:01 - actually let's go back to the other five
52:03 - some of the others first we'll come back
52:05 - to five in a moment availability
52:08 - is the desired service
52:11 - an example of an attack on that service
52:14 - is denial of service
52:16 - okay
52:18 - if
52:19 - Darth can perform a denial of service
52:22 - attack then we haven't got the
52:24 - availability service
52:27 - modification attack is an attack on data
52:30 - integrity
52:31 - because if a modification attack is
52:34 - successful
52:36 - then the data received is not the same
52:37 - as what was sent
52:41 - masquerade is an attack on
52:43 - authentication we should not be able to
52:45 - pretend to be someone else if we can we
52:49 - don't have authentication Service
52:51 - and confidentiality is an attack on
52:53 - releasing the message contents
52:56 - oh sorry another way around releasing
52:59 - the message contents is an attack on
53:01 - confidentiality
53:06 - what about non-repudiation
53:12 - non-repudiation to repudiate something
53:14 - is to deny something
53:17 - so the non-repudiation service
53:20 - is we need to have the ability such that
53:23 - entities cannot deny something happening
53:27 - and the most common things is denying
53:30 - that we've sent or received a message
53:33 - let's say
53:35 - a oh
53:37 - Bob
53:38 - sends a message to Alice
53:41 - Alice receives that
53:44 - later Bob denies that he sent the
53:47 - message I didn't send it
53:49 - that can be a problem in some cases
53:52 - non-repudiation is about making sure
53:54 - that Bob can't do that making sure that
53:57 - if Bob sends a message to Alice
53:59 - then later Bob will not be able to deny
54:02 - that he sent that message
54:05 - if he could that could cause problems
54:08 - and same from the other end point
54:11 - Alice should not be able to deny that
54:13 - she received the message
54:15 - that's the feature of non-repudiation
54:17 - the sender cannot deny that they sent
54:19 - the message the receiver cannot deny
54:21 - that they receive the message
54:26 - we need that in a number of services
54:28 - financial transactions are important
54:30 - okay when we're buying something
54:34 - we'd like to be able to have some
54:36 - confirmation some proof
54:38 - that we've sent the money
54:41 - proof that we sent and proof that they
54:44 - received it such that no one can come
54:46 - back later and say I didn't receive it
54:48 - when they actually did
54:50 - so non-repudiation is providing that
54:53 - service so that no one can deny
54:55 - something that happened
55:01 - these are the main
55:04 - things that we look for in securing
55:06 - computer networks
55:07 - we don't necessarily want all of them
55:09 - depending upon the goal of our network
55:11 - but we often want one or more of these
55:14 - services
55:17 - for my sending the exam from me to the
55:20 - secretary to print I want
55:22 - confidentiality
55:24 - I want to make sure that no one can
55:26 - intercept and read the exam
55:28 - and maybe I also want data Integrity I
55:32 - want to make sure that no one can
55:33 - intercept and modify somehow the exam
55:38 - and potentially we also want
55:40 - authentication that is the secretary
55:43 - wants to be able to be sure that the
55:44 - exam she just received came from me not
55:47 - from some student pretending to be me
55:49 - okay
55:50 - the other services are not so important
55:52 - for that application but for other
55:54 - applications we may choose different
55:56 - services
55:58 - so these are the things that we want in
56:00 - our computer network
56:03 - yeah
56:04 - to implement the services we use
56:08 - security mechanisms
56:10 - we've already mentioned some we've
56:12 - mentioned for confidentiality use
56:14 - encryption
56:15 - maybe use some time stamps some digital
56:18 - signatures these are mechanisms
56:23 - the techniques
56:25 - to prevent detect and recover from
56:28 - attacks
56:31 - there's no single technique that does
56:33 - everything okay so we usually combine
56:35 - there are multiple mechanisms and we use
56:38 - one or more to achieve some service
56:43 - and the most common mechanisms are built
56:46 - around crypto cryptography cryptographic
56:48 - techniques
56:49 - and that's what a lot of this course is
56:51 - about talking about what are these
56:53 - cryptographic techniques
56:54 - some examples are listed here but we'll
56:57 - go through these in the course
56:58 - encryption or incitement digital
57:01 - signatures
57:02 - Excel Access Control firewalls
57:08 - authentication exchange so there are
57:10 - protocols for authenticating users
57:13 - for hiding from traffic analysis traffic
57:16 - padding sending extra messages
57:20 - notarization
57:23 - have some third-party
57:26 - verify that two entities just
57:28 - communicated to avoid non-repudiation
57:31 - so we'll look at some of these
57:32 - techniques in this course
57:37 - and another view of those techniques
57:40 - the services listed and some techniques
57:43 - and sorry some mechanisms
57:46 - and which Services those mechanisms are
57:49 - used to implement
57:54 - for example
57:56 - to provide confidentiality we normally
57:58 - use incipherment or we'll call it
58:00 - encryption
58:03 - to
58:06 - avoid non or to provide non-repudiation
58:11 - we use digital signatures and data
58:14 - Integrity techniques
58:17 - what we're going to do in this course is
58:19 - look at encryption
58:21 - and then a fair bit of time looking at
58:24 - digital signatures data Integrity
58:26 - Authentication
58:28 - some of the others we'll touch upon
58:35 - and that's our introduction to security
58:39 - the next topic and the next several
58:42 - topics are about encryption how do we
58:44 - encrypt data
58:46 - and we'll look at it from different
58:47 - perspectives starting with some very
58:49 - very simple encryption techniques simple
58:51 - insecure but demonstrate the concepts
58:59 - that's finishes for today
59:02 - Thursday
59:03 - next topic classical encryption
59:05 - techniques
59:06 - between now and Thursday
59:09 - I'll assume that you've
59:11 - browse the website you have any
59:13 - questions you ask me Thursday or or
59:15 - before next week and then we'll continue
59:18 - with how do we do encryption
59:27 - foreign
59:32 - go into block ciphers and and uh and the
59:36 - main example of the Box hyper death
59:38 - we'll just recap on what we know
59:41 - or some parts what we know from
59:43 - classical Cycles we went through several
59:46 - example very simple ciphers starting
59:49 - from 2000 years old the Caesar Cipher
59:52 - and they were transposition techniques
59:55 - we Sorry Wrong Way Around substitution
59:57 - techniques we substitute one element
59:59 - with another
60:00 - we use English characters
60:03 - so we were substituting a h with a J for
60:06 - example and then there were
60:08 - transposition techniques where we take
60:10 - the plain text
60:12 - set of characters and rearrange them
60:14 - transpose you change the position of the
60:17 - characters
60:19 - uh
60:22 - did we finish actually I think we've got
60:26 - we can go back to that one last
60:29 - transposition techniques we got to
60:33 - rail fence
60:36 - uh we still have one more thing to do
60:39 - we got through some examples of the two
60:42 - transposition techniques just two basic
60:43 - ones Trend rail fence where we write the
60:46 - plain text in
60:49 - a set of rows
60:51 - writing
60:53 - the first letter in the first row the
60:55 - second letter in the second row and so
60:56 - on so that the key impact was the depth
60:59 - the number of rows and then we finished
61:01 - with an example of Rose columns
61:03 - transposition where again we write our
61:06 - plain text in rows
61:09 - and then the key determines which
61:11 - columns we read first to get our plain
61:13 - text sorry to get our ciphertext so we
61:16 - we write security and cryptography in a
61:18 - set of rows
61:19 - and then the key is a set of integers
61:22 - that says the second column is read
61:25 - first because the one is in the second
61:27 - position of the key
61:30 - the fifth column is red second
61:33 - and we read column by column
61:36 - to get our cycle Tech so we had an
61:38 - example of that
61:43 - both of them
61:45 - simply rearrange the letters
61:51 - this tries to this example tries to
61:53 - illustrate the case that when we
61:56 - repeatedly apply the same algorithm
62:00 - we can improve the security
62:03 - of their resulting ciphertext
62:06 - and this simple case uses a
62:11 - Rose column Cipher
62:14 - so we're not do it on the I've got the
62:17 - answers here we start with some plain
62:19 - text attack postponed until 2 am XYZ the
62:23 - XYZ we're going to use to to pad out so
62:27 - we've got a a correct number of
62:29 - characters because our key four three
62:32 - one two five six seven
62:34 - tells us that we're going to have to
62:35 - write this plain text in seven columns
62:40 - and with seven columns I think the if
62:43 - you count the characters how many are
62:44 - there anyone count for me how many
62:48 - characters
62:50 - 28 I think I hope so
62:53 - how many characters in the plain text
62:59 - yeah 28 characters we'll see here I've
63:02 - got numbers okay 28 characters
63:05 - seven columns so we write
63:08 - our plain text in four rows 28 divided
63:11 - by seven
63:13 - and then
63:15 - so attack posts so the first seven
63:19 - letters and in the first row the next
63:21 - seven letters in the second row and so
63:23 - on and then to get the ciphertext we
63:26 - read
63:27 - the third column
63:29 - because the one in the key is in the
63:31 - third position read the third column so
63:34 - down and that produces ttna so if you
63:38 - look at the third column you'll see TT
63:40 - and a under each other and then we read
63:43 - the fourth column because that's where
63:47 - the 2 is in the fourth position
63:49 - and we'd get this ciphertext so you can
63:52 - try that in your own time we're not
63:53 - going through it now
63:57 - what we show and we'll do it again in a
63:59 - moment but what we show here is let's
64:02 - not worry about the individual letters
64:03 - let's look at the ordering and see how
64:05 - the transposition rearranges the let
64:07 - these letters and see the patterns
64:10 - let's say we number these 28 letters
64:12 - from 1 through to 28. and I can't fit it
64:15 - all on one line so I've wrapped across
64:17 - two lines so a t t a c
64:22 - k p and so on that's how we interpret so
64:26 - one two three
64:28 - Twenty Eight that is character 28 in our
64:32 - plaintiffs so just number them one
64:33 - through to 28.
64:36 - and we get these
64:39 - then we apply the rows columns
64:42 - transposition Cipher and we get this
64:45 - ciphertext but remember transposition
64:47 - transposition we just rearrange
64:51 - so if we follow where do the letters end
64:53 - up
64:55 - where does the first letter a end up in
64:58 - the ciphertext that's what this set of
65:02 - numbers tell us
65:04 - the first letter 0 1 here
65:07 - ends up in which position it's
65:11 - here the 13th letter
65:16 - I think it's this a here if you follow
65:18 - through the cipher you'll see that this
65:21 - a ends up here or if we look at it
65:23 - numbers the first letter in the plain
65:26 - text ends up in the 13th position in the
65:29 - ciphertext after that uh rearrangement
65:32 - after the transposition the third letter
65:35 - in the plain text which was a T ends up
65:39 - in the first position of the Cyber text
65:42 - actually moves to here when we apply
65:44 - this out so that's all these numbers are
65:46 - showing us how did we rearrange them
65:49 - because we want to do some analysis and
65:51 - see how good this rearrangement this
65:52 - transposition is so if we start with
65:55 - some plain text after applying our
65:57 - Cipher we get this
65:59 - arrangement of the letters
66:02 - now look at these numbers
66:05 - on your on the screen on the print out
66:07 - in front of you look at this set of
66:08 - numbers
66:09 - what pattern do you see
66:13 - look at this set of numbers
66:16 - describe the pattern you see if you just
66:19 - tell me if you see any pattern if so
66:21 - what is the pattern
66:26 - just look at the numbers yep
66:33 - foreign
66:36 - I will check that later okay all right
66:38 - thank you someone made a point that
66:40 - maybe there's a mistake in one of these
66:42 - uh and you
66:44 - good chance of being correct
66:46 - maybe a mistake in one of these but
66:49 - we'll survive with this mistake until
66:51 - later okay I don't know uh but I think
66:55 - it won't make any difference maybe once
66:57 - one letter has shifted but I'll check
66:59 - that later
67:04 - looking at the coming back to these
67:06 - numbers this is let's say it's all
67:08 - correct this is the output
67:11 - uh after the first encryption
67:14 - what pattern do you see in these numbers
67:21 - just looking at the numbers
67:22 - does anyone see a pattern
67:25 - [Music]
67:26 - so look at those 28 numbers do you see
67:29 - some ordering of the numbers that make
67:31 - some uh
67:33 - some pattern make some sense was it all
67:35 - random
67:38 - these numbers random
67:43 - what's the pattern we see
67:45 - what do you see there
67:51 - plus seven okay
67:53 - look at the numbers easy
67:56 - I don't ask complex questions okay look
67:59 - at these numbers
68:02 - 3 10 17 24. there's a difference of
68:05 - seven
68:06 - between these four numbers just
68:09 - incrementing
68:10 - all right 24 to 4. oh that's strange
68:13 - that's not a difference of seven but
68:15 - four 11 18 25 a difference of seven
68:19 - okay
68:21 - if I ask you does this sequence of
68:24 - numbers look random yes or no hands up
68:27 - for Yes do they look random
68:31 - so they look random this sequence of
68:34 - numbers
68:35 - if I tell you here's a random sequence 3
68:37 - 4 3 10 17 24. I think you'll start to
68:42 - see a pattern a random sequence should
68:45 - not have any pattern
68:46 - there should be no structure in a random
68:48 - sequence this has some structure that we
68:51 - can obviously see 4 11 18 25 a
68:55 - difference of seven
68:56 - 2 9 16 23 a difference of seven so every
69:00 - four digits every four numbers have a
69:02 - difference of seven
69:05 - why
69:06 - or the way that the rows column Works in
69:09 - that we have seven columns
69:12 - every four numbers because we have 28
69:14 - characters seven columns groups of four
69:18 - the point is
69:21 - when we apply a cipher we take some
69:23 - structured plain text we'd like to get
69:26 - random looking ciphertext
69:30 - ciphertext should be hard to work out
69:32 - what the plaintext is so it should be we
69:35 - say simply random looking this is
69:37 - obviously not random we can easily see
69:40 - the pattern
69:43 - so it's not very secure this this Cipher
69:45 - on its own
69:48 - but
69:49 - if we take this ciphertext
69:52 - and apply the exact same Cipher with the
69:56 - same key again on the ciphertext
70:00 - we and you can check we get this
70:03 - cytotext as an output
70:05 - and instead of looking at letters we
70:07 - look at where do the original plain text
70:10 - letters end up
70:12 - after the first transposition the first
70:14 - letter ended up in the 13th position
70:18 - but after the second application of our
70:20 - Cipher the first letter ends up in
70:24 - wherever the 20-something position
70:27 - here
70:28 - similar
70:30 - the third letter of plain text the T
70:32 - after the first time we applied the
70:35 - cipher went to the first position of the
70:37 - output but then we apply the cipher
70:39 - again on this and that third letter
70:42 - moves to here the 13th position
70:46 - now look at these numbers sequence of
70:48 - numbers 17 9
70:51 - 5. 27 24.
70:54 - tell me the pattern you see
70:57 - so in the in the previous sequence we
70:59 - saw this difference of seven
71:00 - what do you see in the next sequence try
71:03 - and find it
71:05 - [Music]
71:09 - look at those numbers at the bottom of
71:11 - the slide and see what pattern you see
71:14 - between the numbers if any
71:19 - these ones
71:27 - of course I think you'll quickly see our
71:29 - difference of seven has disappeared we
71:31 - don't have a difference of seven between
71:33 - uh the neighbor numbers 17 down to nine
71:39 - some difference of eight down to five
71:42 - minus four but up to 27 plus 12. okay
71:46 - there's uh
71:50 - some differences in how they differ
71:52 - between those numbers
71:56 - anyone else anyone want to guess
72:06 - not so obvious to see any pattern in
72:08 - these numbers
72:10 - to me and I hopefully to most of you
72:12 - that are
72:13 - following
72:14 - these sequence of numbers
72:17 - look more random than this sequence of
72:19 - numbers
72:20 - this one we can see a pattern plus seven
72:23 - plus seven plus seven
72:25 - and then plus seven seven and this one
72:28 - there's no similar pattern no obvious
72:31 - pattern at least
72:33 - now going down and then up
72:36 - the point is that the second output of
72:40 - applying a cipher is more random
72:44 - if we can say that then the first
72:46 - application
72:48 - and less of an obvious pattern in this
72:52 - case using the same Cipher and leads to
72:55 - a more secure ciphertext
72:59 - what we'd like is a cycle text which is
73:01 - completely random that is there's no
73:05 - pattern that can be observed by the uh
73:09 - by the attacker
73:11 - the point is here that by applying the
73:14 - transposition twice we've improved the
73:16 - security of the output cytotext
73:19 - and it's a concept that's applied in
73:22 - most ciphers today
73:25 - take some simple operation rearrange
73:28 - these letters
73:30 - and repeat it multiple times
73:33 - so after the first application maybe the
73:35 - output is not very secure but after you
73:37 - apply it again it's better and again and
73:39 - again and again it keeps mixing things
73:41 - up and the more mixed up it is that the
73:44 - harder it is for the attacker to take
73:46 - the resulting ciphertext and work back
73:49 - and find the original plain text
73:51 - so this is an important concept that we
73:53 - use in in real Cycles apply simple
73:56 - operations multiple times
74:04 - and similar with substitutions not just
74:06 - in transpositions
74:10 - so we've covered the two main techniques
74:12 - substitution transposition
74:14 - last one
74:16 - what's the message for those who haven't
74:19 - sat in my lecture before what's the
74:21 - plain text
74:23 - give you one or two minutes
74:26 - here's a message you receive
74:30 - it has a hidden message what is it
74:39 - and then we'll come back and explain
74:40 - what we're doing in this one there's a
74:42 - hidden message in there
74:46 - it's in fact a real message but there's
74:49 - um secret hidden
74:54 - it's some real message between two
74:57 - professors or two two people at a
74:59 - university someone sending a greeting to
75:01 - George
75:08 - you don't want to have an attempt
75:15 - what the first word
75:18 - [Music]
75:20 - second word okay he has election Nights
75:23 - from last year
75:27 - he's got it anyone else
75:29 - what's the message
75:32 - we'll come back give you a chance let's
75:34 - explain what we're doing this is another
75:37 - uh
75:38 - a different thing than what we're going
75:40 - to cover in this course steganography
75:43 - this is the process of hiding a real
75:46 - message
75:48 - inside a fake but meaningful message
75:51 - so what we do is I send some message
75:54 - that makes sense not encrypted
75:59 - so I send this letter to someone
76:02 - but inside that
76:05 - real message that inside that message
76:07 - that makes sense I hide another secret
76:10 - message one that I don't want other
76:12 - people to know this is the process of
76:14 - steganography
76:15 - and this assumes that the person who
76:19 - receives this message knows the method
76:22 - I'm using to hide the secret
76:25 - and there are different examples of how
76:27 - to hide a secret in some other message
76:29 - in the old days
76:31 - for example a Written Letter
76:34 - you write a letter and you put small
76:37 - pinholes above the characters that make
76:40 - up your secret message and if you hold
76:42 - it up with a light or you hold it so you
76:44 - can see the pinholes then you identify
76:46 - the characters and read off the secret
76:48 - message or some form of invisible ink
76:51 - where you write a normal
76:53 - message
76:55 - but something's marked such that there's
76:57 - some secret identified in there as well
77:01 - we'll see in the next slide our secret
77:04 - message in a moment today more practical
77:08 - you send an image or a video across a
77:12 - network
77:13 - say a jpeg
77:15 - and you modify that jpeg a little bit
77:19 - such that some bits in the binary
77:22 - representation of that that image
77:25 - make up some hidden message
77:29 - the output is that from the user's
77:31 - perspective it doesn't look like the
77:33 - image is any different from some
77:34 - original image some bits are changed
77:37 - meaning maybe some pixels change in
77:39 - color
77:40 - but from the human eye it's hard to
77:42 - detect but in fact there's some coded
77:44 - message included and similar can be done
77:47 - with videos
77:49 - this is not encryption
77:51 - but we can use it for a similar purpose
77:53 - of hiding
77:55 - a secret
77:56 - and communicating between two entities
78:00 - and the advantage of this compared to
78:02 - encryption is it doesn't look like
78:04 - you're hiding anything
78:06 - I send someone a normal message from an
78:09 - attackers or an observer's perspective
78:12 - they cannot doesn't look like I'm
78:14 - communicating a secret to the other
78:16 - person and that can be a benefit
78:17 - sometimes for example to avoid traffic
78:20 - analysis the problem with steganography
78:23 - is that once the attacker knows how I'm
78:25 - hiding the message message they can find
78:29 - everything that I've sent in those
78:30 - messages
78:32 - and it can be inefficient in that I need
78:34 - to send a large amount of information to
78:36 - get a short message from A to B
78:38 - we're not going to cover steganography
78:40 - in this course but it's an interesting
78:42 - thing for you to do outside of the
78:44 - course I will finish anyone else have
78:47 - the
78:48 - message what's the secret
79:04 - well George knows the procedure in this
79:06 - case George knows when he receives this
79:09 - message
79:10 - from an attacker's perspective it just
79:12 - looks like a normal message or email or
79:16 - letter someone would send someone in a
79:17 - university but George the receiver knows
79:20 - the method is to read the last word of
79:23 - each line
79:24 - try
79:26 - the last word of each line
79:35 - your package ready Friday 21st room
79:39 - three please destroy this immediately
79:42 - chaos yours okay so here's the secret
79:45 - message included inside this fake
79:49 - message
79:50 - of course it
79:52 - once you know that method read the last
79:55 - word of each line it's very easy to see
79:58 - and it's very easy for the attacker to
80:00 - find it but if you don't know the method
80:02 - it's hard to find what that secret is
80:11 - but again steganography will not cover
80:14 - that anymore in this course
80:21 - what's the best Cipher we've got so far
80:26 - which Cipher is the most secure
80:32 - I've gone through Caesar mono alphabetic
80:35 - uh
80:37 - play fair visionaire one-time pad rail
80:40 - fence Rose columns
80:42 - they'll all be in your quiz online and
80:45 - all be in your quiz next week in the
80:48 - lecture which one's the best
80:51 - of those seven one time pad is the best
80:58 - in terms of security okay
81:01 - so it's the most secure
81:04 - and in fact it's the most secure Cipher
81:06 - that we know of
81:09 - we saw the one-time pad we applied the
81:11 - Caesar Cipher changing the assuming we
81:14 - had a random
81:16 - key as long as the input plain text
81:19 - thank you
81:23 - can implement the one-time pad in
81:26 - practice as an exclusive ore let's move
81:29 - from English to computing
81:33 - and instead of A to Z we'll look at
81:35 - zeros and ones binary
81:40 - I don't think you have this one sorry
81:41 - but uh let's you don't need it it's just
81:44 - an example no need to copy it down let's
81:47 - just have a quick look
81:49 - and just demonstrate that okay I want to
81:52 - send a message
81:53 - so this is actually an example of a
81:55 - Brute Force attack but that's not so
81:57 - important I have a message hello I want
82:00 - to send that to someone
82:01 - well we represent that in binary so how
82:04 - do we do that we can use an ASCII
82:06 - conversion
82:07 - where we do a look up and see the upper
82:10 - the letter uppercase H converts to some
82:12 - seven bit value and I've done that and
82:15 - it turns out that uppercase H
82:17 - corresponds to
82:21 - one zero zero one zero zero zero you
82:25 - look up in an ASCII table and it'll tell
82:27 - you that
82:28 - and similar to the other so we can treat
82:30 - any messages binary and we'll do so when
82:32 - we look at our cyclists from now on
82:34 - zeros and ones
82:37 - and a second example okay let's say we
82:40 - have
82:42 - the message Steve is what we want to
82:44 - send then here's the binary form of of
82:47 - the four letters and of course e is
82:49 - repeated at the end so in decimal from
82:52 - the ASCII table and the binary form so
82:56 - Steve can be represented as a seven by
83:00 - five 35 bit
83:03 - sine text value
83:06 - so now from now on we're going to deal
83:09 - in binary for our Cyprus not with
83:11 - English characters
83:15 - one
83:17 - operation that we you can use to encrypt
83:20 - and it becomes in fact a one-time pad
83:23 - is to take our plain text
83:27 - and apply the exclusive or operation
83:31 - take the plain text input
83:34 - and exclusive or with a key
83:38 - and it's the same as the one-time ad
83:40 - that we saw where we take our plain text
83:43 - as a set of letters
83:45 - and apply the Caesar Cipher where our
83:47 - key is as long as the plain text if our
83:50 - key is as long as the plain text and
83:53 - random
83:54 - just applying the exclusive or between
83:56 - the plain text and the
83:58 - uh
84:00 - key and I I would not show the example
84:02 - yet
84:03 - the plain text and a key is the same
84:05 - length
84:06 - as the plain text
84:07 - will give us ciphertext which is
84:10 - perfectly secure
84:12 - there'll be no way for the attacker to
84:15 - take that cycle text and determine the
84:16 - correct key
84:18 - nor uh
84:20 - do a Brute Force attack
84:23 - so exclusive war is a way to implement a
84:25 - one-time hat
84:27 - hey remember exclusive or
84:30 - zero X or zero
84:33 - zero xor one One X or zero One X or one
84:40 - when they are different one is the
84:43 - answer when they are the same zero as
84:45 - the answer zero X or zero is zero for
84:48 - example
84:51 - we're going to see xor used and some
84:54 - other operations used when we look at
84:55 - our real sites so just
84:58 - a warning let's treat everything as
85:00 - binary from now on
85:02 - [Music]
85:09 - so let's look at some real or a real
85:12 - Cipher and the first generally the
85:15 - concepts of block ciphers
85:18 - the principles
85:27 - so we're going to talk about block
85:29 - ciphers but first we need to Define what
85:31 - do we mean by block Cipher well there's
85:33 - an alternative a stream Cipher and we
85:35 - distinguish sometimes between stream
85:37 - ciphers and block ciphers and the main
85:40 - difference
85:43 - is on how much
85:45 - of plain text that they operate on at a
85:48 - time
85:49 - stream Cipher typically operates and
85:52 - encrypts one bit or more commonly one
85:54 - byte at a time
85:56 - block Cipher usually encrypts say
85:58 - 64-bits or 128 bits at a time see some
86:02 - examples
86:06 - we will not cover much of stream ciphers
86:08 - yet we'll see an example later uh
86:12 - stream ciphers normally use some
86:16 - plane take some plain taxes input and
86:18 - generate some random sequence of bits
86:22 - and apply the xor operation exclusive
86:24 - ore between that random sequence of bits
86:27 - and the plaintiffs and get our type
86:29 - so stream ciphers usually use exclusive
86:31 - ore and the complexity of stream ciphers
86:34 - is in generating a random sequence of
86:36 - bits so we'll return to that later when
86:38 - we look at random numbers
86:41 - how do we generate them
86:45 - the one-time pad is an example of a
86:47 - stream cycle
86:49 - assuming we have a random
86:52 - a long random sequence of bits that's
86:54 - our key simply xor with the plain text
86:59 - and you get your side effects
87:02 - block ciphers
87:04 - operate on some block of plain text at a
87:07 - time
87:09 - typically 64 or 128 bits in most ciphers
87:12 - will see we take the input bits and
87:17 - apply some encryption algorithm and
87:19 - we'll see that usually much more complex
87:21 - than just an exclusive ore and we get
87:24 - our site protects as output and of
87:26 - course that encryption algorithm takes a
87:28 - key as input
87:31 - we're going to focus on block cycles for
87:33 - now we'll return to stream Cycles later
87:35 - and discuss the differences
87:40 - so some characteristics of block Cycles
87:45 - in fact this is a characteristic of any
87:47 - site but
87:48 - we need
87:50 - uh reversible mappings what a cipher
87:53 - does is take some plain text and
87:55 - produces ciphertext so it Maps
87:59 - the plain text bits to a set of
88:01 - ciphertext bits perform some mapping
88:04 - these bits become these other bits
88:09 - reversible means that
88:11 - we must be able to successfully decrypt
88:15 - if we have some mapping as defined in
88:18 - this table where we have two bits of
88:21 - plain text at a time a block size of two
88:24 - bits
88:25 - and we Define the mapping that if we
88:27 - encrypt 0 0 we get one one as an output
88:30 - if we encrypt 0 1 we get one zero one
88:33 - zero maps to zero zero one one mapped to
88:36 - zero one
88:38 - then this mapping is reversible
88:42 - because
88:43 - if we take our ciphertext we can get the
88:47 - original plain text back
88:49 - if my plane ciphertext if my ciphertext
88:52 - is one one then I know for sure the
88:54 - plain text is zero zero
88:56 - because we have a one-to-one mapping
89:00 - the table on the right here
89:03 - is an example of an irreversible mapping
89:07 - if I encrypt plain text 0 0 I get one
89:10 - one zero one maps to one zero one zero
89:14 - to zero one one one zero one now I
89:17 - received some psychotics I received the
89:19 - psychotex zero one
89:22 - what's the plain text
89:25 - if I receive 0 1
89:28 - I need to decrypt and get the original
89:30 - plain text back but I cannot do it
89:33 - because
89:35 - if I have cytotec zero one I don't know
89:38 - whether the original plain text was 1 0
89:40 - or 1 1. so it's not a reversible mapping
89:43 - we cannot do the opposite mapping so we
89:47 - must have a one-to-one mapping between
89:49 - plain text and scientists the plane text
89:52 - cannot map to
89:53 - a different plane tanks cannot map to
89:56 - the same value cycle text that's the
89:59 - principle
90:02 - otherwise we cannot decrypt
90:07 - [Music]
90:11 - so let's look at
90:14 - let's look at a cipher and and then talk
90:16 - about a block ideal block Simon
90:23 - uh you have the one I'm about to show
90:27 - it's an example of an ideal block cycle
90:36 - you have this in your lecture notes
90:41 - we'll start with a very simple block
90:43 - Cipher that will treat it as a mapping
90:46 - and it Maps
90:48 - two bits of plaintiffs
90:51 - to a set of possible ciphertext values
90:57 - so if you find this one I'll show just
91:00 - the mapping and explain it
91:02 - on
91:06 - screen
91:08 - let's say our block size is two bits
91:11 - that means what we do when we we have a
91:14 - plain text message to send let's assume
91:16 - we have a cipher that encrypts two bits
91:19 - at a time
91:20 - okay we take two bits of plain text
91:22 - encrypt and get two bits of ciphertext
91:25 - then we take the next two bits of plain
91:27 - text and get two more bits of ciphert X
91:29 - and we keep doing so
91:30 - that's our encryption approach
91:34 - so
91:35 - we can think of the cipher
91:38 - as mapping two bits of plain text to two
91:42 - bits of
91:43 - ciphertext
91:46 - what this diagram and it's from the
91:48 - printout you have it shows
91:51 - all possible mappings
91:54 - for every two bits of plain text given
91:57 - 24 different keys
92:01 - so we have
92:05 - a two-bit Block in this example
92:13 - that means our plain text and our
92:15 - ciphertext will be two bits long
92:18 - if our plain text is longer we separate
92:20 - it into blocks so what this diagram is
92:22 - showing is that if we just look at the
92:24 - Top If my plain text is zero zero
92:29 - and if I use key one
92:32 - then the ciphertext will be zero zero as
92:35 - an output
92:36 - that's one mapping
92:39 - using the same key key one
92:42 - plaintext01
92:44 - output is zero one
92:47 - and one zero goes to one zero one one
92:50 - one one there's one mapping using a
92:53 - particular key
92:57 - so how many possible plain text values
93:00 - do we have we see there are
93:04 - 2 to the power of two
93:08 - possible input Playtex
93:14 - this is I think on your
93:17 - handout
93:19 - with a 2-bit block Cipher
93:22 - there's a set of plain text values we
93:24 - can have is four to the power of two and
93:26 - we've listed them in the first column
93:34 - and our Cipher Maps plain text bits to
93:38 - ciphertext bits
93:40 - how many possible mappings do we have
93:42 - and the answers in front of you it's on
93:44 - the screen
93:45 - or there are 24 possible mappings all
93:48 - listed here so the first 12 are on the
93:50 - top and the second twelve underneath
93:52 - that there are 24 possible mappings
93:56 - from those four plain text values just
94:00 - reversible mappings to ciphertens values
94:05 - y24
94:07 - what's the equation
94:08 - how do we get 24
94:18 - 4 factorial
94:24 - there are four factorials 24 in this
94:28 - case we have
94:30 - four inputs
94:33 - we can rearrange
94:36 - them in how many ways
94:40 - well
94:42 - you can check and see that this this all
94:46 - 24 possible rearrangements of that
94:53 - four by three by two by one our 24 or 4
94:57 - factorial arrangements or combinations
94:59 - so if you look at the first column
95:03 - at the top you'll see that's a one
95:06 - arrangement of those four values
95:09 - and
95:13 - so this is one of the arrangements and
95:16 - with K2 that's a different Arrangement
95:18 - and so on so we have a total of 24
95:21 - possible
95:24 - different Arrangements of those four
95:27 - values
95:29 - and they are our possible mappings from
95:32 - plain text disciples
95:33 - [Music]
95:35 - what arrangement do we use to encrypt
95:40 - well that is the key that is the key for
95:42 - our Cipher
95:45 - so
95:46 - this is a definition or this is an
95:49 - example of a ideal block Cipher so how
95:52 - it works is we take some plain text as
95:55 - input
95:57 - and we
96:04 - encrypt
96:08 - and producer ciphertex as output
96:13 - where the input
96:15 - the encryption is also a key
96:22 - that's our normal operation
96:24 - for example
96:27 - plain text zero one
96:31 - the encryption is defined by this all of
96:33 - this data here
96:35 - plain text zero one okay we find the
96:38 - plaintext value and then the key
96:40 - determines which mapping do we use of
96:42 - those 24 possible mappings
96:47 - so if for example we have a key of
96:51 - if we choose a key of
96:54 - k-17 for example key 17.
97:01 - mapping 17 in our list
97:04 - what's the ciphertext well
97:06 - plain text01
97:09 - plain text 01 the third row
97:12 - key 17 mapping number 17 the output will
97:16 - be zero zero as a cycle text
97:23 - plain text sorry
97:25 - line text is zero one let's try that
97:27 - again plain text is the second row zero
97:29 - one
97:33 - key seventeen
97:35 - output 0 1.
97:50 - p17 plain text zero one output 0 1 for
97:54 - this case
97:56 - so here's a cipher
97:58 - what we do is we take all possible plain
98:01 - text values and Define all possible
98:04 - mappings or all possible Arrangements of
98:07 - those plain text values
98:10 - and the key determines which arrangement
98:11 - we use to determine the ciphertext
98:14 - this is what we call an ideal block
98:16 - cycle we can Implement any block cycle
98:19 - alignments
98:26 - how big is the key
98:33 - what is the key length in this case
98:51 - what is the key I said key k-17
98:56 - well the key tells us which mapping to
98:59 - use so k17 means use mapping number 17.
99:05 - so what the the source does the sauce
99:08 - that has the plain text they have this
99:10 - table
99:12 - these tables
99:13 - they Define the mappings all possible
99:16 - mappings
99:17 - and they take their plain text and they
99:19 - choose the secret key and they get their
99:22 - ciphertext they send the ciphertext to
99:24 - the recipient the recipient must have
99:26 - the same set of tables to decrypt
99:31 - but in fact the key can tell us the
99:33 - mapping to use
99:38 - k17
99:39 - we could write as those eight bits
99:45 - which I did these eight bits
99:53 - k17 we can say is
99:55 - one one
99:58 - zero one
100:00 - zero zero
100:03 - one zero
100:07 - how that works is that
100:11 - we read this so it's meaning like a zero
100:15 - the plain text zero zero maps to this
100:18 - value
100:19 - plain text zero one maps to the second
100:21 - value plain text one zero perhaps to the
100:24 - third and plane takes one one match to
100:26 - the fourth value so we order the
100:28 - plaintiffs
100:29 - so if this is the key
100:32 - what we do now is that the
100:35 - the source
100:37 - chooses the key
100:40 - that is this specific mapping they
100:42 - encrypt and they get 0 1 as the output
100:46 - they send zero one to the
100:49 - recipient
100:51 - if the recipient also knows this key
100:55 - then what do they get as the output well
100:57 - they receive ciphertech 0 1 which is in
101:00 - the second position of the key and
101:03 - therefore the plain text is 0 1 of
101:08 - output because
101:11 - it's write it
101:24 - in blue we have our site and text
101:28 - red
101:31 - the plain text
101:39 - the key is the blue value
101:42 - and this is just the values in order
101:45 - so we always write these in order so if
101:47 - recipient receives zero one from the key
101:51 - they know that 0 1 goes to 0 1.
101:54 - if the recipient received one zero as
101:58 - the site and tax they'd know the plain
102:00 - text is one one
102:02 - if they receive one one they know the
102:03 - plaintext is zero zero
102:05 - so the the key in this case defines the
102:08 - mapping
102:10 - this is an ideal block Cipher and that
102:12 - we can Implement any block Cipher just
102:15 - as this mapping from plain text values
102:18 - to a cyber text
102:25 - the problem with using this is that it's
102:27 - impractical to to implement
102:33 - return to our slides for a moment
102:38 - an ideal block Cipher we take an end bit
102:40 - input
102:42 - and bit plain text
102:44 - and that can map to 2 to the power of n
102:48 - possible States
102:50 - so we had our two bit plain text we got
102:52 - four possible plain text inputs to the
102:55 - power of two
102:58 - and we do some substitution
103:00 - we take the input and replace it with
103:03 - one of the other possible values or one
103:05 - other one possible value so there are
103:08 - two to the power of n possible outputs
103:09 - which map back to a two-bit input a
103:13 - two-bit output infused
103:18 - this allows for all possible
103:21 - combinations of plain text to cycle text
103:24 - mappings
103:26 - and another example
103:29 - the one that was we saw another example
103:32 - is shown on this slide but maybe better
103:35 - to show just as these tables
103:38 - just one other example
103:40 - where here's a mapping from
103:44 - on the left-hand table the encryption
103:46 - table these 16 plain text values can map
103:50 - to these 16 cycle text values that's one
103:54 - possible mapping
103:57 - in this Cipher
103:59 - how many mappings are there in total
104:03 - how many possible
104:05 - we saw in our previous example we had 24
104:07 - possible magnets
104:09 - 24
104:11 - possible Keys here I've shown just one
104:13 - mapping for a different Cipher how many
104:16 - possible in total
104:19 - foreign
104:33 - mappings if you want to find the answer
104:36 - maybe start writing them all out
104:39 - it'll take you a long time though
104:46 - that just focus on the left table the
104:48 - other one's the decryption
104:54 - foreign
104:57 - let's go back to our sorry wrong
104:59 - direction our first example we had a
105:02 - two-bit block
105:05 - two bits of plain text
105:07 - gives us four possible plain tax values
105:12 - zero zero zero one one zero one one
105:15 - and how many Arrangements of those four
105:18 - values can we have
105:20 - how many different ways can we arrange
105:22 - them
105:24 - all of these 24 values earlier the
105:27 - possible Arrangements there are 24 or 4
105:29 - factorial Arrangements combinations
105:34 - so with this was a two-bit block Cipher
105:36 - what about with our other Cipher
105:41 - how many possible mappings
105:49 - 16 factorial why
105:55 - is a 4-bit block Cipher plain text four
105:59 - bits
106:00 - how many possible plain text values are
106:03 - there 16 now listed here into the power
106:06 - of four sixteen possible plain texts I
106:09 - challenge you to go and write those 16
106:12 - values or if you want to do it in
106:14 - decimal rather than binary write the
106:16 - value 0 to 15 and then try an
106:19 - arrangement arrange them in different
106:22 - orders see how many different
106:24 - Arrangements you can make
106:26 - and it'll be 16 factorial
106:29 - which is what
106:33 - they're not calculator
106:41 - how many Arrangements
106:48 - we have a four bit block Cipher
106:51 - so 2 to the power of four possible plain
106:54 - text
106:55 - 16 factorial possible Arrangements
107:01 - again
107:03 - 16 factorial
107:05 - two
107:08 - 20 trillion
107:10 - different arrangements okay so you go
107:12 - and write them all all down
107:14 - and that's how many possible
107:15 - Arrangements we have in that case
107:23 - maybe that should be the penalty for
107:25 - those uh who cannot answer the quiz
107:29 - in the next lecture anyone who gets less
107:31 - than 50 has to write more down
107:35 - sounds okay
107:38 - doesn't sound that hard to write 20
107:41 - trillion different Arrangements
107:43 - okay all right
107:46 - so
107:48 - so the point is that this is just one of
107:51 - those 20 trillion different Arrangements
107:53 - we have many others
107:55 - which Arrangement do we use to encrypt
107:58 - this is one
107:59 - well
108:00 - the one that we use is defined by the
108:03 - key
108:04 - how long is our key in this case
108:07 - thank you
108:08 - what is the key
108:14 - and go back to our
108:17 - easier example where we have just 24
108:19 - Arrangements we have a 2-bit block
108:21 - Cipher 24 possible Arrangements the key
108:24 - that determines the arrangement we're
108:27 - using for example key 17
108:29 - was
108:31 - tells us the order in which our plain
108:33 - text values map to our ciphertext so we
108:36 - could write the key key 17
108:39 - as
108:41 - in fact
108:43 - one one zero one zero zero one zero
108:46 - eight bits
108:48 - and the way that we interpret the key is
108:50 - is that since we know it's a two-bit
108:52 - block Cipher we know that okay the first
108:54 - two bits in the key map to zero zero
109:00 - the second two bits mapped to zero one
109:03 - the Third
109:04 - two one zero and the last two to one one
109:06 - so in that case we could represent the
109:08 - key as eight bits
109:16 - how big is our key with our other side
109:26 - in this case
109:31 - well the key would be all of these
109:33 - values
109:35 - what we would send or what we could
109:37 - store as the key is one one zero so
109:41 - every four bits identify the site text
109:43 - for the in-order plain text so 4 by 16
109:47 - or 64 bits would be the length of the
109:50 - key in this case
109:52 - because if we know the key
109:55 - if we know these 64 bits
109:59 - and store them in order when I receive
110:03 - ciphertext1010 from the key I can
110:06 - determine well that's
110:09 - in the what is it in the night position
110:13 - and therefore it maps to decimal 9 or
110:15 - binary one zero zero one
110:18 - so we could use a key in that way
110:23 - so the key in this case in general is
110:28 - how big
110:31 - this is with four bits we have four by
110:35 - sixteen
110:39 - with a four bit block Cipher four by
110:41 - sixteen or an end bit block Cipher
110:45 - and
110:46 - by 2 to the power of n
110:49 - four by sixteen four by two to the power
110:51 - four is the key length in this case
110:59 - in in bits in this case so what yeah
111:08 - the key tells us the mapping let's go
111:10 - back to our simple simpler one
111:13 - of the wrong way 24 mappings
111:17 - okay and we let's keep it simple but
111:20 - which mapping in which order do we do
111:22 - these mappings we need to Define that
111:24 - yeah the key length
111:29 - uh yes correct what did I say
111:33 - oh sorry n n times 2 to the power of n
111:37 - correct so in our case 64 4 by 2 to the
111:40 - power of four
111:42 - so
111:44 - in this case we have a block size of Two
111:47 - Bits n equals to two
111:49 - the key is 2 times 2 to the power of two
111:53 - or eight bits
111:57 - that is these eight bits is key 17.
112:03 - if I want to encrypt using a different
112:05 - mapping
112:06 - for example key 13 then I could set the
112:09 - key to be zero one one zero zero zero
112:12 - one one
112:13 - and when
112:15 - the receiver receives the ciphertext 0 0
112:18 - if they know this key from the key they
112:21 - determine that the plain text is one
112:23 - zero
112:28 - but that leads to our problem with this
112:30 - ideal block Cipher
112:38 - let's say we have a large block size n
112:41 - for example is 64. 64 bits so we've seen
112:46 - an example of a block of two bits a
112:48 - block of four bits let's say we have a
112:51 - block of 64 bits which we'll see is
112:53 - typical
112:55 - then the key length is 64 times 2 to the
112:58 - power of 64 bits
113:01 - which is too large
113:03 - because it's too large to be able to
113:05 - distribute to someone it's too hard to
113:07 - to write down and to to record
113:11 - and it becomes very hard to implement
113:13 - when you have such large values so using
113:17 - a large block size is it is not possible
113:19 - if we use such a cycle
113:23 - using a small block size therefore makes
113:25 - the key more manageable but it turns out
113:28 - the smaller the block
113:30 - if we have a typically large plain text
113:32 - we have more blocks and it becomes much
113:35 - easier to perform an attack
113:37 - by using the static statistical
113:39 - characteristics
113:41 - of the plain text
113:44 - so we have a problem we can't use a
113:47 - small block size because it makes a tax
113:49 - easier based on statistical analysis but
113:52 - we can't use a large block size because
113:54 - it makes the key too large
113:56 - so we need some alternative approach
114:04 - so an ideal block Cipher allows all
114:07 - possible mappings real block ciphers
114:09 - today do not use this approach they only
114:11 - allow a select number of mappings
114:14 - but they make the trade-off of being
114:16 - able to use a large block
114:18 - by keeping the key small
114:21 - and there are different ways of doing it
114:26 - and there was one there's one common
114:28 - approach it was devised by a guy called
114:31 - feistall
114:33 - the approach in general is to
114:36 - use Simple ciphers
114:39 - smaller blocks
114:41 - but apply them multiple times
114:45 - and in some structured manner to make
114:47 - the output cryptographically strong
114:51 - so to
114:53 - use two or more simple ciphers but
114:55 - repeat one after another and and that's
114:58 - the concept we started to introduce with
115:00 - our classical cybers by repeating the
115:02 - same simple Cipher we can get more
115:04 - strength in the output of psychotics
115:09 - and
115:11 - what did we have we had
115:14 - in our ideal side and let's write it
115:16 - down
115:20 - with our ideal Cipher we said with an
115:23 - Ambit lock
115:37 - and that block size
115:44 - how many Transformations or mappings do
115:46 - we have
115:50 - foreign
115:52 - we had
115:54 - 2 to the power of n
115:56 - factorial
115:58 - Transformations or mappings
116:04 - which is good we want as many as
116:06 - possible
116:09 - but the key
116:11 - length
116:15 - [Music]
116:17 - becomes n times 2 to the power of n
116:21 - which is bad because if n is large
116:24 - that key length becomes too large
116:28 - if
116:33 - n is
116:35 - n is 10 for example
116:37 - and this is a Thousand Times Ten this
116:40 - ten thousand bits is the key length
116:43 - La it's bad because of the management
116:45 - problem for the key Distributing the key
116:48 - whether
116:49 - firestore block Cipher it makes a
116:52 - trade-off
116:55 - we have an n-bit block size
117:01 - and the mappings is not determined by
117:04 - the block size but by the key length
117:08 - we also Define a k bit key so we set the
117:11 - key length
117:12 - and the number of mappings depends upon
117:14 - the key length
117:16 - so
117:23 - key length is K bits
117:27 - the number of mappings is 2 to the power
117:29 - of K
117:38 - which
117:40 - is this trade-off of we drew we reduce
117:43 - the number of mappings
117:44 - yes
117:48 - let's say n and K are the same length
117:51 - with an ideal block cycle we have 2 to
117:53 - the power of n factorial mappings
117:56 - which is much much more than just 2 to
117:58 - the power of n if n and K are the same
118:01 - so we reduce the number of mappings
118:04 - but we have a manageable key length K
118:07 - bits so if we Define K as 64 say 64 bits
118:11 - we have 2 to the power of 64 possible
118:14 - mappings
118:17 - uh but we have a manageable key length
118:21 - if we have a 64-bit block
118:24 - with the ideal Cipher the key length is
118:26 - 2 to the power of 64 a two to the yeah 2
118:30 - to the power of 64 times 64 which is
118:33 - just too large
118:34 - he is just 64 bits
118:38 - so fossil structure allows us a much
118:40 - more manageable size in the key length
118:43 - but by repeating the simple encryption
118:46 - operations provides almost equal
118:49 - security is what an ideal blocks are and
118:51 - sufficient security
119:02 - the picture on the next slide shows the
119:04 - structure actually the next one
119:07 - we will not go into much detail because
119:09 - we'll see it in deaths
119:11 - it repeats the general design of a cycle
119:14 - it's not a specific Cipher it's a
119:16 - general design and it breaks
119:20 - the cipher into a set of rounds a round
119:24 - is the same each time the same algorithm
119:26 - we just repeat this algorithm multiple
119:28 - times of multiple rounds
119:30 - and it involves splitting the plain text
119:33 - into left and right halves
119:36 - so if we have a 64-bit plain text we
119:38 - break it into two 32-bit portions
119:42 - swapping the halves we'll see some
119:44 - different operations like swapping the
119:45 - halves using an exclusive ore and
119:48 - applying some function and he
119:50 - generalized that some function we'll see
119:52 - some specific instances
119:54 - and a key is an input and then repeating
119:57 - and repeat and repeat
120:00 - as as per how many rounds we have
120:02 - so we'll come back to that when we see
120:04 - deaths because it's an example of a
120:06 - faster structure
120:08 - or the concepts
120:13 - there's an alternate alternation between
120:16 - substitutions and transpositions so
120:19 - coming back to our classical ciphers
120:21 - we're using these basic operations
120:24 - replacing and rearranging substitution
120:27 - is replacing transposition is
120:30 - rearranging
120:32 - or permutations
120:34 - and we'll see shortly that we talk about
120:36 - s operations and P P for permutation is
120:39 - commonly used
120:41 - he operations
120:46 - and applies the concepts of diffusion
120:48 - and confusion
120:49 - anyone understand confusion
120:52 - I think everyone's experts
120:54 - there's many people who are confused
120:57 - we will look and come back to these
120:58 - concepts of what do we mean by diffusion
121:01 - and confusion with respect to cyphers
121:05 - but let's
121:07 - move on from some of the abstract
121:08 - Concepts and and look at some specific
121:10 - examples
121:14 - we'll come back to the next lecture
121:22 - let's go to Des and then we'll see a few
121:24 - examples before going through the
121:25 - details
121:27 - the data encryption standard
121:29 - it was probably it would maybe still is
121:32 - the it was the most widely used Cipher
121:34 - in the world
121:36 - symmetric block cycle
121:40 - it was developed about 40 years ago
121:44 - very designed by people at uh IBM and
121:49 - NSA apparently had input and it was
121:51 - standardized by what was then called
121:55 - NBS but is now called the National
121:57 - Institute of Standards and Technology
121:59 - East so U.S standards organization
122:01 - created the standard for deaths and the
122:04 - idea was that when this organization
122:06 - creates the standard all the US
122:08 - government
122:09 - departments must use that for encryption
122:13 - and because the US government is using
122:15 - it for encryption many companies use it
122:17 - for encryption
122:18 - and not just in the US outside and it's
122:21 - spread across the world in the deaths
122:23 - become effectively a worldwide standard
122:25 - for encryption
122:27 - a symmetric block Cipher it operates on
122:31 - a 64-bit input block so to encrypt we
122:34 - take 64 bits of plain text
122:37 - and we produce 64-bits output
122:40 - so we produce 64-bit cytotext
122:43 - what if my plain text is larger than 64
122:46 - bits
122:47 - well we break our plain text into blocks
122:50 - of 64 bits in length encrypt them one at
122:53 - a time
122:54 - and then we've got different ways of
122:56 - combining those output cycle texts
122:58 - together and the next topic will talk
123:00 - about how to combine modes of operation
123:03 - so yes just looks at 64 bits at a time
123:09 - it has a 64-bit key but we'll see when
123:13 - we look at the details that
123:15 - only 56 bits of that of those 64 were
123:18 - actually used in the encryption the
123:20 - other eight bits were used as a parity
123:22 - check so parity check to check if
123:24 - there's any errors so from a security
123:26 - perspective
123:28 - it's effectively a 56-bit key
123:34 - how long is our Brute Force take against
123:35 - 64 bits a 56 bits
123:39 - Brute Force
123:41 - worst case we need to approve force of 2
123:44 - to the power of 56 operations if you go
123:47 - back to the last set of lecture notes
123:49 - what days
123:52 - hours seconds if we have Ultra fast
123:54 - machines
123:56 - from a key length perspective it's
123:58 - insecure it's too short nowadays but in
124:01 - the 70s 80s and 90s it was okay
124:06 - but now it's it's not a
124:10 - the principles used in desks have been
124:12 - applied in other Cycles so to overcome
124:15 - the short key length there were
124:17 - improvements like triple deaths
124:19 - and they
124:21 - are still in use today so the principles
124:24 - used are used will see in other Cycles
124:26 - what we're going to do
124:28 - and we'll not go through the details
124:30 - today but in the next lecture we're
124:31 - going to go through the details of how
124:33 - deaths works but because it's quite
124:36 - complex what I'll use is take a cut down
124:38 - version
124:40 - it works on 64 bits
124:43 - I cannot write 64 bits on the board and
124:45 - do an operation or it takes too long so
124:48 - some people have developed one for
124:49 - teaching called simplified debt which
124:51 - will cut things down to smaller smaller
124:54 - sizes eight bits 10 bits and we'll go
124:57 - through one example to show the
124:58 - operations
124:59 - it's not a real site it's just for
125:01 - teaching
125:03 - but we'll go through that next week
125:10 - so we'll go through simplified deaths as
125:13 - an example and then we'll look at well
125:15 - real deaths
125:17 - and look at the details and some of the
125:20 - design issues and and possible attacks
125:22 - on real deaths
125:24 - finished today I want to move on and
125:26 - look at some software that we can use
125:28 - for encryption I know we've talked about
125:31 - a lot of
125:32 - Concepts today so let's look at some
125:34 - practice
125:46 - first
125:48 - let's remind you what your uh
125:51 - homework tasks are
125:53 - you have a quiz to do before the lecture
125:56 - next week
125:58 - okay you must do the quiz
126:00 - and there's a new exercise that I've
126:02 - added but the exercise is not marked or
126:04 - anything and you should only do the
126:05 - exercise if you understand from the quiz
126:08 - okay I've just added it today
126:11 - uh don't it's you don't have to do it it
126:14 - may just help you with understanding
126:16 - some of the the more advanced concepts
126:18 - but before I talk about the exercise
126:23 - um I've mentioned before and I also
126:25 - appointed on the website there are some
126:28 - that's the wrong one
126:30 - I've written up some examples using
126:33 - classical ciphers and attacking classic
126:35 - classical sites so in this web page and
126:39 - you've got to print out described how to
126:41 - do a brute force and more importantly
126:43 - how to do frequency analysis attacks on
126:46 - very simple classical sites
126:48 - I recommend you read that and understand
126:50 - that because if you can understand how
126:52 - the attacks can be performed when you
126:55 - understand the limitations and and
126:57 - approaches for your attacks on real
126:59 - science
127:00 - and there's another one about the
127:02 - one-time Pat
127:04 - so I recommend reading that and looking
127:06 - at the example to see well why is the
127:09 - one-time pad Unbreakable
127:11 - why is it provide perfect security
127:14 - if you don't understand then then have a
127:16 - read through this
127:17 - and it talks about with an example
127:19 - why even a Brute Force attack on the
127:22 - one-time pad will be unsuccessful
127:25 - so read them
127:28 - coming back exercise one only do this if
127:32 - you
127:33 - are okay with all the other Concepts so
127:35 - far because it can be time consuming
127:37 - quite simple here's some ciphertext find
127:40 - the plain text or key
127:42 - okay I give you I think there's four
127:45 - different ciphertext values
127:49 - for example this
127:50 - I give you a hint all right Caesar cycle
127:53 - was used find the key find the plaintiff
127:55 - plain text entry some are easy
127:59 - the first one should be easy second one
128:02 - here's some ciphertext rail fence was
128:04 - used find the key then you'll find them
128:08 - Playtex
128:10 - and I think that one's easy most people
128:13 - could do that three
128:17 - some cyber techs Rose columns was used
128:21 - this takes a little bit of thinking and
128:22 - a bit of trial and error to break that
128:24 - one okay maybe you could write some
128:26 - software to automate it but you can do
128:27 - it on paper as well that one those who
128:30 - can do it you can do it with software
128:32 - fine but what I don't suggest is find
128:34 - some Website that solves it for you no
128:37 - point but I I if you want to write
128:40 - software or use a spreadsheet or some
128:42 - some scripting language to automate the
128:45 - tasks for sure
128:47 - recommended and especially for the last
128:49 - one
128:51 - psychotex 4
128:53 - monoalphabetic Cipher was used using
128:55 - English only so the key length is 26
128:59 - characters
129:00 - effectively randomly erased
129:03 - here's the ciphert X find the plaintiffs
129:08 - I think most people can do one and two
129:10 - quite easily three and four take a bit
129:12 - more time and thinking
129:16 - but if you can do them then you're
129:18 - probably fully understand both how the
129:20 - ciphers work and how the attacks work
129:28 - let's move to real ciphers for the last
129:30 - five five minutes or so
129:38 - another
129:41 - print out provided you and on the
129:43 - website here is
129:45 - well let's use some software to encrypt
129:48 - once we go through a desk let's encrypt
129:51 - something with deaths
129:53 - so you can get different software
129:55 - implementations of many of the ciphers
129:57 - that we we talk about
129:59 - one common open source library and
130:02 - application for encryption is open SSL
130:06 - and we'll use it for demos and examples
130:08 - throughout the course openssl it
130:11 - provides a command line interface it's
130:13 - usually aren't available for most Linux
130:16 - and Mac operating systems already
130:19 - installed
130:23 - I'll just quickly show some examples so
130:26 - this web page describes how to use it
130:28 - let's look at a few examples of how to
130:31 - use them
130:46 - foreign
130:51 - some data
130:57 - first let's encrypt some
130:59 - plain text
131:00 - and I'll take a plain text file with
131:02 - them
131:04 - okay so I've created a plain text file
131:06 - which is just some text message hello
131:08 - this is our super secret message keep it
131:10 - secret
131:11 - uh let's encrypt it using openssl and
131:15 - yet that's uh we'll choose a cipher
131:18 - go
131:22 - different ways of doing it
131:25 - first let's find some details about our
131:28 - plain text
131:29 - sorry
131:33 - how long is a plain text I have a piece
131:35 - of software word count it tells me it's
131:37 - 72 characters long okay
131:40 - let's start with that it's 72 characters
131:42 - in fact it's 72 bytes one character is
131:46 - one bite
131:47 - if we look at how plain text.txt file
131:50 - it's 72 bytes so we're going to encrypt
131:52 - a 72 byte plain text
131:58 - I
132:00 - I
132:01 - have to
132:04 - have a look at the details
132:06 - in maybe hexadecimal
132:09 - everything I'm doing is on the website
132:11 - on those instructions so I would not
132:13 - explain too much just do the steps
132:18 - so that's our message so this is the
132:21 - ASCII this is the hexadecimal remember
132:22 - our ASCII Maps back to binary
132:25 - or we can represent that binary as
132:27 - hexadecimal then so
132:30 - h-e-l-l-o
132:32 - dot space t is in fact represented as
132:35 - these hexadecimal digits
132:38 - or even nicer binary
132:45 - yeah hard to see do it again
132:50 - okay of course I don't expect you to
132:52 - read this but this is h e l l o
132:58 - uh when we get o dot space t
133:02 - so just a binary representation so when
133:05 - we're applying our real cycle we're
133:07 - actually operating on the binary
133:09 - form
133:11 - when we apply Des AES and others we take
133:14 - the binary values and apply our Cipher
133:16 - on those binary vectors
133:19 - but of course hard hard to uh
133:22 - show binary values sometimes
133:25 - so let's
133:28 - encrypt and I'll encrypt using deaths
133:31 - but we need a key
133:33 - okay I need to encrypt with some key and
133:37 - with this we have a
133:39 - 64-bit key although we only use 56 we
133:42 - need to specify a 64-bit key and turns
133:45 - out with the software we can use we can
133:47 - use hexadecimal I don't have to I can
133:50 - write in binary 64 bits or 16
133:53 - hexadecimal digits
133:56 - anyone suggest a key for me
133:59 - 64-bit value or 16 hexadecimal digits
134:05 - well it's best to choose a random key
134:07 - remember a key should be such that it
134:09 - should be secret so I shouldn't tell you
134:11 - but it should be such that no one can
134:13 - guess it
134:15 - if I choose a key of all zeros
134:18 - well an attacker could just try all
134:20 - zeros and it's not very sensible to
134:23 - choose that way so ideally your key
134:26 - should be generated randomly you should
134:28 - not choose it you should let a computer
134:30 - generate it for you
134:31 - so it generates some random number
134:34 - different ways to Generate random
134:36 - numbers
134:42 - program we're going to use to encrypt is
134:44 - called openssl
134:46 - and it includes many different
134:48 - encryption operations
134:50 - including random number generation
134:53 - it has an operation to generate a random
134:55 - number
134:56 - eight hexadecimal
134:58 - eight
135:01 - bytes in hexadecimal that's what we're
135:05 - saying here
135:06 - here it is so what I did is generated an
135:09 - eight byte random number
135:11 - and output in hexadecimal and that's the
135:14 - value sorry we
135:16 - lose a little bit that's
135:20 - sure you can see them
135:23 - again
135:27 - we haven't explained it yet but
135:31 - it turns out to encrypt we need a key
135:33 - and some initial value and I'm going to
135:35 - use some at random initial value but
135:37 - let's encrypt
135:39 - and we use openssl
135:41 - we say we want to encrypt with a
135:44 - symmetric Cipher what Cipher deaths
135:48 - and in the next topic we'll see that ECB
135:50 - means something electronic code book but
135:52 - not so important yet but Des ECB encrypt
135:56 - minus E
135:57 - input
135:59 - plain text file
136:01 - output
136:03 - ciphertext
136:07 - Dot
136:10 - ENC whatever extension I like is not so
136:13 - important
136:15 - import key
136:18 - my random value
136:21 - so use my key to encrypt and we need
136:24 - some initial value
136:28 - let's not explain that yet but we'll
136:30 - need that
136:31 - and I'll choose this other random number
136:33 - for an initial value
136:36 - and sometimes our Cipher when our text
136:40 - is not of a particular length or pad
136:42 - had the plain text I don't want to do
136:45 - any padding here
136:46 - it's not necessary so I'm going to
136:48 - specify an option to not pad
136:51 - no pad and done we encrypted
136:55 - okay so you don't have to remember all
136:57 - these operations so you're just giving
136:59 - you an example
137:01 - and
137:05 - we have our ciphertext which is 72 bytes
137:09 - long that's our cyber text let's look at
137:11 - the ciphertext now
137:19 - there it is okay there's our psychotics
137:22 - from encrypting our message hello this
137:25 - is a super secret message here's our
137:27 - psycho text and as you see it's just a
137:30 - random set of these are hexadecimal
137:32 - digits there's no meaning in ASCII so it
137:34 - doesn't make sense to look at this from
137:36 - a text file perspective because we get
137:39 - any of those uh
137:42 - ASCII characters the dots mean
137:44 - unprintable
137:46 - and we could look it in binary as well
137:48 - but I will not show you in binary
137:50 - so we've encrypted using
137:53 - openssl you can do that on any file it
137:57 - doesn't have to be a text file it can be
137:58 - an image it can be a Word document any
138:01 - file you like because opensl SSL just
138:05 - treats it in its binary form and zeros
138:08 - and ones
138:11 - and to finish
138:13 - of course let's decrypt
138:16 - and decrypt is almost the same as
138:19 - encrypt so almost repeat the command
138:22 - instead of minus E
138:25 - what do we have minus D to decrypt and
138:29 - the input is of course the ciphertext
138:34 - and the output is some file let's say
138:37 - it's my uh received
138:43 - message
138:45 - same key we need to decrypt with the
138:48 - same key as we encrypted with in the
138:50 - same initial value
138:54 - and let's look at our received message
138:58 - and it should be the same as our
139:00 - plaintext message yes okay so we
139:03 - decrypted successfully that's all our
139:06 - received message which was output from
139:08 - the decryption is identical to the
139:10 - original plain text which was the input
139:12 - to the encryption
139:14 - so
139:16 - just a taster become experts in openssl
139:19 - because you use that you may use that in
139:22 - your homeworks and you'll use it in
139:25 - practice in the future to encrypt data
139:27 - so have a look on some of the websites
139:29 - to see how openssl works and start to
139:32 - use it especially as we go through the
139:35 - real science
139:37 - enough for today to next week we'll look
139:40 - at the details of deaths by going
139:43 - through a simplified depths
139:51 - symmetric block Cipher that takes 64
139:53 - bits of plain text input and produces 64
139:57 - bits of ciphertext as output so encrypt
140:00 - 64 bits at a time
140:02 - it uses a 64 bit keyer's input but in
140:05 - fact only 56 of those 64 bits of key are
140:09 - actually used in the encryption the
140:11 - other eight bits are a parity check
140:13 - to demonstrate deaths I'm going to use
140:16 - this academic version of desk called
140:19 - simplified desks he uses the similar
140:21 - operations but it just cuts down instead
140:23 - of using 64-bit blocks it cuts down to
140:26 - eight bits just so we can go through an
140:28 - actual full example or at least
140:31 - some parts of the example on the screen
140:34 - or on the board
140:36 - so simplified desk is not for real world
140:38 - use but we'll see and compare it to real
140:41 - deaths after we go through the example
140:45 - simplified deaths we deal with 8-bit
140:47 - blocks so it's just cut down to to
140:49 - operate similar to Deaths 8-bit
140:52 - we look at eight bits of plain text and
140:55 - we'll produce eight bits of ciphertext
140:57 - the key will be 10 bits
141:00 - and we
141:02 - in real desk we have 16 rounds that is
141:05 - we apply some function and then repeat
141:06 - it 16 times and simplify desk just two
141:09 - to to speed things up
141:14 - uh the steps that we'll see in the
141:16 - diagram of what what is the the steps we
141:20 - apply this captures the overall diagram
141:23 - for simplified desk and it looks similar
141:25 - to real deaths except
141:27 - it has only two rounds in this diagram
141:30 - real desk has 16. how we read this is
141:33 - that we have
141:34 - to encrypt plain text to get ciphertext
141:38 - if we have ciphertext and want to
141:40 - decrypt to get plain text we go in this
141:42 - direction and we'll explain the blocks
141:44 - but in fact in both cases we take our
141:47 - original key
141:49 - in this case a 10-bit key
141:52 - and we generate what's called round keys
141:54 - or sub keys
141:57 - K1 and K2
141:59 - and this will be round one round two
142:02 - we'll use sub key or round key K1 in
142:05 - round one and K2 and round two
142:08 - in real deaths we do a similar thing
142:10 - where we generate 16 round keys and use
142:14 - one in each of the rounds
142:16 - so there's this key generation step
142:19 - followed by the encryption
142:22 - what are all these blocks will go
142:25 - through them but in in summary
142:27 - the ones with a p
142:30 - initial permutation permutation 10
142:32 - permutation eight
142:34 - we'll see another one I think
142:35 - permutation four
142:37 - they are permutations which means
142:40 - transpositions or simply rearrangements
142:42 - they take some input and rearrange the
142:45 - bits we're operating on bits now not not
142:48 - English letters but remember rows column
142:51 - we took
142:53 - all right going backwards we took some
142:55 - characters and rearranged them we did a
142:58 - transposition or a permutation on those
143:00 - input characters we'll do the same in
143:02 - all of these IP is an initial
143:05 - permutation P10 and p8 are different
143:08 - permutations
143:10 - in fact
143:11 - switch or swap SW here is also a
143:14 - permutation it takes
143:16 - eight bits and swaps the halves
143:19 - so it puts the first four bits last and
143:21 - the last four bits first we'll see that
143:24 - in the example
143:25 - a shift is a left shift again a
143:29 - permutation take eight bits shift it all
143:32 - to the left wrap the first bit around to
143:34 - the end similar to a Caesar Cipher which
143:37 - shifts to the right
143:39 - okay so just a permutation
143:41 - that will not help us
143:49 - so there's permutations and then we'll
143:52 - see in detail that this F this function
143:54 - it's called a round function
143:56 - is where the details are and that will
143:59 - include some permutations as well as a
144:02 - substitution
144:03 - and the substitution is what adds the
144:05 - security we need the substitution in
144:07 - there without it that it'll be very easy
144:09 - to break
144:16 - simplified desk as well as real deaths
144:18 - the actual permutations how we rearrange
144:21 - the bits is defined it's standard and
144:23 - it's known by everyone
144:25 - so well these are the definition of them
144:27 - we'll return them and return to them
144:30 - when we need them not quite yet
144:33 - so we'll return to them through our
144:35 - example
144:37 - let's start with an example and generate
144:39 - a key
144:41 - and we'll see the steps in detail
144:45 - the example
144:49 - I think you have a printout in your
144:50 - handouts of an example I'll try and go
144:52 - through on the screen and we'll
144:53 - calculate it as we go but you you have
144:55 - it already printed out
144:59 - I'll show you
145:07 - you have this document which goes gives
145:09 - all the details of what we're going to
145:10 - go through at the moment so try and
145:12 - follow along and see what's happening
145:27 - foreign
145:34 - let's try and start with a key and
145:37 - generate the round keys
145:48 - and I've just chosen a random key for
145:50 - this example so our key that we'll start
145:53 - with
145:54 - TK
145:57 - 10 bits
146:08 - that's the key that we've chosen for
146:10 - example the user chooses a random key
146:12 - and shares it with the the recipient so
146:15 - both sides the encrypter and decrypter
146:17 - must have this shared secret key
146:21 - we'll have some plain text I'll
146:22 - introduce in a moment
146:24 - the first thing that we must do is
146:26 - generate sub keys
146:30 - and the steps are defined here we take
146:33 - 10 bits as input
146:40 - the 10-bit key is input and the way we
146:42 - read this diagram so this arrow with the
146:45 - slash store and 10 means 10 bits are
146:47 - flowing through here in order
146:49 - P10 is a permutation it takes 10 bits in
146:53 - and rearranges them in some way in some
146:56 - defined way
146:57 - and produces 10 bits out of course it's
147:00 - just a permutation in this case
147:02 - and will in fact we'll treat it as two
147:04 - different halves the left and the right
147:06 - half five bits at a time
147:08 - then we'll do a left shift on each half
147:11 - LS means left shift
147:13 - shift the bits to the left by one
147:16 - position
147:17 - so with five bits moving to the left
147:19 - where the leftmost bit will become the
147:22 - rightmost bit it'll wrap around we do it
147:24 - on each half
147:25 - and then we'll feed them in and do
147:27 - another permutation p8
147:29 - in fact this permutation will take 10
147:32 - bits in
147:33 - and will juice produce eight bits out so
147:37 - it permutates and
147:39 - deletes two bits
147:41 - to get the output K1 the first round key
147:45 - and the outputs of those left shifts
147:47 - will be fed down to do another left
147:49 - shift left shift by two positions
147:53 - p8 will be applied again we'll get the
147:55 - second round key K2 out so let's let's
147:57 - go through that with our 10 bits our 10
147:59 - bit key
148:05 - so the first thing is we apply
148:12 - P10
148:13 - so with our key after applying P10
148:18 - that rearranges those 10 bits but how
148:21 - and that's defined on one of the slides
148:24 - P10 if we go back
148:26 - is defined
148:28 - as
148:29 - if these are the 10 bits coming in
148:33 - bit one through to bit 10 then the order
148:35 - in which they come out are defined by
148:37 - the second row
148:38 - the first bit moves to the seventh
148:42 - position
148:43 - the tenth bit moves to the sixth
148:46 - position the third bit moves to the
148:48 - first position and so on
148:50 - so that's a fixed permutation
148:53 - it just rearranges the bits we'll see
148:56 - when we look at real deaths it has the
148:57 - same there's a a large definite a large
149:00 - list of bits that says of these 64 bits
149:04 - we are rearrange them in this manner
149:07 - why is that coming up
149:09 - connect
149:17 - let's get rid of this error
149:23 - okay so let's do that permutation P10
149:27 - where the well the third bit will become
149:30 - the first bit and so on
149:33 - you do it and just check that it makes
149:35 - sense
149:40 - and I'll write it down just so it's
149:42 - clear in this instance not for all the
149:44 - others
149:45 - what do we have
149:47 - these
150:03 - what do we have three five seven three
150:05 - five two seven four ten
150:10 - that's a two
150:14 - we'll go through slowly in the first
150:16 - case and then we'll speed up as we go
150:18 - through the
150:19 - uh the next steps
150:27 - so the result after we apply permutation
150:30 - P10 is that the third bit one becomes
150:34 - the first bit
150:37 - the fifth Bit Zero becomes the second
150:39 - bit
150:41 - the second Bit Zero becomes the third
150:43 - bit and so on
150:48 - seven
150:50 - or
150:51 - 10
150:53 - bit one bit nine bit eight bit six
150:59 - so that's all very simple rearrange the
151:01 - bits
151:03 - and we'll see the other permutations are
151:05 - very similar different arrangements and
151:07 - we'll talk about why a particular
151:10 - arrangements are chosen later but let's
151:12 - just go through and and perform the
151:14 - operations
151:18 - that is the first step
151:23 - so the 10 bits that come out we're at
151:26 - this position we
151:28 - treat them as two halves and do a left
151:30 - shift on each half left shift by one
151:33 - position
151:40 - so you split them into two halves now
151:45 - and after doing a left shift
151:49 - focusing on the first five bits
151:51 - everything moves to the left
151:56 - where the leftmost bit
151:58 - ends up as the rightmost bit
152:09 - and similar for the right half
152:18 - and next so that's the output of the
152:21 - left shifts they feed into p8 another
152:24 - permutation but note that p8 takes 10
152:26 - bits in produces 8 Bits out
152:30 - and it's defined as
152:33 - this select and permutate so two bits
152:37 - are going to be removed as the output
152:39 - bits one and two
152:41 - so we get six three seven four eight
152:43 - five ten nine as the rearrangement bits
152:46 - one and two are going to disappear
152:54 - and after p8
153:03 - we'll get eight bits and they'll be
153:16 - following T8 the first two bits
153:18 - disappear so now we have 10 bits they're
153:21 - going to disappear and these remaining
153:23 - eight bits are going to be rearranged
153:24 - according to p8 the definition of p8 I
153:27 - want to write down the rearrangement you
153:29 - need to check back on the the slide as
153:32 - to what that definition is but just mix
153:34 - them up
153:36 - that is in fact key
153:38 - key one round key for round one
153:45 - we'll use that later
153:53 - that's this output here K1
153:57 - the previous input to p8 is taken again
154:01 - and perform we perform another left
154:03 - shift on each of the halves by two
154:05 - positions
154:08 - so we'll continue
154:12 - and we'll do another left shift
154:16 - by two positions this time not one and
154:19 - that is taking this one
154:22 - and this value
154:25 - so take those five bits and do a left
154:27 - shift by two positions
154:41 - of course wrapping around where
154:43 - necessary so just focusing for example
154:45 - here this bit if we shift to the left by
154:49 - two positions comes to here and then
154:52 - here
154:53 - this second bit one two positions so the
154:58 - two ones end up here on the output and
155:00 - the three zeros of course will be there
155:04 - so we skipped over p8 that was just used
155:07 - to get k
155:08 - 1
155:10 - and the last
155:13 - last step p8 is applied again
155:16 - on those 10 bits apply p8 and you'll get
155:19 - K2
155:20 - and p8 is the same as it was defined
155:22 - before
155:24 - remove the first two bits and rearrange
155:26 - the remaining eight
155:34 - and we get
155:36 - I have the answers from before
155:39 - you can check
155:45 - that will be K2
155:54 - so the operations are very simple in
155:56 - fact in real deaths they they're that
155:58 - simple we're shifting bids we're
156:00 - rearranging bits
156:02 - transpositions in this case yep
156:08 - yes it in this case this is the
156:12 - algorithm it's defined like this
156:13 - whenever you have a key the the steps
156:16 - we're doing now is generating the round
156:17 - Keys the output of this step
156:20 - we started with our 10-bit key we get K1
156:22 - and K2 as output
156:24 - we always apply those steps that we've
156:26 - gone through always using that fixed
156:29 - definition of p8 left shift and P10 it
156:33 - doesn't change
156:34 - so very simple and the same in desks
156:36 - we'll just see that the the permutations
156:39 - have more bits than than what we're
156:41 - dealing with here
156:47 - so we get two round keys this is the key
156:49 - generation stage
156:52 - we'll use them in a moment
156:55 - just go back
156:58 - put everything into context
157:01 - what we just did was this middle part
157:03 - whenever we have our input key the user
157:06 - chosen key we generate two round Keys K1
157:09 - and K2 by P10 left shift p8 left shift
157:13 - p8
157:16 - and then we'll use those two keys when
157:18 - we encrypt our plain text and we'll go
157:20 - through that step of encrypting the
157:21 - plain text
157:23 - but it turns out with simplified deaths
157:25 - and even real deaths decryption also
157:28 - uses those same round keys so when
157:32 - someone receives ciphertext they want to
157:34 - decrypt they take the same 10-bit key
157:36 - follow those exact same steps and
157:39 - they'll get the same values of K1 and K2
157:44 - and we'll return to it but we'll notice
157:46 - that decryption
157:48 - follows the exact same steps as
157:51 - encryption
157:52 - encryption we'll see is IP
157:55 - F of k s w f of k i p the inverse IP
158:03 - decryption exactly the same steps
158:07 - the only difference is that we'll use
158:08 - the round keys in the opposite order
158:11 - in encryption K1 is used first and then
158:15 - K2 in decryption K2 and then K1
158:19 - the benefits of encryption and
158:21 - decryption being the same operations is
158:24 - that you only need to implement it once
158:27 - you implement encryption and you now
158:29 - have an implementation of decryption
158:32 - that's a significant practical advantage
158:36 - so let's now encrypt some plain text
158:43 - any questions
158:45 - easy so far and it will only get easier
158:47 - as we go
158:54 - we will not go through all the steps
158:56 - don't worry
158:57 - we're just some initial steps
159:05 - let's try again
159:08 - we'll need K1 and K2 and we need some
159:11 - plain text to encrypt
159:16 - I've chosen some plain text
159:20 - we'll return to K1 when we need it
159:24 - some random plain text
159:32 - so that's we want to encrypt this 8-bit
159:34 - block
159:35 - if I had a thousand bits of plain text
159:38 - and I'd have to break it into 8-bit
159:40 - blocks and encrypt one block at a time
159:45 - so what do we do to encrypt
159:48 - the details are
159:51 - here
159:52 - a little bit more detail than the
159:53 - overall diagram
159:55 - this is the encryption phase
159:58 - and it's hard to see uh at this size but
160:03 - we start with eight bits plain text
160:06 - IP is what we call the initial
160:08 - permutation it's a permutation we do
160:10 - just at the start
160:12 - we only do it once in the encryption
160:16 - we'll see at the end we do an inverse
160:18 - initial permutation
160:20 - okay nothing complex that
160:23 - and then these two dark gray boxes
160:26 - other rounds
160:30 - and they involve some permutations in
160:33 - fact EP is expand and permutate
160:37 - meaning we're going to take
160:39 - four bits in
160:41 - and produce eight bits out so we take
160:43 - four bits expand to get eight bits
160:45 - rearrange
160:47 - we're going to take our key K1 which we
160:50 - just generated an exclusive or
160:52 - with the output here
160:55 - we're going to split it into two halves
160:58 - and feed four bits at a time into the
161:00 - two s boxes
161:02 - s0 S1 are called s boxes substitution
161:06 - boxes
161:08 - so the operations we've seen so far are
161:10 - just
161:12 - transpositions permutations the other
161:15 - main operation in cryptography is a
161:17 - substitution we're going to replace
161:19 - bits with other or sets of bits with
161:22 - other sets of bits
161:23 - so we'll see the details of them
161:25 - we'll take the output they'll produce
161:28 - two bits out
161:29 - who have another permutation
161:33 - we're going to X or with the left half
161:37 - of our original output here
161:40 - we'll get four bits and four bits and
161:42 - then we'll swap the halves and we'll do
161:44 - it all again
161:47 - one round the second round
161:50 - let's go through just the first few
161:51 - steps and then we'll
161:53 - give you the answer so you can check if
161:56 - you need
162:01 - first the initial permutation
162:12 - and like the other permutations it's
162:14 - defined
162:19 - bits one to eight become rearranged in
162:22 - in this order okay so that's fixed it's
162:24 - always fixed it's always those values
162:30 - rearrange and you get
162:38 - what do you get
162:40 - tell me the values
162:43 - try it
162:51 - bit two become the second bit on the
162:54 - input becomes the first bit on the
162:56 - output the sixth becomes the second
163:14 - and so on
163:19 - what have I done wrong
163:21 - I've got the wrong answer in front of me
163:23 - sorry I'm going to go back and start
163:25 - again
163:25 - I've got the wrong plain text
163:29 - luckily I noticed before we got halfway
163:32 - through let's try a different plain text
163:34 - because I only have the answer to that
163:35 - one
163:45 - I misread my notes this is the plain
163:47 - text I want to try because I have the
163:50 - answers and we can check and confirm at
163:51 - the end let's forget about the first
163:53 - plain text but we do the same initial
163:55 - permutation the second bit becomes the
163:57 - first and the sixth bit becomes the
164:00 - second and so on
164:02 - and in fact
164:04 - where I misread is that that becomes
164:07 - one
164:14 - six
164:17 - and what do you get
164:19 - this is where I misread the plain text
164:23 - that would be the output after we
164:24 - rearrange those eight bits according to
164:26 - IP
164:32 - foreign
164:37 - that is the output of Ip and in fact now
164:40 - we we operate on two halves the right
164:44 - half
164:45 - we're going to feed into this block here
164:48 - denoted as F uppercase F the left half
164:51 - will return to later we'll need it later
164:54 - so the right half the right four bits we
164:57 - expand and permutate
165:00 - and then xor with the key K1
165:05 - and expand and permutate
165:09 - is defined as this
165:11 - four bits in
165:12 - we're going to repeat those four bits
165:14 - and rearrange them as defined at the
165:16 - first bit becomes the second bit and the
165:19 - eight bit the second bit on input
165:21 - becomes the third and the fifth bit on
165:24 - output and so on so we expand and
165:26 - permutate
165:31 - only on the right most half
165:58 - so that was just on those four bits
166:02 - then we xor with
166:07 - K1
166:09 - and K1 is what we generated before
166:14 - from before K1 was
166:18 - we have
166:30 - if you do an xor between those eight
166:32 - bits
166:38 - One X or one
166:40 - I remember their the basics of xor
166:44 - when they're the same we get zero when
166:46 - they're different we get one
167:00 - and then we're going to input
167:02 - split that into two halves
167:05 - and input that into our s boxes
167:09 - and that's really the next step that we
167:11 - need to go through that's different from
167:13 - before then we the rest is easy
167:17 - so just to show where we're at
167:24 - we had eight bits out of our expand and
167:27 - permutate we xor with the K1 and take
167:31 - four bits into s0 and four bits into S1
167:44 - where the S boxes
167:47 - we perform a substitution
167:50 - and the way that we use it we're going
167:53 - to the S boxes are also defined the
167:55 - substitutions
167:57 - like our
167:59 - uh
168:00 - monoalphabetic Cipher defines how we
168:04 - what we
168:06 - replace our plain text characters with
168:08 - what do we get on output this defines
168:11 - given an input what is going to come out
168:15 - and it's defined we'll Define it as two
168:16 - matrices s box zero s box S1
168:20 - so focusing on s0 we have four bits in
168:25 - the way that we interpret this so this
168:27 - is the s box
168:29 - we have a four bit input bits one
168:31 - through to bit four
168:33 - bit one and bit four specify the row bit
168:36 - two and bit three specify the column and
168:38 - we just do a simple Matrix lookup and
168:40 - with the element that we find becomes
168:43 - the output
168:44 - where we label our columns and rows
168:49 - in in binary so 0 1 2 3 in decimal
168:53 - so
168:55 - row 0 or in binary zero zero zero one
168:59 - one zero one one
169:01 - and column zero one two three
169:05 - and
169:06 - bit one and four specify the row
169:10 - two and three specify the column
169:13 - so what's the output
169:18 - find out
169:20 - the output
169:21 - when we feed these values into our two s
169:24 - boxes
169:34 - foreign
169:42 - and two bits going to come out
169:50 - with S1 the row is going to be
169:54 - 0 0
169:57 - and the column
170:00 - 1 1.
170:03 - if it's one and
170:05 - go back
170:07 - beats one and four specify the row two
170:10 - and three specify the column
170:15 - so row 0 0 column one one or in decimal
170:18 - row zero column three
170:21 - look up your s box
170:28 - row zero
170:30 - the first row column three
170:32 - the last row output one zero
170:37 - okay so it's just a look up on that
170:39 - defined substitution box
170:41 - so the output for S1 will be one zero
170:44 - and then do the same for the the right
170:46 - four bits to get S1
170:55 - what does S1 give us
171:02 - first and fourth bit
171:04 - column second and third bit
171:07 - and just do a lookup in the s box
171:26 - if we can get past the S boxes you'll
171:28 - see that the rest is all permutations
171:30 - and easy
171:32 - any questions
171:34 - on the S boxes or or the other aspects
171:37 - of simplified desks so far
171:47 - find out the output of S1
171:56 - is it one one
172:06 - row
172:07 - now think of the rows and columns in
172:10 - binary the easiest way row 0 1 column
172:12 - one one so when we look at our Matrix we
172:16 - if you want to convert a decimal then
172:18 - zero through to three
172:21 - zero one one
172:24 - in s box S1
172:27 - the second row
172:28 - zero one
172:31 - the last column one one produce output
172:34 - one one
172:36 - okay
172:49 - just to look up on that Matrix our
172:52 - substitution
173:01 - we are the output of s0 and S1 we have
173:05 - four bits we permutate with P4 we'll get
173:09 - four bits out
173:11 - then we xor those four bits with the
173:14 - left half that came out of the initial
173:15 - permutation
173:18 - let's quickly do that and then we'll get
173:20 - to our answer
173:24 - so we're going to apply P4 now
173:34 - four bits into P4
173:42 - we'll produce those four bits out where
173:44 - does that come from
173:47 - four bits in one zero one one
173:49 - P4 is defined
173:52 - here
173:54 - a rearrangement
174:04 - bit two becomes the first bit and then
174:08 - the remaining three bits at the end
174:12 - and X all that with
174:18 - the left half we have it up somewhere
174:25 - this left half of the initial
174:27 - permutation
174:29 - if we can bring it down
174:34 - is then reused down here one zero one
174:37 - zero
174:50 - this one zero one zero is the left half
174:53 - from our initial permutation output you
174:56 - can follow it up on here or on the slide
174:58 - it comes from the initial permutation
175:01 - exclusive or
175:07 - foreign
175:18 - [Music]
175:22 - what do we just do we just took the four
175:25 - bits out of P4 exclusive all with the
175:28 - four bits from the initial permutation
175:29 - we get four bits out
175:32 - combine it with the original right half
175:34 - of the initial permutation
175:39 - I'll bring that down
175:43 - the right half here
175:46 - is now reused
176:00 - one zero zero one
176:08 - and the last
176:10 - in fact that's the end of our round
176:13 - that's the end of the round
176:15 - we swap the halves
176:17 - and then repeat all of it again repeat
176:19 - the round again
176:29 - what we've just done is
176:32 - we started with plain text we did the
176:35 - initial permutation then we did
176:36 - everything inside this dark gray block
176:40 - now we're going to swap the halves and
176:42 - then we repeat everything inside the
176:44 - dark gray block
176:45 - but using K2 as an input a distance
176:49 - and then we'll get some eight bits out
176:51 - do an inverse initial permutation we'll
176:53 - get our ciphertext so let's swap the
176:55 - halves and then I'll give you the answer
176:57 - you can do the rest in your own time
177:06 - swap the halves
177:12 - so this is the swap
177:21 - then you apply
177:24 - our round function denoted on the
177:26 - diagram is f of K using K2 as an input
177:35 - you'll get as an output
177:37 - I've done it before I hope
177:55 - has the output you'll get eight bits of
178:06 - then you'll do the inverse initial
178:09 - permutation
178:16 - and you get your output ciphertext
178:38 - foreign
178:41 - we will not go through many ciphers in
178:45 - this much detail we'll just use this one
178:47 - to demonstrate that in fact
178:50 - complex ciphers is made up of simple
178:52 - operations
178:55 - so
178:56 - as the output of our swap swapping the
178:59 - halves we get these eight bits you apply
179:01 - the the dark gray block again but use a
179:03 - K2 as an input and we calculated K2
179:06 - before
179:08 - you get some eight bits you apply the
179:10 - inverse initial permutation and then you
179:13 - get eight bits of ciphertext and we're
179:14 - done
179:25 - you as homework will try and work out
179:27 - what the inverse initial permutation is
179:32 - well the inverse of Ip so
179:35 - try and work out what it means to do the
179:38 - inverse of this operation this
179:39 - permutation
179:42 - try
179:45 - it's the inverse yes let's see what
179:48 - happens
179:49 - it's it's like thinking about the the
179:53 - rose columns a little bit just be
179:55 - careful with it
180:02 - so we're done we've encrypted using
180:04 - simplified deaths if we want to decrypt
180:06 - in fact we do the exact same steps we
180:10 - except we take our ciphertext eight bits
180:13 - exact time steps but we use K2 first in
180:18 - the first round and then K1
180:20 - okay so just rearrange the ordering of
180:22 - the keys
180:23 - so you know simplified desk now
180:30 - to finish the last two minutes
180:36 - that was the example we went through
180:40 - comparison of simplified death and real
180:42 - deaths some some aspects so a simplified
180:44 - this is just for educational purposes
180:46 - real deaths some of the differences all
180:50 - right we now we have 64-bit blocks not
180:53 - eight
180:55 - and we have 16 round Keys it turns out
180:58 - the round keys in real deaths are 48
181:00 - bits so K1 K2 K3 up to k16 will each be
181:05 - 48 bits they'll be derived from the
181:07 - original input key
181:10 - right the initial permutation is 64 bits
181:14 - the function f if you look in the
181:16 - diagram operates on 32 bits
181:19 - simplified Des had two s boxes real desk
181:22 - has 8s boxes
181:24 - for the same Concepts
181:26 - 16 rounds not two rounds this is this
181:30 - concept of keep applying transpositions
181:33 - and substitutions and you get better and
181:36 - better cycle text from a security
181:37 - perspective
181:40 - so
181:41 - you could go away and do simplified
181:43 - deaths if you had the definition of all
181:45 - those operations
181:47 - and for your reference I included them
181:50 - here just taken from the textbook
181:54 - real death goes through 16 rounds
181:58 - here's the initial permutation IP
182:02 - and the inverse 64 bits in we rearrange
182:06 - those 64 bits so the first bit ends up
182:09 - here the 58th bit becomes the first bit
182:12 - and so on
182:13 - that's all
182:17 - the expand and permutate
182:19 - permutation functions
182:22 - a single round we take our right half
182:24 - expand and permutate xor s box
182:29 - permutate EXO and
182:32 - keep going
182:36 - all right
182:38 - the S boxes
182:40 - with
182:41 - simplified desk we just had our two four
182:44 - by four major matrices here we have
182:47 - eight S boxes
182:50 - but same concept we just do a lookup in
182:53 - the s box to get the output in this case
182:56 - we get output 4 bits I think we have a
182:59 - decimal
183:00 - 4-bit value there
183:04 - and it's slightly different in the key
183:05 - generation but uh it's not much more
183:10 - complex
183:16 - so we now know simplified deaths you
183:20 - could now expand that knowledge to real
183:21 - deaths and real deaths is one of the
183:24 - most used ciphers in the world it's no
183:26 - longer recommended but if you consider
183:28 - the its use over the last 30 or 40 years
183:30 - is one of the most used ciphers in the
183:33 - world and many other ciphers use similar
183:36 - Concepts rounds
183:38 - substitutions transpositions xor
183:41 - generate keys and so on so this is one
183:45 - example of
183:47 - a real and relevant Cipher
183:50 - on Thursday we'll talk about some of the
183:53 - some of the reasons it uses these
183:56 - operations and some of the limitations
183:58 - of them
183:59 - and then move on to the next topic
184:05 - let's stop there
184:09 - this is from
184:12 - the previous set of lecture notes on the
184:14 - classical ciphers but generally talked
184:16 - about attacks and we skipped over one
184:19 - side and I forgot to come back to it so
184:20 - Now's the Time because we mentioned some
184:23 - of the concepts as we move forward
184:25 - coming back to an attacker what they
184:27 - want to do is discover the plaintext or
184:29 - the key
184:31 - getting the keys better because then you
184:33 - can uh if the other users don't know
184:37 - then you can easily decrypt subsequent
184:40 - ciphertext that you come across
184:44 - the attacker we assume knows ciphertax
184:47 - so we can obtain the ciphertext and we
184:49 - know the algorithm being used so that's
184:51 - an assumption uh hiding the algorithm is
184:54 - usually not possible uh adds very little
184:57 - extra security
185:00 - we'll see and we'll see today in some
185:03 - attack where the attacker often makes
185:06 - use of known pairs of plain Tech
185:08 - ciphertexts and that's what we'll see in
185:10 - some actor attacks and different attacks
185:13 - we've mentioned Brute Force again before
185:15 - so you know about Brute Force try all
185:18 - keys so you need to know how many keys
185:20 - and how
185:22 - how many keys we can try per second to
185:25 - work out how long a Brute Force attack
185:26 - takes
185:28 - Crypt analysis we've seen some attacks
185:30 - for example in the quiz the mono
185:31 - alphabetic Cipher we can use frequency
185:33 - analysis that is take advantage of the
185:36 - fact that the plain text and the
185:38 - ciphertext exhibit similar
185:39 - characteristics in the frequency of
185:41 - letters diagrams and so on
185:43 - and there are other types of attacks
185:45 - that can be performed on real ciphers
185:52 - often so now moving away from Brute
185:55 - Force often the other types of attacks
186:00 - there are some common techniques which
186:01 - are applied across against different
186:03 - Cycles so there may be a tax specific to
186:06 - one Cypher like death but but it won't
186:09 - work on AES but then there may be some
186:12 - general techniques that may work across
186:14 - a set of Cycles
186:16 - and we're not going to go into any
186:17 - details of those techniques we may see
186:19 - today we'll see one example we may see a
186:22 - few later but just to mention some of
186:24 - the methods the general methods linear
186:27 - cryptanalysis
186:29 - is really trying to find some think of
186:32 - some linear equation that relates the
186:35 - ciphertext back to the key and back to
186:37 - the plain text and solve effectively
186:39 - that equation but it's it can be very
186:42 - complex
186:43 - and differential Crypt analysis is
186:45 - looking at differences in
186:48 - across different plan cytotext values to
186:51 - try and work out how that Maps back to a
186:54 - key
186:56 - we'll see meet in the middle attack
186:57 - today that'll become clearer side
187:00 - Channel attacks and there are others
187:01 - side channel is using uh
187:04 - some outside information
187:07 - to try and use determine the key or the
187:10 - the plaintext
187:11 - an example and it's it's used in a
187:14 - number of systems is
187:16 - when I encrypt something on my computer
187:20 - say I'm implementing I've implemented
187:22 - deaths and I'm in quick encrypting some
187:24 - data
187:25 - there are many different operations of
187:27 - desks we saw simplified desks yesterday
187:29 - the rounds the xor the permutations and
187:34 - so on
187:36 - it turns out in some cases if you can
187:38 - measure how long it takes your Hardware
187:40 - to do each operation
187:43 - you can get some extra information and
187:46 - try and then
187:47 - use that to try and determine the key or
187:50 - plain text
187:51 - so one example of a side Channel attack
187:53 - is actually measuring how long the the
187:56 - hardware takes for each operation in the
187:58 - encryption
188:00 - and because depending on different keys
188:02 - and different plain texts the operations
188:05 - may take different amounts of time
188:07 - so by analyzing that you can start to
188:11 - work backwards from the cycle text to a
188:14 - key or plain text so using extra
188:15 - information
188:17 - some other information from some other
188:20 - channel
188:23 - often
188:25 - attacks are compared against the worst
188:28 - case Brute Force so look
188:30 - if we can do Brute Force
188:32 - then fine we can defeat the cipher but
188:36 - often the the success of other attacks
188:39 - is compared against well how long is it
188:41 - does it take compared to Brute Force
188:43 - we'd like to be faster than brute ports
188:46 - okay so brute force is the the worst
188:48 - case approach if we can come up with an
188:51 - attack which is better faster than Brute
188:53 - Force then that's a good thing from an
188:55 - attacker's perspective
188:57 - defeating the security
188:59 - so with Brute Force we normally measure
189:01 - the number of operations so how many
189:04 - decrypts do we need to do to defeat the
189:06 - cipher to find the key for example
189:10 - which depends
189:12 - entirely on the number of keys and the
189:14 - type and the time depends upon how long
189:17 - each operation takes so
189:20 - a cipher with a
189:22 - 64-bit key
189:25 - takes worst case with Brute Force 2 to
189:28 - the power of 64 operations
189:30 - to find the key
189:33 - so we use a similar metric to measure
189:35 - other attacks how many operations does
189:37 - it take to find the key
189:39 - should be better than Brute Force if
189:41 - that attack is ever any use
189:44 - so if
189:46 - a Brute Force attack takes two to the 64
189:48 - operations and we've got some other
189:50 - attack that takes 2 to the power of 60
189:52 - operations
189:54 - and we'd say that's better than Brute
189:55 - Force
189:56 - and is the weakness in the cycle
189:59 - but the other thing we'll see that other
190:01 - attacks use is
190:04 - not just that they take many operations
190:06 - but to work often they require some
190:09 - memory to store information while
190:11 - they're performing the attack
190:13 - the less memory required the better it
190:16 - is
190:16 - from the attacker's perspective
190:19 - and often they require knowledge the
190:22 - attacker requires knowledge of past
190:24 - pairs of plain text cytotecs
190:28 - so
190:29 - the attacker has some ciphertext uh
190:32 - trying to find the key
190:34 - often attacks assume that the attacker
190:37 - also knows some
190:40 - other ciphertext values which were
190:42 - produced
190:44 - with the same key from same some paint
190:46 - text and the attacker knows both the
190:48 - pair of plain text and ciphertext but
190:51 - they don't know the key
190:54 - so how many pairs of plain text
190:56 - ciphertexts or
190:59 - and particular
191:01 - um can we choose particular values has
191:03 - an impact on how we measure how
191:04 - successful an attack is
191:07 - some classification of that information
191:09 - known by the attacker
191:11 - not this slide is here what is known
191:15 - from the attacker's perspective okay
191:18 - let's imagine where the attacker trying
191:20 - to defeat a cipher
191:22 - the worst case for us
191:25 - well first in general
191:27 - the more information I know
191:30 - the more the better it is for me to be
191:32 - able to attack a cycle
191:34 - so the worst case for the attacker is
191:36 - knowing very little
191:38 - the worst case is knowing just the
191:40 - ciphertext
191:41 - and the algorithm we're assume in all
191:43 - these cases we know the algorithm
191:46 - and if we just know the ciphertext then
191:48 - we need to take that ciphertext and the
191:50 - algorithm and determine the key
191:53 - or the plain text for that psychotics
191:55 - normally we look for the key
191:58 - but it can be a little bit easier for
192:00 - the attacker if they know some
192:03 - pears
192:05 - in addition to the algorithm and
192:07 - ciphertext they know some pairs of past
192:09 - plain text cycle text
192:12 - somehow
192:13 - they've discovered
192:15 - some past ciphertext values and the
192:18 - corresponding plain text
192:20 - but not the key
192:22 - so that's what we mean by plantex
192:25 - ciphertext pairs
192:27 - plain text was encrypted with a key to
192:29 - get a psychotex the attacker knows the
192:31 - plain text and ciphertext but they don't
192:33 - know the key are trying to find that
192:37 - that information can help the attacker
192:40 - to try and find the key
192:44 - how do we get a past pair of plain text
192:47 - ciphertext
192:48 - maybe the plaintext became not important
192:51 - and is no longer considered secure and
192:54 - is made available so the attacker can
192:57 - learn the plain text without knowing the
192:59 - key
193:02 - the simple example I think I may have
193:05 - mentioned it before is that okay
193:07 - um some text is some
193:11 - information about some event happening
193:14 - in the future
193:16 - the event will happen at this time at
193:18 - this location
193:22 - after the event happens the attacker
193:25 - knows the psycho text
193:27 - they also can determine the plaintext
193:29 - because they know that the event
193:30 - happened at this time and at this
193:33 - position so they can determine what the
193:35 - original paintex was without knowing the
193:37 - key
193:38 - so there are a number of cases when the
193:40 - attacker we assume those pairs of
193:43 - plaintiff psychedules
193:46 - oh
193:49 - if the attacker can choose
193:52 - what pairs
193:55 - it can learn
193:57 - it can make the attacker even
193:59 - of the attack even easier
194:02 - so a known plain text is the case where
194:05 - the attacker is able to find some
194:07 - plaintext cyphert experts chosen plain
194:10 - text is where they've chosen particular
194:13 - plain text values
194:15 - and found the corresponding psychotex
194:17 - values
194:18 - an example
194:20 - I choose a plain text value as the
194:23 - attacker and somehow I get the user to
194:26 - encrypt that plain text with their key
194:29 - and I intercept their ciphertext
194:32 - so now I know the plain text and
194:33 - ciphertext
194:35 - choosing the plain text
194:39 - allows the attacker to choose values
194:41 - that may help breaking the cipher by
194:43 - finding weaknesses that depend upon that
194:46 - plaintext
194:48 - so being able to choose the specific
194:50 - value can help in some attacks
194:54 - chosen ciphertext is similar except the
194:56 - attacker gets to choose the ciphertext
195:00 - and can find the corresponding plain
195:03 - text
195:04 - chosen text is when we can have both
195:07 - the attacker can choose both plain text
195:09 - and ciphertext and get the other value
195:11 - in the pair
195:13 - generally as we go down the more
195:16 - information the attacker knows the
195:18 - greater the chance they can perform a
195:21 - successful attack
195:22 - with ciphertext only
195:25 - then
195:27 - it's harder for the attacker with chosen
195:30 - text is generally easier for the
195:32 - attacker
195:34 - we'd like to design ciphers
195:37 - such that we can defend against any
195:40 - attack preferably
195:42 - even if the attacker knows chosen plain
195:45 - text chosen ciphertext or even chosen
195:47 - text
195:48 - sometimes we can defend against all
195:51 - sometimes just selection
195:56 - so the more info that the more
195:58 - information the attacker knows generally
196:00 - the easier it is for them to attack
196:03 - we'll see this come up when we perform
196:05 - an attack in a moment well soon
196:08 - hopefully
196:09 - at the end of this lecture
196:16 - and the last thing that we missed over
196:21 - how do we measure security
196:24 - well the absolute measure
196:28 - we can say a cipher is unconditionally
196:32 - secure
196:34 - means it's perfect in terms of security
196:39 - that is the ciphertext has no
196:42 - information such that an attacker can
196:44 - find out the correct plain text or key
196:47 - so a cipher which is unconditionally
196:50 - secure has that property
196:52 - the only known
196:55 - the only known Cipher that is
196:57 - unconditionally secure is the one-time
196:59 - pack
197:00 - we've seen the example of the one-time
197:02 - pad even if we try a Brute Force attack
197:07 - given some cyber text we cannot
197:09 - determine the correct plain text or key
197:12 - so it's perfect in terms of security
197:14 - it's unconditionally secure under no
197:16 - conditions is it insecure
197:20 - no other ciphers are known to be
197:22 - unconditionally secure
197:24 - there are conditions in which they are
197:26 - insecure
197:28 - so therefore to be practical to compare
197:31 - ciphers we talk more about computational
197:33 - security
197:37 - and
197:39 - in general
197:41 - as Cipher is considered to be
197:43 - computationally secure if
197:46 - the cost of breaking it exceeds the cost
197:48 - of the information encrypted
197:51 - or the time required to break exceeds
197:54 - the useful lifetime of that encrypted
197:56 - information
197:57 - example
197:59 - I have
198:02 - a hundred thousand baht in my bank
198:04 - account
198:05 - and my password
198:09 - to get access to my bank account is
198:11 - encrypted
198:13 - and
198:15 - someone finds the encrypted password
198:17 - some malicious user a student and they
198:19 - want to get my 100 000 Baht so they go
198:22 - and they buy many computers and do a
198:23 - Brute Force attack against my password
198:25 - and they spend a million bucks
198:29 - to find the password they get the
198:31 - password they get into my bank account
198:33 - they steal my 100 000 baht
198:36 - this
198:37 - information would say is computationally
198:40 - secure because the value of the
198:42 - information was 100 000 bar for the
198:44 - attacker but the cost of breaking it was
198:46 - 1 million so
198:48 - it costs them all to break it than it is
198:50 - than they get in return
198:53 - so a simple example that we need to
198:55 - evaluate how much is the information
198:57 - worth
198:59 - that one was easy but uh
199:02 - I encrypt
199:05 - I encrypt a confident confidential
199:09 - information about trade secrets for my
199:11 - company
199:12 - I don't want other companies to get that
199:14 - what's that information worth
199:16 - it's very hard to put a value on lots of
199:19 - information
199:20 - so it's hard to put numbers on how much
199:22 - is the information actually worth
199:24 - and how much would it take to cost to
199:27 - break that how much cost would it take
199:31 - it's hard to estimate the value of a lot
199:34 - of information
199:36 - the other one is the exam
199:39 - I have the exam on my laptop for the
199:42 - midterm the midterm is in what four
199:45 - weeks time
199:47 - and I encrypt the exam
199:49 - you can have the ciphertext you again
199:52 - you have all these computers the lab
199:54 - computers and you start your attack and
199:57 - it takes you seven weeks to find the
200:00 - exam answers
200:03 - put the exams over
200:04 - okay you had you sat the exam you needed
200:07 - the exam answers in four weeks took you
200:09 - seven weeks to get them so again in that
200:12 - case we'd say it's computationally
200:14 - secure because
200:16 - the time required to break the cipher
200:18 - exceeded the the value or the useful
200:21 - lifetime of the the encrypted exam in
200:24 - that case
200:25 - again
200:26 - it's hard to put or it's hard to
200:28 - estimate what the lifetime of some
200:30 - information is
200:33 - so
200:34 - although the concept is easy in practice
200:36 - knowing how valuable information is how
200:40 - long do we need to keep it secure is not
200:42 - easy to predict
200:44 - and how how long does it take to break
200:46 - is again not easy to predict
200:52 - so one time pad is the OWN only
200:55 - unconditionally secure Cipher
200:58 - all others are conditionally secure
201:01 - that so therefore we look at the
201:03 - computational security how much effort
201:07 - how much cost or time does it require to
201:09 - break it
201:14 - and we'll
201:16 - come to some of that when we look at
201:17 - deaths so let's go back to our desk
201:20 - slides our block Cipher
201:26 - and there's two concepts we skipped
201:29 - there on death as well
201:32 - death and the fiscal structure and many
201:34 - block Cycles in general use the concepts
201:36 - of diffusion and confusion
201:39 - and
201:41 - one of your favorite scientists come up
201:44 - with these Concepts so Claude Shannon
201:47 - some of you took its 323 we saw Shannon
201:51 - capacity equation about how much
201:52 - information we can send across a channel
201:54 - Shannon came up with that Shannon also
201:57 - did a lot of work on security or the
201:59 - concepts of security security and data
202:03 - Communications are closely aligned
202:06 - it's about representing information
202:09 - and getting a information in an
202:11 - efficient way from A to B so there's
202:13 - similar Concepts so Shannon come up or
202:15 - Define the concepts of
202:17 - with ciphers we'd like to have a cipher
202:20 - that has diffusion and confusion
202:24 - what do they mean in simple terms
202:27 - and just go back the feistful structure
202:30 - and including gas use or apply these
202:33 - Concepts so they do have this diffusion
202:36 - is
202:37 - spreading out
202:39 - the plain text when we get the cyber
202:41 - texts
202:43 - our plain text always has some structure
202:46 - think of an English phrase or document
202:49 - there's some structure in the frequency
202:51 - of letters
202:53 - when we apply our Cipher we'd like that
202:56 - structure to be diffused to be spread
202:58 - out across the entire cyphotex so the
203:01 - structure is no longer present in the
203:04 - cycle text that's the idea then so that
203:07 - the structure in the plain text or the
203:10 - statistical nature of the plain text is
203:12 - reduced in the ciphertext
203:14 - so preferably that it looks random in
203:18 - the end
203:19 - how to achieve that
203:25 - apply
203:26 - permutations or transpositions
203:29 - repeatedly
203:30 - and then on the input plain text and
203:35 - apply some function to like a
203:37 - substitution function
203:39 - in the same way that deaths
203:41 - as
203:43 - some basic permutations P we saw those P
203:46 - boxes
203:47 - we saw in simplified desk P10 p8 P4
203:51 - permutations but also some s boxes for
203:55 - substitutions and repeat
203:57 - each round
203:59 - so that
204:01 - increases the amount of diffusion of the
204:04 - plain text
204:07 - the other part is confusion
204:11 - make the relationship between the cipher
204:13 - text and the key complex
204:17 - with the intention that
204:20 - even if there is some structure in the
204:22 - ciphertext
204:24 - so the attacker can find some structure
204:26 - in the ciphertext
204:27 - that is some letters occur more frequent
204:30 - than others it still should be hard to
204:32 - take that ciphertext and find the key
204:35 - so if if that's achieved we've got
204:38 - confusion
204:40 - so making it hard given the ciphertext
204:43 - to find the key
204:45 - so make the relationship between them
204:48 - very complex
204:49 - we saw
204:51 - in some of our classical ciphers once we
204:54 - find the ciphertext
204:55 - the the key is easy to find
204:58 - once we found the psychotex on our mono
205:01 - alphabetic cycle we've automatically got
205:02 - the key
205:03 - whereas with this and other ciphers will
205:05 - see even if you find the ciphertext for
205:08 - a given plain text it's still hard to
205:10 - find the key
205:12 - and that's the concept of confusion and
205:15 - it uses some substitution some complex
205:17 - substitution algorithm
205:20 - non-linear mean it's hard to go in the
205:22 - inverse
205:24 - and in death the S boxes implement this
205:28 - uh increased confusion
205:31 - in the cycle
205:36 - let's hope it decreases confusion of
205:38 - your knowledge of death
205:41 - let's go through and look at the design
205:43 - characteristics and summarize what we
205:45 - know about deaths
205:47 - we went through an example of simplified
205:49 - deaths
205:51 - and then a comparison with real deaths
205:54 - and it's really scaling up simplified
205:57 - depth we make it simple so we can do an
205:59 - example real deaths just
206:02 - as more as boxes more rounds larger
206:05 - blocks and so on
206:07 - but the same Concepts and operations
206:12 - you can look through the details of
206:14 - deaths
206:16 - again
206:18 - of course no need to remember these and
206:20 - no need to remember simplified desk
206:21 - operations okay so I don't ask you in
206:24 - the exam
206:25 - uh to remember these s boxes or this
206:30 - this picture or these permutations you
206:34 - don't need to remember them the reason
206:35 - we went through this example was for you
206:37 - to see
206:38 - that we're using very simple operations
206:41 - permutation substitutions but combining
206:44 - them together to get uh
206:47 - a good Cipher
206:55 - so let's go and look at some design
206:57 - characteristics of deaths is it good
207:01 - and one of the
207:03 - the measures of seeing how good a cipher
207:06 - is and it's not just for desks but for
207:08 - others as well is the Avalanche effect
207:10 - an avalanche what happens at the top of
207:13 - the mountain the small thing starts
207:16 - falling small rock falls and it knocks
207:18 - more rocks and a more rocks and more
207:20 - rocks and at the end there's the whole
207:22 - mountain is falling down
207:25 - the concept is that with ciphers we'd
207:28 - like to have the Avalanche effect
207:30 - with good ciphers and the effect is that
207:33 - small changes in the input
207:37 - produce large changes in the output
207:40 - a small change at the start means a
207:43 - large change at the at the end
207:48 - and we can look at it from two
207:49 - perspectives from the input being the
207:51 - plain text or the input being the key
207:56 - to show that we'll look at the two
207:58 - examples here
208:00 - first in summary
208:02 - death
208:04 - has the Avalanche effect
208:05 - that is that's good for security it's
208:07 - considered designed to be a good design
208:10 - because it exhibits the Avalanche effect
208:13 - and the next two slides give examples of
208:15 - that
208:16 - the idea is that
208:20 - we have two different plain text values
208:24 - they differ by just one bit if you look
208:26 - these are in hexadecimal
208:28 - but in fact it's just the first
208:30 - hexadecimal digit differs zero to one in
208:33 - binary just one bit differs in these two
208:36 - input values
208:37 - so a small change in inputs
208:40 - what we'd like is to produce a large
208:42 - change in the output cycle text
208:48 - and
208:51 - this shows
208:53 - shows those changes so
208:57 - we see after a set of rounds so we start
209:00 - with plain text this zero two four six
209:02 - eight so on that's plain text one
209:04 - and the one below it one two four six
209:07 - eight is plain text two
209:09 - and of course they differ by just one
209:11 - bit single bit difference
209:13 - and the Delta column shows the number of
209:15 - bits that differ so at the start just
209:18 - one bit differs
209:20 - and then we encrypt through the
209:22 - different stages of deaths real deaths
209:24 - not simplified deaths and what this
209:27 - table shows is the output after each
209:30 - round
209:31 - this has 16 rounds
209:34 - so we take the input plain text we apply
209:37 - round one
209:39 - and the output if we encrypt plaintext
209:42 - one is this three c f
209:45 - and the output if we encrypt
209:48 - plain text 2 after round one is this
209:51 - three c f 0 3 and so on
209:55 - there's only one bit that differs
209:56 - between those two outputs
209:59 - so a small change in the input so far
210:02 - has only produced a small
210:04 - change in output that's not the
210:06 - Avalanche effective
210:07 - but with this we go through multiple
210:09 - rounds
210:10 - if we do the second round we get this
210:13 - output these two outputs they differ by
210:16 - five bits after three rounds differ of
210:20 - difference of 18 bits four rounds 34 and
210:25 - we keep going after our 16 rounds and
210:28 - our inverse initial permutation in this
210:31 - specific example 32 bits differ
210:35 - and that's what we aim for
210:39 - what we'd like is the two input plain
210:43 - text values which differ by just one bit
210:46 - when we encrypt both of them using the
210:49 - same key
210:50 - with like the ciphertext values to be
210:53 - completely different
210:56 - now remember with desk we use 64-bit
210:59 - blocks
211:04 - so the output
211:08 - ciphertext one and ciphertix 2 64 bits
211:12 - in length
211:21 - what we're like is that the difference
211:25 - is a random or appear random
211:28 - and on average if you have a 64-bit
211:30 - block
211:32 - we'd like at least half of the bits to
211:34 - be different
211:37 - 32 would be optimal it turns out to be
211:39 - 32 in this case but on all patterns
211:42 - because
211:45 - as an example let's say an 8-bit block
211:49 - let's say a cycle text is
211:54 - what's a ciphertext value which is
211:57 - different
211:59 - from C2 a C1
212:03 - significantly different
212:07 - we have a 8-bit ciphertext value to keep
212:09 - it small what's a value that is
212:11 - significantly different from C1 in this
212:12 - case
212:16 - so an example cycle text C1
212:20 - give me an example ciphertext right
212:22 - let's keep it simple
212:27 - what's the difference
212:29 - how many bits just one bit differs in
212:32 - this case so I would say that these are
212:33 - similar they're not much different
212:35 - so
212:42 - eight bits differ right that's
212:43 - significantly different but
212:48 - now if we have a random
212:51 - or another Cypher text value
212:59 - then we'd like on average if we consider
213:02 - all possible cyber text values on
213:05 - average we'd expect half of the bits to
213:07 - change
213:10 - because what if we have all the bits
213:11 - change and it's just the inverse all the
213:13 - time
213:15 - another random value may be
213:21 - eight bits how many bits differ one two
213:25 - three
213:27 - four
213:29 - just two random values four bits differ
213:31 - on average if we take two random
213:34 - ciphertexts we'd like half of the bits
213:36 - to differ
213:37 - so with this which has 64 bits in the
213:41 - block an avalanche effect ideally would
213:44 - produce half of the bits different after
213:46 - encryption and this specific instance we
213:49 - do 32 bits in other instances it may
213:52 - vary
213:53 - it's not always the same
213:56 - so that demonstrates that the Avalanche
213:58 - effect is in effect in this example and
214:00 - it is in general with deaths
214:03 - and it in fact turns out after about
214:06 - round four we have this difference of
214:09 - around 32 it goes up and down a bit
214:13 - so maybe we can just encrypt
214:15 - uh after four or five rounds and stop
214:18 - with this
214:19 - so the number of rounds
214:22 - generally the more rounds you add the
214:24 - more secure the output is but the more
214:26 - time it takes to implement
214:28 - so it takes time to do this processing
214:31 - so 16 was chosen as a trade-off of okay
214:35 - we see that four may be okay in this
214:39 - case but maybe in other cases we need
214:41 - five or six rounds or 16 is uh gives us
214:45 - some more freedom some in case uh for
214:49 - some cases which don't have the
214:50 - Avalanche effect until six seven eight
214:52 - rounds but it's not too many such that
214:55 - it's too slow to implement
214:57 - so choosing the number of rounds was an
214:59 - important design decision
215:04 - I've asked in exams or in assignments to
215:07 - measure the Avalanche effect of
215:08 - different ciphers and they see some
215:10 - examples later
215:12 - to understand what it means
215:15 - the second one is
215:16 - the same concept but
215:18 - take two plain text values which are the
215:21 - same
215:22 - these two values
215:24 - encrypt one with key one
215:28 - encrypt the same plain text with a
215:30 - different key differing just by one bit
215:33 - so going back
215:35 - the second example is plain texts are
215:38 - the same but the two keys that we use to
215:40 - encrypt differ by one bit in the first
215:43 - example the plain text values differed
215:46 - by one bit the key was the same
215:49 - and we see in this case where we change
215:53 - the key again after
215:57 - six seven eight rounds we're getting
215:59 - close to this about half bits are
216:01 - differing in output after
216:04 - the entire encryption 30 in this
216:06 - specific case on average if we try
216:08 - different values we'd like 32 it would
216:11 - be the average difference
216:15 - so Des has the Avalanche effect which is
216:18 - good
216:19 - and in fact it is achieved after just
216:22 - several rounds
216:24 - which means it's likely that the number
216:26 - of rounds of 16 is sufficient it was a
216:29 - good design choice
216:34 - what else about deaths the key size is
216:37 - not good
216:40 - the 64-bit initial key in death
216:43 - is actually split into two parts eight
216:46 - bits used for a parity check
216:48 - but not used in the encryption so only
216:51 - 56 bits are used in the encryption so an
216:54 - attacker really only using it only needs
216:56 - to guess those 56 bits
217:00 - which means there are 2 to the power 56
217:02 - possible keys or about 7 by 10 to the
217:05 - 16.
217:08 - in 1977 someone designed a machine they
217:12 - didn't build it they designed or
217:13 - estimated a machine that would break
217:16 - deaths in about 10 hours if it cost 20
217:19 - million US dollars so that's what 40
217:21 - years ago
217:22 - in 1998
217:24 - the electronic Frontiers Foundation
217:26 - built a machine that cost a quarter of a
217:28 - million US Dollars and they broke it in
217:30 - three days so a Brute Force dedicated
217:34 - Hardware
217:35 - to try desk keys
217:38 - they did it in about three days
217:40 - today it's considered too short to
217:42 - withstand Brute Force attacks
217:44 - 56 Pips is not long enough
217:49 - in general with this the algorithm is
217:52 - considered secure
217:54 - that limitation is the key size
217:56 - so the design people have done a lot of
217:58 - analysis than they find in most cases
218:01 - it's secure they can't find weaknesses
218:04 - in the algorithm
218:05 - but it has the weakness of the key
218:07 - length is too short
218:14 - so
218:16 - one approach then because many people
218:18 - had software and Hardware that
218:20 - implemented deaths being used a lot they
218:22 - trust the algorithm
218:24 - how do we make it more secure
218:27 - use it multiple times with a different
218:29 - key each time
218:33 - take a your plain text encrypt with Des
218:36 - with a 56-bit key you get some
218:38 - ciphertext
218:39 - then encrypt that ciphertext using Das
218:43 - again with a different 56-bit key
218:46 - and you get your ciphertext
218:48 - and now effectively you have 2 by 56-bit
218:51 - keys or 112 bits
218:54 - and a Brute Force against 112 bits
218:57 - is
218:58 - uh considered reasonably secure nowadays
219:02 - so the concept was
219:05 - reused deaths by applying it multiple
219:08 - times
219:11 - and a popular Cipher today and although
219:14 - no longer recommended but still widely
219:16 - used is triple deaths
219:19 - and that
219:21 - ignore this 128-bit Keys we'll look in
219:23 - details and see there are different
219:25 - options for the key length of triple
219:26 - deaths
219:27 - yes it uses 128 bits but there are other
219:30 - values
219:33 - we'll see that here
219:37 - what else about death
219:39 - there are some theoretical attacks on
219:41 - deaths
219:44 - timing attacks
219:46 - observe how long it takes your Hardware
219:48 - to encrypt and decrypt
219:51 - and use that information to try and work
219:54 - out what the original plain text or key
219:57 - was
219:58 - in theory possible in practice very easy
220:01 - to to defend against
220:03 - by changing the implementation of this
220:06 - to have some small variations in how
220:09 - long each operation takes
220:11 - and that makes these attacks these
220:13 - timing attacks almost impossible
220:16 - there are other attacks
220:19 - by observing how plain text values
220:21 - change over time looking at the
220:23 - differences there are some attacks
220:26 - so I remember brute force in death 2 to
220:29 - the power 56 operations that's the worst
220:31 - case
220:32 - this differential cryptanalysis attack
220:35 - and they could get it down to 2 to the
220:37 - power of 47 operations much better
220:43 - but
220:45 - it required the attacker to have 2 to
220:48 - the power 47 plain text values known in
220:51 - advance
220:52 - so they need to know a lot of plain text
220:54 - in advance for this attack to work so in
220:56 - practice not very useful
220:59 - and another one uh linear cryptanalysis
221:03 - got it about the same number of
221:06 - operations and they need 2 to the power
221:08 - of 43 known plain text values
221:11 - so if the attacker knows a lot of past
221:13 - plain text cyphertex pairs
221:17 - a lot in this case two to the power of
221:19 - 43 pairs then which is what
221:23 - 100 billion
221:25 - different pairs of cycle text plain text
221:28 - then they can do a tax on deaths which
221:32 - take about 2 to the 47 operations
221:35 - about
221:36 - a thousand times faster than a Brute
221:39 - Force attack
221:42 - still slow well today nowadays brute
221:45 - force is easy against deaths
221:47 - so
221:49 - because it can be broken in Brute Force
221:51 - these attacks people do not explore them
221:54 - much more because you just use brute
221:55 - force to break
222:02 - another issue with this was that
222:04 - originally was designed in private the
222:06 - people who designed it were for
222:08 - companies or governments and they didn't
222:10 - tell people how they chose
222:12 - all the values
222:19 - these are the S boxes from real deaths
222:21 - they tell us that we take some bits in
222:23 - we get some bits out
222:25 - why is it chosen this way
222:27 - or the designers chose it to be this way
222:30 - and there was no original motivation of
222:32 - well why did they choose these values
222:34 - why not some other arrangements
222:39 - it turns out that people have done
222:41 - analysis and found that even though they
222:43 - don't know the original motivations
222:46 - if you make small changes in the design
222:48 - it turns out the death is much less
222:51 - secure
222:53 - so small changes in those S boxes for
222:55 - example means that the Avalanche effect
222:58 - is not not as good and that there's more
223:01 - weaknesses in deaths which suggests that
223:04 - they chose the design to be strong they
223:07 - knew about other attacks
223:11 - so generally Des is considered a good
223:14 - algorithm but poor key length
223:20 - and definitely not not suitable today
223:26 - what about other Cycles
223:33 - triple deaths AES and other block Cycles
223:38 - so the next move since deaths was
223:40 - considered good to apply it multiple
223:43 - times we'll come back to this we'll look
223:44 - at
223:45 - double desk and triple deaths
223:49 - come back to these and look at an attack
223:51 - in some detail but it turned out that
223:54 - even triple deaths was considered secure
223:57 - it was three times as slow as death
224:00 - because in fact you apply the same
224:02 - algorithm three times so to encrypt
224:04 - something was three times slower than
224:05 - desk which wasn't fast uh in the start
224:09 - so
224:11 - the advanced encryption standard was
224:13 - developed designed in the the late 90s
224:17 - the idea was to make a secure of course
224:19 - but also to work well on different types
224:22 - of hardware
224:23 - and in software
224:26 - the advanced encryption standard is used
224:29 - and highly recommended for use today
224:32 - so still considered secure and it's
224:35 - recommended by the US government for
224:37 - example and many people use it in many
224:39 - different implementations
224:41 - in
224:42 - wireless LAN in internet communications
224:45 - in file 11 encryption so if you encrypt
224:48 - your hard disk with Windows or your
224:50 - operating system it usually uses a yes
224:54 - so it's very common
224:59 - it uses
225:01 - 128 bit blocks
225:05 - okay this was 64 bits AES 128 bits it
225:09 - allowed different size keys
225:12 - 128 192 256. so the longer the key the
225:17 - the more secure against Brute Force
225:21 - it used rounds
225:22 - and depending upon the key length it
225:24 - used different rounds 10 to 14 different
225:27 - rounds
225:28 - and used xor and some other s boxes and
225:32 - some other arithmetic that was a little
225:34 - bit more complicated than deaths but
225:36 - still considered secure
225:39 - we're not going to cover the details of
225:40 - AES
225:41 - we just used desk to show an example of
225:44 - one Cipher the other ciphers we will not
225:47 - go into that detail
225:49 - we just mention characteristics
225:52 - but
225:53 - a yes is considered a good Cipher to use
225:56 - that today
225:58 - generally considered secure
226:04 - and others
226:07 - a list of some not all block ciphers
226:11 - some of the designers when they were
226:13 - designed at some characteristics of the
226:16 - block size the key size
226:18 - the design approach the fastest
226:21 - structure is similar to what deaths used
226:23 - those rounds with substitutions
226:26 - permutations
226:27 - they all use similar approaches not the
226:29 - same
226:32 - some are more secure than others
226:34 - generally AES is considered a
226:37 - highly recommended
226:46 - let's go back to death
226:48 - double deaths and triple deaths
226:54 - so given death is considered secure but
226:57 - the key length is too short the idea to
227:00 - improve it was to apply it multiple
227:02 - times
227:06 - then you can reuse the software and
227:08 - Hardware that already implements this so
227:11 - and all the the experience of using it
227:13 - can be reused so encrypt multiple times
227:15 - each time you encrypt use a different
227:17 - key
227:18 - then for a Brute Force attack the
227:20 - attacker needs to guess all keys you use
227:24 - and effectively increases the key length
227:28 - turns out double desk is not so good and
227:31 - therefore triple death was designed so
227:33 - let's look at why double desk is no good
227:38 - that is and also the general concept of
227:40 - double encryption
227:42 - it's not just double deaths
227:44 - this is the idea
227:50 - we have some plain text
227:52 - normally
227:54 - we encrypt using some key and we get
227:56 - output ciphertext
227:59 - so Brute Force requires guessing that
228:01 - key
228:02 - with double encryption
228:04 - we take our plain text equipped with one
228:07 - key hit some intermediate value X then
228:10 - encrypt that intermediate value with the
228:13 - same Cipher but using a different key
228:16 - and then our cycle text is the output
228:19 - so
228:21 - our key is actually made up of two parts
228:24 - K1 and K2
228:27 - and they are they're different say two
228:30 - random keys so now what an attacker
228:33 - needs to do effectively our key length
228:36 - has doubled
228:37 - for Approved Force attack they need to
228:39 - guess both values
228:42 - they need to try all values and
228:44 - therefore if K1 is
228:48 - 56 bits like in death
228:51 - and K2 is a different 56 bits then the
228:54 - attacker for a Brute Force attack needs
228:56 - to try 112 bits that is 2 to the power
229:01 - of 112 operations
229:05 - so that was the idea of double
229:06 - encryption but it turns out it has a
229:08 - severe weakness
229:10 - and we'll use an example to go through
229:12 - that Witness
229:14 - so
229:15 - how that weakness arrives and the
229:17 - example you have one in your handouts
229:19 - but I created a bigger one which is a
229:21 - little bit more interesting so take one
229:23 - of these and pass along
229:27 - it's a cipher but a
229:33 - a block Cipher will use as an example
229:35 - you don't need to do other courses you
229:37 - can do other courses at other times try
229:40 - and solve this
229:43 - a few more
229:47 - enough
229:51 - okay
229:53 - just give this to your old shot on the
229:55 - screen and explain what it is we'll use
229:57 - it as an example
230:01 - three more with me
230:08 - first what what is this this is our
230:10 - let's say our our Cipher that we've
230:12 - designed
230:15 - it's
230:18 - a five bit block Cipher
230:21 - that is the block of plain text is five
230:24 - bits
230:25 - we take five bits of plain text we'll
230:27 - apply our Cipher we'll get five bits of
230:30 - ciphertext as the output so a five bit
230:32 - Block in this case to keep it small
230:34 - and we've got a three bit key
230:37 - so the way we read this table is that
230:40 - with a five bit input block there are 32
230:44 - possible plain text inputs
230:46 - two to the power five
230:48 - and I've listed them here on the left
230:50 - column
230:53 - and then what I've done is said that
230:55 - okay if we're using this particular key
230:57 - in the next columns the keys up the top
231:00 - zero zero zero for example if we take
231:03 - the ciphertext five zeros using key zero
231:07 - zero zero the output ciphertext will be
231:10 - zero zero zero one
231:12 - if I used a different key for example
231:15 - one one one here in the last column
231:18 - encrypt the same plain text the output
231:20 - ciphertext would be one one zero one
231:24 - that's the right way to read this this
231:27 - table
231:28 - plain text input
231:31 - different Keys along the top and the
231:33 - corresponding ciphertext that will get
231:35 - out of our Cipher when we use that key
231:38 - I've just randomly created this
231:41 - okay this arrangement and each of these
231:44 - columns are just randomly mixed them up
231:47 - if you you check you'll see that
231:49 - this this column with a key zero zero
231:53 - zero the 32 values here is just a random
231:56 - arrangement of the 32 possible plain
231:58 - text values
232:00 - so we have a reversible mapping
232:03 - we don't map one plain text to more than
232:07 - one ciphertext value there's 32 unique
232:10 - values here and I've just a different
232:13 - random arrangement in the second and the
232:15 - subsequent
232:16 - so that's our simple Cipher that
232:19 - we can encrypt any plain text five bits
232:22 - long and we'll get a ciphertext as
232:24 - output given one of the three bit keys
232:29 - consider this is our
232:32 - Cipher
232:34 - uh
232:37 - and we want to
232:39 - increase the key length so we have our
232:41 - Cipher like a desk
232:44 - but we want to apply it two times to
232:47 - increase the key length
232:49 - our double Cipher double encryption
232:53 - so what we do is we encrypt twice but
232:56 - using different Keys each time
233:00 - so the concept is let's call our Cipher
233:03 - ABC
233:05 - in the normal approach what we do is we
233:07 - take some plain text in
233:12 - our Cipher
233:15 - ABC
233:17 - takes a key as in
233:20 - and produces
233:22 - ciphertext's output
233:25 - and the the ciphertext it produces is
233:27 - given by that table
233:30 - let's say we want to do it differently
233:33 - and use double encryption we take our
233:35 - five and the plaintext is five fifths
233:41 - cypertext is five fifths
233:45 - and the key was three bits
233:50 - let's say we take our plain text in
233:57 - apply ABC Once with key one
234:04 - and then we'll get an intermediate
234:05 - output
234:07 - equal x
234:10 - and then apply the same Cipher again on
234:13 - the x value with a different key
234:17 - 2
234:19 - and we'll get our cyber text
234:23 - so that's our double encryption let's
234:25 - see how that works and see how
234:27 - we can attack that
234:31 - just to make sure people are awake
234:36 - with double encryption
234:46 - no we'll see how you're awakened when we
234:48 - go through our example
234:50 - um so
234:53 - we're going to do an attack on this
234:54 - Cipher
234:56 - first Brute Force attack
234:59 - on the single instance of the cipher
235:02 - what would approve how many operations
235:04 - does a Brute Force attack take in the
235:06 - worst case
235:09 - Brute Force
235:13 - on the single instance
235:16 - well we need to try all possible keys
235:19 - we have a three bit key so there are
235:22 - eight possible keys so a group Force
235:24 - takes two to the power of three or eight
235:26 - operations
235:34 - what about a brute force on our double
235:36 - Cipher
235:39 - how many operations
235:42 - calculate the number of operations
235:45 - to the power of 9.
235:49 - not
235:52 - how many keys do you get to choose from
235:57 - how many possible keys are think of the
236:00 - key in the double Cipher as just being
236:02 - a combination of those two a
236:04 - concatenation of those two
236:07 - that is
236:09 - to encrypt what I do is I choose K1
236:13 - one of eight and then I choose K2 one of
236:16 - eight
236:17 - so how many possible values do we have
236:24 - that is I can choose a three bit value
236:26 - here
236:32 - three bit value here
236:38 - we could say
236:41 - our resulting key
236:45 - is
236:47 - it's a K1
236:49 - combined with K2
236:53 - so how many keys do we have
236:56 - how many possible keys
237:05 - 64 where does that come from
237:11 - okay there's there are eight values for
237:14 - the first key
237:15 - there are eight possible values for the
237:17 - second key so let's say we choose the
237:19 - first value for the
237:21 - first key then we can choose one of
237:23 - eight values for the second if we choose
237:25 - the second for here we can choose one of
237:27 - eight we get eight times eight
237:30 - or
237:31 - two to the power of six
237:34 - we have effectively six bits
237:37 - okay three bits here three bits here the
237:40 - resulting key is the combinate or the uh
237:43 - concatenation of those two so
237:45 - effectively we have six bits
237:47 - we've doubled the key length
237:50 - with six bits our brute force would take
237:54 - two to the power of six
237:57 - or 64.
237:59 - operations
238:00 - of course easy to break but we'll see uh
238:06 - much stronger in theory than our single
238:10 - Cipher doubling the key length
238:18 - any problems so far
238:20 - on this concept
238:23 - so we double our key length by applying
238:25 - the cipher twice
238:27 - with respect to a Brute Force attack
238:35 - so if I give you a plain text oh sorry
238:37 - if I give you a ciphertext you
238:41 - if I give you a ciphertext output
238:44 - it's five bits you can try all 64 keys
238:49 - and one of them will give you the
238:51 - correct plain text which one is going to
238:53 - be hard to tell
238:56 - but in general when we have a large
238:58 - plain text and structure in the
239:00 - plaintext we'll be able to find
239:03 - now
239:04 - it turns out although a Brute Force
239:06 - attack takes 64 operations 2 to the
239:09 - power of six
239:10 - there's a what's called a meat in the
239:12 - middle attack which will take much less
239:14 - effort
239:17 - in fact the meat in the middle attack
239:18 - will show we can
239:20 - break this Cipher in about the same
239:23 - number as operations as a single version
239:25 - so let's try it
239:32 - so we're going to apply the double
239:33 - Cipher
239:35 - the meat in the middle attack assumes
239:38 - the attacker knows some
239:40 - plain text ciphertex pairs
239:43 - so that's the first Assumption of this
239:45 - attack and I'll give you some
239:47 - and we'll make use of them so the
239:49 - attacker now in the meat in the middle
240:10 - let's try and attack
240:12 - and
240:21 - the attacker for this attack to be
240:23 - successful needs to know some pairs of
240:24 - plain Tech ciphertax and I'll give you
240:26 - some
240:29 - I'll give you two to get started
240:59 - so how to interpret this is this is some
241:03 - plain tax value this is a ciphertax
241:05 - value let's call it P1
241:09 - c one
241:12 - and this is another plain text value P2
241:15 - and C2
241:19 - let's assume the attacker knows these
241:21 - values
241:24 - somehow they've discovered these values
241:27 - and
241:28 - they don't know the key
241:30 - the map the plain text to the ciphertext
241:33 - so they know these pairs their aim is to
241:36 - find the key
241:38 - so the aim for the attacker find the key
241:41 - given our Cipher
241:45 - and given these pairs
241:53 - a Brute Force attack we could take our
241:55 - ciphertext and try all 64 Keys one of
242:01 - them would give us this plain text and
242:03 - we'd know that key gives us the correct
242:05 - uh plain text and that's the key to use
242:09 - but we can be faster than a trying all
242:11 - 64. let's see how
242:14 - so the first step for the meeting the
242:16 - middle attack is that we take one of the
242:19 - known plain text cyphertex Pairs and
242:22 - starting with the plain text
242:24 - encrypted
242:26 - using all possible key values
242:29 - so we'll start with
242:33 - P1
242:42 - and encrypt P1 so Brute Force against P1
242:45 - but for a single version of the cipher
242:48 - so using different key values how many
242:52 - possible key values are there for a
242:53 - single version of the cipher
242:59 - that is let's go to our picture what
243:01 - we're going to do is the attacker
243:03 - is
243:06 - we've got a value of P
243:09 - we're going to encrypt that using our
243:12 - table with a all possible values of K1
243:16 - how many values well there are three
243:18 - bits so there are eight possible values
243:20 - of K1 and that's the the eight columns
243:23 - here okay one of zero zero zero through
243:26 - to K1 of 1 1 1. encrypt that plain text
243:30 - and we'll get eight values of this
243:32 - intermediate value X
243:36 - do that
243:43 - see what you get
244:17 - so you take that plain text and encrypt
244:19 - it with our Cipher our single version of
244:21 - the cipher and get eight values of this
244:25 - intermediate output I'll call it X
244:28 - uh
244:30 - PSI X
244:35 - 1 with K1 X11
244:41 - so when we take P1 0 1 1 0 1 and use key
244:45 - zero zero zero what do we get as an
244:48 - output
244:49 - well you look up the table
244:54 - our plain text
244:56 - zero one one zero one
245:02 - is here
245:09 - what you do is you take the plain text
245:12 - value
245:13 - encrypt it with the first key all zeros
245:16 - and this will be the value of the x that
245:18 - comes out
245:19 - our intermediate value
245:22 - and then do it again for the second key
245:24 - and you'll get this value and the third
245:26 - key through the eight key
245:29 - so we get these eight intermediate
245:31 - values that's the first stage of this
245:33 - attack
245:35 - what we're gonna what we're trying to do
245:36 - is to find the key in less than two to
245:39 - the 2 to the power of six operations in
245:42 - less than 64 operations
245:45 - the first case is encrypt a
245:48 - encrypt
245:49 - the plain text
245:51 - with eight keys so eight operations
245:55 - and you get these eight values as output
245:59 - I X values so I'll list them
246:06 - you can check I've got the answers in
246:09 - front of me but just from that table
246:10 - that row gives us the eight possible
246:12 - values
246:20 - if we encrypt using the second key
246:28 - the third key gives us
246:32 - one oh
246:37 - fourth key
247:03 - those eight values are just the row in
247:05 - that that table you check
247:07 - so the row where the plain text is zero
247:10 - one one zero one for the eight different
247:12 - keys
247:15 - so we just encrypt using our single
247:17 - Cipher that with all keys
247:25 - how many operations so far or eight
247:28 - operations one for each key
247:32 - next step is to take
247:35 - so we knew P1 and we know the
247:38 - corresponding ciphertext C1 what we just
247:41 - did is take P1 encrypt it with all
247:44 - possible Keys the next step is to take
247:47 - the corresponding ciphertext
247:49 - and decrypt it with all possible Eight
247:52 - Keys
247:55 - and we should get
247:57 - matching X values why
248:00 - look at our diagram
248:05 - our Cipher is if we encrypt p with all
248:08 - values of K1 we'll get these eight X
248:10 - values
248:12 - we know the corresponding ciphertext
248:15 - with e so if we decrypt C
248:17 - going backwards C going backwards with
248:20 - all possible values of the key then
248:22 - we'll get eight possible X values
248:25 - at least one of them those X values
248:27 - should match
248:29 - because if we use the correct key
248:33 - if we're using the correct key we take
248:35 - P1 encrypt with the correct key one we
248:38 - get an X
248:40 - if we have the ciphertext and decrypt
248:43 - with the correct key we must get the
248:44 - same X
248:47 - so from the attacker's point of view try
248:49 - C1 decrypted with all eight keys k2s to
248:54 - get a set of eight X ones
249:02 - encrypt the plain text
249:04 - with all keys decrypt the ciphertext
249:07 - with all keys with the aim of meeting in
249:09 - the middle
249:15 - so we know C1
249:27 - C1 is our all ones
249:33 - if we use the correct key if we encrypt
249:36 - P1 with the correct K1 and decrypt C1
249:39 - with the correct K2 which will get the
249:41 - same x value so let's try
249:45 - so given C1
249:47 - what is the plain text if we decrypt
249:50 - using key zero zero zero
249:55 - or we can see from the table
249:58 - if the ciphertext
250:01 - is all ones
250:05 - where are we the Cyber text is all ones
250:08 - here
250:13 - if we decrypt using key zero zero zero
250:16 - the plain text will be one zero zero
250:19 - zero one
250:24 - so we're going backwards now decrypting
250:26 - this table shows taking the plain text
250:28 - with the keys we'll get this ciphertext
250:31 - so to decrypt we find the ciphertext
250:35 - corresponding K column gives us the
250:37 - plaintext so decrypting this with key
250:40 - zero zero zero gives us one zero zero
250:43 - one
250:44 - so that's our first x value
250:46 - and then we do it for the next
250:50 - key
250:52 - so same ciphertext
250:57 - will give us this plain text 0 0 1 1 0.
251:01 - and then for subsequent years
251:06 - if I can find all ones
251:10 - we have it somewhere
251:13 - down here
251:16 - and so on
251:18 - okay so we take the ciphertext decrypt
251:21 - with all the Eight Keys
251:26 - and the values that we'll get I have
251:29 - them
252:13 - are those eight values so if you look up
252:15 - the ciphertext with each of those Eight
252:18 - Keys the corresponding plain text values
252:20 - will be these eight
252:22 - and what we said is that if we'd use the
252:25 - correct key
252:26 - the X values if we come from both
252:28 - directions should match
252:31 - which X values match
252:34 - none of them
252:35 - yes some of them do don't necessarily
252:37 - look in this way that is if I encrypt P
252:40 - P1 with this key I get this value
252:43 - if I decrypt the ciphertext with
252:46 - any of these Eight Keys these are the
252:49 - eight X values I get does this x match
252:54 - one of these eight and we check
252:59 - which ones match
253:01 - and how many
253:02 - try and find them
253:11 - you'll see that the first x value is not
253:14 - in the list
253:17 - one one one zero one is not in this list
253:21 - the second one
253:23 - zero zero one one do we have a currency
253:26 - yes we do
253:31 - there's a match here
253:33 - and then we do it for the rest and
253:37 - this one matches in two instances
253:49 - I thought it was in two instances
253:53 - yep
254:00 - you see now that the three sets of
254:03 - values that match that is here
254:06 - uh
254:10 - what have I yeah zero zero one one zero
254:13 - zero one one one
254:14 - zero one zero zero zero zero one zero
254:18 - zero zero
254:20 - what does that tell us it tells us the
254:23 - possible keys are
254:25 - either
254:27 - okay what so K1 tells us this value K2
254:30 - this value so K1 being 0 0 1
254:33 - and K2 being 1 0 0.
254:38 - or
254:39 - K1 is zero one one
254:42 - produce this x value
254:45 - and K2 being 1 1 1 or K1 K2 so it tells
254:51 - us that we've got three potential keys
254:53 - in this case
254:55 - let's list them
255:06 - okay one
255:08 - the first match is
255:12 - that's this value here and the
255:15 - corresponding K2 that gives us the
255:17 - correct ciphertext V100
255:25 - remember our our final key is just the
255:28 - combination of K1 and K2
255:31 - that's a potential correct key
255:34 - but there are two others as well
255:51 - and K1
255:55 - one zero zero a two or one
256:01 - so the attacker has now broken
256:04 - down to being three possible correct
256:06 - values
256:08 - how do we know which one's the real one
256:10 - we use our second pair of plaintiff
256:13 - cytotecs that we know so we assumed at
256:16 - the start that the attacker already knew
256:18 - two pairs of plantex cytotecs sometimes
256:21 - they need just one it turns out
256:23 - sometimes in many cases there'll be just
256:26 - one correct value and that's it you
256:28 - found the key if not you need a second
256:31 - pair and what we do now is check
256:34 - if we take P2 encrypt with K1 of 0 0 1
256:39 - we'll get some intermediate value
256:42 - then take the intermediate value and
256:44 - encrypt with K2 do we get C2
256:48 - if so this is the key
256:51 - if not try this one
256:53 - or this one
256:55 - which one is it
257:00 - so what you do now is take your P2 and
257:04 - encrypt with K1
257:06 - find the intermediate value then encrypt
257:08 - again with K2 and the ciphertext you get
257:11 - if this is the correct key pair
257:14 - or set of keys is C2
257:24 - let's look in the table
257:26 - P2 is 1 1 0 0 1.
257:30 - P2 is one one zero zero one
257:43 - and the first possible key was
257:48 - zero one zero is that right
257:52 - zero zero one
257:58 - so we try zero zero one
258:02 - encrypt P2 with zero zero one the
258:05 - intermediate value
258:08 - is five zeros and then take the
258:11 - intermediate value
258:12 - and encrypt it with K2
258:15 - so all zeros
258:20 - encrypt it with K2 and what was K2
258:23 - one zero zero
258:28 - we get
258:32 - this value as an output
258:34 - one one zero one one
258:39 - is it correct
258:41 - yes it is
258:44 - so what we just do we talk
258:47 - if I can fit it in here we took our
258:49 - plain text
258:51 - 11001
258:53 - encrypted with this key and the output
258:56 - was our intermediate value of all zeros
259:01 - and then we took that value encrypt with
259:03 - a second key and the output
259:06 - was one one
259:10 - zero one one
259:13 - and in fact that matches our expected
259:15 - ciphertext C2
259:18 - we've found our key already we're lucky
259:21 - in this case we didn't have to try the
259:23 - second two but you can try the second
259:25 - two and you'll see that they don't
259:27 - produce the correct ciphertext just to
259:30 - confirm you'll see that if you take P2
259:33 - with these two keys you will not get C2
259:36 - and the same with the second one
259:41 - so we have the answer
259:47 - the attacker knows the key
259:52 - it's zero zero one one zero zero
259:59 - how many operations did we take to do
260:01 - that
260:04 - how many encrypts or decrypts we treat
260:07 - encrypts and decrypts the same in terms
260:09 - of the amount of effort so how many
260:11 - well we can count them we took our plain
260:14 - text
260:15 - and tried all Eight Keys
260:18 - two to the power of three or eight
260:20 - operations there
260:22 - so in the first instance we took here
260:26 - 2 to the power 3 operations
260:29 - and then we did the same with our
260:31 - ciphertext try all keys so another 2 to
260:33 - the power of three operations
260:36 - and then we did One two operations here
260:39 - just to check
260:42 - so two in this case
260:46 - so the total number of operations 2 to
260:48 - the power of three plus two to the power
260:50 - three plus another two
260:56 - compare that to Brute Force
261:02 - our brute force is 2 to the power of six
261:04 - in this attack we had
261:11 - plus another two
261:17 - 18 operations
261:19 - or
261:21 - 2 to the power of three
261:23 - plus one
261:26 - plus those extra two
261:30 - to the power of three plus two to the
261:32 - power of three is two times two to the
261:34 - power 3 which is 2 to the power of three
261:36 - plus one
261:38 - plus another two small ones at the end
261:40 - sometimes we don't need to row those two
261:42 - at the end uh it will vary
261:46 - Brute Force 2 to the power of six
261:48 - operations
261:51 - meet in the middle attack two to the
261:52 - power of four plus a couple of others
261:59 - extend that from not a three-bit cipher
262:02 - to a 56-bit cipher of deaths
262:06 - our example we use a three bit key same
262:09 - concept applies in deaths if you use a
262:11 - 56 bit key
262:13 - brute force in death
262:18 - would take and running out of space but
262:21 - in death
262:23 - brute force would take 2 to the power of
262:25 - 112.
262:27 - with a 56-bit key but the meat in the
262:30 - middle attack we see with a three bit
262:33 - key is 2 to the power of three plus one
262:36 - plus a few others
262:38 - turns out that this is usually quite
262:40 - small compared to this
262:42 - so it turns out with
262:44 - and
262:45 - 2 to the power of two times three for
262:48 - brute force with this Brute Force 2 to
262:51 - the power of 12 with a meat in the
262:53 - middle on S is 2 to the power of 56
262:57 - plus one
262:59 - plus some others
263:02 - and usually that's quite small it's a
263:05 - compared to two to the power of 56. so
263:08 - approximately
263:11 - two times
263:12 - normal deaths
263:17 - and meet in the middle attack on double
263:19 - deaths takes about twice as much of
263:22 - effort as a brute force on single deaths
263:26 - double desk is about
263:28 - two times stronger than single deaths
263:30 - which is nothing
263:32 - so if single desk takes two days to
263:36 - break double desk takes four days
263:39 - which is nothing in terms of security
263:41 - it's not secure
263:43 - or if it cost a thousand dollars to
263:45 - break deaths it costs two thousand
263:47 - dollars to break double discs so using
263:48 - double desk doesn't provide much
263:50 - advantage over single deaths because of
263:53 - the meat in the middle attack
263:58 - hence double death is not used and in
264:00 - general double encryption okay this is a
264:02 - problem with double encryption turns out
264:04 - by using three stages not two we can
264:07 - overcome this meat of the middle attack
264:12 - and that's where we get to Triple deaths
264:15 - and that's what's used in practice today
264:22 - so we're out of time so
264:26 - try and get your heads around how to do
264:28 - a meet in the middle attack on double
264:31 - encryption
264:32 - but in summary we need some known plain
264:36 - text cycertex pairs that's an assumption
264:38 - the attacker knows these values at the
264:39 - start
264:40 - just two normally even with real deaths
264:43 - you don't need to know many
264:46 - you take a plain text encrypt with all
264:50 - possible keys
264:51 - 2 to the power of K
264:54 - if our single single cipase K bit key
264:57 - length and then take that corresponding
264:59 - ciphertext and decrypt with all possible
265:01 - Keys another 2 to the power of K
265:06 - and then if you find the matching ones
265:09 - and if you have more than one then try
265:11 - the second pair
265:13 - and usually there's not many that are
265:15 - that are matching so it doesn't take
265:17 - many further operations to do those
265:19 - second second pair and then you find the
265:21 - key
265:23 - so double encryption doesn't help
265:27 - triple encryption
265:29 - avoids this problem
265:31 - let's stop there
265:34 - next week we'll move on to the next
265:36 - topic of using modes of operation how do
265:38 - we encrypt a large document these are
265:41 - operating on 64 bits 128 bits what
265:43 - happens if we have one megabyte and then
265:46 - move on to I think public key encryption
265:50 - maybe next week we'll get on to that
265:57 - if you want to collect your hard copies
266:00 - of your quiz you may do so
266:08 - they're in alphabetical order so you may
266:10 - find your name
269:10 - so this topic we're going to get to very
269:13 - cover very briefly stream ciphers and
269:16 - relate it to that
269:17 - and a very important part of many
269:19 - security algorithms is random numbers
269:22 - okay so we'll talk first about random
269:24 - numbers and then some quick examples of
269:27 - stream ciphers and then return and look
269:30 - at brute force and other attacks on
269:31 - cyphers in general
269:36 - with our block Cipher
269:38 - with
269:40 - AES for example
269:42 - it operates on a block of 128 bits at a
269:45 - time
269:46 - and one mode of AES I use 128 bit key
269:53 - and to use a a block Cipher a symmetric
269:57 - Cipher
269:59 - the encrypter and decrypter must know
270:01 - the same key okay so we encrypt with one
270:04 - key we decrypt with the same key that's
270:07 - the idea of a symmetric cycle
270:11 - how do we choose a key
270:15 - choose 128-bit value 128-bit key
270:21 - anyone how are you going to choose one
270:29 - uh
270:31 - what about and I will not write all 128
270:34 - bits but what about this as a key if I
270:37 - choose a key I want it to be secret but
270:39 - I'll tell you okay
270:44 - all zeros
270:45 - 128 bits and maybe a one at the end
270:49 - decimal one
270:51 - I chose that as my key and I tell you
270:54 - the person I want to send a message to
270:56 - and what I do is I take my data my file
270:59 - I encrypt using AES using this 128 bit
271:03 - key you know the key so you can decrypt
271:09 - is that okay secure
271:12 - why why is it what's wrong
271:15 - all right everyone knows but let's say I
271:18 - trust you and we don't want uh someone
271:20 - from uh it section to know so
271:24 - what can an attacker do
271:27 - to try and decrypt the ciphertext that
271:30 - we get so I take some plain text
271:32 - encrypt
271:34 - using this key and I get some ciphertext
271:38 - the attacker has the side for text
271:42 - assuming we have a strong Cipher
271:45 - there are no known attacks against the
271:46 - cipher what's the what can the attacker
271:48 - do
271:50 - to try and break the ciphertext to get
271:53 - the plain text
271:55 - what can they do
271:58 - they don't know the key
272:00 - what can the attacker do
272:03 - come on you you need to be think like a
272:05 - malicious person
272:06 - I know Brute Force generally brute force
272:10 - or trying guess Keys okay Brute Force
272:14 - means gas a key
272:17 - that is take the ciphertext let's as an
272:20 - attacker guess choose some random key
272:24 - decrypt and see if the plain text we get
272:27 - from decryption makes sense if it does
272:29 - we've found the key
272:31 - okay if it doesn't we try a different
272:32 - key we guess a different key and we keep
272:35 - guessing keys until we get one that
272:39 - decrypts successfully
272:42 - now maybe as an attacker instead of
272:45 - getting random Keys maybe you'd start
272:48 - with some uh structured keys
272:52 - what if maybe I'll try all zeros as a
272:56 - key as the attacker guess that one first
272:58 - and maybe try this key second
273:02 - yes it can be a random value but the
273:05 - attacker
273:07 - if they have some knowledge about how
273:09 - you may choose the keys
273:12 - they can use that to try and try those
273:14 - keys first
273:16 - which gives a much more chance of
273:18 - finding the plain text
273:19 - brute force is going to take too long
273:21 - but if they can try the keys all zeros
273:26 - or ones
273:29 - 127 zeros and one one
273:32 - then immediately they found the plain
273:34 - text
273:36 - the point is
273:38 - if you want to prevent a Brute Force
273:41 - attack
273:42 - when you choose a key you should choose
273:45 - random keys
273:48 - if you choose a key okay let's just use
273:51 - all ones
273:52 - because it's easy to write down
273:54 - then it's not random
273:56 - and the attacker can take that knowledge
273:58 - okay Steve's lazy he just chooses Keys
274:00 - which are easy to write down and he'll
274:03 - try them first and find the the plain
274:06 - text so
274:08 - when you choose a key it should be a
274:11 - random value
274:13 - similar when you choose a password for
274:15 - your login for Moodle which should be a
274:17 - random password a random set of
274:19 - characters everyone chooses random
274:20 - passwords
274:22 - for your bank account your Hotmail your
274:25 - or your no one chooses random passwords
274:28 - okay we'll come to that in another topic
274:30 - uh because random passwords for humans
274:33 - are hard to remember
274:35 - but for computers
274:37 - because usually the user doesn't have to
274:39 - remember the key we'll see that it's
274:40 - usually software
274:42 - choosing the key
274:44 - so they can random choose a random value
274:47 - and store it in memory or on disk and
274:51 - encrypt using the random key
274:54 - so we need to use random numbers
274:57 - to generate keys for encryption
275:03 - many other aspects of security network
275:06 - and and security protocols make use of
275:09 - random numbers
275:11 - and that's why we're talking about
275:13 - random numbers now because they in fact
275:15 - used in many parts of security one of
275:17 - them is choosing keys but there are
275:19 - other parts where we use random numbers
275:24 - how do you choose a random number
275:30 - come on you've all had almost two weeks
275:32 - holiday or maybe holiday uh
275:36 - so you're all your brains are refreshed
275:39 - yeah
275:41 - to choose a random number use the
275:43 - current time okay is the time random
275:48 - sorry
275:52 - use the time to generate a fake random
275:54 - number
275:55 - the time's predictable it's not random
275:57 - the time now
275:59 - and the time in one second time I can
276:01 - predict what that is the time is not
276:03 - random what can we do with it
276:09 - throw a dice okay so every time I wanted
276:13 - I want to choose 128 bit key
276:16 - so what do I do get a a die
276:19 - 128 side die and roll it uh
276:26 - or two side and roll it 128 times
276:30 - flip a coin
276:32 - okay not very convenient
276:34 - how you get a computer to Generate
276:36 - random numbers
276:44 - you use a function what function
276:47 - on your computer scientists give me an
276:49 - example
276:51 - Rand use the Rand function okay great
276:54 - now your task is to implement a new Rand
276:57 - function how you're going to implement
276:59 - it
277:00 - what does a Rand function do
277:05 - it's not magic it
277:07 - follows some steps you can't just rely
277:09 - on that all the time so is how would the
277:12 - Rand function in your programming
277:14 - language be implemented
277:17 - how do you think a computer can Generate
277:20 - random numbers
277:25 - anyone
277:28 - use the the ID of the CPU or uh of the
277:33 - process the software process
277:35 - uh uh usually not random usually limited
277:38 - between zero and sixty five thousand or
277:41 - so uh there's not many values to choose
277:44 - from I suspect it's not very random I
277:47 - want to choose a a value of 128 bits
277:49 - length
277:52 - and I think there'll be some structure
277:54 - in the processes the first process will
277:56 - always be process ID one say on our Unix
277:58 - system
278:02 - where do you generate how do you
278:04 - Generate random numbers okay let's try
278:06 - easily
278:08 - how do you Generate random numbers I ask
278:11 - you choose a random number between one
278:13 - and one million
278:18 - or too slow for my software okay anyone
278:20 - else
278:21 - how do you Generate random numbers
278:25 - well it's hard to describe isn't it
278:27 - how do you remember a computer just does
278:30 - what we program it to do
278:33 - okay we program a computer from the very
278:35 - Basics the Assembly Language to program
278:38 - you know the operations so
278:41 - to implement that Rand function
278:45 - in C or in whatever language you use we
278:48 - must program some function
278:52 - so in most cases
278:54 - we actually don't you create real random
278:58 - numbers or true random numbers we use
279:00 - some function that approximates random
279:03 - numbers
279:04 - and we'll go through some functions some
279:06 - are very simple
279:07 - some are more complex but it's really
279:10 - just a function that takes some input
279:13 - and produces hopefully some numbers
279:15 - which look random
279:18 - so it's not easy to create random
279:20 - numbers
279:22 - in many cases with our computers we
279:25 - generate what we'll call pseudo-random
279:27 - numbers
279:29 - not quite
279:32 - not not really random but approximately
279:36 - okay so we often call them pseudo-random
279:39 - numbers not true random numbers so let's
279:43 - let's explore that a bit further
279:46 - and see how computers May Generate
279:48 - random numbers
279:54 - why do we need random numbers in
279:56 - security
279:57 - select Keys we need to random numbers
279:59 - and we need to do it fast
280:02 - and so we can't just roll it roll a dice
280:05 - manually we need software to implement
280:08 - to choose a random number and be able to
280:10 - do it quite quickly and repeatedly
280:13 - and there's a number of other so
280:15 - generating keys
280:16 - uh we'll use them in stream ciphers
280:19 - authentication we'll see these Concepts
280:22 - or Technologies later they all make use
280:25 - of random numbers
280:26 - so we need random numbers
280:29 - what do we mean by Randomness
280:34 - a uniform distribution
280:38 - is one measure there are others it's not
280:40 - the only one but think of a sequence of
280:42 - numbers
280:45 - then
280:47 - we'd expect if it's a binary value
280:51 - we'd expect on average for a long
280:53 - sequence we'd have the same number of
280:55 - zeros and ones
280:59 - so
281:01 - a long sequence say if we consider many
281:04 - many random numbers binary say millions
281:07 - of bits
281:09 - we'd expect not all of those best to be
281:12 - zero if all of those one million bits
281:14 - were zero I would guess that that's not
281:16 - a random number
281:18 - so we'll have to expect uh the same
281:22 - frequency of ones or zeros that we
281:24 - consider a a binary value
281:29 - but not necessarily 500 000 ones
281:32 - followed by five hundred thousand zeros
281:35 - same number of ones and zeros
281:38 - but we'd look at subsequences
281:42 - instead of looking at all one million
281:43 - look at five hundred thousand we'd
281:45 - expect approximately half of them to be
281:47 - zeros and ones as well
281:50 - solves different subsequences we'd
281:52 - expect a uniform distribution of our
281:54 - zeros and ones
281:58 - that's one measure or one way that we we
282:02 - try and interpret randomness
282:04 - another one is the independence
282:07 - take a sequence of numbers
282:11 - the next number in the sequence should
282:13 - not depend upon the previous numbers
282:16 - or at least it should be very hard to
282:18 - see the relationship
282:20 - we'll see with pseudo-random numbers
282:25 - let me generate a random sequence of
282:27 - numbers
282:32 - I'm going to write some numbers let's
282:33 - say I have a random number generator
282:37 - and I call it many times okay my code
282:40 - calls the Rand function many times and
282:42 - it returns these values the first value
282:44 - it returns is 10 that's working decimal
282:46 - the second value it returns is 20.
282:49 - the third value is 30.
282:52 - and then 40.
282:54 - what do you think the and then 50 what
282:57 - do you think this value is going to be
283:01 - we'd say that this value
283:03 - is not in
283:06 - independent of the previous values it's
283:08 - actually dependent on the previous value
283:10 - we see there's a pattern here
283:13 - is this a random sequence
283:15 - no there's some structuring
283:20 - this the next value in our sequence was
283:24 - dependent on the previous values and
283:26 - here it's quite obvious it was dependent
283:30 - what about this
283:43 - what's the next value
283:47 - a sequence of numbers generated by the
283:50 - Rand function the first time I call it
283:52 - 17 then 26 then 93 1 52 what's the next
283:57 - value
284:06 - what's the next value
284:09 - what do you think
284:13 - and I'll give you a hint it's been
284:14 - between zero and one hundred
284:28 - I don't know that is there's no pattern
284:30 - in this case I tried to choose them
284:33 - randomly in my head in this case so we'd
284:35 - say that we have a sequence and we
284:39 - cannot see any dependence between the
284:41 - numbers
284:42 - whereas in the first sequence we could
284:44 - see the dependence that they're
284:45 - increasing by 10.
284:47 - in this case we cannot see the
284:49 - dependence between the numbers
284:51 - and that
284:52 - hopefully this next one is into
284:55 - independent of the previous ones it
284:58 - doesn't depend upon the previous values
285:00 - if so then we generate a random sequence
285:03 - of numbers so we'd like Independence
285:06 - of our numbers
285:08 - so that given one value we cannot infer
285:12 - what the next value would be so you
285:14 - couldn't guess what this would be well
285:16 - you couldn't correctly guess
285:19 - uh because you there's no dependence
285:22 - between those numbers so that's what
285:24 - we'd like in a random number generator
285:28 - and that another way to interpret that
285:31 - is it's hard to predict the next value
285:33 - okay and that's an important property
285:36 - for
285:38 - security we'll see why soon
285:46 - so we distinguish between
285:48 - [Music]
285:49 - true random number generators
285:52 - and pseudo random number generators
285:54 - sometimes shorteners prng
285:57 - pseudo-random functions let's let's
286:00 - ignore that
286:01 - we're not talk about that keep it simple
286:05 - a true random number generator
286:08 - uses some physical source
286:11 - some non-deterministic source to
286:14 - Generate random numbers
286:17 - non-deterministic means it's not
286:19 - predetermined
286:20 - we do not have some algorithm for
286:22 - generating them
286:24 - some examples of such sources something
286:27 - that measures radiation events
286:30 - in in the physical environment uh
286:33 - radiation measurements of radiation from
286:36 - some source is in is considered to be
286:39 - random or as close as random as as we
286:41 - know in physics
286:44 - similarly if we have capacitors on some
286:47 - electronic uh set of
286:50 - on a motherboard for example or on on a
286:52 - circuit board the measurements from
286:55 - those capacitors
286:57 - usually exhibits randomness
287:01 - some noise from different electronic
287:03 - components
287:05 - it's considered that the noise is not
287:08 - predictable it's random
287:12 - uh or some noise from some audio system
287:14 - okay some the noise that's come comes
287:17 - out of the the speakers through the the
287:19 - audio system is often considered random
287:23 - truly random
287:27 - so yes we can use in computers some of
287:30 - these sources okay
287:32 - well
287:33 - we'll talk about that
287:35 - uh okay and then
287:38 - maybe a little bit less so but still
287:41 - often considered true random is
287:42 - different physical activities if we
287:45 - think about a computer
287:46 - uh measuring
287:48 - the difference between the times of i o
287:52 - input output operations on a hard disk
287:54 - okay the the rights and the reads on the
287:56 - hard disk uh over different periods of
287:59 - time uh in some cases exhibits true
288:03 - randomness
288:04 - or interrupts in fact usually combining
288:07 - these together not just one but looking
288:09 - at the time in which software or
288:12 - interrupts occur on from a piece of
288:14 - hardware
288:15 - disk read write operations activity on a
288:19 - keyboard even on a mouse can start to
288:22 - exhibit true randomness
288:26 - all of these true random number
288:28 - generators usually require some physical
288:30 - device to measure them
288:32 - okay
288:34 - how do I get random numbers out of some
288:37 - radiation or leaky capacitors I need
288:39 - some special device to measure the input
288:43 - and then convert it into binary for our
288:45 - random numbers
288:47 - and usually they generate just a small
288:49 - number of values over a period of time
288:53 - so because they need physical devices
288:56 - to implement random number generators
288:59 - using true sources on on computers is
289:01 - usually costly or inconvenient
289:04 - so it's not so calm
289:08 - who has a radiation measuring device on
289:12 - their laptop
289:13 - no one okay
289:15 - so how do you get random numbers on your
289:18 - laptop
289:19 - how does the Rand function work well we
289:21 - use what's called pseudo-random number
289:23 - generators
289:25 - we use some algorithm or function to
289:27 - calculate numbers
289:30 - and output a sequence of numbers
289:33 - such that hopefully if it's a good
289:35 - algorithm those that sequence of numbers
289:39 - appears to be random
289:42 - it's not truly random but for most
289:45 - practical purposes it's random enough
289:48 - relatively random sequence
289:51 - but note it's a deterministic algorithm
289:55 - the algorithm is implemented follows
289:57 - some steps so in theory you can
289:59 - determine the next value
290:02 - you can determine what the values are
290:04 - going to be in the sequence in practice
290:06 - it just needs to be hard to predict the
290:08 - next value
290:11 - so in practice
290:13 - most computers use pseudo-random number
290:15 - generators some special cases may use
290:18 - true random number generators
290:25 - for example you buy CPUs now like an
290:28 - Intel or an AMD CPU and they have
290:31 - inbuilt their own operations to Generate
290:34 - random numbers
290:36 - and it's thought that they take some
290:39 - measurements of what the CPU is doing
290:41 - to get some input of randomness and that
290:45 - can be used as a true random number
290:48 - generator
290:57 - so to use in a computer system where we
291:01 - need a
291:02 - generate a random number or a sequence
291:04 - of bits
291:06 - if we have a
291:08 - source of true Randomness we can measure
291:10 - that
291:11 - and then convert it into binary and we
291:13 - get our random stream of bits
291:17 - but that requires some physical
291:19 - measurements usually and it's
291:20 - inconvenient so in a pseudo-random
291:22 - number generator what we do is we just
291:24 - have some algorithm
291:26 - that takes some initial input some
291:28 - initial value
291:30 - and with random numbers it's called the
291:31 - seed value
291:33 - and that algorithm takes that c produces
291:37 - an output and usually has some feedback
291:39 - the next value is fed back and produces
291:41 - the the next value
291:44 - so we generate a stream of bits if we
291:47 - look in binary and that's a
291:50 - pseudo-random number generator
291:55 - let's go straight to an example
291:58 - we'll come back to some of the things we
292:00 - skip the linear congruential generator
292:02 - lcg
292:04 - an example of a simple
292:08 - pseudo-random number generator simple to
292:10 - explain and go through a few examples uh
292:14 - here it is
292:16 - the idea of random number generators is
292:18 - they generate a sequence of numbers
292:20 - where that sequence should appear random
292:27 - so this function or algorithm is defined
292:30 - here
292:31 - where it takes several parameters
292:34 - the idea is that we have three constants
292:37 - a C and M
292:41 - a is a multiplier
292:42 - C is just some
292:45 - value that we add
292:47 - and we
292:50 - take the current value of our random
292:54 - our current random value
292:57 - and multiply by a add C and mod by m the
293:01 - modulus
293:02 - and that produces our next random value
293:05 - in the sequence
293:08 - and to generate the next value then we
293:11 - use the the previous one again and use
293:13 - the same function and generate hopefully
293:15 - a random sequence so just let's see how
293:18 - that works in practice and then we'll
293:20 - come and discuss
293:22 - some of the design issues
293:29 - so what we need to do is choose values
293:32 - of these constants a C and M
293:35 - so the constants for this algorithm
293:38 - and we have an initial value
293:42 - X 0.
293:44 - we need to start with some value that's
293:46 - called our seed value so we'll choose a
293:48 - seed value
293:51 - so I'll give you some parameters and
293:53 - you'll calculate some of the values in
293:54 - the sequence
293:59 - let's say to get started we choose
294:03 - uh
294:05 - we're using lcg
294:10 - and
294:11 - the parameters you can try
294:15 - let's keep it simple a is one C is one
294:20 - m is 100
294:24 - and we start with an initial value a
294:27 - seed value x0 of let's say 23.
294:33 - no significance of the sea
294:35 - generate the next few numbers in the
294:38 - sequence using the lcg function
294:42 - see what happens
294:43 - so use those three constants in that
294:46 - algorithm in that equation and the
294:48 - initial value x0 and see what X1 is and
294:52 - X2
294:54 - and that will be our sequence
294:57 - generated by this pseudo-random number
294:59 - generator
295:04 - so find X1
295:07 - when you have X1 you can find X2 and X3
295:25 - anyone have the values of the the first
295:27 - 10
295:28 - X1 through to X10
295:36 - so simply look at that equation x n plus
295:39 - 1 equals a x n plus C Mod m
295:43 - you have the constants AC and M you have
295:46 - x0
295:47 - so from that you can calculate X1
295:51 - n equals zero
295:54 - so you'll get X1 as the output
295:57 - then do it for the first few values what
296:00 - do you get
296:02 - keep going
296:14 - values come on come on give me some
296:16 - random numbers
296:28 - no need to use your computer to
296:31 - calculate I think you can calculate
296:32 - addition and multiplication by yourself
296:38 - but fine use your computer
296:40 - see if this random number generator is
296:42 - as good as the one that the Mac OS uses
296:47 - excuse me
296:50 - X1
296:53 - 24.
296:55 - keep going X2 X3 X4
297:10 - let's see so simply a times x n the
297:15 - current value plus C Mod m
297:18 - m is 100
297:20 - C is one a is one so in fact we forget
297:24 - about a because it's multiplied by by
297:26 - one so it's the current value plus one
297:28 - mod 100.
297:31 - so the current value
297:34 - plus one
297:37 - mod 100.
297:43 - 24.
297:45 - X2
297:51 - be 24 plus 1 mod 100.
297:58 - so we say x our sequence
298:05 - we're starting with x0 our C was 23 and
298:09 - if we write the sequence of numbers I
298:11 - think you'll see 24
298:13 - 25
298:16 - we just PL add one all the time up to
298:19 - where
298:26 - 99
298:29 - what's after 99.
298:32 - zero mod 100
298:39 - and
298:40 - eventually we'll get back to
298:43 - 23.
298:50 - that's a comma
298:55 - okay all right not a very good random
298:58 - sequence
299:00 - so this is
299:03 - our random number generator but with the
299:05 - set of parameters we've used it's not
299:07 - very good
299:08 - okay so we'll change the parameters in a
299:10 - moment
299:11 - uh so we just increment by one so uh not
299:16 - a good random sequence but we the aim is
299:19 - to generate a sequence of numbers which
299:21 - is appears random
299:23 - this one doesn't appear random it's
299:25 - obvious in this case now uh but some
299:28 - characteristics
299:32 - note that when we get back to 23 if we
299:35 - keep going we'd be back to 24 25 and we
299:38 - just repeat all the time
299:40 - we'd get back to 23 and repeat
299:42 - re repeat so the set of unique values is
299:47 - called the period or the length of those
299:49 - unique values is the period of this
299:52 - sequence
299:55 - what's the period of this sequence or
299:57 - how many values
299:59 - so the period in this case goes from
300:05 - here up to 22 in fact
300:09 - so 23 all the way through to 22 and how
300:13 - many values there
300:15 - 100
300:24 - the period of this sequence we have 100
300:27 - different values generated here
300:32 - we'll return to what we why that's
300:35 - significant after we see a few other
300:36 - sequences
300:38 - let's try again but with some different
300:40 - parameters
300:47 - and see if we can get a better random
300:49 - sequence one that it looks more random
300:53 - let's try our lcg
300:55 - same algorithm
300:57 - but
300:59 - let's try
301:02 - a is seven
301:04 - C is zero
301:07 - and M is 32.
301:13 - and
301:15 - a seed of
301:18 - one
301:21 - generate the the set of sequence numbers
301:24 - with this configuration of the lcg
301:31 - easy tasks
301:36 - same algorithm different parameters
301:39 - a is 7 C is zero m is 32.
301:44 - okay
301:53 - X1 what value do you get
302:04 - remember we have a times x zero
302:08 - seven times one plus c
302:12 - all mod m
302:15 - foreign
302:25 - and X2
302:48 - foreign
302:53 - to keep your brains working I know
302:57 - some simple mathematics
303:04 - X2 17 someone's got 17 that sounds
303:08 - familiar
303:10 - X2 17.
303:18 - again
303:20 - no problem
303:22 - seven a times our previous value
303:26 - all right
303:29 - a times our previous value which was
303:31 - seven plus zero mod 32.
303:35 - 49 Mod 32
303:38 - 17.
303:41 - X3 and you'll do the same 7 times 17
303:44 - which is
303:47 - 119 Mod 32
303:51 - 23. good
303:55 - you can check
303:57 - X4
303:58 - 7 times 23 which is 161 mod 732
304:06 - is 1.
304:07 - okay
304:09 - X5
304:12 - it's seven again we're back we're
304:14 - repeating again okay because if we have
304:17 - one we've already got to one so from one
304:19 - the input will be seven again we repeat
304:23 - so we can say this sequence in this case
304:26 - X
304:30 - we start at one
304:33 - seven
304:36 - twenty three
304:41 - a period of four
304:46 - there are just four values generated
304:48 - with this sequence and then we repeat
304:57 - in the previous sequence
304:59 - we had a period of 100. we'll see the
305:03 - longer the period the better
305:06 - but not necessarily the better random
305:07 - sequence okay we saw would we have 23 24
305:11 - 25 definitely not random
305:13 - looks a little bit more random
305:16 - it's not one two three four five but
305:20 - can we do better
305:22 - well if you change the parameters around
305:25 - you can start to get more random looking
305:28 - sequences so it's all about with this
305:31 - algorithm choosing the correct parameter
305:32 - values uh we'll not go through it I'll
305:35 - give you a
305:36 - one that you can check later another
305:39 - configuration
305:43 - uh
305:45 - a is five
305:49 - C is zero again m is still 32.
305:55 - with the same seed of one
306:02 - we get and I've calculated it before one
306:07 - five
306:09 - 25
306:14 - 29
306:18 - 17 21
306:22 - 9 13.
306:26 - and then we go back to one
306:33 - a period of
306:38 - eight
306:42 - so we have a very simple algorithm
306:46 - with several parameters and it turns out
306:49 - with this algorithm if we choose the
306:51 - parameters well so some parameters are
306:54 - not good
306:55 - the first set were terrible because we
306:57 - just got incrementing numbers
307:00 - if we choose them well though
307:02 - we can generate quite good random
307:05 - sequences this sequence 1 5 25 29 17 21
307:09 - 9 13. can you see any structure there
307:13 - nothing obvious okay
307:16 - there is structure because it comes from
307:18 - an equation okay
307:20 - but the sequence at least very simple
307:24 - example
307:26 - it looks to have some randomness
307:28 - especially compared to the first
307:30 - sequence which was just incrementing
307:31 - numbers
307:32 - the third one compared to the previous
307:34 - one all right there's only four numbers
307:37 - there in general the longer the period
307:39 - the better
307:41 - we desire a long period
307:44 - that is a large number of numbers before
307:47 - we repeat
307:52 - with lcg how do we make the period
307:55 - longer
308:00 - what's all right in theory what's the
308:02 - maximum period
308:04 - uh
308:08 - it's m
308:10 - okay this
308:13 - equation
308:16 - take some value mod m
308:19 - so the answers are always going to be
308:21 - between 0 and M minus 1. we can never
308:25 - have an answer which is larger than or M
308:27 - or larger because we mod by m
308:30 - so the period is limited by m in this
308:32 - case
308:34 - so if you want a large period
308:37 - make M large
308:41 - and some recommended values for using
308:44 - lcg in practice is to make M as large as
308:46 - possible and it turns out it's good if
308:48 - it's a prime number modding by a prime
308:50 - number
308:51 - will give us more distinct values in in
308:55 - the result
308:57 - so choose the the
309:00 - a prime number as large as possible
309:03 - well that depends upon your your
309:06 - computer say if you've got 32-bit
309:08 - numbers
309:09 - uh a large prime number is 2 to the
309:12 - power of 31 minus one people have found
309:14 - that before
309:16 - which means the maximum possible period
309:20 - if you use this value of M is about 2 to
309:22 - the power of 31.
309:24 - okay about 2 billion
309:27 - so you can have up to about two billion
309:30 - different values
309:32 - in your random sequence then you'll have
309:34 - to repeat
309:35 - guaranteed you'll have to repeat
309:39 - and
309:40 - you need to choose values of A and C
309:42 - which are good
309:44 - the first values we chose were not good
309:46 - some people have done analysis and found
309:48 - out if C is zero some there are several
309:51 - good values of a one is turns out
309:53 - sixteen thousand eight hundred and seven
309:56 - try
309:57 - set C to 0 a to sixteen thousand eight
310:00 - hundred and seven M to 2 to the 31 minus
310:04 - one choose a seed
310:06 - choose x0 and start calculating the
310:09 - sequence of values and you'll see you'll
310:12 - get a very long sequence of different
310:14 - values before they repeat and they will
310:16 - look random
310:25 - so there's the first example of a very
310:27 - simple algorithm to Generate random
310:29 - numbers
310:33 - so
310:35 - your random function in your programming
310:37 - language
310:38 - we'll use a pseudo-random number
310:40 - generator not necessarily this one maybe
310:43 - maybe a different one we'll use a
310:45 - pseudo-random number generator to
310:46 - generate
310:47 - a sequence of numbers
310:49 - and they will always have a period
310:52 - a finite period
310:54 - which means if you keep calling that
310:56 - random
310:58 - number generator
311:00 - eventually you'll get back to the first
311:01 - value and repeat the sequence
311:08 - unless you change the parameters and
311:11 - that's where the seed is important by
311:13 - changing the seed
311:15 - you'll get a different sequence
311:17 - to start with
311:20 - so if you're using the random function
311:23 - in your programming language
311:26 - then often there's a way to change the
311:28 - seed for that random number generator
311:30 - and that will produce the different
311:31 - sequence of random numbers
311:37 - let's go back
311:39 - and see some of the general concept
311:41 - we've missed
311:46 - so what would we like with a
311:47 - pseudo-random number generator
311:50 - we want to be able to generate a stream
311:52 - of numbers a sequence of numbers
311:55 - usually we think about binary all right
311:58 - our examples we use decimal but usually
312:00 - we want binary values for security
312:03 - or for security applications
312:07 - we're generally like such that we can
312:09 - generate
312:10 - some stream of random numbers
312:13 - but if you don't know the seed
312:16 - that initial value it should be hard to
312:19 - determine the sequence
312:22 - okay so if you don't know what the seed
312:25 - is
312:25 - an attacker even if they know that
312:28 - algorithm
312:30 - shouldn't be able to determine what the
312:31 - sequence is should be unpredictable
312:38 - forward and backward unpredictability
312:40 - means that given some value cannot
312:43 - predict the next value
312:46 - okay you cannot predict forward
312:48 - or given some values you cannot predict
312:51 - previous values so given subsequent
312:53 - values you cannot predict what happened
312:55 - in the past
313:00 - there are different tests so we've just
313:03 - said
313:05 - we said this sequence looks random okay
313:08 - there is a mathematical test to start to
313:11 - consider a sequence and give some
313:13 - measurements of how random it is okay so
313:16 - there are different tests to to be more
313:18 - scientific than just saying it looks
313:20 - random
313:26 - like looking at the frequency of numbers
313:29 - and bits that occur in there how often
313:31 - they occur the subsequences things like
313:35 - compressing if it compresses well
313:37 - it's not random if it doesn't compress
313:41 - well then it generally exhibits
313:43 - randomness
313:46 - so what we're like is
313:49 - when we use random numbers for security
313:51 - purposes is a generator such that if the
313:55 - attacker doesn't know the seed they
313:57 - cannot predict other values in the
313:59 - sequence
314:00 - and for that to work we normally need to
314:02 - keep the seed Secret
314:06 - and often to choose a seed we don't just
314:09 - choose x 0 equals one
314:12 - we choose a seed which is random
314:16 - and a common way is then to use a pseudo
314:19 - a true random number generator
314:23 - use a true random number generator to
314:25 - generate a seed and then use that seed
314:28 - in a pseudo-random number generator to
314:30 - generate a larger sequence
314:33 - it's more convenient because
314:36 - true random number generators generally
314:38 - just work or only produce a small
314:40 - sequence of values in a fixed period of
314:43 - time
314:49 - so a common use of random numbers for
314:54 - security purposes you have it says an
314:57 - entropy Source but think of some
314:58 - physical Source some measurement of the
315:01 - CPU operations the the disk operations
315:04 - the noise from circuits
315:08 - you have different sources you have some
315:10 - device that can measure those sources
315:12 - and generates some random number
315:15 - we'll use that as a seed into our
315:18 - pseudo-random number generator which
315:20 - generates a large sequence of random
315:22 - numbers
315:24 - true random numbers
315:26 - are typically generated only a small
315:28 - sequence of values in some period of
315:30 - time pseudo-random number generators can
315:32 - generate many random numbers in the same
315:35 - period of time
315:37 - so this is a common way to use it
315:49 - often your operating system May
315:53 - try and implement this in that your
315:56 - operating system
315:58 - provides a facility for generating
316:00 - random numbers in that your computer
316:02 - measures different characteristics and
316:05 - you can use a combination of physical
316:06 - sources
316:08 - CPU operations hard disk operations
316:11 - keyboard input Mouse movements
316:15 - different physical operations on your
316:17 - computer are measured
316:19 - and used to generate a true random
316:22 - number generator which is then used as a
316:24 - seed in a sum function our pseudo-random
316:27 - generator which is then made available
316:29 - to Applications by your operating system
316:47 - what's another random number generator
316:49 - there are many others okay we've just
316:51 - gone through a simple one that we can
316:52 - demonstrate
316:54 - lcg turns out it's not very secure lcg
316:58 - so it's not commonly recommended for
317:01 - when you want strong security there are
317:03 - other algorithms which are better
317:06 - developed by
317:08 - three people
317:10 - a different algorithm it's considered
317:14 - secure when we use it for for
317:16 - cryptographic or security applications
317:19 - you can see the example on the next
317:21 - slide but we take
317:23 - some large prime numbers
317:26 - um
317:30 - and this may not make sense to you yet
317:32 - but we'll in the next few topics such
317:34 - that those large numbers when we mod by
317:36 - four
317:38 - give three
317:40 - calculate some large n by multiplying
317:43 - those prime numbers and we take our
317:45 - initial value as some random
317:49 - s squared mod n and then go through a
317:52 - loop and generate
317:54 - x i based upon the previous value
317:56 - squared mod n
317:58 - and extract the last bit in that number
318:02 - to get the the
318:04 - sequence of random numbers
318:06 - but not so important to go through that
318:08 - have a look if you want so an example of
318:11 - some initial parameters we go through
318:13 - and generate these values using the
318:15 - equation and we take the last bit from
318:18 - that and our random bit stream is one
318:21 - one zero zero one one zero zero zero
318:24 - zero one and keep going okay so that's
318:27 - the output in this case not these
318:29 - numbers but those bits are the output
318:33 - and we just keep running that Loop okay
318:37 - it's a for Loop it can run forever
318:39 - just keep running that and it keeps
318:41 - generating a stream of bits this is our
318:43 - random bit stream
318:47 - if we want to generate our 128 bit key
318:50 - we run it 128 times iterations
318:59 - uh
319:00 - I think somewhere else maybe I don't but
319:03 - there are many other algorithms and I
319:05 - think that will stop for us on random
319:07 - numbers
319:09 - there are different algorithms
319:11 - we can all use soyuz block ciphers like
319:13 - des and AES to Generate random numbers
319:17 - because encryption the idea of
319:20 - encryption takes some structured plain
319:22 - text produce some random looking
319:25 - ciphertext so encrypting something
319:27 - produces a random number
319:30 - so we can use encryption to Generate
319:32 - random numbers
319:34 - so it works quite well the problem is
319:36 - often it's quite slow to encrypt
319:38 - something compared to using the
319:40 - algorithms we've seen
319:42 - so we can use encryption if needed
319:48 - let's have a look at an example
319:53 - several examples
320:09 - let me just check
320:15 - uh say on a Unix operating system the
320:18 - operating system has its own random
320:20 - number generator so it measures and
320:22 - there are different implementations but
320:24 - it commonly measures different inputs
320:26 - from the hardware
320:27 - and think of that as the true random
320:30 - number generator and generates a
320:32 - sequence using some pseudo-random number
320:34 - generator
320:35 - in Unix or Linux operating systems
320:38 - it's called a special device called
320:40 - random or you random
320:43 - and it just keeps generating random
320:45 - numbers
320:46 - but it generates a sequence a binary
320:48 - sequence so
320:51 - if I look at the contents of view random
320:55 - which is generated by my operating
320:57 - system I'll see
320:58 - random bits but if I display it on the
321:01 - screen it will come out as garbage so I
321:04 - will just display a selection of it
321:07 - using this program xxd
321:10 - xxd takes the binary value and converts
321:13 - to hexadecimal Okay so this
321:17 - displays the output of the operating
321:19 - system random number generator a
321:21 - sequence of bits head minus one just
321:23 - takes the first
321:25 - line of output okay because it keeps
321:27 - going and xxd takes that first line of
321:30 - output which is a sequence of bits and
321:32 - converts it to hexadecimal so I can show
321:34 - on the screen 7 5 8B this is the the
321:39 - random hexadecimal digits okay so uh
321:44 - that's produced from the operating
321:45 - system
321:47 - just an example and other operating
321:49 - systems would have their own
321:50 - implementations of random number
321:53 - generators
321:57 - some are more secure than others
322:00 - in terms of the ability to predict the
322:03 - next value in the sequence
322:13 - if I want in binary
322:16 - doesn't show as well but we can convert
322:18 - instead of hexadecimal into binary and
322:20 - we get our binary sequence
322:27 - do it again
322:31 - uh let's zoom out a bit
322:38 - if I keep doing it
322:41 - you should see it's not easy to see but
322:44 - if you compare all those values you'll
322:45 - see that that different there's no
322:47 - structure in there okay if you do tests
322:49 - on the randomness on those sequences of
322:51 - zeros and ones you should see that they
322:54 - exhibit those characteristics of uh
322:57 - unpredictability and distribution of
323:01 - zeros and ones
323:14 - the next part is related is stream
323:16 - ciphers but
323:18 - let's
323:20 - let's finish with something else let's
323:22 - not cover stream cybers today and go
323:23 - back and look at
323:25 - uh
323:27 - in the last 10 minutes something
323:30 - that we skipped is a tax on block
323:34 - science
323:42 - and
323:43 - the last slide one of the last slides
323:50 - returning the block site as Des AES
323:53 - triple Dash and others
323:57 - how secure are they
323:59 - well there are two types of attacks
324:01 - brute force and crypt analysis Brute
324:04 - Force try all keys so the security
324:07 - depends upon the length of the key
324:12 - so with this the key space with a 56-bit
324:15 - key is 2 to the power of 56 so an attack
324:19 - on deaths the time it takes
324:22 - if we measure in number of operations we
324:26 - need 2 to the power of 56 operations to
324:28 - find the key
324:29 - Brute Force try all keys in worst case
324:32 - so we talk about the time for a DEC
324:35 - attack the best known method is in fact
324:38 - Brute Force
324:41 - takes 2 to the power of 56 operations
324:43 - which is feasible today with the right
324:46 - Hardware that's possible
324:49 - triple Jess
324:52 - if you use three different Keys three
324:54 - different desk keys or 56 bits gives us
324:57 - a key length of 168 bits
325:00 - so the key space is 2 to the power of
325:02 - 168.
325:07 - a Brute Force attack on Triple deaths
325:09 - would require 2 to the power of 168
325:11 - operations
325:13 - okay so if you do the calculations
325:17 - that's going to take forever
325:20 - but we can still use the man in the
325:22 - middle attack on Triple death
325:26 - but we need to do it two times because
325:28 - we have two values in the middle triple
325:31 - deaths double deaths had
325:33 - encrypt you get an x value encrypt again
325:37 - with triple Dash encrypt we get X1
325:40 - encrypt get x2 and get our ciphertext
325:45 - after the third encryption we can do a
325:47 - man in the middle but it takes much more
325:49 - effort because we need to do it two
325:52 - times effectively
325:54 - turns out the amount of effort required
325:57 - using a man in the middle attack on
325:59 - Triple deaths requires 2 to the power of
326:01 - 111 operations
326:04 - Brute Force
326:06 - 2 to the power of 168
326:09 - but with a man in the middle we cut it
326:11 - down to just 2 to the power of 111.
326:14 - there are other known attacks
326:16 - one of them by Lux who's wrote a paper
326:19 - about it takes a little bit longer 2 to
326:22 - the power of 113.
326:24 - so we measure attacks based upon how
326:27 - many operations they they would take
326:29 - We compare them to Brute Force
326:32 - if it's slower than Brute Force then
326:34 - it's not a good attack
326:35 - if it's faster than Brute Force then
326:38 - then that's better
326:40 - how much faster we care about
326:43 - so brute force on Triple deaths 2 to the
326:45 - one six eight but there are better known
326:47 - attacks which bring it down to much less
326:51 - but still 2 to the power of 111
326:54 - still would take a long time
326:56 - and we've got some slides earlier I
326:58 - think we've seen how long that would
327:00 - take
327:02 - but with these attacks the other thing
327:05 - to measure how good they are
327:08 - remember with double desks we assume the
327:11 - attacker knew some plain text cyphertex
327:14 - pairs in advance to perform the attack
327:16 - the attacker needed to know something in
327:18 - the advance
327:21 - so we often measure how much data is
327:23 - known in advance
327:26 - the more you need to know
327:28 - the harder it is for the attacker
327:31 - okay
327:32 - so with a man in the middle attack you
327:35 - only need to know four different values
327:36 - that's nothing that's easy
327:39 - but with this other attack you need to
327:40 - know about four billion different values
327:42 - which is much harder in practice to know
327:45 - those values so we can compare them
327:47 - based upon how much data they need to
327:50 - know
327:52 - and how much memory they consume when we
327:55 - do the attack
327:56 - how much data we need to store
327:58 - so with a man in the middle attack
328:01 - we require to use memory of up to 2 to
328:04 - the 56.
328:09 - which is a lot of memory okay so if you
328:12 - do the calculation in bits or bytes
328:14 - whatever it doesn't matter
328:17 - so in theory we can do these attacks but
328:20 - in practice
328:22 - uh well we can't because of the time but
328:24 - if we could because of time in practice
328:27 - the memory
328:28 - becomes a limitation we don't have
328:30 - enough memory to perform these attacks
328:34 - AES is recommended today and there are
328:38 - three modes with AES they have different
328:40 - key lengths two are listed here 128 bit
328:44 - key key space two to the one two eight
328:47 - the best known attack
328:50 - at least in the last few years
328:53 - with this one called bike leak attack
328:56 - and the amount of time it takes is two
328:58 - to the one two six point one
329:02 - so I Brute Force 2 to the power of 128
329:06 - this
329:07 - Krypton analysis this other attack about
329:10 - 2 to the power of one two six about four
329:13 - times faster than Brute Force
329:15 - so not very effective
329:17 - because if Brute Force took a billion
329:20 - centuries
329:22 - then this attack would just take uh 250
329:27 - million centuries still doesn't help us
329:32 - it doesn't require much memory but it
329:35 - requires a lot of known data
329:37 - three ah I I can't remember but billions
329:42 - of terabytes okay so again not practical
329:45 - from memory from data perspective or
329:47 - from time
329:48 - with a 256-bit key the same attack
329:51 - brings it from 256 down to 254.
329:57 - so there are different attacks this just
329:59 - lists some of the the known attacks on
330:02 - the real ciphers
330:04 - the attacks we measure compared to Brute
330:06 - Force usually in terms of number of
330:08 - operations amount of memory needed
330:11 - amount of space to store the data and
330:14 - the amount of data you need in advance
330:16 - to perform the attack
330:18 - and they differ in each of those
330:23 - so today
330:25 - AES the advanced encryption standard
330:28 - even with 128-bit key is considered
330:30 - secure
330:31 - okay there are no known attacks that
330:33 - we're aware of that uh are practical
330:37 - and even in the future it's still
330:39 - considered secure with 128 bits but if
330:42 - you want to be safe use 192-bit keys or
330:45 - 256-bit keys
330:48 - Okay so uh maybe in a in the future come
330:52 - someone will come up with better attacks
330:54 - but it's unlikely that there'll be a
330:57 - significant advance that reduces this to
331:00 - be manageable
331:02 - maybe down to 2 to the power of 100 or 2
331:05 - to the power of 80 may be possible in
331:07 - some cases
331:13 - the problem with longer Keys is that
331:16 - it's slower to encrypt
331:25 - and you're we're going to introduce over
331:27 - the next few lectures some software to
331:29 - do the encryption called openssl and
331:31 - I'll just give a quick demo now
331:33 - it's does encryption using different
331:35 - ciphers
331:37 - and
331:39 - it actually I will not do an encryption
331:42 - I'll just show a speed test it gives us
331:43 - some how fast my computer is to encrypt
331:46 - using different ciphers
331:48 - if I use AES with a
331:52 - 256-bit key with a different mode of
331:54 - operation it does a speed test of takes
331:57 - many random inputs and encrypts them
331:59 - using AES with a 256-bit key and at the
332:03 - end you'll give me some some performance
332:05 - benchmarks
332:07 - doesn't take long it tries different
332:09 - input sizes
332:12 - don't worry about all of this
332:16 - this is saying that it takes just focus
332:20 - on this number
332:21 - 60 million
332:24 - bytes per second it can encrypt
332:27 - okay 60 megabytes per second
332:31 - is the speed so if I have 60 megabytes
332:34 - of data and I encrypt with AES
332:36 - in this configuration my computer can
332:38 - encrypt 60 megabytes per second about
332:43 - different computers will be at different
332:45 - speeds
332:46 - and different algorithms different
332:48 - speeds
332:53 - I think we have triple deaths
333:06 - different name this ed3
333:12 - so you can try different ciphers and see
333:15 - which ones are faster than others
333:19 - I made a mistake in the previous case
333:22 - Des
333:23 - ede3 really means triple deaths encrypt
333:26 - decrypt encrypt
333:28 - 20 million
333:31 - bytes per second
333:33 - AES was 60 million bytes per second
333:35 - Triple S 20 million bytes per second
333:37 - it's
333:38 - triple death is three times slower than
333:40 - AES so there's the advantage of AES it
333:43 - performs much much better
333:48 - one last one
333:51 - by default
333:54 - they use software to encrypt the CPU
333:57 - just normal software I've set an option
334:00 - to
334:01 - tell my
334:03 - tell the program to use my special
334:06 - instructions on the CPU that does AES
334:08 - encryption
334:09 - before AES was 60 million bytes per
334:12 - second by using Hardware encryption so
334:15 - the CPU
334:17 - has Special Operations to encrypt AES
334:20 - it's up to 176 million bytes per second
334:24 - so Hardware encryption can be much
334:26 - faster than software-based encryption
334:30 - we'll see some more examples of openssl
334:32 - over the coming lectures
334:41 - let's stop there
334:45 - so again our symmetric block ciphers
334:49 - operate on a small block of bits at a
334:52 - time
334:54 - 64 bits 128 bits a comma
334:58 - the modes of
334:59 - the modes of operation are ways to use
335:03 - that same Cipher on a larger input
335:06 - larger than the block size
335:09 - ECB
335:10 - is
335:12 - the the basic approach and what you
335:14 - would expect in a very trivial approach
335:20 - you take your plain text
335:22 - say a megabyte you break it into blocks
335:26 - that match your Cipher so my plaintext P
335:29 - is broken into blocks of P1 P2 up to PN
335:35 - then I use my Cipher AES desk whatever I
335:39 - use my Cipher to encrypt each block of
335:42 - plain text using my key my chosen key
335:45 - and get ciphertext C1 as output
335:49 - then I use the same Cipher the same key
335:51 - to encrypt and I get
335:54 - C2 as output
335:56 - and I do that for each of the input P's
336:00 - P1 to VN I get C1 to CN out the output
336:04 - resulting ciphertext is just a
336:06 - concatenation of those C values okay so
336:09 - that's
336:11 - the basic approach split your plain text
336:13 - into blocks encrypt each block one at a
336:16 - time
336:17 - same key same Cipher
336:19 - ciphertext is a combination of the
336:21 - output ciphertext blocks
336:25 - the problem with ECB is that you can get
336:29 - repetitions in the output ciphertext
336:33 - and you may have seen that in some of
336:34 - your quiz questions
336:37 - actually I don't think you used ECB if
336:41 - you you may or may not have seen the
336:43 - repetition but if you have two blocks
336:45 - which are the same on input
336:47 - because we're using the same key and the
336:49 - same Cipher we'll get the exactly exact
336:51 - the same
336:52 - ciphertext blocks output
336:55 - if two blocks are the same on input then
336:58 - the two blocks in the ciphertext will be
337:00 - the same
337:01 - so let's say you have a large file
337:04 - and you want to encrypt it you break it
337:06 - into blocks if it turns out that there's
337:08 - some repetition in the file
337:10 - then there'll be repetition in
337:12 - potentially in some of the blocks
337:14 - and repetition in the output ciphertext
337:18 - which is bad from a security perspective
337:22 - any repetition
337:25 - in the ciphertext is some structure in
337:27 - that cyber text and it it makes a
337:30 - potential opportunity for an attacker to
337:32 - exploit that structure
337:34 - to work out okay there's some structure
337:36 - in the ciphertext work backwards to find
337:39 - out the corresponding plain text so ECB
337:43 - two blocks are the same on input will
337:45 - get the same output ciphertext so that's
337:47 - not good from that perspective
337:50 - so other modes of operation are used and
337:53 - these all work for different ciphers
337:56 - doesn't matter if it's AES desk or
337:58 - something else
338:02 - and the two you saw in the quiz was CBC
338:05 - Cipher block chaining and counter mode
338:07 - CTR
338:08 - let's just have a quick look at them
338:10 - Cipher block chaining we chain the
338:13 - output of one step to become the input
338:16 - of The Next Step
338:18 - so we take our long plain text break
338:20 - into
338:21 - blocks P1 through to PN
338:25 - and we start with another value our
338:27 - initialization Vector IV we choose some
338:30 - other value so we have a key chosen plus
338:33 - an IV
338:35 - we use that to start this encryption
338:38 - and with CBC the approach is take your
338:41 - plain text block xor with the IV value
338:44 - then encrypt the answer of that
338:48 - the output ciphertext is C1
338:51 - but that C1 is fed into the next stage
338:56 - so we don't use the IV again that's used
338:58 - just once
338:59 - to initialize the ciphertext is fed into
339:02 - the next phase P2 is xored with C1 then
339:06 - encrypt so we're not encrypting directly
339:08 - upon the ciphertext we're encrypting the
339:11 - site sorry we're not encrypting the
339:13 - plain text we're encrypting the plain
339:16 - text x-ord with the previous values
339:21 - and then we keep going in a chain like
339:23 - that
339:24 - so this is a way such that if we have
339:28 - two plain text values which are the same
339:31 - P1 and P2 are identical
339:34 - it's most likely that
339:37 - C1 and C2 will be different
339:40 - because
339:42 - P1 xhord with IV
339:45 - is going to be different from P2 xor
339:48 - with C1
339:51 - even though P1 and P2 are this the same
339:54 - that we xor them with different values
339:56 - here we X all with the initialization
339:58 - Vector here we xor with C1 which with
340:01 - high probability will be different from
340:03 - the initialization vector
340:05 - so two input plain text blocks will
340:08 - produce different output ciphertext
340:10 - blocks and that's our goal here to to
340:11 - mix things up on the upward
340:17 - that's a common mode of operation use I
340:19 - think in many encryption algorithms or
340:22 - products if you don't specify usually
340:24 - they'll use CBC so there are others but
340:26 - this is a common one
340:31 - what about xor exclusive or we'll see it
340:35 - again when we look at stream ciphers in
340:37 - a moment
340:38 - take your plain text
340:41 - xor with a random value
340:45 - is a form of encryption
340:47 - and it's equivalent if you have a good
340:50 - random value equivalent to a one-time
340:52 - pad
340:54 - so xor is a good operation
340:57 - note the ciphertext should be random or
341:00 - random looking random appearance because
341:02 - the idea of encryption takes some
341:04 - structured plain text encrypt
341:07 - and get some random looking ciphertext
341:11 - xoring this random looking ciphertext
341:13 - with our structured plain text P2 should
341:16 - produce some random looking output
341:20 - which is good for dispersing the
341:22 - structure from the plaintext encrypting
341:24 - that should give us more Randomness in
341:26 - the output
341:28 - so xor is a common operation used in
341:31 - encryption we see it in these modes of
341:33 - operation and in other
341:35 - in the details of science
341:40 - note for decryption you need to go sort
341:42 - of in the reverse steps so that you get
341:44 - the original plain text back
341:48 - and I think in the quiz you had to
341:50 - attempt some of these with in your case
341:52 - you use that small five bit block Cipher
341:55 - so the table that I gave you
342:00 - the table I gave you
342:03 - you use
342:05 - in this block here so you talk
342:08 - actually I gave you decryption I think
342:11 - you took your ciphertext
342:14 - you took your key
342:16 - if you're using CBC and you look up in
342:19 - the table for that ciphertext using that
342:22 - key what was the original plain text and
342:25 - you've got the output here then you
342:27 - xored that with your initialization
342:28 - Vector which was given in the question
342:30 - and then you've got P1
342:33 - and then C1 was fed into the xor in the
342:36 - next stage
342:41 - there are other modes of operation and
342:45 - the other one you saw in the quiz was
342:47 - the counter mode
342:53 - let's go back sorry
342:56 - CBC
342:58 - Cipher block chaining
343:00 - one
343:02 - stage depends upon the output of the
343:04 - previous stage
343:06 - okay you look at the second stage here
343:07 - to encrypt
343:10 - let's say we know all the plaintext
343:12 - values to encrypt P2 we must have C1
343:17 - in terms of an implementation that means
343:19 - this must be done in serial we cannot
343:23 - implement it in parallel
343:25 - because
343:27 - to encrypt P2 we need C1 and to encrypt
343:31 - and to get C1 we must first encrypt P1
343:35 - so we cannot encrypt P1 and P2 at the
343:38 - same time
343:39 - with ECB we could
343:42 - with ECB if we have P1 and P2 let's say
343:46 - I have two cores
343:48 - on my computer I have a quad core
343:50 - processor
343:52 - I could send
343:54 - P1
343:56 - to be encrypted on one core and P2 to be
343:59 - encrypted on a different core and they
344:01 - could happen in parallel at the same
344:03 - time
344:04 - because they P2 encryption doesn't
344:06 - depend upon the output of the encryption
344:08 - of P1
344:09 - so we can implement this in parallel
344:11 - depending upon how many processes we
344:13 - have
344:14 - with CBC we cannot
344:17 - because
344:18 - to do the encryption here we need the
344:20 - result of the previous phase so we
344:23 - cannot put it in parallel so that's a
344:26 - disadvantage in terms of performance if
344:28 - we want to encrypt things quickly
344:31 - we cannot Implement CBC in a parallel
344:35 - mode
344:37 - counter modes another approach
344:40 - it's very simple
344:41 - and it has the advantage that you can
344:43 - encrypt in parallel
344:45 - quite easily you choose a counter
344:49 - an initial value so another IV let's say
344:53 - zero in binary
344:55 - you encrypt that value with your key and
344:59 - then xor with the plain text
345:02 - the plain text block and you get your
345:04 - cycle text for the second plain text
345:06 - block
345:07 - the counter two is just counter one
345:09 - incremented by one so if counter is zero
345:12 - a counter one was value zero
345:15 - counter two would be value one
345:17 - that's a counter we just keep
345:18 - incrementing
345:20 - where the initial value of counter one
345:23 - is your IV
345:27 - remember even though the counter is
345:30 - predictable
345:32 - encrypting the counter value with your
345:34 - key produces a random
345:37 - output some psychotects we cannot
345:40 - predict the value
345:42 - and xoring that random value with the
345:44 - plain text produces random looking
345:46 - output our ciphertext box C1
345:49 - so very simple in that we just encrypt a
345:52 - counter
345:53 - and xor that output of the counter with
345:55 - a plain text
345:58 - and an advantage compared to CBC is that
346:02 - we can implement this in parallel
346:05 - there's no dependence upon the second
346:07 - block
346:08 - compared to the first block
346:11 - so what I can do is I take my plain text
346:14 - blocks I generate my counter values
346:17 - because I know them in advance counter
346:19 - one is going to be zero counter two is
346:21 - going to be one and so on
346:23 - and all I do is on one core or one CPU
346:26 - encrypt the first block
346:28 - and at the same time on the other CPU
346:31 - encrypt the second block
346:33 - so they can be encrypted at the same
346:36 - time in parallel and we'll get our paint
346:38 - our ciphertext out
346:40 - and we can do that
346:42 - for as many cores as many CPUs as we
346:45 - have or as many entities that we can
346:49 - execute in parallel
346:52 - so this has an advantage in terms of
346:54 - performance compared to CBC
346:58 - CBC and counter mode are considered
347:00 - practically just as strong as each other
347:02 - they're both considered secure
347:05 - and CBC is more commonly used because
347:08 - it's been around longer but counter mode
347:10 - is starting to be used
347:14 - or is being increasingly used
347:19 - and there are other modes of operation
347:21 - some are generic for all ciphers some
347:23 - are specific to selected ciphers some
347:26 - are specific to AES trying to take
347:28 - advantage of AES structure
347:36 - effectively with counter mode what we do
347:40 - take some fixed predictable input
347:44 - encrypted
347:46 - and the process of encrypting produces a
347:49 - random output
347:52 - that's the idea of encryption take some
347:54 - structured input encrypt and get some
347:56 - random ciphertext as output
348:00 - random looking or pseudo-random
348:03 - and then
348:04 - we do that for each phase
348:07 - to encrypt our plain text we take that
348:10 - random output here and xor with P1
348:13 - take this random value xor with P2 and
348:17 - so on so really all we're doing is
348:18 - taking our plain text block and xoring
348:21 - with a random value
348:24 - and it turns out that's what stream
348:26 - ciphers do
348:27 - so this is a block Cipher but stream
348:30 - ciphers use the same concept
348:32 - last week we
348:34 - spoke about random numbers
348:37 - and that random numbers are important to
348:40 - computer security
348:42 - generating them is not easy we need some
348:44 - algorithm to Generate random numbers
348:46 - and
348:47 - a block Cipher is an algorithm to
348:50 - Generate random numbers
348:52 - our encrypt block here takes some
348:54 - counter as input and a key
348:57 - and the output is a random sequence of
348:59 - bits or a pseudo-random sequence of bits
349:03 - and same here
349:04 - so
349:06 - xoring that pseudo-random sequence of
349:08 - bits with a plain text is a form of
349:10 - encryption
349:12 - and it can be implemented very fast
349:20 - we'll show some examples of different
349:22 - Block ciphers in use uh later uh just
349:26 - notice counter mode encryption
349:28 - decryption what's the difference
349:31 - almost nothing
349:33 - so the same algorithm it's just
349:35 - encryption P1 here you get C1 out
349:38 - to decrypt C1 here P1 out you can use
349:42 - the same code
349:43 - the same software the same Hardware to
349:46 - implement encryption and decryption with
349:48 - counter mode
349:51 - it's just the reordering of those that
349:54 - input
349:57 - foreign
350:01 - ciphers quite briefly
350:06 - so we
350:07 - are actually we're skipping this one we
350:10 - can use block ciphers like AES des and
350:14 - so on to as pseudo random number
350:16 - generators if I need a random number for
350:19 - security I can encrypt some value with a
350:21 - block Cipher
350:24 - and there are different ways to do it
350:25 - one is using counter mode
350:28 - we take some counter
350:31 - uh and here we're using it
350:35 - in the opposite approach we have
350:39 - some
350:40 - some value we xor
350:42 - and encrypt to give us our bits here so
350:45 - we have a key so we can do it in other
350:49 - ways output feedback mode is one that we
350:51 - skipped over in the slides but another
350:53 - mode of operation
350:56 - and there are other ways to use and this
350:58 - was an example of using triple deaths
351:00 - for generating a random sequence of bits
351:06 - stream ciphers to effectively do what we
351:09 - just saw with catamo
351:11 - we take
351:13 - our plain text think of it as a stream
351:15 - continuous sequence of bits
351:18 - okay so imagine you uh
351:22 - using Skype
351:24 - or a voice over IP application on your
351:27 - computer you're talking
351:29 - the microphone takes your voice and
351:31 - converts the software converts it to
351:33 - bits bits that represent your voice
351:36 - and as you send them across the network
351:38 - you want them to be encrypted
351:40 - so you wanted an encrypted voice call
351:43 - so think of the bits coming in here as
351:46 - the bits representing your voice the
351:48 - stream of input bits
351:49 - continuously coming in
351:54 - you have a key
351:57 - you have some pseudo-random number
351:59 - generator it's called a byte generator
352:01 - here because it's generating a byte at a
352:03 - time but it generates random numbers
352:07 - this is the seed to the pseudo-random
352:09 - number generator it produces a random
352:12 - number as output
352:14 - represented in binary we xor that random
352:17 - number with the first in this case byte
352:21 - of your plain text
352:23 - the result of the xor is your ciphertext
352:27 - so if this is your voice coming in that
352:30 - is
352:31 - you're talking on the computer the
352:33 - microphone sends it to a codec which
352:36 - generates some bits representing your
352:38 - voice
352:39 - then the encryption software xores those
352:43 - first eight bits of your voice with some
352:46 - pseudo random number
352:47 - the output 8 Bits are the ciphertext
352:50 - which are sent across the network
352:53 - and that continues to happen as you keep
352:56 - generating input bits you just keep
352:58 - xoring with this the next random number
353:01 - in the sequence and keep going
353:03 - keep sending a stream of ciphertext
353:06 - and decryption is easy
353:10 - note xor if you xor the plain text with
353:15 - this value K and get C to decrypt we use
353:18 - xor again
353:20 - take C xor with the same K gives us the
353:25 - original plain text back
353:29 - so at the decrypter we have the same
353:32 - input key uppercase K here generate the
353:36 - same sequence of pseudo-random numbers
353:38 - and xor the first eight bits of
353:41 - ciphertext with the same lowercase k as
353:44 - was used for encryption here
353:51 - this lowercase k is called a keystream
353:54 - it's just it's the case streams used to
353:58 - xor with the input plain text string
354:03 - the structure of
354:06 - stream ciphers
354:08 - and the difference between different
354:09 - stream ciphers is how they Generate
354:11 - random bytes there are different ways to
354:13 - do it so algorithms have effectively
354:16 - different pseudo-random number
354:17 - generators
354:20 - one of them
354:22 - we'll come back to that rc4 is a common
354:26 - commonly used example of a stream Cipher
354:30 - it has an algorithm
354:33 - shown on the following sides but we will
354:35 - not go through it to this in this
354:37 - lecture there's an algorithm
354:40 - that effectively implements this
354:43 - pseudo-random bite generator
354:45 - and it's relatively simple
354:48 - and a key advantage of stream ciphers
354:51 - compared to block ciphers is that
354:53 - usually they're faster to implement
354:57 - so it doesn't take long to generate this
354:59 - random value and it doesn't take long to
355:01 - do an xor
355:03 - in Hardware or in software xor is very
355:05 - easy very fast
355:07 - whereas if you want to encrypt something
355:09 - with this or AES it can be quite slow
355:14 - so stream ciphers are generally much
355:16 - faster to encrypt than
355:19 - block cybers
355:21 - therefore they're mainly or commonly
355:23 - used when where we need small delay
355:29 - we can't wait a long time to encrypt our
355:32 - data
355:32 - like real-time voice Communications or
355:35 - real-time Communications of some media
355:37 - so some common applications of stream
355:40 - ciphers is encrypting real-time medium
355:54 - for the stream Cipher to be secure the
355:57 - pseudo-random number generator must be
355:59 - good it must produce a good sequence of
356:02 - pseudo random numbers
356:04 - a long period
356:06 - we spoke about our random number
356:08 - generators the sequence of numbers we
356:10 - generate there must be a large variety
356:13 - there
356:14 - we shouldn't repeat those numbers
356:17 - so a large period required there so
356:22 - as random as possible the output should
356:25 - be the less random the output is that
356:28 - what it should approximate a true random
356:30 - number generated
356:34 - so some algorithms don't generate uh
356:38 - as good random numbers as others that is
356:41 - it's easier to determine what the next
356:43 - value will be or what the previous value
356:46 - came from
356:49 - thing and as with any
356:52 - Cipher that we have a secret key there's
356:54 - a secret key in this case this key K
356:57 - must be kept secret
356:58 - it must be long enough to withstand
357:01 - Brute Force attacks
357:03 - often simpler to implement and faster
357:07 - than block service
357:09 - the problem with stream ciphers is that
357:12 - you cannot reuse the keys
357:14 - you need to use a different key when you
357:17 - have a next set of plain text
357:19 - with block ciphers you can reuse keys
357:23 - with a stream Cipher
357:25 - if you
357:28 - let's say you encrypt some
357:31 - voice call using one key and then you
357:35 - reuse that key the next day and the next
357:38 - day and the next day you keep reusing
357:40 - the same key with the stream Cipher it
357:42 - becomes very easy for the the attacker
357:45 - to get the ciphertext
357:47 - and promotable ciphertext work back and
357:50 - get the key
357:51 - okay so with stream ciphers it's
357:54 - important to change the key on a regular
357:55 - basis
357:57 - so often those keys would be generated
357:59 - and updated automatically
358:07 - and that's about all we want to say
358:09 - about stream ciphers there's an example
358:11 - of rc4 here I'm not going to go through
358:13 - it this semester uh
358:16 - note it's developed by Ron rivest
358:19 - remember the name because he comes up
358:21 - later
358:22 - uh
358:25 - it has different key sizes it's very
358:28 - simple to implement so simple that you
358:30 - could implement it yourself in a a
358:32 - couple of hours
358:33 - it's
358:35 - a for Loop
358:38 - another for Loop
358:40 - and a loop with a few basic operations
358:44 - so
358:46 - it's very simple to implement
358:48 - it has a few weaknesses that people are
358:50 - starting to identify but for the
358:52 - purposes it was used for was quite good
358:55 - as a stream Cipher
358:59 - it was used for example in Wireless lens
359:02 - there's only a few few known attacks
359:04 - which are practical
359:05 - but there are other stream Cycles which
359:07 - are now considered stronger than rc4
359:17 - we're going to move on give some other
359:19 - examples and I'll move on to a new topic
359:22 - but with we're starting to finish this
359:24 - topic about our traditional ciphers
359:28 - up until now after going through things
359:31 - like Caesar and visionaire and the
359:33 - classical cyphers
359:35 - those and then death
359:38 - AES are block Cyprus
359:41 - and they're symmetric Block ciphers in
359:44 - that both sides must have the same key
359:47 - and the stream ciphers are also
359:49 - symmetric both sides
359:52 - must have the same key
359:55 - so all of the ciphers we've considered
359:57 - so far have that same characteristic
359:59 - symmetric symmetric key ciphers the
360:02 - Symmetry between the keys on both sides
360:04 - the encrypta and decrypton
360:06 - the next topic is going to lead us into
360:08 - an alternative approach where we have
360:10 - two different keys at the encrypta and
360:12 - decrypton and that requires some new new
360:15 - Concepts to talk about
360:17 - before I I close this and move on any
360:20 - questions
360:21 - block ciphers modes of operations stream
360:23 - ciphers random numbers
360:30 - any questions for the upcoming quiz
360:37 - so the size that I skip over we will not
360:40 - covering the exam or the quiz so rc4 for
360:43 - example
360:46 - and because we missed a lecture I need
360:49 - to move on a little bit
360:51 - as an or alternatively we have we can
360:54 - have a makeup lecture do you want to
360:56 - make up lecture
360:58 - hands up
360:59 - if you don't want to make up lecture
361:03 - okay I need more than half
361:07 - so I you can't put two hands up that
361:10 - doesn't count as two
361:12 - okay well at this stage we don't need a
361:15 - makeup lecture because we missed just
361:16 - one but we'll see how we go with
361:19 - progress
361:23 - let's encrypt
361:26 - so far we've just looked at algorithms
361:29 - of course
361:30 - if I give you a one megabyte file and
361:33 - you want to encrypt it with desk you
361:34 - cannot do it by hand
361:36 - we need some software implementation to
361:39 - do so
361:40 - and
361:41 - implementing the ciphers
361:43 - and making sure they implemented
361:45 - correctly is important for security
361:47 - because if you implement a cipher and
361:51 - you make a mistake in the implementation
361:53 - some bug then it opens up an Avenue for
361:56 - an attack
361:59 - so when you write your software
362:03 - and you develop a website that needs
362:05 - encryption
362:06 - you probably won't Implement your own
362:09 - Cipher
362:10 - you'll
362:11 - you will not design your own Cipher nor
362:14 - will you implement an existing Cipher
362:16 - you'll probably take a library that
362:18 - someone else has developed that
362:19 - implements the cipher
362:21 - so many people don't Implement their
362:24 - ciphers themselves they use something
362:26 - that others have used and tested a lot
362:30 - and one Library that's common and open
362:32 - is called openssl
362:34 - I'll show you a few examples and I'll
362:38 - point to some on the website that you
362:40 - can see more details of those examples
362:42 - but we'll ask you in some homework to
362:44 - use this software to do some encryption
362:47 - and to solve some problems
362:53 - [Music]
362:55 - the software is called openssl open
362:58 - SSL it
363:01 - it's a standalone application that we
363:03 - can run on the command line it's also a
363:06 - library
363:07 - in that you can write your own code and
363:10 - link to the operations provided by
363:12 - openssl
363:14 - we'll use it in command line mode
363:18 - there are many different things that we
363:20 - can do with openssl
363:22 - we can encrypt with different ciphers we
363:25 - can generate Keys random numbers uh
363:30 - and some Key Management that we'll see
363:32 - in later topics
363:34 - there are some different versions that's
363:36 - just to show the version I'm just going
363:37 - to show a few quick examples of
363:40 - encrypting with
363:41 - uh
363:43 - symmetrically
363:46 - ciphers
363:49 - [Music]
363:51 - let's start with some message
363:56 - and so I want to encrypt some plain text
363:58 - so let's create some plain text
364:01 - let's
364:15 - download
364:22 - and I'm just creating it long enough so
364:24 - we can use it in the example here so
364:27 - that's just my my plain text
364:29 - and I'm going to write that to a file
364:32 - let's call it plain text
364:39 - so there's our message it's our plain
364:41 - text for our example
364:42 - uh how long is it
364:45 - um
364:54 - the size of this file is 72 bytes
364:58 - okay so that's the size of the file 72
365:00 - bytes there are 72 characters there one
365:02 - character one byte in the storage when
365:04 - we use our ciphers
365:07 - we're encrypting on the binary input
365:11 - so not like Caesar where we're going to
365:14 - change H to another letter we just treat
365:17 - this text as a set of zeros and ones
365:21 - so 72 bytes in this case
365:26 - let's
365:28 - look at those bytes just so we know what
365:31 - we're dealing with
365:33 - and to look at the binary view of a file
365:37 - I can see the ASCII contents to look at
365:39 - the binary contents we need some special
365:41 - program I have one called xxd
365:44 - it will show me the the contents of the
365:46 - file in binary minus B for binary
365:50 - show me across eight columns
365:53 - the plain text and I'm going to have to
365:55 - zoom out of it
365:59 - all it does is program xxd and I'll Zoom
366:02 - back in in a moment is shows this file
366:06 - in its binary form
366:07 - okay just
366:11 - a sequence of bits so the first eight
366:14 - bits and the last eight bits here
366:20 - let's encrypt
366:26 - and we'll encrypt using a symmetric
366:28 - block Cipher
366:30 - we'll start with Des okay just normal
366:33 - deaths and we'll use ecd mode of
366:36 - operation
366:38 - and to encrypt with this we need a key
366:40 - how do we choose a key
366:44 - I'll need a key for desk how do I choose
366:46 - a key
366:48 - someone choose a key for me
366:51 - how long should the key be for death
366:58 - 64 bits
367:00 - deaths actually has a 64-bit key
367:02 - although only 56 bits are used desk
367:05 - takes a 64-bit key someone choose a
367:08 - 64-bit key
367:10 - well we want a random key preferably I
367:13 - don't want to choose a key that someone
367:14 - can guess
367:15 - so we've actually to generate the key
367:18 - we'll create generate a random number
367:21 - so let's generate a random number first
367:24 - and then we'll use that as the key
367:28 - and luckily openssl has a way to
367:31 - Generate random numbers
367:37 - it has a Rand operation generate a
367:40 - random number
367:42 - eight
367:43 - bytes long
367:46 - eight bytes is 64 bits
367:48 - and instead of outputting binary
367:51 - we'll make it a little bit easier and
367:53 - output in hexadecimal
367:55 - no need to remember these operations uh
367:58 - there's links to a detailed description
368:00 - of them in a way in the website I'll
368:02 - show you later uh just demonstrating
368:05 - what you can do
368:06 - generate a random
368:09 - 64-bit or 8 byte value output in
368:12 - hexadecimal there it is
368:16 - 16 hexadecimal digits
368:20 - now let's encrypt using that as the key
368:26 - [Music]
368:28 - openssl ENC to encrypt
368:32 - and we need to choose our Cipher
368:35 - and the cipher we're going to use is eat
368:38 - is death
368:40 - and we should choose the mode of
368:41 - operation as well
368:43 - so ECB CBC counter and others we can
368:47 - choose from
368:48 - to start I'll just choose ECB the very
368:50 - basic mode
368:54 - and
368:55 - to encrypt we'll specify minus E tell it
368:58 - to encrypt
368:59 - the input we want to encrypt the plain
369:01 - text file
369:05 - I want to produce an output let's call
369:07 - it ciphertext
369:09 - dot bin sorry it's wrapping around but
369:14 - encrypt using desk and ECB mode of
369:17 - operation
369:19 - the plain text file output into a file
369:21 - called ciphertext.bin
369:25 - doesn't matter about the extensions
369:28 - and now let's specify our key
369:36 - and I'll copy the key from the random
369:40 - number
369:42 - and use that so open SSD will allow us
369:47 - to give a key in hexadecimal instead of
369:49 - just binary
369:51 - encrypt using des and ECB this plain
369:54 - text using this key producing this cycle
369:57 - text
370:03 - normally with modes of operation we'll
370:05 - also include an initialization vector
370:09 - it's not needed for ECB but I'll just so
370:13 - we can repeat this later I'll include it
370:15 - here
370:16 - and it needs to be 64 bits or
370:23 - 16 hexadecimal digits that's in
370:25 - hexadecimal that's a bad initialization
370:28 - vector all zeros you shouldn't choose
370:30 - that you should choose another random
370:32 - value so it should choose a random value
370:34 - here for my initialization vector
370:37 - bye
370:38 - just for this example
370:42 - done encrypted
370:46 - the output ciphertext
370:53 - 80 bytes
370:56 - input plaintext 72 bytes output
371:00 - ciphertext 80 bytes what happened
371:04 - is that correct
371:07 - what went wrong
371:12 - what we'd expect
371:14 - is that if I have an input of 72 bytes
371:18 - plain text
371:19 - I get 72 bytes output ciphertext all of
371:22 - our ciphers take the same length input
371:25 - same length output
371:26 - okay 64 bits in for one block 64 bits
371:30 - out combine the blocks same length in
371:33 - same length out here it's different
371:35 - 72 bytes in 80 bytes out
371:40 - it turns out that with many ciphers they
371:43 - add some padding in there and even some
371:45 - error detection to be able to detect if
371:47 - something goes wrong
371:48 - and that's what these extra eight bytes
371:50 - have been added in this case open SSL is
371:53 - has added some padding in there
371:56 - it wasn't really needed
372:00 - so let's add an option encrypt again but
372:03 - say Notepad
372:04 - let's not Pat just to make things a
372:06 - little bit simpler in the output
372:11 - and now our output is 72 bytes
372:14 - okay that's what we should have or we
372:16 - expected at the start
372:19 - 72 bytes in
372:21 - 72 bytes out
372:24 - but in practice we'll often allow
372:26 - padding in case the input
372:30 - is not uh integer multiple of the number
372:33 - of bits of our block we need to do some
372:36 - padding
372:39 - now let's look at our ciphertext
372:42 - and it's binary if you take those ASCII
372:45 - characters and try and view them
372:47 - they'll produce some strange characters
372:48 - let's look at them with xxd
372:53 - and I'll look at them in
372:56 - binary so zoom out a little bit
373:03 - let's look at the cycle text
373:06 - there it is okay
373:08 - so the binary ciphertext and it's hard
373:11 - to see of course but if you look closely
373:14 - you should shouldn't see any structure
373:17 - in here
373:18 - or should you
373:21 - and this is the corresponding ASCII
373:23 - representation of this where you see a
373:25 - dot it means it's a non-printable
373:27 - character
373:28 - Okay so
373:30 - this is the actual binary after
373:31 - encrypting
373:33 - anyone see any structure
373:35 - in the ciphertext
373:38 - what I'd like is my structured input
373:41 - plain text this message when I encrypt
373:43 - it I get some random looking output
373:46 - if you can see structure in the
373:50 - ciphertext and that's bad for security
373:53 - anyone seen a structure
374:05 - anyone all right here's a hint there is
374:08 - some structure there's a problem
374:10 - anyone notice it maybe look at the ASCII
374:13 - representation of the ciphertext
374:15 - I'll zoom in a little bit more sorry
374:20 - uh
374:34 - uh sorry I can't zoom in very easily
374:40 - without getting the right hand side I'll
374:42 - point it to you because it's hard to see
374:43 - I've seen it before
374:46 - and it's not obvious if you look at
374:49 - these two lines of
374:52 - binary
374:55 - and this line of
374:58 - binary values in the ciphertext you see
375:02 - the ASCII is the same in fact if you
375:04 - look closely the binary values are the
375:07 - same
375:08 - this line
375:10 - this 64 bits and this 64 bits are
375:13 - identical
375:16 - so we have some structure in the plain
375:18 - text
375:20 - that's not good that is bad for security
375:23 - what's the problem
375:27 - so
375:29 - was it
375:32 - the fourth line and the seventh line
375:36 - [Music]
375:38 - well you can see some of the bits here
375:43 - identical here same eight bits same
375:46 - eight bits same eight bits and so on
375:50 - why
376:00 - bonus one mark for the next Quiz
376:03 - for a quick answer
376:05 - quick correct answer
376:12 - why in the ciphertext
376:16 - do we get some structure in this case
376:18 - the structure is
376:20 - a sequence of 64 bits were identical
376:24 - translate all right
376:28 - uses the same process uh be more
376:31 - specific
376:35 - yep
376:39 - both plain texts are the same be more
376:42 - specific
376:44 - the both blocks of plain texts are the
376:47 - same therefore the output ciphertext is
376:51 - the same because of
376:55 - in same key but there's one more step
376:58 - yeah
377:00 - ECB
377:02 - I think half a mark each bonus
377:08 - yeah ECB mode of operation the same
377:10 - that's the the problem in this case
377:12 - let's go back and zoom out
377:17 - uh
377:20 - look at the input
377:23 - plain text
377:26 - and remember our blocks are 64 bits so
377:29 - effectively each line is one block input
377:32 - so with our mode of operation P1 is
377:35 - hollow dot space t P2 is his space is
377:40 - space o and so on look at the fourth
377:43 - block
377:44 - space secret space and the seventh block
377:47 - space secret space the same
377:51 - two blocks so P four
377:55 - and P seven in the mode of operation are
377:58 - the same
378:00 - let's go back and just
378:02 - make that clear
378:13 - we're using ECB as the mode of operation
378:16 - although we don't list them here but p
378:20 - 4
378:21 - and p7 are the same we encrypt with the
378:25 - same key
378:26 - using guess therefore we'll get the same
378:28 - ciphertext as output
378:31 - and indeed we do
378:34 - these two blocks the ciphertexts are the
378:37 - same
378:38 - and that's bad
378:39 - and that's the problem with ECB when you
378:41 - have same input blocks you'll get the
378:45 - same output ciphertext box and the
378:46 - attacker can try and take advantage of
378:48 - that
378:52 - so ECB usually should not be used
378:54 - especially when we have large plain text
378:56 - input
379:01 - I will leave it for you as your homework
379:03 - and I'll set a homework soon that it
379:05 - requires you to use openssl and encrypt
379:08 - some plain text decrypt some ciphertext
379:11 - just to get some feel with the software
379:14 - and to see what it can do and maybe do a
379:17 - little bit of analysis of the outputs in
379:19 - some cases
379:22 - you can do many more ciphers we can
379:24 - change to AES different modes of
379:26 - operation and in fact uh even symmetric
379:29 - public Keys cryptography
379:36 - since everyone's so excited about
379:38 - openssl we'll stop there and
379:41 - try a new topic any questions before we
379:44 - move on about that concept of
379:48 - the the poor security of ECB
379:52 - foreign
380:15 - block ciphers and symmetric key
380:17 - encryption
380:18 - let's try an alternative approach
380:22 - [Music]
380:27 - and close this
380:39 - wrong one
380:53 - this is from one of our earliest
380:54 - lectures
380:58 - we've seen this before this is the the
381:00 - general model for encrypting for
381:02 - confidentiality where what we do is we
381:04 - take our plain text input
381:07 - and in a cipher
381:09 - take a key the output is a ciphertext we
381:13 - send the ciphertext the decrypter the
381:16 - receiver applies the decryption
381:18 - algorithm a key and gets the plain text
381:21 - up until now
381:24 - key one and key 2 have been the same
381:28 - with symmetric key encryption
381:31 - uh
381:33 - shared secret key k
381:35 - K1 and key two are the same
381:40 - there's some problems with that it can
381:43 - be very inconvenient for some purposes
381:45 - so people have developed an alternative
381:47 - where there's two different keys and
381:49 - that's the what the next form of
381:51 - cryptography we're going to cover but to
381:53 - understand some of that we need some
381:56 - refresher in some cases some new
381:58 - material on some of the mathematics that
382:01 - supports the new form
382:03 - so that's the next topic that we'll
382:04 - start on today
382:06 - and it's some very simple mathematics
382:08 - that will just uh cover with a few
382:11 - examples that will set us up for the
382:13 - next form of cryptography
382:17 - so I call it number Theory it covers a
382:19 - few different things
382:27 - some of it should be easy that is just
382:30 - refreshing your memory some of it may be
382:32 - new but still easy
382:40 - just remind you something about prime
382:42 - numbers and division so this you should
382:44 - follow and if you don't understand then
382:46 - then have a read ask me a question
382:48 - otherwise we'll go through quite quickly
382:51 - uh just some
382:56 - remind you of some terms
382:59 - okay division we all know about how
383:01 - division works but we can talk about
383:03 - some a divisor and B divides a
383:07 - we can say B divides a if
383:11 - a equals some
383:14 - integer times B
383:17 - and sometimes we write this so just the
383:19 - terminology we sometimes we write this
383:21 - as b and a vertical bar a so this is the
383:25 - topic on number Theory B is a divisor of
383:27 - a we can say
383:29 - yeah
383:31 - and we know about greatest common
383:32 - divisors of two numbers the greatest
383:35 - common divisor of those two numbers can
383:37 - be found
383:40 - anyone unclear so far gcd greatest
383:43 - common divisor so the greatest common
383:45 - divisor of seven and 15 is
383:53 - 7 and 15.
383:55 - is one okay the greatest common divisor
383:58 - of eight and
384:00 - uh 20.
384:04 - four okay
384:06 - all right so look at the divisors of
384:08 - eight
384:09 - one two four eight
384:11 - look at the devices of 20.
384:14 - one two four five ten twenty and look at
384:20 - the the greatest common values simple
384:24 - there's there are efficient algorithms
384:25 - for finding greatest common devices
384:27 - especially large numbers for small
384:29 - numbers in example is easy we can do it
384:31 - in our head but if you have very large
384:33 - numbers there are some algorithms for
384:36 - finding the greatest common divisor
384:44 - we say two integers are relatively prime
384:47 - if the greatest common divisor of those
384:49 - two integers
384:51 - is one
384:52 - so our example 7 and 15
384:56 - the greatest common divisor of 7 and 15
384:58 - is one so we say those two integers are
385:01 - relatively prime not Prime
385:04 - relatively prime
385:06 - so that may be new to some of you
385:09 - is
385:10 - height and R8 and 20 relatively prime
385:16 - 8 and 20 are not relatively prime
385:19 - so if they have a greatest common
385:20 - divisor which is greater than one then
385:23 - we say they are not relatively prime
385:26 - that will come important later
385:28 - and we'll see it in use a little bit
385:30 - later
385:32 - prime numbers
385:34 - everyone remember prime numbers
385:36 - what are the first 10 prime numbers
385:42 - give me a prime number
385:45 - seven okay give me a smaller prime
385:47 - number
385:48 - three another one
385:52 - one's confusing let's not cover one
385:55 - one's not really considered a prime
385:56 - number two is two is a prime number uh
386:00 - two three five seven
386:04 - no more even numbers of course a prime
386:08 - and then the numbers
386:10 - how do you define the prime number
386:16 - their divisors are one in itself
386:20 - okay the devices
386:22 - of that number are one and itself
386:25 - so prime numbers I think you're aware of
386:27 - fine
386:28 - uh
386:32 - some integer P larger than one we Define
386:35 - prime numbers larger than one
386:37 - if and only if it's divisors are plus or
386:39 - minus or really one and P one in itself
386:45 - and
386:46 - any integer any integer not necessarily
386:50 - a prime can be factored in into its
386:53 - Primes
386:55 - where
386:57 - some integer a can be written as some
387:01 - the second Pro or prime two
387:03 - powered to some exponent
387:06 - and multiply by different primes so any
387:09 - integer can be written as multiplying a
387:11 - set of primes out
387:14 - and that will become important later
387:16 - uh
387:23 - very simple examples just to all right
387:26 - keep going
387:33 - what is 15 written as
387:36 - multiplication of primes
387:41 - or let's start easier what
387:44 - what are the divisors or factors of 15.
387:51 - the divisors of 15 are
387:55 - 1 3
387:57 - five
387:58 - and if we count 15 is a divisor
388:03 - therefore
388:05 - the prime divisors are three and fifth
388:09 - three and five less than fifteen so
388:12 - three times fifteen
388:16 - all right what are the divisors of 24
388:23 - one oh we're not all right one two
388:32 - six
388:34 - I
388:35 - twelve
388:37 - 24.
388:39 - 24 is
388:42 - written as primes prime factors
388:52 - how we write 24 as in
388:57 - as a multiplication of primes
389:02 - which means
389:04 - take the prime numbers and multiply them
389:06 - together to get 24.
389:12 - well
389:17 - 2 is a prime
389:21 - 24 divided by 2 is 12.
389:24 - divides by 2
389:26 - here's a 6 divided by two
389:31 - or
389:32 - 2 to the power 3
389:34 - Times by 3 to the power of one
389:38 - so we can write any integer as if we
389:42 - multiply the prime numbers and select an
389:45 - exponent here an integer exponent so in
389:47 - this case it's 2 to the power 3 times 3
389:49 - to the power of 1 times 5 to the power
389:52 - of zero
389:54 - we don't write that because 5 to the
389:55 - power of 0 is 1 times all the other
389:58 - primes to the power of zero
390:01 - that is sometimes useful or simply the
390:04 - prime factors
390:06 - of 24 or 2 and 3.
390:09 - so we'll see we'll be interested later
390:12 - in finding
390:13 - the prime factors
390:18 - in this case we found them as two and
390:19 - three
390:25 - okay
390:27 - and that's what
390:28 - this equation States General we can
390:31 - write any integer as multiplying the
390:33 - primes together where those exponents
390:36 - are integers
390:38 - zero or higher
390:41 - and a list of some prime numbers the
390:44 - first or the under two thousand okay
390:49 - okay let's
390:51 - move on modular arithmetic
390:58 - we in some of the algorithms we'll use
391:01 - for public key cryptography the next uh
391:04 - form of encryption we'll use modular
391:06 - arithmetic
391:08 - and normal arithmetic it's normal
391:10 - arithmetic but we mod the answer
391:13 - effectively and it has some useful
391:14 - properties uh when we use it in
391:17 - encryption
391:19 - so very Basics you know about mod
391:25 - a mod n is the remainder when a is
391:27 - divided by n
391:29 - okay we write a mod n n is called the
391:32 - modulus
391:33 - n is the modulus in this case we can say
391:36 - two numbers are equivalent or congruent
391:40 - modulo and
391:41 - equivalent in mod n
391:44 - if when we take those two numbers and
391:46 - mod by n we get the same answer
391:50 - so we often write that as a is
391:52 - equivalent to B in mod n
391:59 - [Music]
392:17 - easy one what's the answer
392:22 - three
392:24 - in mod 10
392:26 - 13 and 3 are the equivalent of congruent
392:29 - modular modulo 10.
392:32 - because 13 mod 10 is three three mod 10
392:35 - is three that's all when we mod by the
392:38 - same number and get the same answer we
392:40 - say they're equivalent in the modulus
392:46 - do we need more examples not really
392:50 - negative numbers will ignore for the
392:53 - moment
393:00 - what's next
393:07 - so the mod n operator maps all of our
393:10 - integers
393:12 - so the infinite set of integers into
393:14 - some finite set
393:16 - of zero to n minus 1. okay so when we
393:20 - mod by n the answer is always between 0
393:23 - and N minus one that's all we're saying
393:25 - so it Maps it to a particular set
393:27 - denoted as z n so Z8
393:31 - is zero up to seven
393:34 - take any integer mod by eight and the
393:36 - answer will always be in that set of
393:38 - zero to seven
393:40 - modular arithmetic performs arithmetic
393:42 - addition subtraction multiplication and
393:45 - division
393:47 - within the confines of some set ZN
393:51 - so we talk about
393:52 - a set Z8
393:55 - means the answers of our arithmetic will
393:58 - always be between be between 0 and 7.
394:03 - so when we do
394:04 - 10 plus
394:06 - 15.
394:09 - in mod 8 and the answer is always going
394:13 - to be between 0 and 7. so always the
394:17 - answers of the arithmetic operations are
394:18 - always in this set
394:24 - let's go through some simple examples
394:29 - make sure we don't get
394:32 - some useful ones
394:37 - foreign
394:38 - [Music]
394:51 - yell out the answers
394:56 - anyone
394:59 - Arthur
395:02 - four plus three
395:05 - don't all yell at the same time okay
395:07 - this is a hard one
395:09 - four plus three again
395:11 - seven okay
395:13 - not bad
395:16 - four part four plus seven
395:21 - louder
395:25 - one
395:27 - note we're using Z10 here
395:30 - in other words to be precise everything
395:33 - is mod 10.
395:35 - so what
395:39 - our modulus is always 10 so I'm not
395:41 - writing the mod operator here we're
395:43 - using modular arithmetic in this
395:46 - specific examples
395:57 - the problem Additionally the
395:59 - if you just add them with your normal
396:01 - original modify uh
396:11 - what about the track well that need to
396:15 - use the new content first with
396:20 - with addition with modularity we can
396:23 - just add the numbers using our normal
396:25 - approach the pathway and one by ten with
396:29 - we can talk about the input
396:32 - what the inverse operation of a
396:34 - difference
396:37 - first operation of multiplication
396:41 - so we talk about the people
396:48 - so now using that I'll just write here
396:51 - normal arithmetic not using modulus
396:57 - four plus three is
397:05 - one
397:12 - instead of minus 3.
397:23 - which is right up as inhibition 7 plus
397:29 - negative three
397:34 - so this is our operation
397:37 - subtraction
397:38 - is the same as adding the inverse
397:44 - inverse of plus three is negative three
397:46 - so
397:49 - if we want to perform subtraction
397:51 - instead of minus B it's the same as 7
397:54 - plus the inverse is driven
397:57 - the inverse of 3 or precisely the
398:00 - additive inverse 3 is minus
398:03 - so that's the normal concept of
398:04 - arithmetically making things think about
398:08 - the inverse of the numbers
398:11 - inverse when we add is subtract we'll
398:14 - negative
398:16 - who use the same concept with modularism
398:22 - so
398:24 - we can talk about the additive input
398:26 - and I think
398:34 - a is the additive inverse of B
398:37 - in a plus b is equivalent to zero odd n
398:41 - the same in our normal arithmically
398:46 - the additive inverse of 3
398:49 - if the number starts that when we add it
398:52 - to three we did zero
398:54 - three plus minus 3 gives us zero so we
398:56 - say the additive inverse of three is
398:58 - minus three but in modular arithmetic we
399:01 - don't have negative numbers
399:05 - so
399:06 - what the additive inverse of
399:12 - Z10
399:14 - the additive inverse of tree
399:25 - okay
399:46 - the value of 10 numbers again
399:54 - when we add the two numbers together we
399:57 - can hear over here
399:59 - so the additive inverse of three what
400:03 - number when we add the three to the hip
400:10 - in Europe
400:31 - and then the fact that you just use an
400:34 - adjectives
400:35 - the performance attraction we add the
400:38 - energy together
400:40 - in our normal arithmetic
400:45 - free
400:47 - minus three
400:48 - seven subtract 3
400:51 - 17
401:13 - or 110 or 4 minus seven
401:19 - not ten
401:29 - or 10.
401:35 - every they have to must be between zero
401:38 - and now
401:44 - three
401:45 - seven
401:47 - seven
401:49 - why subtraction
401:52 - is the same as additional
401:57 - of the added even though
402:28 - so there's something that confuses some
402:30 - people we're not dealing with negative
402:32 - numbers we can still do subtraction and
402:36 - we still use the same concept of our
402:38 - normal repetitive but everything is in
402:40 - modern
402:46 - okay
402:50 - in normal arithmetic we implement we can
402:54 - Implement retraction simply adding the
402:57 - invert
402:59 - inverse of three to one of three because
403:02 - three plus minus three is zero
403:05 - the same concept is modulator
403:07 - we can implement the fraction by
403:11 - adding the additive additive input of 7.
403:18 - seven examples
403:30 - [Music]
404:58 - foreign
405:16 - okay
405:22 - additive inward
405:29 - in
405:31 - all numbers will have an additive income
405:37 - so in our set
405:41 - zero the attitude University zero and
405:44 - one is nine but two is eight so the
405:49 - whole numbers have compatible
405:59 - let's so we can do addition subtraction
406:04 - operation multiplication
406:21 - all right
406:23 - okay okay
406:36 - hey
406:54 - not four
407:05 - 12.8
407:12 - foreign
407:57 - foreign
408:36 - normally
409:02 - we multiply the two numbers together a
409:05 - number again with each other
409:20 - foreign
410:53 - great
411:12 - foreign
412:14 - foreign
413:12 - foreign
413:43 - about that
413:47 - be more announcements thank you
414:20 - so we're at the stage of just the last
414:23 - operation for our modular arithmetic
414:25 - logarithms
414:27 - exponentiation is easy well easy in
414:31 - terms of concept
414:32 - that is
414:34 - it's repeated multiplication and in
414:36 - terms of how we think about
414:38 - exponentiation you take uh your number
414:41 - raise it to the power mod by and you get
414:43 - your answer so conceptually easy
414:46 - in practice
414:48 - time consuming sometimes to calculate
414:50 - we'll see some examples when we have big
414:52 - numbers last one logarithms
414:56 - and the concept we have is a discrete
414:58 - logarithm
414:59 - in normal arithmetic if we have b equals
415:03 - a to the power of I
415:04 - I is the index or the exponent
415:07 - then the log in base a of B is I that
415:10 - index or exponent
415:12 - but now we have everything mod n all
415:14 - right and this this uh equation mod P
415:19 - so if we have B equivalent to a raised
415:23 - to the power of I all in mod T then we
415:26 - say in the same concept the logarithm in
415:30 - base a
415:32 - with mod P
415:34 - of b equals I the index so we're trying
415:37 - to find the index of this exponentiation
415:40 - the opposite of the exponentiation
415:42 - operation and we call it for modular
415:45 - arithmetic a discrete logarithm
415:49 - if we go back to multiplication in
415:52 - modular arithmetic we can do
415:53 - multiplication for all numbers but we
415:55 - cannot do division for all numbers
415:57 - and similar follows we cannot do
415:59 - logarithms for all numbers there's only
416:00 - special cases where we can determine the
416:04 - unique exponent
416:06 - so we need to introduce a primitive
416:07 - route to explain that
416:12 - so A Primitive route
416:15 - is
416:16 - of some so we Define A Primitive route
416:18 - of some prime p a prime number P
416:26 - if a number is a primitive root of that
416:28 - Prime P then a raised to the power of
416:31 - one two three up until P minus one
416:35 - gives us distinct values
416:38 - and that's best shown with some examples
416:40 - so we'll go straight to some examples to
416:42 - introduce the concept of a primitive
416:44 - route
416:48 - and then see
416:50 - the discrete logarithm relies on
416:52 - A Primitive route being found
416:58 - I have some better examples
417:06 - let's say our modulus is
417:12 - everything is mod
417:15 - seven for this set of examples mod set
417:18 - seven so in our equation mod P or p is
417:22 - seven
417:27 - let's look at the numbers when we take
417:30 - some number a
417:36 - and we raise it to some power I
417:43 - where I ranges from from Mod 7 1 up
417:47 - until six
417:51 - foreign
418:02 - so
418:04 - we're trying to
418:08 - give an example of a primitive root A
418:10 - Primitive root of some prime or some
418:13 - number P is that if we can take that
418:16 - primitive root raise it to the powers of
418:18 - one two three up until P minus one if
418:21 - the answers are distinct
418:24 - different values
418:26 - let's try some values
418:29 - so what we're going to do is take our
418:32 - value a
418:36 - raise it to the power of I
418:39 - and then mod by our modulus P which in
418:42 - this case is seven for this example
418:45 - so
418:47 - a
418:50 - to the power of I
418:52 - mod 7 so 1 to the power of one mod seven
418:55 - we get what
418:57 - one one to the power of anything we're
418:59 - going to get one so this is going to be
419:00 - a simple case we'll write the answers
419:05 - here just to demonstrate a equals a one
419:08 - I equal to one one to the one mod seven
419:11 - answer is one
419:13 - one to the power of two mod seven also
419:16 - one one to the power of three mod seven
419:20 - you can see what we're going to get as
419:21 - artists
419:24 - we'll come back to that one and let's
419:26 - try for a different value of a and then
419:27 - explain what they mean
419:29 - what if a equals two
419:32 - so what we do
419:34 - when we mod 7 consider 2 to the power of
419:37 - one
419:38 - two to the power of two two to the power
419:40 - 3 and so on mod 7. what are the answers
419:45 - 2 to the power of one mod seven
419:49 - is two two to the power of 1 is 2 mod 7
419:52 - we get two is the answer
419:58 - 2 to the power of two
420:01 - mod 7
420:06 - . how about we uh I'm very lonely up the
420:09 - front
420:10 - come down closer everyone small small
420:13 - group of students large room
420:16 - move down the front it's okay to eat
420:18 - everyone moved down the front front two
420:19 - rows
420:21 - it's okay
420:24 - we've got time off you go yeah everyone
420:27 - moved I can't move the screen closer to
420:29 - you
420:31 - come on
420:33 - the front three rows
420:36 - it's okay
420:39 - it's all right
420:45 - Just For Today front three rows
420:53 - yes everyone not not just uh
420:56 - two or three people
421:03 - just try something different
421:06 - it's okay bring your laptop
421:25 - it's not too hard just just move down
421:28 - the front
421:31 - the front a little bit closer
421:34 - there's so many seats to choose from
421:37 - yeah
421:44 - okay
421:46 - now I can ask a question and hear your
421:48 - answers
421:51 - two to the power of two mod seven what's
421:55 - the answer
421:58 - four
422:00 - two to the power of three
422:02 - mod seven
422:04 - two to the power of three is eight mod
422:06 - seven we get one
422:09 - 2 to the power of four
422:11 - mod seven try it
422:17 - 2 to the power of 2 mod 7 we get four
422:20 - two to the power 3 mod 7 we get one
422:24 - two to the power of four mod seven two
422:26 - to the power of four is
422:29 - 16 mod 7 the answer is two
422:33 - to the power of five
422:35 - mod seven
422:37 - two to the power of 5 is 32 mod 7.
422:42 - four four two to the power of 5 is 32
422:46 - 4 times 7 is 28 remainder is four
422:50 - two to the power of six mod seven
422:58 - one
422:59 - check
423:01 - two to the power of 6 is 64.
423:05 - 9 times 7 is 63 so the remainder is one
423:08 - okay easy
423:11 - maybe it's so easy when you're sitting
423:13 - down the front too so let's do this one
423:16 - what if a is three
423:20 - three to the power of one mod seven easy
423:23 - three three to the power of two is nine
423:26 - mod seven
423:28 - three to the power of three
423:33 - mod seven
423:34 - three to the power 3 is 27.
423:37 - mod 7 6 3 to the power of four
423:42 - I'll give you
423:48 - a calculator
423:51 - you can use your head fine
423:58 - what do we have
423:59 - 3 to the power of four
424:02 - mod seven
424:05 - sorry that's
424:08 - four
424:11 - what's the next one three to the power
424:13 - of five
424:15 - mod seven
424:18 - five okay so this is doing it for us so
424:22 - that this one was three to the power of
424:23 - four mod seven we got four three to the
424:26 - power five mod seven
424:28 - five three to the power of 6 mod 7 let's
424:31 - use our calculator
424:36 - one
424:37 - okay
424:40 - nothing hard there
424:43 - now why do we do that
424:47 - our modulus is Prime Seven p is seven
424:52 - A Primitive route
424:55 - of seven is a number when we raise it to
424:59 - a power of all the integers up until
425:01 - that number seven but less than
425:04 - we get distinct answers
425:08 - so we say three
425:10 - is a primitive root of mod 7.
425:13 - with two we get
425:15 - non-unique values in this set of answers
425:18 - two occurs twice four and one occurs
425:21 - twice with a equal to three
425:25 - when we mod
425:27 - raised to the power of I and mod by
425:29 - seven we get this distinct set of six
425:31 - values
425:33 - yeah
425:36 - so we say a is a primitive root
425:40 - all right
425:47 - two and one are not in this case and
425:49 - then we can try for other numbers
425:51 - so that's the definition of primitive
425:53 - root
425:55 - we use it to do to work out when a
425:58 - discrete logarithm is possible
426:02 - the idea is that
426:04 - a discrete logarithm
426:07 - coming back remember logarithm find the
426:09 - find the exponent or index that's a
426:12 - logarithm
426:13 - given
426:15 - the base
426:16 - and the answer find the index that when
426:19 - we raise the base to that index we get
426:21 - the answer B same with discrete
426:23 - logarithm but everything is mod P
426:26 - with some base I
426:28 - if we mod P and get the answer B what is
426:31 - the index I
426:33 - sorry some base a
426:35 - base is a mod is p the answer is B then
426:39 - the index is I
426:42 - well we can only solve such value
426:46 - and get a unique exponent I that is get
426:49 - an answer that's unique
426:51 - if a the base is a primitive root of
426:54 - prime p
426:56 - so that's the conditions when our
426:58 - discrete logarithm will work
427:07 - it's
427:09 - give an example
427:18 - have we got
427:24 - what is this discrete log
427:29 - in base
427:32 - three
427:34 - mod seven
427:38 - of six
427:45 - the way we read that is that
427:49 - three raised to some power so some index
427:54 - mod by seven give us an answer gives us
427:56 - an answer six so what is that index
427:59 - 3 raised to some number then we mod by 7
428:03 - gives us six
428:05 - what is that number
428:09 - where do you get the number from
428:13 - we just calculated it didn't we
428:24 - three
428:27 - raised to the power of some number
428:31 - mod 7 this table we calculated these
428:34 - values calculated with Mod 7 gives us an
428:37 - answer six so what's the index that
428:39 - gives us an answer six
428:41 - three so the answer of this is three
428:56 - and we can check you can check that that
428:59 - is
429:00 - 3 the base to the power of the answer 3
429:03 - mod 7
429:08 - 3 to the power of 3 is 27 mod 7 gives us
429:11 - 6. okay that one's fine
429:15 - discrete log
429:18 - of Base 2. mod 7 still
429:23 - of
429:25 - four
429:32 - the discrete logarithm
429:35 - of four in base 2 mod 7 means two to the
429:39 - power of some number
429:42 - 2 to the power of some number mod 7
429:44 - gives us the answer of four what is that
429:46 - number what is the index
429:54 - what do we have as possible answers
429:58 - yeah we just calculated again
430:05 - we just calculated it for the values
430:07 - when we mod by seven we calculated it
430:10 - the base is two raised to the indexes of
430:14 - one through to six mod by seven we get
430:17 - the answers two four one two four one
430:21 - in this question we have or do we have 2
430:24 - to the power of
430:27 - discrete log of
430:31 - 4. so what index gives us an answer of
430:35 - four there are two possible values
430:37 - two to the power of 2 mod 7 gives us
430:40 - four two to the power of 5 Mod 7 also
430:43 - gives us four
430:46 - we don't have a unique value
430:48 - and therefore we cannot determine what
430:50 - the index was originally there's no way
430:52 - to know which index was it if we want to
430:55 - do a discrete logarithm there's no
430:58 - unique answer here
431:01 - why
431:02 - because the base is not a primitive
431:05 - route of seven
431:08 - so when the base
431:10 - this value is a primitive root of the
431:12 - modulus
431:14 - then we can get a unique answer
431:16 - because we have a distinct set of values
431:18 - here but when the base like two is not a
431:22 - primitive root of seven then we will not
431:24 - get a unique exponent because we have
431:26 - multiple instances of the answer
431:31 - so what's the answer well we say there
431:33 - is no answer or no unique answer
431:37 - not of interest to us
431:42 - there are two possible answers
431:45 - but generally we'd like to get a unique
431:47 - value especially when we apply to
431:48 - encryption
431:49 - so
431:51 - when we want to use the discrete
431:53 - logarithm we normally need to have the
431:55 - base To Be A Primitive root of the
431:57 - modulus
431:58 - in this case it's not
432:01 - and we'll see algorithms cryptographic
432:03 - algorithms that use this concept
432:12 - so again all we did was
432:15 - for our example when we're using mod 7
432:18 - we said
432:20 - well given the values one up until six
432:24 - the set of E
432:25 - exponents if a to the power of I these
432:29 - are the possible values of I when we mod
432:31 - by seven if we take all values of a
432:35 - which values when we raise the power of
432:38 - I give us a unique set here three does
432:40 - two dozen one dozen and you can check
432:43 - the others whether they do or not if
432:44 - they do it's called A Primitive root and
432:47 - if we have a primitive root in this case
432:48 - we can solve the discrete logarithm with
432:51 - a unique answer
432:59 - thank you
433:06 - not all
433:09 - okay and
433:11 - some useful values
433:17 - the only integers with primitive roots
433:21 - are listed here
433:23 - two four
433:26 - and some prime
433:28 - raised to some integer
433:30 - any Prime raised to the integer P to the
433:33 - power of one p to the power of two and
433:34 - two times that value
433:36 - so there's only some numbers have
433:38 - primitive roots and that restricts us
433:40 - when we want to find a discrete
433:41 - logarithm so when we want to use the
433:44 - discrete logarithm in a cryptographic
433:45 - algorithm
433:47 - we must choose our numbers carefully
433:52 - so for now just be aware what is a
433:54 - primitive root
433:56 - A Primitive root of some prime p is a
433:59 - number such that when we raise it to the
434:02 - powers up until P minus one we get
434:04 - distinct answers when we mod by P
434:07 - what is a primitive root
434:11 - and that for a discrete logarithm we can
434:13 - only find a unique exponent
434:17 - if the base a
434:19 - is a primitive root of the Prime p
434:22 - so that's what we need to know for now
434:25 - now we say we can find the answer
434:28 - another thing we'll see later maybe not
434:30 - today
434:32 - solving the discrete logarithm can be
434:34 - complex
434:37 - complex enough if you use large enough
434:39 - numbers practically impossible
434:42 - that is if you spend your 10 million
434:44 - years trying to solve it you will not
434:46 - get an answer it'll take too long
434:49 - so that will be a property that we take
434:51 - advantage of later
434:54 - but we'll return to that when we use it
434:59 - this is using Mod 19 as a different
435:02 - example we had an example of mod 7 if we
435:05 - have Mod 19
435:07 - what are the Primitive routes of 19.
435:12 - and this is a table similar to what we
435:14 - calculated this is the values of a
435:17 - and then a to the squared cubed up to a
435:20 - to the power of 18.
435:23 - up to P minus 1.
435:26 - how many primitive roots of 19 are there
435:32 - are six and this these gray boxes
435:35 - highlight
435:37 - look at the the answers when we raised
435:40 - the power in Mod 19 the gray boxes
435:43 - highlight the unique set of values
435:46 - A Primitive route is one that gives us a
435:48 - unique set of values which is distinct
435:50 - amongst all
435:52 - 18 in this case
435:54 - one two three four five six possible
435:56 - primitive routes they are two three ten
436:00 - thirteen fourteen and fifteen
436:08 - okay
436:10 - and in
436:12 - Mod 19 some discrete logarithms so the
436:16 - answers have been calculated for us
436:18 - so in base 2 base 3 10 13 14 15 base of
436:23 - the Primitive root Mod 19
436:27 - so for example
436:31 - log
436:32 - in base 13
436:34 - Mod 19 of 8
436:38 - is 15.
436:40 - that's how we read this table
436:42 - the log or the discrete log of the top
436:45 - row the answer is the the second row and
436:49 - the base is 13 here mod 19. the base
436:52 - here 14 mod 19. so the base are the six
436:56 - different primitive routes
436:59 - generally I do not ask you to solve a
437:01 - discrete logarithm in a quiz or an exam
437:03 - unless I give you some extra supporting
437:05 - information so especially with large
437:08 - numbers they're not solvable
437:10 - with large enough numbers there are no
437:13 - known algorithms that can solve the
437:14 - discrete logarithm in reasonable time
437:19 - with small numbers you can do it with
437:20 - trial and error okay you can find a way
437:23 - to do it but if it's large enough it
437:24 - will take too long
437:33 - and this actually this is the last point
437:36 - on this slide
437:37 - with certain problems
437:41 - when the numbers are large enough it
437:43 - takes too long to be able to solve those
437:45 - problems and we'll take advantage of
437:47 - that fact when we use some of this
437:50 - mathematics in in public key
437:51 - cryptography three problems that we will
437:54 - see that arise which are what we see
437:56 - computationally hard
437:59 - meaning
438:00 - if the numbers are large enough it'll
438:02 - take forever to get the answer
438:04 - factorization
438:08 - that is
438:09 - given some
438:11 - integer
438:14 - n which was calculated by multiplying
438:17 - two primes together
438:21 - if n equals P times Q
438:24 - p and Q are prime numbers large prime
438:26 - numbers
438:28 - if I give you n
438:30 - it'll take you forever to find p and Q
438:32 - if you don't know them that's the
438:34 - problem there there's no known algorithm
438:36 - that will take n and Factor it into its
438:40 - two Primes in reasonable time
438:44 - uh one example of a large number uh
438:48 - one maybe five or so years ago now a
438:52 - number n which was
438:55 - the number n was 768 bits long or 232
438:59 - decimal digits so write a number 232
439:03 - digits
439:04 - given that number
439:06 - Factor it into its two primes p and Q
439:08 - several years ago it took some on
439:11 - something like 2
439:12 - 000 uh Computing or man years to
439:16 - to do that factorization
439:19 - so if you make it longer
439:21 - it will effectively take forever
439:25 - sorry
439:26 - be
439:28 - and this problem is
439:30 - yes yes uh NP
439:35 - uh
439:37 - yes
439:38 - yes
439:40 - I don't know if all of them I think
439:43 - interfacturization
439:45 - I'm not sure
439:47 - uh in practice
439:51 - um
439:51 - too large whether it's NP uh what's the
439:56 - difference MP complete and be hard uh I
439:59 - don't remember for all of those
440:00 - algorithms so there's some slight subtle
440:02 - differences in the non-polynomial
440:05 - algorithms
440:07 - and effectively they are but there's
440:09 - some variations so some are easier than
440:11 - others okay
440:13 - but yes
440:14 - effectively
440:16 - all of these algorithms we cannot solve
440:19 - them in reasonable time if we have a
440:21 - large enough input
440:24 - the input for Euler's token is or the
440:27 - problem is
440:28 - given n just n
440:31 - a non-prime n a composite n find the
440:34 - totian remember the token was the the
440:37 - count of numbers less than n which are
440:40 - relatively prime with n
440:42 - we could do it we could okay if n was 20
440:46 - the 1 2 3 up to 19 check which numbers
440:49 - are relatively prime with n
440:51 - but now make n
440:53 - a thousand bits long
440:56 - hundreds of digits
440:58 - and then find the answer
441:01 - it's considered harder than it
441:03 - integer factorization
441:06 - with the same size n it will take you
441:08 - longer to do this and this so this one
441:10 - may take a million years this may take
441:12 - two million years
441:14 - but effectively unsolvable
441:17 - similar discrete logarithms with large
441:20 - enough values
441:21 - finding the index is considered
441:24 - unsolvable
441:27 - so if you know the base the modulus and
441:30 - B
441:31 - finding the discrete logarithm
441:34 - is impossible
441:39 - we'll come back to them and see how they
441:40 - used in cryptography and that's our next
441:43 - topic so let's get to it any questions
441:45 - before we move away from the theory onto
441:48 - the application in in security
441:54 - all right
441:58 - next topic public key cryptography
442:02 - what have you done
442:04 - crashed
442:14 - so all of the security schemes we've
442:16 - seen up until
442:18 - today have been symmetric key
442:20 - cryptography
442:22 - encrypt with one key decrypt with the
442:25 - same shared secret key now we're using
442:27 - to moving to a different approach public
442:29 - heat cryptography
442:30 - let's look at the principles and then an
442:32 - example
442:37 - so it's reported that around the 1960s
442:40 - the NSA and the US discovered the
442:43 - concepts or developed the concepts for
442:45 - public key cryptography
442:47 - similar organization in the UK
442:49 - around the same time or the 1970s that's
442:52 - the first known report
442:55 - but it was only made public and 1976
442:59 - two guys Diffie and Hellman come up with
443:02 - this idea of public key cryptography so
443:04 - that was the first that the public knew
443:06 - of this concept
443:08 - and it was only until later that NSA and
443:11 - and the government headquarters in in
443:13 - the UK started to advertise that they
443:16 - already knew about it so it's only been
443:18 - around for 40 50 years
443:23 - Caesar Cipher's been around for what two
443:26 - thousand years
443:27 - so it's relatively new
443:31 - the idea is to use two different keys
443:33 - for our encryption and decryption not
443:35 - using a shared secret key
443:37 - the motivation of Diffie and Hellman to
443:40 - come up with this idea was to
443:42 - when you use secret key encryption you
443:45 - often rely on someone generating the key
443:47 - for you and giving you the key you often
443:50 - need to trust someone else with a key to
443:53 - make it easy to distribute
443:55 - they wanted to develop
443:56 - a way to avoid relying on other
443:59 - organizations to to trust with your key
444:01 - and so you can do it just direct between
444:03 - two users
444:05 - and to do things like digital signatures
444:08 - which is
444:09 - someone can take some documents say
444:12 - electronic file and attach their
444:16 - signature to it
444:18 - such that at a later time anyone can
444:20 - prove that it came from that person
444:23 - that's your idea of a signature you sign
444:25 - a document the concept is that later
444:28 - someone can see that document and prove
444:31 - that it came from you
444:32 - that you have approved that document
444:34 - because it's got your signature on it
444:36 - they wanted to to provide this
444:39 - functionality and they come up with
444:41 - public key cryptography
444:47 - so the principles symmetric algorithms
444:50 - use the same secret key for both
444:52 - encryption and decryption
444:55 - asymmetric algorithms
444:57 - which is another way for public key
445:00 - cryptography algorithms
445:02 - asymmetric use one key for encryption
445:06 - and a different
445:08 - but somehow related key for decryption
445:11 - so two different keys
445:13 - they're not random keys but they're
445:15 - related in some way
445:20 - usually they require that
445:22 - asymmetric algorithms that it's hard
445:25 - computationally and feasible practically
445:27 - impossible
445:29 - if you know the algorithm and you know
445:31 - one of the keys
445:32 - to find the other key
445:37 - sometimes it's useful to have to be able
445:40 - to use the keys in office orders but
445:41 - we'll ignore that last point we'll come
445:43 - to it when we need it
445:45 - so we have now have two keys encrypt
445:49 - with one
445:50 - decrypt with the other
445:52 - and the requirement is that if I know an
445:56 - algorithm
445:57 - I know one key it should be hard for me
446:00 - to be able to determine or calculate the
446:02 - other key
446:08 - so in fact we have two keys we talk
446:10 - about a key pair
446:12 - and one's a public key and one's a
446:14 - private key so we talk about our public
446:16 - private keypad
446:19 - and in most systems the way that works
446:22 - each user in that system has their own
446:24 - care own key pair
446:27 - so we denote that for user a they have
446:30 - two keys
446:31 - the public key of user a and the private
446:34 - key of user a so the private key of
446:37 - Steve and the public here Steve I have
446:39 - my own key pair
446:41 - you have your own key pair everyone has
446:43 - their own keypad
446:46 - often created by yourself
446:49 - and we'll see the ways we're creating
446:51 - them later
446:52 - they're not random numbers
446:54 - okay they're the key values are not
446:57 - random numbers they are related somehow
447:04 - a public key as you guessed by the name
447:07 - it can be made public
447:09 - that means if I have my public key and
447:12 - private key the two values I can tell
447:14 - all of you my public key
447:16 - doesn't matter
447:18 - it's available to everyone
447:20 - anyone who wants it
447:23 - my private key again should be secret
447:27 - it should be private to me
447:30 - so I have my key pair I tell everyone
447:33 - you I tell everyone my public key but I
447:36 - keep my private key secret I don't tell
447:38 - anyone that's the assumptions that uh
447:40 - our keys rely on
447:43 - and then
447:44 - all right let's see these four secrecy
447:46 - and authentication with some pictures uh
447:53 - to explain how we use those keys
447:56 - so the concept
447:58 - let's say I want to get a message from A
448:00 - to B confidentially
448:05 - we have a message M the plain text
448:08 - this is user a on the left user B on the
448:11 - right
448:12 - we want to get a message from from A to
448:15 - B such that no one else in between can
448:17 - read the message
448:19 - we want confidentiality
448:22 - both users have their key pair
448:26 - so we can say user a has a key pair user
448:28 - B has a key pair
448:30 - to achieve confidentiality what we do
448:33 - user a on the left takes the message
448:37 - uses a public key encryption algorithm e
448:42 - and uses the public key of the
448:44 - destination
448:46 - so if user a is tending to B
448:49 - and they want this message only to be
448:51 - read by B
448:52 - and user a encrypts the message using
448:57 - the public key of B
448:59 - in this encryption process
449:02 - and the result we can write as we
449:04 - encrypt using the public key of B
449:07 - message M and we get some ciphertext as
449:09 - output
449:11 - we send the site text across the network
449:16 - the destination B receives the
449:18 - ciphertext
449:20 - and to decrypt they use their
449:22 - corresponding private key
449:25 - if a message was encrypted with B's
449:27 - public key
449:29 - our algorithm should be such that it
449:31 - will only successfully decrypt with
449:33 - these private Key Well the other key in
449:35 - the key pair
449:38 - so what b does
449:40 - they take the cytotec C
449:43 - their private key prb and decrypt using
449:47 - our algorithm
449:49 - and if our algorithm is designed
449:51 - correctly
449:52 - they'll get the original message as an
449:54 - output
449:56 - so we'll get the plain text back
449:59 - so if we want to have confidentiality
450:01 - with public key encryption and this is
450:03 - an important point to remember the
450:04 - concept is always encrypt with the
450:07 - destinations public key
450:10 - we'll look at the algorithms for e and d
450:13 - uh in this topic
450:16 - but the concept in general is you
450:19 - encrypt with the destinations public key
450:22 - and the destination decrypts with their
450:25 - private key
450:27 - and because
450:30 - why does it work
450:32 - well the keys should be related in such
450:35 - the way that it will only successfully
450:37 - decrypt if we use the other key in the
450:39 - key pair
450:40 - we have a key pair p u b p u r p r b
450:46 - public key of B private key of B
450:49 - if we encrypt with the public be a
450:52 - public key of B we can only decrypt with
450:55 - a private key of B
450:58 - that's the the requirements of our
451:00 - algorithm
451:03 - now why does this provide
451:05 - confidentiality
451:07 - let's say a malicious user intercepts
451:09 - the ciphertext
451:10 - they have sea they want to find m
451:16 - so they have C they need to decrypt C
451:19 - using some key
451:21 - but the nature of the algorithm should
451:23 - be such that we can only decrypt
451:26 - the ciphertext using the other key in
451:29 - the key pair from which it was encrypted
451:32 - this ciphertext was obtained by
451:34 - encrypting with a public key of B
451:37 - therefore it will only decrypt with the
451:39 - private key of B
451:41 - and by definition
451:44 - the private key of B is known only to B
451:46 - it's private to be
451:49 - so a malicious user cannot decrypt
451:52 - because they don't have the private key
451:53 - of B
451:55 - so no one can intercept and find the
451:57 - original message M unless we know that
451:59 - private key
452:04 - only the pro person with the private
452:06 - keys and can successfully decrypt
452:13 - for this to work
452:16 - we need to design an algorithm such that
452:19 - it was successfully decrypt and a way
452:21 - for generating the keys such that it
452:23 - will work in this manner so this is just
452:25 - the concept how does it actually work
452:27 - depends upon the algorithm
452:31 - but people have designed algorithms that
452:33 - meet these requirements so it does work
452:40 - we'll come back to authentication we can
452:43 - use the keys in the opposite order
452:45 - but we'll come back to that after we go
452:47 - through an example of an algorithm to
452:49 - see that in use
452:54 - what have we got
452:58 - let's go direct to an algorithm
453:01 - we'll come back to the applications
453:02 - after we see a detailed example let's
453:06 - get to one
453:07 - and the most common and maybe the first
453:09 - algorithm or one of the first few
453:11 - algorithms that was developed and still
453:13 - used widely today
453:15 - RSA we're going to go through it in
453:17 - detail
453:18 - see how it works and
453:22 - we may see another algorithm in a little
453:25 - bit less detail a little bit later maybe
453:27 - after the midterm
453:30 - so RSA is one algorithm for public key
453:33 - cryptography there are others
453:35 - this is my one of the most widely used
453:37 - algorithms
453:40 - where does the name come from it was
453:42 - developed by Ron rivest ADI Shamir and
453:45 - Len Adelman r s and a okay so the name
453:49 - comes from the three people who develop
453:51 - this algorithm
453:53 - so in 1978 these three researchers
453:57 - developed this algorithm and then they
453:59 - started a company to sell products that
454:02 - implemented the algorithm called RSA
454:05 - security eventually sold to some other
454:07 - companies so it's still part of another
454:09 - company now RSA
454:12 - EMC I think is the company
454:18 - it's the most widely used public key
454:20 - algorithm
454:22 - and the way that we think of the
454:26 - plain text and ciphertext is
454:29 - integers numbers
454:31 - it's a block Cipher we take a block of
454:34 - text an integer
454:37 - and we encrypt it using RSA
454:41 - and commonly it's just used on small
454:43 - inputs but we'll come to that after we
454:45 - go through how RSA works
454:50 - so going back to our general approach
454:53 - for public key cryptography
454:55 - we need an encryption algorithm
454:59 - we need a decryption algorithm
455:02 - and we need some way to get the keys
455:06 - unlike symmetric key cryptography
455:08 - the keys must be generated
455:11 - and they're related in some way in
455:13 - symmetric key cryptography we normally
455:15 - just create a random key a random
455:17 - sequence of bits
455:19 - but here we have an algorithm for
455:21 - generating the public and private key
455:24 - because for the decryption to work those
455:27 - keys must be related
455:30 - so with RSA
455:33 - there's a key generation algorithm we'll
455:35 - go through the steps
455:36 - then there's an encryption algorithm and
455:39 - a decryption algorithm
455:51 - and we can describe the whole algorithm
455:54 - of RSA on this single slide remember
455:57 - back to death
455:59 - simplified deaths even if you remember
456:02 - back to that lecture Des there are many
456:05 - different algorithms of the
456:08 - uh the
456:10 - generating the sub Keys the S boxes the
456:14 - uh the different rounds and we repeat
456:16 - the rounds with deaths the 16 rounds the
456:21 - many large s boxes and so on
456:24 - that was quite complex encryption with
456:27 - RSA is simply take our message as an
456:30 - integer
456:31 - rise to some power mod by n
456:35 - so conceptually it's very very easy
456:38 - it's just doing
456:40 - exponentiation in modular arithmetic
456:43 - modular exponentiation
456:46 - and decryption is just as easy
456:50 - it's the same algorithm
456:52 - just we vary the numbers that we use to
456:54 - decrypt some ciphertext we take the
456:57 - ciphertext
456:58 - raise it to some power D mod by n
457:02 - and we get the original message back
457:06 - very simple algorithms conceptually
457:09 - to implement and to a little bit more
457:12 - complex but compared to our block
457:15 - ciphers our symmetric block ciphers uh
457:18 - much simpler
457:21 - for this to work
457:23 - we need to generate the keys correctly
457:26 - and that's what we'll go through first
457:27 - the way of generating the keys and then
457:30 - we'll look at an example that shows how
457:32 - it works
457:36 - so what happens is that each user in the
457:38 - system generates their own key pair
457:41 - so imagine every user goes through the
457:44 - key generation steps
457:46 - and at the result of the key generation
457:48 - each user has a key pair
457:51 - once each user has a key pair we can
457:54 - encrypt and decrypt using the correct
457:55 - key
457:56 - so let's go through key generation first
458:00 - step to generate your own key pair
458:03 - what do you do
458:04 - is choose two primes p and Q
458:08 - two prime numbers
458:11 - and then you calculate n as the
458:13 - multiplication of those two Primes
458:17 - let's do it in an example
458:32 - let's go through an example where we
458:34 - generate our keys for the example we're
458:37 - going to use very small values just so I
458:39 - can calculate them we can always do it
458:41 - in our head but
458:42 - we'll talk later about in practice
458:46 - so first RSA key generation
459:02 - and you think each user does this they
459:05 - do it independently
459:07 - so the first step is to choose two prime
459:09 - numbers
459:15 - p and Q
459:20 - two prime numbers okay
459:24 - I'll choose two that I can calculate
459:26 - easily
459:27 - p17 Q is 11. okay we'll talk later about
459:32 - what are the recommender values
459:34 - especially regarding length
459:36 - but the concept is the same
459:38 - and then we calculate n
459:43 - which is p times Q
459:57 - where we hit 187.
460:02 - so that's the first step in generating
460:04 - our keys
460:12 - The Next Step
460:15 - we're going to need the totient of n
460:18 - we're going to use the totian of n to
460:21 - find some other value either so let's
460:22 - first work out the totient of n Euler's
460:25 - totium
460:29 - what's the value
460:35 - the torsion of N and in our case is 187
460:44 - quickly find the answer
460:50 - of 187. the totian remember that the
460:55 - number of numbers less than 187 which
460:59 - are relatively prime with 187.
461:02 - so we in the very basic form we say all
461:05 - right number one is it relatively prime
461:08 - with 187 well what does relatively prime
461:11 - mean it means are the two numbers have a
461:14 - greatest common divisor of one
461:16 - and 187 greatest common divisor one okay
461:20 - relatively prime two and weight at one
461:23 - eight seven what's the greatest common
461:25 - divisor if it's one and relatively prime
461:28 - three and one eight seven four and one
461:31 - eight seven and so on
461:33 - what's the answer
461:35 - how many numbers less than 187 are
461:38 - relatively prime
461:40 - 160 okay he calculated quickly
461:44 - we don't do it the manual way
461:46 - okay we've got a formula that will help
461:49 - us solve this quicker
461:51 - if we go back to our number Theory
461:57 - one characteristic of the totian of n is
462:00 - that the totian of I'll just write it
462:02 - here the total of a prime number
462:06 - is p minus 1.
462:10 - because the number of numbers less than
462:13 - that Prime
462:15 - which are relatively prime with that
462:17 - Prime is all of them
462:19 - so the numbers less than P there are P
462:22 - minus one values so the total of a prime
462:25 - is p minus one
462:27 - and it can follow from that the totian
462:29 - of two primes multiplied together
462:31 - remember p n is just P times Q
462:35 - is the totian of
462:37 - the primes multiplied together
462:40 - so let's write that
462:42 - 187
462:44 - we know because we just calculated it is
462:46 - 17 times 11.
462:49 - so do it on the four way
462:52 - 17 is a is a prime 11 is a prime because
462:55 - we just chose them that way
462:58 - so it's equivalent to the partition of
463:00 - 17 times the total of 11.
463:04 - that's true if they are prime numbers
463:09 - and the totian of 17 is 17 minus 1.
463:13 - and the total of 11 is 11 minus one
463:22 - so the fact that we chose the primes
463:24 - means we can quickly solve the total of
463:27 - the multiplication of those two Primes
463:39 - that's going to be needed in step two
463:43 - step two is Select some value e some
463:46 - integer e
463:49 - such that it is relatively prime with a
463:52 - totian of n
463:54 - and it's stated on the slide here is
463:56 - that e and the totion of n the greatest
464:00 - common divisor is one
464:02 - or in other words the two values are
464:04 - relatively prime so find an e which is
464:07 - relatively prime with 160.
464:12 - and it should be less than the totian of
464:13 - n
464:15 - there may be multiple values
464:17 - find one
464:19 - yes
464:21 - it's not small
464:23 - find an a number
464:26 - that is relatively prime with 160.
464:30 - small as possible
464:35 - uh sorry e should be greater than one
464:38 - and less than the totian of n okay so
464:40 - not one
464:42 - there are multiple answers okay
464:46 - so it needs to be a number
464:49 - which has a greatest common divisor with
464:52 - 160 of one
464:55 - seven yeah
464:58 - so
464:59 - greatest common divisor with 160 it's
465:01 - not going to be an even number
465:04 - two has a greatest common divisor with
465:06 - 160 of two so that's not an answer 3 and
465:10 - 160
465:13 - 4 5 6. try some numbers just try a few
465:20 - so we have the total of 187
465:25 - find an e
465:27 - we want
465:30 - the greatest common divisor of e and 160
465:34 - to be 1.
465:37 - so an e should be
465:41 - greater than one
465:42 - and less than 160.
465:45 - as the condition
465:48 - so
466:00 - you can test them okay
466:03 - in a very simple form two and 160 no
466:07 - they don't have a greatest common
466:08 - divisor of one
466:09 - three in 160 yes that one's okay
466:14 - 4 and 160 in fact all of the even
466:18 - numbers have a greatest common divisor
466:20 - or have a divisor of at least two
466:22 - so the the
466:25 - we can rule out the even numbers
466:27 - 5 and 160.
466:29 - greatest common divisor
466:32 - is it one or higher
466:35 - it's higher 160 has a divisor of five so
466:39 - we cannot use five seven
466:43 - check
466:44 - it's okay
466:47 - 160 will not divide by seven seven is a
466:50 - prime number
466:51 - and we can keep going nine
466:54 - I think you'll find nine is okay
466:59 - eleven
467:01 - is also okay
467:04 - there are multiple answers here
467:06 - many or multiple numbers
467:09 - between 1 and 160 which are relatively
467:12 - prime with 160 choose one of them
467:16 - that's the step two
467:19 - and that's the value e
467:21 - in our algorithm and I would choose
467:24 - because I've got the answer
467:26 - seven
467:38 - next
467:40 - so that was step two
467:42 - step one choose your primes calculate n
467:46 - step two calculate the totion of N and
467:49 - find e
467:51 - select an e
467:54 - such that it is relatively prime with
467:56 - the totian of n
467:57 - step three
467:59 - find some d
468:01 - or calculate d
468:03 - such that D is the multiplicative
468:07 - inverse of E
468:10 - in them
468:12 - thank you
468:14 - in mod the torsion of n
468:18 - so
468:19 - D times e
468:22 - mod the totian of n should be one that's
468:25 - our requirement find D
468:32 - E I chose a seven find D
468:38 - in other words e and D are
468:41 - multiplicative inverses
468:43 - multiply them together we get one as the
468:45 - answer
468:54 - when we mod by the total of n which is
468:57 - 160. so
469:02 - e
469:03 - you're correct e times d
469:07 - mod
469:09 - our totion of n 160
469:12 - should equal one
469:16 - a is
469:22 - let's get rid of a
469:23 - e is 7 in our case seven times D mod 160
469:29 - equals one
469:30 - what value of d
469:35 - and you can manually try some different
469:37 - values okay so the the very basic way
469:44 - seven times d
469:46 - mod 160 equals one means seven times D
469:49 - should be either 161
469:53 - or 321
469:55 - [Music]
469:57 - or 481 or some other value
470:00 - why because when we mod by 160 we'll get
470:03 - one
470:05 - so that's the basic way that is
470:08 - if 7 times d
470:14 - if it equals
470:16 - 161
470:17 - [Music]
470:19 - then 161 mod 160 gives us one
470:23 - is there any and remember we're dealing
470:25 - with integers here is there a d such
470:27 - that multiplied by 7 we get 161.
470:31 - or other words
470:33 - 161 divided by 7 do we get in an integer
470:39 - yes
470:40 - D equals 23.
470:46 - so we've got our new parameter d
470:50 - they're in fact algorithms for the
470:52 - computer to do this to solve it quite
470:54 - quickly to find such a d it's not so
470:57 - hard to find with a with an algorithm
470:58 - there are algorithms that will do it for
471:00 - us
471:01 - if you want to do it manually then
471:04 - basically you look at
471:06 - what number when you multiply with e
471:08 - gives us 161 plus one
471:12 - or two times 160 plus one or three times
471:15 - 160 plus one because all of those
471:18 - numbers mod 160 will give you one
471:24 - we're done
471:26 - we've generated our key pair
471:30 - the values which are generally
471:32 - considered our key pair the public key
471:34 - is e and n
471:37 - the private key is DNN
471:41 - but in practice
471:43 - some other values are often stored as
471:45 - well especially p and Q
471:48 - they are also private
471:52 - it depends upon the implementation
471:55 - but pink p and Q must be kept secret
471:59 - one way to keep them secret is to delete
472:01 - them
472:03 - you generate them using a computer two
472:06 - large Primes
472:07 - go through these steps get your value of
472:10 - e d and n then delete p and Q
472:14 - so then no one can find it
472:17 - but it turns out to help with the
472:20 - implementations it's usually useful to
472:21 - keep those values we use them later but
472:24 - in in theory you don't need them in
472:26 - practice we often do
472:28 - so let's write down our key pair
472:34 - and I will denote as the public key of
472:37 - our user
472:41 - what are we at e was seven
472:45 - n is 187
472:51 - and the corresponding private key in
472:54 - this pair
472:59 - d
473:00 - is 23
473:04 - n is 187
473:07 - the same n
473:10 - a little bit conflicting in the words or
473:12 - the terminology here we said the public
473:15 - key is made public
473:17 - okay we can tell everyone
473:19 - my value of e is seven my value of n is
473:22 - 187 I can tell everyone once I've
473:24 - generated these
473:26 - the private key should be kept private I
473:29 - should keep it to myself not tell you
473:31 - but often because we use n we also write
473:36 - it in the private key n is not private n
473:39 - is public because it's in the public key
473:42 - but we often write it as part of the
473:44 - private key as well
473:46 - because we use it when we do the
473:48 - encryption and decryption so be careful
473:50 - there are really three values here e and
473:52 - D
473:54 - must be secret
473:56 - don't tell anyone your value of d
473:58 - e and n
474:00 - can be public or and are made public
474:03 - but often we write the private key is
474:06 - also including n
474:16 - so I generate those values I tell you my
474:19 - public key yep
474:24 - if you know Ian n can you calculate d uh
474:28 - no
474:29 - if the numbers are big enough
474:31 - and and I think we'll run out of time
474:34 - today but in the next lecture we'll go
474:36 - through and see well what can an
474:38 - attacker do
474:40 - when we have large enough numbers for
474:42 - today we'll just get to let's use the
474:44 - algorithm the next lecture will analyze
474:46 - and see well why does it work
474:50 - for now I think we won't get time to see
474:52 - why it works we'll just see how it works
474:54 - of how to use it
474:57 - but you're on the right track that we
474:59 - need to start asking well what does an
475:01 - attacker do
475:03 - we will come back to that
475:08 - so for now we've generated a key pair
475:11 - everyone does that generates their own
475:14 - key pair you tell everyone else e m
475:18 - you don't tell anyone D or P or Q they
475:21 - must be kept secret
475:24 - now you want to encrypt some message
475:30 - where are we here sorry
475:36 - let's say this is the key pair that
475:39 - we've generated for user B
475:43 - user B did this
475:45 - and a wants to send a message to b
475:53 - and we want this message to be secret to
475:56 - be confidential
475:58 - what do we do
476:02 - we have some message we want to send it
476:04 - to be
476:08 - what we do is we take that message and
476:10 - we encrypt it using the RSA algorithm
476:13 - and to keep the message secret we
476:15 - encrypt it with B's public key
476:19 - okay so to send to someone else
476:22 - use their public key
476:25 - what's the message
476:29 - my message is a complex one it's 88.
476:35 - the plain text in RSA are just integers
476:39 - so let's say you have a sequence of bits
476:40 - like an ASCII message a hello
476:43 - you must somehow represent that as
476:45 - integer just as one number
476:48 - because the encryption operation
476:49 - operates on that integer and that's easy
476:51 - to do if you have ASCII
476:54 - you can create the uh
476:57 - the binary form of each letter h e l l
477:00 - and O get it in 8-bit values and then
477:03 - you can combine those uh five eight bit
477:06 - values you get 40 bits and that can be
477:07 - your integer
477:09 - so you can convert any message into a
477:11 - single number
477:16 - the constraint
477:17 - is that the
477:19 - the integer M your plain text so that
477:22 - you want to send must be less than the
477:24 - number n
477:26 - our n is 187
477:29 - so we have
477:31 - must have a plain text Which is less
477:33 - than 187 so I've chosen 88. what does 88
477:36 - mean nothing in this context but uh with
477:39 - a larger example it could have some
477:40 - meaning
477:43 - and then we use this equation to encrypt
477:47 - take your message raised to the power of
477:49 - E
477:50 - mod by n and you get sieve
477:56 - so a does that
478:04 - foreign
478:10 - to encrypt they use B's public key
478:14 - the value of e is 7.
478:19 - and N is 187.
478:27 - what's the answer
478:29 - you can go and do it on pen and paper
478:31 - remember last week we showed you how to
478:33 - do the modular multiplication or
478:36 - exponentiation you can break it into 88
478:39 - squared three times and then Times by
478:42 - 88.
478:44 - you don't need to do it I've got the
478:45 - answer for you
478:50 - I don't know if my calculator will do it
478:51 - 88 to the power of 7. mod187
478:57 - 11.
478:58 - okay so we can calculate that
479:09 - we send that across the network
479:13 - the value 11.
479:17 - again
479:18 - I know it's hard to to visualize but the
479:21 - value of 88 is our plain text
479:24 - it has no meaning in this example but if
479:27 - we had a much larger numbers we could
479:29 - have the integer to represent any
479:31 - information just by converting that
479:34 - information to binary
479:37 - we send the ciphertext across the
479:39 - network
479:40 - B the receiver decrypts
479:44 - and the decryption algorithm is that you
479:46 - take C
479:47 - raised to the power of d
479:50 - mod by n
479:52 - and you should get the message back
479:54 - let's try
479:57 - so B receives
480:01 - to get the message back let's say m
480:03 - Prime the received value
480:06 - they take C
480:08 - 11
480:09 - raise it to the power of d d
480:13 - it was encrypted with B's public key
480:17 - therefore we decrypt with B's private
480:19 - key in this case D is 23.
480:25 - n is 187 again
480:34 - and I need my calculator 11 to the power
480:37 - of 23 mod 187.
480:45 - any guesses
480:48 - 88
480:49 - Magic
480:56 - it works
480:58 - that is with these numbers at least
481:03 - when we took 88 raised the power of E
481:06 - mod by 187 and then took that value and
481:09 - raised it to the power of D this other
481:11 - number
481:12 - mod by the same end
481:15 - we get the original message back and
481:17 - that's what we need for encryption
481:20 - we need to be able to encrypt get
481:21 - ciphertext and decrypt and get the
481:23 - original plain text otherwise it's
481:25 - useless
481:28 - it worked in this case
481:30 - it will work in all cases
481:32 - because of the way that we chose those
481:35 - keys e and D
481:43 - thank you
481:47 - why
481:49 - all right before we go through why will
481:50 - it work any questions on the steps so
481:52 - far
481:54 - not on how we attack it but just on how
481:57 - we generate the key and how we encrypt
481:58 - and decrypt
482:00 - any questions
482:03 - so when we have a quiz on Thursday if we
482:05 - have a quiz then you can encrypt with
482:07 - RSA decrypt with RSA generate RSA keys
482:12 - at least for small values
482:17 - all right you need a calculator for this
482:20 - step
482:22 - well you don't really I could ask you I
482:24 - wouldn't in a quiz but I could ask you
482:25 - to solve it manually
482:27 - by expanding it out you could but are
482:31 - not that mean uh
482:34 - not in a quiz in an exam I'm meaner than
482:37 - that so you may have to solve these
482:39 - manually but the steps
482:42 - you should be able to generate your own
482:44 - key pair
482:45 - using small numbers like I've just
482:48 - chosen
482:54 - any questions
483:00 - first what the last thing today yeah
483:04 - why does it work
483:07 - if we change M to a different value will
483:10 - it always produce when we get the
483:12 - ciphertext and decrypt with d will we
483:14 - always get M back here
483:16 - well yes it will why
483:20 - let's have a quick look
483:27 - let's look in general the equations
483:35 - sorry C we start with
483:38 - the first equation we have is C equals m
483:40 - to the power of E mod n
483:46 - and the other equation we have is M the
483:49 - decryption is C to the power of d
483:52 - mod n
483:59 - so let's start with the right one
484:03 - start here M so the other two equations
484:06 - we have we want to see if we start with
484:09 - M encrypt
484:11 - and then decrypt will we get the
484:13 - original M back
484:15 - start with the right equation and do
484:16 - some substitutions
484:22 - so that's just the right equation
484:25 - the right hand side now let's replace
484:27 - this C
484:29 - with this C
484:32 - okay we know C equals m to the power of
484:35 - E mod n
484:37 - let's call this m m Prime
484:41 - meaning the the decrypted m
484:44 - we take our ciphertext decrypt and we
484:47 - get M Prime
484:49 - now let's replace C with the top left
484:52 - equation
484:57 - C is in fact created by taking m
485:00 - to the power of E mod n
485:04 - all to the power of d
485:07 - mod n
485:10 - so I've just done a substitution in that
485:12 - case
485:17 - we can expand this that is
485:20 - m to the power of E mod n all to the
485:23 - power of D we have the same properties
485:25 - in Normal exponentiation
485:28 - m to the power of E
485:30 - o to the power of d
485:32 - is what
485:36 - m to the power of D all to the power of
485:38 - E
485:39 - in normal arithmetic
485:47 - equals
485:50 - with normal arithmetic m to the power of
485:53 - E times d
485:55 - the same applies in modular arithmetic
485:57 - and you can check and go back to our
485:59 - properties to see that
486:01 - m to the power of e to the power of d
486:04 - is the same as m to the power of E times
486:07 - d
486:13 - mod n
486:17 - mod n
486:19 - and we don't really need that
486:25 - all I did was effectively bring this D
486:28 - inside here
486:31 - m to the power of e to the power of D is
486:34 - m to the power of E times D mod n and we
486:36 - have the second mod n but note
486:40 - if you mod end multiple times it's the
486:43 - same as modding and one time
486:46 - 12 mod 10 is 2. mod 10 is 2. mod 10 is
486:52 - two if you keep modding 10 you'll still
486:54 - get two so it doesn't matter how many
486:57 - mod ends we have here it's equivalent to
487:00 - just to one mod n
487:05 - so it simplifies to m to the power of E
487:08 - times D mod n
487:15 - so
487:19 - if we take our original message M
487:22 - raise it to the power of E times D mod n
487:27 - we get M Prime
487:30 - our encryption and decryption will work
487:33 - if m equals m Prime
487:38 - that's our requirements for successful
487:41 - decryption to get the original M back
487:46 - so
487:48 - it leads to the question is in what
487:51 - conditions
487:53 - does m equal m Prime
487:59 - if you take some number
488:01 - raise it to the power of E times d
488:04 - and mod by n you get that same number as
488:07 - an answer
488:09 - if we have those conditions
488:12 - then our decryption works
488:18 - foreign
488:27 - yeah one of our theorems from the
488:29 - previous topic is going to help us
488:32 - let's write it differently but just
488:33 - change the variables instead of M Prime
488:35 - we require M Prime and M to be equal
488:38 - let's say we require something like this
488:41 - a equals a to the power of something
488:45 - e times D mod n
488:49 - when do we have such a condition
488:53 - and this will be our last thing we look
488:55 - at I have to go back
488:58 - to last topic
489:03 - which will give you the answer
489:09 - here
489:12 - when does a to the power of something
489:14 - equal a in mod n
489:16 - when that something is the total of n
489:19 - plus one
489:23 - so we will use this theorem to find the
489:27 - conditions when RSA algorithm works
489:34 - but we've run out of time
489:37 - so the next step what we'll do is we'll
489:39 - take this algorithm
489:41 - and we'll use it to find the last two
489:43 - conditions
489:47 - but if we think of that as
489:52 - the totian out the theorem was like this
489:57 - version of n
490:02 - almost the same
490:04 - when are when are these two equations
490:06 - the same
490:10 - when are these the same when e times D
490:12 - equals a total of n plus one
490:22 - if we have e times D equals the total of
490:25 - n plus one
490:26 - let's finish today
490:29 - I mean let's spend another minute to
490:31 - finish
490:33 - those two will be the same if this is
490:36 - true
490:37 - when is this true
490:40 - well when e times d
490:46 - mod
490:49 - the totian of n
490:53 - equals one
490:55 - that is
490:57 - um
490:59 - mod this by the totian of n
491:01 - and you get the left side mod this side
491:04 - by the torsion of n divide by the totion
491:06 - of n the remainder is one the total of n
491:08 - plus one mod the totian of n is one left
491:11 - over
491:13 - so that's our condition for when RSA
491:15 - will decrypt
491:20 - and if you go back to the key generation
491:23 - we have this condition we chose
491:27 - a d
491:29 - such that when we Times by e
491:32 - and mod by the totian of n we got one
491:35 - so the way that we generated the keys
491:37 - made sure that this condition was true
491:40 - which makes sure RSA decrypts
491:43 - successfully
491:47 - so that's the way to show that RSA
491:50 - always works if you generate the keys in
491:52 - that
491:53 - that approach with the algorithm we we
491:56 - use
491:59 - that's a bit involved
492:01 - try and understand make sure you know
492:04 - the key generation encryption and
492:05 - decryption and then try and understand
492:07 - the concepts behind why RSA works
492:12 - what we'll do next lecture is attack RSA
492:17 - if we're the malicious user
492:19 - how can we find the plain text given the
492:22 - ciphertext or even better how can we
492:24 - find the key the private key given just
492:28 - the public key or the ciphertext we'll
492:30 - look at that next lecture
492:34 - foreign
492:40 - 's awake good if you're interested in
492:43 - RSA
492:44 - you may have seen or in Security in
492:47 - general sorry I've got it somewhere
492:51 - you may have seen in the news last week
492:52 - and this week on the technical news that
492:55 - people have come up with ways to break
492:57 - RSA researchers cracked the world's
492:59 - toughest encryption they're referring to
493:01 - RSA by listening to Tiny sounds maybe
493:04 - your computer or your CPU
493:06 - the setup is a laptop here decrypting
493:09 - with RSA
493:10 - a microphone
493:12 - it listens into the CPU actually listens
493:16 - to the noise it makes and comes out of
493:18 - the fan of the the laptop
493:21 - and then from that they determine the
493:24 - secret key
493:26 - just by listening to the CPU from a
493:28 - distance of one to four meters
493:35 - it works
493:36 - and if you're interested this week I'm
493:39 - going to give a presentation maybe at a
493:41 - lunchtime break where there's no one no
493:43 - one has any free time about how it works
493:46 - so I'll send out an announcement
493:48 - tomorrow maybe it's not required to
493:50 - attend only if you're interested in
493:52 - knowing out knowing how it works it will
493:55 - most likely be Friday lunchtime then
493:57 - we'll I'll give some plots and some
493:58 - results from their paper that show
494:01 - how that works okay that will be
494:03 - breaking RSA
494:05 - it's not needed for the lecture only if
494:07 - you're interested
494:13 - so again this is our RSA encryption
494:17 - decryption and the other part which is a
494:19 - bit hard to remember but you should it
494:21 - would have helped you solve that part C
494:25 - of the first exam question is that the
494:27 - key generation
494:30 - now
494:31 - with RSA the security comes from using
494:34 - large numbers not from using small
494:36 - numbers like in the exam of course we
494:38 - can break that it's using large numbers
494:40 - and therefore we need software to do the
494:42 - uh
494:44 - encryption and decryption for us and
494:46 - also importantly to generate the keys
494:49 - with symmetric key ciphers
494:53 - there's a shared secret key
494:56 - how do you generate a key for a
494:58 - symmetric key Cipher
495:02 - random okay you and I we want to use AES
495:06 - to encrypt in our data between us we
495:09 - both need the same key so what may
495:11 - happen is I choose a random number
495:14 - uh 256 bit key a 256-bit random number I
495:19 - generate it using some software openssl
495:22 - I give you that random number and that's
495:25 - the key that we will use it's a shared
495:26 - secret key between the two users
495:29 - but with public key crypto
495:31 - the keys are generated According to some
495:34 - algorithm not a random number
495:38 - so with RSA here's the algorithm
495:42 - so we can use openssl to generate these
495:45 - keys
495:47 - and again the idea is that every user
495:50 - has a pair of keys public and private
495:53 - key so you generate your own pair
495:58 - I'll show you how to do that with
496:00 - openssl and there are some notes on this
496:02 - I'll point to on the website so I'll
496:04 - just go direct to the command
496:07 - uh you can zoom in
496:12 - we can use different software to
496:13 - generate the keys and this is just one
496:15 - way to use openssl
496:18 - to generate a public
496:20 - or in this case a public private key
496:22 - pair the operation gen P key
496:26 - we're using sorry
496:29 - we're using the algorithm RSA there are
496:33 - other algorithms that we can use for
496:35 - this one just RSA
496:37 - and then we've
496:39 - we don't have to but in this case I'll
496:41 - specify two key options
496:44 - this Dash it continues across the next
496:46 - line Dash P key opt
496:49 - an option for the key we can specify
496:52 - some optional parameters
496:55 - the first optional parameter is the key
496:58 - length
497:00 - with RSA
497:02 - the key length is really the length of n
497:07 - the modulus n
497:11 - so I specify I want n to be 2048 bits
497:20 - and
497:23 - all right we may have seen in the slides
497:26 - there are three typical values for n in
497:28 - common use 1024 bits 2048 and 4096. the
497:34 - larger value the more secure
497:36 - but the slower it is to encrypt
497:39 - and decrypt
497:41 - the second option
497:45 - is that public exponent
497:50 - I specify in this case
497:52 - the public exponent
497:54 - e to be three
497:58 - so I can choose the value of E
498:01 - if I don't give these options openssl
498:04 - will choose default values and from
498:06 - memory I think the default public
498:09 - exponent is 65 537 it's a common value
498:14 - and it's probably best to use that
498:16 - compared to three but I just use it as a
498:18 - different example here three and I can't
498:21 - remember the default size maybe it's
498:22 - 1024.
498:27 - everyone watch and see how long it takes
498:30 - so I'm going to generate my key pair
498:35 - all right almost instantaneously it took
498:37 - a bit of time
498:39 - you see some dots and so on it takes
498:41 - some time because
498:43 - what just happened then
498:45 - was my computer
498:49 - chose two primes p and Q
498:52 - such that when those two multiplied
498:54 - together we got a
498:56 - 2048-bit number n
498:59 - then it selected some value e well that
499:03 - was already selected three
499:05 - I better calculated D which is uh the
499:08 - multiplicative inverse of e in the mod
499:10 - the total of n so these steps were
499:13 - performed by open SSL and that's case
499:15 - and we get a public and private key
499:19 - let's look at the values
499:24 - it was saved in a file called I call
499:28 - privkey.pm PM's just a format commonly
499:31 - used
499:33 - so my key pair
499:36 - is saved in this file it's 1704 bytes
499:39 - long
499:42 - let's look at the contents
500:02 - should we have a quiz
500:04 - next week on the contents of this file I
500:06 - think you should be able to do this you
500:08 - can try it at home
500:11 - zoom out
500:13 - try again
500:16 - there's my key pair
500:18 - now we need to explain the the format of
500:20 - this
500:22 - I generated the key pair
500:26 - we'll see the detailed values in a
500:28 - moment but what openssl does by default
500:31 - in this this format of the output is it
500:33 - it encodes the the values into some form
500:37 - that can be printed on the screen
500:40 - and for example included on a web page
500:42 - so this is not encrypted
500:44 - this is what we say is encoded
500:46 - in the same way that we have ASCII
500:48 - encoding to encode uh
500:52 - our different characters into some
500:54 - decimal or some binary value we can have
500:57 - different encodings and this is one
500:58 - encoding it's called base base64
501:02 - encoding
501:04 - that takes
501:06 - some binary values
501:09 - and encodes them using I think it's one
501:13 - of 64 different characters
501:15 - and that's the accommodation here so it
501:17 - makes no sense here but that's
501:19 - all the information needed because a
501:22 - decoder will find the original values so
501:25 - often you'll see
501:26 - not private keys but when we look at
501:28 - public Keys you'll see some encoding
501:30 - like this say attached to the bottom of
501:32 - an email
501:33 - or on a web page
501:37 - let's look at the actual values let's
501:39 - decode this
501:40 - and the way to do it openssl has an
501:43 - option
501:51 - we can
501:54 - output it in some nice to view text
501:56 - format
501:58 - take our input private key and produce
502:01 - an output in a text former and so I can
502:03 - scroll through I'll pipe it into less
502:06 - gives us the original form and we scroll
502:08 - down then it gives us n and now it gives
502:11 - us the human friendly form
502:14 - a little bit more human friendly than
502:16 - their first one
502:18 - it gives us the private key the modulus
502:21 - n okay there's the value of n
502:25 - it's 2048 bits
502:28 - but it's represented in hexadecimal here
502:31 - so if you convert you'll get this as a
502:33 - 2048-bit number
502:36 - the public exponent e
502:39 - so e is 3 in in decimal
502:43 - the private exponent D is the next value
502:46 - don't look at this because this is
502:48 - private for me
502:53 - again a lot another large number
502:56 - so this value is the secret value that
502:59 - it should be specific to you and not
503:01 - shared with anyone else right it's just
503:03 - a demo in this case
503:06 - so really we have three values e d and n
503:09 - d must be kept private e and N we make
503:12 - public
503:15 - but for
503:17 - performance reasons for the
503:19 - implementation we also store some other
503:21 - intermediate values
503:23 - so we just really need e DNN but open
503:26 - SSL and other software store some other
503:28 - values to to help the the speed up the
503:31 - encryption and decryption
503:33 - so we see prime one and Prime 2.
503:40 - recall what happens in the key
503:42 - generation is that we have a prime p a
503:46 - prime Q we multiply together to get n
503:49 - this is p and Q I don't know which order
503:51 - it doesn't matter the two prime numbers
503:53 - here
503:54 - so they are our large primes again must
503:57 - be kept private
503:58 - because if someone else knows these
504:00 - primes then they can easily break
504:03 - anything encrypted using your public key
504:09 - and then some other intermediate values
504:12 - are stored
504:13 - not so important for you to know about
504:15 - these there's two other exponents some
504:19 - other coefficient
504:21 - again just for implementation purposes
504:29 - those values which are stored in your
504:32 - key are listed here on one of the slides
504:35 - you can go back and check that but
504:36 - there's a modulus and the public
504:39 - exponent e the private exponent D the
504:42 - three values that we always think of
504:46 - where
504:48 - and we write it
505:02 - where we often write that the public key
505:06 - is e and n
505:09 - modulus and public exponent the private
505:12 - key is DNN
505:14 - private exponent and the modulus the
505:17 - remaining values are there for uh
505:21 - speeding up the encryption and
505:23 - encryption when we use these Keys the
505:25 - two primes and these other exponents and
505:27 - coefficient not so important to remember
505:29 - or worry about these
505:34 - they should be kept secret
505:37 - when you have them
505:39 - you shouldn't show anyone else what the
505:41 - values are
505:42 - otherwise they can defeat the RSA so
505:45 - really the public values that you can
505:48 - tell anyone else and an e the other
505:50 - values are kept private or Secret
506:03 - so I have a private key
506:06 - your next homework task is to generate
506:08 - your own Keys key pairs
506:12 - and we'll need to exchange some values
506:14 - and do some encryption and
506:16 - authentication using those key pairs
506:19 - so the private key
506:21 - from that
506:23 - we can extract the public values only
506:28 - so the values in the file so far are all
506:31 - of these we can extract just n and E
506:38 - and the way to do so
506:47 - with openssl we can extract just the
506:50 - public values
506:52 - we take our
506:55 - sorry
506:57 - we take our input private key
507:00 - which contains all values and output to
507:03 - some file I'll call Pub Key
507:07 - and
507:09 - specify to just output the public values
507:12 - so that we hide or don't display any of
507:16 - the private values
507:27 - so our private key contains all values
507:31 - proof key.pm public key contains just n
507:35 - and E
507:36 - and what you'll do in your homework is
507:38 - once you generate these the public key
507:41 - you can then tell over anyone else
507:43 - you can send anyone this file for
507:46 - example attach it at the bottom of an
507:47 - email put it on a web page because the
507:50 - cat contains your public values
507:53 - and we can look at them
508:02 - output into some text format so
508:06 - take my public key
508:09 - specify it's a public key coming in and
508:12 - display the output as text
508:15 - and just so we can scroll through our
508:17 - pipe into less
508:20 - and here's the encoded format of my
508:22 - public key
508:25 - so if you want to attach your public key
508:27 - to your email when you send someone an
508:29 - email you can attach just this encoded
508:31 - form
508:32 - because software will be able to decode
508:34 - it but here are the actual values the
508:36 - public key
508:37 - 2048-bit modulus and hexadecimal
508:43 - and the exponent E equals three
508:46 - so the two public values of N and E
508:58 - that's all we'll attempt to cover today
509:01 - because no one's too concerned so next
509:04 - week we'll move on to the next topic
509:07 - there's another algorithm for public key
509:10 - crypto diffie-hellman that we need to
509:12 - cover and then Authentication
509:17 - focused so far on
509:19 - confidentiality encrypting messages so
509:22 - no one can see the contents but another
509:24 - key part of security is making sure that
509:26 - we can confirm
509:28 - who did the message come from
509:30 - you receive a message did it come from
509:32 - Steve or someone pretending to be Steve
509:33 - like a masquerade attack
509:36 - so we need techniques to confirm that
509:38 - and we will use public key cryptography
509:41 - again to do that as well as some other
509:43 - techniques so that's the next topic
509:56 - so we got to this approach of using a
509:58 - public key Authority but before we we
510:01 - come back to this Authority approach and
510:03 - look at the another one let's just make
510:06 - sure everyone understands the problem
510:10 - I'm just going back
510:13 - to our man in the middle attack
510:18 - this was a scheme we used to distribute
510:21 - a secret
510:22 - and that's what we'll we're trying to do
510:27 - a wants to communicate with B
510:29 - to do so they want to encrypt their
510:32 - Communications
510:34 - and using a symmetric key algorithm
510:37 - so they want to encrypt
510:40 - everything using some secret key and in
510:43 - this scheme is denoted KS so KS is our
510:46 - secret
510:47 - but they don't know it yet
510:49 - so they haven't communicated in
510:52 - in the past
510:55 - so this scheme
510:57 - uses public key cryptography to exchange
511:00 - that secret where a sends its public key
511:03 - to B
511:05 - saying I am a I want to communicate with
511:09 - you
511:10 - let's create a shared Secret
511:13 - so that's step one we send our public
511:15 - key to a oh sorry we send
511:18 - our public key to B
511:20 - B generates a secret
511:23 - it creates KS
511:25 - let's say generator
511:27 - 256 bit random value and that will be
511:30 - the secret that they use for AES to
511:32 - encrypt the data so B creates KS
511:36 - and is going to send KS back to a but of
511:39 - course we cannot send the secret in the
511:41 - clear it must be encrypted because if we
511:44 - send it in the clear across our Network
511:47 - then someone can intercept and find our
511:49 - secret
511:50 - so what V does is encrypts the secret KS
511:54 - using the public key of A
511:58 - so that
511:59 - if someone intercepts this message
512:01 - message number two
512:04 - they need the private key of A to try
512:06 - and decrypt and get KS without the
512:08 - private key of A they will not be able
512:10 - to learn KS and who has the private key
512:12 - of A A does
512:14 - that's how uh understanding of public
512:17 - key cryptography only a has a private q
512:20 - a so the idea is that b sends this
512:23 - encrypted message back
512:25 - a receives it decrypts using the private
512:28 - key of A and learns KS
512:30 - and from then on they use KS to encrypt
512:33 - their data KS and some symmetric key
512:36 - cycle
512:37 - so this is a common technique that we
512:40 - use a public key
512:43 - and public key encryption to encrypt a
512:46 - shared secret key
512:47 - and once that secret key is shared we
512:52 - use that secret T secret key to encrypt
512:54 - using a symmetric key algorithm
512:57 - because symmetric key algorithms are
512:59 - much faster than public key algorithms
513:02 - but we saw that there's a problem with
513:03 - this
513:05 - we went through and I don't have the
513:07 - picture here but we went through and you
513:08 - went through and tried to work out well
513:10 - what could an attacker do
513:12 - and come up with this man in the middle
513:14 - attack
513:17 - a sends the message to b
513:20 - but someone in the middle modifies that
513:23 - message in particular uses a different
513:25 - public key
513:28 - just to remind us of what what it is
513:33 - the man in the middle attack involved
513:37 - a sending a message
513:43 - as per the original scheme public key of
513:46 - A
513:47 - and the ID of a
513:50 - but the man in the middle that is C
513:52 - intercepting
513:55 - and modifying such that they send so
513:58 - this is C receives that
514:02 - you've drawn this before they change the
514:05 - public key to theirs
514:08 - they don't change the identity
514:13 - B receives that so C is somewhere in the
514:17 - middle of the the path of a network they
514:19 - received the message before it gets to
514:21 - be and modify the public key
514:25 - B thinks it got a message from a
514:28 - B chooses KS
514:32 - and sends that KS back to a
514:37 - encrypted with the receive public key B
514:40 - thinks the public key
514:42 - of a is this value
514:44 - but it's in fact the public key of C
514:49 - so B encrypts KS using the public key of
514:52 - C
514:53 - not knowing that thinking it's the
514:56 - public key of
514:59 - a
515:01 - as a result when C intercepts the reply
515:05 - it can decrypt and learns KS
515:11 - C can decrypt because C has the private
515:13 - key of C
515:15 - and then C sends back
515:19 - that same KS to a
515:23 - but encrypted with A's public key
515:26 - which is of course known
515:33 - and when a receives this reply they
515:36 - decrypt with their private key and they
515:38 - learn KS
515:39 - so we've gone through this attack of
515:41 - this man in the middle attack just to
515:43 - remind you that someone in the middle
515:45 - intercepts the messages and changes the
515:47 - public key
515:50 - so this is not good
515:52 - so the what we're dealing with now is
515:54 - ways to make sure that the public key we
515:58 - have
515:59 - when B receives a public key
516:02 - B needs to know this is A's public key
516:05 - they need to be sure who's public here
516:08 - it is otherwise such attacks are
516:09 - possible
516:10 - so what we're dealing with is ways to
516:12 - prevent these attacks
516:16 - and
516:19 - so to prevent a man in the middle attack
516:21 - on the public key
516:23 - we need some secure way to to distribute
516:26 - public keys and we went through this
516:28 - scheme first
516:31 - the way to securely distribute public
516:34 - Keys is to get someone else to confirm
516:36 - they are indeed someone's public key so
516:39 - in this case we introduced this new
516:41 - entity called the public key Authority
516:43 - who everyone trusts
516:45 - so assumes that this Authority is
516:48 - trusted
516:50 - and that includes that everyone knows
516:53 - the public key of the authority
516:56 - if you know the public key of the
516:57 - authority
516:59 - when the authority sends you a value
517:03 - and signs that so a message to this
517:07 - public key of B was signed by the
517:09 - authority
517:11 - a can verify that
517:13 - because when something's signed with a
517:15 - private key we verify that with a with
517:17 - the corresponding public key
517:20 - so this scheme is really a way so that A
517:23 - and B can exchange public keys and
517:25 - they're sure they are the correct public
517:26 - Keys it's not a man in the middle attack
517:28 - like in the previous uh approach and the
517:32 - way they do that is that the public key
517:35 - of B is signed by the authority
517:39 - and the public key of A in message five
517:41 - is signed by the authority as well
517:44 - and since they are signed by the
517:46 - authority both A and B can verify them
517:49 - by decrypting with the public key of the
517:51 - authority
517:52 - and that comes back to our assumption
517:54 - that a trusts the authority which really
517:58 - means a has the public key of the
518:01 - authority and knows for sure it is the
518:03 - public key of the authority
518:05 - it's not someone pretending to be the
518:07 - authority
518:08 - so we we have that assumption maybe what
518:11 - happened is that a physically went to
518:13 - the authority
518:15 - confirmed their their identity and got
518:17 - the public key then
518:21 - so this is just one scheme for
518:23 - Distributing public keys so that if
518:25 - someone tries to send a public key
518:27 - pretending to be someone else we can
518:29 - detect that
518:31 - it involves if a wants to talk to B
518:35 - a sending a request to the authority and
518:38 - getting the public key of B
518:41 - identify
518:42 - contacting B saying I want to
518:44 - communicate with you B does the same to
518:47 - learn the public key of A
518:49 - and the last two steps are just to
518:51 - confirm that these messages are a recent
518:54 - and not been replayed by someone else
518:58 - and the end result is a noise B is
519:01 - public key and B knows A's publicly
519:05 - easy
519:07 - one of the problems with this approach
519:09 - is that
519:10 - every time a wants to communicate with a
519:13 - new entity
519:15 - we go through these steps of contact The
519:17 - Authority get the key
519:20 - and the the receiver contacts The
519:22 - Authority gets the key imagine there are
519:25 - thousands of entities in the network
519:27 - they all need to communicate with each
519:30 - other there's many contacts to the
519:31 - authority and it becomes overloaded it
519:34 - becomes a bottleneck
519:35 - many packets are sent to the authority
519:37 - which must respond quickly if the
519:39 - authority cannot respond then
519:42 - A and B cannot communicate
519:47 - so the next scheme is one way to improve
519:49 - that mainly from a performance
519:51 - perspective
519:52 - not from security
519:59 - and it's called public key certificates
520:09 - thank you
520:11 - so we'll go through the general approach
520:13 - again the same objective
520:16 - A and B want to learn each other's
520:18 - public key
520:19 - and they need to be sure that they're
520:21 - they're public key not someone else's
520:25 - similar approach we have some third
520:28 - party to confirm whose key it is
520:33 - and in the previous scheme it was called
520:36 - a public key Authority here the more
520:38 - common name is a certificate Authority
520:42 - what happens
520:44 - is that a and b are issued certificates
520:49 - denoted in this diagram is CA and CB a
520:53 - certificate will contain the public key
520:55 - of that entity signed by the authority
521:01 - and this is a bit confusing when we
521:03 - compare this diagram to the previous one
521:09 - these four messages sent between a and
521:13 - the authority and B and the authority no
521:15 - there's no numbers on them
521:17 - they actually happened before the
521:19 - communications need to take place so
521:21 - they happen manually
521:24 - whereas in the previous scheme we didn't
521:27 - draw the ones that happen manually all
521:29 - seven messages happen automatically
521:31 - across the network in this case contact
521:33 - The Authority get a response whereas
521:36 - with
521:38 - if we want to draw the equivalent to
521:40 - what we have here
521:43 - A and B want to communicate using
521:45 - certificates
521:49 - let's draw it
521:56 - the scheme is quite simple
522:17 - a sends its certificate to B
522:22 - in the first message
522:24 - and then B response
522:30 - with its certificate
522:33 - so if we want to compare those schemes
522:35 - of using the authority the public key
522:37 - Authority versus using the certificate
522:39 - Authority
522:41 - compare this diagram
522:45 - with
522:47 - this one
522:49 - when we use the public key Authority
522:51 - every time a wants to communicate with
522:54 - someone we go through these seven steps
522:56 - contact The Authority get a response
522:59 - contact thee who contacts The Authority
523:02 - gets a response
523:04 - the problem was that there was many
523:06 - Communications to the authority
523:08 - when we use certificates
523:11 - it's this approach
523:14 - a wants to communicate with B quite
523:16 - simply a sends its certificate to B and
523:19 - B responds with its own certificate
523:21 - and we get the same security as in the
523:24 - previous scheme so we need to go through
523:27 - what is a certificate and what does it
523:29 - mean and why this is secure
523:33 - now this diagram
523:37 - compared to this one it's actually these
523:39 - Two Steps step one and step two
523:41 - that's all it's just that this picture
523:43 - it's a bit confusing it includes the
523:46 - prior steps that must happen manually in
523:48 - advance whereas the publicly Authority
523:51 - didn't include them
523:54 - so note when we use certificates every
523:56 - time a wants to communicate with someone
523:58 - it's very easy a sends its certificate
524:01 - to the destination
524:03 - and that destination let's say C sends
524:06 - back its certificate and then they're
524:08 - done
524:12 - what's a certificate
524:17 - in the same way that the author the
524:20 - public key Authority signed A's public
524:23 - key
524:24 - a certificate is A's public key signed
524:27 - by an authority when we say signed by
524:30 - someone we mean encrypted using that
524:33 - sign as private key
524:37 - confirming it came from that particular
524:39 - entity
524:41 - so the certificate of a includes the
524:44 - public key of A
524:46 - signed by someone else
524:48 - signed by the authority in our scheme
524:52 - and in our diagram
524:54 - back to the lecture notes
524:56 - it's captured in these steps here
524:59 - these two
525:00 - so what happens at the start is user a
525:03 - goes to the authority and say I want a
525:06 - certificate
525:07 - here's my public key
525:10 - and the authority confirms that this is
525:12 - user a and this is user A's public key
525:16 - so in a simple example let's say I'm the
525:18 - authority
525:20 - and all of the users are the students in
525:22 - this class
525:24 - so one student comes to me and say
525:26 - Here's my public key and I look at your
525:29 - public key I look at your ID card to
525:31 - confirm this is you it's not someone
525:32 - pretending to be you
525:34 - and I confirm yes this is you and this
525:37 - is your public key
525:39 - therefore what I do is I issue a
525:42 - certificate
525:43 - that's what the authority does
525:45 - they create a certificate which contains
525:48 - the public key of that user
525:52 - Pua in this case the identity of that
525:55 - user
525:58 - some timestamp so T1 here is a timestamp
526:01 - saying that this certificate is valid
526:02 - from right now maybe until six months in
526:05 - the future
526:09 - and I signed that information
526:12 - so the authority encrypts that
526:14 - information using their private key
526:16 - so that anyone else who has the public
526:19 - key of the authority can verify
526:23 - so think of a certificate as
526:25 - the public key of a user signed by some
526:29 - Authority
526:32 - and we'll see that a different format
526:34 - this is the general concept we'll see a
526:36 - more specific format in a moment
526:38 - similar
526:40 - B does the same
526:42 - B goes to the authority saying here's my
526:44 - public key and the authority creates a
526:47 - certificate for them CB in this case
526:55 - now note that these steps happen in
526:58 - advance
526:59 - that is whenever a wants to communicate
527:02 - with someone all it does is sends its
527:04 - certificate so once a has CA its own
527:08 - certificate if it wants to communicate
527:10 - with B it sends C A to B
527:13 - it doesn't have to contact the authority
527:15 - if it wants to send communicate with C
527:18 - some other entity it just sends its
527:21 - certificate to C
527:22 - so it doesn't matter the destination we
527:24 - don't have to contact the authority
527:26 - except in the very first instance and
527:28 - that really cuts down on the
527:30 - communications because it's only that
527:32 - first step of being issued a certificate
527:35 - that we have to contact the authority
527:47 - what is the certificate what information
527:49 - is is
527:51 - included inside here's one
527:53 - representation which is on the slide or
527:55 - on the diagram before where we said
527:58 - it includes the public key of A
528:01 - the identity of a
528:03 - some time stamp
528:06 - because instead of having certificates
528:08 - which are valid forever
528:10 - we have some time limitation on them
528:13 - and importantly encrypted using the
528:16 - private key of the authority
528:19 - and that allows someone to verify it if
528:21 - they have the public key of the
528:22 - authority
528:24 - so again this comes back to trust
528:26 - to be able to verify a certificate you
528:29 - must have the public key of the
528:30 - authority
528:32 - and
528:33 - you must know it is indeed the public
528:36 - keys that the public key of the
528:38 - authority it can't be someone else so we
528:40 - must trust the authority
528:47 - the certificates this is the general
528:49 - concept but we'll go through a more
528:51 - detailed View and look at some specific
528:53 - examples of how to store that
528:55 - information that's what we do to them
529:05 - when we sign something what do we do
529:11 - when you sign if you're using public key
529:14 - cryptography when you sign something how
529:16 - do you sign a message
529:20 - how do you sign a message
529:22 - encrypt with something okay you get an F
529:25 - in the exam if you say that anyone else
529:29 - encrypt with
529:31 - encrypt with a private key still not
529:34 - enough f for U maybe a d plus is a bit
529:37 - closer
529:39 - encrypt with
529:43 - right
529:47 - more specific if you want to sign
529:49 - something what do you do
529:55 - all right hash is is is good you'll get
529:57 - an A if you say hash but even if you
530:00 - just want to be you encrypt
530:03 - with the private key of
530:06 - who
530:09 - you that is if you want to sign
530:11 - something you encrypt with your private
530:13 - key so make sure you're clear because
530:14 - remember everyone has their own private
530:17 - key
530:18 - think of all users have their pair of
530:20 - keys so to sign something you encrypt
530:23 - with your private key
530:25 - now
530:26 - more specifically we encrypt a hash of
530:30 - the message using your private key
530:32 - the hash is there for performance
530:34 - reasons not for security
530:36 - so let's write that down here we haven't
530:38 - shown the hash function but in practice
530:41 - we usually use a hash function even for
530:44 - certificates
530:46 - so
530:49 - one way we can
530:53 - write CA
530:59 - we have
531:03 - the identity of a
531:07 - that is some something that identifies
531:09 - this user in the system
531:13 - we have the public key of A
531:20 - so the actual public key of the user
531:24 - we usually include some time stamp so
531:27 - noted here T1 meeting
531:30 - some information about when this
531:32 - certificate was created and how long
531:33 - it's valid for
531:38 - and all of that information
531:41 - is combined with the signature
531:48 - and we create the signature by
531:50 - encrypting
531:53 - using
531:57 - the private key of the authority
532:02 - I'm going to run out of space
532:05 - the hash
532:12 - the hash of what
532:16 - I'm running out of space you'll find
532:18 - more space the hash of all of this
532:22 - okay so this is our message
532:29 - this is the information we want to sign
532:39 - think of this as our message m
532:43 - we take the message and combine it with
532:45 - a signature this part is
532:48 - if we
532:51 - m is here
532:54 - this part is the signature
533:07 - the message is the information we want
533:10 - to communicate to someone
533:11 - our identity our public key some timing
533:15 - information a timestamp
533:18 - we take that message
533:21 - and it's signed we actually take the
533:25 - hash of the message
533:27 - and encrypt the hash value using the
533:30 - private key of the signer The Authority
533:32 - in this case
533:34 - so someone else signs this message on
533:36 - AIDS behalf
533:39 - so message signature where the signature
533:43 - is
533:45 - the hash of the message encrypted with a
533:47 - private key
533:48 - that's the same as we've seen all
533:50 - through the content on public key
533:53 - cryptography
534:00 - so really a certificate is the public
534:02 - key and identity and some other
534:04 - information
534:05 - signed by an authority
534:07 - signed by someone else usually
534:17 - when B receives this certificate
534:20 - so in the first message these values are
534:23 - sent from A to B when B receives it what
534:25 - does B do
534:28 - B receives the certificate what does it
534:31 - do
534:39 - decrypt
534:41 - decrypt what
534:45 - your signature okay we the the general
534:48 - process we say we verify
534:50 - okay so we to verify we decrypt the
534:54 - signature
534:55 - s we decrypt it using which key
535:00 - the public key of the authority okay so
535:03 - if it was encrypted with the private key
535:04 - of the authority we decrypt with the
535:06 - public key of the authority we get a
535:08 - hash value
535:09 - and we compare the hash value with the
535:11 - hash of a message so this verification
535:14 - step
535:31 - so we say the verification verify
535:35 - what do we do
535:40 - we decrypt
535:43 - using the public key of the authority
535:47 - the signature component
535:50 - s here
535:53 - and we take a hash
535:56 - of the message component
536:00 - and then we compare them
536:09 - so that's the verification step decrypt
536:11 - the signature we should get a hash value
536:16 - take a hash of the message
536:18 - and compare those values if they're the
536:20 - same everything's okay if not don't
536:22 - trust it okay so this is the same as
536:24 - we've seen with all of our signatures
536:28 - to do so we need the public key of the
536:31 - authority
536:33 - so for B to do this verification it must
536:36 - know the public key of the authority and
536:38 - that's when we say we must trust the
536:40 - authority including we must know the
536:42 - public key of the authority
536:44 - and it we must be sure it's it's the
536:47 - authorities it's not someone else's
536:49 - because remember that's our problem
536:52 - our problem is if you get a public keys
536:55 - from someone how do you be sure it's
536:57 - theirs
536:58 - so we're saying that we have some
537:00 - initial trust that we are sure that the
537:02 - public here of the authority is indeed
537:03 - theirs
537:07 - if we can do that we verify
537:11 - the signature meaning we now know the
537:14 - public key of A
537:15 - and because we trusted the authority we
537:18 - know that it is indeed the public key of
537:20 - A because
537:22 - if it wasn't
537:24 - the verification would fail
537:33 - B of course does the same thing it sends
537:35 - back its certificate and a verifies that
537:38 - so same steps any questions yep
537:45 - how do you become how does an entity
537:47 - become a trusted Authority so
537:50 - in in a generic system say then
537:54 - an entity must be trusted by the users
537:57 - how does it become trusted by the users
538:00 - well depends on what system let's say
538:02 - the system is we want to allow all
538:04 - students to communicate
538:06 - then one way to get a trusted Authority
538:08 - is to choose someone that you all trust
538:10 - maybe me and
538:15 - I become the trusted Authority
538:17 - of course that assumes that you all
538:19 - trust me
538:21 - if you don't then that system won't work
538:24 - so
538:26 - in practice in the internet how does
538:29 - someone become a trusted Authority
538:31 - um
538:33 - how do you trust me why do you trust me
538:37 - yeah do you why would why do you trust
538:40 - anyone well based on past experiences
538:44 - okay if your past experiences with them
538:47 - have been positive
538:49 - then you build up Trust
538:51 - so in practice certificate authorities
538:54 - in in the internet usually are based
538:57 - upon organizations that people have
539:00 - dealt with in the past and have done
539:03 - things that have
539:05 - build up their trust
539:07 - um but there's no absolute way to become
539:10 - a trusted Authority you must trust
539:13 - someone
539:14 - otherwise
539:16 - there's no way to bootstrap to start
539:18 - this off
539:19 - any other questions so far
539:24 - this is important because when you open
539:26 - up your
539:29 - computer and you open it a website in
539:33 - particular a website using https
539:39 - to secure create a secure connection to
539:43 - that website that web server is sending
539:45 - you its certificate
539:47 - and we'll see some examples of that so
539:49 - secure web Communications uses digital
539:53 - certificates and therefore it's
539:55 - important to understand what they are
539:58 - what the limitations of them are and
540:03 - how they provide security
540:18 - let's try our man in the middle attack
540:25 - important
540:28 - see what conditions a man in the middle
540:30 - attack would be successful
540:40 - yes our assumption is that when we say
540:44 - we trust the authority it means we know
540:46 - the public key of the authority
540:54 - and our man in the middle let's call him
540:56 - m
540:58 - uh let's call them because we may use M
541:00 - for the message let's call them
541:02 - something else uh
541:07 - d
541:09 - oh I've got to choose a letter that we
541:11 - won't use
541:12 - C we use for a certificate Authority
541:15 - sometimes f
541:19 - just so we don't get confused with some
541:21 - of the other letters we use
541:24 - remember our man in the middle
541:26 - a sends data to B but F intercepts the
541:30 - malicious user intercepts and makes some
541:32 - changes
541:35 - so a sends its certificate to B
541:41 - but f-intercepts
541:49 - what can f do
541:59 - well can f
542:03 - learn A's public key
542:06 - yes the public key is included in the
542:09 - certificate so F knows the public key of
542:11 - A
542:13 - F wants to
542:17 - forward on a message to b I think making
542:20 - B think it came from a
542:22 - what can f do
542:31 - let's try
542:43 - some different things that F can try
542:46 - let's say F tries to create a new
542:48 - certificate
542:49 - containing its own public key
542:52 - I'll call it
542:58 - c a prime it's not CA it's going to be
543:01 - modified
543:03 - and how is it modified
543:06 - let's say ca Prime
543:12 - contains the public key
543:15 - of f
543:19 - the identity of
543:22 - a
543:24 - a timestamp
543:26 - just a note t
543:28 - and
543:31 - the signature component
543:41 - and again I will not try and draw the
543:43 - rest but the signature component is the
543:45 - entire message
543:47 - hashed and signed
543:53 - too much
544:06 - so we've got some missing parts here
544:09 - we'll come to them in a moment so the
544:11 - certificate remember public key identity
544:13 - timestamp
544:15 - and then take all of those values inside
544:18 - here hash them
544:20 - and encrypt with a private key
544:24 - who's private key
544:30 - whose private key do we encrypt with
544:39 - whose can we not encrypt with
544:44 - normally we'd encrypt well the signature
544:47 - is using the private key of the
544:49 - authority
544:51 - oh the malicious user F doesn't know the
544:54 - private key of the authority so CA maybe
544:57 - we can draw CA so people are clear
545:00 - the original certificate CA
545:08 - public key of
545:09 - a
545:14 - identity of a
545:17 - timestamp
545:22 - and then
545:24 - encrypted using the private key
545:30 - of the authority
545:40 - the hash of all of those three values
545:53 - that's the original certificate
545:55 - public key ID time stamp hash it all
545:59 - encrypt with the Authority's private key
546:01 - but when F tries to send a fake
546:04 - certificate to B
546:05 - they've modified the public key of A to
546:08 - be the public key of f
546:10 - hoping that b will receive this and use
546:13 - this instead of the public key of A
546:15 - they don't change the ID the timestamp
546:18 - they copy from the previous one
546:20 - they take a hash of all those values
546:23 - and encrypt with the private key
546:27 - well the important point is that they
546:29 - cannot use the private key of the
546:31 - authority
546:33 - because they don't know it
546:36 - it should be private just in the
546:38 - certificate Authority
546:42 - so let's denote they use some private
546:44 - key X
546:46 - a private key of x
546:52 - hoping to fall be into thinking this is
546:54 - the public key of A
546:58 - B receives the certificate and verifies
547:10 - so try the verification steps
547:26 - remember to verify we take the hash of
547:29 - the received message
547:31 - decrypt the signature
547:46 - try to verify
547:56 - do we have a volunteer to come and do it
547:58 - on the board
548:11 - yep
548:14 - what is X good question
548:19 - f
548:20 - received the certificate CA they want to
548:23 - change the public Key C between CA and
548:26 - CA Prime the thing that's changed is
548:28 - instead of Pua puf
548:31 - this is trying to do a man in the middle
548:33 - attack
548:34 - so they change that
548:37 - but
548:38 - they want to also change the signature
548:42 - remember the message must come with a
548:44 - signature so what I've attempted to do
548:46 - they take the hash of these values and
548:49 - they encrypt using someone's private key
548:52 - they should use the private key of the
548:54 - authority but they don't know it
548:56 - so I'm saying that they use some private
548:59 - key of X it may be F's private key but
549:02 - it's a private key which is not that of
549:04 - the authority
549:05 - so it's a private key
549:10 - B receives this
549:12 - be verifies
549:15 - and the verification steps are the same
549:17 - as always we decrypt
549:20 - the signature component and compare to
549:22 - the hash of the message component
549:25 - remember message component signature
549:29 - component
549:30 - try the verification
549:43 - this
549:45 - is the message component and this part
549:47 - here is the signature component
549:51 - so the verification
549:53 - by B
550:01 - decrypt
550:04 - the signature component
550:06 - which was
550:09 - the hash value encrypted with the
550:11 - private key of x
550:19 - and we're going to compare that to the
550:21 - hash of the message component
550:38 - when B verifies
550:41 - which key did I use to decrypt
550:47 - no
550:49 - the public key of the authority
550:55 - B receives a message a certificate
550:59 - this certificate should have been signed
551:01 - by the authority therefore to verify it
551:03 - you use the public key of the authority
551:05 - to verify so you decrypt the signature
551:08 - component
551:09 - with the public key of the authority
551:14 - and again our basic assumption is that
551:17 - every entity knows the public key of the
551:19 - authority
551:21 - and it is indeed the public key of the
551:23 - authority
551:29 - what happens in the first step when we
551:31 - decrypt
551:32 - and then compare to the hash of this
551:34 - value
551:36 - why what happens are they the same
551:42 - so once we decrypt here and compare to
551:45 - the hash we need to check are they the
551:47 - same
551:48 - no they will not be the same why not
551:54 - that a different key was used between
551:57 - the encrypt and decrypt here we use the
551:59 - private key of x
552:01 - to encrypt some hash value
552:03 - the hash value was in fact the same as
552:05 - this
552:06 - but we decrypt that ciphertext using the
552:10 - wrong public key
552:11 - using the different public key and the
552:14 - pair that was used to encrypt
552:16 - therefore the resulting output will not
552:19 - be the same as the original input
552:21 - it would not be the hash value
552:23 - so that will not be the same
552:28 - and when we compare them and find
552:30 - they're not the same then
552:34 - there's an error
552:36 - that is
552:38 - the certificate fails the verification
552:40 - we don't trust it
552:42 - so when B receives this CA Prime
552:46 - as a result of the verification steps it
552:48 - finds I don't trust this certificate
552:51 - maybe report the error or at least don't
552:53 - use the public key in in future
552:55 - communications
552:58 - so again this is using same Concepts
553:00 - that we've looked at when we look
553:02 - generally at signatures
553:07 - any other ways to attack
553:10 - what can f do
553:17 - what can f do to try and
553:20 - full B into thinking this is the public
553:22 - key of A but it indeed is the public key
553:24 - of f
553:34 - what we did was we changed the public
553:36 - key
553:37 - and then we try to regenerate a
553:40 - signature but we didn't have the right
553:42 - private key to generate the correct
553:43 - signature so that was a failure here
553:45 - another way would be to change the
553:47 - public key but we just reuse the
553:49 - signature from the previous
553:51 - approach the previous the real
553:53 - certificate
553:55 - but again you'd find out that the
553:57 - hash of this
553:59 - would not match the hash of the original
554:01 - value and therefore to be detected
554:04 - so changing just the message but not the
554:07 - signature would also be detected
554:12 - yeah
554:13 - so it turns out by using this signature
554:16 - then B can verify changes of the of the
554:19 - message and therefore because we have
554:21 - the public key of the authority at B
554:25 - when we receive a certificate we can be
554:27 - certain that we have the correct users
554:29 - public key if it verifies
554:34 - and B can do the same in the opposite
554:37 - direction
554:46 - how did B get the public key of the
554:48 - authority I know many people are
554:50 - thinking of that
554:52 - any suggestions how does B get the
554:54 - public key of the authority
555:04 - could they use certificates
555:10 - yeah if so how does B get the public key
555:14 - of the authority because that's an
555:15 - important part here that is
555:17 - to verify we use the public key of the
555:20 - authority because we assumed the
555:22 - signature was created using the private
555:24 - key of the authority
555:27 - so
555:28 - what if we
555:30 - if the malicious user f
555:33 - created this signatures using the
555:35 - private key of x
555:36 - and then F got B to think that the
555:39 - public key of the authority was actually
555:41 - the public key of x
555:44 - so that would be a successful attack in
555:47 - that case so we need to be sure then we
555:50 - when we have the public key of the
555:51 - authority it is indeed theirs
555:55 - if we use certificates
555:58 - we could do that but it means that we
556:02 - need another authority to confirm that
556:04 - this is the public key of the authority
556:07 - okay remember all the certificate is
556:09 - doing is confirming this is the public
556:11 - key of a particular user
556:14 - and it's doing so by
556:16 - having a another user The Authority
556:19 - confirming that
556:21 - by giving it signature
556:26 - so
556:29 - to be sure that it's a public key of the
556:31 - authority we could include the public
556:33 - key of the authority in a certificate
556:35 - and have it signed by someone else by
556:37 - another Authority but for that to work
556:40 - we must know the public key of that
556:42 - other authority and we have this
556:44 - infinite Loop
556:46 - so we must trust one public key of one
556:49 - Authority at least
556:51 - but we can have a hierarchy
556:53 - it can be such that the public key of
556:56 - the authority is in fact signed by a
556:58 - higher up Authority
557:01 - and that makes things more convenient in
557:02 - large Networks
557:08 - it turns out in practice usually public
557:10 - keys of authorities are stored in
557:13 - certificates as well
557:19 - so we could say
557:21 - the certificate of the authority
557:33 - is the public key of the authority
557:44 - their identity
557:49 - a time stamp t
557:52 - some some indicator of how long this
557:54 - certificate is valid for
557:56 - and then a signature
558:08 - again
558:10 - we take a hash of those first three
558:13 - values in the signature
558:20 - I just never have space to draw them
558:25 - okay so this could be the certificate of
558:28 - the authority including its public key
558:30 - its identity a timestamp the hash of all
558:33 - of those values and encrypted using the
558:36 - private key of who
558:40 - of
558:42 - another Authority
558:45 - or itself
558:47 - all right let's do another Authority
558:49 - First
558:50 - and we'll see the the hierarchy
558:53 - let's say it was encrypted using a
558:55 - private key of someone else
558:58 - I'll say
559:01 - Authority
559:03 - two
559:05 - you can see that someone else some other
559:08 - authority
559:11 - meaning this public key is signed by a
559:14 - higher up Authority
559:17 - but then we have this same issue that
559:19 - the public key of this higher up
559:21 - Authority what is that well it could be
559:24 - a certificate
559:32 - the certificate of this second Authority
559:36 - we don't have to be limited by a single
559:38 - one is
559:40 - its public key
559:43 - its identity
559:51 - a timestamp
559:53 - we haven't said too much about that
559:55 - we'll come back to it later
559:58 - encrypted
560:02 - using someone's private key of the hash
560:05 - of all those values
560:11 - same structure public key identity
560:13 - timestamp signature where the signature
560:16 - is those values hashed and encrypted
560:19 - with a private key
560:23 - who's private key
560:32 - who's private key
560:36 - another authority authority three okay
560:40 - and you see where we give this this
560:43 - continuation that someone needs to sign
560:45 - the public
560:47 - public key so we could have the private
560:49 - key of the authority three and then we'd
560:52 - need a certificate of authority three
560:54 - signed by Authority four and we'd go
560:58 - forever
560:59 - well at some point in this hierarchy we
561:01 - need a route
561:04 - and the root Authority
561:07 - has a special case certificate where it
561:09 - signs its own certificate let's say
561:12 - Authority two is the root Authority
561:18 - it's signed by itself
561:32 - check the
561:34 - the public key in the private key
561:36 - same entity
561:51 - and we get what's called a self-signed
561:53 - certificate
561:56 - so this is how the the root Authority
561:59 - distributes its public key
562:03 - it creates its public key identity
562:06 - timestamp and signs it itself
562:10 - saying I confirm that this public key is
562:14 - my public key
562:16 - and that's what we need to trust
562:19 - that is the other users need to trust
562:22 - this one
562:25 - so that they can confirm the lower level
562:28 - certificates
562:30 - so if we trust this certificate
562:33 - then we can confirm the certificate of
562:35 - the first Authority which in turn can be
562:38 - used to confirm the certificate of user
562:40 - a and other users but it's signed
562:45 - so we can have this hierarchy of
562:47 - certificates
562:48 - and at the top of the hierarchy is a
562:51 - root CA and that has a certificate which
562:54 - we call is self-signed
562:56 - the private key used there is the
562:59 - corresponding key of the public key
563:02 - inside the certificate
563:16 - self-science certificate it's like
563:17 - saying
563:21 - foreign
563:24 - this this piece of paper contains my
563:27 - public key
563:28 - and I sign it to confirm it's my public
563:30 - key and I give it to you
563:33 - how do you confirm that it is my public
563:35 - key
563:36 - well you cannot with a self-signed
563:38 - certificate it's me confirming that it's
563:41 - mine
563:42 - but anyone can do that anyone can say
563:46 - here's my public key
563:47 - and I confirm it's my public Key by
563:50 - signing it themselves so there's no
563:52 - security uh
563:54 - measure in that it's not secure a
563:57 - self-size certificate because anyone can
563:59 - create a self-signed certificate
564:02 - but in in the digital certificate system
564:05 - we need to be able to trust at least one
564:08 - self-signed certificate
564:11 - so how would we trust it then let's say
564:13 - it's an organization or an entity that
564:15 - everyone else trusts in that system and
564:18 - they they implicitly trust that it is
564:21 - their correct public key
564:35 - we'll look at the x509 certificates uh
564:40 - just some notation just to summarize
564:43 - this hierarchy
564:45 - in this picture we use some notations
564:47 - saying that a certificate of X is issued
564:51 - by some Authority y
564:53 - by denoting it as shown here
564:56 - so let's use that in our example
565:02 - some
565:04 - shorthand notation that says
565:12 - we had the certificate of a
565:17 - was signed or issued by our Authority
565:28 - and the certificate of the authority
565:31 - not good names but
565:33 - our first Authority
565:35 - was signed by Authority two
565:42 - and the certificate of authority to
565:45 - was self-signed
565:48 - because
566:00 - a shortened way to to write down who
566:04 - signs particular certificates
566:09 - to verify one certificate
566:12 - we must trust the certificate of at
566:15 - least one other entity
566:20 - so to verify a certificate we must
566:24 - trust or we must have the public key of
566:27 - the authority
566:29 - and to verify that we must have the
566:31 - public key of authority too
566:33 - and
566:34 - we must in this case ex trust the
566:38 - self-science certificate of authority
566:40 - too
566:41 - so we can build up a chain of trust
566:43 - amongst these certificates
566:46 - so long as we have the route in the
566:48 - hierarchy we can verify the others
566:58 - foreign
567:10 - up your web browser
567:13 - people always sit in my classes with
567:16 - their laptops open your browser do
567:18 - something useful and access the Moodle
567:21 - website
567:25 - log in if you're already logged in log
567:27 - out and log in again and I'll do it here
567:30 - for those that don't have their
567:31 - computers
567:33 - so my browser I access the Moodle
567:35 - website and I need to log in well uh
567:40 - it's here somewhere the login button
567:43 - log in
567:45 - now note the URL
567:53 - not in the top of the address bar there
567:56 - the URL
567:59 - ict.sit Dot
568:02 - t-u-a-c-t-h slash Moodle
568:04 - what protocol was used to access that
568:07 - website
568:10 - HTTP so accessing a web server HTTP now
568:15 - I log in
568:18 - and maybe you can see I cannot zoom when
568:21 - you hover over a link usually your
568:23 - browser shows you the the destination
568:25 - URL down the bottom note that the
568:27 - destination is https
568:31 - what's going to happen when I click on
568:33 - the link those with the computers click
568:35 - on the link
568:40 - this connection is untrusted if you
568:42 - didn't get that then you've been hacked
568:47 - okay
568:49 - then your login to Moodle is insecure
568:55 - so this is a warning message presented
568:57 - by my browser and let's see what it says
569:00 - you have asked that so this connection
569:02 - is untrusted
569:04 - you've asked your browser to securely
569:06 - connect to ICT s i t t u a c t h but we
569:10 - cannot confirm that the connection is
569:12 - secure
569:15 - normally when you try to connect
569:16 - securely sites will present trusted
569:19 - identification
569:21 - to prove that you're going to the right
569:24 - place
569:25 - this site's identity however cannot be
569:28 - verified
569:29 - so this is a message from my browser
569:31 - saying
569:32 - I cannot confirm I can cannot verify
569:36 - that this is in fact ICT server
569:40 - and https which is what we're using here
569:44 - uses digital certificates for servers to
569:47 - verify their identif identity to
569:50 - browsers
569:51 - when you access a website you would like
569:53 - to know it is that website that you're
569:55 - setting up a secure connection with
569:58 - it's not a man in the middle attack
570:00 - and this message is saying well we
570:02 - cannot be sure
570:04 - maybe someone between my browser
570:07 - and the ICT server is performing a man
570:09 - in the middle attack
570:11 - because what's happened
570:13 - and we'll see in details later that the
570:15 - server has sent its certificate to my
570:18 - browser
570:20 - and my browser has tried to verify the
570:22 - certificate
570:23 - but reports this error saying it cannot
570:25 - be verified
570:27 - so this is an example of
570:29 - receiving a certificate that is not
570:31 - trustworthy
570:36 - so let's not trust that and let's not go
570:38 - to that website let's try a different
570:40 - one
570:43 - I open up a different website again
570:45 - using https
570:50 - so my internet works
570:58 - slowly
571:05 - it's coming
571:11 - using https and https uses digital
571:14 - certificates and it's connected to this
571:15 - website no warning
571:17 - which implies that
571:20 - the server this fsf.org has sent their
571:24 - certificate to my browser
571:26 - and my browser automatically goes
571:28 - through the verification process it
571:30 - tries to
571:32 - compare the signature
571:34 - with the public key and identity
571:36 - information and if they're verified
571:39 - it allows me to access the website if it
571:42 - doesn't verify then it presents that
571:44 - warning and since it didn't present the
571:46 - warning it
571:48 - was successful
571:50 - here I can see this little lock up the
571:52 - top the padlock and if I click on that I
571:54 - can see more information
571:57 - and it gives me a summary
572:01 - uh the lock here
572:05 - he says you are connected to fsf.org the
572:08 - domain
572:09 - verify verified by Gandhi SAS
572:15 - so this is a given me summary about
572:17 - The Authority that has verified the
572:20 - identity of this website and more
572:22 - information
572:27 - and your browser will show you if you
572:30 - look into the details the certificate of
572:32 - the web server
572:33 - so here I'll view the certificate
572:40 - and it gives me a summary of the
572:42 - certificate sent by the server to my
572:44 - browser
572:47 - remember a certificate is a public key
572:49 - in identity of some entity in the
572:53 - network
572:54 - issued by someone else signed by an
572:57 - authority
572:58 - so it summarizes it's issued to fsf.org
573:03 - and is issued by some other organization
573:10 - the common name is just the the field
573:13 - which indicates the domain for this
573:15 - certificate
573:18 - also includes optionally organization
573:20 - organizational unit
573:22 - and some serial number for this
573:24 - certificate
573:26 - so in practice we don't just include the
573:28 - public key and one field with the ID we
573:31 - can include other values
573:34 - issued by is the identity of the
573:37 - authority
573:40 - some organization called Gandhi standard
573:42 - sslca
573:44 - CA short for certificate Authority
573:48 - and some organization name
573:51 - and the timestamp here it's stored as
573:53 - represented by two values
573:56 - the date when this certificate was
573:58 - issued
573:59 - and when it expires
574:02 - so
574:04 - certificates have a fixed lifetime
574:09 - or a finite lifetime
574:16 - let's look at the details
574:24 - and again
574:28 - my browser represents and shows that
574:30 - this certificate is actually part of a
574:33 - hierarchy
574:35 - so the certificate for fsf.org
574:39 - was signed by an organization Gandhi
574:42 - standard SSL
574:46 - and that certificate was signed by some
574:49 - other authority called utn user first
574:52 - Hardware
574:53 - this is the shortened name for those
574:55 - authorities so in fact here we have a
574:57 - hierarchy one certificate signed by
575:00 - another which in then signed by a third
575:03 - similar to our example where we had a
575:06 - certificate signed by the authority
575:07 - which was signed by authority too
575:12 - so there are in fact three certificates
575:14 - here
575:18 - the web servers certificate the first
575:20 - authorities and then the topmost
575:23 - authorities or the root authorities
575:30 - the details of those certificates are
575:32 - included here
575:36 - and the format is referred to as x509
575:39 - there's a standard that says what what's
575:42 - the contents of a certificate and the
575:44 - name of that standard is x.509 so it's
575:47 - commonly used in in certificates there
575:49 - have been some different versions
575:51 - and
575:53 - we'll look through some of the fields in
575:55 - there
576:01 - it's on the slide here it shows the
576:03 - different fields but we'll use the
576:04 - example to see them
576:19 - we have
576:21 - something identify the version of the
576:24 - the certificate
576:25 - but it's a standard used x509 I think
576:28 - version three will see a serial number
576:30 - that identifies the
576:32 - this certificate so each certificate
576:35 - gets a a different serial number
576:38 - we sign
576:41 - the sign the certificate so we drew
576:46 - generally we encrypt the hash value well
576:49 - what algorithms do we use for the hash
576:51 - value and for the encryption so it gives
576:53 - some values here the issuer is the
576:56 - authority
576:57 - who signed this certificate
577:00 - validity is like our timestamp not be
577:03 - not valid before this date not valid
577:05 - after someday and the subject is whose
577:08 - certificate it is
577:10 - and we'll have the subject public key
577:13 - information
577:20 - version three that's just the version of
577:22 - the the the format of this certificate
577:26 - some unique serial number
577:28 - so another certificate would have a
577:30 - different value
577:34 - the algorithms used
577:36 - in this certificate
577:40 - The Authority who issued the certificate
577:44 - so some values to identify that
577:46 - organization it's usually an
577:48 - organization
577:51 - can be a person
577:53 - not valid before some time and date not
577:56 - valid after some time and date so after
577:59 - that date whoever receives this
578:02 - certificate should treat it as
578:03 - untrustworthy
578:05 - so they should be updated over time
578:10 - the subject
578:13 - and the important part is the common
578:15 - name
578:17 - which identifies in web browser in web
578:19 - service certificates the domain so here
578:22 - anything.fsf.org
578:25 - so this certificate is that is for that
578:27 - domain when you visit a website with
578:30 - that domain this certificate applies
578:33 - the others are just I think the common
578:36 - name the organizational unit are just
578:38 - optional values
578:43 - people
578:47 - then the public key information the
578:49 - algorithm used
578:51 - RSA
578:54 - and
578:55 - the actual public key
578:59 - remember RSA we have a public key which
579:02 - is e and n
579:05 - and the private key DN
579:07 - so in the public key n is the modulus so
579:11 - there's the value 2048 bits in
579:13 - hexadecimal and E is the exponent
579:16 - 65 537 so this is the actual public key
579:20 - the RSA public key for that subject
579:24 - for the web server
579:26 - there's some extensions some extra
579:28 - optional information that can be used to
579:30 - support by the uh the certificate
579:33 - Authority
579:35 - would not look at them
579:38 - that algorithm used for signing
579:41 - sha-1 with RSA
579:44 - that refers to
579:47 - we find it
579:51 - the hash algorithm H is sha1
579:55 - and the encryption algorithm is RSA so
579:58 - the signature algorithm refers to the
580:00 - two algorithms used here
580:07 - we may use different algorithms sorry
580:11 - and finally the actual signature
580:16 - so this is the 2048-bit signature used
580:19 - which is that s part when we draw on the
580:22 - screen
580:27 - that's the certificate of the of the web
580:30 - server fsf.org
580:32 - it was issued by an organization called
580:35 - Gandhi standard sslca
580:39 - to verify this certificate we need the
580:42 - issuer's public key
580:45 - which is stored in the next certificate
580:48 - up in the hierarchy
580:51 - the subject
580:53 - is Gandhi standard sslca
580:57 - the issuer in this case is utn user
581:01 - first Hardware
581:02 - so another Authority
581:05 - to verify this certificate we need this
581:08 - utn user first Hardware
581:10 - certificate and we see that up in the
581:13 - topmost
581:14 - of the hierarchy
581:16 - subject
581:19 - and the issuer
581:21 - anyone want to guess
581:25 - who's the issuer of this certificate
581:29 - all right itself
581:32 - at the top of the hierarchy we'll have a
581:35 - a root certificate and it's a
581:37 - self-signed certificate so the subject
581:39 - is utn user first Hardware
581:43 - the issuer is the same
581:47 - utn user first Hardware
581:49 - so this is a self-signed certificate
581:53 - it's the same as this example where we
581:55 - had
581:56 - think of this as the servers certificate
581:59 - issued by one Authority that Authority
582:02 - certificate was issued by a second
582:04 - Authority but that second Authority
582:07 - certificate is self-signed by itself
582:15 - it doesn't have to be two levels all the
582:17 - time it can be a single level or it can
582:19 - be multiple
582:26 - let's go back to our first example just
582:28 - to finish
582:31 - when I connected to ICT what happened
582:35 - it gave me a warning saying my browser
582:38 - could not verify the received
582:39 - certificate
582:40 - try again
582:42 - untrusted connection
582:46 - technical details saying the certificate
582:48 - is not trusted because it is self-sign
582:51 - so the browser says
582:54 - I've received a certificate from a
582:56 - server
582:57 - but it's signed by
582:59 - the person whose public key is included
583:04 - and if we
583:06 - want to access this website we must
583:10 - manually trust the certificate
583:15 - so I understand the risks
583:18 - and we can add an extent exception
583:27 - we can actually view the certificate in
583:29 - fact since I run the ICT server I've
583:31 - created a self-signed certificate
583:34 - because I haven't gone to the effort of
583:35 - creating a real certificate
583:38 - and you can see it's out of date as well
583:40 - okay 2012.
583:43 - so this is
583:45 - the issuer
583:47 - and the subject are the same in this
583:50 - case
583:55 - so be careful when you access such sites
584:01 - if we confirm the exception and we
584:04 - manually trust it then we get access to
584:06 - this site
584:08 - okay
584:09 - I'm sure you've seen others like that
584:12 - next week we'll discuss some of the
584:14 - issues well why do we have that why is
584:17 - there a self-science certificate and
584:18 - other issues of where did the
584:22 - why did the browser trust these other
584:24 - authorities
584:26 - so whose certificates do we initially
584:28 - trust some of the Practical issues to
584:31 - finish off on certificates and that'll
584:33 - be next week
584:36 - any questions on certificates so far
584:40 - you'll see a few more examples next week
584:42 - you'll see some in your homework
584:47 - which is yet to be released will be
584:50 - today or tomorrow
584:53 - any questions you follow the
584:56 - certificates on your laptop
584:59 - so the informal homework whenever
585:02 - accessed some websites and check the
585:04 - certificates from your browser just so
585:06 - you can get some examples and see the
585:09 - the general structure to start to
585:11 - understand what's happening
585:15 - a formal homework will be assigned soon