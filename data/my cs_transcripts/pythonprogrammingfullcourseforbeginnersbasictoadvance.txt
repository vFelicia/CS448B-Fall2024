00:00 - welcome to today's left-brain lesson
00:02 - which is all about numbers one of my
00:04 - favorite topics so of course we're gonna
00:05 - start with some of the basics like
00:07 - integers and floats depending on how
00:09 - much fine-grained control you need but
00:11 - then we're gonna talk about rounding
00:12 - numbers up depending on how many digits
00:14 - out you want things or how you're gonna
00:15 - print them we're gonna talk about the
00:17 - difference between casting and coercion
00:19 - so it's whether we want to change things
00:21 - specifically from one type to another or
00:23 - it's happening automatically in the
00:24 - background and I show you some of the
00:26 - constants you can bring in like pi or e
00:29 - and then some boolean math the thing a
00:31 - lot of people don't think about but one
00:33 - in a 0 the true and the false
00:35 - these are definitely ways that we can
00:36 - calculate and then of course working
00:38 - with some random sequences how do we get
00:40 - random numbers generated and then how do
00:42 - we print those to a console and the way
00:43 - that makes sense for whatever the
00:45 - application or program is that we're
00:47 - doing so stay tuned stick with me and I
00:49 - can make sure that you never go bald
00:51 - let's talk integers shall we so here's
00:56 - some basic integers just to review we
00:58 - can have a negative 17 a 0 or 42 as long
01:01 - as we don't have decimal places also not
01:04 - just notation so see I have int 1 & 2 &
01:07 - 3 and I'm just using commas and then
01:08 - assigning them to these 3 but this is
01:10 - just like before when we made variable
01:11 - is a little bit different syntax a
01:13 - little more compressed but we can put
01:15 - them all out in the same way if I just
01:16 - putting commas between them and you can
01:18 - see that they work just fine and we can
01:20 - check them to make sure they are of type
01:22 - integer okay now let's talk flow to get
01:26 - some of the basics so we're gonna make a
01:27 - couple variables here one we're gonna
01:29 - set to the integer 21 1 to the float
01:32 - 3.1415 and by printing out the types you
01:35 - can see that we get exactly what we were
01:37 - hoping for we get an integer and a float
01:39 - type but here's a good question so how
01:41 - many decimal places do you think that we
01:43 - are gonna get when we run this cell
01:45 - because we input 4 after the decimal and
01:47 - we get we're out okay so Python doesn't
01:51 - have any problem with that level of
01:52 - precision but what about this we're
01:54 - gonna import a constant pi which goes on
01:57 - as you all know forever so how many
01:59 - decimal places do you think it's gonna
02:01 - print out for pi okay so this is gonna
02:05 - be its normal limit so that's the
02:08 - precision level that we're dealing with
02:09 - usually not a big deal but just
02:11 - something to kind of keep in mind that
02:13 - is different levels and at certain times
02:15 - that's way more than we want to show
02:16 - someone so if you want to tell someone
02:18 - what pi is 3.14 is usually good enough
02:21 - so let's move on to the next topic and
02:24 - talk a little bit about rounding let's
02:27 - look at how we would do that so let's
02:29 - make a variable and this one has many
02:31 - digits after the decimal and we can use
02:33 - this cool function round and it puts in
02:36 - the variable and a parameter which
02:39 - specifies how many digits we want to
02:42 - round to and then we're also going to
02:43 - wrap that again and this second function
02:45 - called type just to make sure we are
02:47 - still dealing with the float so when we
02:49 - run this cell we get that it's still a
02:52 - float and that it's now down to just two
02:54 - digits okay now if you don't put any
02:56 - parameters into it at all it's gonna
02:59 - actually assume zero and it's gonna move
03:01 - it all the way up to an integer and it's
03:03 - a different type also now so the
03:05 - important thing to remember is that if
03:07 - you round all the way up python is gonna
03:09 - try to save memory and it's gonna turn
03:11 - it into an integer and it's not a float
03:12 - anymore also let's talk about if you
03:15 - want to round in certain ways because
03:17 - sometimes what they call ceiling or
03:19 - floor rounding makes more sense meaning
03:21 - no matter where the digit is just bring
03:23 - it up or bring it down and there's a
03:25 - couple things we can do for that we can
03:27 - import a module called math and then we
03:29 - can wrap it in a function called math
03:30 - dot seal for sealing or math dot floor
03:33 - for floor and you can see it's gonna
03:36 - round it up to 183 I'm sorry nine as you
03:40 - can see it's gonna round it up to nine
03:42 - eighty-three or down to nine eighty two
03:45 - let's start casting so let's make a
03:48 - couple toys variables here so we have a
03:50 - negative float and the regular integer
03:53 - and now I want to use an absolute
03:55 - function okay so you remember for
03:57 - mathematics absolute numbers are
03:58 - non-negative numbers they're a distance
04:00 - away from something so we can actually
04:03 - run a float negative 3.14 into an
04:06 - absolute function and get out an
04:07 - absolute number which is a cool thing
04:09 - that Python can do and remember we
04:11 - didn't actually make my float back into
04:14 - this absolute number we just referenced
04:16 - it made an absolute value and viewed it
04:19 - sorry when we cast our float into an
04:22 - integer what do you think we're gonna
04:24 - get
04:25 - did you guess negative three because we
04:27 - still have the negative up there we
04:28 - didn't actually overwrite it we just
04:30 - displayed this so nothing to remember is
04:32 - that the state of the variable it can be
04:34 - very different from what you're
04:35 - outputting on on screen so let's look at
04:39 - another casting if you're gonna take my
04:41 - integer and turn it into a flow to my
04:43 - integer right now being 21 what do you
04:45 - think we're gonna get
04:47 - 21.0 right like it's just the same
04:50 - number the other one you can kind of
04:52 - think of as having a point zero but it's
04:54 - gonna take up more memory now because
04:55 - it's remembering more precision also
04:58 - want to talk about complex numbers you
05:00 - know not that they really come up that
05:01 - much in regular life but they are cool
05:03 - and I'm sure you remember in mathematics
05:05 - how fun it was to you know use angles to
05:07 - solve you know multiplication problems
05:09 - and you know that's just kind of cool so
05:12 - knowing that Python has complex ability
05:15 - is neat we can actually in input two
05:17 - digits here it's gonna be we're on the
05:20 - x-axis something is and we're on the
05:22 - y-axis something is the two integers
05:24 - here or one float and one integer are
05:26 - gonna give us 21 to the right and then
05:28 - negative 3.1415 down you can think of j
05:31 - is the y-axis so it's cool to know that
05:34 - it has that and we also have hexadecimal
05:36 - so you know in reality the only time
05:38 - hexadecimal comes up in my life is like
05:40 - with colors sometimes we'll be with
05:41 - Photoshop things like that but there is
05:43 - a conversion because that's a base 16
05:45 - system but we can convert the number 78
05:47 - to hexadecimal and get 0x
05:50 - you know for E or whatever it is and we
05:52 - can do this with any number we want so
05:55 - we have a conversion and we can convert
05:56 - back and we can do all sorts of cool
05:58 - things through casting in Python
06:03 - coercion very similar to casting but it
06:06 - takes place behind the scenes without
06:08 - our knowledge so a good way to think
06:09 - about casting is that it's explicit it's
06:12 - a decision that we make and then
06:13 - coercion is very similar but it's
06:15 - happening implicitly it's happening
06:17 - behind the scenes pythons just making it
06:19 - happen so it can solve problems for you
06:22 - so easy example we have 1.0 a float and
06:25 - we're gonna add it to the integer two
06:27 - but after go of running through the
06:29 - function float which turns it into a
06:30 - float and you'll see that we end up with
06:33 - 3.0 okay now if we actually add one
06:36 - directly to the number two we get the
06:39 - same answer so behind the scenes it's
06:42 - just saying whoa 1.0 can't be added to
06:45 - just two I better turn to into 2.0 and
06:47 - then do the man next let's talk
06:51 - constants so a few constants that are
06:53 - that commonly come up are PI and Euler's
06:56 - number so just so you know how you get
06:58 - those is by importing the math module so
07:00 - once that's in
07:01 - for did you can run math dot pi and you
07:04 - can get 3.14 yada yada and you can run
07:07 - math dot e to get 2.718 yada yada yada
07:10 - so that's great sometimes we don't have
07:12 - to type all these things out we just
07:13 - throw in math dot pi or math dot e or
07:16 - maybe even assign that to e and you do
07:19 - something like that and then throughout
07:21 - your code you can just use e whenever
07:23 - you need to so there you go
07:28 - let's talk boolean math so this is just
07:31 - kind of an interesting thing to have in
07:32 - your head that false and true also act
07:36 - like the numbers 0 and 1 in python and
07:38 - they can actually be used as
07:40 - replacements for 0 and 1 so we're gonna
07:42 - sign a couple variables here just F
07:44 - equals true I mean F equals false and T
07:47 - equals true and you can see that we can
07:49 - simply just do 1 plus F right so f is
07:52 - gonna be 0 so 1 plus 0 should give us 1
07:57 - 1 plus true so it should be 1 plus 1
07:59 - which is gonna give us 2 and then we can
08:02 - do 1 - false equal 1 1 minus true equals
08:06 - 0
08:07 - so cool little thing we can do there
08:09 - with billions so now let's talk about
08:11 - randomness so randomness actually seems
08:13 - to come up a lot when I'm programming
08:15 - and I wouldn't have thought it when I
08:16 - started but you know just the way the
08:18 - world's going especially with like
08:19 - neural networks and some of the kind of
08:21 - cutting-edge stuff that we're gonna
08:22 - eventually get to it's all about
08:25 - controlling uncertainty it's about
08:26 - having grasp on randomness so you know
08:30 - in the super basic sense what we can do
08:32 - for a random number is bring in a module
08:35 - called random and I'm also gonna make
08:37 - just a little sequence here that we're
08:38 - gonna use in a couple cells but if you
08:40 - want a random number it's as simple as
08:42 - random dot random open closed
08:44 - parenthesis right it's a method inside
08:46 - of the random module so we run that and
08:49 - we get in this case 0 for 0.04 but it's
08:54 - always going to be a number by default
08:56 - between 0 and 1 and there are a whole
08:58 - bunch of parameters so make sure to wrap
08:59 - that thing and help and go google it if
09:02 - you're interested in all the other ways
09:04 - you can generate random ranges but you
09:07 - can see by just running this over and
09:08 - over again we're gonna get a different
09:10 - number between 0 and 1 and one of the
09:13 - cool things that you can do
09:15 - sequences is you can use random dot
09:17 - choice I find this really powerful if
09:19 - you want to pull something out of this
09:21 - sequence like you want a random thing
09:22 - out of a database or you want a random
09:24 - item pulled out of some kind of a list
09:27 - or a dictionary you can use this random
09:29 - dot choice and you'll see that it's
09:30 - gonna pull out the number six in this
09:32 - case but if we just keep running it we
09:34 - get two we get six again we get six
09:36 - again we get six again we get four so
09:39 - it's a very cool way you can pull that
09:41 - out of lists using the random module
09:44 - okay and finally let's talk about just
09:47 - how you would print these things because
09:48 - you know it's not really intuitive to
09:50 - always see tons of numbers after the
09:52 - decimal so let's just show how you might
09:54 - want to print this out in a way that's
09:55 - more human intuitive so we make this
09:58 - float which has a whole bunch of numbers
10:00 - after the decimal but we can say in a
10:02 - format in a print format my float and we
10:06 - can actually just reference it and see
10:08 - everything or we can use a colon dot 2f
10:12 - and remember this is different than
10:14 - needing to round it first and then
10:16 - printing the rounded number the whole
10:17 - numbers still there in memory we still
10:19 - have all of the precision that we had
10:20 - before but in a simple way we can
10:23 - actually just print out that it's
10:24 - national pie day subscribe to the
10:29 - mnemonic Academy YouTube channel for
10:31 - daily uploads that will help you learn
10:33 - amazing concepts through effortless
10:35 - associations
10:47 - welcome to today's lesson on strings
10:49 - very excited to talk about strings
10:52 - because there's so much we can do with
10:53 - them and we're gonna start by going over
10:54 - the basics how to print them to the
10:56 - console how to format them so they look
10:57 - nice when we're printing for the user
10:59 - we're gonna talk about slicing them up
11:01 - on an individual character level going
11:03 - from one character to another and then
11:05 - taking pieces in between we're gonna
11:07 - talk about concatenation which is the
11:08 - process of putting strings together
11:10 - again merging them we're gonna talk
11:12 - about escaping which are special
11:14 - characters that we can use to get out of
11:16 - strings and put in information that
11:18 - gives it much more power we're gonna
11:20 - talk about raw which is another type
11:22 - it's an input type that lets the user
11:24 - type things to us and then we can change
11:27 - those using casting into numbers or
11:30 - floats or whatever we need to do with
11:31 - them we're gonna talk about reaper which
11:33 - is a function that doesn't print in the
11:35 - same way a human would read it but it
11:37 - does in the same way that a computer
11:39 - thinks about what it's giving us and it
11:41 - can be really useful in a lot of
11:43 - situations then we're gonna talk about
11:44 - encoding so we talked about everything
11:47 - being utf-8 inside of Python so we're
11:49 - gonna look at all the different fun
11:50 - characters we have how we can use them
11:52 - and then we're gonna use an origin
11:54 - alysus to actually figure out what's
11:56 - going on behind each of the characters
11:58 - and then finally we're just gonna show
12:00 - off a bunch of methods I don't have
12:01 - enough time to go through everything but
12:02 - we're gonna look at how to change the
12:04 - cases and strip them in different ways
12:06 - and do alignments and finds and replaces
12:09 - and splits and oh my let's hop into the
12:13 - deep end of strings so the basics okay
12:16 - python has a built-in class of strings
12:18 - you'll know this as STR when you search
12:21 - for the different types and here's an
12:23 - example a best friend is like a
12:25 - four-leaf clover hard to find lucky to
12:27 - have I'm gonna put that string of text
12:30 - into a variable called friend and now
12:32 - I'm gonna make a couple more of those
12:34 - and look at the different types okay
12:36 - they're both strings make sense whether
12:37 - they have spaces or not now here's a
12:41 - question for you the number equals five
12:43 - but it's in quotes is it gonna be a
12:46 - string or an integer well we should know
12:49 - this it's going to be a string an STR
12:52 - and that is because of the quotes you
12:55 - know let's talk about the basics of
12:56 - printing so of course we have double
12:58 - which were starting to get used to for
12:59 - making a string variable but also don't
13:02 - forget we have single quotes and the
13:04 - reason you might want to use a single
13:06 - quote or a double quote in different
13:07 - situations has to do with the text
13:09 - inside so in this example it's national
13:12 - pie day we have a contraction that uses
13:14 - a comma so we're gonna want to use maybe
13:17 - double quotes but also maybe we have
13:19 - double quotes inside so we want to use
13:20 - single quotes or some kind of mixture of
13:22 - them so later we'll look at some other
13:24 - ways to handle that but just in a basic
13:26 - understanding either of these they're
13:28 - just identical they're the same thing so
13:30 - let's look at some formatting issues now
13:33 - formatting becomes a big thing you're
13:35 - constantly printing you're constantly
13:38 - writing things out and knowing how to
13:39 - make it all look right and spaced right
13:41 - and read right for the user is a big
13:43 - thing so formatting is one of those kind
13:45 - of core concepts in programming so let's
13:47 - make a couple variables here we have one
13:49 - that's called pop and another one called
13:51 - tart first brother-and-sister I assume
13:53 - and there's an old style of printing
13:56 - this does work in Python 3 it also works
13:59 - in Python 2 you'll see it a lot but it's
14:01 - not the recommended way so I just wanted
14:03 - you to see it but not really use it and
14:05 - that is to print out this % s % s and
14:10 - then use a percentage of the middle and
14:11 - it corresponds to the two variables so
14:13 - when you run that it does work but it's
14:16 - not the preferred way and there's a lot
14:17 - more powerful things you can do when you
14:19 - use this dot format function okay so
14:22 - this is the way we should be printing
14:24 - things print you open the quotes and you
14:28 - close them and somewhere in between
14:29 - where you want the variables to show up
14:31 - you use these double brackets double
14:33 - bracket double bracket okay so we know
14:35 - that our 1 course wants a pop and bar to
14:38 - a tart so it should say ding comma my
14:40 - pop was tarted I know I know
14:44 - okay so there we go boom work just fine
14:46 - but here are some cool things we can do
14:48 - now also we can also put the order of
14:50 - the variables in in any order that we
14:52 - want in the brackets so this one will go
14:55 - first then second by default but look
14:57 - now we can say make this the zeroeth
14:59 - because python often use a 0 for the
15:01 - number 1 slot and then number one
15:03 - meaning number two for this one so when
15:05 - we run this you'll see we get a reversed
15:07 - order ding my tart was popped you know
15:10 - it's very cool and
15:11 - in this one we're doing the same thing
15:13 - but now we're adding a duplicate okay so
15:15 - now we have 0 twice which no problem we
15:18 - can do that too so you can see how
15:20 - powerful it is to use this dot format
15:22 - with an open closed parenthesis because
15:24 - they're variables that are being put in
15:27 - passed in as parameters okay now let's
15:29 - look at some slicing and you know might
15:31 - not be an intuitive word but what we
15:32 - mean is we're taking the sentence up
15:34 - imagine I like a carrot and we're
15:35 - slicing it into little pieces and each
15:37 - one of those pieces is the different
15:38 - characters the K the end the ode the W
15:40 - so we're gonna make a new variable here
15:42 - called knowledge and now let's talk
15:44 - about some of the functions we have like
15:46 - we have Len which comes up a lot and
15:48 - it's actually gonna count how many
15:50 - characters there are inside so count
15:52 - them for me and then take a guess at
15:53 - what this cell is gonna I've returned 55
15:56 - whoa that's a lot but it's also correct
16:00 - now there's a question does it use the
16:03 - space as a character or not holy crap I
16:07 - don't know the answer to this I just
16:08 - asked it and thought it up right now
16:10 - 1 2 3 4 yeah 55 that includes the spaces
16:14 - because spaces are gonna be a Unicode
16:15 - character too so now we both know but
16:18 - let's look at slicing so we're gonna
16:20 - take knowledge and we're gonna put this
16:22 - different type of bracket notice the
16:24 - square bracket that we're using not the
16:26 - normal parameter parentheses K this is a
16:29 - different thing
16:29 - this is slicing and when we say 7 what
16:32 - we're saying is go in 7 letters
16:36 - 0 1 2 3 4 5 6 7 we are going to be
16:41 - returning a G okay now we can also do a
16:47 - slice that's a bigger chunk so instead
16:49 - of like little thin carrot slices this
16:51 - is just like cutting the carrot into
16:52 - thirds or something with larger width in
16:55 - between so in this case we're going from
16:57 - character number 7 to character number
16:59 - 20 so what do you think should happen
17:01 - when we run this cell
17:03 - okay we get GE is only a you know this
17:06 - is the slice from seven to 20 through
17:08 - here now what about if we use zero and
17:11 - then comma and then negative one whoa
17:14 - what's a negative Dylan we have you
17:15 - talked about a negative whereas echo
17:17 - well I kind of give it away with my
17:19 - mouse but take a guess and you can see
17:22 - it's an e so it looped around okay we
17:26 - have e because it's at the very end and
17:27 - this is another really cool powerful
17:29 - thing so knows you have these long lists
17:30 - and you know long sentences and things
17:32 - like that and you're gonna want to start
17:34 - from the other end start from the bottom
17:35 - and work your way up instead of working
17:36 - your way down now we also have in
17:39 - between first and last letters so we can
17:42 - do one : negative one and it's a little
17:46 - confusing cuz one's a looped around and
17:48 - ones on the front end so what do you
17:49 - think we're gonna get Oh
17:51 - everything in between minus those two on
17:53 - the side so you know it kind of you know
17:56 - went around and just took out the ends
17:58 - right it chopped the ends off the two
18:00 - sides and then I want to also show you
18:02 - that we can use some of our membership
18:03 - conditionals that you're gonna learn in
18:05 - the next section but it's really cool to
18:07 - just ask you know is the letter e inside
18:10 - of the word knowledge because behind the
18:11 - scenes they're kind of working like
18:12 - lists so we can do that too true he is
18:16 - in knowledge you can see it right there
18:17 - next to the L and behind the D okay now
18:21 - let's talk about concatenation so one of
18:23 - the things that we want to do at certain
18:25 - points is take these slices and put them
18:27 - back together right like two strings can
18:28 - be merged together so here's a couple
18:31 - variables I've created popsicle
18:32 - knuckleball and then a sequence which is
18:35 - all made of strings three strings
18:37 - Alvin Simon and Theodore with little
18:39 - dashes around them so let's go ahead and
18:40 - make those variables and then let's do
18:43 - this it's a concatenation pop string
18:46 - plus knuckle string is equal to this new
18:49 - variable X what do you think is going to
18:51 - happen when we print X
18:54 - it's squish them all together right
18:56 - popsicle knuckleball right now what if
19:00 - we do multiplication what do you think
19:02 - we're gonna get when we take something
19:03 - that's a string and we multiply it by
19:06 - five five times easy
19:09 - cool huh it's just popsicle popsicle
19:11 - popsicle everywhere popsicle popsicle
19:13 - now what if we concatenate a sequence K
19:16 - so we have our Alvin Simon Theodore
19:18 - sequence above what if we use pop string
19:22 - which has already got some kind of a
19:24 - variable in it our text and then we do
19:27 - dot join we bring that method in and we
19:30 - pass in an entire sequence so this is
19:32 - kind of confusing right like we actually
19:33 - have pop string which is its own
19:35 - variable and we're passing in this
19:37 - sequence so what do you think we're
19:39 - gonna get Alvin popsicle Simon popsicle
19:43 - Theodore whoa blow my mind but there's
19:45 - some very cool things like join that we
19:47 - can use to put these together and that's
19:49 - a process called concatenation now let's
19:51 - move on to our next topic which is
19:53 - escapee basically saying that there are
19:56 - certain patterns that if you put them
19:58 - inside of a string can break out of the
20:00 - string but most importantly it's this
20:02 - one character that's used most often
20:04 - it's a backslash okay so remember
20:07 - forward slash and backslash this is the
20:09 - one that has the top leaning to the left
20:10 - to the Leaning Tower of Pisa of falling
20:12 - to the left and when you use this
20:15 - in-between which should be just a normal
20:17 - string it's gonna break out the next
20:20 - character and the next character in this
20:21 - case happens to be N and n is gonna
20:24 - create a new line when it's broken out
20:26 - so in this sense take a guess what
20:28 - you're gonna see that way you expected
20:31 - it takes high it adds the space there's
20:34 - actually a space right here that's a
20:35 - character that came in and then it sees
20:37 - this and says okay the next character is
20:39 - gonna make me do something different not
20:41 - something that normally would be inside
20:43 - of a string oh it's order n create a new
20:45 - line and then ho so we have hi ho hi ho
20:48 - it's off to the next cell we go and in
20:52 - this one we're using the letter T now T
20:54 - is short for a tab and some of these
20:56 - things you're just gonna have to
20:57 - memorize but as long as you understand
20:59 - the concept of escaping and you're
21:00 - trying to do something with text you can
21:02 - probably go look up some of the other
21:03 - characters that you can escape and
21:06 - depending on your use case but as long
21:07 - as
21:08 - there there you can do really cool
21:09 - things like combine it with
21:11 - multiplication so just like before what
21:13 - do you think we're gonna get when we
21:14 - multiply an escape character and then n
21:17 - with five yeah five new lines check down
21:22 - here line line line line now let's talk
21:26 - about raw input which is something that
21:29 - is super cool it's the ability to simply
21:31 - ask the user for information text
21:34 - numbers integers and then use it in the
21:37 - same way as we've been using everything
21:38 - else so here's an example if you wrap
21:41 - this string what's your name
21:43 - in a function that starts with input
21:45 - what do you think is gonna happen
21:47 - let's find out what's your name and then
21:51 - this cool text box look I can name
21:53 - myself whatever I want
21:55 - Oh's oh okay well what happened now well
22:00 - we have a variable here that we set this
22:02 - to so let's check what's in it
22:03 - oh is oh cool huh so it just prompts the
22:07 - user to input things and then if you're
22:09 - working with websites and things like
22:11 - that you can actually style it so it
22:13 - happens in different ways but at the
22:14 - core of it this is pythons way for you
22:16 - to just type input and one of the things
22:19 - we can do is actually cast before
22:21 - dropping it into our variable so you can
22:24 - see how that could be sort of convenient
22:25 - if we were to take an input and it was
22:28 - some kind of a number we might want to
22:29 - cast it into a float because we'd want
22:31 - to do a calculation with it I mean I
22:33 - doing fingernails probably three times a
22:34 - month but yeah once a month okay so the
22:36 - number one goes in and because of the
22:38 - dot zero we already know that it's a
22:40 - float it couldn't have done that in any
22:41 - other way but I suppose just to show you
22:44 - how the proper way to do it is because
22:45 - you don't always have that hint would be
22:47 - to wrap it up like that and you'd see
22:49 - that it's a float okay cool so what if
22:52 - we want to take how many times each
22:54 - month do you cut your fingernails and
22:56 - turn that one into a float and then we
22:59 - want to use some concatenation maybe we
23:01 - want to add them actually so this is a
23:04 - that's an interesting mistake I just
23:06 - made we could probably learn from that
23:07 - plus we'll concatenate it if these two
23:10 - are both strings but we have trained
23:13 - changed them both in two floats so the
23:17 - plus is just going to do what plus does
23:18 - always in math and add the two together
23:20 - okay so the next question
23:22 - is how many times each month do you cut
23:24 - your fingernails well I cut them three
23:26 - times on average precisely so we run
23:30 - that now we can actually add the two
23:32 - together and put them in a new variable
23:33 - and we can have a total of four times a
23:37 - month on average I'm cutting either some
23:40 - kind of my nails I guess is the way to
23:43 - interpret that now let's talk about this
23:47 - repr function because I find that it's a
23:49 - great way to see how we interact with
23:51 - computers versus how a computer X with
23:53 - the computers okay it's like catching it
23:56 - in its own little environment how do you
23:58 - talk to yourself when I'm not around you
24:00 - know but if we import this module date
24:02 - time which you don't need to know we can
24:04 - make a couple of these variables based
24:06 - on date and time so let's just print
24:09 - these out know using a normal print so
24:11 - what we're saying is take the
24:12 - information that came turn it into a
24:14 - string cast it and then print it out so
24:17 - you can see the format the 2016 1204 and
24:19 - then the hour minute second and like
24:21 - super decimal second okay now I want to
24:25 - take the same variables but now instead
24:27 - of printing them out with string let's
24:29 - print them out with the Reaper function
24:31 - and see the difference now in this case
24:34 - it looks quite a bit different look it
24:36 - says date time dot date which is similar
24:39 - to how it's up here date time date and
24:41 - then dot today this function this method
24:44 - right here is now replaced and just to
24:47 - remind you guys it is a function but
24:48 - it's also a method because we're
24:50 - accessing it through the dot syntax but
24:52 - you can see it's a little bit different
24:53 - this is more of how the computer sees it
24:55 - and views it and thinks about where the
24:57 - information came from and this is more
24:59 - about how humans would want to read it
25:00 - so sometimes it can be great to run
25:02 - different things that you're trying to
25:04 - learn about through the Reaper function
25:06 - just to see and of a more structured way
25:08 - of where they're coming from now let's
25:12 - talk about encoding is I want to build
25:14 - on that utf-8 statement we made in the
25:16 - new mnemonics so ASCII is a different
25:19 - set of characters this is the one that
25:20 - you could have found in some places in
25:23 - Python 2 or python 1 and what you find
25:25 - in older computers that's now been
25:27 - totally removed from python 3 but it's
25:29 - the characters that kind of I'm most
25:30 - familiar with they come on the American
25:32 - keyboard but look at this if we actually
25:34 - make a
25:35 - variable and we put a string in it with
25:37 - ASCII characters in Python 2 we could
25:39 - have asked is this instance Unicode like
25:42 - we could have said is it a skier is a
25:44 - Unicode we could have checked for it but
25:45 - it's we're gonna get a warning now
25:47 - because everything is Unicode and that
25:49 - threw me off because it's saying like
25:50 - Unicode it's not defined it's just
25:52 - because it's baked so deeply into Python
25:54 - 3 that we don't need to check it all the
25:56 - time and that means we can just write
25:58 - variables like this strings that have
26:00 - whatever that is that blah I think or
26:03 - law or something and then you know cool
26:05 - Japanese characters like that they can
26:06 - just be written right in and one of the
26:09 - cool things about this is that with
26:10 - Python 3 we can actually just use
26:12 - unicode we can use Greek letters that
26:14 - come with Unicode so we can use the PI
26:16 - symbol if we want to just set math dot
26:18 - pi to you know the PI we can use the
26:21 - Greek letter epsilon the capital one if
26:23 - we want to use something for like some
26:24 - and it makes it very cool we can use all
26:26 - these like copyright icons and things
26:28 - like that inside of our code to you know
26:30 - explain things better to other people
26:32 - who are reading it and to remind
26:33 - ourselves and you know just be badass
26:36 - programmers really okay and then I want
26:39 - to talk to you about this function it's
26:40 - called Ord and what it's doing is it's
26:42 - linking a specific unicode number that
26:45 - we don't see but is actually behind
26:48 - every character so in an ASCII character
26:50 - like a there's gonna be a specific
26:52 - number in unicode utf-8 that is going to
26:56 - correspond to the capital letter a so
26:58 - we'll have another one for the capital b
27:00 - and you can see that they're separate
27:03 - but then when you actually go to
27:04 - lowercase they have their own numbers
27:05 - too so this is I was keeping track
27:07 - behind the scenes of all these
27:08 - characters in fact I think I could
27:10 - probably even take like this Greek
27:12 - epsilon and throw it in there and then
27:14 - it's gonna have its own number and it's
27:16 - always gonna be that same number so
27:18 - that's gonna correspond with what we see
27:19 - on our end ok so just one other use case
27:22 - for this I want to show you is that we
27:24 - can use a for loop and I know you
27:25 - haven't seen this before we'll talk
27:26 - about it later but just kind of observe
27:28 - it and get familiar with it on a sort of
27:30 - superficial level to actually run
27:33 - through every single character in a
27:35 - string and show us what the character is
27:37 - that corresponds to the utf-8 so you
27:40 - know that capital i' is always going to
27:41 - be the number 73 behind the scenes okay
27:44 - now let's talk about some methods that
27:46 - we can use with strings because this is
27:48 - really
27:49 - the fun stuff is okay so finally let's
27:53 - talk methods and there's way too many to
27:54 - cover everything but I just want to get
27:56 - you excited about some of the big
27:57 - groupings and the stuff that I use a lot
27:59 - so let's start with a new variable
28:01 - that's a long string our best friend
28:03 - string and now we can actually use the
28:05 - method dot capitalize to make sure it
28:08 - starts with a capital in this case it
28:09 - already does so you don't say anything
28:10 - but that a at the beginning right there
28:13 - is because we ran it through this method
28:15 - and we can go further and use some other
28:16 - cool ones like upper we can make
28:18 - everything lowercase we can make
28:20 - everything title case so that each
28:21 - letter has a capital at the beginning of
28:23 - it and we even can do checks so you can
28:26 - take a string variable and you can say
28:28 - dot is upper and we're asking give me a
28:30 - true or false response if it is all
28:33 - upper or if it's not and you can do that
28:35 - to then trigger the change so you can
28:37 - say hey bring me a bunch of text if it's
28:39 - not already in title case then make it
28:42 - in title case or something along those
28:43 - lines there's also some really cool ones
28:46 - that we can use with strip and this is
28:47 - gonna remove white spaces so if we have
28:50 - an input function like a raw function
28:52 - that we looked at before and somebody
28:53 - types in some stuff with a bunch of
28:55 - spaces at the beginning or end this is
28:57 - gonna strip those clean we also can
28:59 - remove the leading white spaces or just
29:01 - the trailing white spaces and hard to
29:03 - see these but they would be spaces that
29:05 - would be over here over here we can also
29:07 - do some cool stuff with alignment for
29:10 - example this one dot Center is going to
29:12 - bring us a method that allows us to put
29:14 - 50 characters before and after it'll
29:17 - take that number and split it between
29:18 - the two and put them on both sides to
29:20 - help Center your text and there's some
29:22 - other cool alignment ones too we don't
29:23 - have time for but I want to get defined
29:25 - so if we take this string here and we
29:28 - use dot find clover it's actually gonna
29:30 - parse through the entire thing and find
29:33 - the word clover and then it's going to
29:34 - count how many spaces it went before
29:36 - finding it so we know that it's 34 in
29:38 - there's also this one that counts
29:40 - characters we're looking for how many
29:42 - times the letter A and lowercase shows
29:44 - up so like one two three four like that
29:47 - it will count it and return that there's
29:49 - four in the entire string and the max
29:51 - and min which you might think of usually
29:53 - only in the terms of numbers are also in
29:55 - alphabetical order so it can say you
29:57 - know is there a queue is there a Z
29:59 - what's the maximum height flow letter
30:01 - inside of this string
30:03 - and we can see that it's a why and we
30:05 - can do the same with men I'm sure it'll
30:06 - find an a oh actually a nothing yep so
30:09 - even before a is a space so it's really
30:12 - cool there's a lot of neat things you
30:14 - can do with Find and Replace you can
30:16 - actually go in and say take the word
30:18 - clover right which this can be a really
30:21 - useful function and we know where that
30:22 - is right here and then we say replace it
30:26 - with snickerdoodle then boom the best
30:29 - friend is like a four-leaf snickerdoodle
30:30 - that is very cool and it can do some of
30:32 - the same things that you can do a slice
30:34 - but way simpler more automated
30:36 - especially with big corpuses of text so
30:39 - let's make our friend variable and then
30:41 - let's just run dot split method and see
30:43 - what happens
30:43 - oh how cool is that it broke out our
30:46 - entire sentence into individual words
30:48 - and it does this by a need Eliminator we
30:51 - want so we didn't put in an argument we
30:53 - passed in nothing so it just did a
30:55 - default which is to look for these
30:57 - spaces but check this out we can also
30:58 - add in the string with a comma in
31:02 - between it and it's going to look for
31:03 - these and split at the commas so see now
31:07 - we have a list that has three different
31:10 - items in it and it's the ones between
31:11 - the commas and we could do that with all
31:13 - sorts of stuff you can make maybe Ellie
31:15 - is where you want on yours to be or I
31:17 - don't know some kind of crazy array that
31:19 - makes sense to you and the last one I
31:21 - want to talk about is split lines this
31:23 - is just like split but what it's going
31:26 - to do is automatically do it on the
31:27 - character return so if you had a large
31:29 - corpus of text that had paragraphs this
31:32 - would break it in each paragraph into
31:34 - their own item on a list very cool stuff
31:36 - lots of neat methods I encourage you to
31:38 - explore oh and remember what about this
31:41 - and in fact before we end I will give
31:43 - you a reminder of something else we
31:45 - learned dot tab is going to let you look
31:48 - through all of these cool things so I
31:51 - encourage you now to just go through and
31:52 - play with them all see what else you can
31:53 - do with the text
32:02 - subscribe to the mnemonic Academy
32:05 - YouTube channel for daily uploads that
32:07 - will help you learn amazing concepts
32:09 - through effortless associations we will
32:22 - be learning the how of programming by
32:25 - reviewing code examples that demonstrate
32:26 - how lists work including some of the
32:30 - various sub topics like how to view a
32:32 - list how to insert new items into a list
32:34 - how to find certain items inside of a
32:37 - list how to retrieve the specific item
32:39 - that we find how to remove items combine
32:41 - sort all of the stuffs that we might
32:43 - want to do with lists then we're gonna
32:45 - talk about range and range is a really
32:47 - powerful way to make a list it's a way
32:49 - that we can specify huge lists without
32:51 - having to go in there and manually type
32:53 - everything and then finally we're gonna
32:55 - talk about matrices which are really
32:57 - just lists inside of lists and different
32:59 - things that we can do to break them up
33:01 - and flatten them down and look at them
33:03 - in different dimensions so let's get
33:05 - ready to talk about the all-important
33:08 - Python list definitely one of the most
33:12 - powerful types in Python comes up all
33:14 - the time as a programmer and you can see
33:17 - why they're so powerful they can hold
33:19 - integers floats strings they can hold
33:22 - lists of lists and they all have a few
33:24 - characteristics so we start with a
33:26 - variable we use an assignment operator
33:28 - this equal sign and then we open a
33:30 - bracket and close a bracket the square
33:32 - brackets and inside we put all sorts of
33:35 - different elements which can be
33:37 - different types they can be strings
33:39 - integers floats etc they can be all
33:41 - sorts of different things and elements
33:43 - are just broken up by these commas so
33:45 - you can see how easy it is to make a
33:47 - list and then we can even put lists
33:48 - inside of lists and they will be broken
33:50 - up in the exact same way with the comma
33:52 - in between let's run this cell we now
33:54 - have three lists our scores tax code and
33:56 - mixed and now let's look at how we view
33:59 - it so if you're using Jupiter of course
34:00 - we have individually running cells so we
34:03 - can just write scores which is going to
34:05 - return it and of course we're using an
34:06 - IDE or some kind of other interactive
34:08 - way to work with Python you could use
34:09 - the print statement and it would do the
34:11 - same thing and here is something I
34:13 - haven't talked about yet but
34:14 - we have an entire video devoted to for
34:16 - loops so don't worry about the syntax
34:18 - too much but one way to think about this
34:21 - is that this is a special way to address
34:23 - some kind of logic on each individual
34:26 - element before passing on to the next
34:28 - one so it would be like you know
34:29 - multiply 3 times 3 and then multiply 1
34:32 - times 3 and then multiply 4 times 3 or
34:34 - whatever it is in this case we're just
34:36 - printing that we can break them into
34:37 - their own lines and now inserting is
34:40 - gonna be one of the most common use
34:41 - cases you're gonna maybe create a list
34:43 - and you're gonna wanna you know scrape
34:45 - the internet and like tack on a whole
34:46 - bunch of things to a list or you know
34:48 - whatever reason a database of some kind
34:50 - and you're gonna want to add things to
34:51 - and any variable that is of the type
34:53 - list has a method called insert an
34:56 - insert requires two arguments the first
34:58 - one is the position that you want to
35:00 - insert the element in and the second one
35:02 - is the element itself I've got a
35:04 - question for you here is our tax code
35:06 - list you can see that it's BAM Fuzzle
35:08 - caddywhompus gargle ooh and Billingsgate
35:11 - we want to add a loophole to this tax
35:14 - code and we have specified the number to
35:17 - what position is it going to end up in
35:19 - thank you yes is that what you thought
35:22 - the third position so this is a reminder
35:25 - that python uses zero indexing so this
35:28 - is the zero number this is the one and
35:31 - this is the two which makes sense when
35:33 - you think about it from a computer's
35:34 - point of view but it's not necessarily
35:36 - intuitive to how we would normally count
35:37 - normally you would say this is probably
35:39 - the third item in a list but it's not
35:41 - how Python works so it's just something
35:42 - to remember now another really powerful
35:44 - way to add an item to a list is to use
35:47 - the append method and this is really
35:49 - powerful because we don't need to know
35:50 - how long the list is instead we can just
35:52 - say append and no matter how long the
35:54 - list is it's gonna put this on the end
35:55 - when we run this cell you can see that
35:57 - we now have added our loophole our was
35:59 - loophole so now we added our was
36:01 - loophole to the end
36:02 - so now BAM Fuzzle cattywampus loophole
36:04 - gargola Billingsgate and Oise loophole
36:06 - are all inside of the tax code so how
36:09 - are we gonna find one of these list
36:10 - items because these lists you could
36:12 - imagine become thousands or maybe even
36:14 - millions of elements long how can we
36:16 - find something in an efficient way
36:17 - well Python gives us some really
36:19 - powerful methods to do that also so here
36:21 - we are making a new variable called
36:23 - letters and we're creating a list that
36:25 - holds the string these are single
36:27 - character strings
36:28 - PQRS Oh and you what we can do is
36:32 - actually say here's the variable of type
36:35 - string dot for accessing our method use
36:38 - the method index and check to see if the
36:41 - list is holding the string of character
36:43 - R so when I run this cell what do you
36:46 - think is gonna happen cuz you'll notice
36:47 - that there is an R there is a P but
36:49 - there is not a Z okay well that's what
36:52 - we expected so it's actually a little
36:54 - more powerful okay so that's what we
36:55 - expected right we have R which is in the
36:58 - second position 0 1 2 we have P which is
37:02 - in the zeroeth position the very first
37:04 - one and then we have a Z which is not in
37:07 - the list at all so it throws a value
37:08 - error not in the list you can imagine
37:10 - how powerful that would be if you want
37:12 - to look through you know a database of
37:13 - names and say is this name in there
37:16 - another thing that we might want to find
37:17 - out is how long is our list so we can
37:20 - simply wrap that in le n for length when
37:23 - we put our variable of type list in
37:25 - there it will return 6 for the 6 items
37:27 - 0 1 2 3 4 5 or 1 2 3 4 5 6 so here you
37:36 - can see that it actually does return how
37:37 - many individual elements there are and
37:40 - we don't need to think about it in the
37:41 - terms of 0 to 6 we just think of it as 6
37:45 - you know a little tricky there but just
37:47 - something to keep in mind how Python
37:48 - indexes sort of on 0 but there's still
37:51 - only 6 elements in it you know but I
37:53 - feel like that's one of those things
37:54 - that like just trips up everybody even
37:56 - good programmers are just like why
37:58 - didn't that come yeah oh yeah that's
37:59 - right zero indexing you know so
38:01 - retrieving something out of a list is
38:03 - also very important ok here's a reminder
38:06 - of our tax code Bam Fuzzle caddywhompus
38:08 - loophole gargle ooh Billingsgate was
38:10 - loophole so if we want to retrieve an
38:12 - item there is a very special syntax and
38:14 - they call this slicing whenever you see
38:16 - these two brackets surrounding integers
38:19 - we're slicing a list up you know a
38:22 - couple things to note here is that this
38:24 - is very different from like space equals
38:26 - that that's creating a list with the
38:28 - integer 0 in it this is assuming the
38:31 - list already exists and it's this
38:33 - variable tax code and we want the
38:35 - zeroeth element we want Bam Fuzzle to be
38:38 - returned let me run this cell and show
38:40 - you what I mean so you can see it's
38:42 - actually saying bam Fuzzle and what if
38:43 - we put in one it's gonna bring in
38:45 - caddywhompus or two so this is a way to
38:48 - pull out the third element or the second
38:50 - element from our list and we can also
38:52 - slice out groups very commonly you're
38:54 - gonna want a range of things so here we
38:57 - want one through three now remember our
39:00 - zero indexing makes this a little
39:01 - confusing why don't you take a guess we
39:03 - have 0 1 2 & 3 and we're specifying give
39:06 - me everything between 1 & 3 so you know
39:09 - if you haven't seen this before you
39:10 - might think well it could bring all of
39:12 - these 3 it might bring just these 2 or
39:14 - just these 2 but let's run it and see so
39:17 - we get just caddywhompus & loophole so
39:20 - by slicing the index 1 through 3 we're
39:24 - ignoring 0 makes sense we're starting
39:26 - with 1 then we're getting to and then
39:29 - surprisingly we're not getting 3 so
39:31 - that's just a reminder that the third
39:33 - element is kind of the one that you
39:34 - ignore it's gonna capture the one right
39:36 - before it it's not gonna include this
39:37 - but it is gonna include that so I always
39:39 - think of it like this ones included this
39:42 - one's not included now another
39:43 - interesting thing about slicing is we
39:45 - have the ability to use negatives so
39:46 - what do you think it negative 3 is gonna
39:48 - do you guess and then we'll talk about
39:51 - it
39:51 - dargol ooh okay so it brought us this
39:54 - one let's look at why negative 3 goes
39:58 - backwards it loops around the list we
40:01 - can always assume that this first
40:03 - element is 0 and then we can count up 1
40:06 - 2 3 or in the case of a negative slice
40:09 - we actually jump and loop all the way
40:12 - around to woz loophole so negative 1
40:15 - negative 2 and negative 3 okay so the
40:20 - way to think about that is actually
40:22 - let's say 0 1 2 3 let's not use 3
40:24 - because that is actually the same either
40:26 - way but something like Billingsgate you
40:29 - can think 0 loop around negative 1
40:34 - negative 2 so negatives are another
40:38 - really powerful way to jump to the end
40:39 - of a list now let's look at how we can
40:41 - save a slice just reminder here's what
40:44 - our tax code looks like slicing is very
40:46 - powerful in its shorthand notation where
40:48 - we use those brackets with the colon or
40:51 - an individual number but it's also on
40:53 - its own function and its own function
40:54 - comes with more
40:55 - parameters in fact it has the ability to
40:57 - step which is an interesting property so
41:00 - what we can say is I want to get every
41:02 - other element every odd element or every
41:04 - third element so here there's a function
41:07 - called slice now if we look at some of
41:09 - the parameters using our nifty shift-tab
41:11 - in jupiter we can see that the first
41:14 - argument is for where the slicing starts
41:16 - the second one is for where it stops
41:18 - this is very similar to the colon but
41:20 - then we also have this thing called step
41:22 - meaning take every second item so I will
41:25 - save this into a variable and then we
41:29 - will pass that variable into here now
41:31 - remember that's the same as taking this
41:33 - and doing that you have something
41:34 - specific you want and then use it as a
41:36 - variable later but it can be used either
41:38 - way depending on your purpose so let's
41:39 - go ahead and make that slice now we can
41:41 - see slice 0 none to just what we specify
41:44 - it now we're gonna pass that into our
41:46 - tax code and we get out every other
41:48 - element just like we asked for so it
41:51 - starts with the zeroth element and then
41:53 - it doesn't take one but then it does
41:54 - take two and then it doesn't take three
41:57 - and it does take four very cool pattern
42:00 - now if we do one that's gonna be the
42:01 - same as just a range that's gonna give
42:03 - us everything or if we do three it's
42:05 - gonna jump all the way to the third one
42:07 - and just give us Bam Fuzzle and gargle
42:09 - ooh and if we add another element there
42:10 - it would bring that back too so very
42:11 - cool way to retrieve items now how about
42:14 - removing an item from a list because
42:16 - this is another very common thing well
42:18 - it's as easy as using the remove method
42:22 - tax code remove Bam Fuzzle course we
42:25 - won't get rid of that loophole but now
42:28 - Bam Fuzzle is gone so you can see right
42:30 - here it that was the first element in
42:32 - our list and when Bam Fuzzle
42:34 - caddywhompus Gargoyle ooh and billions
42:35 - gate and now it's just caddywhompus
42:37 - gargle ooh and Billingsgate just what we
42:39 - wanted now let's look at some fun ways
42:40 - to combine lists together so there's a
42:42 - lot of powerful things we can do here I
42:44 - won't cover them all but for example
42:46 - what if we have a list here of strings
42:48 - it's all different strings no integers
42:50 - in here code mint or Python and
42:53 - developer now if we take this variable
42:56 - and we pass it into an empty variable of
42:59 - type string and we use the join method
43:02 - it can actually combine these together
43:04 - so if I went I don't know feels like it
43:06 - went kind of fast there but basically we
43:07 - have we have our list okay
43:09 - it's all made of strings and then we're
43:11 - saying just forget that for a second and
43:13 - then what now we're saying over here
43:14 - make a new variable and it's got a
43:16 - string inside of it this could be words
43:18 - but it's not it's just empty it's just
43:20 - one space character so the string is of
43:24 - one character and it's the space
43:26 - character so you don't really see
43:27 - anything but just know it's a string of
43:29 - one space and then we're saying hey
43:31 - you're of type string and you have a
43:34 - special method called joined so when you
43:37 - pass in a list the join is going to
43:40 - combine all of these together they're
43:43 - not separated any more this is all one
43:45 - word this is like a paragraph or a title
43:47 - whereas these are individual elements
43:49 - inside of a list now lists can also hold
43:52 - a different list so an example of that
43:53 - would be here we have a list called
43:56 - things and it's holding strings an int
43:59 - is holding a string an integer and then
44:01 - a whole nother list and this list has
44:04 - two more integers and it also has
44:07 - another integer that's coming in through
44:08 - this variable numbers here and that has
44:10 - a float now here's the syntax that you
44:12 - don't need to know yet we're gonna cover
44:14 - this in later videos but one powerful
44:16 - thing I just wanted to show you that we
44:17 - can do with lists is we can break a
44:19 - string apart into individual characters
44:22 - and then put those individual characters
44:24 - back into a list so don't worry too much
44:26 - about this it's called the list
44:28 - comprehension that we're gonna talk
44:29 - about later one of the cool things you
44:31 - can do is take a string 1 space 2 space
44:34 - 3 and break it into actual integer so
44:38 - we've cast it into an integer here and
44:40 - these are four different integer numbers
44:42 - that we could do math on and they
44:43 - started out as just numbers that were
44:45 - inside of a string so maybe you can
44:46 - imagine some situation where you're you
44:48 - know parsing some text and you're
44:50 - pulling out numbers and then doing math
44:52 - on those numbers kind of cool as long as
44:54 - we're talking about these lists inside
44:55 - of lists we're basically making groups
44:57 - right so let's look at a couple
44:59 - different ways that we can do some more
45:01 - powerful grouping we have a list here
45:03 - that's just full of a bunch of integers
45:05 - a bunch of random numbers and one of the
45:07 - things we can do is create groups of
45:10 - either 3 or 2 or 4 or whatever we want
45:14 - now don't worry too much by the syntax
45:15 - this is kind of later in the course kind
45:18 - of stuff but I want to show you that we
45:20 - can actually make an awesome group of
45:21 - four or
45:22 - we can make a group of two so we've
45:25 - taken all of these elements up here and
45:26 - said make those two a group make those
45:28 - two make those two a group and this
45:30 - group is technically called a tuple but
45:32 - we'll learn about that in the next video
45:33 - so it's really cool to be able to take
45:36 - lists and break them up like that and
45:37 - another neat thing that we can do is
45:39 - actually count them so this really cool
45:40 - method called max we can pass in a list
45:43 - and then we can look at a key called X
45:45 - dot count so we can find out that the
45:48 - number one is the most common you can
45:51 - see that number one occurs three times
45:53 - and all of the other ones only occur
45:55 - once so pretty neat stuff we can do is
45:57 - just the tip of the iceberg when it
45:58 - comes to combining let's talk about
46:00 - sorting we'll start with a couple lists
46:01 - here these numbers are not in order and
46:03 - these words are not in alphabetical
46:05 - order so just note that to start with
46:07 - and then we can actually just run them
46:09 - through a function called sorted which
46:10 - is gonna look for either the smallest to
46:13 - largest number or alphabetical setting
46:15 - if we run scores through this function
46:17 - we see that we're now in order one two
46:20 - three point three three point three etc
46:22 - and another syntax for that is using a
46:24 - dot sort method and then passing nothing
46:27 - into the parameters so starting with tax
46:28 - code our list we can actually use that
46:31 - syntax to put these in alphabetical
46:33 - order Billingsgate bumfuzzled
46:35 - caddywhompus and gargle ooh and then
46:37 - finally I just want to talk about one
46:38 - way we could reverse a list we could
46:40 - sort it in backwards order and that
46:42 - would be to use this negative one saying
46:44 - sort of go backwards with a couple
46:46 - colons before it and by using this we
46:48 - can actually sort backwards so gargle
46:51 - ooh caddywhompus bam Fuzzle and billing
46:54 - gates will be in the reverse order now
46:56 - we have an idea of sorting so so we've
46:58 - covered a lot this is an area where
47:00 - you're gonna want to keep playing with
47:01 - lists until you get more familiar with
47:02 - them but now let's talk about ranges
47:04 - which are a really powerful way to make
47:06 - lists next up let's talk about a special
47:10 - function called range and it has a lot
47:12 - to do with the way lists work there is a
47:14 - function here and it's called range and
47:17 - it takes a minimum of one parameter so
47:19 - if you give it one argument it is going
47:21 - to create something of type range which
47:24 - is different than type list but in this
47:26 - case we're gonna want to be using him in
47:28 - the sense of a list so instead of
47:30 - leaving it at range 6 we're actually
47:32 - going to always be wrapping it in this
47:34 - list here we
47:35 - can get range to return a list of six
47:37 - elements zero one two three four and
47:39 - five six elements here and imagine if we
47:42 - wanted this to be a million long or a
47:44 - hundred thousand long now the way to
47:45 - think of range with one argument is that
47:48 - this is the stop argument it's gonna
47:49 - start at zero and it's gonna go until
47:51 - it's got six elements and then it's
47:53 - gonna stop but we can also specify in
47:55 - between some kind of a range so we can
47:58 - have a start element and a stop element
48:01 - and in this case going from three to six
48:02 - just like with list slicing this is like
48:05 - list creation but it's gonna go from
48:08 - three four and five creating three
48:11 - elements and just like the list slicing
48:13 - it's gonna take the start argument and
48:15 - actually make that the number and then
48:16 - it's gonna stop one before the second
48:18 - now if we look here we use our ship tab
48:21 - to learn a little bit more and we'll see
48:23 - that range has another argument start
48:25 - stop and step this is very similar to
48:28 - how we were using the slice function
48:31 - where we were stepping every other or
48:33 - every third and we can do the same thing
48:35 - so here we're gonna create a list it
48:37 - goes from the elements two through ten
48:39 - so there's gonna be eight elements total
48:41 - and it's gonna be using every other one
48:44 - which gives us which gives us that's
48:47 - right two four six eight which range do
48:50 - we appreciate this range this range you
48:52 - tell my cheerleader days didn't go too
48:55 - well now we can also go backwards so we
48:58 - can have list range and we can have 0
49:00 - through negative ten and remember this
49:02 - is gonna go around a loop so what do you
49:04 - think is gonna happen here where we have
49:06 - a negative 10 and a negative two because
49:08 - before we talked about negatives looping
49:09 - back around in a list but we haven't
49:11 - even created a list to loop yet so what
49:14 - do you think it's gonna do well let's
49:15 - find out interesting so negative two
49:19 - negative four negative six negative
49:20 - eight who do we appreciate
49:22 - yeah it doesn't really work the same but
49:24 - it is stepping backwards negative twos
49:28 - and it is giving us a total of negative
49:31 - ten so you can see it works about the
49:33 - same way now interestingly we can put
49:36 - positive steps and it's not going to be
49:38 - able to go anywhere because it's gonna
49:39 - only have negative numbers for its list
49:41 - so we have to have negatives for here
49:44 - and negatives for here if we're looking
49:46 - to step through a negative range that's
49:48 - all range
49:49 - in nutshell very powerful very cool very
49:52 - fun way to make lists they I want to
49:56 - touch on the power of lists when they're
49:58 - holding integers and floats and numbers
50:00 - we can work with and thinking of them as
50:03 - multiple dimensional arrays so we might
50:06 - have something like this a matrix which
50:08 - is really a list of lists and it has
50:10 - nothing but numbers in it it's got two
50:12 - elements this element and this element
50:14 - and each of those elements is a list of
50:16 - three items in themselves but another
50:17 - way to think about it would be in a
50:19 - multi-dimensional sense so we could
50:21 - actually think of a Y and an x-axis and
50:24 - think of it as a 2d array where we have
50:26 - these numbers stacked on top of each
50:28 - other just like a matrix and one of the
50:31 - things we can do when we start thinking
50:32 - about lists in this way is we can do
50:34 - things like rotate so here if we take
50:37 - the matrix and we'll use this function
50:38 - that we haven't talked a lot about
50:39 - called zip which combines two different
50:41 - elements together in a special way and
50:43 - we reverse them by using the negative
50:45 - side of the matrix reverse that we
50:47 - talked about earlier so we can actually
50:49 - output this which is a different
50:50 - arrangement of the matrix that we
50:52 - started with where four and one are
50:54 - grouped together five and two are
50:56 - grouped together in six and three but
50:57 - then if we break these out also based on
51:00 - the comma the same way we did up here
51:01 - you'll notice that it creates a
51:03 - different shape four five six one two
51:05 - three one two three four five six it
51:08 - looks like what we've done is just
51:09 - rotated this around and we have a
51:11 - different shape now and that's exactly
51:14 - what we did we rotated a matrix so
51:16 - imagine like in a video game when you
51:17 - want to move a character around or you
51:20 - want a character to like turn to the
51:22 - right this is essentially the concept
51:24 - pretty neat stuff really when you start
51:25 - thinking about it another thing we might
51:27 - want to do is flatten them out so let's
51:28 - look at some examples of that because
51:30 - there's a bunch of different ways to
51:31 - think about this so let's start with a
51:33 - multi-dimensional array we have one two
51:35 - three four five six on separate things
51:37 - so another way we could actually write
51:38 - this out is using commas and spaces and
51:41 - this is totally valid we can run this
51:43 - cell in the exact same way we could have
51:44 - when it was all flattened out anytime
51:46 - there is a comma feel free to drop it
51:48 - down to a new line and Python will know
51:49 - to keep these all oriented correctly and
51:52 - one of the things we can do is run this
51:54 - sum function over it and for the second
51:56 - parameter put a blank list and look what
51:58 - we get we get it all flattened out one
51:59 - two three four five six all in one way
52:02 - now there's a couple more comp
52:03 - created ways to do it I just wanted to
52:05 - show you we haven't covered these things
52:06 - by using list comprehension we can do it
52:08 - there's also something called itertools
52:10 - that can do it the same thing so a bunch
52:11 - of different ways this is the simplest
52:13 - so thanks for watching and let's get our
52:16 - right brain ready for another lesson
52:17 - coming up next subscribe to the mnemonic
52:21 - Academy YouTube channel for daily
52:23 - uploads that will help you learn amazing
52:25 - concepts through effortless associations
52:39 - welcome in today's lesson we are going
52:41 - to be learning the how of programming by
52:43 - reviewing code examples that demonstrate
52:45 - tuples what they do what makes them
52:48 - different than lists and what it means
52:50 - to be immutable and then we're gonna
52:52 - talk about a different type called sets
52:54 - and how sets are a lot like a Venn
52:56 - diagram they have the ability to
52:58 - calculate Union intersection or
53:01 - difference or even symmetric difference
53:03 - so get ready cuz these are a couple fun
53:05 - types to play with let's get started so
53:09 - let's start talking about tuples
53:11 - so tuples are very similar to lists the
53:13 - main way you can tell the difference is
53:15 - because of the brackets on the outside
53:17 - the circular brackets mean that it's a
53:19 - tuple the square brackets mean that it's
53:20 - a list and the difference is being that
53:22 - the tuple is unordered and immutable
53:24 - meaning it can't be changed and we'll
53:26 - talk about that more in a second but
53:28 - let's start by just creating a list in
53:29 - creating a tuple so we can compare the
53:31 - difference so when we run these first
53:33 - three cells you'll see that even when
53:35 - they're printed to the console they have
53:36 - the different bookends so that's one of
53:38 - the easiest ways to tell what we're
53:39 - dealing with also of course we could
53:41 - simply ask by using one of our favorite
53:43 - functions type and noting that it's a
53:45 - tuple also okay now let's look at some
53:47 - of the methods that are gonna come with
53:48 - tuples so let's use our trusty dot tab
53:52 - function here that Jupiter allows us to
53:55 - do to see what methods a type has so by
53:58 - hitting period and then hitting tab I
54:00 - can see that a tuple has two methods
54:02 - count and index so here's a question
54:05 - before we look at those what do you
54:07 - think is gonna happen when we do a dot
54:09 - tab on my list you think a list is gonna
54:11 - have more or less methods whoa
54:14 - tons more right okay so the reason
54:17 - why there's so many more is because of
54:19 - an important property of tuples and that
54:22 - is that they are immutable
54:24 - we can't have an immutable tuple that's
54:26 - pointing to a mutable element so there
54:29 - can be some changes but on the highest
54:31 - level the tuple is a secure unchangeable
54:35 - thing now let's make a couple two poles
54:37 - let's make some DC villains because
54:39 - they're immutable you wouldn't want to
54:41 - get rid of them and then an integer one
54:42 - for pi so one cool thing is that we can
54:45 - cast these into lists we want to maybe
54:47 - edit these but they're immutable so what
54:50 - we do is we can take pi we wrap it in a
54:53 - list function and then we end up with a
54:54 - list we can actually wrap this list
54:57 - inside of a tuple so new list tuple and
55:00 - it's gonna become a tuple again so you
55:02 - can see now it's locked into place here
55:04 - and finally I just want to show you that
55:06 - just like the list we can use the for
55:08 - loops which once again we haven't talked
55:10 - too much about yet but we can use logic
55:12 - on individual elements in a sequential
55:15 - order one of the easiest being simply
55:17 - printing them out so 1 2 3 4 5 you know
55:21 - list you know tuples time to talk sets
55:25 - sets are very powerful and they are
55:27 - different from lists and tuples because
55:30 - they don't have duplicates and they're
55:32 - not stored in order and they are mutable
55:35 - so I think of them kind of as Venn
55:37 - diagrams like the same way you could
55:38 - imagine a Venn diagram using unions or
55:41 - intersections or differences that's
55:42 - usually the way that we're gonna work
55:43 - with sets so we'll show some examples of
55:45 - that after we get the syntax down the
55:47 - main syntax is to use these curly
55:50 - brackets on both sides so you're
55:51 - probably noticing the pattern here with
55:53 - the square brackets for lists and the
55:55 - parentheses for tuples and now the curly
55:57 - braces
55:57 - actually the curly braces are used for
55:59 - both dictionaries and for sets but the
56:03 - difference is a set only has one item in
56:05 - between the commas main thing to notice
56:07 - is that it has the curly braces here so
56:09 - let's make a set there we go we've got
56:12 - Dylan Elmer Gere Mochan and Naomi so
56:16 - what type is this well it's a set like
56:18 - we said it would be now there's also a
56:20 - function for creating sets and we can
56:22 - pass in a set or we can pass in a list
56:25 - but of course we can't pass in the
56:26 - elements in the same way we would a list
56:28 - it only takes one argument
56:30 - the argument needs to be made up of
56:32 - several elements so just for an example
56:34 - we can see the function create sets in
56:35 - both of these situations ok so now let's
56:37 - talk about the duplicates because that's
56:39 - one of the big things about sets is that
56:41 - in this list we have the number 2 2 2 2
56:44 - and that's just fine with a list we can
56:47 - have a whole bunch of duplicate elements
56:49 - it's gonna remember them in order in a
56:51 - sequence but a set does not it can only
56:55 - have the element one time so we're gonna
56:57 - make this list a set and see what
56:59 - happens we're making my list with the
57:02 - duplicates and then we're passing that
57:04 - into the set function to make it a set
57:06 - so when we look down here at the length
57:08 - of my list when we check the length of
57:10 - this original one and we check the
57:12 - length of my set you're gonna notice
57:14 - that there are different sizes because
57:16 - it's eliminated all of the duplicates in
57:18 - fact if we actually want to print out my
57:20 - set here you can see that it's now 1 2 3
57:23 - 4 5 instead of 1 2 2 2 2 3 4 5 and now I
57:28 - want to talk about what we would do if
57:30 - we had a list of strings so here we have
57:32 - a list of strings that we're turning
57:34 - into a set now remember the dot split
57:36 - method is going to take each word and
57:39 - separate it by the space and make it a
57:41 - list of strings instead of one long
57:43 - string so we can think of this as
57:45 - inputting a string for my a separate
57:48 - string for peanut another string for is
57:50 - and then turning that into a list which
57:53 - is then turned into a set when we do
57:56 - that I want to show that it does
57:57 - consider the difference between capitals
58:00 - separate and unique Elmer my and is my
58:04 - is coming in as a separate character and
58:06 - this makes sense the Unicode behind the
58:08 - capital m and the lowercase M are
58:10 - separate so it sees these as totally
58:12 - different elements so even though it
58:14 - might read the same we have to remember
58:15 - that something like a capital might be
58:17 - seen as different and unique to the
58:19 - computer when it makes the sets enough
58:21 - with the Venn diagrams stuff now let's
58:24 - talk unions so to take the union of two
58:26 - sets is as simple as calling one of its
58:29 - methods now we're gonna need two
58:31 - different sets to work with so let's
58:32 - take the first one again my peanut is
58:34 - named Elmer and then let's make another
58:36 - set which is just names but one of the
58:39 - names happens to be Elmer so you'll see
58:41 - Elmer here and you'll
58:42 - Aylmer there now we know that sets can't
58:45 - have duplicates and when a union is
58:48 - checked its going to see if there is any
58:50 - duplicates between the two different
58:52 - sets the way this would work is we can
58:53 - pick either one will start with names
58:55 - and then we do dot Union to access the
58:57 - method and then we pass in the other set
58:59 - and when we do this we will get a return
59:02 - that has every single unique element in
59:04 - either set so we're combining the two
59:07 - now something like Elmer that's in twice
59:09 - is still only gonna show up one time but
59:12 - anything that's in either of the sets
59:13 - that's unique is gonna make it into this
59:15 - super master list so you might want to
59:17 - use something like Union if you're
59:18 - combining two databases together and you
59:20 - say okay like you've got a big list of
59:22 - names and I've got to be listed names
59:24 - and we know some of them are duplicates
59:25 - so let's push them together using the
59:28 - Union and it will create a list of
59:29 - everything in both lists but not
59:32 - duplicates of an e so we don't end up
59:34 - with two of one name and just to show
59:36 - you we can actually do it the exact
59:37 - opposite way too so peanut because it's
59:40 - also a set is going to have a method
59:42 - Union and then we can pass names into
59:43 - that one and either way we do it we're
59:45 - gonna end up with the same list
59:47 - let's talk intersection so very similar
59:50 - to how unions worked we have methods
59:52 - that allow us to do this and then we
59:53 - simply do names dot intersection access
59:56 - the method and pass in peanut you can
59:58 - remember from high school math do you
60:00 - guys remember what the intersection is
60:01 - gonna do is opposed to the difference
60:03 - only elmer i don't know if you guys
60:06 - expected that you did kudos good good
60:08 - job paying attention in high school but
60:10 - the reason we got that is because the
60:12 - intersection is the only place in both
60:14 - lists where the same element shows up so
60:17 - we have elmer here and we have elmer and
60:19 - you know once again just remembering
60:20 - that the reason why these look similar
60:22 - is because we're using this dot split to
60:24 - break this up if we do the reverse do
60:26 - you think we're gonna get the same thing
60:27 - yep either way you do an intersection
60:30 - it's only gonna bring you the things
60:31 - that overlap specifically so once again
60:34 - if you have a big database and maybe you
60:36 - want to say gosh I wonder what in our
60:38 - database is overlapping like who signed
60:41 - up for your website and has also signed
60:42 - up for mine you could compare email
60:44 - lists or something like that so
60:45 - intersections are powerful now let's
60:47 - talk difference this is a really
60:49 - powerful way to think about sets so
60:51 - we'll make our traditional sets again
60:53 - our peanut and names
60:55 - now what do you thinks gonna be returned
60:57 - when we do peanut difference for the
60:59 - method and then we pass in names is that
61:02 - what you expected cuz I remember this
61:03 - one tripped me up when I was even
61:05 - writing this it took me a second to
61:06 - remember what the difference actually
61:07 - was but just like when you're doing
61:09 - subtraction you have to remember that
61:11 - say three minus five is actually
61:13 - negative two you have to think of the
61:15 - first one is being sort of like the
61:16 - staple to compare the next one to it
61:18 - does matter the order that we put these
61:20 - in so names dot difference in passing
61:23 - and peanut is different than peanut
61:24 - difference passing in names so here the
61:28 - way to think about this is that we have
61:29 - peanut and it's a set with all of these
61:31 - elements my peanut is named and what
61:33 - it's gonna do is it's gonna bring in
61:35 - another set and it's gonna check if
61:37 - anything overlaps and if it does overlap
61:39 - it will be removed so it found Elmer in
61:42 - the second set that was passed in so it
61:43 - removed
61:44 - Elmer from the first set and we ended up
61:46 - with something that was close to my
61:48 - peanut is named and then there's no
61:52 - Elmer in here and Elmer which has been
61:55 - removed again is my name so you can see
61:58 - here we have everything that we had
61:59 - inside of peanut except it's now missing
62:02 - Elmer because that was the one word that
62:03 - was overlapping in the other it's kind
62:05 - of think through the logic you sort of
62:07 - know what's gonna happen here but it
62:08 - might not be instantly recognizable so
62:11 - in this one we're gonna get all of the
62:13 - names - Elmer because Elmer was the only
62:15 - one that was in the peanut that's it
62:17 - tons of use cases for that - if you're
62:19 - trying to say like you know remove all
62:21 - of these things from my database or
62:23 - something along those lines now let's
62:25 - talk about symmetric difference because
62:27 - this is the one that is a little bit
62:28 - more intuitive for me this is the one
62:30 - that just says subtract everything if
62:32 - it's in both lists so we can do names
62:35 - dot symmetric difference peanut or
62:37 - peanut dot symmetric difference names
62:39 - and we end up with the same result we
62:42 - have a list here that just removes
62:44 - anything that's duplicated like Elmer
62:46 - but it does combine everything else so
62:48 - we do end up with names like Guillermo
62:50 - and we do end up with words like peanut
62:52 - that are only in one or the other set
62:54 - and then of course just to prove that it
62:57 - works we'll look at it in the reverse so
62:58 - very cool now we know how to work with
63:01 - set so we can do all of these unions and
63:03 - intersections and differences and tuples
63:05 - and they're immutable states and the
63:07 - difference between lists and
63:08 - all of that so the only thing left for
63:11 - the basic group types is the all-mighty
63:14 - dictionary get ready we're going key
63:17 - value pairs in the next lesson subscribe
63:22 - to the mnemonic Academy YouTube channel
63:24 - for daily uploads that will help you
63:26 - learn amazing concepts through
63:28 - effortless associations welcome in
63:41 - today's left-brain lesson we are gonna
63:44 - be learning the amazing powers of
63:46 - operators in Python so we're gonna start
63:49 - with the traditional arithmetic
63:51 - operators a lot of the ones that you're
63:52 - already familiar with from your math
63:54 - class and from your math tutor and then
63:56 - some gotchas then we're gonna look at
63:58 - the comparison operators which are the
64:00 - Equality ones greater than less than
64:02 - equal then then we're gonna look at the
64:04 - assignment variable is a very important
64:06 - thing that we're actually already
64:07 - familiar with whether we knew it or not
64:09 - next we'll be looking at the identity
64:11 - operators to find out is or is not
64:14 - something what it says it is and taking
64:16 - that a step further afterwards we'll
64:18 - look at the Equality which is similar
64:20 - but a little bit different and you'll
64:21 - see why and then we're gonna talk about
64:23 - membership whether something is in a
64:25 - group or not in a group and then finally
64:28 - we'll look at logical operators let's
64:31 - start by talking about arithmetic
64:33 - operators so pretty basic the ones you
64:36 - learned in math class you'll probably
64:37 - know but let's just review them so
64:39 - blackjack is gonna be set to 21 Jackson
64:42 - to 5 and lottery to 0 so let's do some
64:45 - Q&A
64:46 - what is blackjack plus Jackson correct
64:50 - what is blackjack - Jackson close mm-hmm
64:56 - yep 16 correct
64:58 - what is blackjack divided by Jackson
65:02 - god I don't have to answer these what is
65:05 - Blackjacks
65:05 - times lottery yeah zero because anything
65:08 - times a lottery is zero so losing
65:10 - proposition
65:11 - ooh not defined what are you missing
65:13 - here Jabba black hmm and that would make
65:17 - sense
65:18 - looks like I'm in spell alright that's
65:20 - gonna raise it to the power so
65:21 - everything that uses exponentiation even
65:24 - if it's zero ends up being one because
65:26 - that's how exponentiation works makes
65:27 - sense okay and finally let's talk about
65:30 - why the square root looks so different
65:32 - and that's because we don't have a
65:34 - built-in Python operator for it I mean
65:36 - we do it's part of the library that
65:38 - comes with it the math library but we
65:40 - have to remember it's not quite as easy
65:42 - as just using one of these operators we
65:44 - have to actually bring in the module
65:46 - math and then we have to call the method
65:48 - sq RT and put our variable in there so
65:51 - we can still do it it's not impossible
65:53 - but just know it's a little bit of a
65:54 - different route and I can understand
65:56 - that not everybody had the greatest math
65:58 - teacher so you know maybe sometimes you
66:00 - had to learn a little bit more
66:00 - arithmetic from your tutor so let's go
66:02 - over those and just in case you need a
66:05 - refresher the double wack which is a
66:07 - kind of the urban tech dictionary
66:10 - version for a forward slash a whack it
66:13 - blackjack whack-whack Jackson is no
66:16 - remainder division meaning we will end
66:18 - up with what for did you get that so we
66:23 - have 21 we have five it's gonna go into
66:27 - twenty-one four times evenly and then
66:29 - we're gonna have the remainder of one
66:30 - but we just throw that away
66:31 - okay so double whack division means we
66:34 - throw away the integer now mod losing
66:37 - and it's hard to get your head around
66:38 - but it's kind of like when you ride a
66:40 - bike you never forget
66:41 - once you see it okay so what do you
66:42 - think we're gonna get when we use the
66:44 - modulo operator on the exact same
66:47 - problem blackjack modulo Jackson
66:51 - did you guess one well maybe not but I
66:54 - bet now you have a sense for it right
66:56 - because the five is gonna go into the
66:59 - twenty-one four times with a remainder
67:01 - of 1 so it's like getting the remainder
67:02 - only but just to sink this in a little
67:05 - bit more it's interesting to think about
67:06 - what's gonna happen so let's try it
67:08 - again 10 modulo 1 well we know one's
67:11 - gonna go into 10 10 times and nothing's
67:13 - gonna be left over so maybe we're gonna
67:16 - get a remainder of zero right nothing
67:21 - left but about two that goes into 10
67:23 - evenly also do you think we'll get a yep
67:26 - what about three now we know three is
67:28 - only gonna go into ten three third yeah
67:30 - three times and we're gonna have a
67:31 - remainder of mm-hmm okay five goes in
67:35 - yeah all right I can see it loot end
67:38 - goes into ten just one time they'll
67:39 - remain there maybe zero correct oh and
67:42 - now we're backwards so now we have the
67:44 - bigger number on the right so or the
67:46 - denominator and what do you think
67:48 - happens here because it can't even fit
67:50 - into it one time let alone have a
67:52 - remainder ah I just get stuck at ten
67:56 - interesting what if we go even higher do
67:58 - you think it's always ten no matter what
67:59 - the number is on the other side yep I
68:01 - was there any questions I gave away but
68:04 - now let's look at some gotchas cuz
68:05 - that's where things get tricky all right
68:08 - dividing any two integers will produce a
68:11 - float so we talked about earlier how you
68:13 - want to save memory by using integers
68:15 - when possible and if you're casting them
68:18 - and it's happening automatically it's
68:20 - called coercion so 9 divided by 3.0 an
68:25 - INT and a floating number is going to
68:27 - give you a float but if you actually
68:28 - have two integers and you divide them
68:31 - you still end up with the float so
68:34 - that's another important thing is you
68:35 - can't actually keep integers even if
68:37 - you're doing perfect integer math it
68:40 - just does this by itself so you would
68:42 - want to wrap this in the int function
68:45 - and then it could take the answer and do
68:48 - that for you there's also a zero
68:51 - division error that we need to be really
68:53 - careful about and you know this is
68:55 - definitely broken every one of your
68:56 - calculators in elementary school but we
68:59 - get the same thing and we're gonna get
69:00 - this kind of an error zero division
69:02 - error at least we know what's going on
69:04 - when we see
69:04 - err but you know even pythons not
69:06 - powerful enough to divide by zero' and
69:11 - now let's look at some comparisons three
69:13 - is it less than 10 we're gonna get a
69:16 - boolean value return to true or a false
69:18 - true obviously ok so here we are at the
69:21 - movie theater you've all seen the
69:23 - pricing it's terrible it's two dollar
69:25 - fifty if you want a small popcorn three
69:27 - dollars for a medium or eighteen dollars
69:29 - for a large set some variables and do
69:32 - some single comparisons is small less
69:35 - than large true is small greater than
69:38 - large false is small greater than or
69:42 - equal to large 150 or eighteen noop what
69:47 - about less than or equal to false okay
69:49 - so just look at the syntax there if you
69:52 - want to do blank or equal to use the
69:55 - symbol and then use the equal sign right
69:58 - after it here's one got your warning is
70:01 - it can be really easy to just do that
70:03 - backwards like you put the equal sign
70:04 - first and then use the greater than or
70:06 - less than operator and you will get a
70:09 - syntax error for that so just a little
70:12 - reminder there to make sure to use the
70:14 - greater than or equal in the order that
70:17 - you would say it greater than or equal
70:19 - to blank okay done with that let's look
70:23 - at multiple operators so this is kind of
70:24 - where it becomes powerful sort of more
70:26 - powerful than your regular calculator is
70:28 - you can just start stringing this stuff
70:30 - together and making it more and more
70:31 - complex so we can use the word and and
70:35 - we're gonna learn a little bit more
70:35 - about that later but is small less than
70:38 - medium and is medium less than large
70:42 - that is true as small as the medium and
70:45 - is medium less than large you tell me
70:49 - true is small bigger than medium and is
70:54 - medium less than large all right small
70:59 - is not bigger than medium what about
71:01 - small being less than medium and medium
71:03 - being less than or equal to medium yes
71:07 - small equal to medium well we haven't
71:11 - seen this yet but double you're gonna
71:12 - see this is an equality operator and the
71:15 - double equals is saying is it exactly
71:18 - equal to so remember the regular equal
71:20 - sign that doesn't work that's what gives
71:22 - us an assignment so double equals is
71:26 - saying is small exactly equal to medium
71:28 - and is medium less than large oh okay
71:32 - I think you get the picture now let's
71:35 - look at a little bit of mixed up stuff
71:36 - because we can do some arithmetic
71:39 - operators right in the middle of these
71:41 - comparisons so imagine small plus small
71:43 - plus small that's a dollar fifty times
71:46 - three is that gonna be once it's totaled
71:49 - less than the medium of three dollars
71:52 - and is the medium gonna be less than the
71:55 - large false right because this totaled
71:58 - up to be more than three dollars dollar
72:00 - fifty times three what about when we
72:02 - throw the parentheses around it okay so
72:04 - now we have small plus small and then
72:07 - we're going to multiply it by small then
72:10 - is it going to be less than medium and
72:12 - less than large take a second
72:18 - what about if we do is small less than
72:21 - medium or is small less than large or is
72:25 - a little bit different in the end so we
72:27 - only need one of these develop the true
72:28 - for the whole thing to be true and of
72:31 - course it's true so they go give you a
72:33 - little overview of the way we can use
72:35 - the comparison operators now probably
72:37 - the most powerful one that we've already
72:39 - used a lot next up is the assignment
72:41 - operator we had to learn the basics of
72:44 - the assignment operator early on we
72:47 - needed it just to work with variables
72:48 - the equal sign but there's a lot more to
72:51 - it than what we know and there's also
72:52 - some great shorthand notation and in
72:55 - fact the many things the assignment
72:57 - operator can do also mimic the story of
72:59 - my life so I thought this would be a
73:00 - great time to tell you that story story
73:03 - of my life first I was a fetus it's much
73:08 - weirder to say out loud than it was to
73:09 - write and then after nine months I was
73:12 - born and in fact actually I was born I
73:15 - was 0 because that's more pythonic after
73:17 - 9 months of being a fetus I was born 0
73:20 - and then I had my first birthday after
73:22 - 12 months of being alive that's more
73:24 - like hell Python would do it so that's
73:25 - why I'm gonna do it then after 79 more
73:27 - years I became a grandpa so this new
73:30 - variable Dylan is assigned the old
73:34 - variable plus 79 in the old variable
73:36 - zero so we're gonna have a Dylan that is
73:39 - 79 years old but then I found an
73:43 - expensive lotion and it took me back
73:45 - into my tweens now note the difference
73:47 - on this line because instead of having
73:48 - to sign it to the old variable plus that
73:52 - variable we can just squish the two
73:54 - together in this nice notation and it's
73:56 - the equivalent of subtracting 65 there I
74:00 - am 14 years old again awkward years here
74:03 - I come but then after twice that amount
74:06 - of time the multiplication I found love
74:10 - at 28 identity operators are really
74:15 - powerful and I find them easy to
74:16 - understand in the terms of just simple
74:18 - English okay so we have is right BIP is
74:21 - equal to bippity bop is equal to buddy
74:23 - bop is BIP it's kind of saying like are
74:27 - these the same is BIP equal to Bop boss
74:29 - what about being equal to BIP
74:31 - true and what about if we use the is not
74:34 - so it's just as simple as saying is bit
74:37 - not equal to Bob kind of but in that
74:40 - turn and the syntax of is not nothing
74:43 - the way I said it and you get a false
74:45 - and a true all right well there's cool
74:48 - ways to mix and match this too so we can
74:50 - say you know is three three true what do
74:54 - you think by this one is three three
74:56 - point oh we know there are different
74:57 - types false okay so we know that even if
75:00 - they're the same number if they're not
75:01 - the same type it's not gonna work out
75:02 - what about true is true is that even
75:05 - valid okay I guess that's true what
75:08 - about true is false mmm that's like a
75:11 - conundrum false okay true is false I
75:14 - guess that would be false what false is
75:17 - false could that be true
75:19 - yep it's what false is false so it's
75:24 - true it's true that false is false two
75:27 - wrongs in this sense make a right what
75:30 - about false just period okay boss has
75:34 - remembered it didn't really need to
75:35 - return this you know like if we have
75:38 - returned false because it's actually
75:39 - something that returns a boolean value
75:41 - because it turned out false what about
75:43 - not false yeah Oh true okay so there you
75:47 - go the true is true true is false is
75:50 - wrong false is false that's the same
75:52 - false false not false true alright super
75:57 - super simple right they're easy to
75:58 - understand huh might have to wrap your
76:01 - head around it for a minute but that's
76:02 - how identity operators work
76:05 - let's talk quality everybody we need to
76:08 - be more equal in this world especially
76:10 - you stupid popcorn prices okay so here's
76:13 - what we got something interesting to pay
76:15 - attention to double equals now the weird
76:18 - thing about double equals in programming
76:20 - is that it's not the same as equal it's
76:23 - not an assignment and it's much more
76:25 - like what you would think of as the
76:26 - normal equal sign if you weren't a
76:28 - programmer like what you learned in
76:29 - school like is this equation equal to
76:32 - this other equation that's what we're
76:34 - asking but we use a double equal sign
76:36 - because there's also a way to write it
76:37 - like is not it's kind of a more sharp
76:40 - way to have two of them so we can
76:42 - combine them with the exclamation point
76:43 - so just kind of remember
76:45 - that it's gonna feel a little
76:47 - unintuitive to use double equals for is
76:49 - it equal to and the regular equal to for
76:52 - like become this the assignment operator
76:54 - but just I can show you how it works
76:56 - small we're asking is it equal to large
76:58 - and we're gonna get back a boolean
77:00 - response a false well if we ask is small
77:03 - not equal to large which we know it's
77:05 - not we're gonna get it true and then
77:07 - just a little gotcha here is you don't
77:09 - actually get thrown a warning if you do
77:10 - it backwards but it doesn't work so it
77:12 - can be a place where a bug in your code
77:14 - comes you see it's like yep worked for
77:16 - me but nothing really happened not in
77:18 - this sense in the sense we're trying to
77:20 - use it for this boolean response
77:21 - okay so just make sure you always get it
77:23 - the right way and it's similar to when
77:25 - we used the comparison operators this
77:27 - piece has to go in front of the equal
77:29 - okay
77:30 - and that's equality now let's talk about
77:34 - memberships obviously everybody wants to
77:36 - be a member of a cool-kid group so what
77:39 - if 34 is not in the cool-kid group how
77:43 - do we check well we can just say is 34
77:46 - in and then we have this list here which
77:48 - we'll talk more about in the next video
77:49 - 34 35 or 36 if the answer is yes give me
77:53 - a true yes okay and we can also do with
77:56 - sentences if the word good is in this
77:58 - sentence this is a great example then
78:01 - give me a true but it's not so we get a
78:03 - false how about this what about if good
78:06 - is not in the sentence this is a great
78:08 - example it is not in this so we'll
78:12 - probably get a true they think you can
78:15 - see how it works
78:15 - 34 can also not be in a group which is
78:19 - false because it is in the group so it
78:21 - kind of give you a quick overview of how
78:22 - the membership operator of in or not in
78:26 - works and last but not least our good
78:31 - old Spock logical operator one of my
78:33 - favorites cuz it's right there you know
78:35 - it's just in your face it's just it's
78:37 - not going around the bush it's just boom
78:39 - true or false give me a yes or no answer
78:41 - you know logical operators got things to
78:44 - do places to go so cat equals true dog
78:47 - equals false cat or dog
78:50 - so we're saying here is true or false
78:53 - are either of them true yep cats true so
78:56 - true
78:58 - here we're saying cat and dog are both
79:01 - of them true well we know they're not we
79:02 - know dogs false so probably false and
79:06 - here we can wrap it in a little bit of
79:07 - an if statement something else we're
79:08 - gonna learn about more but this is very
79:10 - cool because it gives us the power to
79:11 - say if true then print high and if false
79:16 - well don't print high which is
79:18 - equivalent of nothing how about if not
79:21 - true might be get a hang of this now but
79:23 - you know if something is not true then
79:25 - it's false so nothing happens if
79:28 - something is not false then it's true so
79:30 - something happens okay so we get the
79:32 - print of high and just to close it out
79:34 - here's a little bit of a way you can
79:36 - imagine putting things together to
79:38 - create some more kind of advanced
79:40 - functionality let's assign a and B both
79:42 - to the variable v and then let's ask
79:44 - this question if a is equal to 5 and if
79:47 - b is equal to 5 then print you know
79:50 - we're both fives and they both are so
79:53 - it's been printed and we can also use it
79:56 - the other way we can say if a is not 5
79:59 - okay which it is so that one's going to
80:01 - come out false or if B is equal to 5 I'm
80:05 - gonna change that right now and we're
80:07 - saying that this one's evaluating to
80:08 - true so either this one or this one
80:10 - evaluates to true this one's false this
80:12 - one's true then give us another print
80:14 - boom one of us is not 5 which is also
80:18 - true subscribe to our new Manik Academy
80:24 - YouTube channel for daily uploads that
80:26 - will help you learn amazing concepts
80:28 - through effortless associations
80:41 - okay in today's in lecture we're gonna
80:43 - be looking at some examples of
80:45 - conditionals so we're gonna look at a
80:47 - canonical example to start with and then
80:49 - we're gonna get an overview of the key
80:51 - words if eltz and l if and then we're
80:53 - gonna look at how they can stack into
80:55 - decision trees we'll look at some ways
80:57 - you can write them out in one line and
80:59 - then when you have more complex logic
81:01 - how you might want to look at nesting
81:03 - them and how those will evaluate and
81:04 - finally we're gonna sort of mix and
81:06 - match these conditionals with things
81:08 - that we've learned before okay we are
81:11 - back now with our trusty jupiter
81:12 - notebook so let's look at a concrete
81:14 - example of a conditional so look at this
81:16 - variable we have taste and it's equal to
81:18 - the string good and we have calories
81:20 - which is becoming the integer 350 now we
81:23 - can use these in almost an english
81:25 - readable sentence you know print the
81:27 - string eat cake if the taste is equal
81:31 - the double equal sign to the string good
81:33 - and the variable calories are less than
81:35 - the integer 300 else print order salad
81:39 - right so can Elsa eat a cookie if she
81:43 - walks up thinks it tastes good and has
81:46 - 350 calories in it nope because that's
81:50 - too many calories for her variable says
81:53 - that it has to be less than 300 so
81:55 - instead of printing eat cheesecake we
81:57 - got order salad okay so let's look at
82:01 - all the different key words that we have
82:03 - and how they might kind of bunch
82:05 - together so if if you remember is
82:08 - represented by Anna
82:10 - now if calories are less than 300 what
82:13 - do you think's gonna happen
82:14 - without anything else specified nothing
82:17 - so we executed the cell and absolutely
82:19 - nothing came out however if it would
82:22 - have if it would have hit the boolean
82:23 - true we would have got an outcome so
82:26 - that's one thing to remember is that
82:27 - nothing else happens by default you have
82:29 - to actually add this else statement
82:31 - which of course is represented by our
82:32 - mnemonic for Elsa and in this case it's
82:35 - not gonna validate up here as true it's
82:38 - gonna come out as false but then it's
82:39 - gonna say if that's false then do this
82:41 - and then of course we can put the third
82:43 - one together which is the elf who's
82:44 - sitting in between the two and if the
82:47 - calories are less than 300 print eat
82:50 - else if
82:51 - kind of in English you'd say if else but
82:53 - calories are exactly equal to 350 print
82:58 - just this one time else print order
83:01 - salad
83:02 - now the cookie is 350 calories so what's
83:05 - gonna happen correct
83:08 - just this time so got away with this one
83:11 - because it's exactly on the dot
83:14 - now let's look at decision trees so that
83:17 - was our mnemonic with our with our kind
83:19 - of dead tree with no leaves on it and we
83:22 - have a couple variables here for Elsa
83:24 - and Anna set to 21 and 17 now we're
83:27 - gonna find out what fun things Anna is
83:30 - old enough to do now if Anna's age is
83:33 - greater than or equal to 21 print she
83:36 - can drink and drive of course but not at
83:39 - the same time very very important you
83:41 - realize it not at the same time else if
83:44 - Ana's age is greater than or equal to 17
83:48 - and on his age is less than or equal to
83:52 - 21 we can print she can drive but not
83:56 - drink so using that and operator we've
83:59 - now specified that we have to be in
84:00 - between seventeen and twenty one has to
84:02 - be inside of that bracket that range and
84:05 - else we can print she's not old enough
84:10 - to do anything fun so on a seventeen why
84:13 - don't you follow the logic through here
84:15 - and see what's gonna happen all right
84:18 - well let's first assign the variables to
84:19 - their respective ages 21 and 17 and she
84:23 - can drive but not drink man that's 17
84:26 - for you it's a sucky time in your life
84:28 - alright let's talk about some simple
84:31 - logic and how we can kind of code these
84:33 - things both in one line or in sort of a
84:36 - more spaced out way now we get Python
84:39 - can handle tons of conditions but how
84:41 - you want to write them is important
84:43 - because you have to give your code other
84:44 - people you have to read it yourself so
84:46 - let's look at a couple one-line examples
84:48 - now to me this logics you know pretty
84:50 - readable print kid if Elsa's age is
84:53 - under 13 else print teenager so what's
84:57 - gonna happen also we just assigned to be
84:59 - in 17 she is a teenager but this one's a
85:03 - little more tricky so we have to if
85:05 - state
85:05 - in Senate print kid if on his age is
85:08 - less than 13 which we know should print
85:10 - else because it's a teenager but then
85:12 - teenager if on his age is less than 18
85:16 - else adult so what do you think is gonna
85:19 - happen first evaluate here and then
85:21 - there or there and then there take a
85:23 - guess
85:25 - teenager hmm okay let's look at this in
85:28 - a more spaced out way so we've talked
85:30 - about it before but Python of course is
85:32 - aware of whitespace this what saves us
85:35 - from all those terrible brackets from
85:36 - other programming languages but the
85:38 - important thing is that they represent a
85:40 - sort of nesting that you can't quite see
85:42 - here as well now if you look at this if
85:45 - Anna's age is less than 18 then if this
85:49 - evaluates true go into the block here
85:51 - but if it evaluates as false just skip
85:54 - that whole block and go down to here and
85:56 - then once you're in here you're gonna
85:58 - then look at the age to see if it's less
86:00 - than 13 to print kid L it's teenager so
86:03 - take a guess is what this code is gonna
86:04 - run before I hit it a teenager again
86:08 - okay so the thing that's important here
86:10 - is that this evaluates in kind of a
86:14 - different order so anna's age is less
86:17 - than 18 is now here on the back end and
86:20 - you can think of this as coming first
86:22 - not as something that comes first in one
86:25 - line but is something that's inside of
86:27 - this thing so the thing at the end is
86:28 - actually the biggest because it's like
86:30 - i'm inside of this thing and you can see
86:33 - that much more clearly down here but
86:35 - over time as you you learn to program
86:38 - you'll see it kind of compressed into
86:39 - one line more because people are
86:40 - starting to save time and kind of type
86:42 - more advanced but at the beginning think
86:44 - of it like this until you've got it kind
86:46 - of in your head how it works now imagine
86:49 - this two-face has captured Batman and he
86:52 - happened to come in I don't know why
86:53 - he's you know at the bake sale or with
86:55 - frozen guys or whatever but here he is
86:58 - and he says to Elsa and the elfin on hey
87:01 - I've got Batman here but there's a
87:03 - chance he could survive because I'm
87:05 - gonna flip this coin and it follows this
87:07 - very special logic if not true print
87:11 - Batman dies else print Batman lives what
87:17 - do you guys think is going to happen
87:18 - when two-face flips the coin Batman
87:22 - lives of course he does he's Batman
87:24 - let's talk about why so if not true it's
87:27 - kind of a weird statement now let's just
87:30 - look at if true hate to do this to you
87:32 - Batman but now you're dead okay so if
87:35 - true is the boolean answer we would have
87:38 - got if Ana's age is less than 18 we
87:42 - would have actually got back from just
87:43 - this chunk of code they're either a true
87:45 - or a false but you can see you can
87:47 - actually skip the processing step and
87:49 - just type it right in
87:50 - so if true do this if false do this and
87:56 - then the kind of the trickiest one and
87:59 - you just sort of got to think about this
88:00 - for a second to make sure you know it if
88:02 - not true you know that's false why not
88:05 - just write false because it's wordy you
88:07 - should but just know if not if not true
88:11 - is the same as false and that's why you
88:12 - end up with Batman living okay last
88:14 - thing let's go look at a few ways we can
88:16 - sort of mix and match these things
88:17 - together so a reminder that we have the
88:20 - taste set to good and the calories to
88:22 - 350 now what's gonna happen here print
88:26 - eat if taste is good and calories are
88:29 - less than 300 else order a salad
88:32 - calories are 350 order salad right all
88:37 - right now how about this what if we what
88:39 - if Elsa says hey you know I know there's
88:42 - 350 calories in there but I'm gonna
88:43 - exercise right after this and that
88:46 - that's gonna burn 200 so now let me see
88:48 - if I can eat this piece of cheesecake
88:52 - and you can see that we're actually
88:53 - doing the math here it's in the
88:55 - parentheses so it should be executing
88:57 - first and then it's gonna go and do the
89:00 - rest of this statement so what do you
89:01 - think we're gonna get yeah she gets to
89:04 - eat the Cheesecake even though it's over
89:05 - calories because she burns some off all
89:08 - right and now finally I want to just
89:10 - talk about what we do when with the
89:11 - operator for memberships is added so now
89:14 - the taste isn't good anymore the taste
89:16 - is awesome but the calories have dropped
89:18 - so it should be edible what's gonna
89:20 - happen here print eat if the taste is in
89:24 - the list with items awesome delightful
89:29 - and delicious and the calories are less
89:32 - than 300 eltz order salad awesome is it
89:38 - in the list yes it is nice so awesome is
89:44 - right there but if it was good
89:47 - that would be no good because then you
89:49 - would have to order salad thanks for
89:51 - watching another video I will see you
89:53 - next time remember be smart be creative
89:56 - and be syntactically observant subscribe
90:01 - to our no Manik Academy YouTube channel
90:03 - for daily uploads that will help you
90:05 - learn amazing concepts through
90:07 - effortless associations
90:12 - [Music]
90:20 - - today's left-brain lesson on Lupe's I
90:24 - mean you know Lupe's
90:26 - sorry that was that was we're gonna
90:29 - start with learning about for loops
90:30 - probably the most common type of loops
90:32 - and then we'll look at a cool thing
90:33 - called a numerate which will use all the
90:35 - time to keep that stuff in order and
90:37 - then we're gonna look over what kind of
90:38 - types inside a Python we can even loop
90:40 - over cuz at first you don't really know
90:42 - strings range list dicks who knows and
90:46 - then we're gonna look at starting and
90:47 - stopping within loops so sometimes you
90:49 - want to break out of a loop something
90:50 - changes you're done with it how do you
90:53 - trigger those kind of things then we're
90:55 - gonna look at a while loop very similar
90:57 - to a for loop but it's gonna work on a
90:58 - different type of conditional and then
91:00 - we're gonna look at nesting so can we
91:02 - have loops inside of loops
91:03 - it's very assembly we call Inception a
91:07 - kind of loop inception and then we're
91:10 - gonna look at a really fun thing yeah
91:13 - this is so fun I'm just gonna show you
91:14 - now we can use a loop to boom make a
91:19 - status bar it's gonna get you know see
91:22 - how far through the process of looping
91:25 - we are which I just think is the coolest
91:27 - thing ever and we can do that by only
91:29 - importing one module so stay with me
91:32 - you're not gonna want to miss this
91:33 - episode of looping the lesson so what do
91:38 - you thinks gonna happen when we take
91:39 - this variable food that's a list and we
91:42 - put it in the syntax for and we just
91:45 - make this word up it doesn't always have
91:46 - to be item it can be the letter I
91:47 - sometimes you'll see it as then like you
91:50 - know who this will be like foods with an
91:54 - S and then this one will be like food
91:58 - without an S something like that first
92:02 - thing we have to run this whole thing
92:03 - again but why not let's just do it foods
92:05 - food oh there goes that's what you get
92:08 - you get pizza pasta salad not you list
92:10 - it out so what we're saying here is for
92:12 - food in foods print whatever this thing
92:16 - is okay and it's a great way to just
92:18 - name things in a way that you understand
92:20 - and to understand that this as long as
92:22 - it's a list or a type that can be looped
92:25 - over that that's all we have to do so
92:28 - what do you think is gonna happen when
92:29 - we add in one more thing called
92:32 - enumerate we're gonna wrap this function
92:35 - around our foods oh man am I gonna have
92:39 - to fix all of these okay around foods
92:44 - what you expected very powerful very
92:47 - important function that we can wrap
92:50 - something that can be looped in is
92:52 - called enumerate and this allows us to
92:54 - create both an index and an item and we
92:58 - can print out the index meaning how many
93:00 - times the loop itself has happened and
93:02 - the item being the place inside of the
93:05 - loop the list or the items that we've
93:08 - passed into it excited about for loops
93:11 - like you know you're thinking about all
93:13 - the cool stuff you could loop over and
93:16 - you're probably thinking but what stuff
93:17 - can I loop over who can tell me that
93:21 - well I can tell you that let's look at
93:24 - different things that are commonly
93:25 - looped over for instance strings might
93:28 - not have thought up but check this out
93:29 - the string hula hoop can just be passed
93:31 - into that same syntax for item in and
93:35 - then the name of the string and we can
93:37 - print out the item hula hoop and it's
93:40 - gonna create something or each character
93:42 - is its own item cuz we talked about it
93:44 - before strings are kind of like lists
93:46 - and behind the scenes now what about
93:48 - this remember the range way have you
93:51 - seen range you haven't seen range it so
93:52 - check this out for I in range of 20 so
93:57 - what we're saying is create a list of 20
94:01 - depends on how deep you went into the
94:02 - concept of types if you saw a range or
94:04 - not but so you know they're basically
94:06 - just like a list I think 1 through 20 of
94:08 - a list and boom there it is you do cool
94:10 - stuff with it okay so what about jumping
94:13 - over a gap okay
94:14 - so don't worry if you haven't seen this
94:16 - thing yet but this is another range
94:18 - which is a list but it's gonna skip
94:21 - every two so actually the reason I like
94:23 - this in particular is that it goes 2 4 6
94:25 - 8 you know 2 4 6 8 pretty cool huh
94:29 - so we know we can loop over strings and
94:32 - ranges and we actually already know we
94:34 - can do lists but just to show you again
94:35 - to keep it in context with everything
94:37 - else we can make a list our bucket list
94:40 - in this case and then we can just print
94:41 - out the things that we still need to do
94:43 - before we die what about dictionaries
94:45 - these are where it starts to get really
94:48 - powerful and a little complicated so
94:51 - stay with me here we created this
94:53 - dictionary called colors and it's got
94:56 - two items
94:58 - dictionary a key and a value as we
95:00 - talked about before and we can loop over
95:02 - it in the same way and the first item
95:05 - that we do is going to always be the key
95:07 - if we only put one kind of argument in
95:09 - between the four and the in then we will
95:13 - get the keys the first part of the
95:16 - dictionary we can also get the values
95:19 - right by putting K comma V in colors and
95:24 - then we use this dot items method at the
95:27 - end okay so a few things to remember
95:30 - here is it doesn't matter what letters
95:32 - were using here like this is not gonna
95:35 - work okay I mean it's it's gonna work in
95:38 - the sense that it's gonna print out both
95:39 - it's not gonna print out just the key
95:42 - and if you're wondering why it didn't
95:44 - just print out the key this time it's
95:46 - because we're using this items we did
95:49 - that we would get just the key all right
95:51 - hopefully that is clear and now you know
95:54 - that we can use dix lists ranges and
95:57 - strings in loops another way to
96:01 - construct a loop is called a while loop
96:04 - and these can be useful in the right
96:06 - situation so it works like this we start
96:08 - with the variable in this case we're
96:09 - gonna make a bunny hop and we're gonna
96:11 - say that we wanted to hop three times
96:13 - and we construct the loop in a way that
96:16 - instead of using four we use well
96:18 - and then while while while hops is
96:23 - greater than or equal to zero then we're
96:25 - gonna print hops and then after we've
96:28 - printed it we're gonna decrement it by
96:29 - one that way it eventually comes to an
96:32 - end so we get three to one hops do the
96:36 - same thing with something like
96:37 - temperature we're gonna say well the
96:39 - temperature is greater than 112 then
96:42 - print the temperature and then decrement
96:45 - it and notice this time we're using the
96:46 - shorthand and we can say oh the T is now
96:50 - cool enough to drink it wasn't when it
96:52 - was 115 but it is now at 112 there's the
96:55 - question can we count up also of course
96:58 - we can if we can decrement we can
97:00 - increment and that can be useful in many
97:02 - cases and we want something to just
97:03 - happen a certain amount of time you know
97:06 - we don't always have to have like this
97:07 - nine kind of hard-coded in either we can
97:09 - say like you know check a database see
97:11 - how many
97:12 - in a classroom we have a number turns
97:14 - out to be 32 and then just put that
97:16 - variable there so then it will count up
97:18 - just as many times as we have you know
97:20 - students in the classroom or something
97:21 - and we don't need to actually construct
97:23 - a for-loop and have that data in exactly
97:25 - the kind of format that Python can loop
97:27 - over so you can see the advantages let's
97:31 - look at breaking out of these loops so
97:33 - there's gonna be times when we don't
97:35 - want the thing to just run X amount of
97:37 - times we want it to check some kind of a
97:40 - condition like should I still be doing
97:42 - this or has the goal of this loop and
97:44 - accomplished it's time to stop so let's
97:46 - start by just placing a conditional
97:48 - inside of a for loop and show you what
97:50 - that looks like alright and don't let
97:51 - this character throw you off I just
97:52 - thought it'd be fun to go get another
97:54 - you know utf-8 icon so you guys would
97:57 - know how how fun Python can be so in
98:00 - this case we're running a range so it's
98:03 - gonna run six times and it's gonna ask
98:07 - if this Captain Picard icon is three
98:11 - print make it so else print not so so
98:17 - this is what we get not so not so not so
98:20 - make it so not so not so pretty cool huh
98:23 - so you can see that it's just running
98:25 - through it and then when it found the
98:26 - one that was equivalent to three because
98:28 - we used our is conditional then it said
98:31 - make it so and it was made so when the
98:34 - Starship Enterprise survived that
98:36 - encounter but here comes another
98:37 - encounter will Captain Picard make it so
98:39 - this time for Captain Picard in range
98:43 - six if Captain Picard is three then
98:46 - print make it so but then we're gonna
98:48 - break out of the loop so we're not gonna
98:50 - get to the rest of them so will he make
98:52 - it so he will but he's not gonna make
98:55 - more not so afterwards so this break
98:58 - kind of as it seems like it would be it
99:00 - just takes the entire loop and stops
99:03 - doing it it breaks out of it
99:04 - okay so we also sometimes might put the
99:07 - break before the print statement so do
99:09 - you think it just breaks Acutes
99:11 - everything in this block of code and
99:12 - then breaks or do you think it's gonna
99:14 - print something underneath the break
99:16 - well let's find out not so okay so we
99:20 - have to remember that when it breaks it
99:21 - really breaks like right on this line
99:23 - it's not just breaking out of the loop
99:25 - this code but it's where it's
99:27 - specifically located so you know that
99:29 - can be another bug in your code at some
99:30 - point you might say like when when I was
99:32 - breaking out did I really complete
99:33 - everything I needed to complete because
99:35 - as soon as it sees that word it's done
99:36 - even if you're already in this block of
99:39 - code being executed is valid all right
99:42 - so enough with breaks enough with
99:43 - conditionals what about continue that's
99:45 - kind of a weird one we're in the you
99:48 - know the Star Trek deck with Captain
99:51 - Picard from the next generation
99:53 - obviously the best version of Star Trek
99:55 - here's how it goes for Captain Picard
99:59 - I just wanted to use a unicode eight so
100:00 - don't let that scare you you use any
100:02 - letters you want or any word you want
100:04 - here but I chose Captain Picard Unicode
100:06 - icons so for Captain Picard in range of
100:10 - six if Captain Picard is three print
100:13 - make it so else mmm also make it so so
100:17 - we make it so is all over the place how
100:19 - many times will Picard make it so yeah
100:23 - six times it's pretty obvious but we're
100:25 - building up to stuff here okay now what
100:28 - if we wrap it in the enumerate now we
100:30 - have an index so we can say how many
100:33 - times this is looped independent of
100:35 - knowing exactly that this is arranged
100:37 - six it's easy for us to see in this
100:38 - example but a lot of times it won't be
100:40 - and when we do this we are gonna have
100:43 - the same thing but now we also have our
100:44 - index to help us keep track of how many
100:46 - make it so is we have so so far Captain
100:49 - Picard's like making it so every
100:51 - direction you know like should we fight
100:53 - the Klingons make it so should we you
100:56 - know do something good for someone make
100:57 - it so he's doing that everywhere but now
101:00 - all of a sudden continue is into the
101:02 - loop so when we get to the third part of
101:05 - the loop the third iteration and Captain
101:07 - Picard becomes a valid true statement
101:10 - because Picard is going to be three
101:12 - we're gonna have to make it so and then
101:14 - continue what do you think is going to
101:16 - happen
101:18 - sike nothing yet Oh even more build-up
101:21 - you say doing more you're building up
101:24 - more and more and it's so intense
101:27 - I don't see why continue did anything
101:28 - because it doesn't do anything according
101:30 - to this example well that's because it
101:33 - was underneath the statement now look
101:35 - what if continue is put in front of
101:37 - print what do you think is gonna happen
101:39 - now one two three make it sews and four
101:45 - no make it so was made so that's because
101:49 - continue isn't just something that
101:51 - applies to this whole block it's
101:53 - specifically that line of code and this
101:55 - can be where bugs come in sometimes in
101:57 - your code because you're like I don't
101:59 - know I executed it it was valid and then
102:01 - I continued but it didn't happen so it's
102:04 - actually something you always want to
102:05 - put you know down here at the bottom
102:08 - like it is in this example so in this
102:11 - example it's saying if this and then
102:13 - continue but there's nothing else to
102:14 - continue down here so we don't see it
102:16 - all right
102:17 - so to make this really clear what's
102:21 - happening is that when it hits continue
102:23 - it's not breaking out of the loop the
102:25 - loop is not stopping but it is going to
102:28 - stop doing anything below it in its
102:31 - specific blocks so this print statement
102:33 - never got a chance to be made so it just
102:36 - went all the way back up here to the
102:37 - loop and then continued but it never
102:39 - missed a beat see we've got the index
102:40 - here to prove that three four five six
102:43 - it just didn't make it to this even
102:46 - though that was valid
102:47 - okay well that's break and continue for
102:51 - you
102:52 - so now let's not take a break and
102:54 - continue on with nesting well welcome
102:59 - fellow birds to our next section on
103:00 - nesting to twerp twerp or tweet-tweet
103:03 - tweet-tweet
103:05 - okay so and get a little crazy in this
103:07 - room but nesting is a very difficult
103:10 - task for a baby bird like you to learn
103:12 - and it's my job as the mom missed
103:14 - actually the dad bird to teach you how
103:17 - to build a nest and I am gonna do it in
103:19 - the only way I know how I'm just gonna
103:22 - throw you into the deep end we're just
103:24 - gonna push you out of the nest and
103:25 - you're either gonna follow the ground
103:27 - and die or you're gonna learn how to
103:29 - nest so
103:31 - we have a variable that's set to an
103:33 - empty list and we're gonna pend a few
103:35 - things to it now from the outer ring
103:37 - we're gonna be appending 1 & 2 and from
103:41 - the inner ring the inner loop here we're
103:44 - gonna be appending 11 and 12
103:47 - so I also put these in order of true and
103:50 - false so you can see that it's this one
103:52 - than this one now there's no real good
103:54 - way to I think explain this I tried a
103:56 - few times in rehearsal but I think best
103:58 - just to print it out and let you guys
104:00 - look at it and let's talk through it
104:02 - best we can but it's one of those things
104:03 - that I would say keep staring at it
104:04 - maybe pause your video kind of thing so
104:07 - if you're ready of course you're not
104:09 - ready you're a baby bird you don't know
104:10 - what I'm doing but no sympathy got to
104:13 - push you out it's for your own good mmm
104:15 - all right you flew good job you're a
104:18 - flying bird now so let's see how you did
104:20 - it all right we have the very first
104:23 - thing that was printed
104:24 - I was appended is the 11 so it obviously
104:28 - read from the first ring first and then
104:30 - it printed our true statement and then
104:33 - it went and got our big stick our first
104:35 - big stick one then it did the next thing
104:38 - and that was print the false version of
104:41 - the same small stick and big stick but
104:44 - here's where it gets interesting so now
104:46 - let move it up to 12 on the inner ring
104:48 - it kept being true and it kept the same
104:52 - position on the second loop it didn't go
104:54 - all the way back it just looped this one
104:57 - once then loop this inner one twice so
104:59 - you can see now it's got a false but
105:01 - we're still on the first iteration of
105:03 - the bigger loop and then once it was
105:05 - done with that it finally went up to the
105:07 - bigger loop and then it ran this
105:09 - appended the 11 and then 11 again and
105:13 - then it went up to the 2nd 12 and then
105:17 - the second 12 okay so I guess point is
105:20 - it's like loop bloop-bloop doo doo doo
105:23 - so it'd be like 1 2 1 1 2 2 like that
105:29 - makes sense kind of tricky but just play
105:32 - with it and get your head around it
105:33 - here's another way with a little bit
105:35 - more nesting so you can see if we had a
105:38 - list that was already pre-made and it
105:40 - has you know single digits double digits
105:42 - and then triple digits if we were to do
105:44 - a four
105:44 - or loop a for loop and then print out
105:47 - everything you can see that it will
105:48 - print and sort of this pyramid order one
105:50 - more thing to get you kind of thinking
105:53 - about how to do it is for I in range of
105:56 - one through ten okay another for loop
105:59 - which is X in range for eleven through
106:01 - twenty this case you're gonna see that
106:03 - it's gonna be pretty long and it's
106:05 - actually gonna print eleven twelve all
106:08 - the way up to nineteen and then BOOM
106:12 - back to eleven twelve all the way to
106:14 - nineteen and then BOOM actual eleven
106:17 - twelve all the way up to nineteen I
106:19 - think you get the picture but guess what
106:23 - all of his work was not in vain
106:26 - whatsoever because we are now going to
106:29 - learn the coolest thing that you can do
106:31 - with a loop ever that is watch your nest
106:35 - get built with a progress bar yeah yeah
106:39 - boop boop we did it loops are done we
106:42 - have completed this lesson yeah
106:51 - subscribe to our mnemonic Academy
106:54 - YouTube channel for daily uploads that
106:56 - will help you learn amazing concepts
106:58 - through effortless associations welcome
107:12 - in today's lesson we will be learning
107:14 - the how of programming by reviewing code
107:17 - examples that demonstrate how to connect
107:19 - we're gonna talk about some of the most
107:21 - common use cases and methods the basics
107:24 - of creating dictionaries how to display
107:27 - the keys and values that are inside of
107:28 - them how to retrieve keys and values
107:30 - sort dictionaries insert new elements
107:33 - and of course remove things that we
107:35 - don't want then we're gonna talk about
107:37 - loops something that we're not gonna
107:39 - cover in detail here but there's some
107:41 - very powerful ways dictionaries can be
107:43 - combined with loops and I want to give
107:45 - you the first overview of what to expect
107:47 - in some of the later videos and how the
107:49 - power of the two can be put together and
107:51 - then finally we're going to talk about
107:53 - default Dix now this is a special
107:55 - package that we can bring in that mimics
107:57 - most of the dictionary functionality but
107:59 - also adds a few more elements that can
108:02 - be useful so get ready for a good time
108:03 - with dictionaries let's start with the
108:07 - dictionary basics creating an empty
108:09 - dictionary now we use the curly brackets
108:12 - which is very similar to sets so let me
108:14 - show you the main difference here is
108:16 - really in how we structure the data
108:18 - that's inside so we use curly brackets
108:21 - for a set and we use in the example of
108:24 - strings here we'll make the first
108:26 - element and then we'll use a comma and
108:27 - then the second element but with
108:29 - dictionaries we have to have a colon
108:32 - between the two instead of the comma so
108:34 - we if we actually wanted to dictionary
108:37 - elements it would need to be two pairs
108:39 - for example something like this that
108:42 - would be the equivalent of two items
108:43 - inside of the dictionary whereas each
108:45 - item has a key and a value so since they
108:49 - both use curly brackets here's my
108:51 - question what type is this variable
108:53 - gonna be a set or a dictionary since we
108:56 - haven't specified anything with our
108:58 - format got your guess in hand it's a
109:01 - dictionary not really sure why but
109:03 - that's just the default that
109:04 - they use so in fact if you actually
109:05 - wanted an empty set you would have to do
109:08 - something like that where you created an
109:10 - empty bracket and then typecast it into
109:13 - the set type the basics are the colon
109:15 - and the comma pattern inside of the
109:18 - brackets next let's look at some ways we
109:20 - can display dictionaries because there's
109:22 - two elements both the key and the value
109:24 - there's a few different ways we can
109:26 - actually display them also so let's
109:29 - start by making a dictionary that we can
109:31 - play around with it's called Hogwarts
109:32 - and it has the names of some of the
109:35 - Harry Potter characters and then after
109:37 - the colon it has the house that they
109:39 - belong to hermione is in Gryffindor and
109:42 - Hannah is at Hufflepuff and course
109:44 - Penelope ravenclaw
109:46 - nobody likes Penelope now just like we
109:49 - print all variables we can simply do
109:51 - Hogwarts to see the entire pair so we
109:54 - can see the key and the value now
109:56 - another way that we can display the key
109:58 - and the value is by using this method
110:00 - called items there's some more
110:02 - functionality with items but nothing
110:03 - that we're gonna worry about now so most
110:05 - importantly if you only want the keys or
110:07 - the values we have separate methods for
110:09 - those so Hogwarts dot keys is gonna
110:12 - return just the three people and then
110:14 - Hogwarts dot values is going to return
110:17 - just the three houses so a few different
110:19 - ways to display those there now let's
110:21 - talk about retrieving elements out of
110:23 - dictionaries this is something that
110:25 - comes up a lot so we're gonna create a
110:27 - new pokemon dictionary here and one of
110:29 - the main methods we can use is this dot
110:31 - git method and the method requires one
110:33 - argument that we must pass and this pass
110:35 - is going to be the key for the value
110:38 - that we want returned so we have to pass
110:40 - in either a string or a number that
110:42 - matches one of the keys here so you can
110:45 - see we have our Bock in here we have our
110:46 - buck right there so we would expect it
110:48 - to return the value like in a real life
110:50 - dictionary this would be like looking up
110:52 - the word here and then getting the
110:53 - definition back when we run this we will
110:55 - get 14 now it doesn't work the other way
110:57 - we can't put in the value and then get
111:00 - back the key it doesn't work that way
111:01 - now there's also a shorthand without
111:03 - using the method get we can use our
111:05 - slicing if you remember earlier we had
111:07 - the two brackets and they were put right
111:09 - up against the variable here and we can
111:11 - do the very same thing so we need to
111:13 - pass in the key which we have right here
111:15 - and it will return the match
111:17 - value 89 you can see that we have 14 or
111:20 - 89 so now let's look at a second
111:23 - argument that the get method can
111:25 - actually take and that is a return value
111:28 - if nothing is found so in this case
111:30 - we're gonna look for Jericho odor kakou
111:33 - yeah that's right kind of like Pikachu
111:36 - but a jerk version in this argument
111:39 - we're saying look through my dictionary
111:40 - and if you find Jirka Chu then return it
111:44 - and if not return
111:45 - Pokemon not found so in this case we
111:48 - know that Jirka Chu is not Ivysaur or
111:50 - Pikachu AER Bach or Jigglypuff so when
111:54 - we run it we will get Pokemon not found
111:57 - so now let's talk about sorting a
112:00 - dictionary because inherently
112:01 - dictionaries are not stored in a
112:03 - sequential order like a list but there
112:05 - are functions that we can wrap around
112:06 - them to get some of the functionality
112:08 - that we need so let's go ahead and
112:09 - create a new Hogwarts dictionary with
112:11 - some of the characters and the houses
112:13 - that they're from and then let's sort
112:15 - them so first we know the items is going
112:17 - to return both the key and the value so
112:20 - when we sort these we get everything
112:22 - returned and sorted by the key it uses
112:25 - the key first so we have H a and then H
112:27 - E and then the letter P and then we can
112:30 - also specifically say sort it by the
112:32 - keys and only return the keys and then
112:35 - we'll have the same thing but we won't
112:36 - have the values returned also and of
112:38 - course we have the dot values method and
112:40 - we can run that before using the sorted
112:42 - function and get a similar result but
112:44 - this time sorted on values so you can
112:47 - see that can be a great way to actually
112:48 - sort out your dictionaries when the need
112:50 - arises
112:51 - now let's talk about inserting new items
112:53 - into a dictionary new key value pairs
112:56 - let's start with our pokemon dictionary
112:59 - here we have our pokemon and the level
113:02 - that they're at Ivysaur is at 89 and
113:04 - pikachu is at 11 and arbok is at 14 and
113:07 - then Jigglypuff is over there at 51 so
113:10 - now I want to add two new Pokemon my
113:12 - first one is Professor X and he is at
113:15 - level 34 and my second one is the Joker
113:17 - now we specify the new item in the same
113:20 - way we would slice out one of the values
113:23 - based on key except we add a new one so
113:25 - professor X does not exist in the
113:27 - dictionary at all right now this would
113:28 - normally cause a key value error
113:31 - except we have an assignment variable
113:33 - here and we're also giving it a value
113:35 - when we run these you can see that both
113:37 - the Joker and the professor X have been
113:40 - added to our poke dictionary right and
113:43 - there we go now Joker and professor X
113:45 - have both been added as keys and values
113:48 - so our dictionary is growing now let's
113:52 - talk about what we do in our dictionary
113:53 - gets too big and we need to remove
113:55 - something removing key value pairs from
113:57 - dictionaries can be pretty easy so let's
113:59 - go ahead and make another dictionary
114:00 - with poke just to remind ourselves what
114:02 - we have and reset it and then we simply
114:04 - use the de el keyword and the same way
114:07 - we would slice an item out hoping to get
114:10 - a return value we just put del the
114:12 - keyword before it and then all of a
114:14 - sudden poke Jigglypuff is gone and we
114:18 - just have our bok I have a soar and
114:20 - Pikachu another way that we can actually
114:22 - clear an entire dictionary is by using a
114:25 - method that all dictionaries have called
114:27 - clear and when we do this we end up with
114:30 - a dictionary of nothing and that is
114:33 - removing items from a dictionary well we
114:36 - have an understanding of the basic ways
114:38 - we can work with the dictionary I want
114:40 - to talk about what we can do when we
114:42 - combine them with the powers of loops
114:43 - now loops are an entire lesson that
114:46 - we're gonna talk about in the section on
114:48 - recursion so I don't want you to look at
114:50 - this and think it's stuff that you
114:51 - should know but maybe take a more
114:53 - relaxed attitude towards this loop
114:55 - section just see some of the things that
114:57 - we can actually do with the dictionary
114:59 - when it comes to nesting and looping
115:01 - just to go kind of quickly over this the
115:03 - same way we had the Hogwarts keys and we
115:06 - could display the keys out we can
115:08 - actually specify something called for
115:10 - and say for I in Hogwarts key and this
115:13 - is saying for the index or whatever
115:15 - character string we want to put here for
115:17 - I or whatever variable we choose to put
115:20 - here for I in Hogwarts keys and we can
115:22 - actually print the keys so we can just
115:25 - print the keys out now we also can do
115:27 - the same with values and then this
115:29 - variable I will become not the keys but
115:32 - the values and we can also specify both
115:35 - a key and value so remember these are
115:37 - just variables we can choose them to be
115:38 - anything we want and here we can
115:41 - actually combine the two together for a
115:42 - custom combination
115:44 - that way we can actually have a couple
115:46 - variables here they can be used together
115:47 - in all sorts of combinations using the
115:50 - dot keys the dot values and the dot
115:52 - items now like I said you don't really
115:53 - need to know this right now but the
115:55 - reason I put them here is because I
115:56 - think someday you might want to come
115:58 - back to these videos and this seems like
116:00 - the most logical section to keep some of
116:01 - this stuff so just like we were sorting
116:03 - things before by printing them out with
116:05 - the keys and values and then wrapping
116:06 - him in the sort function we can also do
116:08 - that with loops a little bit more
116:10 - complicated but sometimes there can be
116:11 - more places where we can add new logic
116:13 - so there can be reasons for it but just
116:16 - so you see it's the same thing we're
116:17 - organizing by keys but here we're using
116:19 - some different logic to organize it but
116:21 - just another way to do it just for your
116:22 - reference for later so now something you
116:24 - should pay attention to again the
116:26 - default dictionary I want to talk about
116:29 - the default dict it's a different type
116:31 - that we can bring in using a package and
116:33 - the reason why it can be so powerful is
116:36 - because it allows us to specify some
116:38 - logic saying if you get a key and you're
116:41 - not past a value instead of throwing an
116:43 - error just use this as a default and
116:46 - this makes it really powerful for
116:47 - quickly appending items into it that
116:49 - aren't completely validated ahead of
116:51 - time so I'll show you with an example
116:53 - here so we're gonna create a dictionary
116:55 - and this is just a blank dictionary has
116:57 - nothing in it and then I'm gonna slice
116:59 - to the third value now there is no third
117:01 - value so we are gonna get a key error
117:03 - however in some situations maybe instead
117:06 - of throwing back an error saying this
117:07 - doesn't exist we want it to
117:09 - automatically make something and
117:11 - something the same for all of the keys
117:13 - that are passed in without values that
117:15 - is where the default dict comes into
117:17 - play so from collections we have to
117:19 - import default dict first just like we
117:21 - do with a lot of our packages and then
117:23 - we have to actually create a type an
117:25 - object that is a default dict type and
117:28 - the most important parameter here is
117:30 - this where we say int so what we're
117:33 - saying is in this special dictionary if
117:36 - somebody calls a key that's not there
117:38 - automatically using integer as the value
117:42 - pair for example now in some dict
117:45 - it's also blank so this new dictionary
117:47 - we have some dict it is blank and when
117:50 - we call the third value we would get a
117:53 - key error if it was a regular dictionary
117:55 - but in this situation we get
117:57 - no matter what number we put in here
118:00 - it's gonna automatically put an integer
118:02 - now that's really cool because then
118:04 - maybe we want to do some kind of math
118:05 - maybe you want to build some kind of it
118:07 - you know giant dictionary that has zeros
118:10 - for all the values that aren't filled in
118:11 - but the numbers in other parts or we can
118:14 - even put in other types so here we can
118:16 - try putting a string in and when we run
118:19 - it we are gonna get a blank string in
118:21 - return so now the dictionary actually
118:23 - has a key of four with a string value
118:26 - after it and you'll see in our
118:28 - applications play video there's some
118:30 - really cool ways to make hierarchical
118:32 - trees or api's and some things some some
118:35 - kind of more complicated things but it's
118:37 - nice to not get an error thrown back at
118:39 - you but just have some kind of a default
118:41 - parameter that the dictionary knows that
118:42 - it should have if it gets incomplete
118:45 - information so that's it you are now up
118:47 - on dictionaries thanks for
118:49 - around with me subscribe to the mnemonic
118:54 - Academy YouTube channel for daily
118:56 - uploads that will help you learn amazing
118:58 - concepts through effortless associations
119:11 - scopes an important concept so we're
119:14 - gonna start by looking at some basic
119:15 - examples of what we mean where variables
119:17 - can be where they can't be then we're
119:19 - gonna look at some more specific
119:20 - categories like locals and Global's and
119:23 - the system Global's and then how we can
119:25 - make our own Global's and what global
119:26 - even means then we're gonna talk about
119:28 - namespaces I think of these as big long
119:31 - lists of variables we have access to so
119:33 - we're gonna talk about how you can
119:35 - actually find out what these are how can
119:37 - you output the variables that you have
119:39 - in your namespace and then also talk
119:40 - about the order that your code is
119:42 - actually written in it's another
119:43 - important thing that decides what you
119:45 - have access to at what time so at
119:47 - certain states you don't have the same
119:48 - namespace as you do at other states as
119:50 - you write code and move your way down a
119:52 - page there's changes in the namespace
119:54 - along the way that you have to take
119:55 - account for and then finally we're gonna
119:56 - talk about privacy now this relates to
119:58 - classes so it's a little bit premature
120:00 - for what we're talking about but I want
120:02 - to start implanting the idea that
120:04 - there's also what you could think of as
120:05 - a system of permissions so let's talk
120:08 - scope
120:09 - Cope's an important concept because it's
120:11 - really about what's in the area I almost
120:13 - think of it in real life like something
120:15 - that would be geo-fenced in or different
120:17 - rooms inside of it building something
120:18 - like that so for the example I tried to
120:21 - make it kind of in the same way and I
120:22 - want you to first imagine a kitchen now
120:25 - say you had one pie that was sitting on
120:26 - the counter and we're gonna call that
120:27 - pie global rhubarb and then inside the
120:30 - fridge there's another pie from the
120:32 - night before and that's called local
120:34 - apple now you can really think of the
120:35 - two pies in a real world sense as being
120:38 - separated by the fridge let's say that
120:40 - one area is the kitchen counter and one
120:42 - area is inside of the refrigerator and
120:45 - they are separated by that fridge door
120:47 - someone would need to open the door and
120:49 - actually put one of the pies in or take
120:51 - one of the pies out if you wanted to get
120:52 - past that boundary so the concept of
120:54 - scope is like asking what pies are here
120:56 - on the counter right now and then what
120:58 - pies are in the fridge but we can only
121:00 - but we can think of those as separate
121:02 - namespaces we have a variable called
121:05 - pipe and we also have a variable called
121:07 - pie so if these were written right next
121:09 - to each other we know that one would
121:12 - override the other when the next line
121:14 - came we know first this variable would
121:15 - be assigned this string and then later
121:17 - would be overwritten and then assign
121:19 - this string next but because it's inside
121:22 - of this refrigerator function it's
121:24 - protected until it's called that's not
121:26 - gonna do anything so just take a second
121:29 - to think about what's going on here
121:30 - pie is defined and pie is about to be
121:33 - redefined in here so if this function
121:36 - changes it then pie is gonna be Apple
121:39 - underneath but if it doesn't change it
121:41 - it's gonna be global rhubarb underneath
121:43 - okay so let's run this in a second but
121:44 - let's type global and local scope so the
121:46 - way I touched before about the fridge
121:48 - being its own area that would be a local
121:51 - scope of the fridge and the counter
121:52 - would be the local scope of the counter
121:54 - but when you say something's at global
121:56 - what you're saying is it can be
121:57 - everywhere whether I'm in the fridge or
121:59 - on the counter I have access to some
122:01 - super pie like some lemon a lemon
122:03 - meringue pie let's make it that's
122:05 - floating near the ceiling and it's just
122:07 - everywhere it just follows me around so
122:09 - when I'm in the kitchen it's there and
122:10 - this like floating kind like I think of
122:12 - a kind like a drone like a floating
122:13 - lemon meringue pie that's on a you know
122:15 - drone that flies around with me and
122:17 - whether I'm at the fridge or I'm at the
122:18 - counter that lemon meringue pie is
122:20 - always within scooping distance of my
122:22 - spoon
122:23 - let's look at an example of what I mean
122:24 - and now when we print out baked what do
122:26 - you think is gonna happen because this
122:27 - is returning the local scope of pie okay
122:30 - we get local apple seems reasonably to
122:31 - find this thing inside even though pie
122:34 - was defined before it overrode it and
122:36 - then it returned it into our bake
122:38 - variable here and then when I go to look
122:40 - at pie do you think that's been
122:41 - overridden because it was overwritten
122:43 - inside when we executed this function no
122:45 - global rhubarb so it stayed on the
122:48 - outside it's almost like it was like
122:49 - this lemon meringue pie was floating out
122:51 - here but then when I was looking inside
122:53 - of the fridge I like pulled it in and
122:55 - then replaced it with an apple pie and
122:57 - then ate the apple pie but it was a
122:59 - clone like the other ones still floating
123:01 - up there still remembering it's a
123:02 - meringue pie and it's gonna follow me to
123:04 - the next place man I sometimes I blow my
123:08 - own mind with how good I am metaphors
123:09 - now let's look at system Global's maybe
123:11 - another way to think about this would be
123:13 - reserved keywords but these are the
123:15 - ultra global namespaces these are like
123:17 - just by entering the house whether
123:19 - you're in the kitchen or you have your
123:21 - drone meringue pie next to you or any of
123:24 - that stuff you can't change it so TR UE
123:27 - I can never make this a variable I can
123:29 - never change it in any way I will just
123:31 - get errors when I try to do something
123:33 - like that so whenever we take a system
123:35 - global like true and we put it into a
123:37 - variable we do make a copy of it but we
123:40 - can never actually change true it could
123:42 - never go the other way
123:43 - regular Global's are usually defined
123:45 - with capitals now it's important to
123:47 - remember that when we write a variable
123:49 - in all caps what we're signaling to
123:51 - other programmers is that this is a
123:53 - global that you should set the parameter
123:55 - on or that we really don't want you to
123:57 - mess with it doesn't mean that they
123:58 - can't it doesn't make it immutable it's
124:00 - just still a regular variable but there
124:03 - usually is something specific that the
124:05 - programmers trying to bring your eye to
124:06 - trying to bring attention to we've
124:08 - assigned at the variable pink this car
124:09 - color and now we're gonna try to change
124:11 - it with a function so we have a new car
124:13 - color which is the exact same variable
124:15 - what color is inside blue and pink just
124:19 - like we did before it's exactly what we
124:21 - expected this new color took its cue
124:23 - from the inside of the function but now
124:25 - let's look at it again and this time
124:27 - let's use this key word global so now
124:30 - imagine that we take the exact same code
124:33 - where we're assigning a car color pink
124:35 - on the outside of the function
124:36 - and then inside were making a car color
124:39 - blue and then we're returning that car
124:40 - color but we're adding the global
124:43 - keyword to car color first what we're
124:45 - saying is hey this thing is now global
124:47 - now global meaning break the heck out of
124:50 - this fridge I know you were in apple-pie
124:52 - that was inside the refrigerator but now
124:54 - I've strapped you to it drone so you can
124:55 - follow me around and you can get out of
124:57 - here too so what do you think is gonna
124:58 - happen when we try to change this one
125:00 - well first off we get this syntax
125:03 - warning now I was playing with this
125:05 - before recording and I'm gonna leave
125:07 - this syntax warning here I do think this
125:09 - is a this is not really how you would
125:12 - write a normal function that you were
125:13 - using globulin but for our example I'm
125:15 - trying to show the overwriting I'm gonna
125:17 - leave it that way
125:17 - so what's gonna happen when we run this
125:19 - okay blue that makes sense it took its
125:22 - cue from the inside car color overrode
125:25 - it then we made it a global and then we
125:27 - returned it but here's the powerful part
125:29 - because car color here was defined as a
125:31 - global even though it was returned
125:33 - inside of this variable it also is able
125:36 - to break out and override pink up here
125:39 - which was defined inside here which
125:41 - should be confined to the inside of this
125:43 - refrigerator rhubarb is now Apple people
125:46 - the world is upside down global gave it
125:49 - so much power that it broke out of the
125:51 - refrigerator by itself and put itself on
125:53 - the counter and replace the pie on the
125:55 - counter so now we have an apple pie
125:57 - inside and outside pretty wild so you
126:01 - can see why this global keyword can be a
126:02 - powerful thing it can allow us to define
126:04 - something in a local space that can
126:06 - break out of that local space so now
126:09 - let's talk about namespaces now the way
126:11 - we were talking before about the pie
126:13 - being on the counter or in the fridge
126:14 - that was something where you would look
126:16 - around and just see which pies are there
126:18 - but when we're talking about programming
126:21 - we don't have a physical world a counter
126:23 - that we can look at so namespaces are
126:25 - the equivalent so imagine we're in the
126:27 - living room watching the football game
126:28 - and we ask our you know wife or husband
126:31 - or girlfriend or whatever honey I am
126:33 - curious what pies are in the
126:36 - refrigerator and what pies are on the
126:38 - counter right now so she comes back with
126:40 - a list she says okay on this post-it
126:43 - note I've listed all of the pies that
126:45 - are on the counter and then on this
126:47 - post-it note I've listed all of the pies
126:49 - that are in the refrigerator and then
126:50 - you
126:50 - go get on the counter there zepa land
126:53 - pineapple and cheesecake and then in the
126:56 - fridge there's you know apple and and
126:58 - others so the namespaces are those
127:01 - post-it notes with all of the lists on
127:04 - it because we don't actually have that
127:05 - physical space we can look at that
127:07 - so how do we output one of these lists
127:09 - so first off I just want to import this
127:11 - module P print it stands for pretty
127:14 - print and it has nothing to do with name
127:16 - spaces or scopes but when you print out
127:18 - a dictionary it does a nice job of
127:20 - indenting them when you print it out to
127:22 - console so it's just an aesthetic thing
127:24 - and this function would work just fine
127:26 - without just to prove it to you I'll
127:28 - show but it's a little bit ugly for an
127:29 - output so when we wrap it in this nice
127:31 - function P print then we get it in a
127:34 - more indented way with this nice
127:36 - scroller so that's the only reason we
127:37 - have that there don't get confused on
127:39 - that anyways but here in our local you
127:41 - can see that we have the variable car
127:43 - color and its value right now we can
127:45 - think of these as key values or give
127:47 - these as variables in their current
127:49 - state B this is the container and inside
127:51 - of it is the color blue it's weird or
127:53 - inside of this cucumber there is the
127:55 - value of truth you know that's the thing
127:57 - and that's the thing about the core of a
127:58 - cucumber is that they are true they're
128:00 - they are true blues actually cucumbers
128:02 - are true blue inside these are the
128:04 - variables we have access to so now
128:06 - remember inside of our fridge our local
128:08 - space is defined much more narrowly out
128:11 - here when we're just running it it's
128:13 - saying alright my local space is pretty
128:15 - much my global space I'm not inside any
128:17 - containers if we're both you know we're
128:19 - both in a house that has no
128:20 - refrigerators and all the pies are out
128:22 - in the main area then the global and
128:24 - local space will be the same but you can
128:25 - see once I put the local function inside
128:28 - of my own function pie is being assigned
128:30 - to the string pecan then you see when I
128:33 - run this fridge function there's only
128:35 - one thing that comes up just this pie in
128:38 - fact if I get rid of that there's
128:39 - nothing just an empty dictionary that
128:41 - has no variables it's a refrigerator
128:42 - with no pies inside of it which is
128:45 - really sad thing but no matter where we
128:47 - are inside or outside if we use Global's
128:50 - we get every variable that's available
128:52 - to us anywhere so here's global ran by
128:54 - itself and now you can see even if we
128:56 - call our global function from inside of
128:59 - our refrigerator we will get everything
129:03 - it's a good way to put that is a
129:05 - the apple pie that's in the refrigerator
129:07 - is not something the guests know about
129:09 - until they open the fridge so basically
129:11 - inside of the fridge we have access to
129:13 - the Global's what the Global's don't go
129:15 - the other way and have access back and
129:16 - that Python has built in these global
129:18 - and local functions that you can use
129:20 - code there are some amazing magics we
129:23 - can use for example percent who is gonna
129:26 - show you all of your global variables so
129:29 - you can see that a warm pie showed up
129:30 - and our pie from before an even P print
129:33 - it is in the namespace cuz it's in its
129:34 - own object its own name and then
129:36 - cucumber from before and car color so
129:38 - you can see this is the way in reality
129:39 - to do it is just open up a new cell and
129:42 - put percent now that we know about these
129:43 - powerful magicks for clearing out our
129:45 - namespaces i want to show you in a real
129:47 - world application why you would want to
129:50 - think about using these and how going
129:52 - down the page in a linear order from top
129:55 - to bottom and left to right is actually
129:57 - something that does come off you need to
129:59 - really think about what's happened
130:00 - before and after certain points to reset
130:03 - so yes we'd like to reset everything so
130:05 - looking at it we know that our namespace
130:08 - is empty there is no variables that have
130:11 - been defined no names that have been
130:12 - defined so if I want to find out what
130:14 - the cosine of 90 is and I haven't
130:16 - brought in the math package or module
130:18 - two you can see that nothing is gonna
130:21 - run make sense right we haven't defined
130:22 - what math is and that makes sense
130:24 - because the namespace is empty but after
130:27 - we do import it so now I've imported it
130:29 - let's look at our namespace so we have
130:31 - brought in math and the only thing that
130:32 - we're seeing in our namespace is math so
130:35 - now that I have access to math I know
130:37 - that I can do math dot cosine and we
130:39 - gonna sign it to our variable which
130:41 - should be a second name and now you'll
130:42 - see that we have both and also whenever
130:44 - we see something here in namespace it's
130:46 - also a trigger that we can probably find
130:48 - some methods so if we do math dot and
130:51 - then tab remember in Jupiter it shows us
130:53 - all the things we can do with it or if
130:55 - we went over here to even our variable
130:57 - that we made and did the same thing we
130:59 - can actually see why the point would be
131:01 - like you try to run something you don't
131:02 - see it you check the namespace using
131:04 - this percent whoo and Jupiter it shows
131:06 - you what you have access to a names you
131:08 - have access to and then that kind of
131:09 - starts getting you thinking about how
131:10 - these tools can work together it's like
131:12 - they get o if you're like a mechanic and
131:13 - you're like working on a car and you
131:14 - like scan around to see like what's
131:16 - close to me screwdriver a wrench maybe I
131:18 - can use one of these
131:18 - so it's just about scanning the area for
131:20 - what's available only let's talk privacy
131:24 - now if you are going through this course
131:26 - in the passes like we talked about
131:28 - earlier you probably have seen classes
131:30 - but if you're just sort of following
131:31 - these in a linear order you probably
131:33 - haven't classes are gonna be an
131:34 - important thing that we learn later but
131:36 - for now you can think of them as
131:37 - souped-up functions and it's really the
131:39 - only place you're gonna find variables
131:41 - that have different permissions like
131:43 - privacy on them but let's go ahead and
131:46 - just get our head around them because we
131:47 - are talking about scope right now and
131:49 - the scope of a variable or name is going
131:51 - to be where it's located like on the
131:53 - counter or in the fridge
131:54 - we're now saying is that like if you
131:57 - look inside the fridge and you see an
131:58 - apple pie
131:59 - you're like sweet I have access to it
132:01 - it's in my name space but then you go to
132:03 - pick it up and there's a little note on
132:04 - it that says like this is Beth's pie
132:08 - don't eat it or you're dead and you're
132:10 - like ding so even though I can see it
132:11 - and I have access to the pie I'm in my
132:14 - you know office refrigerator or whatever
132:15 - and it's actually somebody else's and I
132:17 - can't eat it or they're gonna be mad at
132:19 - me so that's what this is about this is
132:21 - about taking a name and saying hey don't
132:23 - mess with it because it's got some other
132:25 - use so if you see a name that has a
132:27 - single underscore like this one
132:29 - underscore Sherlock Holmes then you know
132:32 - that it's probably supposed to stay
132:34 - private and just like in the office you
132:36 - like could eat somebody else's pie that
132:39 - they left in the fridge you really
132:40 - shouldn't and that's exactly how an
132:42 - underscore should be thought of is that
132:43 - somebody made it another programmer
132:46 - wrote it and said hey don't touch this
132:48 - this is private it's mine I don't want
132:50 - to messed with for whatever reason
132:51 - although you could it's not really
132:52 - locked off or do anything it's just it's
132:54 - sort of like suggested like hey like
132:56 - we're all in an office here I'm writing
132:57 - code you're writing code don't mess with
133:00 - it because I put an underscore there I
133:02 - want it to stay private and then double
133:04 - underscore private is a little bit
133:05 - different so this is especially when
133:07 - we're dealing with a class something
133:09 - you're gonna see that is important when
133:11 - there is a double underscore or a dunder
133:13 - as it's sometimes called then you're
133:15 - referring to something called name
133:17 - mangling and you really can't mess with
133:20 - this pie like this is the kind of pie
133:22 - that if you eat it the fridge might not
133:23 - even work anymore and you're gonna break
133:24 - the whole refrigerator don't if you see
133:27 - a double underscore change it because
133:28 - what's happening is Python is actually
133:31 - looking for these
133:32 - underscores and then it's changing it in
133:35 - classes so it has the class name in
133:37 - front of it it's almost like an
133:39 - important utility function that when
133:40 - you're using classes which are like
133:42 - blueprints for objects when it's making
133:44 - the objects it's gonna need to see that
133:46 - that's a private variable or a private
133:48 - function so that it can override it so
133:50 - might not make tons of sense if you
133:52 - haven't learned about classes yet but
133:54 - the important thing is just to remember
133:55 - that anytime you see this double
133:57 - underscore think to yourself oh that
133:59 - should probably be behind the scenes or
134:01 - hidden or I shouldn't be messing with it
134:03 - that's like going to Disneyland and
134:05 - looking like over the gate like that's
134:06 - not for the guests you know that's the
134:08 - double underscore and this one's like
134:10 - hey don't mess with me like I got my
134:12 - headphones in you know I know you could
134:14 - like if you need to like make eye
134:16 - contact and I'll take my earphones out
134:17 - but really just I'm trying to work right
134:19 - now alright so you learned a ton today
134:21 - we're getting pretty pretty advanced
134:23 - here you guys are really starting to
134:24 - learn a lot about programming so I will
134:26 - see you in the next lesson subscribe to
134:30 - the mnemonic Academy YouTube channel for
134:32 - daily uploads that will help you learn
134:34 - amazing concepts through effortless
134:36 - associations are you ready to get funky
134:51 - with functions well I hope so because
134:55 - today we are gonna be talking about
134:58 - functions in a nutshell we're gonna
135:00 - learn the basics the syntax of how they
135:02 - look the keywords that we use what they
135:04 - can do then we're gonna talk about very
135:06 - important concept related to functions
135:09 - which is calling the function how do you
135:11 - tell it to execute that code how do you
135:13 - pass in variables how do you get things
135:16 - back out of it that's gonna all be
135:17 - covered in the calling section and then
135:20 - our final topic is gonna be parameters
135:23 - because there are stipulations that you
135:25 - can specify and some that are specified
135:28 - by Python is itself for what can go into
135:31 - a function and what can come out and how
135:34 - that looks so we're gonna learn about
135:35 - some of the styling that you can use
135:37 - when you're telling somebody else how to
135:39 - put a function in we're gonna talk about
135:41 - something called star args which allows
135:44 - us to do lists
135:45 - and then we're gonna use something
135:46 - called star star quarks so get ready to
135:49 - find out what all these funky words are
135:51 - about in this lesson functions funky
135:55 - functions I mean let's go to Funkytown
136:01 - man I wish I could afford that song you
136:04 - know the rights to use it even know what
136:06 - song that is is how bad I sing who knows
136:08 - but listen today we are here to learn
136:11 - about functions so why do you think that
136:13 - a gas pump is what I chose for our
136:15 - mnemonic you put X amount of dollars in
136:18 - and you can mathematically calculate
136:21 - what amount of gallons you're gonna get
136:23 - out so I'd like to think of functions as
136:25 - ratios even though obviously they can
136:27 - have all sorts of logic they don't have
136:28 - anything to do with ratios at the end of
136:30 - the day but just to keep it in your head
136:32 - to start with think all right every $1
136:35 - that I put into this gas pump I am gonna
136:37 - get one half of a gallon out so if I put
136:40 - in $2 I get one gallon of gas and we
136:43 - want to model that using a function we
136:45 - would do a syntax that started with D
136:47 - ef4 define or defining a function short
136:52 - and then we would give it a name using
136:54 - our normal naming conventions we don't
136:56 - do camelcase we could but we just
136:58 - conventionally don't and we can't use
137:00 - dashes or the number one or a number
137:02 - here at the beginning so we have gas
137:04 - pump this looks good and then we have an
137:06 - open and closed parenthesis colon okay
137:08 - this is just the syntax to get used to
137:10 - and in here is where we're passing our
137:13 - variable now this dollars can be
137:16 - anything it's whatever variable we
137:17 - choose to make it it can be that Captain
137:19 - Picard
137:21 - utf-8 icon I used before it can be
137:24 - anything the Python understands as long
137:26 - as we use it as a symbol to remember
137:28 - what we're using it for inside so name
137:30 - this something that makes sense to what
137:32 - you're doing in here think of everything
137:33 - in here as something that's enclosed
137:35 - kind of in Tupperware different then our
137:39 - variable because that just holds a state
137:41 - but an entire working machine like a
137:44 - toaster think of a toaster with all of
137:46 - its little components and they're all in
137:48 - here those components only interact
137:50 - inside the shell of the toaster and here
137:52 - we take whatever is passed in it could
137:54 - be $5 it could be $50 depends on how
137:57 - much guess you need for your car
137:59 - and then it's going to multiply it by
138:00 - 1/2 by 0.5 and it's gonna create a new
138:03 - variable gallons
138:04 - now this gallons variable is stuck
138:06 - inside of the function there's no way to
138:08 - get it out unless we explicitly ask for
138:11 - it using this keyword return so we'll
138:14 - talk about that in a second but let's
138:15 - just look at an example here this is my
138:17 - function for a gas pump it's gonna give
138:20 - you half a gallon for each dollar you
138:22 - put in so we're gonna define how much
138:25 - cash we have we have 14 dollars in cash
138:27 - and then we're gonna pass it in ok this
138:30 - number 14 it could go right here also we
138:33 - don't necessarily need it to be a
138:34 - variable but just to show that you can
138:36 - it will go in to here it will process
138:39 - and it will return whatever this gallons
138:42 - total is are you ready to pump some gas
138:46 - done right 14 dollars we got 7 gallons
138:50 - of gas and now our you know fast
138:53 - motorcycle rebel without a cause Harley
138:57 - Davidson is all you know full of gas and
139:00 - pumped up ready to to cruise the open
139:04 - road so we're gonna be cruising the open
139:07 - road we're probably gonna need to make
139:08 - some calls so why don't we talk about
139:11 - calling a function very punny doing very
139:14 - punny ring ring ring hey you're
139:19 - conscious here would you like a bowl
139:22 - full of melted contacts like contacts
139:26 - like the kind that you would put in your
139:27 - eye like a whole bowl full of a melted
139:29 - down no that sounds disgusting gross and
139:32 - memorable doesn't it that it does let's
139:35 - talk about calling a function so we've
139:37 - defined this function here cup of melted
139:39 - contacts it's hard to say because it's
139:42 - not a real thing that anyone would ever
139:43 - do and cream okay so we're passing in to
139:47 - this function I imagine imagine like a
139:48 - cup of coffee but we're passing in
139:51 - melted contacts instead of coffee and
139:53 - then some cream you know probably to
139:55 - make it taste better and we're gonna
139:57 - return instead of making the variable
140:00 - first and then returning the variable
140:01 - we're just doing it all kind of in this
140:02 - shorthand notation so we're just
140:04 - returning the sum of the two so we have
140:06 - a function now what he thinks gonna
140:07 - happen when we run this
140:10 - nothing kinda but kinda not actually
140:14 - there is a function that was just to
140:16 - find but functions are containers
140:18 - they're like can they're like toasters
140:20 - there they were there and they're ready
140:22 - to go but until you stick that toast in
140:24 - them they're not gonna do anything it
140:26 - looks like you plug in a toaster and it
140:27 - looks like it doesn't work right because
140:28 - you haven't put toast in and press the
140:30 - button down that's the same way so
140:32 - calling is essentially the same thing as
140:34 - putting toast in the toaster and
140:36 - pressing the button so let's make a
140:37 - couple variables here so we're gonna
140:39 - melt down 64 contacts
140:41 - melt you know I hope you know what I
140:44 - mean like a context that people put in
140:45 - their eyes for good vision I imagine
140:47 - like a bunch of them 64 or 100 or
140:49 - whatever and then you put them in a bowl
140:50 - and put them in the microwave and you
140:52 - just melt them into a liquid okay
140:54 - because they're probably plastic or
140:55 - something weird like that
140:56 - okay so that's what we have for our
140:58 - variables now what do you think is gonna
141:02 - happen when our function doesn't have
141:03 - any logic in it except it just has this
141:05 - keyword pass so we are passing in this
141:08 - number 64 and we're also passing in this
141:11 - number four what's gonna happen nothing
141:15 - oops
141:15 - so that's kind of weird now that's a
141:20 - totally pointless function but you might
141:22 - see something like this in code because
141:24 - you know you're gonna need it later or
141:26 - kind of like a reminder that you're
141:27 - gonna do something but you know in
141:29 - essence this function that we created
141:31 - called morning drink really has no use
141:33 - so let's go ahead and start filling it
141:35 - in with some stuff that might actually
141:36 - do something so what do you think is
141:38 - gonna happen if we don't have a return
141:40 - but we do have some logic inside well
141:44 - following what we said before it will
141:46 - process that these two have been added
141:48 - together but they didn't go anywhere
141:50 - they didn't get returned they didn't get
141:51 - put into a variable so you know Python
141:54 - just got this this like toaster that's
141:56 - like hey I'm ready to be pressed now I
141:58 - have the mechanics inside of the toaster
142:01 - and you can press the button and put
142:02 - toast in me but you just haven't yet now
142:04 - this is like a toaster that has nothing
142:05 - inside of it this is like a toaster that
142:07 - just needs some toast so let's give it
142:10 - everything that it needs let's think of
142:12 - this return keyword as pressing that
142:14 - button and putting toast in our toaster
142:17 - 68 all right so what happened here let's
142:19 - just remind ourselves sixty-four and
142:21 - four are the two variables that we
142:22 - passed in that makes
142:24 - so 64 came in here four came in here
142:27 - what was pairs is now melted contacts
142:31 - okay so that's important to keep this is
142:33 - a variable of the number 64 and it just
142:37 - becomes this ok these don't have to
142:39 - match up even though it seems kind of
142:41 - like like they kind of should like you
142:43 - you could go the extra mile and like
142:45 - make it so that this is also melted
142:47 - contacts and you define melted contacts
142:49 - as the variable and that it could be
142:50 - smart for your situation but just
142:52 - important to know that this is totally
142:54 - separate ok now that we see that it's
142:56 - working let's make a point to separate
142:58 - these two concepts so we have what I
143:00 - consider the Tupperware part up here the
143:02 - logic the container the toaster and then
143:04 - I have the part where you put the bread
143:06 - in down here so we don't have to put
143:08 - them right next to each other so in this
143:09 - case the toaster analogy really breaks
143:12 - down like this is like almost like a
143:13 - light switch or if we could put the
143:15 - toast in the wall somewhere else but the
143:18 - toaster was like on the other side of
143:19 - the room and then sent the heat over or
143:21 - something weird but anyways the point is
143:23 - that these two are totally separate so
143:25 - you should think of this as being
143:27 - something that can be somewhere else in
143:29 - your code right like put it way down
143:31 - here and you can run it and you still
143:33 - get the same response ok it just kind of
143:37 - magically travels through the air and
143:38 - this is what makes it powerful is that
143:40 - we can write all of these complex
143:41 - functions and the functions can have
143:43 - functions inside of them and they can
143:44 - call on others and there's a huge stack
143:46 - of logic and all this amazing stuff your
143:48 - computer can do and you just write
143:50 - something like here like you know make
143:52 - me a morning drink or you know move my
143:54 - mouse to the right and it does all the
143:56 - logic to move all the other things and
143:57 - all the pixels around and you know kind
143:59 - of the mind-boggling stuff is done
144:01 - separately and it's contained in its own
144:03 - world ok well now we know that the
144:05 - function works but you might ask
144:07 - yourself how would I know if I didn't
144:08 - write the function myself if you didn't
144:10 - have first-hand knowledge well luckily
144:12 - Python helps us with that too because
144:14 - there is a callable function that we can
144:16 - pass our function or actually any other
144:20 - object because everything is an object
144:21 - in Python in - to find out if it Scala
144:23 - below or not so here's an example the
144:26 - tiniest simplest function I can imagine
144:28 - actually we can make it more let's call
144:30 - it a a function a we define it we name
144:35 - it we give it the parameter
144:37 - with no print we have parentheses for
144:39 - the parameters with no variables passed
144:41 - in the colon to give it a statement that
144:43 - it's over and then pass now it's kind of
144:45 - unique to have it up there usually you
144:47 - would see it down one block but it
144:48 - actually works if it's just passed in
144:50 - this kind of shorthand notation so we
144:54 - have a can we run this true or false
145:00 - true because it's a valid function right
145:03 - there it is right in front of us so we
145:05 - also can check other things so we know
145:07 - we defined morning drink this should we
145:08 - call ball too
145:09 - yep and what about the number one an
145:12 - integer well an integer is not really
145:14 - callable in my head it's not a function
145:16 - doesn't do anything you can't pass
145:18 - anything into it but who knows pythons
145:21 - weird oh we were correct false you could
145:24 - not pass it in and you might think a
145:27 - variable all right well that's a
145:28 - container it's got some stuff inside of
145:30 - it maybe that's callable so let's find
145:33 - out if our two knees can be all
145:37 - boss so it's easy to find out what's
145:41 - call and what's not
145:42 - but what's the syntax to actually make a
145:44 - call ring ring ring yellow would you
145:48 - accept a collect call from simple
145:50 - function no parameters being passed in
145:54 - it's a three times four return yes yes I
145:57 - will even know what I press but I don't
146:00 - even know what I'm saying there collect
146:02 - calls it's an old watch old movies
146:05 - people it's how people tell old people
146:08 - used to make calls I guess or old poor
146:10 - people made calls so here's the problem
146:13 - with the syntax if you don't make the
146:16 - call with the parentheses on it meaning
146:18 - that there could be parameters even
146:20 - though in this case there's not but you
146:21 - have to say I could be passing in some
146:23 - parameters if you forget to do it which
146:25 - is a really common mistake you don't
146:27 - even really get an error so you have to
146:29 - be kind of aware of it because it is
146:31 - just what it says it is it's it's a
146:33 - function it's kind of like a variable
146:34 - even though you never put it in a
146:36 - container it's in this private place
146:38 - dunder main and its dot simples and then
146:42 - it sort of attached it to this
146:43 - behind-the-scenes method okay so if you
146:47 - see this just realize oh I forgot the
146:50 - parentheses that's the only thing you
146:51 - need much better then you can call this
146:54 - and it's actually going to process
146:55 - what's inside and do the return so this
146:57 - is gonna like working with the
146:58 - Tupperware this is like moving it around
147:00 - or looking at it it's defined up here in
147:03 - sort of the same way a variable would be
147:04 - but this is actually execute this is do
147:07 - something like go ahead and process that
147:09 - and give me your return and this is also
147:11 - where we will be passing in things when
147:13 - we get to our parameter section so quick
147:16 - touching on annotations annotations are
147:19 - not required in other programming
147:21 - languages you have to specify things
147:23 - like this but you don't in pathan so if
147:25 - you want to specify for the sake of
147:27 - clarity that you want to pass in a
147:30 - parameter and you want that parameter to
147:32 - be an integer so don't pass me a string
147:34 - you can actually use colon kind of like
147:36 - a dictionary here and you can say
147:38 - alright this is the variable remember X
147:40 - is anything you want to name it as long
147:41 - as you want to work with it in here but
147:43 - you can say I want it to be of type
147:45 - integer or if type string or of type
147:47 - float and you can use this arrow here
147:49 - with a list
147:50 - to say you will be getting back a list
147:53 - check this out shopping equals ad okay
147:57 - this is a function you can see it to
148:00 - find right there and it's got the number
148:02 - four this is an integer it's got a
148:05 - string which is going to correspond to a
148:07 - string and it's got four point four
148:09 - which means it's a float so it's going
148:11 - to give us a list in return because we
148:14 - specify it so look down here when we do
148:18 - shift-tab
148:20 - it gives us some information here saying
148:23 - pass me in an integer pass me in a
148:24 - string pass me in a float so that's
148:27 - really the power of it when you're
148:28 - working with the team they can see what
148:30 - you were expecting or gives them more
148:32 - clarity on what what you need and it's
148:34 - not gonna throw an error if you give it
148:37 - the wrong thing it's just gonna work
148:38 - also a worker not work depending on what
148:40 - the logic is but it's not necessarily
148:42 - something that is enforced either so
148:44 - keep that in mind and you can see that
148:46 - the type we got back was a list just
148:48 - like I said it would okay many ways
148:50 - that's annotations okay enough about the
148:54 - topic of calling time to hang up on that
148:57 - topic you know what I mean
148:59 - very funny very plenty doing let's talk
149:02 - parameters very cool stuff these are the
149:05 - things that were passing into our
149:07 - functions to be processed these are the
149:09 - dollars in the gas-station example so
149:12 - there's a few styles on how you can put
149:14 - them let's start with the most basic we
149:16 - have a couple variables BM here and ym
149:18 - and they're just defined as these two
149:20 - numbers and we have a function called
149:21 - hungry hippo it's gonna take in an X
149:24 - argument and a Y argument remember we
149:26 - name these and match them here and it's
149:27 - gonna subtract Y from X okay so you know
149:30 - what is it subtraction is not
149:32 - commutative it's whatever the opposite
149:34 - of commutative is so it has to be done
149:36 - in a specific way so watch what happens
149:38 - when we have a function we call it with
149:41 - BM first it's gonna take seven in the
149:44 - first argument which is going to become
149:46 - X which is going to make it seven and
149:47 - then we are going to subtract Y which is
149:50 - going to be the ym argument which is
149:52 - going to come in here and subtract there
149:53 - so we're gonna start with seven and
149:55 - we're gonna subtract Y now it will still
149:59 - work if we reverse it
150:02 - because the logic needs it in a certain
150:05 - order we are gonna get a different
150:07 - answer we're gonna get negative four so
150:08 - this is something to be careful of well
150:11 - I mean we can't just be passing in
150:13 - parameters like willy-nilly on this
150:15 - thing you know it's not gonna know which
150:17 - order you want things in so we have a
150:20 - few options one you can make sure that
150:22 - the order goes in correctly always
150:24 - starting with the first argument first
150:25 - argument second argument second argument
150:27 - or we can actually specify so in cases
150:30 - like this where we need things to be in
150:32 - the correct order we can be explicit
150:34 - about the variables we're passing in so
150:36 - in this example you'll see that we set Y
150:38 - and X the same way we did up here but in
150:41 - this case we're saying Y is equal to ym
150:43 - and we make sure that the variable three
150:46 - that we have is in the variable named ym
150:49 - when you do this it will go the same no
150:52 - matter what order they're in so watch
150:54 - this for example we're gonna get out
150:56 - four here and we also could rearrange
150:58 - this and still get out four so it's
151:03 - gonna be invariant to the order that
151:07 - they're in for lack of a better word now
151:09 - let's look at a new function where we
151:11 - have this equal sign on the opposite
151:13 - part instead of having it down here
151:15 - where we're calling we're actually
151:16 - having it up here where the function is
151:19 - so this is interesting do you think it
151:21 - is the same thing let's try five all
151:26 - right so I think you kind of get it just
151:28 - now that this is acting as a default
151:30 - argument if we were to put in something
151:33 - else over the X like then it will
151:37 - override it but if no arguments are
151:39 - passed in it's going to default to five
151:41 - so this is a really powerful thing to do
151:43 - if you would get an error if no argument
151:45 - was passed in but you know sometimes
151:46 - they're gonna be lazy the user is gonna
151:48 - be lazy or whatever and you just want to
151:50 - make sure that something goes in and a
151:52 - five is a good default value so x equals
151:54 - up here in the function is an automatic
151:57 - default position so we can mix and match
152:01 - the two I just kind of want to show you
152:02 - how you can have something that's
152:03 - required to be passed in or you can have
152:06 - something that's a required slash it has
152:08 - a default so it's kind of optional in a
152:10 - sense but it does need an argument it's
152:12 - not optional to have an argument but
152:14 - it's our optional to pass it a new one
152:16 - it's got a default state so here's an
152:18 - example of that we can pass it why am
152:20 - get three
152:25 - yeah we're gonna have a missing we're
152:26 - missing error here so the positional
152:28 - argument X is gone this is referring to
152:31 - how we have passed in one argument which
152:33 - is all that's really required from the
152:35 - mix and match but it's not the right one
152:38 - because we were so explicit about saying
152:40 - that ym is only going to replace this
152:43 - one that has the default it's not gonna
152:45 - work but we could say it's X and then we
152:49 - would have something that ran so what do
152:52 - you think about a triple-threat
152:54 - nobody likes a triple-threat double
152:56 - threats are terrible single threats are
152:57 - terrible triple threats are oh they're a
153:01 - home run okay got a function first
153:04 - second and third are gonna be the
153:05 - variables we pass in and we're gonna add
153:07 - them together to see where our runner
153:08 - goes so we place the arguments in the
153:11 - function call with a comma between the
153:14 - two to separate them out that makes it
153:16 - so that it's first comma first and then
153:19 - the number one then comma cuz you can
153:21 - take all these together and add them up
153:22 - and of course we get six you already
153:24 - knew that and that's it for style part
153:26 - of parameters now we're gonna talk about
153:29 - args and kwargs the coolest words in
153:33 - Python so what is passing in Star args
153:36 - do I will show you it means that we can
153:40 - pass in something of varying length
153:43 - whether it has two items or four items
153:46 - or 50 items as many items as your memory
153:49 - can handle by putting star args up here
153:52 - it's gonna take in the entire list of
153:55 - everything that you pass in another
153:58 - really powerful thing if you have a
153:59 - function that just says you know process
154:01 - however much comes in I don't need to
154:02 - know how many times the variable is
154:04 - gonna come in just every time I see one
154:06 - this is what I'm gonna do so do you
154:09 - think we can make some specific and some
154:11 - of the star Arg style that in the same
154:14 - function can we have some that are just
154:15 - like I need these and then the rest are
154:17 - like and anything else you got but I
154:20 - gotta have these oh yeah of course I was
154:24 - really a setup question let's be honest
154:26 - but here you can see we have first
154:28 - required second require third required
154:31 - and then as many more as we want to pass
154:33 - in so when we make the call we have this
154:36 - star args up here we have the first one
154:38 - one two
154:39 - it's got to go in second - tequila goes
154:42 - in third tequila and then floor plus the
154:46 - rest car in jail hey your decision
154:51 - let's talk star star quarks star star
154:55 - quark is there just like saying it
154:56 - star star quarks what do you think
154:59 - adding star star kwargs will do to this
155:01 - function did you guess that cabbage
155:05 - equals vegetable well what's happening
155:08 - here is we're able to not just pass in a
155:10 - long list we're actually able to pass in
155:13 - pairs so this creates a dictionary on
155:17 - the back end that we don't really see
155:19 - and it's combining the two things as
155:22 - they come in and keeping them grouped
155:24 - together so when something gets passed
155:26 - in as star star kwargs we can run this
155:30 - for loop and remember before we talked
155:33 - about having an index and a value a key
155:35 - and a value using this dot items method
155:37 - well we can use that to actually see
155:39 - what's going on we can pull a name and a
155:42 - value out of what's passed in through
155:44 - star star kwargs and we can put them in
155:46 - these positions right the first position
155:48 - is gonna be the name and then the second
155:50 - position is gonna be the value from the
155:52 - string video remember this equal sign is
155:54 - only a string of text this could be like
155:56 - hi guys or whatever that's not an actual
155:58 - equal sign that's just part of what I'm
156:00 - showing you because these two are
156:02 - connected together and when they come in
156:04 - they come in as Apple equals a fruit
156:08 - okay so it's a string like a tag that
156:11 - we're putting on top of it and then
156:13 - we're passing in a real variable called
156:15 - cabbage and we're saying by the way
156:16 - that's a vegetable so we can throw in
156:18 - these little tags with it which can help
156:20 - us when we get more complex logic inside
156:22 - of a function okay so let's just break
156:25 - this down from the top because I'm not
156:26 - gonna pretend it's really easy at the
156:28 - point we're at now but it can be worked
156:30 - through so we have a new function we're
156:33 - defining it named bar makes sense it's
156:36 - getting a first second and third
156:37 - argument these are just single arguments
156:39 - and then we're giving it this star star
156:41 - kwargs the special options it's going to
156:43 - be this kind of key value dictionary
156:45 - styled pair then we're closing out the
156:47 - definition and we're saying here's the
156:48 - logic then we're going to make an if
156:51 - statement so we're going back to our
156:52 - conditionals
156:53 - and we're saying bring in this
156:54 - dictionary of stuff and get out the item
156:58 - action if it was passed in which it was
157:01 - passed in down here and we're saying
157:03 - once you see what that is if it's this
157:07 - and it's equal to this then execute this
157:13 - logic adding this this this together and
157:16 - printing it out okay so it's a little
157:20 - tricky but when we call the function
157:22 - we're passing in the first three
157:24 - parameters that are just singles then we
157:26 - have this pair here action comes with
157:29 - sum and then number comes with first so
157:33 - we get the sum is six kind of make sense
157:38 - keep thinking about it look it over you
157:40 - can always download the notebook from my
157:42 - github and then I just want to show you
157:44 - kind of a fun ending let's talk about
157:46 - unpacking it's just a really cool thing
157:47 - that you couldn't save a ton of time
157:50 - doing when you really get your head
157:51 - around not totally necessary as a
157:53 - beginner but I just want to show it to
157:55 - you we can make this function called
157:56 - alphabet and we can bring in a B and C
157:58 - the first three letters of the alphabet
158:00 - and we do nothing but print them so we
158:02 - can pass in a dictionary we can pass in
158:06 - a dictionary with two stars or we can
158:08 - pass in a list with star so star Arg
158:11 - star Arg and star star quark here is
158:14 - what happens ABC one two three and ten
158:19 - twenty thirty so the first one it's the
158:21 - dictionary it has just a single star in
158:24 - front of it which is just an art not a
158:25 - quark but I also said that only the
158:28 - quarries were the dictionaries right so
158:30 - when it sees the dictionary come in
158:32 - it just says all right there's only one
158:34 - star here so it's an argument just use
158:36 - that argument that argument and that
158:38 - argument and it just throws away the
158:40 - value the value that's paired up with
158:42 - the key and just uses the keys by itself
158:44 - but when you pass in the star star quarg
158:48 - the dictionary then brings you the exact
158:50 - opposite it only uses this as a label
158:52 - and brings you the value the value and
158:55 - the value and then if you bring in a
158:57 - list you just want to use a single which
158:59 - makes sense because there's only one
159:01 - space there's no colon and another key
159:04 - value pair it's just a key or an item
159:06 - from a list so kind of get your head
159:08 - around that and you will understand how
159:10 - to pass things into functions how useful
159:13 - it can be to store all that code and you
159:15 - know on the broader context just how
159:16 - amazing functions are hunted layers of
159:18 - functions below what we have to deal
159:21 - with and it's really amazing it's what
159:22 - makes computers and all this magical
159:24 - tech stuff work so that's it we'll see
159:27 - you next time
159:28 - subscribe to our mnemonic Academy
159:31 - YouTube channel for daily uploads that
159:33 - will help you learn amazing concepts
159:35 - through effortless associations all
159:48 - right get ready for this how-to video
159:50 - where we discuss nesting we're gonna
159:54 - talk about passing functions left and
159:56 - right we're gonna talk about a really
159:58 - important concept called closure meaning
160:00 - like what variables are packaged along
160:02 - with it when we're sending functions off
160:04 - to go visit places and do different
160:06 - things and that's what makes them
160:08 - first-class because they have the
160:10 - ability to do anything that a Python
160:13 - object does which is pretty incredible
160:14 - when you start thinking about it and
160:16 - then we're gonna talk about nesting and
160:18 - the differences in the way we can nest
160:21 - the different functions and what it
160:23 - means for how we call and execute them
160:25 - and of course closing on closure we're
160:28 - gonna build on the concept from the why
160:30 - videos where we talk about being at the
160:32 - post office and closing a box with a
160:34 - package inside of it and the entire
160:36 - environment of the post office going
160:38 - into the box also so when your friend
160:41 - opens the box
160:42 - he's also inside the post office so
160:45 - we're gonna go through and just show a
160:46 - bunch of experiments and examples to see
160:48 - where and when you can access what to
160:50 - hopefully drive that concept home so get
160:53 - ready
160:53 - let's talk nesting
160:56 - all right let's start with first class
160:58 - functions
160:59 - remember that airplane seat that first
161:01 - class experience that's what we're about
161:03 - to go through now so imagine yourself
161:05 - with all of that beautiful you know we
161:08 - eat we tea stuff going on in your on
161:10 - your flight so here's what we're gonna
161:13 - look at we're gonna look at functions
161:15 - and how they can be passed in to one
161:17 - another so we're gonna define a function
161:20 - just called R and O we import the random
161:23 - module and it returns a random number
161:26 - between 1 and 10 so I'm gonna run this
161:30 - cell multiple times and you'll see that
161:31 - we get different answers each time we
161:33 - run it so it's picking a random number
161:35 - so we have this function R and oh we
161:37 - know how to call it we know it provides
161:39 - a random number here's the question can
161:41 - we use a function as a parameter and if
161:45 - we do do we add it with the parentheses
161:47 - or without the parentheses what happens
161:50 - so here we're defining a new function
161:52 - this doesn't have to match up remember
161:54 - because we're inside of the parentheses
161:56 - here so this just has to match whatever
161:58 - logic it is there is a variable in
162:00 - itself this is the variables contents
162:03 - this is the shot-glass this is the
162:05 - liqueur we have defined a robin's nest
162:08 - and we want to bring in Rando when we do
162:13 - we're gonna have some kind of a return
162:16 - here and then we're gonna do some logic
162:18 - we're gonna add 100 so we know we're
162:20 - getting a number we know they're both of
162:22 - the type integer so that should work we
162:24 - should get some kind of random number
162:26 - here and add a hundred to it and then
162:28 - return it if we're allowed to pass
162:30 - functions in as parameters and as you
162:33 - probably guessed because in Python we
162:36 - have first-class functions we can pass
162:40 - them right in so let me just run this
162:42 - sell a few times and you'll see that we
162:44 - get that random portion 1 through 10 is
162:47 - always added to the static 100 the
162:50 - constant that we get from the second
162:51 - function so a cool way to think about we
162:54 - have these little packages of code and
162:56 - they can actually be passed into
162:57 - packages of code it's also easy now to
163:00 - start thinking about how Python really
163:02 - does so many powerful things when you
163:05 - start writing programs that do amazing
163:07 - things on your phone
163:09 - applications that tap into all these
163:11 - other resources you can kind of imagine
163:12 - that you're just on the top of all of
163:14 - these nested functions it's calling on a
163:16 - function that could be calling on a
163:18 - function that's calling on a function
163:19 - and they're all hidden from you but
163:21 - they're going all the way down to the
163:22 - ones and zeros the binary that actually
163:25 - runs computers or goes into huge
163:27 - databases and does more complicated
163:29 - queries just because you ask for
163:31 - something simple so really cool to
163:33 - understand first-class functions means
163:35 - that functions are treated as objects
163:38 - and they have all of those same
163:39 - first-class rights so we talked about
163:43 - passing a function into a function but
163:45 - let's talk about nesting meaning the
163:48 - functions are inside of the functions so
163:50 - we can look at it a couple ways first we
163:53 - think of them as separate containers
163:54 - where one is just going around like a
163:57 - kitchen and grabbing whatever it needs
164:00 - because it's got access to everything in
164:02 - the kitchen and that's what I call this
164:03 - separate category so the way to think
164:06 - about this in code is to define a
164:08 - function that does something simple like
164:10 - just returns the string of texts fly
164:12 - i'mjust will run that so you can see
164:14 - that it works and then let's define
164:17 - another function and what it's gonna do
164:20 - is it's gonna return bird and then it's
164:24 - gonna multiply it by five so it's kind
164:26 - of like our first-class function here
164:28 - but you might be asking yourself but you
164:29 - didn't pass anything in ah that leads to
164:32 - an interesting question what if we would
164:33 - have put Rand oh just right in there
164:37 - like that what if we in fact don't pass
164:39 - in anything that and that does that work
164:43 - oh it does look we don't even need to
164:49 - pass it in so it does work when you pass
164:51 - it in and in some cases you want to
164:53 - because you can't just have everything
164:54 - floating around everywhere but it's good
164:56 - to know that we can grab them just like
164:58 - we would any other variable so here we
165:02 - can just say take that function multiply
165:06 - it by five and return fly fly fly fly
165:09 - fly fly okay so when I mean separate
165:11 - what I mean is floating out there in the
165:13 - environment variable that we have access
165:16 - to it's an object technically but it's
165:18 - just an object that we have access to at
165:20 - any given time like we could call it at
165:22 - any given
165:23 - we can also build some new container and
165:26 - put it in the container because it's
165:27 - already in the kitchen it's like out on
165:29 - the counter and we can put it in the
165:30 - Tupperware stuff that's in the type of
165:32 - work can't necessarily get out of the
165:33 - Tupperware and get onto the kitchen
165:34 - counter
165:35 - it must be hungry I wonder why I'm
165:36 - making all these kitchen analogies ok
165:38 - but let's look at it together so this is
165:41 - another function that we calling nest to
165:44 - and inside of it is another function so
165:47 - the function wasn't created outside and
165:49 - then we're just calling it in this thing
165:51 - solely exists its whole life is inside
165:54 - of this cage it's inside of nests - bird
165:57 - - doesn't know what it's like outside
165:59 - but what's interesting is we can define
166:02 - it it is in the scope inside of this
166:04 - function so maybe the best way to think
166:06 - about this is to focus on the inner
166:08 - function first pretend this is all of
166:10 - our world don't worry about the
166:11 - indentation all we're doing is returning
166:13 - this string egg but who's gonna call
166:17 - that well we could call it down here if
166:20 - we were pretending this wasn't spaced
166:22 - out and this then it exists so maybe we
166:24 - can just add a return and then put a
166:26 - definition so we're now indented one
166:30 - layer and this is automatically going to
166:31 - get called and then returned okay so
166:35 - that's interesting
166:36 - egg is solely living in here and we
166:40 - can't call it outside so right here I
166:43 - can't call bird - for example there's
166:49 - nothing there but with the separate one
166:52 - I could call well I already have it's
166:56 - pretty obvious but yeah I could call
166:57 - bird right it's already there so
167:01 - interesting just to think about how we
167:03 - nest things and where the scoped of
167:06 - variables and access is let's talk about
167:10 - closure so closure is one of my favorite
167:14 - topics but kind of tricky to understand
167:17 - so for those of you who are like just
167:19 - playing my video in the background will
167:21 - you you know like right political
167:23 - comments now is the time to stop doing
167:26 - that and actually watch the video
167:28 - because if you don't see this it's not
167:30 - gonna click very easily it's
167:32 - conceptually hard to understand but
167:34 - seeing examples I think is the most
167:36 - concrete
167:36 - way to deal with it so I'm excited for
167:39 - this we're gonna talk about closure with
167:41 - some experiments that I was testing
167:44 - before that will hopefully demonstrate
167:46 - this so here's our scenario we're a tiny
167:50 - little bird we're like a little bird
167:52 - that can't fly yet and we're inside of a
167:54 - nest and we're inside of the jungle okay
167:57 - we're in a tree like our mother bird has
168:00 - left so we're just hanging by ourselves
168:02 - and we don't want to jump out of the
168:05 - nest down to the ground because we don't
168:07 - know how to fly who will probably get
168:09 - eaten and and we don't know how to get
168:11 - back to our place but we can like hop a
168:13 - little bit so we can like hop out of our
168:15 - little stick nest and we can go up and
168:17 - down the branches and we can pick little
168:19 - branches or eat little bugs stuff like
168:21 - that that's on the branch okay trust me
168:23 - this is going somewhere otherwise you
168:24 - might end up a garbage man in the
168:26 - stinkiest part of town and assigned to
168:29 - only the stinky garbage we have a
168:31 - variable here called stones three it's
168:35 - outside of every function that we have
168:37 - obviously we have access to it it's at
168:40 - the top then we have our first function
168:42 - which is our nest so we're moving from
168:44 - the forest floor where the stones are up
168:47 - the tree into our nest it's another
168:49 - little container and we have inside of
168:51 - here some sticks we don't have access to
168:53 - that variable from the outside but if
168:56 - you're in this function you do then we
168:59 - go inside of the bird inside of the bird
169:02 - the bird has bones
169:03 - so we have the variables stones sticks
169:06 - and bones and they're at different
169:08 - levels of scope so now we have this
169:11 - print function in the most inner nested
169:15 - function and it's printing sticks stones
169:18 - and bones so we're checking to make sure
169:21 - it has access to all three of these
169:23 - levels we're just gonna make that
169:24 - function it's not executed yet but
169:27 - that's the layout okay so now let's just
169:29 - double check what we have access to
169:30 - stones 3 we do have access to because
169:34 - it's on the outermost thing sticks 3 we
169:38 - don't because it's nested inside of a
169:40 - function and we can't get to that we
169:42 - haven't executed that and then of course
169:44 - this function we can't even call we
169:47 - can't even execute birds 3 because it's
169:50 - inside of
169:50 - another function which we don't have
169:51 - permissions for so that one's protected
169:53 - too so now we know what we do and don't
169:56 - have access to so if we take nest three
169:59 - our outermost function and we run it it
170:03 - is going to return bird three which is a
170:07 - call to the inner function and it's
170:09 - using the parentheses so you know it's
170:11 - going to execute the logic that's inside
170:13 - of here so it should print all of these
170:15 - out and what do we get
170:17 - yes by just calling this outer function
170:19 - which then in turn calls the inner
170:21 - function which then in turn says do I
170:24 - have access to this this and this which
170:26 - it does does and does okay all right so
170:29 - execution with parentheses down here now
170:33 - let's look at it without parentheses so
170:36 - this is basically the exact same except
170:39 - now I've changed everything from three
170:41 - to four just so we know that we're
170:42 - working with fresh variables nothing's
170:43 - coming down the page and one big change
170:46 - here is that the returned variable isn't
170:49 - being executed that's different from
170:51 - this one because we add the parentheses
170:53 - around it so this one's just passing it
170:57 - in and it is going to use closure to
171:01 - bring all of these variables into it and
171:03 - then we can pass it around later so same
171:06 - thing stone sticks bones execute from
171:08 - the inside when we define this function
171:11 - and then run nest for we'll get
171:14 - something different instead of executing
171:16 - it we just get some information saying
171:18 - hey this is a variable it could be ran
171:20 - but right now you're getting back just
171:23 - bird for the variable holding the entire
171:26 - function and all of the namespace and
171:29 - all of these variables at all three
171:31 - layers so we can put this variable which
171:34 - is uh necks acute 'add into a new
171:37 - variable and then we can pass it around
171:39 - so now we can run this and instead of
171:42 - using
171:43 - that function to execute that function
171:45 - it's just gonna pass all that
171:46 - information into a new variable called
171:47 - shot-glass make sense shot glasses hold
171:50 - things and if we look at this we'll see
171:52 - the same thing as before so we just
171:54 - passed it in no problems there but
171:57 - here's the question when we take shot
171:58 - glass and we add the parentheses is it
172:02 - the same as having the parentheses in
172:04 - do you think it's gonna actually execute
172:06 - this code surprise surprise it can and
172:10 - it has access to sticks for stones for
172:14 - and bones for so that means all of this
172:17 - stuff that that and that it all got
172:20 - packaged in here so really bird for is
172:24 - amazing like it was like I'm gonna get a
172:26 - stone I'm gonna get a stick I'm gonna
172:27 - get bones you can pass me into another
172:30 - variable and then you can execute that
172:32 - variable later and it has all of that
172:34 - stuff in it so when we're talking about
172:35 - closure we're talking about this concept
172:37 - that the function itself has like
172:40 - brought in all of these variables that
172:42 - are normally just floating around and I
172:44 - mean it kind of makes sense that it has
172:45 - access to it here
172:47 - but it's sort of surprising that it has
172:49 - access to it down here so it's really
172:51 - bringing a lot in with it the entire
172:53 - environments in there so now let's take
172:55 - it a step further and look at what
172:58 - happens when we actually repackage that
173:00 - variable that's holding a function
173:04 - that's also that a nested function and
173:06 - it's got some logic that's looking at
173:07 - variables that are spread out all over
173:09 - the scopes so here we are stone five
173:13 - this is the same as last time we just
173:15 - added five to everything now we're gonna
173:17 - take this remember the return is coming
173:19 - in without the execution no parentheses
173:21 - there and we're gonna put it in a
173:23 - variable this is the same as shot
173:24 - glasses last time just a new name we put
173:26 - it in closed package and now I have to
173:28 - find a whole nother function so remember
173:30 - now we're kind of going back into
173:32 - another Tupperware container so we are
173:34 - gonna check to see if you can actually
173:36 - return it so before I run this function
173:39 - what I'm saying is I have a new function
173:41 - and its goal is just to return whatever
173:44 - is in mystery and what I'm going to put
173:46 - into it is the closed package this
173:49 - equivalent to shot-glass and I'm going
173:51 - to put the parentheses on it so it
173:53 - should execute this that should execute
173:55 - that which should check to see if all
173:57 - those variables are there but remember
173:59 - this is now all contained inside of this
174:02 - can I print world like all of these
174:05 - variables that were all outside they
174:07 - can't get out of this because it's
174:09 - enclosed in its own Tupperware so now
174:11 - it's like before where we'd open the box
174:13 - and we'd look around and we were like
174:16 - actually in the post office like
174:17 - everything came
174:18 - out of the box the entire environment
174:20 - but now that entire post office is
174:21 - inside like another little Tupperware
174:23 - container you know like there's another
174:25 - wall on the outside that we definitely
174:27 - don't have access to those variables are
174:29 - not floating everywhere in our code but
174:31 - they will be contained inside of here so
174:34 - can I print you certainly can
174:38 - sticks five stones five and bones five
174:41 - so pretty interesting stuff just weird
174:43 - to take all these variables and like
174:45 - package them in with something and then
174:47 - put them in something else and I mean
174:49 - it's really just fascinating to see how
174:51 - closure works I mean it can let you get
174:53 - access to variables when you're pulling
174:55 - up modules things like that so just
174:58 - powerful interesting and something that
175:01 - you should know about now go back to do
175:03 - and your political comments you
175:05 - Republican Democrat independent or other
175:11 - channel your inner Martha Stewart for
175:14 - this one we're talking decorators you've
175:17 - seen this set of functions before but
175:19 - the last time you saw him they were
175:20 - reversed and we had Rando on top ads 102
175:24 - the random number generated here and
175:27 - that is possible because even though
175:30 - it's floating in the scope of this Dec
175:33 - function it can be read by the inner
175:35 - function and then the call gets returned
175:37 - not executed in here because there's no
175:39 - parentheses it gets passed into this
175:42 - Rando Dec variable and then we execute
175:45 - it with the parentheses okay that didn't
175:47 - make sense watch the last video so let's
175:51 - do do it and what we get is exactly what
175:55 - we expected let me run it a few times
175:57 - you can see that we keep getting our
175:58 - random integer added to the big number
176:01 - so this is basically what a decorator is
176:05 - shorthand for decorators can be thought
176:07 - of a really simple way to take a general
176:11 - common function that you want to modify
176:13 - a lot of other functions so it doesn't
176:16 - come up all the time but I'm telling you
176:18 - that I never saw decorators like seven
176:22 - eight years ago and now they're coming
176:24 - up all the time so my most recent real
176:26 - world example of dealing with a
176:27 - decorator is if you connect to Google's
176:30 - cloud infrastructure
176:32 - they have decorators all over the place
176:34 - and they're really powerful because you
176:36 - can make a function that does some kind
176:38 - of complicated computation and then
176:40 - you'll add a decorator which are these @
176:42 - symbols and then the name of a function
176:45 - that's been defined as a decorator and
176:47 - what happens is Google takes your output
176:49 - and then sends it up into its cloud
176:52 - infrastructure and can then paralyze it
176:54 - or do processing or host an app in the
176:57 - cloud it can do a whole bunch of
176:59 - functionality that you don't need to
177:00 - worry about anymore you don't have to
177:01 - write all that stuff because it's
177:03 - general everybody wants the app to be
177:05 - fast so you just add the decorator at
177:08 - fast to your function and Google figures
177:10 - out how to make it go fast so with the
177:12 - world of API is and this Internet of
177:14 - Things I think you're gonna see
177:15 - decorators popping up more and more now
177:17 - what they do is sort of a shorthand it
177:21 - could all be done with functions being
177:23 - passed into functions but there's a lot
177:25 - of cases where it's just a waste of time
177:27 - to write all that stuff so a decorator
177:29 - is something that you want to be general
177:30 - something that you want to apply over
177:32 - and over again like if you had a house
177:34 - but you wanted every item and every wall
177:36 - and the house to be pink you could write
177:39 - a decorator that says no matter what the
177:41 - thing is after it's made and put in its
177:43 - place
177:43 - color at pink right it's like bringing a
177:45 - can of spray-paint in and just painting
177:47 - everything that you own pink you would
177:49 - make that function of spray-painting
177:51 - everything pink a decorator because it
177:52 - would apply to so many things and it's
177:55 - really not that useful if you're just
177:56 - gonna do it once like up here it would
177:58 - be just as easy to make this two
178:01 - functions as it is to make one function
178:04 - that's a decorator and then apply it
178:05 - here is a situation where you might want
178:07 - to use a decorator you might define like
178:09 - at the top of your code a topping we're
178:12 - gonna think about cakes in this example
178:13 - as our sort of mental visual pneumonic
178:16 - so you imagine the topping of like
178:19 - frosting and it can be put on any cake
178:22 - it can be put on a chocolate strawberry
178:23 - or vanilla cake we just pass in any cake
178:27 - this is a variable that we've defined
178:29 - and to make it a decorator function we
178:31 - just need to do well nothing we just
178:33 - call it later using that symbol so it's
178:36 - really easy to make decorators and even
178:38 - easier to use them here we pass in any
178:41 - cake and the cakes in this case are
178:43 - going to be a number for chocolate one
178:45 - through
178:45 - 10 for strawberry 11 through 20 it'll be
178:48 - a number here and then we just do the
178:49 - same thing we add 100 to it and then
178:52 - send it back for executions or just like
178:54 - what you saw up here we only now need to
178:56 - write one topping function because we
178:59 - know that we want frosting on all of our
179:01 - cakes and then on each of our cakes we
179:03 - just add at topping so the way to think
179:05 - about it is whenever you see that at
179:07 - symbol and then some kind of word you
179:09 - automatically know oh that's some
179:11 - function somewhere else in my code and
179:13 - once this logic executes it's gonna go
179:17 - traveling up here and go into there so
179:21 - you can just take all of this and then
179:22 - pass it into topping and then all of
179:24 - this and pass it into topping and you
179:25 - can see when we run chocolate cake what
179:28 - you think might just do what's here in
179:31 - the definition like you think the code
179:32 - works down in fact that's that is one
179:35 - interesting thing is that you can always
179:36 - think of code as moving down the page
179:38 - except in this one situation this is the
179:41 - only thing that's popping into my head
179:42 - right now is times where you can add
179:43 - something above the execution line and
179:46 - it actually works that's interesting so
179:47 - here we call chocolate cake and it does
179:50 - run all of this but it takes that return
179:53 - and instead of just giving it to you
179:55 - down here in the call like it should it
179:57 - then puts it into the topping function
180:00 - it automatically goes up here and passes
180:02 - it into that so you can see when we run
180:04 - chocolate cake we get that random number
180:06 - one through ten and then it's added to
180:08 - 100 and we can do that over and over
180:11 - again and we'll see that we'll always
180:12 - get a number between 1 and 110 now
180:14 - moving down with strawberry our number
180:16 - that's random is gonna be between 11 and
180:19 - 20 so we got the same thing but these
180:21 - numbers are always gonna be between 110
180:24 - and 120 and then doing it one last time
180:27 - you can see it works for a vanilla cake
180:29 - too so you can imagine if you had
180:31 - thousands of these functions and you
180:33 - really just needed to add this little
180:35 - topping or you have like a handful of
180:37 - these toppings that you sort of memorize
180:38 - like shortcut functions that modify it
180:41 - in some way especially something like
180:42 - cleaning up text before it goes out or
180:46 - like rounding digits up so that they're
180:49 - whole numbers because you're presenting
180:50 - them to the user or in some kind of a
180:52 - graph like it's great to just have a
180:54 - little function that does that and then
180:56 - you can just apply it to everything that
180:57 - comes out so
180:59 - hope you're feeling very much like
181:01 - Martha Stewart now and you're still
181:03 - imagining that weird pink house
181:05 - subscribe to our mnemonic Academy
181:08 - YouTube channel for daily uploads that
181:10 - will help you learn amazing concepts
181:12 - through effortless associations welcome
181:26 - to this how-to video on comprehensions
181:28 - and now the reason I broke this out from
181:29 - the other videos is because we're really
181:31 - not learning any new core functionality
181:33 - we've already learned how loops work
181:35 - some of the amazing things they can do
181:37 - and comprehensions are just gonna be a
181:39 - way for us to shrink this code it's
181:42 - gonna be notation it's gonna be
181:44 - shorthand and we can do all sorts of
181:46 - cool things in a much more simple way so
181:48 - we're gonna start by looking at types
181:50 - how do we handle the different group
181:52 - types like lists dictionaries and sets
181:54 - then we're gonna talk about operations
181:56 - how do we use comprehensions and still
181:58 - bring operations that we might need in
182:00 - then the same with conditionals how can
182:02 - comprehensions and conditionals work
182:04 - together we're gonna talk about nesting
182:05 - you know we can have loops inside of
182:07 - loops so can we have comprehensions
182:09 - inside of comprehensions we sure can and
182:11 - we'll talk about why and then we will
182:14 - talk about using range and finally a
182:16 - generator can also use comprehension so
182:20 - they can use our yield statement and
182:21 - have that same overtime functionality
182:24 - with the pause that we talked about and
182:25 - finally we're gonna look at a fun
182:27 - fizzbuzz problem a problem that you'll
182:29 - very likely get on your very first
182:31 - programming interview and how we can do
182:33 - that in comprehensions to make you look
182:36 - super sharp when you solve that problem
182:38 - all right let's do it so we're gonna go
182:41 - over lists dictionaries and sets to
182:44 - start with so first off let's look at a
182:46 - regional way we might go through a loop
182:49 - over a list so we've got this list to
182:51 - find it's just got some strings in it we
182:53 - call it old so it's full of prunes and
182:55 - wrinkles and wheelchairs and such and
182:58 - then what we could do before was write a
183:01 - for loop we could say for I in old and
183:04 - we know what we're doing here is saying
183:05 - old must be something that we can
183:07 - iterate over and this I stands for the
183:10 - individual elements the pockets if you
183:13 - and we're gonna take each one of those
183:15 - and perform this method of append onto a
183:18 - blank list so we end up with a new loop
183:21 - list okay simple enough so how would we
183:24 - do that with a comprehension that only
183:26 - takes one line instead of one two three
183:29 - well we could just say for I in old just
183:33 - like we have up here and the logic that
183:35 - we would normally have inside is just
183:37 - put right here now logic in terms of
183:40 - operators would go here like a
183:41 - multiplication and we'll see that down
183:43 - here in a second but we don't actually
183:45 - need to take a blank list and then
183:48 - append it because this comprehension is
183:51 - inside of the brackets and look brackets
183:54 - are how we make lists so these are
183:57 - important again this is not a not a
183:59 - willy-nilly kind of bracket situation
184:02 - that's gonna be important if you want it
184:04 - to be a list curly braces are gonna make
184:06 - it a dictionary or a set let's look at
184:09 - that next
184:10 - boom prunes wrinkles in wheelchairs fin
184:14 - okay dictionaries now this one's a
184:17 - little bit more tricky because we have
184:18 - keys and values so I made a couple lists
184:22 - here now these are just classic lists
184:23 - you can tell by the brackets of
184:24 - superhero identities in real life and as
184:28 - heroes you know Bruce Wayne and Batman
184:30 - Clark Kent and Superman etc so the way
184:34 - we might loop over this dictionary in
184:37 - our previous how videos would have been
184:40 - to say four key and four value in and
184:43 - then we would zip the two together and
184:45 - then go over them so here we're making a
184:48 - blank dictionary you can tell by the
184:50 - brackets that we used and then we say
184:52 - take that dictionary and add R which is
184:55 - our key and make that equal to value so
184:59 - make that key equal to that value that
185:01 - comes through from the zip this new
185:03 - dictionary called loop dictionary and it
185:05 - consists of these key value pairs which
185:07 - was everything that was in these two
185:08 - separate lists but can we do the same
185:11 - thing with comprehensions yes we can
185:14 - dictionary comprehension looks pretty
185:16 - similar right for key value in zip just
185:21 - like we had up here take what was inside
185:24 - nested
185:26 - loop it up this way accept the fact that
185:28 - we're using a dictionary is defined by
185:30 - this outside comp dict done cool huh
185:37 - okay so lists and dictionaries no sets
185:40 - are close to lists but one thing that's
185:42 - a little bit different about them of
185:43 - course is that you can't have duplicates
185:45 - the old way of dealing with this would
185:47 - have been for n in nums we would have
185:49 - just added it kind of similar to append
185:52 - with the list but the comprehension way
185:55 - we can put the curly braces around it
185:57 - and you're probably thinking well you
185:58 - just put curly braces around around this
186:02 - comprehension so how could how does it
186:05 - know it's not a dictionary comprehension
186:06 - and that's just because pythons smart
186:09 - enough to know that we don't have keys
186:10 - and values we just have I guess just a
186:13 - value here or a key a key and value are
186:16 - squished into one it's a symbiotic
186:17 - relationship but just because we're not
186:20 - saying and like if this was like K - V
186:24 - then it would be expecting something
186:26 - that was a dictionary to come in but
186:28 - since it's getting numbs which is a list
186:30 - it's all confused so we just make it a
186:34 - simple element that can be put into a
186:36 - set so my set was created on the fly
186:39 - there no need to do this part like watch
186:44 - this I think we can just do set - set -
186:46 - boom same thing right so don't don't
186:49 - don't let that trip you up you don't
186:50 - actually need it to say my set there we
186:53 - have our our own set and then just the
186:56 - very last thing is that when we do this
186:57 - with the square brackets just remember
186:59 - that we're making not a set but a list
187:02 - so we are gonna get all of our
187:04 - duplicates so the difference between
187:05 - duplicates and not duplicates is curly
187:08 - braces for none and brackets for a
187:11 - sequential order that does have
187:12 - duplicates all right there's the basic
187:15 - types lists sticks and sets all right
187:19 - now let's look at operations and the
187:20 - good thing is you've really learned to
187:22 - everything you need already you know how
187:24 - loops worked and then you just saw some
187:25 - examples of the basic comprehensions
187:27 - with basic group types so now we're just
187:30 - gonna add some layers to it and this is
187:32 - just kind of a nuance thing that you'll
187:33 - get familiar with over time on where to
187:36 - put operations and conditionals when
187:38 - you're doing comprehension so
187:39 - good to just play with this one this is
187:41 - a great notebook for you to just goof
187:43 - around with or test yourself and see if
187:44 - you can recreate some of these just to
187:46 - get familiar with them I'll show you the
187:47 - first ones now so we create a list of
187:50 - nums and this time we're just saying no
187:51 - change and we're not assigning it to a
187:53 - variable so it's basically just gonna
187:55 - print a console because we're inside a
187:57 - jupiter notebook and it's gonna stay a
187:58 - list because it's in the brackets around
188:00 - it so it makes sense that it looks
188:02 - exactly like it did before then we're
188:04 - gonna take a multiplication of each of
188:07 - them so now we're saying for each
188:09 - element in this list multiply it by two
188:11 - and you can see this would be the logic
188:13 - inside of the for loop we just put it in
188:15 - front so I like to think of it as
188:17 - something that would be like right it
188:19 - would be underneath this and it's now
188:21 - like moved up and to the left so it's in
188:23 - front now an easier way to read this as
188:26 - the old way would be like for aya nums
188:28 - and then it would be do this
188:30 - multiplication so same thing we're gonna
188:33 - get what we expect the multiplication
188:36 - and everything has been multiplied by
188:37 - two and now I'm gonna show you just one
188:40 - more kind of layer so we're saying for
188:43 - this in nums we have our answer here now
188:47 - when normally we would do our logic
188:48 - because we want our logic to be behind
188:50 - an if statement we put it at the end if
188:52 - then go ahead and print if not don't
188:55 - this is gonna be only our even number
188:58 - think we could just you just do multiply
189:01 - two again right there if you wanted to
189:02 - see that just for those few that is
189:05 - selected here those two that is selected
189:06 - you could actually do the operation on
189:09 - them there you go that's operations with
189:11 - list comprehensions but remember that
189:13 - could be dictionaries or sets or all
189:16 - sorts of different things
189:17 - next up conditionals pretty much just as
189:21 - easy the main thing to remember about
189:22 - conditionals and operations is
189:24 - operations usually are on the left like
189:26 - you we only have one line now so we take
189:29 - what would have been the top of our for
189:30 - loop or a while loop and now we say
189:33 - operation stuff is mostly on the left
189:35 - conditional stuff is mostly on the right
189:38 - if it's gonna be an if statement or
189:40 - something's gonna trigger on some kind
189:42 - of check you're probably gonna add that
189:44 - check to the right side of it so let's
189:46 - just look at another example here so we
189:48 - have a normal for loop where we're
189:49 - saying here's a list and then go through
189:52 - all the items in the
189:53 - and if it's a module Oh of two that
189:55 - brings no remainders then we know it's
189:57 - an even number so append it to my list
189:59 - easy enough just add that and then we
190:02 - just have our normal four and in nums
190:04 - which is just like for this item in my
190:06 - list or group type then we have our if
190:09 - statement which would you know normally
190:11 - be down a line but we're gonna keep it
190:14 - in one line because we're doing
190:15 - comprehensions and then you have the
190:17 - logic so conditionals go on the right
190:20 - operations go on the left well I'm sure
190:23 - you're all wondering what this exciting
190:26 - banana example is about well we're gonna
190:28 - make a dictionary and it's gonna be
190:30 - assigned different fruits and vegetables
190:33 - and ducks and babies and their number of
190:38 - best friends let's say so we have the
190:43 - key value pair separated by the : of
190:45 - course the calmness changes the elements
190:47 - and the colon signifies the relationship
190:49 - between those two now one thing we could
190:52 - do in a normal function is we could pass
190:56 - in both this dictionary list and then
190:58 - this custom value that's asking for a
191:01 - string okay now this string is going to
191:03 - go into a function called starts with
191:06 - okay this is a method that's just built
191:08 - into the string function and one things
191:11 - we can do is put one of these dictionary
191:13 - comprehensions in the same line as the
191:16 - return so look at how convenient that is
191:19 - we've got this function that is pretty
191:21 - complicated it's bringing in a
191:24 - dictionary it's saying for these key
191:26 - value pairs sort them by only the ones
191:29 - that start with the letter B even though
191:32 - we have apples and carrots we don't want
191:33 - those we just want bananas and baboons
191:35 - and babies so we can put that all in one
191:39 - line and that's that's cool I mean
191:41 - that's it's easy to read we're saying
191:43 - for key value in this dictionary of
191:46 - items where this logic is applied
191:49 - returned both the key and the value and
191:51 - don't get too caught up on functions
191:53 - that's our next chapter but we're
191:55 - basically passing these things in and
191:56 - you can just see that comprehensions can
191:58 - be really powerful we've now sorted what
192:01 - could be you know a million item
192:02 - dictionary down to just the ones that
192:04 - are with the letter B or
192:05 - you know that maybe we just want baboon
192:07 - so we just type that in and it searches
192:09 - that whole key value pair so sorry it's
192:11 - very interesting when you think about it
192:13 - and down here we can take that and it
192:16 - doesn't have to be inside of a function
192:18 - we can just all of a sudden right here
192:21 - make it we can just say it's a
192:22 - dictionary comprehension and here's what
192:24 - it needs to do we could also you know
192:27 - give that a dictionary key value so now
192:30 - we have give which is our just wanted
192:32 - you to see how easy that is
192:36 - be happy baboons babies and bananas
192:39 - that's our banana example now let's talk
192:42 - about nesting okay so now let's talk
192:47 - about nesting comprehension so first off
192:50 - just gotta make sure that you know how
192:52 - to think about loops inside of loops or
192:54 - else this isn't gonna make sense in a
192:55 - normal way so just kind of recap we have
192:58 - an outside loop that we've defined as
193:00 - letter and it's got four pockets in it
193:03 - because it's string with four characters
193:05 - and then inside of that is another loop
193:07 - that has four pockets also this time
193:11 - it's a numbers inside of a list but it's
193:13 - the same thing so we can think of this
193:15 - as running just this outside loop once
193:18 - for a and then what is inside the loop
193:20 - well a whole nother loop that goes
193:21 - through four times so we'll expect just
193:24 - for a to get one two three four and then
193:27 - just for B to get one two three four so
193:30 - you can see that's exactly what we get
193:32 - we get four a's and then four B's and
193:34 - four C's okay and then just to kind of
193:37 - get your head around it if we add the
193:39 - print line up here so that it's not
193:41 - inside of the second loop we get it just
193:44 - once because that's actually what's
193:45 - happening we're doing it once but we get
193:47 - these you know four times it prints out
193:50 - so just to run that I want to make sure
193:52 - that you see that you'll get it once a
193:54 - and then one two three four and then B
193:56 - one two three four okay so that lets us
194:00 - see what a comprehension with two loops
194:03 - looks like starting here like our
194:05 - outside loop four letters in ABCD that
194:09 - would be like right here four letters in
194:10 - ABCD and then we have no : no no way to
194:15 - signify to python just a space and then
194:18 - we start four again and no
194:19 - and then for num in our numbers which is
194:23 - the same as for num in our numbers and
194:26 - then the thing that would be the print
194:28 - statement in the most inner part the
194:30 - most nested part is going to be on the
194:33 - front here so it's not going to be
194:36 - printing from this level it's going to
194:37 - be printing from this level so we add
194:40 - that and we put it into this test list
194:43 - and we get out one two three four just
194:46 - like we expected here one two three four
194:50 - one two three four one two three four
194:53 - and one two three four so the syntax
194:56 - just remember it's just for right after
194:59 - a four and then whatever you put here is
195:01 - gonna be the innermost nested statement
195:05 - normally if we wanted to work with the
195:08 - range we might have a list like this one
195:10 - of a bag full of gold silver the blooms
195:14 - I don't know I'm not a pirate and jewels
195:16 - we can use this function length and it's
195:19 - gonna say one two three four I see four
195:22 - Puckett's that's the length of it and
195:23 - then range accepts an integer and the
195:27 - number four will make a range a list of
195:29 - one two three four
195:30 - so I'm printing before we assign here
195:34 - and then we're printing again so expect
195:35 - two print statements but I did this one
195:37 - because I want you to see that this is
195:39 - actually a number and then down here to
195:41 - see that it's actually the character is
195:43 - multiplied so down here you'll see zero
195:47 - one two three and that's because it
195:50 - found the length of for which you know
195:52 - we have the zero indexing and then it
195:54 - printed that out and then it said for
195:56 - the index of that number so for the
195:58 - first pocket take that pocket and then
196:01 - multiply it by five and what's in that
196:03 - pocket is a string so we end up with
196:06 - five pieces of gold and five pieces of
196:10 - silver and five two blooms so we're
196:13 - getting rich you know or da blooms
196:16 - however you want to say it now when
196:18 - we're doing I'm gonna do this just to
196:19 - reset it this respect to one with list
196:22 - comprehensions look we can just say in
196:25 - bag that would not work right here if we
196:29 - take just bag and say you know
196:32 - run that we're gonna get an error
196:34 - because it's got strings inside of it
196:37 - but down here it's smart enough to
196:40 - understand that we want to take that
196:42 - item and we want to multiply it by five
196:44 - and get five of our the blooms and gold
196:47 - and it can handle the range by just sort
196:50 - of understanding that if you're in a
196:52 - comprehension it's a range cool huh
196:55 - there is our powerful yield keyword so
196:58 - if we're gonna use comprehensions for a
197:00 - list we've seen this before we take our
197:02 - element we can do our operations to it
197:05 - we say for X in blank and then we have
197:07 - our group item here our group type so we
197:10 - run that and you can see that we do have
197:12 - a list just as expected because we have
197:15 - brackets on the outside the way that we
197:18 - make lists but if we use parentheses
197:21 - which normally would be a tuple if we
197:24 - weren't working with comprehensions but
197:25 - we have the same logic the for loop and
197:28 - the group item we end up with a
197:32 - generator interesting so that's the way
197:36 - to think about generators with
197:38 - parentheses around the outside and then
197:41 - of course we can convert them back and
197:43 - forth using our normal function our
197:46 - inner function or our list function so
197:49 - there you go just a little glance at how
197:52 - you would work with generators and
197:53 - comprehensions and now finally for my
197:56 - favorite thing fizzbuzz always reminds
197:58 - me you have a soda is that something
198:00 - from the Simpsons is Cola or something
198:03 - it is Bart Simpson drink not important
198:05 - don't stand topic can't believe I only
198:09 - had one Z and fizzbuzz that's such a
198:11 - lame error anyways it's fizz buzz with
198:15 - two Z's it's a little program a little
198:17 - test that a lot of newbies get and the
198:19 - goal is to write a program that prints
198:21 - numbers from 1 to 100 but for multiples
198:24 - of 3 it prints fizz for multiples of 5
198:27 - it prints buzz and then for multiples of
198:30 - 15 it prints fizzbuzz and sometimes
198:33 - there's little variations of that using
198:34 - comprehensions we can write it in one
198:36 - line so you look very impressive if you
198:39 - do this at your first job interview so I
198:42 - think you should play with this on your
198:44 - own and make sure you understand how it
198:46 - kind of fits together and here is what
198:49 - we're doing or at the end we're creating
198:51 - a range in here you can see a handful of
198:55 - these statements where they start
198:56 - repeating module o3 is equal to 0 and
198:59 - then we say else and then we kind of
199:01 - keep going down so here it is in one
199:03 - line boom
199:04 - visit buzz print it all in a big long
199:07 - list one two fizz for buzz five fizz and
199:12 - then seven a areata
199:13 - this is the same line we're just spacing
199:15 - it out so you can read it a little bit
199:17 - more but this is a one line solution and
199:19 - it's the same as up here but this way
199:21 - you can see it a little bit better so
199:23 - we're saying to print this and then we
199:26 - say if X is the module O 15 and that is
199:30 - equal to zero elfs and then yadda yadda
199:33 - and then else yadda yadda and then L so
199:36 - then we do this for the range 1 through
199:37 - 100 you'll see this will print the same
199:39 - thing but just a better way to look at
199:41 - it very cool very fun fizzbuzz away with
199:44 - two Z's and we are done with
199:47 - comprehensions I think it's time to go
199:50 - visit our memory palace and get a little
199:53 - crazy before we move in to the
199:55 - all-powerful section of functions
200:00 - functions functions functions functions
200:06 - functions subscribe to our new Manik
200:12 - Academy YouTube channel for daily
200:14 - uploads that will help you learn amazing
200:17 - concepts through effortless associations
200:29 - come in today's lesson we will be
200:32 - learning the how of programming by
200:34 - reviewing code examples that demonstrate
200:36 - the ways we can work with recursion
200:38 - iteration and generators so recursion is
200:42 - defined as something that calls itself
200:43 - and we're gonna look at a couple
200:45 - examples that demonstrate a factorial
200:47 - and a Fibonacci sequence return then
200:49 - using classic iteration and getting the
200:51 - same result as recursion then compare
200:53 - the difference and finally we're gonna
200:55 - talk about generators now generators are
200:57 - an entirely different type of object in
200:59 - Python and they're very powerful because
201:01 - they have the ability to generate their
201:05 - returns each sequential step which
201:07 - allows us to pause or halt the system in
201:10 - many different places and that can be a
201:12 - really powerful thing we're gonna look
201:13 - at the time it takes to execute
201:15 - generators we're gonna show a couple
201:17 - examples of generators and traditional
201:19 - looping iteration so get ready because
201:21 - this is gonna be an exciting lesson that
201:23 - hopefully is explained clearly enough
201:24 - that you don't have to iterate over it
201:26 - too many times let's start talking about
201:30 - recursion let's start talking about
201:33 - recursion let's start talking about
201:35 - recursion in the sense of factorials so
201:39 - here is what makes recursion recursion
201:41 - it has a mini version of itself inside
201:44 - of its own logic it is a tricky thing to
201:47 - get your head around but the important
201:49 - way to look at it syntactically is when
201:51 - you see the name of a function up here
201:53 - repeated again somewhere inside of the
201:56 - logic but another way to think about
201:58 - them is that they're sort of stacking on
202:00 - top of one another in sort of a pyramid
202:02 - shape so when we look for factorial 5 we
202:06 - then need to wait for a whole new
202:07 - function which is actually getting the
202:09 - input of 4 instead of 5 to find its
202:11 - answer which is then waiting for a whole
202:13 - new function which gets the input of 3
202:15 - not 5 or 4 to get its answer and then
202:18 - when it finally gets to the answer when
202:20 - it finally gets a 1 input and it gets a
202:22 - return then it solves this one which
202:25 - solves this one which solves this one
202:27 - which solves this one back up the chain
202:28 - so the way to look at this inside is
202:32 - usually with an if-else we're saying
202:34 - finally if you get to the input of 1 we
202:36 - have an actual answer for you but other
202:38 - than that we're just explaining the
202:40 - logic that's it
202:41 - get you to the answer no matter how far
202:43 - out you are from the number one and you
202:45 - can see that right here we're taking the
202:47 - number n which we're gonna put in this
202:48 - five could be any number and then we're
202:51 - multiplying it by this exact same
202:53 - function but that function is taking in
202:55 - the number five minus one and so on and
202:58 - then the next one and the next one and
202:59 - the next one let's just run this and you
203:01 - can see that each time we print it each
203:03 - time it made one of these we had a
203:05 - different print statement here so even
203:06 - though you see one print statement we do
203:08 - get it printed out five times because
203:11 - each time was a whole different function
203:13 - this whole function is inside of just
203:15 - this call to another whole function
203:19 - which has a call to another whole
203:20 - function so that is how you think of
203:23 - recursion and why it's different than
203:25 - traditional looping so now let's show
203:26 - another example instead of the factorial
203:28 - example I'm looking to create Fibonacci
203:31 - if you don't remember the Fibonacci
203:33 - sequence it's 1 plus 1 is 2 and then 1
203:36 - plus 2 is 3 and then 2 plus 3 is 5 so
203:39 - one of the ways we can do this using
203:41 - recursion is by calling a function that
203:44 - is decremented by 1 and then adding it
203:47 - to another function that's decremented
203:49 - by 2 we're running this exact same
203:51 - process we're saying to get this answer
203:53 - first put in that one and that one and
203:55 - then to get that answer put in that one
203:58 - and that one so you can see we can
204:00 - actually run this we get this thing out
204:02 - of the way you can see we could actually
204:04 - run this function multiple times so each
204:06 - one of these is a separate call but I
204:08 - wanted to show you that it does make the
204:09 - pattern if we recall the first place the
204:11 - second the third the fourth the fifth
204:13 - and so on in the list so you can see
204:15 - that we can get it that way but another
204:17 - another example of being able to find
204:18 - the actual function with some kind of
204:20 - different argument inside of the exact
204:23 - same function with the original argument
204:25 - and then something modifying it down
204:27 - there okay so that is recursion in a
204:29 - nutshell nutshell nutshell nutshell now
204:34 - let's talk about iteration because
204:36 - iteration is a more abstract notion and
204:39 - the same way recursion is it's a
204:40 - conceptual thing that goes beyond just
204:42 - Python or a single programming language
204:44 - an iteration is simply the process of
204:47 - doing something to every element in some
204:50 - kind of a sequence I always think of it
204:52 - in my head first as a list
204:54 - a list of items and you're doing
204:56 - something to all of them like if your
204:57 - actual notepad like a physical to-do
204:59 - list I consider that iteration when you
205:01 - cross out each item when they're done
205:03 - you say is this item done you do the
205:05 - logic and then you cross it out but that
205:07 - pattern of crossing out happens the
205:08 - exact same way to every element on your
205:11 - list every to do that you finish so the
205:13 - way we would define this and this is
205:15 - just a reminder that that's what the
205:16 - Fibonacci sequence output is that we're
205:18 - looking for so this function this
205:20 - iteration version of the Fibonacci
205:22 - sequence is a little bit different you
205:23 - can see that we start with two assigned
205:25 - variables a and B 0 1 1 and then we say
205:29 - for I in the range of 0 through n so
205:31 - this is going to make a list because we
205:33 - need a list to iterate over that's as
205:35 - long as the number that we input so in
205:38 - this case it's a list it's one long in
205:40 - this case it's a list that's six long
205:41 - and then what we do is we take that list
205:44 - and then the logic that we use on every
205:47 - single item is that we make the item a
205:49 - the equivalent of what was B and now we
205:52 - change B to what is a plus B and that
205:55 - does the same thing as a plus B and then
205:58 - it becomes a a plus B becomes a and we
206:02 - can do the exact same thing to get the
206:05 - Fibonacci sequence just as we expected
206:07 - the 1 1 2 3 5 8 and the 1 1 2 3 5 8 up
206:11 - here maybe that gives you a little bit
206:12 - more of a sense of what it's like to
206:13 - work with iteration versus recursion
206:16 - talk about generators this is a very
206:19 - powerful object inside of Python for its
206:22 - ability to work asynchronously for its
206:25 - ability to pause its state let me just
206:27 - show you
206:28 - traditional example of a loop that has
206:30 - the logic for squaring because we're
206:33 - gonna use this as a comparison for the
206:34 - generator 1 next just to remember how
206:36 - this works we have a function it's
206:38 - called loop squares we're gonna pass in
206:40 - these numbers and then each number is
206:42 - going to get squared by itself and then
206:45 - it's going to be appended to a list so
206:47 - we have to start with a blank list we
206:48 - have to run through each of the items
206:50 - like in the way we just talked about in
206:52 - an iterative way iteration and then on
206:55 - each iteration we are going to append
206:57 - that result and then return the final
206:59 - list when we're done so we run these two
207:01 - cells and we get exactly what we think
207:03 - it did a type check here on the return
207:05 - numbers it's a list and then
207:07 - there is the list itself so now let's
207:09 - look at how we would do that exact same
207:11 - thing with a generator in less lines of
207:13 - code and arguably in a more powerful way
207:15 - depending on your use case so this
207:17 - generator version does the same thing by
207:20 - starting a function and as the same
207:22 - inputs and we're gonna input the same
207:24 - numbers we have for I and noms which is
207:27 - the same as I here for each number that
207:28 - we have in the list and it does take a
207:30 - list we can't just put in the number
207:31 - five and it makes its own and although
207:33 - we could build it that way but the point
207:34 - is it needs a list at this point before
207:36 - the yield statement and then the yield
207:38 - statement which you haven't seen before
207:40 - a brand new key word is the equivalent
207:43 - of the logic in this case append but any
207:46 - other kind of logic to and the return
207:49 - all wrapped into one but it's a special
207:51 - type of return because it's not just
207:53 - returning any object it is returning a
207:56 - generator object the yield keyword is
207:59 - crucial for returning a generator object
208:02 - what we're saying is don't just return
208:05 - any variable like our normal return can
208:08 - we need you to send back an actual
208:10 - generator type of a variable and because
208:13 - of that we have the ability to keep some
208:16 - of the logic inside of it and execute it
208:18 - one by one so what I mean by that is
208:20 - that if we run this function and then we
208:24 - look at the output we actually have a
208:27 - generator object now remember before we
208:29 - actually got back our list and by
208:31 - printing the list we printed the list
208:33 - when we try to print the generator we
208:35 - just print something that says I am a
208:37 - generator we don't actually print out
208:39 - all of these numbers they're sort of
208:41 - unprocessed they're more raw you could
208:43 - say and the reason why they're more raw
208:45 - is because we need another function
208:47 - after that to push through each step so
208:50 - the logic for two times two which was
208:52 - done and then appended to this has not
208:55 - been done yet it's actually the logic
208:57 - two times two is inside of the yield
208:59 - statement it's inside of our object
209:01 - right here so when we say next and then
209:04 - we look at the generator object that we
209:06 - got out then we find our first result so
209:09 - the number four comes out and finally
209:11 - only at this point have we processed two
209:14 - times two so sitting in here in the next
209:17 - step in the generator is three times
209:19 - three it hasn't been done yet
209:21 - but by calling the next function we get
209:24 - it nine and so on down to sixteen so
209:26 - that's the difference is it's bringing
209:28 - in the entire logic and waiting to
209:30 - execute it until the time is right and
209:31 - there's certain reasons why working
209:33 - asynchronously is powerful like
209:35 - something with a server where you're
209:37 - waiting for a response from someone or
209:39 - there's some kind of thing that needs to
209:41 - happen before the logic is processed so
209:43 - you can see how powerful they are
209:45 - another thing about them is supposedly
209:48 - they're a lot faster okay now I'm gonna
209:50 - be real upfront that these tests are not
209:52 - demonstrating what I read think I'm on
209:54 - the right track when guiding you this
209:56 - way but I want you to be aware that I'm
209:58 - not solid on exactly why these times are
210:00 - coming out the way they are when we use
210:02 - our timer function in Jupiter what we'll
210:04 - see is the amount of time it takes to
210:07 - create this function and then down here
210:09 - how much time it takes to call it and
210:11 - they're doing the same thing they're
210:13 - both processing the same list the
210:15 - numbers 2 through 6 and they're doing
210:17 - the same logic the multiplication here
210:20 - so arguably one of the main reasons you
210:23 - would use a generator is because it
210:24 - saves time it's not gonna be as
210:27 - computationally heavy it doesn't need to
210:29 - run through the entire list you can run
210:32 - through it piece by piece on an
210:33 - as-needed basis but beyond that I
210:36 - actually thought that doing the
210:37 - generator by itself would be faster like
210:39 - it's just a more efficient way all
210:41 - around to handle it but with a use case
210:44 - this small it comes out to be about the
210:46 - same amount of CPU cycle so you might
210:48 - not see it but I did want to show you
210:50 - how we could run something like this so
210:52 - you can see up here on the wall time it
210:53 - took 3.1 this is M us which I'm gonna
210:56 - assume is milliseconds but I'm 100% sure
210:58 - on that but 3.14 up here and then it
211:02 - took 3.14 down here so creating the
211:04 - function putting the yield logic
211:06 - together or in this case running the
211:09 - loop and appending all the logic to the
211:11 - answer they took the same amount of time
211:13 - but now when it actually comes to
211:15 - calling the function down here and
211:18 - processing the list you'll see that it
211:20 - took 5.1 and down here it only took 4.05
211:24 - so even though we have all of these
211:26 - calls it's kind of amazing like next
211:29 - generate object next generate object
211:31 - which we think take more time it's like
211:33 - starting and stopping all of this over
211:35 - and over again you know they do come out
211:36 - being more efficient as a whole so my
211:39 - point is if you're gonna be working with
211:40 - a gigantic data set and down the road
211:42 - when you're you know a real high paid
211:44 - programmer and you're doing crazy stuff
211:47 - with big data sets you should revisit
211:49 - the concept of whether you should use a
211:51 - generator and see if there might be ways
211:53 - to get more computational gains out of
211:55 - it as a beginner it's not a thing to
211:57 - worry about but it is a thing to know
211:58 - that there is time differences between
212:00 - the way we write code just one more
212:03 - example it's just a different version of
212:04 - kind of what we started with but I want
212:06 - to make sure that you see the difference
212:08 - in the yield statements and I found out
212:10 - that surprisingly my name backwards is
212:12 - super cool and I was really proud of
212:15 - that and wanted to share it with you we
212:16 - have a couple of different functions
212:17 - here one that's going to use a generator
212:20 - and one that's going to use a regular
212:21 - loop so in this one we're gonna be
212:24 - importing a string of characters in fact
212:27 - my name DUI LAN it's gonna be an
212:30 - argument that passes through here we're
212:32 - gonna get a number from this the amount
212:34 - of letters minus one so we have we have
212:36 - five characters here so this is gonna
212:38 - return the number five but then we're
212:40 - gonna decrement it by one so we end up
212:42 - with four in here here we're gonna
212:44 - create a brand new list an empty list
212:46 - with no items inside of it and then
212:48 - we're gonna make a loop and we're gonna
212:50 - say while the count and this count
212:52 - appears four is greater than negative
212:55 - one then I want you to append something
212:59 - to this list and that thing that you'll
213:02 - be appending is the text count so it
213:05 - will be this and then in the slicing
213:08 - bracket it will be this count so it'll
213:10 - start with five and then four so what
213:14 - it'll be doing is appending that letter
213:16 - than that letter then that letter each
213:18 - to this list so this list is going to
213:20 - grow from being empty to being this but
213:22 - it's gonna work backwards and reverse my
213:24 - name and then just to make sure that our
213:27 - while loop does eventually end we take
213:30 - this count variable here and we
213:32 - decrement it by one using our shorthand
213:35 - notation our shorthand assignment
213:36 - notation right there
213:37 - because this is a word this is a string
213:40 - we want to create a blank string called
213:42 - new and we want to join this new list
213:45 - unto here but we totally could just
213:47 - return the list
213:48 - - but it just makes more sense living in
213:50 - this case to make it a string Dillon
213:53 - backwards is nailed like my name is
213:56 - nailed like nailed it Dillon pretty cool
213:59 - I think let's look at it in generator
214:01 - version so here we have the same thing
214:04 - reversed we're gonna pass in an argument
214:06 - we have the exact same argument except
214:08 - we're making it into a generator and
214:09 - then running through each part of the
214:11 - generator using an outside for loop our
214:14 - inside for loop here meaning inside of
214:16 - our function so this is quite a bit
214:18 - different looking but I wanted to
214:19 - compare the two so you could see that
214:21 - they actually could be interchangeable
214:22 - we could use a for loop up here instead
214:24 - of a while loop it would just look
214:26 - different so I wanted you to maybe play
214:28 - with these two and kind of get your head
214:29 - around why they're different but why
214:31 - they kind of work the same and here
214:32 - we're taking that same string that comes
214:34 - in my name dy LAN and we're breaking it
214:37 - down into how many letters it is using
214:38 - the Len function so we end up with five
214:40 - and then we are - sing one in the same
214:42 - way we did in the same way we did up
214:44 - here so we end up with four but then
214:46 - you'll notice these other two minus ones
214:48 - which are pretty unusual
214:50 - so these allow it to loop around and
214:53 - then also to skip in increments of one
214:55 - so if you remember back to when we
214:57 - worked with our range function in loops
214:59 - the range had a start a stop and it had
215:04 - a step function so we can use all of
215:07 - those in this to create the kind of
215:08 - range that we need so a little bit
215:10 - different than the count approach but it
215:12 - works and then when we're in here we do
215:14 - a very simple piece of logic instead of
215:16 - needing a pend which is only a method of
215:18 - the list out that we had before we can
215:21 - just yield the logic itself which is
215:23 - slice this right up and then put this
215:25 - into a yield statement piece by piece so
215:27 - we can get it out later
215:28 - so when we run this you'll see that we
215:30 - get the exact same thing and in this
215:32 - case we're getting it back out as a
215:33 - generator so we don't need it as a list
215:35 - or a string but you can see it totally
215:37 - worked so we ran the function we saved
215:40 - the return into it generator because we
215:43 - know it's a generator object and
215:44 - generator objects can be looped over so
215:47 - we just said for I in Jen print I and
215:49 - then all of a sudden you get nailed
215:52 - thanks
215:53 - nailed it all right you lovely generator
215:56 - people who know about recursion and
215:58 - iteration thanks for listening and enjoy
216:00 - the next lesson
216:02 - subscribe to our no Manik Academy
216:05 - YouTube channel for daily uploads that
216:07 - will help you learn amazing concepts
216:09 - through effortless associations welcome
216:23 - in today's lesson will be discussing the
216:25 - why of programming by reviewing
216:27 - mnemonics and having a discussion that
216:28 - relates to the following topics our
216:31 - first topic is going to be debugging
216:33 - we're gonna talk about what a bug is the
216:35 - difference between bugs and features in
216:37 - the surprisingly gray area and then
216:39 - we're gonna talk about what the action
216:40 - of debugging actually looks like then
216:42 - we're gonna move over to something
216:43 - called a stack trace we're gonna talk
216:44 - about what that is how to read the stack
216:47 - trace and what it means we'll talk about
216:49 - exceptions
216:50 - what are exceptions we'll talk about the
216:53 - difference between a syntax error and an
216:56 - exception and then to follow up on that
216:58 - will talk about exception handling we'll
217:00 - talk about what that means why it's
217:02 - different from regular exceptions we'll
217:04 - talk about the keywords raised and
217:06 - finally we'll talk about what the
217:08 - keyword raised actually does and what
217:10 - the keyword finally actually does so
217:13 - remember that there's only 12 giant
217:15 - pandas in captivity in the United States
217:17 - it's really not that many so our first
217:22 - pneumonic today is going to be a
217:24 - wonderful ladybug and it's gonna
217:26 - represent the topic in general of
217:28 - debugging and the reason I chose the
217:30 - ladybug for our mnemonic is because it
217:32 - has the word bug in its name and it is a
217:34 - bug it's double bugged just like some of
217:37 - your code might be so what is a bug well
217:40 - a software bug is an error flaw failure
217:43 - or Fault in a computer program or it's
217:46 - system that causes it to produce an
217:48 - incorrect or unexpected result or maybe
217:51 - even just to behave in unintended ways
217:53 - and because unintended ways can be hard
217:56 - to define it's the same reason why bugs
217:58 - and features come in many shades of gray
218:00 - if you don't clearly define the
218:02 - functionality that you want to achieve
218:04 - sometimes a bug becomes a feature or a
218:06 - feature becomes a bug so what is the
218:09 - action of debugging well debugging is
218:11 - the process of smoothing out these bugs
218:14 - or replacing the parts that
218:16 - broken once you have a clear definition
218:18 - of the functionality you want when that
218:20 - functionality always occurs you have a
218:23 - bug-free code but it almost never
218:25 - happened because there's so many use
218:26 - cases that you can't predict so
218:29 - debugging is a spectrum and it can be
218:31 - easy it can be as simple as a print
218:34 - command that prints a variable at a
218:36 - certain point in the program and you
218:37 - notice that it's wrong and make a quick
218:39 - fix or it can be as complicated as
218:41 - introducing new complex debugging code
218:44 - which just tests for subtle changes
218:47 - between your expected outputs and your
218:50 - true outputs and there can be so many
218:52 - layers to this both nested inside of
218:54 - functions instead of functions or in
218:56 - simple decision tree style complexity
218:59 - where you have conditionals that are
219:00 - layered on top of each other so there's
219:02 - a big spectrum to debugging so our next
219:05 - pneumonic is going to be a giant Ginga
219:08 - and it's gonna represent the topic of a
219:10 - stack trace and the reason I chose this
219:12 - giant Jenga game is because the process
219:15 - of playing that game Jenga is sort of
219:18 - similar to a stack trace in the sense
219:20 - that we're looking up and down this pile
219:23 - right we're analyzing which pieces can
219:26 - be separated which pieces can be moved
219:28 - and we're guessing how that's gonna
219:29 - affect the balance of the overall
219:31 - structure and in the same way we're
219:32 - looking up and down this code trying to
219:35 - imagine how it's going to affect the
219:36 - overall output so what is a stack trace
219:39 - well a stack trace is a report it's a
219:41 - report at certain points in time during
219:45 - the execution of a program so it's gonna
219:47 - take each line like a step and we're
219:50 - gonna be able to see a list of the
219:52 - method calls but the application was in
219:54 - the middle of when the error occurred
219:57 - aka an exception was thrown let's talk
220:01 - about how to read the stack trace
220:02 - because not every bug will have a stack
220:04 - trace but many do and if they do this
220:06 - means that the bug is not on the surface
220:08 - level of your code but instead it's
220:10 - wrapped up deeper down and by deeper
220:13 - down I mean that the order of the code
220:15 - that it's compiled in has different
220:17 - layers to it and our bug might not be on
220:20 - the top surface layer so it could be
220:22 - deeper in scope like inside of a
220:24 - function or it could be deeper in the
220:27 - source modules being imported so it's
220:29 - of starting at the top of our code we
220:32 - just start with our topmost method call
220:34 - and then often this will get our
220:36 - attention close enough to the problem
220:38 - that we can work through the rest
220:42 - so our next pneumonic is going to be
220:44 - China's red flag and the reason why this
220:47 - represents the topic of exceptions is
220:50 - because it's literally a big red flag
220:53 - that you can remember and exceptions
220:55 - should be thought of as red flags that
220:57 - need to be addressed so what is an
220:59 - exception well imagine if somebody
221:00 - passed in a string argument when your
221:02 - function only works with integers
221:04 - exception handling is how you deal with
221:07 - this so what's the difference between a
221:09 - syntax error and an exception
221:11 - well syntax errors which are also known
221:14 - as parsing errors these are syntax
221:17 - problems and I think of them similar to
221:19 - just misspellings or typos you probably
221:22 - just type something in wrong and if you
221:24 - look closer you'll see that you're
221:25 - missing a semicolon or something like
221:27 - that
221:27 - but even if a statement or expression is
221:31 - syntactically correct it may still cause
221:33 - an error and in those cases you have an
221:36 - exception and the reason I chose this
221:39 - for the mnemonic is because in the same
221:41 - way that a practical joke works
221:42 - exception handling is all about bringing
221:45 - attention to the unexpected so what is
221:47 - exception handling well exception
221:49 - handling is about making sure that we
221:51 - have variables that don't break our code
221:53 - in some way so this is gonna be similar
221:55 - to how we had our conditional section
221:57 - before we're gonna want to do exceptions
222:00 - to make sure that our variables are what
222:02 - we expect they are at the right times
222:04 - exception handling is a process of
222:06 - responding to an unwanted action during
222:10 - either the compile time or the run time
222:12 - which we'll talk about in a second so
222:14 - we're gonna want to know a couple of key
222:15 - words for this specifically the key
222:17 - words try and accept going back to the
222:19 - conditionals these are very similar
222:21 - pythor's us these conditional type
222:23 - keywords to help us find where our code
222:26 - goes wrong in the sense of a variable
222:29 - not being what we expect it to be let's
222:31 - zoom in on this try keyword so kind of
222:33 - like our conditional that had an if
222:35 - statement where we could say is
222:36 - something equal to some variable our try
222:39 - statement is going to check to see if
222:41 - the exception is the
222:42 - type that it expects so remember when we
222:44 - have an exception there is already a
222:46 - type that it can have when we downloaded
222:49 - Python many of these exceptions already
222:51 - exist we can add a few more but there's
222:53 - already dozens and dozens they come with
222:55 - Python so that's what we're gonna be
222:56 - checking for and we have a few options
222:59 - we can try with no exception we can try
223:02 - with a match type so the exception we
223:05 - get matches the one that we're telling
223:06 - it to look for or we can try with a type
223:09 - mismatch meaning if it's anything except
223:12 - the one that we want so let's talk about
223:13 - trying using the keyword try with no
223:16 - exception so first the statement between
223:19 - the try and the accept keywords are
223:22 - executed probably able to see this
223:24 - better in the next video when we're
223:25 - actually looking at code examples but
223:27 - you can imagine it a lot like our if
223:29 - statement from before and then if no
223:31 - exception occurs the except Clause is
223:33 - skipped entirely and the execution of
223:36 - the try statement it's finished and we
223:39 - also have try with a type match so in
223:42 - this case if an exception occurs during
223:44 - the execution the rest of the Clause is
223:46 - skipped and then if it's type matches
223:48 - the exception named after the accept
223:51 - keyword the except Clause is executed
223:53 - and then the execution continues after
223:56 - the try statement and then finally
223:58 - there's try with a type mismatch and
224:01 - sort of the opposite to the others if an
224:03 - exception occurs which does not match
224:05 - the exception type named
224:06 - in the except Clause then it's passed on
224:10 - I feel like I feel like you'll probably
224:12 - understand that better in the next
224:13 - lesson so you know I said the things
224:16 - right I think it's like all over the
224:18 - place until you sort of see the spacing
224:20 - and stuff so roll with it in the next
224:22 - video so now let's talk about a couple
224:24 - more keywords that go along with that
224:26 - and we're gonna use the pneumonic of a
224:27 - cosplay woman raising her sword and it's
224:31 - gonna represent raise and finally two
224:34 - more keywords that we're gonna use for
224:35 - debugging and the reason I chose her is
224:38 - the mnemonic is because when you see
224:39 - someone looking at you and then they
224:41 - raise that sword you know something's
224:44 - wrong and these will tell you
224:47 - something's wrong to just these are
224:49 - exceptions that one means you're gonna
224:51 - get killed okay so what does the keyword
224:53 - raise do it's focusing on that one first
224:56 - so raise is a way to override the
224:58 - default exceptions in a way that we want
225:00 - so what does the raise keyword do so
225:03 - let's focus in on that now the raise
225:05 - keyword is a way to override the default
225:07 - exceptions in any way that we want so we
225:09 - can display information that we need to
225:12 - to other developers and to users so I
225:14 - mean in a nutshell raised just allows us
225:16 - to define our own type of exception
225:18 - errors and really you don't need this
225:20 - too often Python has the main ones
225:22 - already built in but every once in a
225:24 - while you have a special use case where
225:25 - it's good to know that you can do this
225:27 - now how about the keyword finally what
225:29 - does that do well we can use the finally
225:32 - statement to ensure that a block of code
225:34 - is closed at the end of the file even if
225:36 - there is an exception that causes the
225:38 - interpreter to break so we have
225:40 - something that stops right in the middle
225:42 - of the code but we still need the code
225:44 - to jump to the bottom and close
225:46 - something up or release something to
225:49 - make sure that it actually is pulled
225:50 - away in the correct way kind of I kind
225:52 - of imagine like on your computer when
225:54 - you like pull out a USB stick without
225:55 - clicking the thing and it's like uh like
225:58 - that's the way you can think about this
225:59 - so times when you might want to do
226:01 - something like this is when you need to
226:03 - close out an Open File at the very end
226:05 - of your program or something like that
226:06 - and for a final pneumonic I want to
226:09 - group together some of these exceptions
226:12 - into runtime and compile time exceptions
226:15 - so our mnemonic a marathon runner and I
226:18 - chose a marathon runner for the run time
226:20 - and compile time because a marathon
226:22 - runner is keeping track of their
226:24 - runtimes like on their watch and then I
226:26 - also think of the compile time is maybe
226:28 - the big number thing that you'll see at
226:31 - the end of like runners there big finish
226:32 - line number you know and also I kind of
226:35 - think compile time sounds similar to a
226:37 - mile time so you might want to think of
226:38 - it that way too but that's up to you so
226:41 - now let's talk about grouping these
226:42 - errors into two different groups one for
226:44 - runtime and one for compile time now
226:46 - studying with compile time this is when
226:48 - we're first executing the code on RN not
226:50 - when the user is actually using it
226:52 - compile time errors happen when we feed
226:54 - in a whole bunch of text to the compiler
226:56 - it's reading the code that we just wrote
226:58 - and it's converting it behind the scenes
227:00 - into machine code ones and zeros so
227:04 - these compile time errors are usually
227:06 - syntax errors meaning we type something
227:08 - wrong they're typed
227:10 - keen errors like where we use a variable
227:12 - that's say type string but we're using
227:14 - it like it's a type integer and it
227:15 - doesn't know what to do and then in rare
227:17 - occasions that never happened to me but
227:19 - when I read the documentation I said it
227:20 - happen there's compiler crashes where
227:23 - you just have to like shut your IDE down
227:25 - or the Jupiter notebook breaks in our
227:27 - situation okay and then there's also the
227:29 - runtime errors and these are the errors
227:31 - that will be used when somebody else
227:33 - brings up our program and there could be
227:34 - say a division by zero meaning somebody
227:37 - put a zero into our code from the user
227:39 - end and it did something weird broke
227:41 - gave us an error great staying with me
227:44 - on this lesson so let's end with a quick
227:46 - summary of the mnemonics that we just
227:47 - learned and the concepts that they
227:49 - represent now our first mnemonic was a
227:51 - ladybug and it represented the topic of
227:53 - debugging in general we learned that
227:56 - bugs are pieces of code that produce
227:57 - unexpected results we learned that bugs
228:00 - and features come in many shades of gray
228:02 - and we learned that debugging is the
228:05 - process of smoothing out these bugs once
228:07 - you have a clear definition of the
228:09 - functionality that you want next we
228:11 - learned the mnemonic of a giant Jenga
228:13 - set and it represented the topic of a
228:15 - stack trace and a stack trace is a
228:18 - report and this report can point to
228:20 - different points in time as the computer
228:24 - compiles our code and some different
228:26 - techniques to read this stack trace and
228:28 - understand it and our next pneumonic was
228:30 - a giant Ginga and it represented the
228:32 - topic of a stack trace and we learned
228:34 - that a stack trace is a report and it's
228:36 - a report that talks to us about our code
228:38 - in different points in time as it moves
228:41 - its way down the code from top to bottom
228:43 - and then we talked about some of the
228:44 - techniques to look at the stack trace
228:46 - and get some intuition about what might
228:48 - have gone wrong then we learned the
228:49 - pneumonic of China's big red flag which
228:52 - represented the topic of an exception
228:54 - and we learned that exceptions occur
228:56 - even when we have written our statements
228:58 - correctly and it often has to do with
229:00 - what's inside of our variables after
229:02 - that we learned the mnemonic of one of
229:03 - those hand buzzers that like a clown
229:05 - would have or the Joker and it
229:07 - represented the topic of exception
229:09 - handling it's how to handle those red
229:11 - flags and we learned that exception
229:13 - handling is the process of responding to
229:16 - the unwanted actions either during
229:18 - compile time or during run
229:20 - and then we learned the mnemonic of a
229:22 - warrior princess as she raised her sword
229:24 - and it represented the keyword raised
229:26 - and the keyword finally and zooming in
229:29 - on them we learned that raise is a way
229:31 - to override the default exceptions in
229:33 - any way that we want so we can display
229:36 - information that we need to the users
229:38 - and other programmers and then we
229:39 - learned about the finally keyword which
229:41 - lets us run a special block of code at
229:43 - the end of our file which helps us
229:44 - either disconnect from a server or close
229:46 - out a file or something else that might
229:48 - cause a problem if we don't make it all
229:49 - the way through our code and our final
229:51 - mnemonic was a marathon runner who is
229:53 - keeping track of their run time and also
229:55 - looking at their final time on the
229:58 - finish line and this represented our run
230:00 - time and compile time errors so we
230:03 - learned some of the things that would
230:04 - happen at the different times and which
230:07 - kind of errors would be grouped into
230:08 - which ones and then our final mnemonic
230:11 - was a marathon runner and he was keeping
230:12 - track of his run time and then also his
230:15 - finish line time and this represented
230:18 - our run time and compile time errors and
230:20 - then we talked about how different
230:22 - errors can fall into these two different
230:24 - groups so I think we've had enough
230:26 - theory for now why don't we pull up our
230:28 - old trusty Jupiter notebook and start
230:30 - looking at some of these examples in
230:32 - code subscribe to our new Manik Academy
230:36 - YouTube channel for daily uploads that
230:38 - will help you learn amazing concepts
230:40 - through effortless associations
230:50 - you