With timestamps:

00:00 - How's everyone doing, this is Carlos here with Codecademy with another lesson on Visual Studio and Razor Pages.
00:06 - Now creating an application from start to finish and expecting it to compile without
any errors is extremely unlikely.
00:13 - Making mistakes when programming is simply part of the process.
00:16 - Today, we're going to learn different ways to detect and 
remove existing potential errors in your code.
00:22 - Now when it comes to debugging, Visual Studio shines with its lengthy list of tools that we can use to track and remove any bugs in our code.
00:29 - Today, we'll be exploring how to use breakpoints, how to step into, over, and out of functions, and how to quickly navigate around our project.
00:37 - We'll also be taking a look at different kind of debugger windows that provide us with very useful information. So without further ado, let's go ahead and get started.
00:45 - Okay, so I have a small application here, and the first thing we're gonna do before we start diving into the code is to check what version of Visual Studio we're running.
00:54 - We can do this simply by clicking on the visual studio tab on the upper-left corner, and then going into about Visual Studio.
01:02 - Here, you'll see the information about the Visual Studio that you're running,
01:06 - you can see in my case, I'm using the Visual Studio for Mac Community Edition and I'm using the latest build at this moment, which is built 7 or version 8 point 5 point 5.
01:17 - Now if you want more details you can click on show details, which will give you more information on what frameworks and runtimes were installed.
01:24 - You can see how the dot net core runtime and the SDK installed.
01:30 - And if you're in a Windows machine, you can check the information about Visual Studio by clicking on help, and then going down to about Microsoft Visual Studio,
01:40 - and you'll find information about the Visual Studio version,
and other tools and frameworks you have installed.
01:47 - Back in our application, you'll see I have the generated pages and other folders and files that were created when we created a Razor Pages application.
01:56 - So you'll see I have an About page along with the page model for it, and inside the page model, we'll see a few functions that I wrote that we'll be working with.
02:05 - We'll be moving around these functions using Visual Studios tools, like the breakpoints, but we need our application to run first before we do so.
02:13 - This means our app needs to be compiled and built in order to actually run.
02:17 - So let's take a look at what it means to actually build a project 
and the different ways we can build in Visual Studio.
02:23 - With Visual Studio, we're able to build, rebuild, and clean a project.
02:27 - Now with building, this means that we compile the source code to produce dot exe and dot dll assembly files, which we'll look into in a minute.
02:37 - So we can build a project by clicking on the build tab, and then selecting build all.
02:43 - This will compile our human-readable code into machine-readable code,
so that our computers can run it.
02:50 - The machine-readable code is organized into files called process assembly files, which have a dot exe file extension,
02:57 - and library assembly files, which have a dot dll extension.
03:02 - So if we open up our project in our finder,
03:07 - and navigate into the project directory, we'll see that we have a bin and an object folder created for us.
03:13 - And if we take a look at the bin folder, and navigate into 
the project, and into netcore app 3.1, we'll see the library assembly files created for us.
03:24 - Now if you're using Windows, you will also find the executable files,
which have a dot exe extension.
03:31 - In this case, we'll find dot dll files along with some dot json files 
that contain some configuration for our project,
03:38 - and we'll also find pdb files, which stand for program database files.
03:43 - And pdb files, essentially, contain information for the debugger to work with.
03:48 - So initially, for the first build, the entire project is built.
03:52 - All consecutive builds are treated as incremental builds, meaning that code is compiled, and if any changes are found in the file,
03:59 - the ID is smart enough to know to only build that file instead of 
building everything again.
04:04 - Now we can also clean our project.
04:07 - Cleaning the project removes intermediate and output 
files from the object in bin project folders.
04:13 - Let's say we want to clean our project. So we can take a look at the current files found in our bin folder netcore app 3.1,
04:20 - we'll see that we have our json files, our dll files, and our pdb files.
04:26 - So if we go to build, and then Clean our DebugApp,
and then go back into our actual project directory,
04:39 - and then navigate straight into our bin folder, debug netcore app 3.1,
we'll see that all our files have been removed.
04:48 - Lastly, you can also rebuild a project.
04:51 - The way rebuild works is we first clean the project, 
and then build a solution from scratch,
04:57 - and it says the project is cleaned prior to running the build command, and all intermediate and output files are removed prior to the build.
05:04 - We end up building the project from scratch with this one rebuild command.
05:08 - And rebuilding a project is very useful when we want to preserve the integrity of the build and ensure that no output files are stale,
05:16 - if we introduce multiple dependencies over an extended period of time.
05:20 - So hopefully that gave you a better understanding of what 
happens when we run our application.
05:25 - Okay, so before we start debugging our app, let's take a quick look at our About page model, and see what functions we have created, and what we'll be doing here.
05:34 - First, we'll see here on line 13 that I have a public property of data type string called Message with a getter and setter.
05:41 - Inside our on get method here, we're assigning "Hello" to that same property.
05:46 - And right after assigning "Hello" to it, we're reassigning a new 
value to it using the add to message function.
05:54 - The AddToMessage function takes an array of three elements, 
and then returns a new value from it.
06:01 - So if we jump to the AddToMessage function, we'll see what's 
happening with that method.
06:05 - AddToMessage is a private method that takes in a string array 
and creates a new string called result.
06:11 - So you'll see we start out with an empty string assigned to 
result, then we loop over the array that's passed into the method,
06:18 - and append each element from the array to that result variable, 
which it starts out as an empty string,
06:24 - then after the first iteration, it will add the first element with a new line,
then the second element with another line,
06:31 - and then the third element with another line.
06:34 - Once the loop is done, we're using a function created, ReplaceToUpper, that takes in that string and we can look down here on line 41
06:45 - that it converts the whole string into uppercase.
06:48 - Lastly, we have a divide by 0 method. In this method, we have a try and catch statement, where it attempts to divide by 0 in the try clause,
06:57 - and the catch clause simply logs a message into the debugger.
07:01 - So now we can get into the meat of the video.
We're going to start by looking into Breakpoints.
07:07 - Now a Breakpoint indicates where Visual Studio should suspend your running code,
so you can take a look at the values of variables,
07:14 - or the behavior of memory, or whether or not a branch of code is getting run.
07:18 - We can place a Breakpoint right next to a line number.
07:21 - So in our application, I'm going to go ahead and add a breakpoint in our on get function, where I assign the string "Hello" to the property message.
07:29 - From here, we have a few options on how to run our application with debugger, we can go to run and select start debugging,
07:37 - you can also click the play button here, which has a debugger that will open and launch our application on a Google Chrome tab.
07:43 - So I'm going to go ahead and click the play button here, and this should run a build, and then run and execute our application.
07:53 - Once the build is successful, our application should be launched
in a new Google Chrome tab.
07:58 - And a shortcut on a Mac to run the app with the 
debugger would be alt and command and enter.
08:06 - On a Windows machine, there are a few ways you can start your application with a debugger, you can go to the debug tab up here, and select start debugging,
08:14 -  the shortcut for it would also be f5, or you could click on the play button here
on the upper-right corner.
08:22 - So once we've run the application with a debugger, we can navigate to the About page, and from there, we'll be taken to our breakpoint location.
08:30 - So I'm going to go ahead and click on About, and we'll be taken to the breakpoint location where our code has been suspended.
08:38 - Once we're here, we'll see that a few windows have popped up for us.
08:41 - You have the locals error, breakpoints to watch, and the threads window.
08:45 - So if we go into the locals window, we'll see some information displayed on local variables and objects based on the current context or the local scope.
08:53 - Since we're in the About model, we'll see variables from that model,
and the model it inherits, which is the Page model.
08:59 - So the keyword this is in context to that actual model.
09:03 - So if we open up this drop-down, we'll see a bunch of properties and built-in functions that belong to the About model and the Page model class.
09:12 - The second line here will see our property message, which has 
a value of null, which makes sense because our code has suspended,
09:19 - so this line 17, where we assigned the string "Hello" to Message,
hasn't been actually executed yet.
09:24 - Now when it comes to Breakpoints, Visual Studio is very useful in providing us with three different types of actions that we can use on Breakpoints.
09:33 - First thing we could do is step into which runs the next statement so 
if the current line contains a function call  
09:39 - step into steps into that function the shortcut 
for this command on a Mac is shift command and I  
09:45 - and on Windows it is f11 we could also step over 
which runs the next statement without stepping  
09:51 - into functions or methods in the shortcut for this 
on a Mac is shift command and o and on Windows it  
09:57 - is f10 and lastly we could step out of which 
advances the debugger all the way through the  
10:02 - current function and it continues running code 
and suspense execution when the current function  
10:07 - returns the shortcut for this on Apple is shift 
command in U and on Windows it is Shift + f11 back  
10:14 - in our application we can find options for these 
commands here at the top of our tab so let's go  
10:21 - ahead and jump over into the next statement which 
is found here on line 19 where we reassign message  
10:27 - so next to the play button I'm gonna go ahead 
and click on step over which will direct us to  
10:32 - the next statement here on line 19 and now if we 
take a look at our locals windows we'll see that  
10:38 - message now has a value of hello because a line on 
line 17 was actually executed now here on line 19  
10:45 - were making a call to the function add to message 
so we want to take a look at what's happening in  
10:50 - there we could step into that function so let's 
click on the step into action button and then  
10:56 - we'll be taken to the function definition you can 
see by our cursor here indicated that we're now  
11:01 - in this code lock since the method now has actual 
scope we could also click on the parameter to see  
11:09 - what values were passed in so we click here 
on text we'll see a little drop down of text  
11:14 - that contains an array containing three string 
elements so we can actually open it up and see  
11:19 - the values that were passed into that method and 
now that we have local scope in this function we  
11:24 - can actually go into our locals window and find 
the variable text in there with some information  
11:29 - regarding its value we could also find it here on 
our watch window so we'll be going to this watch  
11:37 - window we'll be able to track down any variables 
that we care about and see how they change while  
11:43 - we're debugging our application so we can add 
any kind of variable or i-10 that we'd like so  
11:49 - I can double click here and that message and 
you'll see the value being populated so I can  
11:55 - also add another one I'll add text to see what the 
value of it is and you'll see that it's actually  
12:02 - an array containing three string elements so 
the watch window is very useful in letting us  
12:07 - track how these variables change or even seeing 
any expression being generated you can actually  
12:13 - type in any kind of expression here and it will 
return us a value so let's write out a string  
12:19 - that displays the first element in the text array 
so we'll type in tuck 0 is and then I'll type out  
12:26 - and access the first element in the text array and 
then we'll see that the value has been populated  
12:31 - for us it's also useful to point out if you're 
on a Windows machine you can simply highlight  
12:37 - and drag the variable into your watch window so 
now let's take a look at the call stack now the  
12:46 - call stack shows the order in which methods and 
functions are getting called and it's a good way  
12:51 - to examine and understand the execution flow of 
an app so if you place a breakpoint in a replace  
12:57 - to upper method here where we return text dot to 
upper we can actually continue this and see the  
13:03 - call stack now you won't see the call stack here 
and if you by any chance closed any of these tabs  
13:08 - you can find them like going on to view going to 
debug pads and then you'll see the windows that  
13:14 - are useful for debugging so I'm gonna go ahead and 
click the call stack and it should show up here  
13:18 - so I'm gonna head expand this a little bit more 
scroll down so now if we continue and I click on  
13:26 - run well we take in and shown the call stack which 
is basically either line of execution so we start  
13:34 - here on line 19 as indicated where we make a call 
to add to message then we're taken to the add to  
13:41 - message function and then from here you can see 
that it's highlighted we're making another call  
13:45 - to another method called replace to upper which 
starts out here and a function definition and  
13:50 - then finally it returns the text in uppercase so 
our code is suspended here at the moment meaning  
13:56 - it hasn't returned anything but if I click run 
again our call stack should be cleared since or  
14:01 - returning a value from that method so let's take 
another look at how the call stack actually worked  
14:06 - so we started our on get method within that 
method we're making a call to add to message  
14:12 - so the add to message function call is added to 
the call stack within the apt in message method  
14:18 - were actually making another call to a method 
called replace to upper so from there replace  
14:23 - to upper is added to the call stack as well and 
once a value is returned from replace to upper  
14:29 - our call stack is clear so we're essentially three 
lines deep into our line of execution before we  
14:34 - return a value so I'm going to go ahead and close 
the call stack window and now we can look at the  
14:40 - output window now the output window displays 
status messages for various features and IDE  
14:47 - and it helps us track of what's happening while 
the application is running well find certain logs  
14:52 - of applications running what port were running 
our application on or packages being installed  
14:58 - or updated but we can use it ourselves to actually 
log out certain information whenever we hit a line  
15:03 - of code if we take a look at our divide by zero 
method call here we're attempting to divide an  
15:09 - integer by zero which throws an exception we can 
then cast the exception and write to the line a  
15:15 - custom message so when we continue the application 
if we look on our on get method we notice that we  
15:21 - made a call to divide by zero on line 24 since 
we know it's not possible to divide by zero we  
15:27 - caught the error the exception and send a custom 
message to our output window as you can see we're  
15:33 - using string interpolation to actually display the 
message and you can see that it's out put it here  
15:38 - in our output window where it says oops attempted 
to divide by zero so one other a handy tool we can  
15:44 - use is to set conditionals and our breakpoints so 
instead of hitting a specific break on every time  
15:50 - we run our application we can create a condition 
to only hit it if a certain expression is true so  
15:57 - let's say we only want to stop at this breakpoint 
if the string argument your text contains a word  
16:02 - first I can do that by right clicking on the 
breakpoint and then editing the breakpoint  
16:07 - from here we can specify that the variable 
text should contain the word first well have  
16:18 - some other options provided for us but we want to 
place an advanced condition to only stop at this  
16:23 - breakpoint if the text contains the word first 
so we can click on apply and now that condition  
16:29 - should be applied to the breakpoint so let's go 
over ahead and go through the process of debugging  
16:34 - our application again and let's see if we actually 
land on that breakpoint now so this should launch  
16:41 - our application once more we go ahead and click 
on about well land on the first one where we have  
16:48 - the message equal to hello and we'll continue 
to the next one and you'll see that we actually  
16:53 - land on that breakpoint now if I were to actually 
change the condition for that breakpoint where it  
17:01 - contains something that is not in that so I'll 
type in second and apply that condition and then  
17:07 - we go over the process again let's go ahead and 
launch your application going to about since that  
17:13 - condition will be equal to false then we should 
not land on that breakpoint let's go to about  
17:20 - well land on the first breakpoint and if we click 
run and continue you'll notice that we actually  
17:26 - don't we skip that breakpoint and we go straight 
and to divide by zero which logs out the message  
17:32 - oops attempted to divide by zero now let's take a 
quick look and see how we would do this on Windows  
17:38 - on a Windows machine sending a conditional on 
a breakpoint is a little bit different let's go  
17:45 - ahead and place a breakpoint where we returned the 
text and upper case and right click then you go to  
17:51 - conditions and from here we can set any kind of 
condition that we like so let's add a condition  
17:56 - where we only want to hit the breakpoint if the 
text contains the keyword first and then you'll  
18:01 - see some configurations on the breakpoint and 
you'll also notice a plus sign and the breakpoint  
18:07 - indicating that a conditional has been applied 
to it so this feature is specially useful when  
18:14 - one is trying to catch a condition that may only 
occur once out of many passes and where we want  
18:19 - to save time and not break on each pass to check 
for a value that we're looking for okay now let's  
18:25 - move on to the error window now c-sharp is very 
specific with the syntax so let's say we forget  
18:33 - to add a semicolon I'm gonna remove the one here 
on line 17 where we assign the string to message  
18:39 - and we try to run our application our application 
will fail to build as indicated here at the top so  
18:49 - we can actually open the errors window and see 
where the error actually false so you'll see  
18:55 - we have it really nicely formatted for us we have 
basically a table that displays what the error is  
19:00 - for the description which filed in which line so 
we'll see that on line 17 after about CSS HTML dot  
19:07 - C as file we forgot to actually add a semicolon 
since it was expected here so I'll go ahead and  
19:13 - add it back in there so let's make another mistake 
here that's very common let's scroll down into our  
19:19 - / 0 method now in order to actually use the debug 
object here and make a call with right line on it  
19:26 - we need to import the correct library namespace 
now I already have it added at the top here on  
19:31 - line 3 where we specify that correct namespace 
which is system dot Diagnostics but let's pretend  
19:38 - we forgot to add it so I'll remove it and then 
we'll run our application and see what error  
19:44 - is actually being displayed this time so our 
build was not successful and we'll see in the  
19:50 - description that the name debug does not exist in 
the current context now one thing we could do now  
19:56 - is simply look up online where debug comes from 
and at the proper namespace but there is a handy  
20:02 - tool we can use called quick fix so you'll see a 
red underline where the bug is located and if we  
20:08 - right click on it and select quick fix will be 
provided with a few options on how to actually  
20:13 - fix this bug so you can see that we're missing 
an actual namespace and visual studio is smart  
20:19 - enough to let us know which one it is so we can 
actually click on using system diagnostics and  
20:24 - it will automatically add to our actual code so 
you'll see on line three it's been added now and  
20:30 - the red squiggly line has disappeared quick 
actions are extremely useful and not only at  
20:36 - using statements but help us easily refactor or 
generate or otherwise modify code with a single  
20:41 - action and as you continue your coding journey in 
asp.net you'll see how quick actions may come up  
20:46 - with solutions for other types of errors let's 
take a look at how we can actually navigate a  
20:51 - bit more around or methods and properties so we 
can actually right click on methods and we'll be  
20:57 - provided with a few options so if you right 
click on add to message and we want to know  
21:02 - where exactly the function was declared we can go 
into go to declaration this will take us exactly  
21:09 - to where the actual method was declared as you can 
see by the screwdriver here on line 28 we can also  
21:16 - see where a method was referred so we scroll 
down here and 2/0 and we right click here and  
21:22 - we go to find references will be given a search 
results window where we find all the references  
21:29 - to that method so we'll see our search results we 
are declaring it here on line 46 and I'm making a  
21:37 - call here on line 24 finally let's assume our 
project is huge and we're working with a large  
21:43 - number of folders and files imagine we want to 
look up where a certain function is called or  
21:48 - what files are using it we could search for that 
method with a search functionality so if we click  
21:53 - on the search tab and go down into finding files 
we be able to search any methods or variables that  
21:59 - we want so let's go ahead and search for add to 
message and we'll look in our current project and  
22:06 - let's click on find and here you go you should get 
the search results at the bottom here where we're  
22:12 - actually making function call on line 19 and the 
definition on line 28 so this covers a large chunk  
22:21 - of the available tools that Visual Studio provides 
for building and debugging an application we saw  
22:26 - how to build clean and rebuilt works we also saw 
how useful breakpoints are in order to suspend  
22:31 - the application in certain sections and navigate 
around it in the state's debugger windows were  
22:37 - extremely useful and we looked at a couple of them 
we looked into the call stack which is extremely  
22:41 - useful in seeing the flow of how methods are 
called and which methods are being trickled  
22:45 - down into other ones which is very useful to track 
where your application could be breaking we use  
22:50 - the output window in order to log certain messages 
from within the application and then we look into  
22:56 - the error window which provides us a more detailed 
information regarding any errors found on our code  
23:01 - by displaying the line a description and what 
possible solutions we can actually give lastly we  
23:07 - took a look at some useful quick action features 
like quick fix in order to modify our code with  
23:11 - a few simple clicks and finally we looked into 
how to find method declarations or references  
23:16 - by simply right-clicking on them and selecting 
jump to definitions or find references now these  
23:22 - tools are extremely valuable in helping solving 
issues around the application but most importantly  
23:26 - remember to read the error messages oftentimes our 
application could be breaking because we forgot to  
23:32 - add a comma somewhere so error messages could save 
us a lot of time by letting us know on what line  
23:37 - and arrow was found in a description of it so hope 
this video gave you a good understanding on how  
23:42 - to debug your application Thanks to everyone 
who watched and I'll see you all next time

Cleaned transcript:

How's everyone doing, this is Carlos here with Codecademy with another lesson on Visual Studio and Razor Pages. Now creating an application from start to finish and expecting it to compile without any errors is extremely unlikely. Making mistakes when programming is simply part of the process. Today, we're going to learn different ways to detect and remove existing potential errors in your code. Now when it comes to debugging, Visual Studio shines with its lengthy list of tools that we can use to track and remove any bugs in our code. Today, we'll be exploring how to use breakpoints, how to step into, over, and out of functions, and how to quickly navigate around our project. We'll also be taking a look at different kind of debugger windows that provide us with very useful information. So without further ado, let's go ahead and get started. Okay, so I have a small application here, and the first thing we're gonna do before we start diving into the code is to check what version of Visual Studio we're running. We can do this simply by clicking on the visual studio tab on the upperleft corner, and then going into about Visual Studio. Here, you'll see the information about the Visual Studio that you're running, you can see in my case, I'm using the Visual Studio for Mac Community Edition and I'm using the latest build at this moment, which is built 7 or version 8 point 5 point 5. Now if you want more details you can click on show details, which will give you more information on what frameworks and runtimes were installed. You can see how the dot net core runtime and the SDK installed. And if you're in a Windows machine, you can check the information about Visual Studio by clicking on help, and then going down to about Microsoft Visual Studio, and you'll find information about the Visual Studio version, and other tools and frameworks you have installed. Back in our application, you'll see I have the generated pages and other folders and files that were created when we created a Razor Pages application. So you'll see I have an About page along with the page model for it, and inside the page model, we'll see a few functions that I wrote that we'll be working with. We'll be moving around these functions using Visual Studios tools, like the breakpoints, but we need our application to run first before we do so. This means our app needs to be compiled and built in order to actually run. So let's take a look at what it means to actually build a project and the different ways we can build in Visual Studio. With Visual Studio, we're able to build, rebuild, and clean a project. Now with building, this means that we compile the source code to produce dot exe and dot dll assembly files, which we'll look into in a minute. So we can build a project by clicking on the build tab, and then selecting build all. This will compile our humanreadable code into machinereadable code, so that our computers can run it. The machinereadable code is organized into files called process assembly files, which have a dot exe file extension, and library assembly files, which have a dot dll extension. So if we open up our project in our finder, and navigate into the project directory, we'll see that we have a bin and an object folder created for us. And if we take a look at the bin folder, and navigate into the project, and into netcore app 3.1, we'll see the library assembly files created for us. Now if you're using Windows, you will also find the executable files, which have a dot exe extension. In this case, we'll find dot dll files along with some dot json files that contain some configuration for our project, and we'll also find pdb files, which stand for program database files. And pdb files, essentially, contain information for the debugger to work with. So initially, for the first build, the entire project is built. All consecutive builds are treated as incremental builds, meaning that code is compiled, and if any changes are found in the file, the ID is smart enough to know to only build that file instead of building everything again. Now we can also clean our project. Cleaning the project removes intermediate and output files from the object in bin project folders. Let's say we want to clean our project. So we can take a look at the current files found in our bin folder netcore app 3.1, we'll see that we have our json files, our dll files, and our pdb files. So if we go to build, and then Clean our DebugApp, and then go back into our actual project directory, and then navigate straight into our bin folder, debug netcore app 3.1, we'll see that all our files have been removed. Lastly, you can also rebuild a project. The way rebuild works is we first clean the project, and then build a solution from scratch, and it says the project is cleaned prior to running the build command, and all intermediate and output files are removed prior to the build. We end up building the project from scratch with this one rebuild command. And rebuilding a project is very useful when we want to preserve the integrity of the build and ensure that no output files are stale, if we introduce multiple dependencies over an extended period of time. So hopefully that gave you a better understanding of what happens when we run our application. Okay, so before we start debugging our app, let's take a quick look at our About page model, and see what functions we have created, and what we'll be doing here. First, we'll see here on line 13 that I have a public property of data type string called Message with a getter and setter. Inside our on get method here, we're assigning "Hello" to that same property. And right after assigning "Hello" to it, we're reassigning a new value to it using the add to message function. The AddToMessage function takes an array of three elements, and then returns a new value from it. So if we jump to the AddToMessage function, we'll see what's happening with that method. AddToMessage is a private method that takes in a string array and creates a new string called result. So you'll see we start out with an empty string assigned to result, then we loop over the array that's passed into the method, and append each element from the array to that result variable, which it starts out as an empty string, then after the first iteration, it will add the first element with a new line, then the second element with another line, and then the third element with another line. Once the loop is done, we're using a function created, ReplaceToUpper, that takes in that string and we can look down here on line 41 that it converts the whole string into uppercase. Lastly, we have a divide by 0 method. In this method, we have a try and catch statement, where it attempts to divide by 0 in the try clause, and the catch clause simply logs a message into the debugger. So now we can get into the meat of the video. We're going to start by looking into Breakpoints. Now a Breakpoint indicates where Visual Studio should suspend your running code, so you can take a look at the values of variables, or the behavior of memory, or whether or not a branch of code is getting run. We can place a Breakpoint right next to a line number. So in our application, I'm going to go ahead and add a breakpoint in our on get function, where I assign the string "Hello" to the property message. From here, we have a few options on how to run our application with debugger, we can go to run and select start debugging, you can also click the play button here, which has a debugger that will open and launch our application on a Google Chrome tab. So I'm going to go ahead and click the play button here, and this should run a build, and then run and execute our application. Once the build is successful, our application should be launched in a new Google Chrome tab. And a shortcut on a Mac to run the app with the debugger would be alt and command and enter. On a Windows machine, there are a few ways you can start your application with a debugger, you can go to the debug tab up here, and select start debugging, the shortcut for it would also be f5, or you could click on the play button here on the upperright corner. So once we've run the application with a debugger, we can navigate to the About page, and from there, we'll be taken to our breakpoint location. So I'm going to go ahead and click on About, and we'll be taken to the breakpoint location where our code has been suspended. Once we're here, we'll see that a few windows have popped up for us. You have the locals error, breakpoints to watch, and the threads window. So if we go into the locals window, we'll see some information displayed on local variables and objects based on the current context or the local scope. Since we're in the About model, we'll see variables from that model, and the model it inherits, which is the Page model. So the keyword this is in context to that actual model. So if we open up this dropdown, we'll see a bunch of properties and builtin functions that belong to the About model and the Page model class. The second line here will see our property message, which has a value of null, which makes sense because our code has suspended, so this line 17, where we assigned the string "Hello" to Message, hasn't been actually executed yet. Now when it comes to Breakpoints, Visual Studio is very useful in providing us with three different types of actions that we can use on Breakpoints. First thing we could do is step into which runs the next statement so if the current line contains a function call step into steps into that function the shortcut for this command on a Mac is shift command and I and on Windows it is f11 we could also step over which runs the next statement without stepping into functions or methods in the shortcut for this on a Mac is shift command and o and on Windows it is f10 and lastly we could step out of which advances the debugger all the way through the current function and it continues running code and suspense execution when the current function returns the shortcut for this on Apple is shift command in U and on Windows it is Shift + f11 back in our application we can find options for these commands here at the top of our tab so let's go ahead and jump over into the next statement which is found here on line 19 where we reassign message so next to the play button I'm gonna go ahead and click on step over which will direct us to the next statement here on line 19 and now if we take a look at our locals windows we'll see that message now has a value of hello because a line on line 17 was actually executed now here on line 19 were making a call to the function add to message so we want to take a look at what's happening in there we could step into that function so let's click on the step into action button and then we'll be taken to the function definition you can see by our cursor here indicated that we're now in this code lock since the method now has actual scope we could also click on the parameter to see what values were passed in so we click here on text we'll see a little drop down of text that contains an array containing three string elements so we can actually open it up and see the values that were passed into that method and now that we have local scope in this function we can actually go into our locals window and find the variable text in there with some information regarding its value we could also find it here on our watch window so we'll be going to this watch window we'll be able to track down any variables that we care about and see how they change while we're debugging our application so we can add any kind of variable or i10 that we'd like so I can double click here and that message and you'll see the value being populated so I can also add another one I'll add text to see what the value of it is and you'll see that it's actually an array containing three string elements so the watch window is very useful in letting us track how these variables change or even seeing any expression being generated you can actually type in any kind of expression here and it will return us a value so let's write out a string that displays the first element in the text array so we'll type in tuck 0 is and then I'll type out and access the first element in the text array and then we'll see that the value has been populated for us it's also useful to point out if you're on a Windows machine you can simply highlight and drag the variable into your watch window so now let's take a look at the call stack now the call stack shows the order in which methods and functions are getting called and it's a good way to examine and understand the execution flow of an app so if you place a breakpoint in a replace to upper method here where we return text dot to upper we can actually continue this and see the call stack now you won't see the call stack here and if you by any chance closed any of these tabs you can find them like going on to view going to debug pads and then you'll see the windows that are useful for debugging so I'm gonna go ahead and click the call stack and it should show up here so I'm gonna head expand this a little bit more scroll down so now if we continue and I click on run well we take in and shown the call stack which is basically either line of execution so we start here on line 19 as indicated where we make a call to add to message then we're taken to the add to message function and then from here you can see that it's highlighted we're making another call to another method called replace to upper which starts out here and a function definition and then finally it returns the text in uppercase so our code is suspended here at the moment meaning it hasn't returned anything but if I click run again our call stack should be cleared since or returning a value from that method so let's take another look at how the call stack actually worked so we started our on get method within that method we're making a call to add to message so the add to message function call is added to the call stack within the apt in message method were actually making another call to a method called replace to upper so from there replace to upper is added to the call stack as well and once a value is returned from replace to upper our call stack is clear so we're essentially three lines deep into our line of execution before we return a value so I'm going to go ahead and close the call stack window and now we can look at the output window now the output window displays status messages for various features and IDE and it helps us track of what's happening while the application is running well find certain logs of applications running what port were running our application on or packages being installed or updated but we can use it ourselves to actually log out certain information whenever we hit a line of code if we take a look at our divide by zero method call here we're attempting to divide an integer by zero which throws an exception we can then cast the exception and write to the line a custom message so when we continue the application if we look on our on get method we notice that we made a call to divide by zero on line 24 since we know it's not possible to divide by zero we caught the error the exception and send a custom message to our output window as you can see we're using string interpolation to actually display the message and you can see that it's out put it here in our output window where it says oops attempted to divide by zero so one other a handy tool we can use is to set conditionals and our breakpoints so instead of hitting a specific break on every time we run our application we can create a condition to only hit it if a certain expression is true so let's say we only want to stop at this breakpoint if the string argument your text contains a word first I can do that by right clicking on the breakpoint and then editing the breakpoint from here we can specify that the variable text should contain the word first well have some other options provided for us but we want to place an advanced condition to only stop at this breakpoint if the text contains the word first so we can click on apply and now that condition should be applied to the breakpoint so let's go over ahead and go through the process of debugging our application again and let's see if we actually land on that breakpoint now so this should launch our application once more we go ahead and click on about well land on the first one where we have the message equal to hello and we'll continue to the next one and you'll see that we actually land on that breakpoint now if I were to actually change the condition for that breakpoint where it contains something that is not in that so I'll type in second and apply that condition and then we go over the process again let's go ahead and launch your application going to about since that condition will be equal to false then we should not land on that breakpoint let's go to about well land on the first breakpoint and if we click run and continue you'll notice that we actually don't we skip that breakpoint and we go straight and to divide by zero which logs out the message oops attempted to divide by zero now let's take a quick look and see how we would do this on Windows on a Windows machine sending a conditional on a breakpoint is a little bit different let's go ahead and place a breakpoint where we returned the text and upper case and right click then you go to conditions and from here we can set any kind of condition that we like so let's add a condition where we only want to hit the breakpoint if the text contains the keyword first and then you'll see some configurations on the breakpoint and you'll also notice a plus sign and the breakpoint indicating that a conditional has been applied to it so this feature is specially useful when one is trying to catch a condition that may only occur once out of many passes and where we want to save time and not break on each pass to check for a value that we're looking for okay now let's move on to the error window now csharp is very specific with the syntax so let's say we forget to add a semicolon I'm gonna remove the one here on line 17 where we assign the string to message and we try to run our application our application will fail to build as indicated here at the top so we can actually open the errors window and see where the error actually false so you'll see we have it really nicely formatted for us we have basically a table that displays what the error is for the description which filed in which line so we'll see that on line 17 after about CSS HTML dot C as file we forgot to actually add a semicolon since it was expected here so I'll go ahead and add it back in there so let's make another mistake here that's very common let's scroll down into our / 0 method now in order to actually use the debug object here and make a call with right line on it we need to import the correct library namespace now I already have it added at the top here on line 3 where we specify that correct namespace which is system dot Diagnostics but let's pretend we forgot to add it so I'll remove it and then we'll run our application and see what error is actually being displayed this time so our build was not successful and we'll see in the description that the name debug does not exist in the current context now one thing we could do now is simply look up online where debug comes from and at the proper namespace but there is a handy tool we can use called quick fix so you'll see a red underline where the bug is located and if we right click on it and select quick fix will be provided with a few options on how to actually fix this bug so you can see that we're missing an actual namespace and visual studio is smart enough to let us know which one it is so we can actually click on using system diagnostics and it will automatically add to our actual code so you'll see on line three it's been added now and the red squiggly line has disappeared quick actions are extremely useful and not only at using statements but help us easily refactor or generate or otherwise modify code with a single action and as you continue your coding journey in asp.net you'll see how quick actions may come up with solutions for other types of errors let's take a look at how we can actually navigate a bit more around or methods and properties so we can actually right click on methods and we'll be provided with a few options so if you right click on add to message and we want to know where exactly the function was declared we can go into go to declaration this will take us exactly to where the actual method was declared as you can see by the screwdriver here on line 28 we can also see where a method was referred so we scroll down here and 2/0 and we right click here and we go to find references will be given a search results window where we find all the references to that method so we'll see our search results we are declaring it here on line 46 and I'm making a call here on line 24 finally let's assume our project is huge and we're working with a large number of folders and files imagine we want to look up where a certain function is called or what files are using it we could search for that method with a search functionality so if we click on the search tab and go down into finding files we be able to search any methods or variables that we want so let's go ahead and search for add to message and we'll look in our current project and let's click on find and here you go you should get the search results at the bottom here where we're actually making function call on line 19 and the definition on line 28 so this covers a large chunk of the available tools that Visual Studio provides for building and debugging an application we saw how to build clean and rebuilt works we also saw how useful breakpoints are in order to suspend the application in certain sections and navigate around it in the state's debugger windows were extremely useful and we looked at a couple of them we looked into the call stack which is extremely useful in seeing the flow of how methods are called and which methods are being trickled down into other ones which is very useful to track where your application could be breaking we use the output window in order to log certain messages from within the application and then we look into the error window which provides us a more detailed information regarding any errors found on our code by displaying the line a description and what possible solutions we can actually give lastly we took a look at some useful quick action features like quick fix in order to modify our code with a few simple clicks and finally we looked into how to find method declarations or references by simply rightclicking on them and selecting jump to definitions or find references now these tools are extremely valuable in helping solving issues around the application but most importantly remember to read the error messages oftentimes our application could be breaking because we forgot to add a comma somewhere so error messages could save us a lot of time by letting us know on what line and arrow was found in a description of it so hope this video gave you a good understanding on how to debug your application Thanks to everyone who watched and I'll see you all next time
