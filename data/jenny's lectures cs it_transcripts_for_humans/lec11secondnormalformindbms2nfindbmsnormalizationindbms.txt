With timestamps:

00:00 - in the previous video we have discussed
00:01 - what is first normal form and how
00:03 - identify that I given table is in first
00:06 - normal form or not right basically we
00:09 - have discussed all the four rules for a
00:11 - relation to be in first normal form all
00:14 - the four important rules right and I
00:16 - have already told you that if they'll
00:19 - give you a relational schema or
00:20 - something like this relation is given
00:22 - having these attributes and functional
00:24 - dependencies are given right then
00:26 - obviously that schema would be in first
00:29 - normal form they will never give you or
00:32 - hardly they will give you a table and
00:33 - they will ask that tell me the stable is
00:35 - in first normal form or not right
00:38 - because first normal form is the basic
00:40 - point the basic step of normalization so
00:44 - always they will give you a table or the
00:46 - schema in first normal form now the
00:49 - important point is you how to identify
00:50 - that as in second normal form third
00:52 - normal form bcnf something like this and
00:55 - if not then convert it into the desired
00:57 - normal form right
01:00 - so in gate and annete these type of
01:02 - questions will be asked they will give
01:04 - you these type of questions functional
01:05 - dependencies are given and they'll ask
01:07 - you that which highest normal form is
01:12 - there in this relation so you have to
01:14 - find it out so we have only functional
01:16 - dependencies right so this functional
01:19 - dependencies will play very important
01:21 - role here so I have already discussed
01:24 - what is functional dependencies trivial
01:26 - functional dependency known trivial
01:28 - functional dependencies on strong exams
01:31 - or you can say inference rules or
01:33 - functional dependencies so first you
01:35 - check out those videos and second
01:37 - important point is here what you should
01:40 - know how to calculate candidate keys in
01:43 - a relation candidate Keys plays very
01:47 - important role without finding out the
01:50 - candidate is you cannot solve the
01:53 - problem of normalization second normal
01:55 - form third normal form bcnf fourth fifth
01:59 - like this right so candidate keys you
02:02 - should know that also we have discussed
02:04 - how to find out candidate keys in a
02:06 - given relation all the candidate keys
02:08 - not one all candidate is right with a
02:11 - simple trick so you can check out that
02:12 - video in this
02:13 - right and after that come to this video
02:15 - so now in this video we will discuss how
02:19 - to find out that a particular given
02:21 - relation is in second normal form or not
02:24 - right what are the rules for a relation
02:28 - to be in second normal form there are
02:30 - basically two roots first rule is very
02:33 - simple that that relation should be in
02:36 - first normal form and I have already
02:38 - told you if they will give you this type
02:40 - of question that our relational schema
02:41 - is given that is by default that will be
02:44 - in first normal form right so first rule
02:49 - is a relation is said to be in second
02:52 - normal form if first rule is if it is in
02:58 - first normal form right and this already
03:02 - we by default we consider that this is
03:04 - in first normal form right second rule
03:07 - is what there would be no partial
03:10 - dependency present in the relation now
03:13 - what is partial dependency that also L
03:15 - discuss so this what is this partial
03:19 - dependency now I hope everybody knows
03:21 - what is functional dependency right I
03:24 - have already discussed you can check out
03:27 - that or you on the side but now what is
03:29 - partial functional dependency or you can
03:31 - write down at something like this proper
03:34 - subset of candidate key of any candidate
03:39 - key if suppose there are three candidate
03:41 - keys so proper subset of any candidate
03:44 - key well determine non-prime attribute
03:49 - if this kind of dependency is there in
03:53 - the list of functional dependency given
03:56 - then that is known as partial dependency
03:59 - right proper subset of candidate key see
04:03 - suppose candidate key here is a B II so
04:08 - proper subset of this as what ad is also
04:12 - proper subset B is also proper subset or
04:15 - you can write a a de6 proper subset of
04:19 - are there right so if any proper subset
04:23 - of the candidate key will determine the
04:26 - know
04:26 - one prime attribute then that is partial
04:29 - dependency and that should not present
04:31 - in the relation if partial dependency is
04:34 - there in the relation that then that
04:36 - relation is not in second normal form
04:39 - now what does this non-prime attribute I
04:41 - hope you got what is partial dependency
04:45 - write partial functional dependency you
04:47 - can say now obviously I will discuss
04:50 - this with elbow in this example then you
04:51 - will get it better now what is known
04:53 - primate rib you see I hold discussed
04:55 - prime a tribute non-prime attribute
04:57 - primary boots are those which are part
05:00 - of candidate keys right suppose here in
05:05 - this relation suppose I am NOT saying
05:07 - that these are the candidate key suppose
05:09 - a D is candidate key B C is candidate
05:12 - key to candidate keys are there in this
05:14 - relation right so prime attributes would
05:16 - be what a b c d e the attributes which
05:23 - are part of candidate keys or which are
05:26 - making the candidate key those are prime
05:28 - atributes and the remaining attributes
05:30 - are means the attributes which are not
05:32 - part of candidate key which are those
05:35 - are non-prime attribute so here
05:37 - non-prime attribute would be i guess
05:39 - only F would be non-prime attribute
05:42 - right so I hope you all know what is
05:44 - known primate repute so now let us
05:47 - discuss it with this example let us find
05:51 - out
05:52 - thus this relation is in second normal
05:54 - form or not right and after that we will
05:57 - discuss it with help of two or three
05:58 - examples with all the type of examples I
06:01 - will take all the type of examples and
06:03 - after that we will see if this is not in
06:06 - second normal form then how to convert
06:08 - it into second normal form right so now
06:12 - this is in first normal form right by
06:14 - default the relational schema is given
06:16 - and this condition is satisfied now you
06:18 - have to find out this condition means
06:20 - there should be no partial dependency so
06:22 - now you have to find out this type of
06:24 - functional dependency here if this type
06:26 - of functional dependency present here
06:27 - then you can say this is not in second
06:30 - normal form right but for this you have
06:32 - to find out what is candidate here to
06:34 - find out the proper subset of candidate
06:36 - keys you have to find out all the
06:38 - candidate
06:38 - from a relation right without finding
06:41 - candidate he is you cannot do anything
06:43 - so that is very important now how to
06:45 - find out candidate keys we have already
06:47 - discussed candidate key is what the
06:49 - minimal superkey so now here how to find
06:52 - out by taking the attribute closer so
06:56 - that also I have discussed what is
06:57 - attribute closer and how to find out
06:59 - that Ribit closer of an attribute right
07:02 - so I will take first of all all the
07:04 - attributes find out the closer
07:06 - definitely it will find out all that
07:10 - reviews so this is all definitely a
07:12 - super key right because of reflexive
07:15 - reflexivity property now try to discard
07:18 - attributes from here so now a can
07:21 - determine B so we have a so I can
07:24 - discard B from here because if you have
07:26 - a then a can determine itself and a can
07:28 - determine B also so you can discard B it
07:32 - can determine V B can determine C so by
07:34 - transitivity property a can determine C
07:36 - so you can discard C C can determine D
07:39 - so by transitivity property a can also
07:41 - determine B so you can discard D now I
07:44 - can determine D and D can determine e so
07:47 - by default a can determine e means by
07:49 - transitivity property so you can discard
07:51 - e can you discard F no we don't have
07:57 - such type of dependent dependency that
07:58 - using that we can discard F because
08:00 - nothing is going to find out nothing is
08:02 - determining here F so now a and if you
08:06 - can take the closer and you will find
08:08 - all the attributes so this would be the
08:10 - super key right so how to find out that
08:13 - that is candidate here not proper subset
08:15 - is a and F proper subset is if proper
08:20 - subset is also super in and that would
08:22 - not be a candidate key you can find out
08:24 - closure of a closure of a will find out
08:27 - a right itself then B then C then D then
08:31 - e not F so this is not super key F
08:33 - proper F closer would we want only F F
08:36 - can determine itself this is trivial
08:39 - functional dependency nothing else so
08:42 - this is also not super key so you here
08:44 - you can say AF is candidate key because
08:47 - no proper subset of super key the super
08:49 - key is super key
08:52 - so here AF is what candidate we have got
08:56 - one candidate key that is F so now we
09:00 - have got as well as the primary beauts
09:02 - right means a and F a comma F R prime
09:07 - attributes now you have to find out
09:11 - still there are another more so more
09:14 - candidate keys exist in the relation or
09:16 - not because we have what only one
09:17 - candidate you know how to find out that
09:19 - thing if the prime attributes are
09:21 - present on the right hand side of any
09:24 - functional dependency then definitely
09:25 - there would be more candidate he is
09:27 - present if not then there would be no
09:32 - more candidate he so find out is a
09:34 - present on the right hand side of any
09:36 - functional dependency no F no so in this
09:40 - relation only one candidate key is there
09:42 - that is a F no more candidate key you
09:45 - will find like that is the short break
09:48 - fine
09:49 - now if AF is candidate key then here
09:53 - known prime attributes are AFR prime
09:56 - attributes so remaining means bc de
10:00 - these are non prime attributes now they
10:03 - have known prime attributes also on
10:05 - cannulate field so now you can check out
10:07 - this type of dependency exist here or
10:09 - not C proper subset of candidate key
10:11 - proper subset of this candidate is what
10:13 - because I have only one candidate key a
10:16 - and right is a or F bit remaining any
10:21 - non-prime attribute C here F is not a
10:25 - determining anything so it cannot be
10:28 - there it cannot be a case now is a
10:30 - determining here C is determining be
10:33 - right and B is what non-prime attribute
10:38 - means you go to this type of functional
10:42 - dependency here right so this is what a
10:46 - determine B this is what partial
10:48 - dependency so here partial dependency
10:51 - exists so this relation is not in second
10:54 - normal form or in another word you can
10:56 - say C complete AF is candidate E and
10:59 - definitely it is also primary key right
11:03 - and only a PI
11:05 - of this primary key only a part of this
11:09 - primary pure candidate key is
11:11 - determining a non-prime attribute only a
11:14 - part not the complete candidate he so
11:17 - that could not be possible right so now
11:20 - let us discuss it with one more example
11:22 - so let us take this example now this is
11:24 - the relation having four attributes and
11:26 - these are the functional dependency is
11:27 - given here so this relation is
11:29 - definitely by defaulting first normal
11:31 - form right now you have to check the
11:33 - partial dependency present here or not
11:35 - how to find out partial dependency see
11:38 - this thing you have to take care if you
11:41 - know how to find out partial dependency
11:43 - what is partial dependency then you can
11:45 - easily find out that a particular
11:47 - relation is in second normal form or not
11:49 - this is the important concept here right
11:51 - so partial dependency means you have to
11:53 - find out this kind of dependency in the
11:56 - given list for this kind of dependency
11:58 - you have to find out candidate keys all
12:00 - the candidate keys and definitely then
12:02 - you can find out the non-prime attribute
12:03 - all right so now first of all find out
12:06 - the candidate keys how to find out if
12:08 - all the attributes take the closer and
12:11 - all the attributes definitely would be
12:12 - super key right now try to discard as
12:17 - many attributes as you can because
12:19 - candidate he is minimal superkey now see
12:22 - check the dependencies a B both can
12:25 - determine C D do you have a B yes I have
12:27 - a B so I can determine both C and D so a
12:31 - B closer would also find out a B itself
12:34 - because of reflexivity and a B can
12:36 - determine C D do you have a B yes so I
12:38 - can determine C D so this closure of the
12:41 - say B is containing all the attributes
12:42 - so a B is what super key a B is still a
12:45 - super here right now can you discard any
12:48 - more attribute from a b c can determine
12:50 - a you have do you have C no they can
12:53 - determine B but we don't have B so we
12:55 - cannot discard any more attribute right
12:57 - so now check out as a B's so candidate
13:00 - he or not find out the proper subset
13:02 - that is a and B find out closure of a
13:05 - find out a and B individual can be a
13:08 - super cure node closure of a single a
13:11 - can determine a but we don't have a B so
13:14 - we cannot determine C D so only a can
13:18 - throw my
13:18 - itself we can determine B only B so this
13:22 - is not super key this is not super key
13:24 - so it means candidate here a B is what
13:26 - candidate key we have got one candidate
13:29 - it means prime attributes are a and B
13:33 - right now check more candidate keys are
13:36 - present or not how to check if prime
13:38 - attributes are present on the right hand
13:40 - side of any functional dependency then
13:42 - definitely more candidate keys would be
13:44 - there C is present on the right hand
13:47 - side of this functional dependency right
13:48 - means you will get more candidate he is
13:51 - here right now how to do that thing C
13:54 - existing candidate is this one so at the
13:57 - place of a you can replace a with C
14:00 - after replacing you will get C B right
14:04 - and second option is C B is also prime
14:07 - attribute and B is present on the right
14:09 - hand side of D so second option is at
14:12 - the place of B you can write down B but
14:16 - I'm not saying that this and s would be
14:18 - definitely candidate is still you need
14:20 - to find out but yeah I can say that this
14:22 - and this are super keys right so now
14:25 - check out the proper subset of B and C 1
14:28 - is B 1 is C check out these are super
14:31 - keys or not find out to be closer see B
14:34 - is not a super key C closer so you can
14:36 - determine itself C can determine a
14:40 - nothing else so this is not super key so
14:42 - it means B C is also candidate key right
14:45 - so now we go to one more prime attribute
14:47 - that is C now check out a DS candidate
14:51 - key or not a closer
14:53 - not candidate key be closer be closer
14:56 - can find out B and B nothing else so
15:01 - this is also not super case so this is
15:02 - also candidate key here fine so a and D
15:05 - so D is also prime attribute right now
15:10 - you can check we have got two more prime
15:12 - attributes now check these are available
15:14 - on the right hand side of any functional
15:16 - dependencies or not yes available see
15:19 - this you can write down something like
15:20 - this by splitting property a B can
15:22 - determine C and a B can determine D so
15:26 - at the place of C you can replace it
15:28 - with a B here a B so obviously
15:31 - not right abb a B but we have got on the
15:34 - candidate he a B so no need to replace
15:36 - and at D also a be at D also a B so we
15:41 - have already got a B so no need to
15:42 - replace so now these are the candidate
15:45 - III candidate he's in this relation and
15:47 - prime attributes are ABCD now here all
15:51 - the attributes of the relations are
15:53 - prime atributes so definitely that
15:56 - relation would be in second normal form
16:01 - why so because there is no non-prime
16:04 - attribute if no non-prime attribute then
16:07 - you will never get this type of
16:09 - situation because proper subset of
16:11 - candidate key is determining non-prime
16:15 - attribute this is partial dependency but
16:17 - we don't have any known primate review
16:19 - so you will never get this kind of
16:21 - dependency here right see at the right
16:25 - hand side non-prime attribute should be
16:26 - there you can check right hand side CD
16:29 - but CDs prime attribute a is also prime
16:31 - attribute B B's also prime attribute
16:33 - fine so if all the attribute of a
16:37 - relation R prime attributes then that
16:39 - relation is definitely in second
16:41 - adorable form right let us take third
16:44 - example so third is this type of
16:46 - question four attributes are there in
16:49 - our relation these are the functional
16:51 - dependence you find out the candidate
16:52 - key first of all how to find out simple
16:55 - rule take all the attributes obviously
16:57 - the closer would be ABCD find out all
17:00 - the attributes so this would be super
17:01 - key right now try to discard attributes
17:03 - how will discard to check the functional
17:05 - dependency is determining B so do you
17:07 - have a yes I can discard be a yet
17:10 - remaining BB is determining see so by
17:12 - transitivity property a will determine C
17:15 - so I can discard C because I have a now
17:17 - third is what C is determining B means
17:20 - a can determine C and C can determine D
17:23 - by transitivity property so means here
17:25 - if you have a so you can discard B so
17:28 - now we are left with only a so find out
17:30 - a closer is it super clear node a will
17:32 - determine
17:32 - itself so we have a a will determine V
17:35 - do you have a yes so it will determine B
17:37 - B will determine CSU will determine D so
17:40 - I am getting all the attributes of a
17:41 - relation so a is what super key
17:43 - right now is a candidate key or not
17:46 - definitely yes why so because proper
17:49 - subset of this is what Phi only right
17:52 - how to find out proper subset that also
17:54 - I have discussed in the previous video
17:56 - you can check out that video in the SCI
17:57 - button right that is Phi and Phi a set
18:00 - of attribute cannot determine any
18:03 - attribute of a relation so definitely if
18:05 - one attribute is there in a super key
18:07 - then definitely that would be candidate
18:09 - key
18:10 - so here is what candidate so prime
18:14 - attribute we got a now check prime
18:17 - attribute is available on the right hand
18:18 - side of any functional dependency here
18:22 - we have B here we have C here we already
18:23 - know it means there would not be no more
18:27 - candidate keys here we have only one
18:29 - candidate key that is a now see here
18:32 - candidate key is having only one
18:34 - attribute so proper subset of candidate
18:37 - key can you get any proper subset of
18:39 - this proper subset would be what Phi
18:41 - only no attribute would be there right
18:45 - now there is no proper subset of
18:48 - candidate key so definitely we will
18:50 - never get this kind of dependency here
18:53 - so there is no func partial dependency
18:56 - so this would be in second normal form
18:58 - this relation would be in second normal
19:00 - form so you can say something like this
19:03 - if candidate is having only single
19:05 - attribute single attribute right then
19:08 - definitely that relation would be in
19:12 - second normal form right it's not like
19:16 - that may be may be in some case in some
19:19 - relation one candidate he is on having
19:21 - single attribute another candidate he is
19:23 - having two attribute in that case you
19:26 - cannot say that there would not be any
19:28 - partial dependency because one candidate
19:30 - key is having two attributes so you can
19:33 - find out proper subset of this you can
19:36 - you cannot find out proper subset of
19:38 - this but you can find out proper subset
19:39 - of this right so it means if all the
19:43 - candidate keys here luckily I have only
19:46 - one candidate key but if suppose all the
19:49 - candidate keys two candidate keys are
19:51 - there oh three candidate keys are there
19:52 - and all the three candidate keys are
19:54 - having single single ID
19:55 - then definitely there would be no
19:58 - partial dependency and definitely that
20:00 - relation would be in second normal form
20:02 - now I hope you got how to find out that
20:05 - particular relation is in second normal
20:06 - form or not right and what is partial
20:08 - dependency now see one question for you
20:11 - is here this this is the relation given
20:14 - and functional dependencies are two
20:16 - functional dependency is only A to B B
20:18 - to D I think this is very simple
20:20 - question so you can tell me in the
20:21 - comment box that this relation is in
20:24 - second normal form or not right now the
20:27 - question is if not in second normal form
20:29 - then how to convert it into second
20:31 - normal form right so we will decompose
20:33 - that relation see this is not in second
20:36 - normal form so you will decompose this
20:38 - you will divide it now how to decompose
20:41 - it that I guess it's not the right time
20:43 - to tell because first of all I will tell
20:45 - you what is decomposition what are types
20:48 - of decomposition we have Llosa
20:49 - decomposition we have lost less
20:51 - decomposition right so definitely there
20:54 - should be loss less decomposition not
20:57 - this low silly composition now I am
20:59 - going to tell you in the next video that
21:01 - what is the low C decomposition and what
21:02 - is loss less decomposition right right
21:04 - and how to decompose a particular
21:07 - relation into loss less the composition
21:09 - right after that only I can I guess you
21:12 - can easily get that how to convert it
21:14 - into its second normal form how to
21:16 - decompose the relation right it's not
21:18 - the right time to tell you right now in
21:21 - the next video I am going to tell you
21:23 - that what is third normal form and how
21:25 - to find out that a particular relation
21:27 - particular given relation is in third
21:29 - normal form or not the basic idea right
21:32 - so I guess now it's done with the second
21:34 - normal form so now I'll see in the next
21:36 - video till then bye bye take care

Cleaned transcript:

in the previous video we have discussed what is first normal form and how identify that I given table is in first normal form or not right basically we have discussed all the four rules for a relation to be in first normal form all the four important rules right and I have already told you that if they'll give you a relational schema or something like this relation is given having these attributes and functional dependencies are given right then obviously that schema would be in first normal form they will never give you or hardly they will give you a table and they will ask that tell me the stable is in first normal form or not right because first normal form is the basic point the basic step of normalization so always they will give you a table or the schema in first normal form now the important point is you how to identify that as in second normal form third normal form bcnf something like this and if not then convert it into the desired normal form right so in gate and annete these type of questions will be asked they will give you these type of questions functional dependencies are given and they'll ask you that which highest normal form is there in this relation so you have to find it out so we have only functional dependencies right so this functional dependencies will play very important role here so I have already discussed what is functional dependencies trivial functional dependency known trivial functional dependencies on strong exams or you can say inference rules or functional dependencies so first you check out those videos and second important point is here what you should know how to calculate candidate keys in a relation candidate Keys plays very important role without finding out the candidate is you cannot solve the problem of normalization second normal form third normal form bcnf fourth fifth like this right so candidate keys you should know that also we have discussed how to find out candidate keys in a given relation all the candidate keys not one all candidate is right with a simple trick so you can check out that video in this right and after that come to this video so now in this video we will discuss how to find out that a particular given relation is in second normal form or not right what are the rules for a relation to be in second normal form there are basically two roots first rule is very simple that that relation should be in first normal form and I have already told you if they will give you this type of question that our relational schema is given that is by default that will be in first normal form right so first rule is a relation is said to be in second normal form if first rule is if it is in first normal form right and this already we by default we consider that this is in first normal form right second rule is what there would be no partial dependency present in the relation now what is partial dependency that also L discuss so this what is this partial dependency now I hope everybody knows what is functional dependency right I have already discussed you can check out that or you on the side but now what is partial functional dependency or you can write down at something like this proper subset of candidate key of any candidate key if suppose there are three candidate keys so proper subset of any candidate key well determine nonprime attribute if this kind of dependency is there in the list of functional dependency given then that is known as partial dependency right proper subset of candidate key see suppose candidate key here is a B II so proper subset of this as what ad is also proper subset B is also proper subset or you can write a a de6 proper subset of are there right so if any proper subset of the candidate key will determine the know one prime attribute then that is partial dependency and that should not present in the relation if partial dependency is there in the relation that then that relation is not in second normal form now what does this nonprime attribute I hope you got what is partial dependency write partial functional dependency you can say now obviously I will discuss this with elbow in this example then you will get it better now what is known primate rib you see I hold discussed prime a tribute nonprime attribute primary boots are those which are part of candidate keys right suppose here in this relation suppose I am NOT saying that these are the candidate key suppose a D is candidate key B C is candidate key to candidate keys are there in this relation right so prime attributes would be what a b c d e the attributes which are part of candidate keys or which are making the candidate key those are prime atributes and the remaining attributes are means the attributes which are not part of candidate key which are those are nonprime attribute so here nonprime attribute would be i guess only F would be nonprime attribute right so I hope you all know what is known primate repute so now let us discuss it with this example let us find out thus this relation is in second normal form or not right and after that we will discuss it with help of two or three examples with all the type of examples I will take all the type of examples and after that we will see if this is not in second normal form then how to convert it into second normal form right so now this is in first normal form right by default the relational schema is given and this condition is satisfied now you have to find out this condition means there should be no partial dependency so now you have to find out this type of functional dependency here if this type of functional dependency present here then you can say this is not in second normal form right but for this you have to find out what is candidate here to find out the proper subset of candidate keys you have to find out all the candidate from a relation right without finding candidate he is you cannot do anything so that is very important now how to find out candidate keys we have already discussed candidate key is what the minimal superkey so now here how to find out by taking the attribute closer so that also I have discussed what is attribute closer and how to find out that Ribit closer of an attribute right so I will take first of all all the attributes find out the closer definitely it will find out all that reviews so this is all definitely a super key right because of reflexive reflexivity property now try to discard attributes from here so now a can determine B so we have a so I can discard B from here because if you have a then a can determine itself and a can determine B also so you can discard B it can determine V B can determine C so by transitivity property a can determine C so you can discard C C can determine D so by transitivity property a can also determine B so you can discard D now I can determine D and D can determine e so by default a can determine e means by transitivity property so you can discard e can you discard F no we don't have such type of dependent dependency that using that we can discard F because nothing is going to find out nothing is determining here F so now a and if you can take the closer and you will find all the attributes so this would be the super key right so how to find out that that is candidate here not proper subset is a and F proper subset is if proper subset is also super in and that would not be a candidate key you can find out closure of a closure of a will find out a right itself then B then C then D then e not F so this is not super key F proper F closer would we want only F F can determine itself this is trivial functional dependency nothing else so this is also not super key so you here you can say AF is candidate key because no proper subset of super key the super key is super key so here AF is what candidate we have got one candidate key that is F so now we have got as well as the primary beauts right means a and F a comma F R prime attributes now you have to find out still there are another more so more candidate keys exist in the relation or not because we have what only one candidate you know how to find out that thing if the prime attributes are present on the right hand side of any functional dependency then definitely there would be more candidate he is present if not then there would be no more candidate he so find out is a present on the right hand side of any functional dependency no F no so in this relation only one candidate key is there that is a F no more candidate key you will find like that is the short break fine now if AF is candidate key then here known prime attributes are AFR prime attributes so remaining means bc de these are non prime attributes now they have known prime attributes also on cannulate field so now you can check out this type of dependency exist here or not C proper subset of candidate key proper subset of this candidate is what because I have only one candidate key a and right is a or F bit remaining any nonprime attribute C here F is not a determining anything so it cannot be there it cannot be a case now is a determining here C is determining be right and B is what nonprime attribute means you go to this type of functional dependency here right so this is what a determine B this is what partial dependency so here partial dependency exists so this relation is not in second normal form or in another word you can say C complete AF is candidate E and definitely it is also primary key right and only a PI of this primary key only a part of this primary pure candidate key is determining a nonprime attribute only a part not the complete candidate he so that could not be possible right so now let us discuss it with one more example so let us take this example now this is the relation having four attributes and these are the functional dependency is given here so this relation is definitely by defaulting first normal form right now you have to check the partial dependency present here or not how to find out partial dependency see this thing you have to take care if you know how to find out partial dependency what is partial dependency then you can easily find out that a particular relation is in second normal form or not this is the important concept here right so partial dependency means you have to find out this kind of dependency in the given list for this kind of dependency you have to find out candidate keys all the candidate keys and definitely then you can find out the nonprime attribute all right so now first of all find out the candidate keys how to find out if all the attributes take the closer and all the attributes definitely would be super key right now try to discard as many attributes as you can because candidate he is minimal superkey now see check the dependencies a B both can determine C D do you have a B yes I have a B so I can determine both C and D so a B closer would also find out a B itself because of reflexivity and a B can determine C D do you have a B yes so I can determine C D so this closure of the say B is containing all the attributes so a B is what super key a B is still a super here right now can you discard any more attribute from a b c can determine a you have do you have C no they can determine B but we don't have B so we cannot discard any more attribute right so now check out as a B's so candidate he or not find out the proper subset that is a and B find out closure of a find out a and B individual can be a super cure node closure of a single a can determine a but we don't have a B so we cannot determine C D so only a can throw my itself we can determine B only B so this is not super key this is not super key so it means candidate here a B is what candidate key we have got one candidate it means prime attributes are a and B right now check more candidate keys are present or not how to check if prime attributes are present on the right hand side of any functional dependency then definitely more candidate keys would be there C is present on the right hand side of this functional dependency right means you will get more candidate he is here right now how to do that thing C existing candidate is this one so at the place of a you can replace a with C after replacing you will get C B right and second option is C B is also prime attribute and B is present on the right hand side of D so second option is at the place of B you can write down B but I'm not saying that this and s would be definitely candidate is still you need to find out but yeah I can say that this and this are super keys right so now check out the proper subset of B and C 1 is B 1 is C check out these are super keys or not find out to be closer see B is not a super key C closer so you can determine itself C can determine a nothing else so this is not super key so it means B C is also candidate key right so now we go to one more prime attribute that is C now check out a DS candidate key or not a closer not candidate key be closer be closer can find out B and B nothing else so this is also not super case so this is also candidate key here fine so a and D so D is also prime attribute right now you can check we have got two more prime attributes now check these are available on the right hand side of any functional dependencies or not yes available see this you can write down something like this by splitting property a B can determine C and a B can determine D so at the place of C you can replace it with a B here a B so obviously not right abb a B but we have got on the candidate he a B so no need to replace and at D also a be at D also a B so we have already got a B so no need to replace so now these are the candidate III candidate he's in this relation and prime attributes are ABCD now here all the attributes of the relations are prime atributes so definitely that relation would be in second normal form why so because there is no nonprime attribute if no nonprime attribute then you will never get this type of situation because proper subset of candidate key is determining nonprime attribute this is partial dependency but we don't have any known primate review so you will never get this kind of dependency here right see at the right hand side nonprime attribute should be there you can check right hand side CD but CDs prime attribute a is also prime attribute B B's also prime attribute fine so if all the attribute of a relation R prime attributes then that relation is definitely in second adorable form right let us take third example so third is this type of question four attributes are there in our relation these are the functional dependence you find out the candidate key first of all how to find out simple rule take all the attributes obviously the closer would be ABCD find out all the attributes so this would be super key right now try to discard attributes how will discard to check the functional dependency is determining B so do you have a yes I can discard be a yet remaining BB is determining see so by transitivity property a will determine C so I can discard C because I have a now third is what C is determining B means a can determine C and C can determine D by transitivity property so means here if you have a so you can discard B so now we are left with only a so find out a closer is it super clear node a will determine itself so we have a a will determine V do you have a yes so it will determine B B will determine CSU will determine D so I am getting all the attributes of a relation so a is what super key right now is a candidate key or not definitely yes why so because proper subset of this is what Phi only right how to find out proper subset that also I have discussed in the previous video you can check out that video in the SCI button right that is Phi and Phi a set of attribute cannot determine any attribute of a relation so definitely if one attribute is there in a super key then definitely that would be candidate key so here is what candidate so prime attribute we got a now check prime attribute is available on the right hand side of any functional dependency here we have B here we have C here we already know it means there would not be no more candidate keys here we have only one candidate key that is a now see here candidate key is having only one attribute so proper subset of candidate key can you get any proper subset of this proper subset would be what Phi only no attribute would be there right now there is no proper subset of candidate key so definitely we will never get this kind of dependency here so there is no func partial dependency so this would be in second normal form this relation would be in second normal form so you can say something like this if candidate is having only single attribute single attribute right then definitely that relation would be in second normal form right it's not like that may be may be in some case in some relation one candidate he is on having single attribute another candidate he is having two attribute in that case you cannot say that there would not be any partial dependency because one candidate key is having two attributes so you can find out proper subset of this you can you cannot find out proper subset of this but you can find out proper subset of this right so it means if all the candidate keys here luckily I have only one candidate key but if suppose all the candidate keys two candidate keys are there oh three candidate keys are there and all the three candidate keys are having single single ID then definitely there would be no partial dependency and definitely that relation would be in second normal form now I hope you got how to find out that particular relation is in second normal form or not right and what is partial dependency now see one question for you is here this this is the relation given and functional dependencies are two functional dependency is only A to B B to D I think this is very simple question so you can tell me in the comment box that this relation is in second normal form or not right now the question is if not in second normal form then how to convert it into second normal form right so we will decompose that relation see this is not in second normal form so you will decompose this you will divide it now how to decompose it that I guess it's not the right time to tell because first of all I will tell you what is decomposition what are types of decomposition we have Llosa decomposition we have lost less decomposition right so definitely there should be loss less decomposition not this low silly composition now I am going to tell you in the next video that what is the low C decomposition and what is loss less decomposition right right and how to decompose a particular relation into loss less the composition right after that only I can I guess you can easily get that how to convert it into its second normal form how to decompose the relation right it's not the right time to tell you right now in the next video I am going to tell you that what is third normal form and how to find out that a particular relation particular given relation is in third normal form or not the basic idea right so I guess now it's done with the second normal form so now I'll see in the next video till then bye bye take care
