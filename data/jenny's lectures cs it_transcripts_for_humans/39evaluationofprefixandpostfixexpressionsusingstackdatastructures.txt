With timestamps:

00:00 - in this lecture we are going to talk
00:01 - about the evaluation of prefix and
00:03 - postfix expressions see I have already
00:05 - uploaded a video an evaluation of
00:07 - postfix expression in that video I have
00:10 - discussed evaluation of postfix
00:12 - expression using stack right in this
00:14 - video I'll discuss both method without
00:16 - using stack as well as using stack how
00:19 - you can evaluate prefix and postfix
00:21 - expressions right now see I'm taking
00:24 - suppose this as our in fixed expression
00:26 - now you have to I'm going to convert it
00:29 - into prefix expression that thing also I
00:31 - have discussed in the previous video how
00:33 - to convert infix to prefix so you can
00:36 - check out that video in this I button
00:37 - right I'm directly right writing this
00:40 - the prefix form of the same fix
00:42 - expression right and here the values of
00:44 - this these variables are I have written
00:47 - here fine now see the prefix expression
00:50 - for this in fix expression would be what
00:52 - so now this is what the prefix notation
00:55 - of the sin fix and I have here
00:57 - substituted the value of these variables
00:59 - right so now this is a prefix expression
01:01 - and now you have to evaluate this one
01:03 - you need to find out a value for this
01:05 - one see what is prefix in fix and
01:08 - postfix expression that thing also I
01:10 - have discussed in the previous video one
01:11 - of the previous video so you can check
01:12 - out that video in this I button prefix
01:15 - means how you denote the prefix notation
01:17 - first of all you will write cooperator
01:19 - then brain and here again operate right
01:24 - this is operator this is one operand
01:26 - this is another operand see here we are
01:29 - discussing specifically about binary
01:31 - operators binary operator means exactly
01:33 - they needs two operands fine now the
01:38 - first step to evaluate this expression
01:40 - is what without step I am going to
01:42 - discuss first write scan this expression
01:45 - from right to left
01:46 - in case of prefix we scan it from right
01:49 - to left and in case of postfix we scan
01:51 - the expression from left to right right
01:53 - now scan it from right to left and find
01:57 - out the first operator so while scanning
02:00 - the first operator is this one after
02:03 - this operator find out the two operand
02:07 - immediately next to this operand so
02:10 - after this operand first after this
02:12 - operator first operand is 2
02:13 - another apprentice three it means we
02:17 - first but you can say you have to find
02:19 - out this pattern operator and operand
02:23 - and operand right once you find out this
02:31 - pattern you can evaluate that thing fine
02:34 - so while scanning first operator is this
02:36 - one find out just after this operator
02:39 - the two operand when is this one one is
02:41 - this one so for this operator you can
02:43 - say these are two operands fine so this
02:48 - is a in sorry prefix expression right
02:51 - you can say within this perfect one
02:53 - prefix is this one so first of all
02:56 - evaluate this one now how do I evaluate
02:58 - this one see for this for this see this
03:02 - the first operand how you write the
03:06 - first operand then the operator and then
03:09 - the second operand means in in fixed
03:12 - form it this prefix means this 1 2
03:14 - raised to power 3 this is power 2 raised
03:17 - to power 3 means 8 right so here what
03:20 - you will write down it after evaluation
03:22 - this would become 8 so now the
03:25 - expression is something like this fine
03:28 - for this I have written 8 right I have
03:33 - even better this one now again find
03:35 - again scan from right to left and find
03:38 - out the first operator so while scanning
03:40 - from right to left
03:41 - now the first operator is thus divided
03:44 - fine now if you are this prefix
03:47 - expression is valid then definitely you
03:50 - will get 2 operand after this maybe 2 or
03:53 - 3 3 4 more operands can be there but you
03:57 - need to find out next to immediate next
04:00 - 2 suppose here 1 & 2 is also there or
04:03 - you can say 2 & 3 are also there but for
04:06 - this how you are going to evaluate this
04:08 - one for this operator the operand would
04:10 - be this one and this one just immediate
04:13 - next - we are not will not consider that
04:16 - these 1 right so here now for this case
04:21 - this is first for this operator this is
04:22 - one operand this is another operand so
04:24 - now how you can write this thing
04:26 - Steen / a now the value of this one is
04:30 - 16 divided by 8 8 is what - so now the
04:33 - expression would become this 1 3 4 and
04:37 - for this one you can write down value 2
04:40 - now another scan in another scan you
04:44 - find out from right to left this is the
04:46 - first operator now for this operator see
04:49 - our prayers are two operands are the
04:52 - next two immediate in x2 means this one
04:55 - and this one we will not consider to
04:57 - this thing you need to take care fine
05:00 - now here this is our prefix 1 a strict 3
05:04 - and 4 now for this one to evaluate this
05:06 - one this is actually 3 into 4 means
05:09 - first operand then operator you will put
05:11 - then 4 means here you will write 2 n so
05:14 - now the your expression would become 2
05:16 - here we have 2 N and here again we have
05:19 - two right now
05:21 - another scan the first from right to
05:23 - left the first operator is + now find
05:26 - out the immediate next two operands one
05:30 - is to one is 12 right so for this one
05:33 - this is our now prefix so how to
05:35 - evaluate this 1 2 + 2 l first operand
05:38 - then this operator then this 2 L means
05:41 - it becomes 14 so then now the expression
05:43 - is this operator then 14 then to see if
05:47 - your expression this prefix expression
05:49 - is not valid in that case you will not
05:52 - find maybe sometimes you will not find
05:55 - two operands after operator if this is
05:57 - the case then you can say your
05:58 - expression is not valid right now here
06:01 - this is the operator this is first
06:03 - operand this is another operand so now
06:05 - it means 14 minus 2 that is 2 n so now
06:09 - the answer is 12
06:10 - without stat you have evaluated this
06:13 - prefix expression but in this case the
06:15 - problem is what you are you have to scan
06:18 - this expression multiple times in one
06:21 - scan I got this value that is that 8th
06:25 - value in another scan for this divide
06:27 - you how evaluated another scan then
06:29 - another scan something like this fine so
06:32 - this is you can say time-consuming
06:33 - process now another thing is I want in
06:35 - one scan only I want to evaluate the
06:38 - expression I need to scan only once this
06:40 - expression from right to left and I get
06:43 - the value 12 now that thing you can do
06:45 - with stack now how you will evaluate
06:47 - this prefix expression using stack that
06:50 - thing we'll discuss now so now this is
06:52 - the stack I have taken fine you have to
06:54 - create a stack right now
06:56 - first step is start scanning the prefix
07:00 - expression from right to left and now if
07:04 - you found you find the operand then
07:07 - simply push that operand into the stack
07:10 - right so now see start scanning first of
07:14 - all we have three this is operand simply
07:17 - push it into the stack again - this is
07:20 - also operand simply push it into the
07:22 - stack next is what operator now you need
07:25 - to do what now you need to pop out two
07:29 - operands from the step 2 values from the
07:32 - stack means top of the stack and next
07:35 - element to the top also - element you
07:39 - need to pop out so now first of all pop
07:41 - out this - so you can say in operand 1 I
07:44 - have 2 and next three in operand 2 I
07:48 - have 3 only two operand you need to pop
07:51 - out if this time only to open we have
07:54 - but suppose here five four friends are
07:57 - there in that case also the top element
08:00 - and next to the top element these two
08:03 - operand you need to pop out just two
08:05 - elements right now see how you will
08:08 - evaluate now you can do operand 1 then
08:12 - the operator you find means here
08:15 - operator and here operand 2 operand 1 is
08:20 - 2 operator is this one and operand 2 is
08:23 - 3 so when word this one the value is
08:26 - this is power so 2 raised to power 3
08:28 - means 8 right and after evaluation this
08:32 - value you need to push this value into
08:35 - the stack right so we have bombed out
08:38 - this one this one and now we have pushed
08:40 - 8 here fine now
08:44 - after that after this we have 16 this is
08:46 - operand simply push it after this we
08:49 - have a gain operator right
08:51 - so now what a little pop out to operands
08:54 - the top and the next stop now now see in
08:57 - the Copeland 1 I have 16 in operand 2 I
09:00 - have it right now how to do 16 operator
09:06 - is divided and 8 this thing operate
09:08 - happened 1 operator and operand 2 now
09:11 - the value is 2 and push this value into
09:13 - the stack so now we have popped out this
09:15 - one also this one also simply push this
09:18 - 2 here now in stock I have only one
09:21 - element next is 4 this is operand push
09:23 - it into the stack next is 3 this is
09:25 - operand push it into the stack next is s
09:28 - tricks or you can say multiplication
09:30 - right now pop out the two operand now in
09:33 - this case C operand 1 is 3 means this
09:38 - you need to pop out then next operand 2
09:41 - is 4 3 we have popped out for we have
09:44 - popped out right this is now the top of
09:47 - the step right how we are going to
09:49 - perform push and pop operation that time
09:51 - also we have discussed I have already
09:53 - discussed what is stack and data
09:55 - structure in detail you can check out
09:57 - the playlist fine now see the operator
10:00 - is this one so 3 into 4 that is 12
10:04 - simply push this to n the result into
10:08 - the stack that is here we push to n
10:10 - after this we have 2 this is operand
10:13 - simply push it into the stack after this
10:15 - we have plus this is what operator now
10:18 - you need to do what push to a print
10:20 - first operand would be 2 second operand
10:23 - would be 2 n now operator is plus so
10:27 - what you need to do 2 plus 2 n you will
10:30 - read this one that is 14 and push this
10:33 - result into the string that is 14 after
10:36 - this we have - this is also operator no
10:38 - need to push anything now pop out the
10:41 - two operands from the strap now operand
10:44 - 1 is 14 operand 2 is to write and
10:51 - perform this one that is 14 minus 2 that
10:53 - is 2n and push this to L into the step
10:58 - right now see we are reached to the end
11:02 - of the expression
11:03 - but now there is nothing now in this
11:06 - case at this point of time if there is
11:09 - only one value in the stack means that
11:11 - is valid prefix expression and you have
11:15 - evaluated that prefix expression
11:17 - correctly now seeing the step I have
11:19 - only one value one element so simply
11:21 - return this value right on the top of
11:24 - the stack because at this time this is
11:25 - the top of the stack so now the answer
11:27 - would be 2n right and now the stack
11:31 - becomes empty
11:32 - as you can see using stack also we have
11:34 - found the same answer right so you can
11:37 - use stack also you can evaluate this one
11:40 - without stack also but in this case the
11:42 - compiler need to scan the expression
11:45 - only once right and in that case without
11:48 - stack the compiler need to scan the
11:50 - expression multiple times right so that
11:53 - is time-consuming process but manually
11:55 - you can evaluate this without using
11:56 - stack programmatically when you evaluate
11:58 - this thing then we use stack so now the
12:01 - algorithm for this thing is C so this is
12:04 - the algorithm first step is scan the
12:07 - prefix expression from right to left
12:08 - right you can write down here a for loop
12:10 - that is for I is equal to from length
12:13 - minus 1 to 0 till then you are going to
12:16 - scan that expression fine for each
12:19 - character in the prefix expression what
12:21 - you need to do in a loop you will write
12:23 - if operand is there what we have done
12:26 - simply push it onto the stack
12:28 - if operator is there in that case pop
12:30 - two elements operand operator so to the
12:33 - operand one is top element operand 2 is
12:35 - the next two top elements fine and now
12:37 - what we will do operand 1 operator
12:39 - operand 2 and you will store this result
12:42 - into a variable any variable you can
12:44 - take here I'm taking result and push
12:47 - this result on to the stack right and
12:49 - you are going to repeat these steps fine
12:52 - because this we are going to write down
12:53 - in a loop from length minus 1 to 0 once
12:57 - the I value becomes 0 simply you will
12:59 - return the stack top this is it this is
13:02 - the algorithm now we will see manually
13:04 - how you will evaluate a postfix
13:06 - expression right we have already
13:08 - discussed using stack how you can
13:09 - evaluate that thing the same example I
13:12 - am taking this is the example this is
13:13 - the postfix expression for this in fix
13:16 - expression how to convert infix to
13:18 - postfix that camel try your disgust you
13:20 - can check out that video in this I
13:21 - button right after conversion this is
13:23 - the postfix expression and after
13:25 - substituting the value for these
13:26 - variable now this is a postfix
13:27 - expression now you have to find out the
13:29 - value of this one you have to evaluate
13:31 - this one now postfix means the that
13:34 - pattern would be operand operand and
13:40 - here operator binary operator I'm
13:45 - talking about means operand opened and
13:47 - after that operator for this operator
13:48 - these two are the operands right now in
13:52 - this case you need to scan it from left
13:54 - to right almost same algorithm we have
13:57 - evaluation of prefix and postfix this is
14:00 - what evaluation of postfix I am
14:04 - discussing here right now see scan it
14:08 - from left to right and find out the
14:12 - first operator as soon as you find out
14:15 - the first operator that is we have found
14:17 - s trick here without step I am
14:18 - discussing here right now you need to
14:21 - find out this pattern find out the two
14:24 - preceding operand for this operator to
14:28 - proceeding right it doesn't mean that
14:31 - here we have three operands so you can
14:33 - take two or three no immediate previous
14:36 - to open you need to find out this
14:38 - pattern you need to find out operator so
14:41 - this is the operator this is one operand
14:43 - this is another option you can say why
14:44 - so now here you can say obtain one we
14:48 - have three and operand 2 we have four
14:51 - right now this case means 3 into 4 this
14:57 - is actually something like this you need
14:59 - to evaluate this one 3 into 4 that is 12
15:02 - so you have to substitute here to L
15:05 - means now the expression would be 2 here
15:07 - we have 2 L then plus then 16 then 2 3
15:12 - this one then divide and then - right
15:16 - again in the next scan the first
15:18 - operator you find is + now find out this
15:22 - pattern if the expression is valid then
15:25 - everywhere you will find out this
15:27 - pattern till you get 1
15:30 - now see before this plus one operand is
15:33 - this one one is this one it means this
15:37 - is the expression now postfix expression
15:39 - so it means here we have 2 plus 2 L 2
15:42 - plus 12 means 14 here you lied 14 here
15:45 - we have 16 2 3
15:48 - this this and this this is the
15:50 - expression now now another skin again
15:54 - compiler will scan this end the first
15:56 - operator is this one now for this
15:58 - operator immediate previous two operands
16:01 - one is this one one is this one means
16:03 - this one now it means to raise to power
16:05 - 3 to raise power 3 means 8 so now the
16:07 - expression would be 1416 here you will
16:10 - write 8 divided and - again in another
16:13 - skin the first operator you find is this
16:16 - 1 for this operator this is the operand
16:19 - this is the operand operand operand one
16:21 - is this one open 2 is this one now it
16:23 - means 16 divided by 8 means to here you
16:27 - will write 14 - and - now in another
16:32 - skin the first operator is - now for
16:34 - this operator find out the previous two
16:37 - operands immediate previous one is this
16:40 - one one is this one right now 14 and 2
16:43 - it means 14 minus 2 that is 12 and now
16:46 - we got 12
16:47 - answer is same because we are we are
16:49 - taking the same expression right so now
16:52 - this is how you can evaluate the postfix
16:53 - expression without using stack if stack
16:56 - you use that is also a very simple see
16:59 - briefly I am talking about from left to
17:02 - right start scanning if our friend you
17:04 - will find push it into the stack means
17:06 - here we have to simply push it into the
17:08 - stack
17:09 - next is 3 simply push it into the stack
17:11 - next is 4 simply push it into the stack
17:14 - next is multiplication now you need to
17:17 - pop out two elements from the stack
17:19 - right but here the slight difference
17:22 - from the evaluation of prefixes what
17:25 - here when you pop out this 4 it means it
17:30 - is operand 2 not operand 1 the next
17:35 - element is operand 1 that is 3 so
17:40 - actually you are going to do what now we
17:42 - are going to do or
17:43 - and one here the operator and operand to
17:48 - write but in that case you remember when
17:52 - you pop out this thing then this would
17:53 - be operator one and this would be sorry
17:55 - this would be operand 1 this would be
17:56 - operand 2 but here the thing are
17:59 - different slight differences this thing
18:01 - only this would be copper end to this
18:04 - one and this would be operand 1 just
18:07 - reverse right means here 3 into 4
18:11 - operator is this one 3 into 4 and here
18:15 - also here also same thing we have done
18:16 - that is to L see in multiplication there
18:20 - would be no problem if you write 4 into
18:21 - 3 or 3 into 4 but in case of divide it
18:24 - would create a problem so you need to
18:25 - take care of these rules in case of -
18:28 - also it would create a problem now see
18:31 - simply push this result here means 2 L
18:34 - so simply push this 12 here now next is
18:38 - Plus this is also operator so pop out
18:41 - two operand so here in this case now
18:45 - operand 2 is what - well operand 1 is
18:49 - what - so now operand 1 that is -
18:54 - operator is plus and here we have 2 L
18:56 - means 14 so here I have written what 14
18:59 - by now C so simply push this 14 here
19:04 - because we have got out of these two now
19:07 - we have 14 here 16 simply push the 16
19:10 - here next we have to simply push this if
19:13 - operator operand is there simply push
19:15 - that next is 3 this is also apparent
19:17 - simply push it now next is exponent now
19:21 - pop out - operand - element from the
19:24 - step here operand - would be 3 and
19:27 - operand 1 would be 2 so now we append 1
19:33 - operator operand 2 means 2 operator is
19:37 - this 1 2 raise to power 3 that is 8 and
19:41 - simply push that result into the step
19:43 - means we have popped out 3 and 2 and now
19:46 - it you are going to push next is divide
19:49 - same pop out two operand from here so
19:53 - now in this case operand 2 would be 8
19:56 - and one would be 60 we have popped out
19:58 - these things now put out put here opened
20:01 - one is 16 16 operators divided it is
20:04 - eights / is for a 16 / ready it is to
20:08 - push that result here next is - pop out
20:12 - this one again - opened from the stack
20:14 - now opened 2 is 2 and operand 1 is 14
20:19 - now here simply push operand 1 is 14
20:22 - operator is - here we have 2 and simply
20:25 - push that here now we have reached till
20:27 - the end of the expression now if in the
20:30 - stack I have only one value and here you
20:32 - can see here will be how only one value
20:34 - now return the top of the stack that is
20:35 - - well you are going to return means the
20:38 - result is 12 and we have formed the same
20:40 - result
20:41 - so I guess algorithm you can easily
20:42 - write down or four algorithm you can
20:44 - check out this video in the side button
20:46 - see we can also represent this in fixed
20:49 - expression into a tree form binary tree
20:52 - form how we are going to represent this
20:54 - thing into a tree form how you can
20:56 - create that expression tree that thing
20:58 - we will discuss in the next video so
21:00 - I'll see you in the next video - the
21:01 - number why take it

Cleaned transcript:

in this lecture we are going to talk about the evaluation of prefix and postfix expressions see I have already uploaded a video an evaluation of postfix expression in that video I have discussed evaluation of postfix expression using stack right in this video I'll discuss both method without using stack as well as using stack how you can evaluate prefix and postfix expressions right now see I'm taking suppose this as our in fixed expression now you have to I'm going to convert it into prefix expression that thing also I have discussed in the previous video how to convert infix to prefix so you can check out that video in this I button right I'm directly right writing this the prefix form of the same fix expression right and here the values of this these variables are I have written here fine now see the prefix expression for this in fix expression would be what so now this is what the prefix notation of the sin fix and I have here substituted the value of these variables right so now this is a prefix expression and now you have to evaluate this one you need to find out a value for this one see what is prefix in fix and postfix expression that thing also I have discussed in the previous video one of the previous video so you can check out that video in this I button prefix means how you denote the prefix notation first of all you will write cooperator then brain and here again operate right this is operator this is one operand this is another operand see here we are discussing specifically about binary operators binary operator means exactly they needs two operands fine now the first step to evaluate this expression is what without step I am going to discuss first write scan this expression from right to left in case of prefix we scan it from right to left and in case of postfix we scan the expression from left to right right now scan it from right to left and find out the first operator so while scanning the first operator is this one after this operator find out the two operand immediately next to this operand so after this operand first after this operator first operand is 2 another apprentice three it means we first but you can say you have to find out this pattern operator and operand and operand right once you find out this pattern you can evaluate that thing fine so while scanning first operator is this one find out just after this operator the two operand when is this one one is this one so for this operator you can say these are two operands fine so this is a in sorry prefix expression right you can say within this perfect one prefix is this one so first of all evaluate this one now how do I evaluate this one see for this for this see this the first operand how you write the first operand then the operator and then the second operand means in in fixed form it this prefix means this 1 2 raised to power 3 this is power 2 raised to power 3 means 8 right so here what you will write down it after evaluation this would become 8 so now the expression is something like this fine for this I have written 8 right I have even better this one now again find again scan from right to left and find out the first operator so while scanning from right to left now the first operator is thus divided fine now if you are this prefix expression is valid then definitely you will get 2 operand after this maybe 2 or 3 3 4 more operands can be there but you need to find out next to immediate next 2 suppose here 1 & 2 is also there or you can say 2 & 3 are also there but for this how you are going to evaluate this one for this operator the operand would be this one and this one just immediate next we are not will not consider that these 1 right so here now for this case this is first for this operator this is one operand this is another operand so now how you can write this thing Steen / a now the value of this one is 16 divided by 8 8 is what so now the expression would become this 1 3 4 and for this one you can write down value 2 now another scan in another scan you find out from right to left this is the first operator now for this operator see our prayers are two operands are the next two immediate in x2 means this one and this one we will not consider to this thing you need to take care fine now here this is our prefix 1 a strict 3 and 4 now for this one to evaluate this one this is actually 3 into 4 means first operand then operator you will put then 4 means here you will write 2 n so now the your expression would become 2 here we have 2 N and here again we have two right now another scan the first from right to left the first operator is + now find out the immediate next two operands one is to one is 12 right so for this one this is our now prefix so how to evaluate this 1 2 + 2 l first operand then this operator then this 2 L means it becomes 14 so then now the expression is this operator then 14 then to see if your expression this prefix expression is not valid in that case you will not find maybe sometimes you will not find two operands after operator if this is the case then you can say your expression is not valid right now here this is the operator this is first operand this is another operand so now it means 14 minus 2 that is 2 n so now the answer is 12 without stat you have evaluated this prefix expression but in this case the problem is what you are you have to scan this expression multiple times in one scan I got this value that is that 8th value in another scan for this divide you how evaluated another scan then another scan something like this fine so this is you can say timeconsuming process now another thing is I want in one scan only I want to evaluate the expression I need to scan only once this expression from right to left and I get the value 12 now that thing you can do with stack now how you will evaluate this prefix expression using stack that thing we'll discuss now so now this is the stack I have taken fine you have to create a stack right now first step is start scanning the prefix expression from right to left and now if you found you find the operand then simply push that operand into the stack right so now see start scanning first of all we have three this is operand simply push it into the stack again this is also operand simply push it into the stack next is what operator now you need to do what now you need to pop out two operands from the step 2 values from the stack means top of the stack and next element to the top also element you need to pop out so now first of all pop out this so you can say in operand 1 I have 2 and next three in operand 2 I have 3 only two operand you need to pop out if this time only to open we have but suppose here five four friends are there in that case also the top element and next to the top element these two operand you need to pop out just two elements right now see how you will evaluate now you can do operand 1 then the operator you find means here operator and here operand 2 operand 1 is 2 operator is this one and operand 2 is 3 so when word this one the value is this is power so 2 raised to power 3 means 8 right and after evaluation this value you need to push this value into the stack right so we have bombed out this one this one and now we have pushed 8 here fine now after that after this we have 16 this is operand simply push it after this we have a gain operator right so now what a little pop out to operands the top and the next stop now now see in the Copeland 1 I have 16 in operand 2 I have it right now how to do 16 operator is divided and 8 this thing operate happened 1 operator and operand 2 now the value is 2 and push this value into the stack so now we have popped out this one also this one also simply push this 2 here now in stock I have only one element next is 4 this is operand push it into the stack next is 3 this is operand push it into the stack next is s tricks or you can say multiplication right now pop out the two operand now in this case C operand 1 is 3 means this you need to pop out then next operand 2 is 4 3 we have popped out for we have popped out right this is now the top of the step right how we are going to perform push and pop operation that time also we have discussed I have already discussed what is stack and data structure in detail you can check out the playlist fine now see the operator is this one so 3 into 4 that is 12 simply push this to n the result into the stack that is here we push to n after this we have 2 this is operand simply push it into the stack after this we have plus this is what operator now you need to do what push to a print first operand would be 2 second operand would be 2 n now operator is plus so what you need to do 2 plus 2 n you will read this one that is 14 and push this result into the string that is 14 after this we have this is also operator no need to push anything now pop out the two operands from the strap now operand 1 is 14 operand 2 is to write and perform this one that is 14 minus 2 that is 2n and push this to L into the step right now see we are reached to the end of the expression but now there is nothing now in this case at this point of time if there is only one value in the stack means that is valid prefix expression and you have evaluated that prefix expression correctly now seeing the step I have only one value one element so simply return this value right on the top of the stack because at this time this is the top of the stack so now the answer would be 2n right and now the stack becomes empty as you can see using stack also we have found the same answer right so you can use stack also you can evaluate this one without stack also but in this case the compiler need to scan the expression only once right and in that case without stack the compiler need to scan the expression multiple times right so that is timeconsuming process but manually you can evaluate this without using stack programmatically when you evaluate this thing then we use stack so now the algorithm for this thing is C so this is the algorithm first step is scan the prefix expression from right to left right you can write down here a for loop that is for I is equal to from length minus 1 to 0 till then you are going to scan that expression fine for each character in the prefix expression what you need to do in a loop you will write if operand is there what we have done simply push it onto the stack if operator is there in that case pop two elements operand operator so to the operand one is top element operand 2 is the next two top elements fine and now what we will do operand 1 operator operand 2 and you will store this result into a variable any variable you can take here I'm taking result and push this result on to the stack right and you are going to repeat these steps fine because this we are going to write down in a loop from length minus 1 to 0 once the I value becomes 0 simply you will return the stack top this is it this is the algorithm now we will see manually how you will evaluate a postfix expression right we have already discussed using stack how you can evaluate that thing the same example I am taking this is the example this is the postfix expression for this in fix expression how to convert infix to postfix that camel try your disgust you can check out that video in this I button right after conversion this is the postfix expression and after substituting the value for these variable now this is a postfix expression now you have to find out the value of this one you have to evaluate this one now postfix means the that pattern would be operand operand and here operator binary operator I'm talking about means operand opened and after that operator for this operator these two are the operands right now in this case you need to scan it from left to right almost same algorithm we have evaluation of prefix and postfix this is what evaluation of postfix I am discussing here right now see scan it from left to right and find out the first operator as soon as you find out the first operator that is we have found s trick here without step I am discussing here right now you need to find out this pattern find out the two preceding operand for this operator to proceeding right it doesn't mean that here we have three operands so you can take two or three no immediate previous to open you need to find out this pattern you need to find out operator so this is the operator this is one operand this is another option you can say why so now here you can say obtain one we have three and operand 2 we have four right now this case means 3 into 4 this is actually something like this you need to evaluate this one 3 into 4 that is 12 so you have to substitute here to L means now the expression would be 2 here we have 2 L then plus then 16 then 2 3 this one then divide and then right again in the next scan the first operator you find is + now find out this pattern if the expression is valid then everywhere you will find out this pattern till you get 1 now see before this plus one operand is this one one is this one it means this is the expression now postfix expression so it means here we have 2 plus 2 L 2 plus 12 means 14 here you lied 14 here we have 16 2 3 this this and this this is the expression now now another skin again compiler will scan this end the first operator is this one now for this operator immediate previous two operands one is this one one is this one means this one now it means to raise to power 3 to raise power 3 means 8 so now the expression would be 1416 here you will write 8 divided and again in another skin the first operator you find is this 1 for this operator this is the operand this is the operand operand operand one is this one open 2 is this one now it means 16 divided by 8 means to here you will write 14 and now in another skin the first operator is now for this operator find out the previous two operands immediate previous one is this one one is this one right now 14 and 2 it means 14 minus 2 that is 12 and now we got 12 answer is same because we are we are taking the same expression right so now this is how you can evaluate the postfix expression without using stack if stack you use that is also a very simple see briefly I am talking about from left to right start scanning if our friend you will find push it into the stack means here we have to simply push it into the stack next is 3 simply push it into the stack next is 4 simply push it into the stack next is multiplication now you need to pop out two elements from the stack right but here the slight difference from the evaluation of prefixes what here when you pop out this 4 it means it is operand 2 not operand 1 the next element is operand 1 that is 3 so actually you are going to do what now we are going to do or and one here the operator and operand to write but in that case you remember when you pop out this thing then this would be operator one and this would be sorry this would be operand 1 this would be operand 2 but here the thing are different slight differences this thing only this would be copper end to this one and this would be operand 1 just reverse right means here 3 into 4 operator is this one 3 into 4 and here also here also same thing we have done that is to L see in multiplication there would be no problem if you write 4 into 3 or 3 into 4 but in case of divide it would create a problem so you need to take care of these rules in case of also it would create a problem now see simply push this result here means 2 L so simply push this 12 here now next is Plus this is also operator so pop out two operand so here in this case now operand 2 is what well operand 1 is what so now operand 1 that is operator is plus and here we have 2 L means 14 so here I have written what 14 by now C so simply push this 14 here because we have got out of these two now we have 14 here 16 simply push the 16 here next we have to simply push this if operator operand is there simply push that next is 3 this is also apparent simply push it now next is exponent now pop out operand element from the step here operand would be 3 and operand 1 would be 2 so now we append 1 operator operand 2 means 2 operator is this 1 2 raise to power 3 that is 8 and simply push that result into the step means we have popped out 3 and 2 and now it you are going to push next is divide same pop out two operand from here so now in this case operand 2 would be 8 and one would be 60 we have popped out these things now put out put here opened one is 16 16 operators divided it is eights / is for a 16 / ready it is to push that result here next is pop out this one again opened from the stack now opened 2 is 2 and operand 1 is 14 now here simply push operand 1 is 14 operator is here we have 2 and simply push that here now we have reached till the end of the expression now if in the stack I have only one value and here you can see here will be how only one value now return the top of the stack that is well you are going to return means the result is 12 and we have formed the same result so I guess algorithm you can easily write down or four algorithm you can check out this video in the side button see we can also represent this in fixed expression into a tree form binary tree form how we are going to represent this thing into a tree form how you can create that expression tree that thing we will discuss in the next video so I'll see you in the next video the number why take it
