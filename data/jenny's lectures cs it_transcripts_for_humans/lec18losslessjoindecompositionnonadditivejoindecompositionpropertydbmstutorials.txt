With timestamps:

00:00 - in the previous video we have discussed
00:01 - one property of the composition that is
00:03 - a dependency preserving right and in
00:06 - this video we will discuss the second
00:08 - property of decomposition that has lost
00:10 - less join decomposition this is
00:12 - mandatory property for decomposition it
00:14 - means the decomposition must be lossless
00:17 - the dependency preserving property that
00:19 - is you can say it's not a mandatory
00:22 - property why so because sometimes it is
00:25 - not possible to get dependency
00:27 - preserving bcnf decomposition right but
00:30 - up to third and if it is always possible
00:33 - to get a dependency preserving the
00:35 - composition right that is why somewhere
00:38 - it is written that the dependency
00:40 - preserving properties were optional
00:42 - right but when it comes to property of
00:44 - decomposition then there are two
00:46 - properties of decomposition dependency
00:48 - preserving and lossless during
00:50 - decomposition right I hope you know what
00:52 - is the composition and why we do
00:54 - decomposition basically to do to perform
00:56 - her to perform normalization means to
00:58 - convert a relation into higher normal
01:00 - form right if a relation is in 2nf and
01:02 - you want to convert it in to be CNF then
01:04 - we will decompose that relation into
01:06 - multiple relations right that is
01:08 - decomposition what that is why we need
01:09 - decomposition join means combine to
01:13 - combine something right or to merge and
01:15 - lossless means without any loss simple
01:18 - English meaning is this thing right now
01:20 - the meaning of this complete word is
01:23 - what lossless no enjoying decomposition
01:25 - in the context of database that I will
01:28 - discuss with the help of a proper
01:30 - example what is lossless join
01:32 - decomposition right see suppose I have a
01:36 - relation R right and I have performed
01:39 - decomposition on this relation to
01:41 - convert into higher normal forms suppose
01:44 - I have decomposed it into R 1 and R 2 2
01:47 - relations only you can decompose it into
01:49 - R 1 R 2 R 3 multiple relations right
01:52 - suppose error hi all decomposed it in
01:54 - into R 1 and R 2 right now if I ask you
01:58 - one question and we have performed our
02:01 - operations and all but sometimes suppose
02:03 - after sometimes we need to combine these
02:08 - two relations right now the question is
02:13 - if I combine these two relation again in
02:16 - simple terms I am saying combined word
02:18 - or you can say if we join these two
02:20 - relation obviously we are going to
02:22 - perform natural join operation here
02:24 - right so if you can join these are these
02:27 - relations then should you get the same
02:33 - relation are yes or no here means after
02:38 - combining after joining these two
02:40 - relation should this resultant relation
02:43 - be equal to this original one definitely
02:46 - yes it is common sense right or you can
02:49 - say that see this is the relation
02:51 - original one parent one and this only we
02:53 - have decomposed this into two sub
02:56 - relations right and after that once you
02:59 - sometimes later when you will join these
03:01 - two then definitely we will get the same
03:03 - relation right exactly same whatever the
03:07 - value of R whatever the digit data in
03:09 - are exactly same data should be present
03:12 - in this are after joining right if this
03:16 - is a case then it is you can say that
03:18 - lossless join be composition so in
03:21 - simple terms what you can say what does
03:23 - this property say that a decomposition
03:26 - of a relation R is said to be lossless
03:30 - if it is feasible to reconstruct the
03:34 - relation R from decomposed sub relations
03:39 - using joints then you can say that that
03:44 - decomposition is lossless I am going to
03:46 - write down the summary of this lecture
03:48 - at last in form of three or four points
03:50 - right and you will also discuss with the
03:53 - help of one or two examples that the
03:55 - decomposition is lossless or not how to
03:57 - find out that the decomposition is
03:58 - lossless join decomposition or not right
04:00 - now suppose I have decomposed in this
04:03 - relation into PO sub relation R 1 and R
04:04 - 2 now you have to check is this
04:06 - decomposition lossless join the
04:09 - composition or not now obviously for
04:11 - that you have to join these two relation
04:13 - you have to combine these two relation
04:15 - right so you must know what is join
04:17 - operation how to perform natural join on
04:19 - relations so let me give you a quick
04:22 - introduction of natural join operation
04:24 - with the help of an example say I am
04:25 - taking a simple
04:26 - example suppose I have these two sub
04:29 - relation r1 and r2 right the data is
04:31 - this one small relation I am taking now
04:34 - what is the result of Cartesian product
04:37 - first of all I am going to tell you
04:39 - Cartesian product because natural join
04:41 - is improved version of Cartesian product
04:43 - then only you can get it better that
04:45 - what is natural join so how to do
04:47 - Cartesian product of carbon in our two
04:49 - simple as what obviously we will do what
04:52 - in our one I have I'm having a B in R
04:55 - why I am having BC so in Cartesian
04:57 - product of r1 and r2 this would be the
04:59 - resultant table right now Cartesian
05:03 - product is what see the first row of
05:06 - this r1 would be combined with each row
05:10 - of r2 right means here we have 1 1 then
05:14 - it will be combined with first row then
05:17 - again we have 1 1 then it will be
05:19 - combined combined with 1 2 then again 1
05:21 - 1 it will be combined with these 3 2 1
05:26 - right second is again the second will be
05:30 - combined with each row same third row
05:34 - will be combined with each row this is
05:37 - what Cartesian product right so the
05:39 - answer is so this is the Cartesian
05:41 - product of these two means each row of
05:42 - one relation will be combined with each
05:45 - row of other relation right so the
05:49 - resultant here we have what nine rows 3
05:53 - into 3 right now what is natural join
05:58 - this is improved version of this
06:00 - Cartesian product right now in natural
06:03 - join of these records you will consider
06:07 - only those records in which in which see
06:12 - here the common attribute is B right so
06:16 - we will consider only those records in
06:18 - which are one dot B how one is the name
06:23 - of this relation is equal to R 2 dot B B
06:27 - is what that common attribute in these
06:30 - two so if you have common attribute in
06:33 - the relation then only you can apply
06:34 - natural join I'll also discuss if no
06:38 - common attribute is there
06:39 - then what will be the result of natural
06:41 - journey first of all so now see here
06:45 - this bees of our one this bees of our
06:48 - two right so now our one dot B are two
06:51 - dot B both are same so we will consider
06:53 - this record and see I'm taking like this
06:59 - 1 1 1 1 here also 1 1 will consider this
07:03 - also in this R 1 dot B is 1 R to go to
07:08 - bees to will not consider this one
07:09 - because this condition is not satisfied
07:11 - so this would not be included in natural
07:13 - join this double here 1 1 so definitely
07:16 - you would consider this one here also 1
07:19 - 1 so we will consider this one also
07:21 - everyone to will not consider this 1 2
07:23 - and we will not consider this 1 2 and
07:25 - not equals will not consider this 1 2 2
07:27 - it is equal so will consider this one so
07:29 - now the result of natural join would be
07:31 - this one only
07:33 - now see here B and B both how to click
07:36 - it right so no need to write it write
07:39 - down again B you just write down single
07:42 - B so there is a return table how you
07:43 - will write like this the natural join of
07:47 - these two would be this one only 5
07:49 - records would be there in Cartesian
07:51 - product 9 records would be there now if
07:53 - no common attribute is there suppose
07:56 - here I am having R 1 is a B and R 2 is C
08:00 - B so I'm asking you are one natural join
08:05 - are to what would be the result because
08:08 - there is no common attribute so we
08:09 - cannot apply this condition so the
08:11 - result would be same you just do
08:14 - Cartesian product and that would be the
08:16 - result of natural join as well because
08:18 - there is no common attribute in that
08:20 - case the result of Cartesian product
08:22 - would be same as the result of natural
08:23 - job like if there is no common attribute
08:26 - and if you want to join suppose R 1 R 2
08:31 - R 3 R 4 multiple table tables are there
08:33 - sub relations are then you want to join
08:35 - these all these so at same time we
08:39 - cannot join all the 4 because the join
08:42 - this one is what binary operation so at
08:46 - first just take two either you can see R
08:48 - 1 R 2 suppose I am taking only 3 or you
08:50 - can take R 2 R 3 or you can take R 1
08:53 - three suppose I am taking these two so
08:55 - r1 and r2 after joining become suppose
08:58 - r1 are going to after that you can join
09:00 - it with r3 like this you can perform
09:03 - your own operation all the type of these
09:05 - all the variants we will discuss one by
09:07 - one later in all the examples right so I
09:09 - hope you got how to perform natural join
09:12 - right now check this decomposition is
09:14 - lossless join decomposition or not I
09:16 - have decomposed this into r1 and r2 so R
09:19 - 1 is having will these require r2 is
09:21 - having these records right now perform
09:24 - r1 natural join our two if after joining
09:29 - these two you get the same table as are
09:33 - exactly same records only four tuples
09:36 - exactly same tuples then you can say
09:39 - that it is lossless in Joran otherwise
09:41 - not right now see what you will get so
09:44 - here the common attribute is B so just
09:47 - apply this condition right so here we
09:51 - are not going to combine this row with
09:53 - each row of the r2 we will combine this
09:57 - with the row far too in which this B
10:00 - value is same as of r1 see here B value
10:03 - is 1 so can you combine this with this
10:06 - first one yes because here also B value
10:08 - is 1 so though 1 record would would be I
10:11 - am NOT going to run it right down b2
10:12 - times because that would be duplicate
10:14 - only one time you we're going to write 1
10:16 - 1 and 1 can you combine this with this
10:19 - yes because here also be 1 here also be
10:21 - 1 right so 1 1 2 can you combine this
10:26 - row with this third one no because here
10:28 - B value is 1 here is 2 can you combine
10:31 - with this one no okay
10:33 - now the next one can you combine this
10:34 - with the first one yes this with second
10:38 - one yes because 1 + 1 B value sing so to
10:44 - motor purrs now can you combine this
10:47 - with this no can you combine this with
10:49 - this no now this 1 3 2 now come can you
10:54 - combine this one with this row know the
10:57 - value is 1 here B value is 2 not same so
11:00 - we can combine this with only this
11:02 - record so 3 2 1 and we can combine this
11:06 - one
11:06 - this this only so four three two I hope
11:09 - you got that we will get this result
11:12 - only right now see in the original one I
11:15 - have one one one yes we got this one -
11:18 - one two - one - yes we got this one
11:21 - three two one yes you got this one and
11:23 - four three - yes you or this one right
11:25 - but these two records are extra records
11:28 - now please don't say that this is
11:30 - lossless why because we got everything
11:33 - whatever is there in our we got
11:35 - everything and even we got something
11:37 - extra so it is not loss see it is we
11:39 - have gained something right no the extra
11:43 - is very dangerous when you are dealing
11:45 - with the composition right we are not
11:48 - going to accept any extra record
11:50 - yeah extra is good in real life because
11:53 - I don't you'll be happy if someone will
11:55 - give you something extra but in this
11:57 - case it is very dangerous so this is not
11:59 - lossless you must get exactly same
12:04 - relation as the original one no less
12:07 - records no extra records right so this
12:11 - property ensures that you will get
12:13 - exactly the same relation as the
12:16 - original one right right after joining
12:19 - the decomposed relations no extra topple
12:23 - no less step right and maybe suppose I
12:29 - am taking this the composition r1 and r2
12:31 - here I'm having a B here I'm having only
12:34 - B although this decomposition is
12:36 - logically not possible but suppose you
12:39 - have given something like this and you
12:41 - are asked that tell me it is lossless or
12:43 - not definitely by looking at this only
12:46 - you can see it is lossless why so
12:48 - because here I have I'm having C but
12:50 - here I'm not having any attribute C
12:52 - right so C the one first property is
12:57 - what the union of attributes of the
12:59 - decomposed relations must be equal to
13:03 - that reviewed of the original relation
13:05 - right if suppose I am having to have
13:08 - decomposed a relation into r1 and r2 so
13:10 - you can say that attribute of r1 Union
13:13 - r2
13:14 - of our two must be equal to attribute oh
13:17 - ah definitely right so if we have BC
13:22 - then it's fine ABC Union is ABC and
13:25 - attribute of RS also ABC right second
13:29 - property you can say suppose there is no
13:31 - common attribute then I have already
13:34 - discussed the result of the natural join
13:36 - would be same as the result of Cartesian
13:39 - product right and in Cartesian product
13:42 - we are obviously we are getting extra
13:45 - apples I have already discussed here
13:47 - right so in that case also it is lossy
13:50 - it is not lossless so there must be
13:53 - common attributes between the decomposed
13:57 - relations right suppose I have
13:59 - decomposed into two sub relations so you
14:02 - can say attribute of r1 intersection
14:05 - attribute of R 2 intersection should not
14:10 - be fine
14:12 - it means there must be some common
14:15 - attribute at least one common attribute
14:18 - if you do intersection of a B & B C you
14:20 - will get what B and that is not fine if
14:23 - you will get intersection of like this
14:27 - CD suppose I am having one more
14:30 - attribute C sorry B a B and C D is r1
14:34 - and r2 having any common attribute no
14:37 - right so definitely by looking at this
14:40 - only you can say it is lossy it is not
14:42 - lossless no need to check that do the
14:45 - natural join and all because definitely
14:46 - after natural join you will get
14:49 - something extra in in the resultant
14:52 - table but here see this property
14:56 - satisfied this property is also
14:57 - satisfied in this case but still it is
14:59 - not lossless so there is one more third
15:02 - property also that is very important C
15:05 - Union is ABC find common attribute is
15:08 - they are fine but still it is lossless
15:10 - why so because here see this B is having
15:14 - duplicate values right because of this
15:17 - because of this one this is having
15:20 - duplicate value so it will be combined
15:22 - with one in two rows it is also having
15:24 - duplicate
15:24 - it will be combined with two rows here
15:26 - it's fine it will be combined only this
15:28 - row and this row so one important
15:32 - property is what the common attribute
15:36 - must be a super key or you can say
15:40 - candidate Li if the common attribute is
15:43 - super key of either r1 or r2 or you can
15:49 - say if the common attribute is super key
15:52 - of at least one sub relation then
15:57 - definitely that would be lossless join
16:00 - be composition right I am having two sub
16:04 - relation so common attribute is B if B
16:08 - is super key or at least one subrogation
16:13 - either r1 or r2 or maybe both
16:16 - if being super Q of R 1 then also it
16:19 - would be lost less if being super clear
16:22 - car 2 then also it would be lost as if
16:24 - we super key of r1 and r2 both then also
16:26 - it would be lossless right so let us
16:29 - take this type of example now let us
16:32 - take this decomposition r1 is having a B
16:34 - and r2 is having a C right first of all
16:37 - see the union of these one attribute of
16:39 - these 1 ABC union of attribute of these
16:41 - subrogation is ABC is equal to U is
16:44 - equal to the attribute of okay do you
16:47 - have any common attribute yes I have
16:48 - common attribute right now check this is
16:51 - lossless or not now first of all check
16:54 - using natural join I'm going to do
16:56 - natural join are ones natural join are
16:58 - two so the common attribute is a so we
17:01 - are going to join based on this a see
17:04 - see the first row can you combine this
17:08 - row with this first one check the value
17:10 - of a here also and here also nearest
17:12 - definitely I can combine with this a
17:13 - right so the answer is 1 1 1 1 2 per
17:18 - second can you combine this with this
17:21 - here value of a is 2 here value of phase
17:23 - 1 no value is not same can you combine
17:25 - this with us no with this no ok second
17:28 - one can you combine this with this no
17:31 - when you combine this with this record
17:33 - yes so the next Apple is 2 1 2
17:38 - right can you combine this couple of
17:41 - this one with this one no because value
17:43 - phase not saying value phase not so
17:45 - you're not saying this you can combine
17:47 - only with this and I guess now we are
17:49 - going to this you can combine only with
17:51 - this so next record is 3 2 1 4 3 2 this
17:59 - is the resultant natural join
18:01 - table now you can see it is exactly same
18:04 - as the original one so this is what
18:06 - lossless this decomposition is lossless
18:10 - but this was not lossless right see now
18:14 - here you can say is what you can see
18:17 - directly you can see here is what super
18:20 - cool you can see candidate right using a
18:24 - candidate key of either relation I am
18:27 - NOT saying that the common attribute is
18:28 - candidate key for the original relation
18:30 - no just forget it
18:32 - right just check the common attribute is
18:35 - super key or candidate key of either of
18:39 - either this relation or this relation it
18:42 - should be candidate key for at least one
18:44 - sub relation now how to check that is
18:47 - candidate key first of all check is
18:48 - candidate key for r1 or not see if a is
18:51 - candidate key of any relation then
18:53 - definitely using that we can derive all
18:56 - that the beauty of that relation now can
19:00 - we drive be using a here because I am
19:03 - having only two attributed definitely
19:05 - using a I can drive a that is for sure
19:07 - trivial functional dependency here you
19:09 - have to check can you drive this one is
19:11 - this functional dependency possible in
19:13 - this relation have to check that already
19:15 - we have discussed one of the previous
19:17 - video you can check out that video in
19:18 - the side button yes this dependency
19:20 - exists here in this r1 so here you can
19:23 - see a is candidate for this relation so
19:27 - no need to check for this one
19:28 - fortunately is candidate key for this
19:31 - whole so you can check it right here in
19:33 - this case a is candidate key for both
19:34 - the relation but if a is candidate key
19:36 - for the first one so no need to check
19:38 - for second one that will be lossless
19:40 - join decomposition right so here in
19:43 - short you can say that three property
19:45 - must be satisfied to be lossless join
19:48 - decomposition first of--first to I have
19:50 - already discussed let me write down
19:52 - again so here you can say if a relation
19:54 - R is decomposed into two sub relation R
19:57 - 1 and R 2 then this decomposition is
19:59 - lossless if these properties are
20:03 - satisfied attribute of R 1 union
20:05 - attribute of R 2 equal to a degree 2 5
20:07 - right intersection of attributes of the
20:11 - sub relation should not be Phi right
20:13 - third property is what if I have told
20:17 - you if the common attribute is super
20:19 - pure candidate key for either this
20:22 - relation of this relation so how we are
20:24 - going to write down in two technical
20:26 - terms right so you can say common
20:29 - attribute is what obviously intersection
20:31 - of this one and this one so attribute of
20:33 - R 1 intersection a tribute o fire to
20:34 - right must drive must derive all the
20:39 - attributes of either this relation or
20:42 - this relation so all the attributes of
20:44 - either R one attribute Arbonne or
20:47 - intersection can derive all the
20:50 - attributes of this all to see this is or
20:54 - either this or this if one of this these
20:58 - properties is satisfied C 1 is this one
21:01 - one is this one and at least one of
21:03 - these two property then you can say that
21:06 - the decomposition is lossless now
21:08 - suppose the data is not given only
21:11 - relation is given and functional
21:13 - dependencies are given in that case how
21:15 - to find out that that thus this
21:18 - decomposition is lossless join
21:19 - decomposition or not so that we'll
21:21 - discuss in next video in this video see
21:23 - I have discussed in detailed manner just
21:26 - to clear out your basics that what does
21:29 - this lossless joined decomposition write
21:31 - in next video we'll discuss few more
21:34 - example of this type and simple trick
21:37 - how quickly you can find out that if in
21:40 - gate exam or net exam this type of
21:42 - question is given dependencies or you
21:45 - can say that this type of data is given
21:46 - and you can say this decomposition is
21:48 - given then how quickly you can identify
21:49 - that this is lossless or not right
21:52 - so that thing we'll discuss in next
21:53 - video so now I will see in the next
21:54 - video to the nobody care

Cleaned transcript:

in the previous video we have discussed one property of the composition that is a dependency preserving right and in this video we will discuss the second property of decomposition that has lost less join decomposition this is mandatory property for decomposition it means the decomposition must be lossless the dependency preserving property that is you can say it's not a mandatory property why so because sometimes it is not possible to get dependency preserving bcnf decomposition right but up to third and if it is always possible to get a dependency preserving the composition right that is why somewhere it is written that the dependency preserving properties were optional right but when it comes to property of decomposition then there are two properties of decomposition dependency preserving and lossless during decomposition right I hope you know what is the composition and why we do decomposition basically to do to perform her to perform normalization means to convert a relation into higher normal form right if a relation is in 2nf and you want to convert it in to be CNF then we will decompose that relation into multiple relations right that is decomposition what that is why we need decomposition join means combine to combine something right or to merge and lossless means without any loss simple English meaning is this thing right now the meaning of this complete word is what lossless no enjoying decomposition in the context of database that I will discuss with the help of a proper example what is lossless join decomposition right see suppose I have a relation R right and I have performed decomposition on this relation to convert into higher normal forms suppose I have decomposed it into R 1 and R 2 2 relations only you can decompose it into R 1 R 2 R 3 multiple relations right suppose error hi all decomposed it in into R 1 and R 2 right now if I ask you one question and we have performed our operations and all but sometimes suppose after sometimes we need to combine these two relations right now the question is if I combine these two relation again in simple terms I am saying combined word or you can say if we join these two relation obviously we are going to perform natural join operation here right so if you can join these are these relations then should you get the same relation are yes or no here means after combining after joining these two relation should this resultant relation be equal to this original one definitely yes it is common sense right or you can say that see this is the relation original one parent one and this only we have decomposed this into two sub relations right and after that once you sometimes later when you will join these two then definitely we will get the same relation right exactly same whatever the value of R whatever the digit data in are exactly same data should be present in this are after joining right if this is a case then it is you can say that lossless join be composition so in simple terms what you can say what does this property say that a decomposition of a relation R is said to be lossless if it is feasible to reconstruct the relation R from decomposed sub relations using joints then you can say that that decomposition is lossless I am going to write down the summary of this lecture at last in form of three or four points right and you will also discuss with the help of one or two examples that the decomposition is lossless or not how to find out that the decomposition is lossless join decomposition or not right now suppose I have decomposed in this relation into PO sub relation R 1 and R 2 now you have to check is this decomposition lossless join the composition or not now obviously for that you have to join these two relation you have to combine these two relation right so you must know what is join operation how to perform natural join on relations so let me give you a quick introduction of natural join operation with the help of an example say I am taking a simple example suppose I have these two sub relation r1 and r2 right the data is this one small relation I am taking now what is the result of Cartesian product first of all I am going to tell you Cartesian product because natural join is improved version of Cartesian product then only you can get it better that what is natural join so how to do Cartesian product of carbon in our two simple as what obviously we will do what in our one I have I'm having a B in R why I am having BC so in Cartesian product of r1 and r2 this would be the resultant table right now Cartesian product is what see the first row of this r1 would be combined with each row of r2 right means here we have 1 1 then it will be combined with first row then again we have 1 1 then it will be combined combined with 1 2 then again 1 1 it will be combined with these 3 2 1 right second is again the second will be combined with each row same third row will be combined with each row this is what Cartesian product right so the answer is so this is the Cartesian product of these two means each row of one relation will be combined with each row of other relation right so the resultant here we have what nine rows 3 into 3 right now what is natural join this is improved version of this Cartesian product right now in natural join of these records you will consider only those records in which in which see here the common attribute is B right so we will consider only those records in which are one dot B how one is the name of this relation is equal to R 2 dot B B is what that common attribute in these two so if you have common attribute in the relation then only you can apply natural join I'll also discuss if no common attribute is there then what will be the result of natural journey first of all so now see here this bees of our one this bees of our two right so now our one dot B are two dot B both are same so we will consider this record and see I'm taking like this 1 1 1 1 here also 1 1 will consider this also in this R 1 dot B is 1 R to go to bees to will not consider this one because this condition is not satisfied so this would not be included in natural join this double here 1 1 so definitely you would consider this one here also 1 1 so we will consider this one also everyone to will not consider this 1 2 and we will not consider this 1 2 and not equals will not consider this 1 2 2 it is equal so will consider this one so now the result of natural join would be this one only now see here B and B both how to click it right so no need to write it write down again B you just write down single B so there is a return table how you will write like this the natural join of these two would be this one only 5 records would be there in Cartesian product 9 records would be there now if no common attribute is there suppose here I am having R 1 is a B and R 2 is C B so I'm asking you are one natural join are to what would be the result because there is no common attribute so we cannot apply this condition so the result would be same you just do Cartesian product and that would be the result of natural join as well because there is no common attribute in that case the result of Cartesian product would be same as the result of natural job like if there is no common attribute and if you want to join suppose R 1 R 2 R 3 R 4 multiple table tables are there sub relations are then you want to join these all these so at same time we cannot join all the 4 because the join this one is what binary operation so at first just take two either you can see R 1 R 2 suppose I am taking only 3 or you can take R 2 R 3 or you can take R 1 three suppose I am taking these two so r1 and r2 after joining become suppose r1 are going to after that you can join it with r3 like this you can perform your own operation all the type of these all the variants we will discuss one by one later in all the examples right so I hope you got how to perform natural join right now check this decomposition is lossless join decomposition or not I have decomposed this into r1 and r2 so R 1 is having will these require r2 is having these records right now perform r1 natural join our two if after joining these two you get the same table as are exactly same records only four tuples exactly same tuples then you can say that it is lossless in Joran otherwise not right now see what you will get so here the common attribute is B so just apply this condition right so here we are not going to combine this row with each row of the r2 we will combine this with the row far too in which this B value is same as of r1 see here B value is 1 so can you combine this with this first one yes because here also B value is 1 so though 1 record would would be I am NOT going to run it right down b2 times because that would be duplicate only one time you we're going to write 1 1 and 1 can you combine this with this yes because here also be 1 here also be 1 right so 1 1 2 can you combine this row with this third one no because here B value is 1 here is 2 can you combine with this one no okay now the next one can you combine this with the first one yes this with second one yes because 1 + 1 B value sing so to motor purrs now can you combine this with this no can you combine this with this no now this 1 3 2 now come can you combine this one with this row know the value is 1 here B value is 2 not same so we can combine this with only this record so 3 2 1 and we can combine this one this this only so four three two I hope you got that we will get this result only right now see in the original one I have one one one yes we got this one one two one yes we got this one three two one yes you got this one and four three yes you or this one right but these two records are extra records now please don't say that this is lossless why because we got everything whatever is there in our we got everything and even we got something extra so it is not loss see it is we have gained something right no the extra is very dangerous when you are dealing with the composition right we are not going to accept any extra record yeah extra is good in real life because I don't you'll be happy if someone will give you something extra but in this case it is very dangerous so this is not lossless you must get exactly same relation as the original one no less records no extra records right so this property ensures that you will get exactly the same relation as the original one right right after joining the decomposed relations no extra topple no less step right and maybe suppose I am taking this the composition r1 and r2 here I'm having a B here I'm having only B although this decomposition is logically not possible but suppose you have given something like this and you are asked that tell me it is lossless or not definitely by looking at this only you can see it is lossless why so because here I have I'm having C but here I'm not having any attribute C right so C the one first property is what the union of attributes of the decomposed relations must be equal to that reviewed of the original relation right if suppose I am having to have decomposed a relation into r1 and r2 so you can say that attribute of r1 Union r2 of our two must be equal to attribute oh ah definitely right so if we have BC then it's fine ABC Union is ABC and attribute of RS also ABC right second property you can say suppose there is no common attribute then I have already discussed the result of the natural join would be same as the result of Cartesian product right and in Cartesian product we are obviously we are getting extra apples I have already discussed here right so in that case also it is lossy it is not lossless so there must be common attributes between the decomposed relations right suppose I have decomposed into two sub relations so you can say attribute of r1 intersection attribute of R 2 intersection should not be fine it means there must be some common attribute at least one common attribute if you do intersection of a B & B C you will get what B and that is not fine if you will get intersection of like this CD suppose I am having one more attribute C sorry B a B and C D is r1 and r2 having any common attribute no right so definitely by looking at this only you can say it is lossy it is not lossless no need to check that do the natural join and all because definitely after natural join you will get something extra in in the resultant table but here see this property satisfied this property is also satisfied in this case but still it is not lossless so there is one more third property also that is very important C Union is ABC find common attribute is they are fine but still it is lossless why so because here see this B is having duplicate values right because of this because of this one this is having duplicate value so it will be combined with one in two rows it is also having duplicate it will be combined with two rows here it's fine it will be combined only this row and this row so one important property is what the common attribute must be a super key or you can say candidate Li if the common attribute is super key of either r1 or r2 or you can say if the common attribute is super key of at least one sub relation then definitely that would be lossless join be composition right I am having two sub relation so common attribute is B if B is super key or at least one subrogation either r1 or r2 or maybe both if being super Q of R 1 then also it would be lost less if being super clear car 2 then also it would be lost as if we super key of r1 and r2 both then also it would be lossless right so let us take this type of example now let us take this decomposition r1 is having a B and r2 is having a C right first of all see the union of these one attribute of these 1 ABC union of attribute of these subrogation is ABC is equal to U is equal to the attribute of okay do you have any common attribute yes I have common attribute right now check this is lossless or not now first of all check using natural join I'm going to do natural join are ones natural join are two so the common attribute is a so we are going to join based on this a see see the first row can you combine this row with this first one check the value of a here also and here also nearest definitely I can combine with this a right so the answer is 1 1 1 1 2 per second can you combine this with this here value of a is 2 here value of phase 1 no value is not same can you combine this with us no with this no ok second one can you combine this with this no when you combine this with this record yes so the next Apple is 2 1 2 right can you combine this couple of this one with this one no because value phase not saying value phase not so you're not saying this you can combine only with this and I guess now we are going to this you can combine only with this so next record is 3 2 1 4 3 2 this is the resultant natural join table now you can see it is exactly same as the original one so this is what lossless this decomposition is lossless but this was not lossless right see now here you can say is what you can see directly you can see here is what super cool you can see candidate right using a candidate key of either relation I am NOT saying that the common attribute is candidate key for the original relation no just forget it right just check the common attribute is super key or candidate key of either of either this relation or this relation it should be candidate key for at least one sub relation now how to check that is candidate key first of all check is candidate key for r1 or not see if a is candidate key of any relation then definitely using that we can derive all that the beauty of that relation now can we drive be using a here because I am having only two attributed definitely using a I can drive a that is for sure trivial functional dependency here you have to check can you drive this one is this functional dependency possible in this relation have to check that already we have discussed one of the previous video you can check out that video in the side button yes this dependency exists here in this r1 so here you can see a is candidate for this relation so no need to check for this one fortunately is candidate key for this whole so you can check it right here in this case a is candidate key for both the relation but if a is candidate key for the first one so no need to check for second one that will be lossless join decomposition right so here in short you can say that three property must be satisfied to be lossless join decomposition first offirst to I have already discussed let me write down again so here you can say if a relation R is decomposed into two sub relation R 1 and R 2 then this decomposition is lossless if these properties are satisfied attribute of R 1 union attribute of R 2 equal to a degree 2 5 right intersection of attributes of the sub relation should not be Phi right third property is what if I have told you if the common attribute is super pure candidate key for either this relation of this relation so how we are going to write down in two technical terms right so you can say common attribute is what obviously intersection of this one and this one so attribute of R 1 intersection a tribute o fire to right must drive must derive all the attributes of either this relation or this relation so all the attributes of either R one attribute Arbonne or intersection can derive all the attributes of this all to see this is or either this or this if one of this these properties is satisfied C 1 is this one one is this one and at least one of these two property then you can say that the decomposition is lossless now suppose the data is not given only relation is given and functional dependencies are given in that case how to find out that that thus this decomposition is lossless join decomposition or not so that we'll discuss in next video in this video see I have discussed in detailed manner just to clear out your basics that what does this lossless joined decomposition write in next video we'll discuss few more example of this type and simple trick how quickly you can find out that if in gate exam or net exam this type of question is given dependencies or you can say that this type of data is given and you can say this decomposition is given then how quickly you can identify that this is lossless or not right so that thing we'll discuss in next video so now I will see in the next video to the nobody care
