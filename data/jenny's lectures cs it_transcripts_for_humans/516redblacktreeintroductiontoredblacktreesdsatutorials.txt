With timestamps:

00:00 - the topic is red black please in this
00:02 - video we will see what is need of red
00:04 - black tree how red black trees are
00:06 - different from AVL trees what is red
00:09 - black trees some properties of red black
00:11 - trees as well as I will give you some
00:13 - examples and we will see all those red
00:16 - black trees or not right now see first
00:20 - of all we will see what is the need of
00:22 - Fred black we see we have already
00:23 - discussed many types of trees BST binary
00:26 - tree avian tree B 3 B plus tree he pre
00:29 - as well right so what is the need of red
00:33 - black Pring we have already many types
00:35 - of trees fine see first of all tree is
00:38 - what it is a data structure you can say
00:40 - data structure means it's a way of
00:42 - organizing the data or you can say a way
00:45 - of organizing the data efficiently in
00:47 - such a way that we can access the data
00:50 - in less time we can insert something we
00:52 - can delete something in a less time
00:54 - obviously we want that if we are going
00:56 - to store data somewhere then we want
00:59 - that we can search something from that
01:01 - data in a very less time we can insert
01:04 - we can update that data or we can delete
01:08 - something from that data in a less time
01:09 - that is obviously we want right so if
01:12 - you are dealing with a large data and it
01:16 - if it comes on how to store that data
01:18 - then we need something we need some data
01:21 - structures many data structures we have
01:22 - discussed array linked lists stacks
01:24 - queues now trees right so every data
01:29 - structure is having its own advantages
01:31 - and drawbacks somewhere we are using
01:32 - array data structure somewhere we are
01:34 - using linked list data structure means
01:35 - it's better to use linked list and
01:37 - somewhere it is better to use arrays
01:39 - somewhere it is better to use trees it
01:41 - depends on many types of factors like
01:43 - one factor is one you can say that
01:46 - frequent operations
01:47 - what type of frequent operations you are
01:49 - going to perform on that data right see
01:53 - in pre data structures it is red black
01:57 - tree is basically a binary search tree
01:59 - so the prerequisite of this video is
02:01 - water you should know what is a binary
02:03 - search tree right so you can check out
02:06 - the video in this I button fine now what
02:10 - is a binary search
02:11 - Tracy in the in that case always the
02:15 - left sub-tree of an old would contain
02:19 - the value less than that node and the
02:23 - right subtree of the node contains value
02:25 - greater than that node see if you say
02:29 - that see somewhere it is written that
02:31 - that left child of a node is having
02:34 - value less than that owed and right
02:35 - child is having value greater than that
02:37 - node if you followed that property in
02:39 - that case suppose Here I am drawing that
02:42 - BST this is a node it means left child
02:45 - look this should be less than ten
02:46 - suppose I am taking seven right child
02:49 - should be greater than ten suppose I am
02:50 - taking 15 now this property is applied
02:53 - in all the nodes on all the nodes now
02:55 - for seven left-side child should be less
02:58 - than seven suppose I am taking three
03:00 - right child of seven should be greater
03:04 - than seven now I am taking here eleven
03:08 - but is this a BST no it is not a BST you
03:13 - should say that the left subtree because
03:17 - he's 11 is greater than seven but 11 is
03:20 - greater than ten also but to the left of
03:24 - n the value should be less than ten it
03:27 - means this is the left subtree for this
03:30 - ten this would be the right subtree for
03:32 - the strength right so in this left
03:35 - subtree slot left subtree of any node
03:37 - should contain values less than that
03:39 - node and right subtree should contain
03:41 - values greater than that node so it's
03:43 - better to say that rather than left
03:46 - child and right child it is better to
03:48 - say left subtree and right subtree fine
03:50 - now see I'm taking these both are binary
03:55 - search trees now as we know that in
03:58 - binary search tree the searching or you
04:00 - can say insertion and deletion is going
04:02 - to take order of log n time in average
04:06 - case low to base two and an in average
04:10 - case in best case it is order of one in
04:13 - worst case it is order of n right in
04:17 - average case it is order of log n right
04:20 - so you can say the searching of
04:23 - any data in binary search tree is going
04:25 - to take less time that is why I
04:27 - obviously we are using three data
04:28 - structures right ha see suppose I am
04:32 - taking this is one BST this is another
04:34 - BS you to type so BST we have now see if
04:38 - and I want to search for a number 19 in
04:42 - both the trees in this case 90 means we
04:47 - will compare with the root 90 is greater
04:50 - than this root greater than 10 so we
04:52 - will go to this path in this root means
04:56 - we are not going to check all these
04:58 - elements right again 15 90 is greater
05:03 - than 15 so we will go to this root we
05:05 - are not going to compare this with this
05:07 - 13 that is why here we need not to
05:10 - compare this element with all the data
05:13 - present in the BST that is why the
05:15 - searching is going to take less time or
05:18 - you can say it is going to take order of
05:20 - H time the time complexity would be
05:23 - according to the height of the BST
05:25 - and basically it is what height is log n
05:30 - base is 2 so that is why time complexity
05:32 - would be order of log n 2 right this is
05:36 - the average case you can say fine now
05:40 - in this case suppose I am searching for
05:43 - 19 that is greater than 10 we will go to
05:47 - here greater than 15 there there than
05:49 - there there there anything after that it
05:51 - will give you that the ninth is not
05:54 - present in that way but here
05:56 - the time complexity would be you have
05:58 - compared this element with all the
06:01 - elements present in the BST
06:02 - so it is equal to order of n so this is
06:06 - the worst case right and we want that
06:11 - the time taken or the time complexity
06:14 - would be as less as possible so that is
06:17 - why rather than this this is what a
06:20 - right skewed BST we want that the tree
06:24 - the BST or the tree should be balanced
06:27 - see this is what a balanced BST you can
06:30 - see so whenever we will insert the data
06:33 - we all we always want
06:36 - that the tree would be balanced so that
06:39 - all the operations like insertion
06:41 - deletion deletion searching find minimum
06:44 - and maximum all these operations should
06:47 - take all these operations will take time
06:50 - complexity order of log n only that is
06:53 - very less than order of n fine now okay
06:59 - we will need water balanced tree now and
07:03 - red black tree is also a self-balancing
07:05 - binary search tree but now you can say
07:08 - that also we have a tree that is a BL
07:12 - this is also a self balanced but you can
07:17 - say a height balanced tree then why we
07:19 - need red black tree right because in a
07:22 - real real so it also guarantees that the
07:25 - time complexity would be order of log n
07:29 - right in all the cases in worst case in
07:33 - best case in average case in BST in
07:36 - worst case it is order of n because the
07:39 - BST can be left skewed or right skewed
07:41 - something like this or it may be between
07:43 - this this this and this suppose
07:45 - something like this here we have this
07:51 - tree so this is also a BST here you can
07:55 - write down the numbers according to the
07:57 - BST that follow that rule only this is
07:59 - between this and this this is not a left
08:02 - or right skewed and this is not a
08:03 - balanced tree right but we want that the
08:06 - tree should be balanced so that the time
08:08 - complexity would be less order of log n
08:11 - but AVL tree guarantees that the time
08:13 - complexity would be log n only because
08:16 - this is what height height balanced tree
08:18 - so why we are using red black trees how
08:21 - red black trees are different from AVL
08:23 - trees see now main difference is what in
08:27 - AVL tree you need to do many rotations
08:30 - sometimes if tree is very large so maybe
08:34 - you require more than 2 3 4 5 6 or many
08:38 - rotations to balance that tree suppose
08:42 - at this point of times tree is something
08:45 - like this
08:49 - here this is a tree having multiple
08:51 - nodes this is some there is some node we
08:55 - have and in this case we need to do some
08:57 - rotations so after rotating this after
08:59 - doing this balance suppose this trees
09:01 - the upper trees what unbalanced so you
09:05 - need to do rotations at this part after
09:07 - balancing this part suppose there is the
09:10 - trees unbalanced at this part at upper
09:12 - level so you need to balance here also
09:15 - right so I don't know how many rotations
09:18 - would be required maybe we require the
09:19 - rotation up to the root node right but
09:22 - in red black trees maximum two rotations
09:27 - would be required and the tree would be
09:28 - balanced right and sometimes even the
09:32 - rotary rotations would not be required
09:33 - and recoloring would be required
09:35 - recoloring means as the name suggests
09:38 - the nodes would be either red or black
09:41 - so you need to change the color only if
09:44 - the node is red just changes to change
09:47 - it to black something like this we will
09:49 - discuss these rules in the next video
09:51 - when we are going to discuss the
09:53 - insertion part right so sometimes only
09:56 - recoloring would be sufficient no
09:57 - rotation would be required and if
09:59 - rotations are required then only you
10:02 - know you can say maximum maximum two
10:04 - rotations would be required rotations
10:06 - plus recoloring may be required but not
10:09 - more than two rotations so very less
10:13 - rotations would be required in a red
10:15 - black raised to balance that tree but
10:18 - see red black trees you can say roughly
10:21 - height balanced and AVL trees strictly
10:24 - height balanced tree so you can see AVL
10:28 - tree is more balanced than red black
10:31 - trees but red black trees guarantees you
10:35 - to give the time complexity order of log
10:38 - n for although you can see searching
10:40 - insertion deletion these kind of
10:42 - operations and that that's exactly we
10:44 - want the time complexity would be this
10:46 - one right so we can go for red black
10:49 - trees in the case when you are you are
10:52 - going to perform insertion and deletion
10:54 - operation very frequently see searching
10:58 - is faster in AVL tree because it is
11:01 - strictly height balanced tree but
11:03 - insertion and deletion is faster in
11:06 - red-black trees because here we require
11:08 - few rotations and in AVL trees we
11:12 - require many rotations right so depends
11:16 - on the situation depends on the
11:17 - operations you want to perform on the
11:20 - tree we are going to choose the trees
11:22 - it's not like that red black trees are
11:24 - best and these are not good right it
11:27 - depends on the situation
11:28 - fine in a separate video I will discuss
11:32 - the difference between AVL tree and red
11:34 - black trees properly right now I guess
11:36 - you have got that why we need red black
11:39 - trees fine now we will discuss how red
11:43 - black trees are different from AVL trees
11:45 - right now we will discuss what is red
11:48 - black trees and properties of red black
11:50 - trees so these are some properties of
11:52 - red black trees see it is a
11:54 - self-balancing binary search tree we
11:57 - have discussed what is binary search
11:59 - tree and what is self balancing means it
12:01 - is going to balance itself by doing some
12:04 - rotations or recoloring that thing we
12:06 - will discuss in the next video the rule
12:08 - of rotation and recoloring that thing I
12:11 - will discuss in the next video and we
12:12 - will do the insertion in the red black
12:14 - trees right now next is obviously it is
12:18 - a red black tree so every node is either
12:21 - red or black right it means every node
12:24 - is having a special bit which shows the
12:29 - color of the node right a one bit you
12:32 - can say zero means black and one means
12:37 - red only one extra bit would be required
12:40 - with each node and other than this bit
12:44 - each node is containing what obviously
12:46 - the node is same as binary tree we have
12:48 - discussed the key or you can say the
12:50 - data left pointer right pointer right
12:52 - plus this also one bit for storing the
12:56 - color of the node that is also mandatory
12:59 - right how to write down the node that
13:01 - structure of the node that you will
13:03 - discuss in the implementation part right
13:05 - now next is what C root is always black
13:09 - or you can say the head node is always
13:12 - black so now in this case
13:14 - see suppose this is a tree this is I'm
13:19 - taking root node obviously we have one
13:21 - not only so that would be the root node
13:22 - so this is always black suppose I am
13:25 - taking here the number 10 right or you
13:28 - can relate it with real-life example
13:30 - obviously in the tree we have something
13:32 - like this then here also we have some so
13:37 - these are what child of the Sten and
13:40 - these are child of this node right
13:42 - suppose array of seven five so for these
13:44 - this is the grandparent or you can say
13:47 - the head of the family and see when a
13:50 - person gets angry then you can say the
13:53 - face of that person becomes red right
13:55 - and we consider here that if a person is
13:58 - calm or cool then the face of that
14:00 - person is black so the head of the
14:03 - family always try to remain calm right
14:05 - but you can say the grandparents you can
14:09 - relate it with that they do yoga and all
14:11 - and that is why they always remain calm
14:13 - they usually don't get angry that is why
14:17 - the root or the head node will always be
14:19 - black not red right now next is what
14:24 - every leaf see this property is very
14:27 - important every leaf which is new is
14:30 - black here in this case if you are not
14:34 - considering red black place this is a
14:36 - binary tree here the leaf node are this
14:39 - this and this these are not having any
14:42 - child node but in red black trees what
14:47 - we consider is see here if this is a
14:51 - node means this is the leaf node it is
14:53 - having no left child no right side so
14:58 - here we consider nil
15:01 - this is nil this is nil and see
15:04 - obviously this this color is what it
15:06 - should be black note red it should be
15:08 - black so every leaf which is new is
15:12 - black so it is also having no left no
15:17 - right so it is nil it is named so we
15:20 - usually draw red black tree something
15:22 - like this see we are not going to
15:24 - consider these nodes as a part of the
15:26 - part of the tree they
15:28 - is what external nodes right generally
15:32 - we don't count these nodes in this tree
15:34 - but these are help helpful we will when
15:37 - we will insert and delete the data from
15:40 - the tree fine so now every leaf node
15:44 - which is nil is black which is nil is
15:46 - black it's not like that this is leaf
15:48 - road and this would be black know here
15:51 - we are not considered these as leaf nor
15:53 - leaf node would be these nodes the nil
15:55 - nodes these are considered as internal
15:58 - nodes of the red black trees right this
16:00 - thing you need to take care so now
16:02 - suppose this is a tree here this root is
16:05 - always black and we have taken these nil
16:08 - nodes every leaf which is nil is black
16:10 - right so see here also this node is also
16:14 - having no left child it means basically
16:17 - we can consider it with the pointer left
16:20 - pointer right pointer those are null
16:22 - pointers so here I am drawing these as a
16:24 - node that is nil nodes right simply you
16:28 - can say so here also the left is nil for
16:30 - 20 both left and right could be nil so
16:33 - these nil would be black right now see
16:37 - next is if Rho node is red then it's
16:39 - children are black it means here you can
16:43 - in another term you can say there should
16:46 - not be no red red parent-child
16:49 - relationship or you can say that no
16:52 - adjacent node can be read something like
16:55 - this see this root is black black right
16:59 - so this and this can be black can be red
17:04 - right because constraint is only on the
17:07 - red nodes not on the black color on the
17:10 - black nodes constraint is this one that
17:13 - thing will discuss right so now suppose
17:16 - this is red and this is red fine but
17:20 - this if I say this is red this is not
17:24 - true because if node is red see this
17:28 - node is red so it's children should be
17:30 - black so this and this cannot be red
17:34 - that is for sure so this should be black
17:37 - and this should also be black
17:40 - right here also you can say if this is
17:45 - red so this cannot be red right because
17:49 - if you draw this as red means these two
17:51 - are adjacent nodes and these two are red
17:55 - that is not possible so this should be
17:57 - black right now if this is black then
18:03 - the six and eight these can be red or
18:07 - black according to this rule but
18:10 - obviously we need to take care of this
18:12 - property also right
18:13 - suppose if I'm taking this is black and
18:16 - this also I am taking black and black
18:19 - now check the next property see every
18:22 - path from a node to any of its
18:25 - descendant nil node has same number of
18:31 - black nodes right any path from any node
18:36 - right suppose I'm taking first of all
18:39 - from the root node from the root node
18:41 - check out the paths one path is this one
18:46 - one path is this one one is we can go to
18:50 - this nail we can go to this nail then
18:52 - this this this this and this means one
18:54 - two three four five six seven eight nine
18:57 - paths can be there from the truth node
19:01 - right so in all these paths from root to
19:07 - the nil or any node you are considering
19:10 - here I am taking with the from the root
19:11 - right so all these paths should contain
19:15 - same number of black nodes now check we
19:20 - will not consider these we will not
19:22 - count these because obviously these are
19:23 - all the black nodes so if you will
19:25 - consider this thing so plus one black
19:27 - node that is fine but we will not
19:29 - consider we will not count these nodes
19:31 - in the path now count from here a roof
19:34 - will be black one and two in this path
19:38 - two black nodes are there in this path
19:42 - all also one and two black nodes are
19:44 - there this is red we are not going to
19:46 - consider this one now in this path till
19:49 - this black see one two three black nodes
19:53 - there and in this pot soul so three to
19:57 - this path also three and here also we
19:59 - have one two three right here we have
20:02 - one one only one and in this path we
20:07 - have 1 2 and 1 and 2 for this path so
20:11 - each path is not having same number of
20:13 - black nodes so this is not a red black
20:16 - tree now to make it as a red black tree
20:19 - what you can say see if I suppose if I
20:24 - make this is red this is red you can
20:28 - make it right because the parent is
20:30 - black if the parent is red then you need
20:33 - to take care that its children should be
20:35 - black but if the parent is black then
20:37 - children can be red or black right but
20:39 - with this you need to take care of other
20:41 - property as well so now in this path c1
20:44 - 2 and here also we have 2 black nodes
20:48 - that is fine but problem is what from
20:51 - here to here to this nil node we have
20:54 - only one black node so this is still not
20:58 - a red black tree now suppose here also
21:02 - rather than this nil I draw here one
21:07 - more node and so see it is a BST so here
21:11 - this should contain value less than 15
21:14 - right but it should be greater than 10
21:17 - you need to take care of this thing also
21:19 - right so suppose I am taking here to N
21:21 - and this is black right so to this also
21:25 - having one nil and right also having nil
21:30 - now check out this path to this nail 1
21:35 - and 2 black to this nail we have 1 and 2
21:37 - black here also we have 2 black and 2
21:39 - black now I guess in every path we have
21:42 - same number of black nodes so now this
21:45 - is a red black tree now the question may
21:48 - be is every AVL tree can be a red black
21:51 - tree see if a tree is AVL tree and you
21:54 - color it red and black according to the
21:57 - rules then it would be a red black tree
22:00 - so you can say AVL trees are subset of
22:03 - red black trees right but
22:06 - if a tree is red black tree then it is
22:09 - not true that that would be a real tree
22:11 - maybe if you remove the coloring so it
22:14 - is not compulsory that that that tree
22:17 - would be AVL tree because these trees
22:19 - are roughly height balanced and AVL
22:21 - trees strictly height balanced tree
22:24 - right now I'm going to give you some
22:27 - examples and we will see are those trees
22:29 - red black trees or not if not which
22:32 - property they are violating fine so let
22:35 - us take these three examples are these
22:37 - red black trees or not first of all this
22:39 - thing check out this thing see here you
22:42 - can say first of all it is a BST or not
22:44 - right so you have to check out that
22:46 - condition first thing you can say that
22:48 - root is what here red but root should be
22:51 - black so this is not a BST no need to
22:54 - check out other conditions right first
22:57 - is violated it means it is not a red
22:59 - black tree next is this one here see I
23:03 - have all the nodes are black right and
23:08 - obviously this is a BST because it is
23:11 - following a BST property right now but
23:14 - this is not a red black tree why so
23:18 - which property this is violating see see
23:21 - first property is what every node is
23:23 - either black or red it is not compulsory
23:25 - that there should be one red or black
23:30 - something like this all may be black
23:32 - because on red only we have the
23:35 - restriction if the node is red then
23:37 - children should be black on the black
23:38 - layer we have don't we don't have any
23:40 - restriction we have this restriction we
23:41 - will check out this thing also now
23:44 - root is black root is black every leaf
23:46 - which is nil is black so obviously I'm
23:48 - not throwing those nil that are black
23:51 - consider that thing right if node is red
23:55 - then it's children are black black but
23:57 - here known a red node is there now this
23:59 - property see every path from any node to
24:04 - its descendant null nodes or nil nodes
24:08 - must contain same number of black nodes
24:11 - now check out this path to its nil nodes
24:15 - one two three black nodes here also one
24:19 - two three fine
24:20 - here we have one two three fine but to
24:23 - this path here also we have one nil
24:27 - right so check out through this new one
24:30 - and two we have only two black this
24:33 - condition is violated so this is not a
24:35 - red black tree but suppose I draw here
24:39 - something like this here I now eleven
24:42 - this is black now this is a red black
24:46 - tree even we don't have any red color in
24:50 - this tree still this is a red black tree
24:53 - because it is following all the
24:55 - properties of red black tree so one
24:58 - thing you can say it is what other than
25:01 - red black tree it is what a perfect
25:03 - binary tree we have already discussed
25:07 - binary tree and its types you can check
25:09 - out that video here what is perfect
25:10 - binary tree each node is having exactly
25:14 - two children and these leaf node should
25:18 - be at the same level so here you can say
25:21 - every perfect binary tree that contains
25:25 - only black nodes is also a red black
25:29 - tree so now this is a red black tree
25:31 - right this is a red black tree now check
25:34 - out this thing is this a binary tree
25:37 - binary search tree sorry see it is if it
25:40 - is following all the properties of this
25:42 - one red black tree if you are not
25:44 - checking this BST property because it is
25:46 - not following the binary search tree
25:48 - property other than that see root is
25:51 - black root is always black every leaf is
25:55 - a snail is black obviously these are
25:57 - black if node is red then it's children
25:59 - are black these are black and it's nil
26:02 - note that are always black you can check
26:05 - out the paths from here to here to black
26:07 - node from here to here to black node
26:08 - from here to here to black node and here
26:11 - also obviously we are having what Nellie
26:13 - I am NOT drawing that thing you need to
26:15 - take care of this thing because always
26:17 - we are going to draw that tree something
26:18 - like this rather then drawing the nail
26:21 - everywhere right so through this path
26:24 - also we have to black so you can say
26:26 - this is a red black tree but you need to
26:28 - check out that this is a BH
26:29 - - you're not this is not a binary search
26:31 - tree see to the left of ten we have
26:34 - eleven that is not possible to the left
26:36 - of N in the left subtree we should have
26:39 - values less than ten so this is not a
26:42 - red black tree right see rather than
26:46 - writing all here nil for every node for
26:51 - every leaf node what you can say one
26:54 - node can be NIM that can be sentinel
26:58 - node and you can connect see the left
27:00 - pointer of this to this the right
27:02 - pointer of this to this left point of
27:04 - this to this nil right pointer to this
27:06 - nil so you need only one sentinel node
27:09 - that also you can implement something
27:11 - like this or rather than this you can
27:12 - consider for each leaf node for each
27:17 - these leaf node one nil node that is
27:20 - also fine right now we will take some
27:22 - other examples now check out for this
27:25 - tree is this red black tree it is a BST
27:29 - yes root is black PS but see this is red
27:33 - this is also red but if our node is red
27:36 - then its children should be black so
27:39 - this is violating this property though
27:41 - this one right if I write here black
27:47 - then then s it is a red black tree right
27:51 - this property is also followed now check
27:53 - out this one check out the path from
27:55 - here to here we have one two two black
27:56 - nodes from here to here also two black
27:58 - nodes from here to here we have also one
28:00 - two two black nodes so every path is
28:02 - having same number of you can say that
28:05 - black nodes say this condition you can
28:08 - check out from any node see suppose I am
28:10 - taking this node from this node check
28:12 - out the path to its descendant nil nodes
28:15 - so here we have this path because here
28:18 - we have two nil nodes here we have two
28:20 - nil nodes so one to this node that is
28:23 - one black node from here to here also
28:26 - one from here to here one from here to
28:27 - here one right so this is also having
28:30 - you know same number of black nodes on
28:33 - each path so this is what a red black
28:35 - tree now see
28:38 - if I draw here one more node and which
28:43 - is what suppose black and this is one
28:47 - now this is not a red black tree because
28:49 - in this path we have one two three black
28:51 - nodes and here we have two so this is
28:53 - violating this condition this last
28:55 - condition suppose I'm changing the color
28:59 - to red now this is a red black tree
29:02 - right so now can you can you extend this
29:08 - further can you here draw one more node
29:13 - see we cannot draw red because to
29:15 - address in red are not possible if you
29:17 - do the coloring black right suppose zero
29:21 - I'm taking so in this node B one two and
29:24 - three three black nodes but here we have
29:26 - only two black node so this is not
29:28 - possible right so now here one more
29:31 - point about red black tree is what we
29:33 - are drawing that point from this
29:34 - property only because this because of
29:36 - this property we cannot add here one
29:38 - more node neither red nor black right so
29:42 - here you can say the longest path from
29:45 - the root is no more than twice the
29:51 - length of the shortest path or you can
29:54 - say see the path from root to its
29:57 - farthest leaf node farthest means to its
30:02 - extreme leaf node right is no more than
30:08 - twice as long as the path from root to
30:12 - its nearest leaf node now see that we
30:16 - nearest leaf node of this root is this
30:19 - one right if you don't consider this
30:22 - then here you can say these are leaf
30:26 - node that is nil and right so nearest
30:32 - are these one these two so the path is
30:35 - two right now the extreme leaf node or
30:43 - the farthest leaf notice this one or you
30:46 - can say here we have nil and these ones
30:51 - it or you can see the extreme and the
30:53 - maximum distance from the root these are
30:55 - the nodes so check out the path here
30:58 - what is the path having for this to this
31:03 - then this to this that is for it means 2
31:05 - into 2 that is for it cannot be more
31:09 - than 4 so you can say it cannot be more
31:13 - than twice then this path right that is
31:17 - one more you can say that point about
31:20 - red black trees I hope you are getting
31:22 - this property see here we can add some
31:25 - node here right so these nodes can be
31:31 - what red these cannot be black because
31:34 - if these nodes are black then 1 2 & 3 in
31:38 - this path 3 black nodes are there and
31:40 - here we have only 2 black notes
31:41 - obviously we are not considering these
31:42 - nil nodes right so here you can say red
31:46 - and red that is possible right but this
31:48 - is also what this path is also having
31:51 - what value 4 here we can say nil nil nil
31:57 - but here further we cannot insert any
32:00 - node either red or black red we cannot
32:02 - insert because it is a red red this
32:04 - condition will be violated we cannot
32:06 - insert black because if you insert black
32:08 - then here 1 2 1 2 & 3 3 node would be
32:13 - there black would be there to this path
32:15 - and here we have only two nodes so that
32:17 - is one more point and that point has
32:19 - been you know driven from this point
32:21 - only the longest path from root to its
32:23 - leaf node cannot be you know more than
32:28 - twice the length of the shortest path so
32:33 - now this is question for you you need to
32:35 - tell me is this red black tree or not if
32:38 - not then which property this tree is
32:42 - violating you can write down your answer
32:45 - in the comment box right so this is now
32:47 - just fine I guess for the introduction
32:50 - part of red black trees in the next
32:52 - video we'll discuss the how to perform
32:54 - insertion in red black trees all right
32:56 - so I'll so in the next video till then
32:58 - bye bye I take it

Cleaned transcript:

the topic is red black please in this video we will see what is need of red black tree how red black trees are different from AVL trees what is red black trees some properties of red black trees as well as I will give you some examples and we will see all those red black trees or not right now see first of all we will see what is the need of Fred black we see we have already discussed many types of trees BST binary tree avian tree B 3 B plus tree he pre as well right so what is the need of red black Pring we have already many types of trees fine see first of all tree is what it is a data structure you can say data structure means it's a way of organizing the data or you can say a way of organizing the data efficiently in such a way that we can access the data in less time we can insert something we can delete something in a less time obviously we want that if we are going to store data somewhere then we want that we can search something from that data in a very less time we can insert we can update that data or we can delete something from that data in a less time that is obviously we want right so if you are dealing with a large data and it if it comes on how to store that data then we need something we need some data structures many data structures we have discussed array linked lists stacks queues now trees right so every data structure is having its own advantages and drawbacks somewhere we are using array data structure somewhere we are using linked list data structure means it's better to use linked list and somewhere it is better to use arrays somewhere it is better to use trees it depends on many types of factors like one factor is one you can say that frequent operations what type of frequent operations you are going to perform on that data right see in pre data structures it is red black tree is basically a binary search tree so the prerequisite of this video is water you should know what is a binary search tree right so you can check out the video in this I button fine now what is a binary search Tracy in the in that case always the left subtree of an old would contain the value less than that node and the right subtree of the node contains value greater than that node see if you say that see somewhere it is written that that left child of a node is having value less than that owed and right child is having value greater than that node if you followed that property in that case suppose Here I am drawing that BST this is a node it means left child look this should be less than ten suppose I am taking seven right child should be greater than ten suppose I am taking 15 now this property is applied in all the nodes on all the nodes now for seven leftside child should be less than seven suppose I am taking three right child of seven should be greater than seven now I am taking here eleven but is this a BST no it is not a BST you should say that the left subtree because he's 11 is greater than seven but 11 is greater than ten also but to the left of n the value should be less than ten it means this is the left subtree for this ten this would be the right subtree for the strength right so in this left subtree slot left subtree of any node should contain values less than that node and right subtree should contain values greater than that node so it's better to say that rather than left child and right child it is better to say left subtree and right subtree fine now see I'm taking these both are binary search trees now as we know that in binary search tree the searching or you can say insertion and deletion is going to take order of log n time in average case low to base two and an in average case in best case it is order of one in worst case it is order of n right in average case it is order of log n right so you can say the searching of any data in binary search tree is going to take less time that is why I obviously we are using three data structures right ha see suppose I am taking this is one BST this is another BS you to type so BST we have now see if and I want to search for a number 19 in both the trees in this case 90 means we will compare with the root 90 is greater than this root greater than 10 so we will go to this path in this root means we are not going to check all these elements right again 15 90 is greater than 15 so we will go to this root we are not going to compare this with this 13 that is why here we need not to compare this element with all the data present in the BST that is why the searching is going to take less time or you can say it is going to take order of H time the time complexity would be according to the height of the BST and basically it is what height is log n base is 2 so that is why time complexity would be order of log n 2 right this is the average case you can say fine now in this case suppose I am searching for 19 that is greater than 10 we will go to here greater than 15 there there than there there there anything after that it will give you that the ninth is not present in that way but here the time complexity would be you have compared this element with all the elements present in the BST so it is equal to order of n so this is the worst case right and we want that the time taken or the time complexity would be as less as possible so that is why rather than this this is what a right skewed BST we want that the tree the BST or the tree should be balanced see this is what a balanced BST you can see so whenever we will insert the data we all we always want that the tree would be balanced so that all the operations like insertion deletion deletion searching find minimum and maximum all these operations should take all these operations will take time complexity order of log n only that is very less than order of n fine now okay we will need water balanced tree now and red black tree is also a selfbalancing binary search tree but now you can say that also we have a tree that is a BL this is also a self balanced but you can say a height balanced tree then why we need red black tree right because in a real real so it also guarantees that the time complexity would be order of log n right in all the cases in worst case in best case in average case in BST in worst case it is order of n because the BST can be left skewed or right skewed something like this or it may be between this this this and this suppose something like this here we have this tree so this is also a BST here you can write down the numbers according to the BST that follow that rule only this is between this and this this is not a left or right skewed and this is not a balanced tree right but we want that the tree should be balanced so that the time complexity would be less order of log n but AVL tree guarantees that the time complexity would be log n only because this is what height height balanced tree so why we are using red black trees how red black trees are different from AVL trees see now main difference is what in AVL tree you need to do many rotations sometimes if tree is very large so maybe you require more than 2 3 4 5 6 or many rotations to balance that tree suppose at this point of times tree is something like this here this is a tree having multiple nodes this is some there is some node we have and in this case we need to do some rotations so after rotating this after doing this balance suppose this trees the upper trees what unbalanced so you need to do rotations at this part after balancing this part suppose there is the trees unbalanced at this part at upper level so you need to balance here also right so I don't know how many rotations would be required maybe we require the rotation up to the root node right but in red black trees maximum two rotations would be required and the tree would be balanced right and sometimes even the rotary rotations would not be required and recoloring would be required recoloring means as the name suggests the nodes would be either red or black so you need to change the color only if the node is red just changes to change it to black something like this we will discuss these rules in the next video when we are going to discuss the insertion part right so sometimes only recoloring would be sufficient no rotation would be required and if rotations are required then only you know you can say maximum maximum two rotations would be required rotations plus recoloring may be required but not more than two rotations so very less rotations would be required in a red black raised to balance that tree but see red black trees you can say roughly height balanced and AVL trees strictly height balanced tree so you can see AVL tree is more balanced than red black trees but red black trees guarantees you to give the time complexity order of log n for although you can see searching insertion deletion these kind of operations and that that's exactly we want the time complexity would be this one right so we can go for red black trees in the case when you are you are going to perform insertion and deletion operation very frequently see searching is faster in AVL tree because it is strictly height balanced tree but insertion and deletion is faster in redblack trees because here we require few rotations and in AVL trees we require many rotations right so depends on the situation depends on the operations you want to perform on the tree we are going to choose the trees it's not like that red black trees are best and these are not good right it depends on the situation fine in a separate video I will discuss the difference between AVL tree and red black trees properly right now I guess you have got that why we need red black trees fine now we will discuss how red black trees are different from AVL trees right now we will discuss what is red black trees and properties of red black trees so these are some properties of red black trees see it is a selfbalancing binary search tree we have discussed what is binary search tree and what is self balancing means it is going to balance itself by doing some rotations or recoloring that thing we will discuss in the next video the rule of rotation and recoloring that thing I will discuss in the next video and we will do the insertion in the red black trees right now next is obviously it is a red black tree so every node is either red or black right it means every node is having a special bit which shows the color of the node right a one bit you can say zero means black and one means red only one extra bit would be required with each node and other than this bit each node is containing what obviously the node is same as binary tree we have discussed the key or you can say the data left pointer right pointer right plus this also one bit for storing the color of the node that is also mandatory right how to write down the node that structure of the node that you will discuss in the implementation part right now next is what C root is always black or you can say the head node is always black so now in this case see suppose this is a tree this is I'm taking root node obviously we have one not only so that would be the root node so this is always black suppose I am taking here the number 10 right or you can relate it with reallife example obviously in the tree we have something like this then here also we have some so these are what child of the Sten and these are child of this node right suppose array of seven five so for these this is the grandparent or you can say the head of the family and see when a person gets angry then you can say the face of that person becomes red right and we consider here that if a person is calm or cool then the face of that person is black so the head of the family always try to remain calm right but you can say the grandparents you can relate it with that they do yoga and all and that is why they always remain calm they usually don't get angry that is why the root or the head node will always be black not red right now next is what every leaf see this property is very important every leaf which is new is black here in this case if you are not considering red black place this is a binary tree here the leaf node are this this and this these are not having any child node but in red black trees what we consider is see here if this is a node means this is the leaf node it is having no left child no right side so here we consider nil this is nil this is nil and see obviously this this color is what it should be black note red it should be black so every leaf which is new is black so it is also having no left no right so it is nil it is named so we usually draw red black tree something like this see we are not going to consider these nodes as a part of the part of the tree they is what external nodes right generally we don't count these nodes in this tree but these are help helpful we will when we will insert and delete the data from the tree fine so now every leaf node which is nil is black which is nil is black it's not like that this is leaf road and this would be black know here we are not considered these as leaf nor leaf node would be these nodes the nil nodes these are considered as internal nodes of the red black trees right this thing you need to take care so now suppose this is a tree here this root is always black and we have taken these nil nodes every leaf which is nil is black right so see here also this node is also having no left child it means basically we can consider it with the pointer left pointer right pointer those are null pointers so here I am drawing these as a node that is nil nodes right simply you can say so here also the left is nil for 20 both left and right could be nil so these nil would be black right now see next is if Rho node is red then it's children are black it means here you can in another term you can say there should not be no red red parentchild relationship or you can say that no adjacent node can be read something like this see this root is black black right so this and this can be black can be red right because constraint is only on the red nodes not on the black color on the black nodes constraint is this one that thing will discuss right so now suppose this is red and this is red fine but this if I say this is red this is not true because if node is red see this node is red so it's children should be black so this and this cannot be red that is for sure so this should be black and this should also be black right here also you can say if this is red so this cannot be red right because if you draw this as red means these two are adjacent nodes and these two are red that is not possible so this should be black right now if this is black then the six and eight these can be red or black according to this rule but obviously we need to take care of this property also right suppose if I'm taking this is black and this also I am taking black and black now check the next property see every path from a node to any of its descendant nil node has same number of black nodes right any path from any node right suppose I'm taking first of all from the root node from the root node check out the paths one path is this one one path is this one one is we can go to this nail we can go to this nail then this this this this and this means one two three four five six seven eight nine paths can be there from the truth node right so in all these paths from root to the nil or any node you are considering here I am taking with the from the root right so all these paths should contain same number of black nodes now check we will not consider these we will not count these because obviously these are all the black nodes so if you will consider this thing so plus one black node that is fine but we will not consider we will not count these nodes in the path now count from here a roof will be black one and two in this path two black nodes are there in this path all also one and two black nodes are there this is red we are not going to consider this one now in this path till this black see one two three black nodes there and in this pot soul so three to this path also three and here also we have one two three right here we have one one only one and in this path we have 1 2 and 1 and 2 for this path so each path is not having same number of black nodes so this is not a red black tree now to make it as a red black tree what you can say see if I suppose if I make this is red this is red you can make it right because the parent is black if the parent is red then you need to take care that its children should be black but if the parent is black then children can be red or black right but with this you need to take care of other property as well so now in this path c1 2 and here also we have 2 black nodes that is fine but problem is what from here to here to this nil node we have only one black node so this is still not a red black tree now suppose here also rather than this nil I draw here one more node and so see it is a BST so here this should contain value less than 15 right but it should be greater than 10 you need to take care of this thing also right so suppose I am taking here to N and this is black right so to this also having one nil and right also having nil now check out this path to this nail 1 and 2 black to this nail we have 1 and 2 black here also we have 2 black and 2 black now I guess in every path we have same number of black nodes so now this is a red black tree now the question may be is every AVL tree can be a red black tree see if a tree is AVL tree and you color it red and black according to the rules then it would be a red black tree so you can say AVL trees are subset of red black trees right but if a tree is red black tree then it is not true that that would be a real tree maybe if you remove the coloring so it is not compulsory that that that tree would be AVL tree because these trees are roughly height balanced and AVL trees strictly height balanced tree right now I'm going to give you some examples and we will see are those trees red black trees or not if not which property they are violating fine so let us take these three examples are these red black trees or not first of all this thing check out this thing see here you can say first of all it is a BST or not right so you have to check out that condition first thing you can say that root is what here red but root should be black so this is not a BST no need to check out other conditions right first is violated it means it is not a red black tree next is this one here see I have all the nodes are black right and obviously this is a BST because it is following a BST property right now but this is not a red black tree why so which property this is violating see see first property is what every node is either black or red it is not compulsory that there should be one red or black something like this all may be black because on red only we have the restriction if the node is red then children should be black on the black layer we have don't we don't have any restriction we have this restriction we will check out this thing also now root is black root is black every leaf which is nil is black so obviously I'm not throwing those nil that are black consider that thing right if node is red then it's children are black black but here known a red node is there now this property see every path from any node to its descendant null nodes or nil nodes must contain same number of black nodes now check out this path to its nil nodes one two three black nodes here also one two three fine here we have one two three fine but to this path here also we have one nil right so check out through this new one and two we have only two black this condition is violated so this is not a red black tree but suppose I draw here something like this here I now eleven this is black now this is a red black tree even we don't have any red color in this tree still this is a red black tree because it is following all the properties of red black tree so one thing you can say it is what other than red black tree it is what a perfect binary tree we have already discussed binary tree and its types you can check out that video here what is perfect binary tree each node is having exactly two children and these leaf node should be at the same level so here you can say every perfect binary tree that contains only black nodes is also a red black tree so now this is a red black tree right this is a red black tree now check out this thing is this a binary tree binary search tree sorry see it is if it is following all the properties of this one red black tree if you are not checking this BST property because it is not following the binary search tree property other than that see root is black root is always black every leaf is a snail is black obviously these are black if node is red then it's children are black these are black and it's nil note that are always black you can check out the paths from here to here to black node from here to here to black node from here to here to black node and here also obviously we are having what Nellie I am NOT drawing that thing you need to take care of this thing because always we are going to draw that tree something like this rather then drawing the nail everywhere right so through this path also we have to black so you can say this is a red black tree but you need to check out that this is a BH you're not this is not a binary search tree see to the left of ten we have eleven that is not possible to the left of N in the left subtree we should have values less than ten so this is not a red black tree right see rather than writing all here nil for every node for every leaf node what you can say one node can be NIM that can be sentinel node and you can connect see the left pointer of this to this the right pointer of this to this left point of this to this nil right pointer to this nil so you need only one sentinel node that also you can implement something like this or rather than this you can consider for each leaf node for each these leaf node one nil node that is also fine right now we will take some other examples now check out for this tree is this red black tree it is a BST yes root is black PS but see this is red this is also red but if our node is red then its children should be black so this is violating this property though this one right if I write here black then then s it is a red black tree right this property is also followed now check out this one check out the path from here to here we have one two two black nodes from here to here also two black nodes from here to here we have also one two two black nodes so every path is having same number of you can say that black nodes say this condition you can check out from any node see suppose I am taking this node from this node check out the path to its descendant nil nodes so here we have this path because here we have two nil nodes here we have two nil nodes so one to this node that is one black node from here to here also one from here to here one from here to here one right so this is also having you know same number of black nodes on each path so this is what a red black tree now see if I draw here one more node and which is what suppose black and this is one now this is not a red black tree because in this path we have one two three black nodes and here we have two so this is violating this condition this last condition suppose I'm changing the color to red now this is a red black tree right so now can you can you extend this further can you here draw one more node see we cannot draw red because to address in red are not possible if you do the coloring black right suppose zero I'm taking so in this node B one two and three three black nodes but here we have only two black node so this is not possible right so now here one more point about red black tree is what we are drawing that point from this property only because this because of this property we cannot add here one more node neither red nor black right so here you can say the longest path from the root is no more than twice the length of the shortest path or you can say see the path from root to its farthest leaf node farthest means to its extreme leaf node right is no more than twice as long as the path from root to its nearest leaf node now see that we nearest leaf node of this root is this one right if you don't consider this then here you can say these are leaf node that is nil and right so nearest are these one these two so the path is two right now the extreme leaf node or the farthest leaf notice this one or you can say here we have nil and these ones it or you can see the extreme and the maximum distance from the root these are the nodes so check out the path here what is the path having for this to this then this to this that is for it means 2 into 2 that is for it cannot be more than 4 so you can say it cannot be more than twice then this path right that is one more you can say that point about red black trees I hope you are getting this property see here we can add some node here right so these nodes can be what red these cannot be black because if these nodes are black then 1 2 & 3 in this path 3 black nodes are there and here we have only 2 black notes obviously we are not considering these nil nodes right so here you can say red and red that is possible right but this is also what this path is also having what value 4 here we can say nil nil nil but here further we cannot insert any node either red or black red we cannot insert because it is a red red this condition will be violated we cannot insert black because if you insert black then here 1 2 1 2 & 3 3 node would be there black would be there to this path and here we have only two nodes so that is one more point and that point has been you know driven from this point only the longest path from root to its leaf node cannot be you know more than twice the length of the shortest path so now this is question for you you need to tell me is this red black tree or not if not then which property this tree is violating you can write down your answer in the comment box right so this is now just fine I guess for the introduction part of red black trees in the next video we'll discuss the how to perform insertion in red black trees all right so I'll so in the next video till then bye bye I take it
