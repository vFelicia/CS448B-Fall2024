With timestamps:

00:00 - the topic is stack implementation using
00:03 - linked lists right so the prerequisite
00:05 - of this video is you should know about
00:08 - stack and link lists right we have
00:10 - already discussed what is stack and how
00:13 - to implement stack using arrays or what
00:15 - are the different operations on stack
00:17 - right in the previous videos as well as
00:19 - we have discussed the topic linked list
00:22 - all the type of linked list as well as
00:24 - how to perform insertion deletion
00:25 - traverser all the operations on linked
00:28 - list for those with videos you can check
00:30 - out the description box right so I
00:32 - assume that you know the what is stack
00:35 - and what is linked list right now we are
00:38 - going to implement stack using linked
00:40 - list see we will implement stack using
00:43 - linked list right so you have to follow
00:47 - the rule of the stack and what is that
00:50 - rule that is leaf or principle stack
00:52 - always follow what leaf or principle
00:55 - last in first out right that thing we
00:58 - have discussed in the previous video
01:00 - right for that video you can check out
01:02 - the side button so stack is what it is
01:04 - an ordered list or you can say it is a
01:06 - collection where the insertion and
01:09 - deletion always perform from one end
01:12 - only and how we are going to represent
01:14 - the stack the logical represent is
01:16 - something like this it is a container
01:18 - which is having one open end right this
01:21 - insertion is also from this end and
01:24 - deletion would also perform from this
01:25 - end and this end is known as top so the
01:29 - push and pop operations will be
01:32 - performed always from the top of the
01:34 - stack and what is a linked list see when
01:36 - I am saying a linked list it means we
01:38 - are discussing about singly linked list
01:40 - by default right so this is what a
01:41 - singly linked list this is a node in the
01:45 - linked list two parts are there one is
01:46 - data part one is address part this
01:48 - address part or link part is containing
01:50 - address of the next node right that is
01:52 - four hundred here hundred the last node
01:54 - is containing null because this is not
01:56 - pointing to any node and head pointer
01:59 - head is containing address of the first
02:00 - node so when you are going to program
02:02 - the linked list then what we have the
02:04 - information we have is what head pointer
02:07 - only the head pointer right
02:09 - not head in order this is head pointer
02:11 - this is what you can say head node the
02:14 - first right we have only the header
02:16 - pointer that is address of the first
02:18 - node fine this is what a link lists now
02:21 - you have to implement tag using link
02:24 - list so here we will store the Atty in
02:26 - the form of nodes as well as we have to
02:28 - follow the rules that is only for
02:30 - principle and we have discussed the push
02:32 - and pop operation the two fundamental
02:36 - operations push and pop is going to take
02:38 - order of one time complexity is order of
02:41 - one only in the form of stack so you
02:43 - have to take care of this thing also so
02:45 - now we can perform insertion and
02:47 - deletion from the one end all right so
02:51 - in linked list suppose I am taking
02:52 - linked list so that end can be the stale
02:56 - or the head you can insert and delete
02:59 - both from the tail and only also as well
03:03 - as from the head also from the starting
03:06 - also right so two options you have so if
03:09 - you insert and believe the data from the
03:12 - tail here from the end of the linked
03:15 - list then see the time complexity would
03:17 - be suppose this is the list and we will
03:19 - we want to insert another node in the
03:22 - list so here you are going to insert
03:24 - suppose I am taking that approach that
03:26 - from and only I can insert and here only
03:29 - I can delete right so now you can
03:33 - directly insert the data here why so
03:34 - because in link list only sequential
03:37 - access is possible so you have to
03:38 - traverse the list till here after that
03:40 - you can only insert that thing we have
03:42 - discussed in detail right so for that
03:45 - the time complexity would be order of n
03:47 - for inserting order of a node you can
03:50 - say work for this push operation order
03:52 - of n if there are three node in the list
03:56 - then you have to traverse three nodes if
03:58 - there are ten node in the list and after
03:59 - that you want to insert then you will
04:01 - have to traverse all the ten nodes means
04:03 - it depends on the number of nodes order
04:05 - of n second thing if you want to Bill it
04:07 - from the end only in that case also time
04:09 - complexity would be order of n so in
04:11 - case of purple so it would be order of n
04:13 - because we cannot directly delete the
04:16 - data from the end if you want to delete
04:17 - this
04:18 - then you will have to traverse the list
04:20 - till here after then you will do what
04:22 - you will store here is zero then this
04:25 - link would be broken after then after
04:26 - that you can free this data fine so you
04:29 - have to traverse still here so that also
04:31 - depends on the number of nodes present
04:33 - in the list this thing also we have
04:35 - discussed in detail when we were
04:36 - discussing the delete operation from a
04:38 - singly linked list right
04:39 - but in stab see we have discussed these
04:43 - push and pop operation should take order
04:46 - of one so obviously we are implementing
04:48 - step so you should follow these rules
04:50 - now second option is you can insert and
04:55 - delete from the beginning of the list
04:57 - right suppose you want to insert a new
04:59 - node here at the beginning of the list
05:02 - then the time complexity would be you
05:03 - just have to update the links means now
05:07 - head would point to this node and here
05:09 - in the next part you will store address
05:11 - this one and this will spawn to this one
05:14 - right so it is going to take order of
05:16 - one only you no need to traverse the
05:18 - list it does not depend on the number of
05:21 - nor present in the linked list same if
05:24 - you want to delete the first node
05:25 - suppose this is the first node this node
05:27 - I want to delete simply what you need to
05:29 - do one link you will set here head good
05:32 - point two here and you can simply free
05:34 - this node that's it
05:36 - this is also going to take order of one
05:38 - it does not depend on the number of
05:41 - nodes present in the list right so for
05:44 - implementing stack using linked list we
05:47 - will follow which approach we will
05:49 - always push and pop from the beginning
05:53 - or you can say from the head or a right
05:56 - and here we are taking head and instead
05:59 - basically we are taking that name top so
06:02 - here we will take this name as top we
06:05 - are not taking head we are taking top
06:07 - and second thing while implementing
06:10 - stack using linked list you need to take
06:12 - care is see suppose I have called first
06:15 - pushes push to means I want to insert
06:18 - two so here we will create a node
06:21 - because we are using linked list in the
06:23 - data part we will insert two and at star
06:26 - thing I'm taking top is equal to null
06:29 - that is zero or null because we are here
06:32 - considering link list so head rather
06:36 - than head we are taking top and top is
06:37 - equal to null so now suppose we will
06:39 - create a new node this says we have
06:41 - already discussed how to create a node
06:43 - and thus new node pointer is containing
06:45 - address of this one that is 100 suppose
06:46 - it is containing fine so now here what
06:49 - you will do here in the next part we
06:51 - will store this top value is initially
06:54 - top value 0 so here we will store a 0
06:56 - after that now we have inserted we have
06:59 - pushed one node in the stack so top the
07:04 - top should point here so now top should
07:06 - contain hundred right so suppose top is
07:09 - containing hundred address of this one
07:12 - like this this is the stack now next
07:15 - suppose I am inserting five so another
07:18 - node will be created that is five right
07:21 - and suppose address is two hundred in
07:24 - that case this new node would contain
07:27 - two hundred means new node is going to
07:28 - point here fine so now how we will
07:32 - insert this data here in that case this
07:35 - newly created node this next part of
07:39 - this link part would contain address of
07:41 - this node this node we have inserted
07:44 - right so here you will store hundred
07:48 - from where you can get hundred because
07:50 - top is containing one hundred right so
07:52 - now see as you can see this is pointing
07:54 - to this node and now you will do what
07:57 - top is equal to new node that is top to
07:59 - be rude contain 200 so now pop is
08:02 - pointing to this node third suppose you
08:06 - want to insert it here I have created
08:08 - another node here I have eight and in
08:11 - that case new node would point suppose
08:13 - the address is 300 so a new node is
08:15 - containing 300 and you know dude point
08:17 - here now what I will do here you will
08:20 - store address of this node that is 200
08:22 - from where I can get 200 from top so
08:24 - here I have 200 and this will point to
08:26 - this node now we will change this top
08:29 - top would contain 300 that is address of
08:31 - this node and now top is this one and
08:34 - this is what a stack right vertically I
08:37 - am writing the link
08:38 - so now as you can see the difference
08:40 - here in the link list always when you
08:43 - will insert a new node in that case the
08:46 - previous node would contain here the
08:48 - address of the new node but in this case
08:51 - the differences here I have created this
08:53 - new node this new node is containing
08:55 - address of the this previous node this
08:59 - is the difference fine we have changed
09:02 - the policy a little bit and why we have
09:04 - changed with this policy to implement
09:07 - step to follow the rules of stack right
09:12 - now suppose if you want to represent
09:14 - this stack in horizontal form then this
09:17 - would be the step in the form of link
09:20 - list as you can see see top is pointing
09:22 - to this node 8 this node is containing
09:25 - address of this node that is address of
09:27 - this node 200 this node is containing
09:28 - address of this node that is 100 fine
09:31 - firstly we have inserted to find after
09:34 - that we have inserted 5 means 5 becomes
09:37 - the first node and as we have discussed
09:38 - to implement stack to follow these rules
09:41 - the rules of stack we will insert always
09:45 - from the beginning in the linked list we
09:46 - will not insert from the end that we
09:48 - have discussed why we are following this
09:50 - approach because of this time complexity
09:52 - now when we will insert it then it would
09:55 - become the first node that is why it
09:57 - would become the first node right if you
10:00 - will call push again push 10 then here
10:03 - you will insert 10 now top would point
10:07 - here and this node would contain address
10:09 - of this node that is here 300 and top
10:12 - good point suppose address is 400 so in
10:14 - table there would be 400 so this is how
10:16 - you can implement stack using link list
10:18 - you will always insert and delete from
10:20 - one end and that end would be the
10:23 - beginning now we will write down the
10:26 - code for this push and pop operations
10:29 - see here if you write the pop it means
10:31 - after inserting only the 3 3 nodes these
10:34 - few nodes the popped item will be this
10:36 - one it and now top would become pointing
10:38 - to this one and after that you can free
10:40 - this node right same here suppose I have
10:44 - inserted only the 3 nodes top is still
10:46 - pointing to here and if you want to
10:48 - delete then always we will
10:50 - from the head only from the one in
10:52 - Nolan's insertion and deletion so when
10:54 - you will delete this thing - oh good
10:56 - point - here
10:57 - after that you can free this node right
10:58 - now we will write down the code for this
11:01 - push and pop operations so suppose in
11:03 - step I want to push three elements first
11:06 - is 2 then 3 then 10
11:08 - I have called push 3 times right and we
11:12 - have passed the value whatever I want to
11:14 - push fine after that I will display the
11:16 - data after that we will call the peek
11:19 - function peek means it will return the
11:21 - topmost element from the stack without
11:23 - removing that element fine pop means the
11:26 - topmost element would be popped out from
11:28 - the stack fine after that
11:30 - again peek and after that we will
11:31 - display we will called all these
11:33 - functions fine so this is what a stack
11:35 - and we are using the link list that is
11:37 - why obviously for pushing this data to a
11:39 - node would be created fine
11:42 - so struct node we have defined a round
11:44 - area type for that node two parts would
11:47 - be there data part and one is link part
11:49 - pointer part or the next part as you can
11:51 - see fine we have taken one pointer that
11:53 - is top also and this top is of type
11:57 - struct node means type-ins here we
11:59 - always write the data type of that
12:01 - variable or that thing whose address
12:04 - this pointer is going to store and this
12:07 - pointer this top pointer is going to
12:09 - store address of the node proper fine
12:11 - right and that idea type of that node is
12:14 - struct node struct node we have defined
12:16 - this thing we have already discussed
12:17 - when we were discussing the linked list
12:19 - and initially we initialize the top is
12:21 - equal to null means top is not pointing
12:23 - to any node fine now we will define this
12:27 - push function so now here what you need
12:30 - to write here in these arguments what
12:33 - you need to write because I am passing
12:35 - value to so obviously you need some
12:38 - variable integer time because the data
12:40 - type is integer to receive this value
12:43 - fine that is why I am taking here int X
12:46 - parameter of this function void position
12:49 - int X fine now obviously we are going to
12:52 - create a node so and how to create a
12:57 - node that thing we have discussed many
13:00 - times when you are discussing link list
13:02 - so please check out
13:03 - those videos was fine here we will use
13:05 - what a dynamic memory allocation so no
13:07 - need to specify the stack size as we
13:10 - have discussed in Aries in Aries you
13:12 - have to specify the stack size in that
13:14 - example we have taken five so here in
13:16 - that case we have inserted only the five
13:18 - elements but here if you are using the
13:20 - link list means dynamic memory
13:22 - allocation funda we are using so no need
13:24 - to specify the stack size this is what
13:26 - the advantage of using linked list fine
13:29 - now and for dynamic memory allocation we
13:32 - will use what my log function so I guess
13:34 - everybody knows the meaning of this line
13:36 - because we have discussed many times one
13:38 - node has been created and using malloc
13:40 - function dynamic memory allocations and
13:42 - take says we will take how much byte we
13:44 - want how much byte in memory you want
13:46 - sizeof struct node the datatype of this
13:48 - this node is what struct node fine Milo
13:51 - code it and avoid a pointer that is the
13:52 - way you have to typecast this thing
13:54 - because in the new node pointer is what
13:56 - pointer to a node so here you will type
13:58 - cast struck no district and whatever
14:00 - this malloc would return it would be we
14:02 - will store that address into new node
14:04 - new note the address of this node 100
14:07 - this is what how many bytes has been
14:09 - allocated 8 bytes for for this integer
14:12 - data and 4 bytes for this pointer four
14:15 - bytes for this pointer in 32-bit
14:16 - compiler in 64-bit compiler it could
14:19 - take 8 bytes right
14:20 - and in typical compilers the integer is
14:23 - going to take 4 bytes
14:25 - somewhere it is going to take two bites
14:27 - fine so now here you will store in the
14:30 - data part we will store to have you will
14:32 - store that thing how you can access this
14:34 - part we can access the structure members
14:37 - using the pointer only with this pointer
14:39 - is pointing to this node so new node
14:42 - arrow and that this name of this part is
14:46 - data is equal to X because in X we are
14:49 - going to receive this value to write so
14:52 - here we have to now now the next thing
14:55 - is simple rule is what here in the next
14:57 - part what you will store new node next
15:02 - here I am going to store the value
15:03 - whatever the value in top is equal to
15:06 - top right in top I have null so here we
15:09 - will store null fine now
15:13 - firstly we have inserted this data in
15:15 - the stack so top should point to this
15:17 - node right so now in top what you will
15:21 - store address of this node that is
15:23 - hundred and from where you will get this
15:26 - hundred see a new node I have 100 so top
15:30 - is equal to new that's it again suppose
15:36 - if you call push is equal to 3 3 will be
15:39 - power passed X is equal to now 3 fine
15:42 - again a new node would be created a new
15:46 - node would be created right now this new
15:49 - node suppose address is 200 so now in
15:51 - new node point that I have 200 means
15:53 - this is now pointing to this node right
15:57 - new node data is equal to X in X I have
16:00 - 3 now right new node next means new node
16:05 - next this part would contain top top is
16:07 - containing 100 so here hundred it means
16:10 - 100 is that is of this thing so this is
16:12 - pointing to this node right now top is
16:16 - equal to a new node top is equal to a
16:17 - new node a new node I have 200 so top is
16:20 - containing 200 means top would point to
16:22 - this node now right again if you call
16:27 - push is equal to 10 in X now I have 10
16:30 - again a new mode would be carried
16:31 - suppose address is 300 so in new node
16:34 - after creating this this node addresses
16:37 - this one 3 hundreds fine new node datum
16:41 - means here we will store X in X I have
16:44 - now 10 new node next is equal to top new
16:47 - node next is equal to top top is
16:49 - containing 200 means it is pointing to
16:51 - this node now and now top is equal to a
16:54 - new node means top is pointing to this
16:56 - node that is here we will store 300 and
16:59 - this is what a stack this is what a
17:01 - logical representation of stock right
17:03 - now suppose if you call this display
17:06 - function it means it should display
17:08 - first of all 10 then 3 then 2 right
17:13 - because top is bonding to this node
17:15 - somewhere you will find out that they
17:17 - will display the data from here 2 3 and
17:20 - 10 but here we will implement this logic
17:22 - fine because from here only we can
17:24 - display so first of all 10 we
17:26 - let's play then three then two so now
17:28 - how you will display the data see see in
17:31 - the push operation we haven't checked
17:33 - for the old flow condition why so
17:34 - because in the staff we haven't fixed
17:37 - the size suppose we have fixed the size
17:40 - that is three so in that case we haven't
17:42 - we we are not able to insert forth data
17:45 - that is why we check no flow condition
17:47 - right when we were implementing stack
17:49 - using areas but here we haven't
17:51 - specified the size of the stack that is
17:54 - why we haven't checked the overflow
17:56 - condition fine now however we are going
17:59 - to display the data first of all I will
18:01 - display n then three then two where you
18:03 - are going to stop when it becomes zero
18:06 - the next part of this becomes zero so
18:09 - you need to take another pointer you can
18:11 - say m pointer fine because top is always
18:14 - going to point the topmost element we
18:16 - cannot move this top for for displaying
18:18 - first of all you will display this data
18:20 - then this then this so we have to move
18:22 - some pointer so here you will take
18:24 - another pointer that is temp pointer and
18:27 - initially temp would point to top right
18:31 - because we are going to start from here
18:34 - temp is equal to top it means temp is
18:38 - now containing whatever the top value
18:40 - that is three hundred so now temp is
18:42 - pointing to this node right here you can
18:46 - check for under flow condition if there
18:48 - is no node in the list in that case
18:49 - obviously we cannot print anything less
18:52 - than M pretty fine so here you can check
18:54 - if top equal to equal to null right in
18:58 - that case here in printf you can say
19:00 - let's assemble take write in else part
19:03 - what you will do obviously we are going
19:06 - to take a loop so here I am taking a
19:08 - while loop while temp not equal to none
19:16 - right
19:17 - till then what we are going to print the
19:20 - data first of all so here what you will
19:22 - write in printf percentage D and temp
19:29 - data this is Javier boom to access the
19:32 - spot temp data means 10 would be printed
19:35 - right now I want to print 3 so you have
19:38 - to move this
19:39 - them in temp now I want to store 200
19:42 - right address of the previous node from
19:45 - where I can get 200 here I have 200 so
19:48 - here what I can write M is equal to M
19:52 - and then this name of this part is
19:56 - linked now m p-- is equal to temp link
20:01 - means 200 now temp is containing 200
20:04 - means temp is pointing to this node
20:05 - right while time not equal to none yes
20:09 - temp is not equal to null so again
20:11 - control will enter to the soup print f
20:13 - percentage D temp data template i
20:15 - streets you would be printed temp is
20:17 - equal to temp of link in temp of link I
20:20 - have hundred so in here I will update
20:22 - that M that is hundred so temp is
20:24 - pointing to this node now again check
20:27 - time not equal to none
20:29 - yes temp is 100 it is not equal to null
20:31 - again temp of data means to be printed
20:34 - again temp is equal to temp link in temp
20:37 - link now say in temp of link I have 0 so
20:40 - in temp now I will store 0 it means temp
20:43 - is not pointing to anywhere now check
20:46 - the condition temp not equal to null
20:47 - this condition is not true because temp
20:50 - is now 0 and 0 is equal to 0 so control
20:52 - will not enter into the slope right and
20:55 - what you have printed all the rate at 10
20:57 - 3 & 2 so now you can close this else and
21:02 - this display function right this is how
21:05 - we are going to traverse the stack or
21:07 - you are going to display the data of the
21:09 - step so now next function is peak
21:12 - function see the coding of this function
21:15 - what peak function will return it will
21:17 - display the topmost element what is the
21:19 - top element of the data we are just
21:21 - going to see the top element of the data
21:23 - that's it right they are not going to do
21:26 - top - - or anything fine
21:29 - so now suppose we don't have anything in
21:31 - this stack then it should print a proper
21:35 - message suppose top is equal to is equal
21:37 - to null it means here you can write
21:40 - printf stack as empathy right else
21:45 - else what you can print printf top
21:52 - element is percentage D and how we will
21:58 - print this element how you can exist
21:59 - this end this part pointer to this node
22:02 - is top so where you can write top data
22:05 - this is how you can access the data part
22:09 - and that's it
22:11 - when you will call this big then it will
22:12 - print and fine this is what the peak
22:17 - operation is now we will see the coding
22:20 - for the pop operation so now pop means
22:23 - this topmost element would be removed
22:26 - and after that the size of style becomes
22:28 - here now the size of stack is 3 so now
22:31 - after that size of struct becomes 2
22:33 - means after popping this the top should
22:36 - point to this node right and if you
22:41 - don't delete this thing then you can
22:43 - simply do top in top I want to store 200
22:47 - so in top is equal to top link right and
22:50 - after that top would point to this node
22:52 - but we should not leave this node like
22:55 - this the memory is still allocated to
22:57 - this node and memory is very crucial
22:58 - resource so you have to clean this thing
23:02 - this is now our busines you have to
23:04 - clean this garbage so simply you can do
23:06 - you can free this node
23:08 - free and you can use a free function
23:11 - that we have discussed when we were
23:12 - discussing the linked list concept and
23:14 - we can do suppose pointer when pointer
23:16 - is pointing to this node M and we can
23:19 - pass free M after that this memory would
23:21 - be freed right if you will not free this
23:25 - memory that is also fine that is also
23:27 - you have done the popping operation that
23:29 - is also fine but the better approaches
23:31 - you should free this memory and for this
23:34 - thing obviously we are going to take
23:35 - another pointer struct node 10 pointer
23:40 - so that we can pass this pointer in that
23:44 - free function fine so we have taken free
23:48 - sorry struct node M and
23:52 - now Pam should point to top so temp is
23:56 - now containing that is whatever the top
23:59 - is containing three hundred so temp is
24:00 - pointing to this knob right now suppose
24:04 - there is no load in the list in that
24:05 - case under flow condition is there right
24:07 - so here you can check if top equal to
24:11 - equal to none so here you can print
24:14 - printf under flow right there is no node
24:18 - in the list else now what you can do if
24:23 - you want to print the pop element if you
24:26 - want to print that the pop element is
24:28 - then in that case what you will do see
24:32 - first of all here you can print printf
24:37 - here you can write the pop element is
24:39 - percentage D I am writing only this
24:41 - thing and what this thing I want to
24:44 - print so here either you can access this
24:46 - by 10 power by top it's up to you right
24:50 - because both hunters are pointing to
24:52 - this no time is assessing this by top
24:55 - top data top data right so now this you
25:01 - would print 10 after that we can do what
25:04 - after that after removing this you
25:06 - because I want to remove this thing now
25:08 - so the stop should point to this node
25:10 - right so after that I can do top is
25:13 - equal to and this of this node I want to
25:16 - so that is 200 from where I can get 200
25:18 - here I have 200 so I can write top is
25:20 - equal to top link or you can write top
25:25 - is equal to temp link because this node
25:28 - is having two pointers temp and top so
25:31 - you can access these parts either by
25:33 - temple top it's up to you so you can
25:35 - write top is equal to temp off link that
25:37 - is also fine now top is containing two
25:40 - hundred so now top is pointing to this
25:43 - node right now you can free this node
25:46 - here I can write free and the pointer
25:48 - still pointing to this node is 10 right
25:52 - now this is how we have deleted this
25:55 - node and if you don't want to print the
25:58 - pop element then no need to write down
26:01 - this line simply
26:02 - top is equal to top of length and here
26:05 - this would be pointing right and if you
26:08 - will not free this memory free of them
26:10 - if you will not take this temp pointer
26:13 - that is also fine fine but you should
26:17 - take this for freeing this memory right
26:20 - because we cannot leave this garbage
26:21 - like this so now the output of this pop
26:24 - function would be in because we have
26:27 - deleted we have print printed the state
26:29 - a table data now again if you call peak
26:32 - in that case it should print what three
26:34 - only because now after popping one data
26:38 - the topmost element is three so it
26:40 - should print three and when you will
26:42 - display the function sorry when you call
26:44 - the display function then it would
26:46 - display three two so here three and two
26:49 - this would be the output right and now
26:52 - could have this display would be 10 3 to
26:54 - 10 3 n 2 right so this is how we are
26:59 - going to implement stack using link list
27:01 - so next video we will discuss some more
27:04 - applications of stack using code as well
27:07 - as we will discuss about queue data
27:09 - structure fine
27:10 - so as soon the next video till then bye
27:11 - bye take care

Cleaned transcript:

the topic is stack implementation using linked lists right so the prerequisite of this video is you should know about stack and link lists right we have already discussed what is stack and how to implement stack using arrays or what are the different operations on stack right in the previous videos as well as we have discussed the topic linked list all the type of linked list as well as how to perform insertion deletion traverser all the operations on linked list for those with videos you can check out the description box right so I assume that you know the what is stack and what is linked list right now we are going to implement stack using linked list see we will implement stack using linked list right so you have to follow the rule of the stack and what is that rule that is leaf or principle stack always follow what leaf or principle last in first out right that thing we have discussed in the previous video right for that video you can check out the side button so stack is what it is an ordered list or you can say it is a collection where the insertion and deletion always perform from one end only and how we are going to represent the stack the logical represent is something like this it is a container which is having one open end right this insertion is also from this end and deletion would also perform from this end and this end is known as top so the push and pop operations will be performed always from the top of the stack and what is a linked list see when I am saying a linked list it means we are discussing about singly linked list by default right so this is what a singly linked list this is a node in the linked list two parts are there one is data part one is address part this address part or link part is containing address of the next node right that is four hundred here hundred the last node is containing null because this is not pointing to any node and head pointer head is containing address of the first node so when you are going to program the linked list then what we have the information we have is what head pointer only the head pointer right not head in order this is head pointer this is what you can say head node the first right we have only the header pointer that is address of the first node fine this is what a link lists now you have to implement tag using link list so here we will store the Atty in the form of nodes as well as we have to follow the rules that is only for principle and we have discussed the push and pop operation the two fundamental operations push and pop is going to take order of one time complexity is order of one only in the form of stack so you have to take care of this thing also so now we can perform insertion and deletion from the one end all right so in linked list suppose I am taking linked list so that end can be the stale or the head you can insert and delete both from the tail and only also as well as from the head also from the starting also right so two options you have so if you insert and believe the data from the tail here from the end of the linked list then see the time complexity would be suppose this is the list and we will we want to insert another node in the list so here you are going to insert suppose I am taking that approach that from and only I can insert and here only I can delete right so now you can directly insert the data here why so because in link list only sequential access is possible so you have to traverse the list till here after that you can only insert that thing we have discussed in detail right so for that the time complexity would be order of n for inserting order of a node you can say work for this push operation order of n if there are three node in the list then you have to traverse three nodes if there are ten node in the list and after that you want to insert then you will have to traverse all the ten nodes means it depends on the number of nodes order of n second thing if you want to Bill it from the end only in that case also time complexity would be order of n so in case of purple so it would be order of n because we cannot directly delete the data from the end if you want to delete this then you will have to traverse the list till here after then you will do what you will store here is zero then this link would be broken after then after that you can free this data fine so you have to traverse still here so that also depends on the number of nodes present in the list this thing also we have discussed in detail when we were discussing the delete operation from a singly linked list right but in stab see we have discussed these push and pop operation should take order of one so obviously we are implementing step so you should follow these rules now second option is you can insert and delete from the beginning of the list right suppose you want to insert a new node here at the beginning of the list then the time complexity would be you just have to update the links means now head would point to this node and here in the next part you will store address this one and this will spawn to this one right so it is going to take order of one only you no need to traverse the list it does not depend on the number of nor present in the linked list same if you want to delete the first node suppose this is the first node this node I want to delete simply what you need to do one link you will set here head good point two here and you can simply free this node that's it this is also going to take order of one it does not depend on the number of nodes present in the list right so for implementing stack using linked list we will follow which approach we will always push and pop from the beginning or you can say from the head or a right and here we are taking head and instead basically we are taking that name top so here we will take this name as top we are not taking head we are taking top and second thing while implementing stack using linked list you need to take care is see suppose I have called first pushes push to means I want to insert two so here we will create a node because we are using linked list in the data part we will insert two and at star thing I'm taking top is equal to null that is zero or null because we are here considering link list so head rather than head we are taking top and top is equal to null so now suppose we will create a new node this says we have already discussed how to create a node and thus new node pointer is containing address of this one that is 100 suppose it is containing fine so now here what you will do here in the next part we will store this top value is initially top value 0 so here we will store a 0 after that now we have inserted we have pushed one node in the stack so top the top should point here so now top should contain hundred right so suppose top is containing hundred address of this one like this this is the stack now next suppose I am inserting five so another node will be created that is five right and suppose address is two hundred in that case this new node would contain two hundred means new node is going to point here fine so now how we will insert this data here in that case this newly created node this next part of this link part would contain address of this node this node we have inserted right so here you will store hundred from where you can get hundred because top is containing one hundred right so now see as you can see this is pointing to this node and now you will do what top is equal to new node that is top to be rude contain 200 so now pop is pointing to this node third suppose you want to insert it here I have created another node here I have eight and in that case new node would point suppose the address is 300 so a new node is containing 300 and you know dude point here now what I will do here you will store address of this node that is 200 from where I can get 200 from top so here I have 200 and this will point to this node now we will change this top top would contain 300 that is address of this node and now top is this one and this is what a stack right vertically I am writing the link so now as you can see the difference here in the link list always when you will insert a new node in that case the previous node would contain here the address of the new node but in this case the differences here I have created this new node this new node is containing address of the this previous node this is the difference fine we have changed the policy a little bit and why we have changed with this policy to implement step to follow the rules of stack right now suppose if you want to represent this stack in horizontal form then this would be the step in the form of link list as you can see see top is pointing to this node 8 this node is containing address of this node that is address of this node 200 this node is containing address of this node that is 100 fine firstly we have inserted to find after that we have inserted 5 means 5 becomes the first node and as we have discussed to implement stack to follow these rules the rules of stack we will insert always from the beginning in the linked list we will not insert from the end that we have discussed why we are following this approach because of this time complexity now when we will insert it then it would become the first node that is why it would become the first node right if you will call push again push 10 then here you will insert 10 now top would point here and this node would contain address of this node that is here 300 and top good point suppose address is 400 so in table there would be 400 so this is how you can implement stack using link list you will always insert and delete from one end and that end would be the beginning now we will write down the code for this push and pop operations see here if you write the pop it means after inserting only the 3 3 nodes these few nodes the popped item will be this one it and now top would become pointing to this one and after that you can free this node right same here suppose I have inserted only the 3 nodes top is still pointing to here and if you want to delete then always we will from the head only from the one in Nolan's insertion and deletion so when you will delete this thing oh good point here after that you can free this node right now we will write down the code for this push and pop operations so suppose in step I want to push three elements first is 2 then 3 then 10 I have called push 3 times right and we have passed the value whatever I want to push fine after that I will display the data after that we will call the peek function peek means it will return the topmost element from the stack without removing that element fine pop means the topmost element would be popped out from the stack fine after that again peek and after that we will display we will called all these functions fine so this is what a stack and we are using the link list that is why obviously for pushing this data to a node would be created fine so struct node we have defined a round area type for that node two parts would be there data part and one is link part pointer part or the next part as you can see fine we have taken one pointer that is top also and this top is of type struct node means typeins here we always write the data type of that variable or that thing whose address this pointer is going to store and this pointer this top pointer is going to store address of the node proper fine right and that idea type of that node is struct node struct node we have defined this thing we have already discussed when we were discussing the linked list and initially we initialize the top is equal to null means top is not pointing to any node fine now we will define this push function so now here what you need to write here in these arguments what you need to write because I am passing value to so obviously you need some variable integer time because the data type is integer to receive this value fine that is why I am taking here int X parameter of this function void position int X fine now obviously we are going to create a node so and how to create a node that thing we have discussed many times when you are discussing link list so please check out those videos was fine here we will use what a dynamic memory allocation so no need to specify the stack size as we have discussed in Aries in Aries you have to specify the stack size in that example we have taken five so here in that case we have inserted only the five elements but here if you are using the link list means dynamic memory allocation funda we are using so no need to specify the stack size this is what the advantage of using linked list fine now and for dynamic memory allocation we will use what my log function so I guess everybody knows the meaning of this line because we have discussed many times one node has been created and using malloc function dynamic memory allocations and take says we will take how much byte we want how much byte in memory you want sizeof struct node the datatype of this this node is what struct node fine Milo code it and avoid a pointer that is the way you have to typecast this thing because in the new node pointer is what pointer to a node so here you will type cast struck no district and whatever this malloc would return it would be we will store that address into new node new note the address of this node 100 this is what how many bytes has been allocated 8 bytes for for this integer data and 4 bytes for this pointer four bytes for this pointer in 32bit compiler in 64bit compiler it could take 8 bytes right and in typical compilers the integer is going to take 4 bytes somewhere it is going to take two bites fine so now here you will store in the data part we will store to have you will store that thing how you can access this part we can access the structure members using the pointer only with this pointer is pointing to this node so new node arrow and that this name of this part is data is equal to X because in X we are going to receive this value to write so here we have to now now the next thing is simple rule is what here in the next part what you will store new node next here I am going to store the value whatever the value in top is equal to top right in top I have null so here we will store null fine now firstly we have inserted this data in the stack so top should point to this node right so now in top what you will store address of this node that is hundred and from where you will get this hundred see a new node I have 100 so top is equal to new that's it again suppose if you call push is equal to 3 3 will be power passed X is equal to now 3 fine again a new node would be created a new node would be created right now this new node suppose address is 200 so now in new node point that I have 200 means this is now pointing to this node right new node data is equal to X in X I have 3 now right new node next means new node next this part would contain top top is containing 100 so here hundred it means 100 is that is of this thing so this is pointing to this node right now top is equal to a new node top is equal to a new node a new node I have 200 so top is containing 200 means top would point to this node now right again if you call push is equal to 10 in X now I have 10 again a new mode would be carried suppose address is 300 so in new node after creating this this node addresses this one 3 hundreds fine new node datum means here we will store X in X I have now 10 new node next is equal to top new node next is equal to top top is containing 200 means it is pointing to this node now and now top is equal to a new node means top is pointing to this node that is here we will store 300 and this is what a stack this is what a logical representation of stock right now suppose if you call this display function it means it should display first of all 10 then 3 then 2 right because top is bonding to this node somewhere you will find out that they will display the data from here 2 3 and 10 but here we will implement this logic fine because from here only we can display so first of all 10 we let's play then three then two so now how you will display the data see see in the push operation we haven't checked for the old flow condition why so because in the staff we haven't fixed the size suppose we have fixed the size that is three so in that case we haven't we we are not able to insert forth data that is why we check no flow condition right when we were implementing stack using areas but here we haven't specified the size of the stack that is why we haven't checked the overflow condition fine now however we are going to display the data first of all I will display n then three then two where you are going to stop when it becomes zero the next part of this becomes zero so you need to take another pointer you can say m pointer fine because top is always going to point the topmost element we cannot move this top for for displaying first of all you will display this data then this then this so we have to move some pointer so here you will take another pointer that is temp pointer and initially temp would point to top right because we are going to start from here temp is equal to top it means temp is now containing whatever the top value that is three hundred so now temp is pointing to this node right here you can check for under flow condition if there is no node in the list in that case obviously we cannot print anything less than M pretty fine so here you can check if top equal to equal to null right in that case here in printf you can say let's assemble take write in else part what you will do obviously we are going to take a loop so here I am taking a while loop while temp not equal to none right till then what we are going to print the data first of all so here what you will write in printf percentage D and temp data this is Javier boom to access the spot temp data means 10 would be printed right now I want to print 3 so you have to move this them in temp now I want to store 200 right address of the previous node from where I can get 200 here I have 200 so here what I can write M is equal to M and then this name of this part is linked now m p is equal to temp link means 200 now temp is containing 200 means temp is pointing to this node right while time not equal to none yes temp is not equal to null so again control will enter to the soup print f percentage D temp data template i streets you would be printed temp is equal to temp of link in temp of link I have hundred so in here I will update that M that is hundred so temp is pointing to this node now again check time not equal to none yes temp is 100 it is not equal to null again temp of data means to be printed again temp is equal to temp link in temp link now say in temp of link I have 0 so in temp now I will store 0 it means temp is not pointing to anywhere now check the condition temp not equal to null this condition is not true because temp is now 0 and 0 is equal to 0 so control will not enter into the slope right and what you have printed all the rate at 10 3 & 2 so now you can close this else and this display function right this is how we are going to traverse the stack or you are going to display the data of the step so now next function is peak function see the coding of this function what peak function will return it will display the topmost element what is the top element of the data we are just going to see the top element of the data that's it right they are not going to do top or anything fine so now suppose we don't have anything in this stack then it should print a proper message suppose top is equal to is equal to null it means here you can write printf stack as empathy right else else what you can print printf top element is percentage D and how we will print this element how you can exist this end this part pointer to this node is top so where you can write top data this is how you can access the data part and that's it when you will call this big then it will print and fine this is what the peak operation is now we will see the coding for the pop operation so now pop means this topmost element would be removed and after that the size of style becomes here now the size of stack is 3 so now after that size of struct becomes 2 means after popping this the top should point to this node right and if you don't delete this thing then you can simply do top in top I want to store 200 so in top is equal to top link right and after that top would point to this node but we should not leave this node like this the memory is still allocated to this node and memory is very crucial resource so you have to clean this thing this is now our busines you have to clean this garbage so simply you can do you can free this node free and you can use a free function that we have discussed when we were discussing the linked list concept and we can do suppose pointer when pointer is pointing to this node M and we can pass free M after that this memory would be freed right if you will not free this memory that is also fine that is also you have done the popping operation that is also fine but the better approaches you should free this memory and for this thing obviously we are going to take another pointer struct node 10 pointer so that we can pass this pointer in that free function fine so we have taken free sorry struct node M and now Pam should point to top so temp is now containing that is whatever the top is containing three hundred so temp is pointing to this knob right now suppose there is no load in the list in that case under flow condition is there right so here you can check if top equal to equal to none so here you can print printf under flow right there is no node in the list else now what you can do if you want to print the pop element if you want to print that the pop element is then in that case what you will do see first of all here you can print printf here you can write the pop element is percentage D I am writing only this thing and what this thing I want to print so here either you can access this by 10 power by top it's up to you right because both hunters are pointing to this no time is assessing this by top top data top data right so now this you would print 10 after that we can do what after that after removing this you because I want to remove this thing now so the stop should point to this node right so after that I can do top is equal to and this of this node I want to so that is 200 from where I can get 200 here I have 200 so I can write top is equal to top link or you can write top is equal to temp link because this node is having two pointers temp and top so you can access these parts either by temple top it's up to you so you can write top is equal to temp off link that is also fine now top is containing two hundred so now top is pointing to this node right now you can free this node here I can write free and the pointer still pointing to this node is 10 right now this is how we have deleted this node and if you don't want to print the pop element then no need to write down this line simply top is equal to top of length and here this would be pointing right and if you will not free this memory free of them if you will not take this temp pointer that is also fine fine but you should take this for freeing this memory right because we cannot leave this garbage like this so now the output of this pop function would be in because we have deleted we have print printed the state a table data now again if you call peak in that case it should print what three only because now after popping one data the topmost element is three so it should print three and when you will display the function sorry when you call the display function then it would display three two so here three and two this would be the output right and now could have this display would be 10 3 to 10 3 n 2 right so this is how we are going to implement stack using link list so next video we will discuss some more applications of stack using code as well as we will discuss about queue data structure fine so as soon the next video till then bye bye take care
