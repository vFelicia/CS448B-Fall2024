With timestamps:

00:00 - so far in this lecture series of DBMS we
00:02 - have discussed first second and third
00:04 - normal form right what is the basic idea
00:07 - of these those normal forms means what
00:09 - are the rules and regulations for a
00:10 - relation to be in first second and third
00:14 - normal form right and we have also
00:16 - discussed that a particular this type of
00:18 - relation would be given functional
00:19 - dependencies would be given and you have
00:21 - to identify that the particular given
00:22 - relation is in you can say in first
00:25 - second or third normal form or not right
00:28 - using those rules we haven't discussed
00:31 - that if relation is not in second normal
00:34 - form then how to convert it into second
00:36 - normal form means how to decompose that
00:38 - relation fine first of all you will
00:40 - discuss the basic idea of all the normal
00:42 - forms so in this video I will discuss
00:44 - what is bcnf now what are the drawbacks
00:46 - and the second in normal form and
00:48 - because of those drawbacks the concept
00:51 - of third normal form came into picture
00:52 - that also we have discussed in the
00:53 - previous video right but still we have
00:56 - some drawbacks in third normal form it
00:58 - sometimes see I have told you in the
01:00 - previous video that if your database
01:02 - design your relational schema is in
01:04 - third NF then you can say that it is a
01:06 - good database design right
01:07 - but sometimes still because at some
01:11 - cases still there are some redundancy if
01:13 - your table is in third normal form but
01:15 - still there is some redundancy exists in
01:18 - that table and because of that you can
01:20 - get some anomalies right when this type
01:23 - of problem comes because third and if
01:25 - you know it's not able to handle the
01:28 - cases when you have multiple candidate
01:30 - keys and all the candidate keys are
01:32 - overlapping or you can say we have
01:33 - multiple overlapping candidate Keys like
01:36 - this suppose in our relation we have one
01:38 - candidate is a B second is BC next you
01:42 - can say DC like this see this and this
01:44 - is overlapping candidate key is here
01:46 - also see here also see here B here we
01:48 - have B so when these kind of cases exist
01:51 - then third normal form cannot handle
01:54 - these type of cases right to handle
01:56 - these type of cases we have bcnf we
02:01 - cannot say that it is fourth normal form
02:03 - right it is you can say that a stronger
02:06 - version of third normal form where you
02:08 - can say advanced version of 3nf and why
02:12 - it is known as Boyce Codd
02:14 - normal form because it was developed by
02:17 - EF code and Raymond F boys that is why
02:24 - it is known as Boyce Codd normal form
02:25 - it is not fourth normal form right
02:27 - remaining four second or third normal
02:29 - form was developed by EF code only see
02:32 - he's known as father of DBMS right now
02:36 - why this is more strict than third
02:40 - normal form
02:41 - let us discuss that what are the rules
02:43 - for a relation what are the requirements
02:44 - for a relation to be in bcnf and after
02:48 - that we will discuss with the help of
02:50 - two or three examples that something
02:53 - this this type of question would be
02:54 - given and you have to tell this as in
02:56 - bcnf or not and we will also see with
02:58 - one example that you have to tell the
03:02 - highest normal form exist in that
03:03 - relation whether its second third or
03:06 - bcnf right and after this video we will
03:10 - discuss what is the composition and
03:12 - after that we will discuss if a
03:14 - particular relation is not in a desired
03:16 - normal form then how to decompose that
03:18 - relation how to convert that relation
03:20 - into desired a normal phone so the rules
03:24 - are you can say our relation is in bcnf
03:27 - if and only if first one is it is in
03:30 - third and if right second rule is there
03:34 - for each non-trivial functional
03:36 - dependency see I'm talking about known
03:38 - trivial functional dependency not
03:40 - trivial right in the third normal form
03:42 - also we have discussed the rules on
03:43 - known real functional dependency right
03:45 - and by default by default we assume that
03:48 - all the this this relation given is in
03:51 - first normal form plus these
03:52 - dependencies given are in you can say
03:55 - non trivial because we we usually take
03:58 - those kind of dependencies that are
04:01 - known trivial right so second rule is
04:04 - for each known trivial functional
04:06 - dependency the left-hand side of the
04:09 - dependency must be super or you can say
04:13 - that determinant must be super key let
04:15 - me write down these rules so these are
04:18 - two rules it is in third and F second is
04:21 - this one for each non-trivial functional
04:23 - dependency I have discussed what is
04:25 - trivial what is known to your functional
04:26 - dependency suppose
04:27 - - is x2y right then X the left-hand side
04:31 - of the dependency must be super key so
04:35 - it is very easy to check if a particular
04:38 - relation is in bcnf or not just you have
04:41 - to find out the super keys or if you
04:43 - don't want to find out all the super
04:45 - keys then you can go for each dependency
04:47 - and you can check a super key or not be
04:50 - a super key or not and see is super cure
04:52 - not and how to check that particular
04:54 - attribute or particular key is a super
04:55 - key or not just find out to find out the
04:58 - closer attribute closer and if attribute
05:00 - closer contains all the attributes of a
05:03 - given relation then that is what a super
05:05 - key right so let's check this relation
05:09 - is in bcnf or not find C so here I will
05:14 - not simply check that this is super key
05:16 - or not this is super cure not or this is
05:18 - super cure note because obviously
05:19 - they'll give you these type of questions
05:21 - and get in it they'll give you a
05:22 - particular relation functional
05:23 - dependencies and they'll ask the highest
05:26 - normal form exists in this relation so
05:28 - for that obviously you need to check for
05:29 - third also and second also and for those
05:32 - normal forms you need to find out the
05:35 - candidate keys
05:36 - so let's find out the candidate keys
05:37 - first of all after that we will check
05:39 - how to find out candidate he's C take
05:41 - the ol attributes take the closer and
05:44 - definitely that would find out all that
05:46 - tribute of the relation so you can say
05:48 - that this is a super key now find out
05:50 - candidate is you discard as many
05:53 - elements as many attributes as you can
05:55 - because can it he wrote a minimal
05:57 - superkey check out the functional
05:59 - dependencies how to discard check out
06:00 - functional dependency see a determined B
06:02 - it means I have a so I can discard B
06:06 - because using a I can determine a and as
06:10 - well as if you have a you can determine
06:12 - B right and it will later mind see it is
06:15 - still having all the attributes so this
06:16 - is what's still a super key now can you
06:19 - discard anything else a determined B be
06:21 - determined C it means a will determine C
06:23 - by transitivity property so you can
06:24 - discard C so here I am left with only a
06:28 - now a is what super key obviously we are
06:31 - not going to discard anything else
06:32 - because it is single attribute single
06:35 - attribute this will attribute closer
06:37 - will contain all that good so it is so
06:39 - foggy now check it as candidate here not
06:40 - definitely it would be
06:41 - why because it is containing a single
06:43 - attribute and no proper subset would be
06:45 - possible if no proper subset is possible
06:48 - then there is no chance that the proper
06:50 - subset of this would be a super key so
06:53 - that is why it is a candidate key so if
06:55 - a is candidate key then prime attribute
06:57 - we got a now how to check that still
07:01 - more super candidate keys are present in
07:03 - this relation or not if prime attributes
07:05 - are present on the right hand side of
07:07 - any functional dependency I have already
07:08 - discussed this trick in the previous
07:10 - video you can check out that video in
07:11 - the cyber turn then there would be more
07:14 - candidate here so check out prime
07:16 - attribute is a is a present on the right
07:17 - hand side of any functional dependency
07:19 - yes here so you can replace this a with
07:22 - C in candidate he can read he is a so
07:24 - you can replace it with C but we cannot
07:28 - say that still it is a candidate key you
07:30 - have to find it out it is super key that
07:32 - thing I can definitely see now how could
07:34 - a proper subset of C is possible no so
07:37 - if no proper subset is there then
07:38 - definitely that would be an innately so
07:40 - we go to candidate key a and C prime
07:43 - attribute a and C check again C is now
07:46 - prime a tribute now C is present on the
07:48 - right hand side of this functional
07:49 - dependency so you can replace this C
07:50 - with B I am replacing this with B now B
07:54 - is super key find out it is candidate or
07:56 - not yes single attribute yes definitely
07:59 - that would be candidate key prime a
08:01 - tribute is B now you can say B is
08:05 - present on the right hand side of this
08:06 - so you could replace this B with a but
08:08 - we have already check is can it get key
08:11 - right so now we have got all the
08:12 - candidate keys that is one is a B and C
08:15 - prime attribute are a B and C right see
08:19 - all that we do is our prime attributes'
08:21 - now you check this is in bcnf or not now
08:27 - check for each dependency C first of all
08:29 - it is in third and if it should be in
08:31 - third and if so this is in third and if
08:33 - I have taken this kind of example that
08:34 - it is already in third and if right and
08:37 - if you want to check the new can check
08:38 - there would be no transitive dependency
08:40 - because all the attributes are prime
08:41 - attributes and positive dependency is
08:43 - what non-prime attribute determining
08:46 - non-prime attribute right or another in
08:49 - another words you can say first either
08:52 - left-hand side is super key or right
08:55 - hand
08:55 - satisfy my tribute write if any of these
08:59 - to condition holds for each functional
09:01 - dependency you can say that this then
09:04 - you can say that there is no transitive
09:05 - dependency and that relation is in third
09:09 - in F right now there would be no
09:12 - non-prime attribute because all are
09:13 - prime so that would definitely be in
09:15 - third and F check for bcnf this is true
09:19 - now for each non-trivial functional
09:20 - dependency these three are non-trivial
09:22 - functional dependency X must be super
09:25 - key check this left-hand side must be
09:26 - super key is a super key yes
09:29 - so first is what according to first it
09:33 - is in bcnf not check this is violating
09:36 - the rule of bcnf or not is being super
09:39 - key yes B is candidate key definitely it
09:41 - would be super key yes you see super key
09:44 - C is candidate key definitely it is a
09:45 - super key so yes means each functional
09:49 - dependency is satisfying the requirement
09:52 - of bcnf right so you can say that this
09:54 - relation is in bcnf see why we are
09:57 - saying that it is more strict than third
09:59 - and F because in third and F we have
10:01 - what rules either left-hand side is
10:05 - super key or right hand side is prime
10:06 - attribute then find that would be in
10:09 - third and if right but here definitely
10:12 - the left-hand side you can say the
10:15 - left-hand side must be super key right
10:17 - no other condition is there this must be
10:20 - satisfied so that is why we are saying
10:22 - that it is a and you can say more strict
10:25 - origin of 3nf because 3 and F doesn't
10:28 - deal these kind of condition like if a
10:30 - non-prime attribute is determining a
10:34 - prime attribute then according to
10:36 - thordan f it is not a transitive
10:39 - dependency B why so because right hand
10:42 - side is prime attribute so it is not
10:44 - going to do these kind of cases a
10:45 - non-prime attribute is determining a
10:47 - prime attribute because of this
10:48 - dependency there would be some problem
10:50 - right but here in this case this left
10:53 - hand side must be super clean but here
10:56 - it is not a super key so it will not
10:58 - allow these kind of dependency here
11:00 - right and what about second normal form
11:03 - this will the second normal form deal
11:06 - with these type of cases right if Prime
11:08 - tribute is determining a non-prime
11:10 - attribute c-prime attribute means it
11:12 - should be a proper subset of candidate
11:13 - he it's not like that it is a proper
11:16 - candidate key it should be a proper
11:18 - subset of candidate key then it will
11:20 - lower late the condition of second in it
11:21 - right so now you have the idea of all
11:24 - the normal forms for second third bcnf
11:26 - now i will discuss with one example and
11:28 - i will give you one example and we will
11:30 - discuss that what is the highest normal
11:33 - form given in that relation right see
11:36 - let us take this example and find out
11:39 - the highest normal form of this relation
11:41 - see so for this first of all we need to
11:44 - find out the candidate is all the
11:45 - candidate is how to find out candidate
11:47 - keys
11:48 - first of all take all the attributes of
11:50 - this relation closer obviously will
11:51 - contain all that tribute so this is
11:53 - super key now try to discard is
11:55 - remaining BCDE so I have a so using a I
11:58 - can determine a itself plus B CBE using
12:03 - this dependency so a attribute closure
12:05 - of a will contain all the attributes of
12:07 - the relation so a is definitely a super
12:09 - key now a super key I cannot discard
12:11 - anything else because it is an our
12:12 - single attribute right now definitely
12:15 - that would be a candidate key so now
12:17 - candidate these are first of all if we
12:19 - got one candidate key prime attribute we
12:22 - got a in a part of candidate key those
12:26 - attribute which are part of candidate
12:27 - key are known as primary now check is a
12:31 - this primary will present on the right
12:33 - hand side of any functional dependency
12:34 - if yes then there would be more
12:36 - candidate keys here we have a see this
12:39 - dependency can be splitted into bc
12:41 - determine ABC determine C BC determine e
12:44 - because of that splitting property so bc
12:47 - determine a right right hand side we
12:49 - have a so at the place of a in the
12:51 - existing candidate here I can replace it
12:53 - with BC right bc at the place of me but
12:58 - bc we cannot say that still less
12:59 - candidate unit to check out now B is
13:03 - proper subset and C is proper subset
13:05 - find out that reboot closure of B and C
13:07 - is B determining all that tribute being
13:10 - determining be nothing else because here
13:13 - both bc will later mine a sea but we
13:14 - have only B C is determining only see
13:17 - nothing else so this is not super key
13:20 - this is not super key so definitely
13:22 - see what Canada T now Prime a tribute r1
13:24 - is B 1 is C now check out B and C a
13:27 - prime attribute those are present on the
13:28 - right hand side of honey this dependency
13:31 - or not yes here we have C right but
13:35 - definitely we will replace the C this is
13:38 - or trivial functional dependency so if
13:40 - you replace the C with BC then that
13:43 - would be same right here we have C this
13:46 - can be splitted a will determine be able
13:48 - determine C a will determine be able
13:50 - determind
13:51 - e for dependencies right by splitting
13:54 - property now at the place of B two cases
13:59 - can be there at the place of B I'm
14:01 - replacing a so first one a C now at the
14:05 - place of C I am replacing a so second
14:08 - one is B these are super easy but I
14:11 - cannot say that these are candidate
14:12 - he'll check out these cannot be
14:14 - candidate is why so because proper
14:16 - subset of this and this is what a and a
14:18 - itself is a super key so this cannot be
14:20 - candidate key this cannot be candidate
14:22 - key right so in this case we have only
14:24 - two candidate is a and B C 3 prime
14:27 - attributes are their non-prime
14:28 - attributes are D and E now check first
14:31 - of all first of all we will check for
14:33 - the highest normal form that is for bcnf
14:38 - right it's better to check for the
14:40 - highest normal form rather than starting
14:42 - from the second the lowest normal form
14:45 - right if this type of questions are you
14:47 - so for each functional dependency we
14:49 - will check the rules first one is this
14:51 - one a is super key or not because this
14:55 - is the main condition right a super key
14:58 - yes so this is satisfying the bcnf
15:00 - property B C is super key yes because BC
15:04 - is candidate key definitely it is a
15:05 - super game is do a super key no even D
15:10 - is not a prime attribute and if still
15:12 - you want to check then you can find out
15:14 - the D closer
15:15 - if D closer contains all the attributes
15:18 - then that would be super key but D
15:19 - closer contains only D and E nothing
15:23 - else you can try by D and E so this is
15:26 - not a super key so thus because of this
15:28 - property this property is volatile the
15:30 - bcnf
15:31 - rules so this is not in bcnf
15:34 - now find out
15:35 - : see if this functional dependency
15:40 - satisfying the bcnf property definitely
15:41 - it would be throwing it and third and if
15:44 - no need to check right because for busy
15:47 - and if that dependency should be in
15:49 - third in if right so that is for sure
15:52 - that these and these would satisfy third
15:55 - and if rules you just need to check out
15:57 - this one for this one d to e is this
16:01 - transitive dependency or not because
16:03 - third is an F we will check in third and
16:05 - if you'll check transitive dependency
16:06 - means in that case check out left hand
16:11 - side is what it's super ly no you cannot
16:14 - say that this is royal it incurred in F
16:16 - or right hand side is prime attribute to
16:19 - condition at least one should be
16:21 - satisfied not both so is a prime
16:23 - attribute no so now you can say that
16:26 - this is not satisfying third in F
16:28 - property or it now another term you can
16:31 - say NPA determines NP non-prime
16:33 - attribute B is non-prime attribute yes
16:35 - is non-prime attribute yes so this is
16:38 - transitive dependency so this is not
16:40 - satisfying the property of third and if
16:41 - not check for second in F partial
16:44 - dependency so this isn't third so
16:46 - definitely in second definitely it would
16:47 - be in second check out for this one
16:49 - right if you are not satisfied with this
16:52 - answer that this would be definitely in
16:54 - second and if then you can check right
16:56 - you'll find out that these this and this
16:58 - are in second in it check out for this
17:00 - one second and it will check for partial
17:02 - dependency partial dependency is there
17:04 - it is not satisfying that property right
17:06 - if this is partial dependency then that
17:07 - is not in second in F partial dependency
17:10 - is what proper subset of candidate he
17:13 - will determine non-prime attribute right
17:16 - now is the proper subset of candidate
17:18 - key candidate here a and BC proper
17:22 - subset is obviously there is no proper
17:24 - subset of a proper subset of B C is B
17:26 - and C D is not a proper subset of any
17:27 - candidate key so no need to check the
17:29 - right hand side right because left hand
17:32 - side should be proper subset of
17:33 - candidate key right so this is not
17:37 - proper subset of candidate key so you
17:40 - can see that this is not partial
17:41 - dependency if it is not partial
17:43 - dependency then you can say that it is
17:46 - in second normal form
17:49 - I hope you are getting my point right
17:50 - for this video you must check out the
17:52 - first second third normal form videos so
17:55 - you can check out those videos in the
17:56 - description box I'll provide you the
17:57 - complete you know link of that complete
17:59 - playlist of DBMS in description box so
18:02 - you can see that now the highest normal
18:04 - form of this relation is second NL right
18:09 - let's take one more example so let's
18:11 - take this example and check out the
18:12 - highest normal form in this relation for
18:15 - that you need to find out the candidate
18:17 - keys how to find out candidate keys they
18:20 - call the attribute of the relation
18:21 - definitely the closure would contain all
18:22 - that tribute so this is what super key
18:24 - now try to discard attributes how to
18:27 - discard check the functional dependency
18:29 - a B will determine C D so I have a B so
18:31 - I can discard CD they determine a but I
18:33 - you don't have D so I cannot discard
18:35 - anything so I have now a B may be super
18:37 - key if you still want to find out you
18:39 - can find out a be closer maybe closer
18:41 - will have a B reflexivity property and
18:44 - if you have a B then you can determine C
18:46 - D so it is having all the attributes so
18:48 - a B is what super key now edit that is
18:51 - that candidate key or not find out the
18:53 - proper subset one is a one is be closer
18:56 - of a is a only closure of B is B only so
19:02 - it is not super it is not super so you
19:04 - can say that now a B is candidate key
19:07 - because no proper subset is super you
19:09 - know a B is candidate if you go to one
19:11 - candidate key right so now we got prime
19:14 - attributes that is a and B now check out
19:18 - prime attributes are present on the
19:20 - right hand side of any functional
19:21 - dependency or not yes here we have a so
19:24 - now at the place of a in the existing
19:26 - candidate key I can replace D so now I
19:29 - go to B B but I cannot say that it is
19:33 - candidate key you have to find it out
19:35 - but I can say that it is super he so I
19:37 - have to find it out the closure of it is
19:40 - sorry this proper subset is d when is B
19:43 - find out closer of be closer of B but
19:46 - already we have found out B is not super
19:49 - key now closure of D using D I can find
19:52 - out D and a nothing else so it is also
19:56 - not super key so now you can say that B
19:59 - D is also a candidate e so now prime
20:01 - attribute is
20:02 - would be one more prime attribute we got
20:06 - in Kanto city find out see here we have
20:09 - prime attribute would be these present
20:11 - on the right hand side of this
20:13 - dependency right by splitting I can say
20:15 - that a be determine D only they only see
20:19 - only e so on the place of B I can
20:21 - replace it with a B so if you replace it
20:23 - with a B then we have already discussed
20:25 - that a B is a candidate key no need to
20:27 - replace right so now no more candidate
20:30 - these are their two candidate either
20:32 - they're a b and b d now find out first
20:36 - of all you will check for high years to
20:37 - thatis bcnf is it in bcnf or not for
20:42 - each functional dependency check out the
20:43 - rules for bcnf definitely obviously will
20:47 - check that that condition that the left
20:48 - hand side must be super the left hand
20:51 - side of this dependency is a b is a be
20:53 - super key a b's candidate fee definitely
20:56 - it is super gay so yes it is satisfying
20:58 - the property is the super key is d c DS
21:04 - DB is candidate key right so how a loan
21:08 - deal can be super key and if you still
21:10 - want to find out then you can find out
21:12 - the attribute closer of D at a bit
21:15 - closer over here we already discussed it
21:17 - is only da not containing all the
21:18 - attributes or D cannot be super key we
21:20 - have already discussed right so now this
21:23 - is violating the property of bcnf
21:25 - because left hand side is not super key
21:26 - now check for third NF if this is NBC
21:30 - NFL definitely definitely this
21:32 - functional dependency will satisfy the
21:35 - rule of third NF right it is not it is
21:37 - not a transitive dependency right
21:39 - because obviously for bcnf that relation
21:42 - should be three NF and if this
21:45 - functional dependency is satisfying the
21:47 - property of bc anything by default you
21:49 - can say that it is in 3 NF right if you
21:51 - still want to check you in check out
21:53 - they will check out for this one only D
21:55 - determines a is a transitive dependency
21:58 - because 3 NF in 3 and F we deal with
22:00 - transitive dependency so what is trying
22:03 - to transitive dependency this one how we
22:06 - will check either left-hand side is
22:09 - super key or right hand side is Prime a
22:10 - tribute then you can say that that is in
22:13 - third and if that is satisfying the
22:14 - rules of third in it
22:15 - left-hand side is super key know so we
22:19 - have checked for one condition
22:20 - but check out for a second is this one
22:24 - right hand side prime attribute yes is
22:27 - prime attribute right so this is
22:30 - satisfying the property of three n the
22:33 - rules of 3 NF this is not a transitive
22:35 - dependency in another term you can say
22:38 - what is transitive dependency non-prime
22:40 - attribute determining non-prime
22:43 - attribute but this is what a prime
22:45 - attribute not a non-prime attribute
22:46 - right so it is in 3 NF but it is not in
22:50 - bcnf so definitely it would be in second
22:52 - and ifs in highest normal form of this
22:54 - relation is 3 NF and you will find a
22:59 - rare case in which a relation is in 3 NF
23:01 - but not in bcnf because almost every
23:03 - relation which is in 3 NF will be in
23:05 - bcnf right so this is one of that case
23:10 - when this is in 3 in it but not in bcnf
23:12 - so this is all about bcnf normal form
23:15 - how to find out that a particular
23:17 - relation is in bcnf or not right so we
23:20 - also discussed some practice questions
23:22 - like this also will they will take one
23:25 - relation and we'll discuss the highest
23:27 - normal form we'll find out the highest
23:28 - normal form in that relation write some
23:31 - complicated type of questions in the
23:32 - next video right and also we'll take one
23:36 - table and with the help of that table
23:39 - will not take these type of relation we
23:41 - will take a proper table with some data
23:42 - and we'll find out that particular
23:44 - relation particular table is in that
23:47 - desirable normal form or not right so
23:50 - now I'll see in the next video till then
23:51 - nobody take here

Cleaned transcript:

so far in this lecture series of DBMS we have discussed first second and third normal form right what is the basic idea of these those normal forms means what are the rules and regulations for a relation to be in first second and third normal form right and we have also discussed that a particular this type of relation would be given functional dependencies would be given and you have to identify that the particular given relation is in you can say in first second or third normal form or not right using those rules we haven't discussed that if relation is not in second normal form then how to convert it into second normal form means how to decompose that relation fine first of all you will discuss the basic idea of all the normal forms so in this video I will discuss what is bcnf now what are the drawbacks and the second in normal form and because of those drawbacks the concept of third normal form came into picture that also we have discussed in the previous video right but still we have some drawbacks in third normal form it sometimes see I have told you in the previous video that if your database design your relational schema is in third NF then you can say that it is a good database design right but sometimes still because at some cases still there are some redundancy if your table is in third normal form but still there is some redundancy exists in that table and because of that you can get some anomalies right when this type of problem comes because third and if you know it's not able to handle the cases when you have multiple candidate keys and all the candidate keys are overlapping or you can say we have multiple overlapping candidate Keys like this suppose in our relation we have one candidate is a B second is BC next you can say DC like this see this and this is overlapping candidate key is here also see here also see here B here we have B so when these kind of cases exist then third normal form cannot handle these type of cases right to handle these type of cases we have bcnf we cannot say that it is fourth normal form right it is you can say that a stronger version of third normal form where you can say advanced version of 3nf and why it is known as Boyce Codd normal form because it was developed by EF code and Raymond F boys that is why it is known as Boyce Codd normal form it is not fourth normal form right remaining four second or third normal form was developed by EF code only see he's known as father of DBMS right now why this is more strict than third normal form let us discuss that what are the rules for a relation what are the requirements for a relation to be in bcnf and after that we will discuss with the help of two or three examples that something this this type of question would be given and you have to tell this as in bcnf or not and we will also see with one example that you have to tell the highest normal form exist in that relation whether its second third or bcnf right and after this video we will discuss what is the composition and after that we will discuss if a particular relation is not in a desired normal form then how to decompose that relation how to convert that relation into desired a normal phone so the rules are you can say our relation is in bcnf if and only if first one is it is in third and if right second rule is there for each nontrivial functional dependency see I'm talking about known trivial functional dependency not trivial right in the third normal form also we have discussed the rules on known real functional dependency right and by default by default we assume that all the this this relation given is in first normal form plus these dependencies given are in you can say non trivial because we we usually take those kind of dependencies that are known trivial right so second rule is for each known trivial functional dependency the lefthand side of the dependency must be super or you can say that determinant must be super key let me write down these rules so these are two rules it is in third and F second is this one for each nontrivial functional dependency I have discussed what is trivial what is known to your functional dependency suppose is x2y right then X the lefthand side of the dependency must be super key so it is very easy to check if a particular relation is in bcnf or not just you have to find out the super keys or if you don't want to find out all the super keys then you can go for each dependency and you can check a super key or not be a super key or not and see is super cure not and how to check that particular attribute or particular key is a super key or not just find out to find out the closer attribute closer and if attribute closer contains all the attributes of a given relation then that is what a super key right so let's check this relation is in bcnf or not find C so here I will not simply check that this is super key or not this is super cure not or this is super cure note because obviously they'll give you these type of questions and get in it they'll give you a particular relation functional dependencies and they'll ask the highest normal form exists in this relation so for that obviously you need to check for third also and second also and for those normal forms you need to find out the candidate keys so let's find out the candidate keys first of all after that we will check how to find out candidate he's C take the ol attributes take the closer and definitely that would find out all that tribute of the relation so you can say that this is a super key now find out candidate is you discard as many elements as many attributes as you can because can it he wrote a minimal superkey check out the functional dependencies how to discard check out functional dependency see a determined B it means I have a so I can discard B because using a I can determine a and as well as if you have a you can determine B right and it will later mind see it is still having all the attributes so this is what's still a super key now can you discard anything else a determined B be determined C it means a will determine C by transitivity property so you can discard C so here I am left with only a now a is what super key obviously we are not going to discard anything else because it is single attribute single attribute this will attribute closer will contain all that good so it is so foggy now check it as candidate here not definitely it would be why because it is containing a single attribute and no proper subset would be possible if no proper subset is possible then there is no chance that the proper subset of this would be a super key so that is why it is a candidate key so if a is candidate key then prime attribute we got a now how to check that still more super candidate keys are present in this relation or not if prime attributes are present on the right hand side of any functional dependency I have already discussed this trick in the previous video you can check out that video in the cyber turn then there would be more candidate here so check out prime attribute is a is a present on the right hand side of any functional dependency yes here so you can replace this a with C in candidate he can read he is a so you can replace it with C but we cannot say that still it is a candidate key you have to find it out it is super key that thing I can definitely see now how could a proper subset of C is possible no so if no proper subset is there then definitely that would be an innately so we go to candidate key a and C prime attribute a and C check again C is now prime a tribute now C is present on the right hand side of this functional dependency so you can replace this C with B I am replacing this with B now B is super key find out it is candidate or not yes single attribute yes definitely that would be candidate key prime a tribute is B now you can say B is present on the right hand side of this so you could replace this B with a but we have already check is can it get key right so now we have got all the candidate keys that is one is a B and C prime attribute are a B and C right see all that we do is our prime attributes' now you check this is in bcnf or not now check for each dependency C first of all it is in third and if it should be in third and if so this is in third and if I have taken this kind of example that it is already in third and if right and if you want to check the new can check there would be no transitive dependency because all the attributes are prime attributes and positive dependency is what nonprime attribute determining nonprime attribute right or another in another words you can say first either lefthand side is super key or right hand satisfy my tribute write if any of these to condition holds for each functional dependency you can say that this then you can say that there is no transitive dependency and that relation is in third in F right now there would be no nonprime attribute because all are prime so that would definitely be in third and F check for bcnf this is true now for each nontrivial functional dependency these three are nontrivial functional dependency X must be super key check this lefthand side must be super key is a super key yes so first is what according to first it is in bcnf not check this is violating the rule of bcnf or not is being super key yes B is candidate key definitely it would be super key yes you see super key C is candidate key definitely it is a super key so yes means each functional dependency is satisfying the requirement of bcnf right so you can say that this relation is in bcnf see why we are saying that it is more strict than third and F because in third and F we have what rules either lefthand side is super key or right hand side is prime attribute then find that would be in third and if right but here definitely the lefthand side you can say the lefthand side must be super key right no other condition is there this must be satisfied so that is why we are saying that it is a and you can say more strict origin of 3nf because 3 and F doesn't deal these kind of condition like if a nonprime attribute is determining a prime attribute then according to thordan f it is not a transitive dependency B why so because right hand side is prime attribute so it is not going to do these kind of cases a nonprime attribute is determining a prime attribute because of this dependency there would be some problem right but here in this case this left hand side must be super clean but here it is not a super key so it will not allow these kind of dependency here right and what about second normal form this will the second normal form deal with these type of cases right if Prime tribute is determining a nonprime attribute cprime attribute means it should be a proper subset of candidate he it's not like that it is a proper candidate key it should be a proper subset of candidate key then it will lower late the condition of second in it right so now you have the idea of all the normal forms for second third bcnf now i will discuss with one example and i will give you one example and we will discuss that what is the highest normal form given in that relation right see let us take this example and find out the highest normal form of this relation see so for this first of all we need to find out the candidate is all the candidate is how to find out candidate keys first of all take all the attributes of this relation closer obviously will contain all that tribute so this is super key now try to discard is remaining BCDE so I have a so using a I can determine a itself plus B CBE using this dependency so a attribute closure of a will contain all the attributes of the relation so a is definitely a super key now a super key I cannot discard anything else because it is an our single attribute right now definitely that would be a candidate key so now candidate these are first of all if we got one candidate key prime attribute we got a in a part of candidate key those attribute which are part of candidate key are known as primary now check is a this primary will present on the right hand side of any functional dependency if yes then there would be more candidate keys here we have a see this dependency can be splitted into bc determine ABC determine C BC determine e because of that splitting property so bc determine a right right hand side we have a so at the place of a in the existing candidate here I can replace it with BC right bc at the place of me but bc we cannot say that still less candidate unit to check out now B is proper subset and C is proper subset find out that reboot closure of B and C is B determining all that tribute being determining be nothing else because here both bc will later mine a sea but we have only B C is determining only see nothing else so this is not super key this is not super key so definitely see what Canada T now Prime a tribute r1 is B 1 is C now check out B and C a prime attribute those are present on the right hand side of honey this dependency or not yes here we have C right but definitely we will replace the C this is or trivial functional dependency so if you replace the C with BC then that would be same right here we have C this can be splitted a will determine be able determine C a will determine be able determind e for dependencies right by splitting property now at the place of B two cases can be there at the place of B I'm replacing a so first one a C now at the place of C I am replacing a so second one is B these are super easy but I cannot say that these are candidate he'll check out these cannot be candidate is why so because proper subset of this and this is what a and a itself is a super key so this cannot be candidate key this cannot be candidate key right so in this case we have only two candidate is a and B C 3 prime attributes are their nonprime attributes are D and E now check first of all first of all we will check for the highest normal form that is for bcnf right it's better to check for the highest normal form rather than starting from the second the lowest normal form right if this type of questions are you so for each functional dependency we will check the rules first one is this one a is super key or not because this is the main condition right a super key yes so this is satisfying the bcnf property B C is super key yes because BC is candidate key definitely it is a super game is do a super key no even D is not a prime attribute and if still you want to check then you can find out the D closer if D closer contains all the attributes then that would be super key but D closer contains only D and E nothing else you can try by D and E so this is not a super key so thus because of this property this property is volatile the bcnf rules so this is not in bcnf now find out see if this functional dependency satisfying the bcnf property definitely it would be throwing it and third and if no need to check right because for busy and if that dependency should be in third in if right so that is for sure that these and these would satisfy third and if rules you just need to check out this one for this one d to e is this transitive dependency or not because third is an F we will check in third and if you'll check transitive dependency means in that case check out left hand side is what it's super ly no you cannot say that this is royal it incurred in F or right hand side is prime attribute to condition at least one should be satisfied not both so is a prime attribute no so now you can say that this is not satisfying third in F property or it now another term you can say NPA determines NP nonprime attribute B is nonprime attribute yes is nonprime attribute yes so this is transitive dependency so this is not satisfying the property of third and if not check for second in F partial dependency so this isn't third so definitely in second definitely it would be in second check out for this one right if you are not satisfied with this answer that this would be definitely in second and if then you can check right you'll find out that these this and this are in second in it check out for this one second and it will check for partial dependency partial dependency is there it is not satisfying that property right if this is partial dependency then that is not in second in F partial dependency is what proper subset of candidate he will determine nonprime attribute right now is the proper subset of candidate key candidate here a and BC proper subset is obviously there is no proper subset of a proper subset of B C is B and C D is not a proper subset of any candidate key so no need to check the right hand side right because left hand side should be proper subset of candidate key right so this is not proper subset of candidate key so you can see that this is not partial dependency if it is not partial dependency then you can say that it is in second normal form I hope you are getting my point right for this video you must check out the first second third normal form videos so you can check out those videos in the description box I'll provide you the complete you know link of that complete playlist of DBMS in description box so you can see that now the highest normal form of this relation is second NL right let's take one more example so let's take this example and check out the highest normal form in this relation for that you need to find out the candidate keys how to find out candidate keys they call the attribute of the relation definitely the closure would contain all that tribute so this is what super key now try to discard attributes how to discard check the functional dependency a B will determine C D so I have a B so I can discard CD they determine a but I you don't have D so I cannot discard anything so I have now a B may be super key if you still want to find out you can find out a be closer maybe closer will have a B reflexivity property and if you have a B then you can determine C D so it is having all the attributes so a B is what super key now edit that is that candidate key or not find out the proper subset one is a one is be closer of a is a only closure of B is B only so it is not super it is not super so you can say that now a B is candidate key because no proper subset is super you know a B is candidate if you go to one candidate key right so now we got prime attributes that is a and B now check out prime attributes are present on the right hand side of any functional dependency or not yes here we have a so now at the place of a in the existing candidate key I can replace D so now I go to B B but I cannot say that it is candidate key you have to find it out but I can say that it is super he so I have to find it out the closure of it is sorry this proper subset is d when is B find out closer of be closer of B but already we have found out B is not super key now closure of D using D I can find out D and a nothing else so it is also not super key so now you can say that B D is also a candidate e so now prime attribute is would be one more prime attribute we got in Kanto city find out see here we have prime attribute would be these present on the right hand side of this dependency right by splitting I can say that a be determine D only they only see only e so on the place of B I can replace it with a B so if you replace it with a B then we have already discussed that a B is a candidate key no need to replace right so now no more candidate these are their two candidate either they're a b and b d now find out first of all you will check for high years to thatis bcnf is it in bcnf or not for each functional dependency check out the rules for bcnf definitely obviously will check that that condition that the left hand side must be super the left hand side of this dependency is a b is a be super key a b's candidate fee definitely it is super gay so yes it is satisfying the property is the super key is d c DS DB is candidate key right so how a loan deal can be super key and if you still want to find out then you can find out the attribute closer of D at a bit closer over here we already discussed it is only da not containing all the attributes or D cannot be super key we have already discussed right so now this is violating the property of bcnf because left hand side is not super key now check for third NF if this is NBC NFL definitely definitely this functional dependency will satisfy the rule of third NF right it is not it is not a transitive dependency right because obviously for bcnf that relation should be three NF and if this functional dependency is satisfying the property of bc anything by default you can say that it is in 3 NF right if you still want to check you in check out they will check out for this one only D determines a is a transitive dependency because 3 NF in 3 and F we deal with transitive dependency so what is trying to transitive dependency this one how we will check either lefthand side is super key or right hand side is Prime a tribute then you can say that that is in third and if that is satisfying the rules of third in it lefthand side is super key know so we have checked for one condition but check out for a second is this one right hand side prime attribute yes is prime attribute right so this is satisfying the property of three n the rules of 3 NF this is not a transitive dependency in another term you can say what is transitive dependency nonprime attribute determining nonprime attribute but this is what a prime attribute not a nonprime attribute right so it is in 3 NF but it is not in bcnf so definitely it would be in second and ifs in highest normal form of this relation is 3 NF and you will find a rare case in which a relation is in 3 NF but not in bcnf because almost every relation which is in 3 NF will be in bcnf right so this is one of that case when this is in 3 in it but not in bcnf so this is all about bcnf normal form how to find out that a particular relation is in bcnf or not right so we also discussed some practice questions like this also will they will take one relation and we'll discuss the highest normal form we'll find out the highest normal form in that relation write some complicated type of questions in the next video right and also we'll take one table and with the help of that table will not take these type of relation we will take a proper table with some data and we'll find out that particular relation particular table is in that desirable normal form or not right so now I'll see in the next video till then nobody take here
