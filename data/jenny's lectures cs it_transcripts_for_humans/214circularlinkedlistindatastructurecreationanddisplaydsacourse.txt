With timestamps:

00:00 - linked the list and data structure fine
00:01 - so I will provide you the link of that
00:03 - playlist in the description box as well
00:04 - as in this I button and this playlist is
00:07 - containing all the videos of linked
00:09 - lists fine so now first of all what is a
00:12 - circular linked list see this is what
00:15 - you can see a singly linked list fine
00:18 - having four nodes each node is having
00:21 - two parts one is data part one is
00:22 - address part and this part of this
00:24 - pointer is containing address of the
00:26 - next node that is address of Nyx notice
00:28 - 150 right here 300 here hundred right
00:33 - see it's not compulsory that the
00:35 - addresses would be in ascending order or
00:36 - descending order any random address any
00:38 - random location can be you know
00:40 - dynamically allocated to these nodes
00:42 - right and we have a head pointer head is
00:44 - containing address of the first node
00:46 - right now to make it a circular linked
00:50 - list you just have to change it a little
00:53 - bit and what does that change see in the
00:58 - last node see the pointer is containing
01:01 - 0 null it means it is not pointing to
01:04 - any node now for to make it a circular
01:07 - list what we will do here we will store
01:10 - address of the first node now address of
01:14 - the first node is 200 so here we will
01:18 - write 200 it means this is now pointing
01:22 - to first node in the list to make it a
01:26 - circle and as you can see this is now a
01:29 - circle so this has a circular linked
01:33 - list right in this list we cannot say
01:36 - which is the last node because see this
01:39 - was the last node because it was having
01:42 - here null but here we have the address
01:45 - of the first node so it is a circle like
01:47 - this in a circle we cannot say from
01:50 - where the circle is going to start and
01:51 - where the circle is going to the end
01:53 - right so now see how to implement this
01:57 - linked list to this circular linked list
01:59 - how to create the linked list and how to
02:01 - display the content of this linked list
02:03 - right it is same as singly linked list
02:06 - only one as the this difference you how
02:09 - to implement you have to change in that
02:11 - create function right so
02:13 - see how we will write that code same for
02:16 - this note how to represent this node
02:18 - same as we represent a singly linked
02:20 - list so this is how we are going to
02:22 - represent this node struct node we have
02:24 - defined our own datatype to parts are
02:26 - there data part and one is the next or
02:28 - you can say this is this pointer is next
02:30 - pointer which is containing address of
02:32 - the next node and I have declared one
02:35 - pointer also that is head pointer say
02:38 - this pointer is containing address of
02:39 - this node right if you don't write this
02:42 - like this you can write here semicolon
02:44 - on here you can write struct node with
02:47 - this data type as trick head head
02:49 - pointer and I hope everybody is aware
02:52 - about this thing while I am writing here
02:53 - struct node s trick next I have
02:56 - discussed it many times in the previous
02:58 - videos right because here see suppose if
03:00 - you write a strict P it means this is
03:03 - pointer to end this pointer is
03:06 - containing address of a variable and the
03:08 - ad√®le type of that variable is integer
03:10 - so here we will write what the address
03:13 - of that variable whose address this
03:15 - pointer is going to store so that is why
03:18 - here this next pointer this is going to
03:20 - store this address and this addresses of
03:23 - this node so datatype of this node is
03:25 - struct node we have already defined so
03:28 - that is why here I am writing the data
03:29 - type of that node that is struct node
03:31 - fine now now we will define a function
03:35 - how to create this linked list that is
03:37 - create a circular linked list fine it is
03:42 - same as singly linked list I have
03:43 - discussed the core for singly linked
03:45 - list in the previous video I all
03:47 - provided the link of that video in this
03:48 - I button you can check out there first
03:50 - of all we consider what the list is
03:51 - empty we don't have any node in the list
03:54 - so you can say head as what 0 head is
03:56 - equal to null so here I can write head
03:59 - is equal to 0 now insert these nodes
04:03 - first of all you have to create these
04:05 - nodes you have to dynamically allocate
04:07 - the memory to these nodes right
04:10 - obviously we are going to allocate the
04:11 - memory for storing this in busy type and
04:14 - data and this pointer variable fine
04:17 - so how me allocate the memory
04:18 - dynamically we are going to locate the
04:20 - memory I using malloc function in C and
04:22 - I hope you know the syntax of malloc
04:24 - function we have already discussed
04:26 - many times have you will write here we
04:29 - will basically write what that mallow
04:31 - keyword and in bracket we write size of
04:35 - size of a keyword how much size you want
04:38 - size for this node so here you write the
04:41 - data type of this node that is struct
04:43 - node right and my log is going to return
04:47 - what the the starting address pointer to
04:51 - the starting address of that allocated
04:53 - blow right see suppose initially we
04:55 - don't have anything in the list like
04:57 - this head is containing 0 and if you
04:59 - write the smell of my log means memory
05:01 - has been allocated how much memory for
05:03 - this truck node 4 bytes for this and 4
05:05 - bytes for this 4 bytes for this point
05:08 - that is 32 bit compiler and eight bytes
05:09 - in 64-bit compiler so now eight bytes 8
05:13 - bytes has been allocated this is the
05:15 - block of 8 bytes and suppose the address
05:17 - of this is the DOS of stacking byte is
05:19 - 200 right so this lock has been
05:22 - allocated now Milo will return what the
05:24 - pointer to this node you can say the
05:28 - address the pointer to the starting
05:30 - address of this node that is malik will
05:31 - return what this 200 so we are going to
05:33 - store this 200 fine
05:35 - so we are going to create another
05:38 - pointer we are going to declare another
05:40 - pointer you can say new node and in new
05:42 - node we are going to store this address
05:44 - but maillot basically returns what a
05:46 - void pointer and this pointer is what it
05:48 - is a pointer to node so you have to
05:51 - typecast this one whatever this malloc
05:54 - will return and have you will die
05:55 - typecast with this thing here you will
05:57 - write struct node s straight and now we
06:02 - can store this value in this point our
06:06 - new node pointer so here I can say now
06:10 - here I have a new node pointer and this
06:13 - is containing 200 means this is pointing
06:15 - to this node fine now we will ask from
06:18 - the user which data I want to insert
06:20 - using printf and scanf so this is how we
06:23 - can take input from the user using
06:25 - printf and scanf percent is d address
06:27 - off where I want to store that value
06:30 - suppose here 7 I want to store user has
06:33 - entered 7 so how we can access this part
06:35 - the name of this part is data we cannot
06:37 - directly
06:37 - the structure members we need a pointer
06:39 - pointer to this node is what a new node
06:42 - so address of new node arrow data this
06:46 - part I won't fix us so here the value is
06:48 - to be stored
06:49 - fine now initially we store here the
06:51 - pointer in the pointer we store
06:53 - what null so I can say how you can
06:56 - access this part the pointer is new node
06:58 - arrow and this name is next is equal to
07:01 - 0 now I want to insert this node into
07:05 - the list have you will insert because
07:06 - list is empty so now directly what you
07:10 - can do in head we will store what this
07:12 - 200 it means now head is pointing to
07:16 - this node now this is a list right so
07:19 - directly I can write here what head is
07:23 - equal to new node fine but this is not
07:28 - done that is fine if you insert first
07:30 - one node now if I want to insert a
07:32 - second node in that case suppose this is
07:35 - a node so now seek this now the new node
07:40 - would be pointing to this node suppose
07:41 - suppose address is 150 so now new node
07:44 - is going to store 150 new node is
07:47 - pointing to this node right and if I
07:49 - write here head is equal to new node
07:51 - means head is going to contain now 150
07:53 - so head this will this link would be
07:56 - broken and head will point to this node
07:57 - so we are going to lose a reference to
08:00 - this node and that we don't want right
08:03 - because obviously we want to insert
08:04 - second node fine so you cannot directly
08:08 - write this thing what we can write one
08:10 - condition if head is equal to is equal
08:15 - to null means if head is equal to 0 its
08:20 - starting if there is no node in the list
08:23 - that in that case head is equal to new
08:25 - node that is fine else what we can do
08:29 - now else means I'm going to 3 I have
08:32 - created the second node I have created
08:34 - this node new node I have store 150 and
08:37 - now I want to insert this node here so
08:41 - now what you have to do obviously here
08:43 - you will update what here I will store
08:45 - 150 after that only it is going to point
08:49 - here
08:50 - now how I can exist this part see
08:53 - pointer to this node is head head next
08:57 - so I can write here suppose head next is
09:02 - equal to new node but now this is also
09:08 - not correct right now this is fine we
09:11 - have inserted 150 here and now this is
09:13 - pointing to here now if I want to insert
09:15 - a third node in that case what happens
09:18 - now if head is equal to null but head is
09:21 - containing 200 so this condition is not
09:23 - true so control will go into else parts
09:24 - in else would we I have written head off
09:26 - next means head off next this part this
09:31 - part in this part we will we are going
09:33 - to store new node means new node after
09:35 - creating this node new node which would
09:37 - contain 300 right so now new node would
09:42 - point to this node so now head next Here
09:45 - I am going to store 300 it means you
09:48 - will lose this length and this node will
09:51 - directly link to this node so using this
09:57 - logic also you can insert only two nodes
09:59 - so this is not a correct logic now here
10:02 - what I will do see you have to take one
10:06 - another pointer that is 10 because we
10:09 - can know to move head for accessing in
10:12 - in this case after inserting two nodes
10:15 - I'm on pins are this one so I I'll put
10:18 - here rather than 0 I want to store here
10:22 - 300 so that I can establish a link to
10:24 - this tool but how I can access this part
10:28 - of this node because we don't have any
10:30 - pointer pointing to this node head is
10:33 - pointing to the first node new node is
10:35 - pointing to the newly created node so
10:37 - how we can access this node so we need
10:39 - to maintain another pointer you can set
10:41 - em so here you can have another pointer
10:46 - that is M right and if head is equal to
10:51 - is equal to null head is equal to new
10:53 - node for heroes here only we will store
10:56 - M also containing whatever the value in
11:00 - new node so afters
11:03 - inserting this first node we have one
11:06 - another pointer that is also having this
11:08 - 200 so this is also pointing to this
11:11 - node now I can move the step how I can
11:15 - do this see now in else part what I will
11:19 - write see suppose I have inserted this
11:22 - one and I want to insert this second
11:25 - node note third node I want to insert
11:28 - second node now how I can accept this
11:31 - part using temp we will use temple now
11:34 - because we cannot move this head so temp
11:37 - next so here I will write what temp off
11:40 - next is equal to here I want to store
11:44 - address of this node 150 from fair I can
11:47 - get 150 in new node point that we have
11:49 - 150 right and now here I have 150 so now
11:55 - this there is a link between the centers
11:58 - as well as we will do what in temp now
12:01 - we are going to store whatever they
12:04 - value in new node right so now in
12:08 - temples so we are having 150 so now MV
12:12 - is pointing to this node now see if you
12:16 - want to insert this third node in that
12:18 - case if part is not true so we are going
12:21 - in else part we are going to enter into
12:23 - else part in else part what will do temp
12:26 - next using temp which not I can access
12:29 - this node temp next means here here I
12:31 - will insert a new node so after creating
12:33 - this node now a new node I have address
12:37 - of this node right that is 300 so now
12:44 - here I will store 300 and temp is equal
12:48 - to new node so temp is containing
12:50 - whatever the value in new new node that
12:52 - is now 300 so now temp is pointing to
12:56 - this node and if you one want to insert
13:00 - fourth node that is also fine in else
13:02 - part temp next temp of next means this
13:04 - one here I will store whatever they
13:07 - value a new node a newly created node
13:09 - fine and after that we will move this
13:11 - temp right now suppose I I want us to
13:15 - stop here
13:17 - I don't want to insert any extra node
13:19 - now one more thing you have to do to
13:22 - make it a circular list here you will
13:24 - store what this address of this node
13:27 - fine
13:28 - so after this else part what you will
13:31 - write see how we can access this part
13:35 - the pointer to this node is you can say
13:38 - temp temp off next is equal to I want to
13:43 - store here this 200 from where I can get
13:46 - the side press in head we have 200 so
13:49 - here I can write head so now it is
13:52 - having 200 fine and now this this
13:58 - pointer this node is pointing to this
14:01 - one and now this is a circular linked
14:04 - list see as you can see so only this
14:07 - line you have to add in this code of
14:09 - singly linked list creation to make it a
14:11 - circular linked list and now you can
14:14 - write the same code you can write here
14:15 - printf you last from the user do you
14:17 - want to continue one to insert another
14:19 - node type one for continuation and a 0
14:21 - for X 0 and here you can write scanf %
14:24 - is d and address off one variable you
14:26 - can take that as choice and you can you
14:29 - can take here in this function only you
14:32 - can declare after this function you can
14:35 - initialize a variable choice is equal to
14:38 - 1 alright
14:40 - and if choice means if user press 1 it
14:44 - means a new node would be created
14:46 - another if again user press 1 another
14:50 - new one would be created it means these
14:52 - lines from this line because this is the
14:54 - line where dynamically this memory would
14:56 - be allocated means new node would be
14:57 - created so these lines would be in loop
15:00 - so here I can write before this line I
15:02 - can write wise choice
15:06 - and in the bracket fine so here you can
15:10 - write after this ends printf 1 press 1
15:12 - for continuation and 0 for exit so here
15:15 - a scanf you can add percentage the
15:16 - address of choice and after that you can
15:18 - close the while loop and you can close
15:19 - this function create CLE right this is
15:23 - how you can create a circular linked
15:24 - list the see this is not the only way to
15:26 - create
15:27 - circular link list sometimes somewhere
15:29 - you find out that they will maintain the
15:33 - last node note of the head node that is
15:36 - also fine you can maintain a last node
15:38 - means the tail node pointer to the tail
15:40 - node node the head node and see if you
15:43 - want to cross check that we have created
15:45 - a circular linked list or not then what
15:47 - you can do here after this printf and
15:50 - scanf after maybe this while loop you
15:52 - can do what you can print what see here
15:56 - this is the last node and after
15:57 - inserting three temp will be pointing to
15:59 - the last node right now temp is pointing
16:02 - to this node so in printf what you can
16:04 - print em next m p--
16:09 - next means this thing right 200 so 200
16:12 - means we have reached in this node and
16:15 - the data of this node is seven so again
16:18 - arrow and data so this should be printed
16:22 - one seven right it means we have created
16:27 - us as cooler linked list so now we will
16:29 - see how to display this circle of linked
16:31 - list so now for traversing this list
16:33 - from here to here or you can say for
16:35 - displaying the date obviously we need a
16:36 - pointer because we cannot move this head
16:38 - we need another pointer right so now
16:41 - this is the function where we are going
16:43 - to define this function and here I want
16:45 - to take another pointer that is M using
16:50 - temp we are going to traverse right here
16:52 - suppose I have M first of all what we
16:57 - will do if we will check if head is
17:00 - equal to is equal to null it means there
17:02 - is no node in the list so here you can
17:06 - write what printf list is empty right
17:11 - else in else part what you will write
17:16 - now see first of all we will point this
17:19 - temp to this node that is we are going
17:21 - to store 200 in this temp now from there
17:24 - I can get this 200 in head we have 200
17:26 - so here I will write what amp is equal
17:29 - to head so now you can print this data
17:32 - see this pointer is this node is having
17:35 - a pointer temp and head also but we will
17:37 - use time because
17:38 - move this temp temp off data so have you
17:40 - can print suppose it printf I can write
17:44 - what percentage D and temp data this is
17:49 - how you can access this part of this
17:51 - node camp and the name of this part is
17:53 - aro data part fine so now this will
17:55 - print what seven but now we want to
17:58 - print six own so then one also so now we
18:01 - have to use a loop and from will tell
18:04 - where I want to print till here so now
18:07 - in singly linked lists what we have done
18:08 - why attempt not equal to null because in
18:11 - that case here null it was the last
18:13 - pointer but here this is not a case here
18:15 - we don't have none so what condition you
18:17 - will write in while loop so before this
18:20 - time before printing what you will write
18:21 - you write a while loop while now the
18:24 - condition is what C I can write what
18:27 - then I can write a condition on this
18:29 - part here we have 200 and 200 is what
18:33 - address of this first node it means we
18:35 - have raised to the last node if I write
18:37 - here 200 fine so you need to write
18:40 - something like this
18:41 - so suppose at some time tampering is 2
18:43 - here so I can write em next not equal to
18:49 - head because head is containing the head
18:51 - rest not equal to head well then we are
18:56 - going to print this and after printing
18:59 - will do what we will move this temp temp
19:01 - is equal to temp off next now here also
19:06 - one problem is there see what is that
19:08 - problem and starting while temp is equal
19:11 - to head means 200 while temp next not
19:13 - equal to head temp of next is 150 and in
19:16 - head we have 200 so this condition is
19:18 - true fine so we will enter into this
19:20 - loop and will print temp of data temp of
19:23 - data means 7 would be printed right now
19:25 - temp is equal to temp next in temp we
19:28 - have temp next temp next we have in
19:31 - Terminix we have 150 so here we are
19:33 - going to store now 150 so now temp is
19:36 - pointing to this node 150 again my loop
19:39 - temp next what is temp next that is 300
19:42 - 300 not equal to head yes condition is
19:45 - true again will enter to enter into this
19:47 - loop we will print template a template
19:50 - that means
19:50 - we'll be printed again temp will be
19:52 - moved Tampa next is having 300 so now
19:55 - temp is having 300 so now temp is
19:57 - pointing to this node now again while
19:59 - loop temp next not equal to head now
20:01 - what is temp of next temp is pointing to
20:04 - this node and next part is this one that
20:06 - is 200 but 200 not equal to 200 so this
20:10 - condition is not true now fine so we
20:13 - cannot intend to this loop because in
20:14 - temp next we have 200 so now we are
20:17 - going to do what we are going to exit
20:21 - from this loop right but now we have
20:23 - printed only 7 and 6 1 I want to print
20:26 - right and using this I cannot print this
20:29 - thing so after this you will write one
20:31 - more line that has printf percentage be
20:34 - how you can print this one because temp
20:36 - is pointing to this node after this
20:38 - while loop so here I can write temp of
20:41 - data temp data means 1 would be printed
20:46 - here right so after this while loop you
20:49 - will read one more line to display all
20:51 - the content of this list so this is how
20:54 - we are going to display you are going to
20:55 - traverse you can say the circular linked
20:58 - list only one difference is there only
21:00 - one difference this was and second one
21:01 - is in the while loop we are going to
21:03 - change the condition we cannot write
21:04 - down that condition of null because we
21:06 - don't have null in the circular linked
21:09 - list right somewhere you will find out
21:11 - that they will maintain only the last
21:12 - node and using the last node they will
21:14 - traverse the list so that also will
21:16 - discuss later in the videos so this is
21:18 - all about how to traverse a circular
21:20 - linked list and how to create a circular
21:22 - linked list so in next video we will see
21:24 - how to insert a data in a circular
21:26 - linked list so I'll see you in the next
21:28 - video till then bye-bye take

Cleaned transcript:

linked the list and data structure fine so I will provide you the link of that playlist in the description box as well as in this I button and this playlist is containing all the videos of linked lists fine so now first of all what is a circular linked list see this is what you can see a singly linked list fine having four nodes each node is having two parts one is data part one is address part and this part of this pointer is containing address of the next node that is address of Nyx notice 150 right here 300 here hundred right see it's not compulsory that the addresses would be in ascending order or descending order any random address any random location can be you know dynamically allocated to these nodes right and we have a head pointer head is containing address of the first node right now to make it a circular linked list you just have to change it a little bit and what does that change see in the last node see the pointer is containing 0 null it means it is not pointing to any node now for to make it a circular list what we will do here we will store address of the first node now address of the first node is 200 so here we will write 200 it means this is now pointing to first node in the list to make it a circle and as you can see this is now a circle so this has a circular linked list right in this list we cannot say which is the last node because see this was the last node because it was having here null but here we have the address of the first node so it is a circle like this in a circle we cannot say from where the circle is going to start and where the circle is going to the end right so now see how to implement this linked list to this circular linked list how to create the linked list and how to display the content of this linked list right it is same as singly linked list only one as the this difference you how to implement you have to change in that create function right so see how we will write that code same for this note how to represent this node same as we represent a singly linked list so this is how we are going to represent this node struct node we have defined our own datatype to parts are there data part and one is the next or you can say this is this pointer is next pointer which is containing address of the next node and I have declared one pointer also that is head pointer say this pointer is containing address of this node right if you don't write this like this you can write here semicolon on here you can write struct node with this data type as trick head head pointer and I hope everybody is aware about this thing while I am writing here struct node s trick next I have discussed it many times in the previous videos right because here see suppose if you write a strict P it means this is pointer to end this pointer is containing address of a variable and the ad√®le type of that variable is integer so here we will write what the address of that variable whose address this pointer is going to store so that is why here this next pointer this is going to store this address and this addresses of this node so datatype of this node is struct node we have already defined so that is why here I am writing the data type of that node that is struct node fine now now we will define a function how to create this linked list that is create a circular linked list fine it is same as singly linked list I have discussed the core for singly linked list in the previous video I all provided the link of that video in this I button you can check out there first of all we consider what the list is empty we don't have any node in the list so you can say head as what 0 head is equal to null so here I can write head is equal to 0 now insert these nodes first of all you have to create these nodes you have to dynamically allocate the memory to these nodes right obviously we are going to allocate the memory for storing this in busy type and data and this pointer variable fine so how me allocate the memory dynamically we are going to locate the memory I using malloc function in C and I hope you know the syntax of malloc function we have already discussed many times have you will write here we will basically write what that mallow keyword and in bracket we write size of size of a keyword how much size you want size for this node so here you write the data type of this node that is struct node right and my log is going to return what the the starting address pointer to the starting address of that allocated blow right see suppose initially we don't have anything in the list like this head is containing 0 and if you write the smell of my log means memory has been allocated how much memory for this truck node 4 bytes for this and 4 bytes for this 4 bytes for this point that is 32 bit compiler and eight bytes in 64bit compiler so now eight bytes 8 bytes has been allocated this is the block of 8 bytes and suppose the address of this is the DOS of stacking byte is 200 right so this lock has been allocated now Milo will return what the pointer to this node you can say the address the pointer to the starting address of this node that is malik will return what this 200 so we are going to store this 200 fine so we are going to create another pointer we are going to declare another pointer you can say new node and in new node we are going to store this address but maillot basically returns what a void pointer and this pointer is what it is a pointer to node so you have to typecast this one whatever this malloc will return and have you will die typecast with this thing here you will write struct node s straight and now we can store this value in this point our new node pointer so here I can say now here I have a new node pointer and this is containing 200 means this is pointing to this node fine now we will ask from the user which data I want to insert using printf and scanf so this is how we can take input from the user using printf and scanf percent is d address off where I want to store that value suppose here 7 I want to store user has entered 7 so how we can access this part the name of this part is data we cannot directly the structure members we need a pointer pointer to this node is what a new node so address of new node arrow data this part I won't fix us so here the value is to be stored fine now initially we store here the pointer in the pointer we store what null so I can say how you can access this part the pointer is new node arrow and this name is next is equal to 0 now I want to insert this node into the list have you will insert because list is empty so now directly what you can do in head we will store what this 200 it means now head is pointing to this node now this is a list right so directly I can write here what head is equal to new node fine but this is not done that is fine if you insert first one node now if I want to insert a second node in that case suppose this is a node so now seek this now the new node would be pointing to this node suppose suppose address is 150 so now new node is going to store 150 new node is pointing to this node right and if I write here head is equal to new node means head is going to contain now 150 so head this will this link would be broken and head will point to this node so we are going to lose a reference to this node and that we don't want right because obviously we want to insert second node fine so you cannot directly write this thing what we can write one condition if head is equal to is equal to null means if head is equal to 0 its starting if there is no node in the list that in that case head is equal to new node that is fine else what we can do now else means I'm going to 3 I have created the second node I have created this node new node I have store 150 and now I want to insert this node here so now what you have to do obviously here you will update what here I will store 150 after that only it is going to point here now how I can exist this part see pointer to this node is head head next so I can write here suppose head next is equal to new node but now this is also not correct right now this is fine we have inserted 150 here and now this is pointing to here now if I want to insert a third node in that case what happens now if head is equal to null but head is containing 200 so this condition is not true so control will go into else parts in else would we I have written head off next means head off next this part this part in this part we will we are going to store new node means new node after creating this node new node which would contain 300 right so now new node would point to this node so now head next Here I am going to store 300 it means you will lose this length and this node will directly link to this node so using this logic also you can insert only two nodes so this is not a correct logic now here what I will do see you have to take one another pointer that is 10 because we can know to move head for accessing in in this case after inserting two nodes I'm on pins are this one so I I'll put here rather than 0 I want to store here 300 so that I can establish a link to this tool but how I can access this part of this node because we don't have any pointer pointing to this node head is pointing to the first node new node is pointing to the newly created node so how we can access this node so we need to maintain another pointer you can set em so here you can have another pointer that is M right and if head is equal to is equal to null head is equal to new node for heroes here only we will store M also containing whatever the value in new node so afters inserting this first node we have one another pointer that is also having this 200 so this is also pointing to this node now I can move the step how I can do this see now in else part what I will write see suppose I have inserted this one and I want to insert this second node note third node I want to insert second node now how I can accept this part using temp we will use temple now because we cannot move this head so temp next so here I will write what temp off next is equal to here I want to store address of this node 150 from fair I can get 150 in new node point that we have 150 right and now here I have 150 so now this there is a link between the centers as well as we will do what in temp now we are going to store whatever they value in new node right so now in temples so we are having 150 so now MV is pointing to this node now see if you want to insert this third node in that case if part is not true so we are going in else part we are going to enter into else part in else part what will do temp next using temp which not I can access this node temp next means here here I will insert a new node so after creating this node now a new node I have address of this node right that is 300 so now here I will store 300 and temp is equal to new node so temp is containing whatever the value in new new node that is now 300 so now temp is pointing to this node and if you one want to insert fourth node that is also fine in else part temp next temp of next means this one here I will store whatever they value a new node a newly created node fine and after that we will move this temp right now suppose I I want us to stop here I don't want to insert any extra node now one more thing you have to do to make it a circular list here you will store what this address of this node fine so after this else part what you will write see how we can access this part the pointer to this node is you can say temp temp off next is equal to I want to store here this 200 from where I can get the side press in head we have 200 so here I can write head so now it is having 200 fine and now this this pointer this node is pointing to this one and now this is a circular linked list see as you can see so only this line you have to add in this code of singly linked list creation to make it a circular linked list and now you can write the same code you can write here printf you last from the user do you want to continue one to insert another node type one for continuation and a 0 for X 0 and here you can write scanf % is d and address off one variable you can take that as choice and you can you can take here in this function only you can declare after this function you can initialize a variable choice is equal to 1 alright and if choice means if user press 1 it means a new node would be created another if again user press 1 another new one would be created it means these lines from this line because this is the line where dynamically this memory would be allocated means new node would be created so these lines would be in loop so here I can write before this line I can write wise choice and in the bracket fine so here you can write after this ends printf 1 press 1 for continuation and 0 for exit so here a scanf you can add percentage the address of choice and after that you can close the while loop and you can close this function create CLE right this is how you can create a circular linked list the see this is not the only way to create circular link list sometimes somewhere you find out that they will maintain the last node note of the head node that is also fine you can maintain a last node means the tail node pointer to the tail node node the head node and see if you want to cross check that we have created a circular linked list or not then what you can do here after this printf and scanf after maybe this while loop you can do what you can print what see here this is the last node and after inserting three temp will be pointing to the last node right now temp is pointing to this node so in printf what you can print em next m p next means this thing right 200 so 200 means we have reached in this node and the data of this node is seven so again arrow and data so this should be printed one seven right it means we have created us as cooler linked list so now we will see how to display this circle of linked list so now for traversing this list from here to here or you can say for displaying the date obviously we need a pointer because we cannot move this head we need another pointer right so now this is the function where we are going to define this function and here I want to take another pointer that is M using temp we are going to traverse right here suppose I have M first of all what we will do if we will check if head is equal to is equal to null it means there is no node in the list so here you can write what printf list is empty right else in else part what you will write now see first of all we will point this temp to this node that is we are going to store 200 in this temp now from there I can get this 200 in head we have 200 so here I will write what amp is equal to head so now you can print this data see this pointer is this node is having a pointer temp and head also but we will use time because move this temp temp off data so have you can print suppose it printf I can write what percentage D and temp data this is how you can access this part of this node camp and the name of this part is aro data part fine so now this will print what seven but now we want to print six own so then one also so now we have to use a loop and from will tell where I want to print till here so now in singly linked lists what we have done why attempt not equal to null because in that case here null it was the last pointer but here this is not a case here we don't have none so what condition you will write in while loop so before this time before printing what you will write you write a while loop while now the condition is what C I can write what then I can write a condition on this part here we have 200 and 200 is what address of this first node it means we have raised to the last node if I write here 200 fine so you need to write something like this so suppose at some time tampering is 2 here so I can write em next not equal to head because head is containing the head rest not equal to head well then we are going to print this and after printing will do what we will move this temp temp is equal to temp off next now here also one problem is there see what is that problem and starting while temp is equal to head means 200 while temp next not equal to head temp of next is 150 and in head we have 200 so this condition is true fine so we will enter into this loop and will print temp of data temp of data means 7 would be printed right now temp is equal to temp next in temp we have temp next temp next we have in Terminix we have 150 so here we are going to store now 150 so now temp is pointing to this node 150 again my loop temp next what is temp next that is 300 300 not equal to head yes condition is true again will enter to enter into this loop we will print template a template that means we'll be printed again temp will be moved Tampa next is having 300 so now temp is having 300 so now temp is pointing to this node now again while loop temp next not equal to head now what is temp of next temp is pointing to this node and next part is this one that is 200 but 200 not equal to 200 so this condition is not true now fine so we cannot intend to this loop because in temp next we have 200 so now we are going to do what we are going to exit from this loop right but now we have printed only 7 and 6 1 I want to print right and using this I cannot print this thing so after this you will write one more line that has printf percentage be how you can print this one because temp is pointing to this node after this while loop so here I can write temp of data temp data means 1 would be printed here right so after this while loop you will read one more line to display all the content of this list so this is how we are going to display you are going to traverse you can say the circular linked list only one difference is there only one difference this was and second one is in the while loop we are going to change the condition we cannot write down that condition of null because we don't have null in the circular linked list right somewhere you will find out that they will maintain only the last node and using the last node they will traverse the list so that also will discuss later in the videos so this is all about how to traverse a circular linked list and how to create a circular linked list so in next video we will see how to insert a data in a circular linked list so I'll see you in the next video till then byebye take
