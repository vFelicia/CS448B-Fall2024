With timestamps:

00:00 - so the topic is mergesort see we have
00:03 - already discussed quicksort so in
00:05 - quicksort the main idea was or you can
00:07 - say the backbone of that sorting
00:10 - technique is the partition method in
00:12 - merge sort the backbone of this
00:14 - technique is or the main front line this
00:16 - technique is merge processor okay so in
00:20 - this video I am going to discuss with
00:21 - you the working of this merge sort with
00:23 - help of an example and we are going to
00:25 - write down a piece of food for this
00:27 - sorting technique okay so this sorting
00:30 - techniques also works on divide and
00:32 - conquer technique as in quicksort
00:34 - technique fine now what is that
00:36 - technique in this case the complete area
00:39 - you can say the complete list is divided
00:41 - into sub lists fine or you can say the
00:44 - complete complete list is divided into n
00:47 - sub lists and each sub list is having
00:50 - one element or you can say will will
00:53 - keep on dividing the list into sub lists
00:55 - and till be cut and until we get the sub
00:58 - list having one element only fine after
01:03 - that we are going to merge the sub list
01:05 - and we will keep on merging the sub list
01:08 - fine
01:09 - to adjacent sub list you can say to
01:11 - produce a new sorted sub list and we'll
01:14 - keep on merging the sub list until big
01:17 - until we get one complete sub list and
01:21 - that sub list would be sorted sub list
01:24 - so the first step is dividing the given
01:27 - list into sub lists fine second step is
01:31 - merging of those sub lists to get a one
01:35 - complete sorted sub list
01:38 - sorry one complete sorted list so these
01:41 - are two steps main steps see let us take
01:44 - an example and see how this merge sort
01:46 - will work so let us take this example we
01:49 - are having this array array name is a we
01:53 - are having nine elements and these are
01:54 - the elements you are going to sort these
01:56 - elements in ascending order applying
01:58 - this merge sort so first step is we are
02:02 - going to divide this list or this array
02:04 - into two equal sub arrays fine equal sub
02:09 - arrays means you have to find out the
02:11 - position and you are going to divide
02:13 - this array from that mid position fine
02:17 - see how to find out a mid position 0 + 8
02:21 - C 0 is lower bound this one is your
02:23 - upper bound is 0 + 8 is 8 8 divided by 2
02:26 - that is 4 so 10 4 0 2 4 1 sublist is
02:32 - there like this you can write we are
02:34 - going to divide it into two sub lists 15
02:37 - 5 24 8 n 1 0 1 2 3 4 from 0 to 4 we are
02:47 - having 1 sub list and from 5 to 8 we are
02:54 - having another sub list 5 6 7 8
03:00 - like this ok still this this sub list is
03:06 - having in how many elements five
03:08 - elements but we are going to divide the
03:10 - sub list till we get a sub list having
03:12 - one element so we are further going to
03:16 - divide the sub list okay into two halves
03:20 - 0 + 4 that is 4 4 divided by 2 that is 2
03:24 - so my position is 2 from 0 to 2 15 5 +
03:29 - 24 this is 1 sub list and another sub
03:33 - list would be 8 + 1 from 0 1 2 here we
03:38 - have 3 to 4 right this will be again
03:43 - divided into two parts and 3 16 would be
03:47 - in one sub array and this 10 + 20 would
03:52 - be in another sub array
03:54 - fine again this list would be divided in
03:58 - two parts middle middle is 1 0 plus 2 is
04:01 - 2 2 divided by 2 that is 1 so 15 and 5
04:05 - this would be in one list and this 24
04:09 - would be in another list same this would
04:12 - be divided into two halves fine and this
04:16 - would be 8 and this would be one sub
04:18 - list will be having one element
04:20 - this would also be divided into two
04:21 - halves one is having one element three
04:23 - one is having one element sixteen here
04:26 - one is having element 10 and 1 is having
04:28 - element 20 now this one is having
04:32 - element 15 another is having element
04:35 - five fine now we cannot further divide
04:38 - these sub lists why so because each sub
04:41 - list is having only one element and that
04:43 - is the condition you have to stop
04:45 - dividing you will keep on dividing the
04:48 - sub list until you until each sub list
04:51 - is having only one element now each sub
04:53 - list is having only one element now next
04:56 - second step was you have to merge these
04:59 - sub lists so now till now this divide
05:04 - the first step is over now second step
05:06 - is is what for merging okay now if I
05:10 - write down the algorithm then how we
05:12 - will write C merge sort we are going to
05:19 - take a function merge suit is array we
05:22 - are going to pass lower bound and upper
05:24 - bound this is lower bound and this one
05:26 - is upper bound right and if lower bound
05:33 - is less than upper bound it means at
05:37 - least that array is having two element
05:39 - lower bound is less than upper bound if
05:44 - two elements are there if two elements
05:46 - are then then you are going to divide
05:47 - that particular list into sub lists okay
05:52 - and then each each sub list is having
05:53 - only one element so now if this
05:55 - condition is true now next is we are
05:57 - going to divide the array into two
05:59 - halves equal halves so for that thing
06:01 - you have to calculate mid element how to
06:04 - calculate mid element mid as equal to
06:06 - lower bound plus upper bound / - fine
06:11 - now we are again going to recursively
06:16 - call merge sort on array a and from
06:23 - lower bound to
06:28 - may see from lower bound zero to mid
06:32 - hair mid is what for because 0 + 8 0 + 8
06:37 - divided by 2 that is 4 so mid is equal
06:40 - to 4 so 1 1 half is from 0 to mid and
06:44 - next half is from 5 to 8 that is mid
06:47 - plus 1 to upper bound so next is
06:51 - mergesort on array a from mid plus 1 to
06:58 - upper bound right and this is what
07:02 - recursive call we are going to
07:04 - recursively now again we are going to
07:05 - divide this into two halves from 0 to
07:07 - mid to mid plus 1 to this one again we
07:10 - are going to divide into two halves so
07:11 - this is a recursive call to left part n
07:15 - to right part fine
07:17 - finally after that we are going to merge
07:21 - these arrays fine so after this merge
07:26 - sort next next is what a method that is
07:31 - merged we are going to merge these
07:33 - arrays now in merge we are going to pass
07:36 - in a we are going to we are going to
07:39 - merge these two halves so from lower
07:44 - bound to mid 1/2 is from lower bound
07:49 - lower bound to mid and another is from
07:51 - mid plus 1 to upper bound so from mid
07:53 - plus 1 to upper bound so you are just
07:57 - going to pass these parameters lower
08:00 - bound mid and upper bound fine so this
08:04 - is the merge sort
08:06 - now here the main thing is you have to
08:09 - write down the code for this merge
08:10 - function that this backbone of this
08:13 - merge sort is this merge function how we
08:15 - are going to merge these Ares ok now if
08:21 - if you I this is the recursive code fine
08:24 - this is recursive call if you if you
08:26 - draw our recursion tree for this this
08:29 - numerical then how you will draw see
08:32 - first of all we are going to call merge
08:35 - sort
08:36 - suppose I am going to write
08:38 - mas only fine Eddie a I'm not going to
08:42 - pass away I'm going to pass this lower
08:44 - bound and upper bound lower bound is
08:45 - zero upper bound is it fine
08:50 - lower bound is less than upper bound yes
08:52 - that is true then you calculate made
08:54 - made is equal to zero plus a divided by
08:57 - two that is for fine
08:59 - again merge three statements are there
09:02 - this this and this so I'm going to
09:04 - divide into in this into three parts so
09:07 - here we have again merge sort merge sort
09:13 - I'm going to write a mess for my soul
09:15 - lower bound to mid lower bound is 0 mid
09:18 - is for fine again
09:23 - second is mergesort mid plus 1 that is 5
09:27 - - upper bound is 8 and next is this
09:34 - merge would be merge would be lower
09:37 - bound is 0 mid is 4 and upper bound is 8
09:43 - from 0 to 4 and 5 to 8 we are going to
09:46 - merge these arrays but after sorting of
09:49 - these sub arrays fine now from 0 to 4
09:53 - again recursively merge so much so it
09:55 - would be called from 0 to 4 0 is less
09:58 - than 4 yes
09:59 - calculate mate mate is equal to 0 plus
10:01 - for the divide by 2 that is 2 midpoint
10:04 - is 2 now again call this merge sort now
10:09 - see M is 0 to 2 minutes - now here again
10:18 - M is 3 to 4 now here we have merge 0
10:27 - then made is 2 then for 0 to 2 and + 3
10:32 - to 4 we are going to merge these two
10:34 - halves now next is see this one from 0
10:40 - to 2 0 is less than - yes calculate mid
10:44 - 0 plus 2 2 divided by 2 that is 1 min is
10:48 - 1
10:49 - again for a merge sort zero two middles
10:54 - one merge sort
10:57 - zero mate is one then mid plus one - two
11:00 - - only one element we have now now here
11:04 - we have merging of zero to one and then
11:09 - to fine now here again 0 & 1 0 is less
11:15 - than 1
11:15 - yes calculate midpoint midpoint is what
11:17 - 0 plus 1 divided by 2 that is 1 divided
11:20 - by 2 that is 0 0 is midpoint fine so
11:25 - here we call merge sort
11:26 - 0 - middle element is 0 because 0 plus 1
11:30 - that is 1 1 divided by 2 is 0 and then
11:35 - again merge sort 1 to 1 and again we are
11:41 - going to call merge methadone 0 metal
11:45 - point is lower bound is 0 mate is also 0
11:49 - and upper bound is 1 from 0 0 to 1 to 1
11:54 - fine here we have 2 - that is one
11:57 - element is there only so we are not
11:59 - going to divide this anymore because
12:01 - lower bound is - upper bound is also -
12:04 - who is less than 2 no this condition is
12:06 - not true so we are not going to divide
12:07 - this this is worse now come to this
12:10 - point 3 is lower bound upper bound 3 is
12:13 - less than 4 yes then we are going to
12:15 - divide this into three parts
12:19 - see 3 is less than 4 yes find out
12:22 - midpoint 3 plus 4 that is 7 7 divided by
12:25 - 2 is 3 only fine
12:28 - so here we are going to call merge sort
12:30 - lower bound is 3 mid is also 3 second is
12:36 - merge sort 4 to 4 and this one is merged
12:42 - 3 3 & 4 fine
12:46 - 3 3 lower bound is 3 upper bound is 3 3
12:50 - is less than 3 no 4 is less than food no
12:52 - we are not going to divide this merged
12:54 - this then again we have this merged then
12:57 - finally this one merge so 5 - 8 5 is
13:00 - less than 8 lower bound is less than 8
13:02 - yes we are going to divide this one now
13:05 - now see calculate midpoint 8 plus 5 that
13:10 - is 13 13 divided by 2 that is 6 we have
13:13 - so middle point is 6
13:15 - mergesort 5 to 6 then mergesort
13:21 - 7 to 8 and then we are having merge 5 6
13:26 - & 8 then again come to records equal to
13:30 - this 1 5 2 6 5 is less than 6
13:32 - yes again divide this one into 3 parts
13:38 - calculate a midpoint
13:39 - 6 plus 5 is 11 11 by divided by 2 is 5
13:42 - so merge so 5 to 5 then merge sort
13:48 - 6 to upper bound is 6 then we are going
13:54 - to call merge 5 then 5 and then 6 fine
13:59 - lower bound is 5 mid is also 5 and upper
14:02 - bound is six now seven 8 7 is less than
14:05 - this it yes this condition is true to
14:08 - again divide this into three parts now
14:10 - I'm going to divide it here only so now
14:17 - first is mergesort 7 plus 8 calculate
14:20 - midpoint 7 plus 8 is 15 divided by 2 is
14:24 - 7 so 7 is midpoint 7 to 7 then merge
14:30 - sort
14:30 - mid plus 1 8 to 8 and then we are going
14:34 - to merge 7 7 8
14:37 - he and finally merge 5 6 again finally
14:41 - merge 0 4 & 8 so this is the recursive
14:43 - tree now how this is going to be called
14:46 - see first of all massive of 0 to 8 here
14:50 - we have first cold would we do this
14:54 - function 0 to 4 we are going to first of
14:57 - all call the merge sort on 0 to 4 again
15:01 - for first sorting of this one we are
15:04 - supposed to cool this one again we are
15:06 - going to hold this one 0 to 2 for
15:09 - sorting off from 0 to 2 we are going to
15:10 - divide this again so here we go from 0
15:14 - one only now for sorting of zero then
15:18 - zero then one element we are going to
15:20 - divide this into two halves only if you
15:22 - so here we are going to call this one M
15:26 - is 0 0 and M is 1 and 1 0 0 means we are
15:30 - having only one element now 0 0 that is
15:33 - 15 here we have 15 and here we have only
15:38 - 5 because we cannot further divide it
15:41 - fine so this one is done this one is
15:45 - done now next step is now control would
15:48 - go to this merge now merging of 0 to 0 0
15:53 - to 0 is 15 and 0 or you can say 0 to 0
15:57 - then 1 to 1 1 to 1 is 5 then you are
16:00 - going to merge this 15 and 5 now how
16:05 - this merging is to be done see two sub
16:09 - lists are there which are already sorted
16:11 - you are going to merge those sub lists
16:14 - and you are going to produce a new sub
16:16 - list and that new sub list is also in
16:20 - sorted order fine
16:23 - so after merging of this 15 and 5 the
16:27 - new sub list would be 5 and 15
16:32 - right how they are going to merge I am
16:34 - going to explain that processor also but
16:37 - for now you have to keep in mind that
16:39 - you two sorted sub lists are there you
16:41 - are going to merge those sorted sub
16:43 - lists so the new new produced sub list
16:46 - would be its sorted order so this would
16:49 - be 5 and 15 so after merging the list
16:51 - would be 5 and 15 5 and 15 done now now
16:57 - the control would go to here only ms 2 n
17:01 - 2 2 n 2 so this is only one element is
17:06 - there 2 into that is 24 fine now
17:10 - this one is done now 24 is there 24 is
17:14 - there now control will go to here only
17:17 - merge of 0 to 1 0 to 1 this list and
17:21 - this list is what 5 and 15
17:24 - and from tu-tu-tu-tu-tu-tu is 24 so now
17:28 - we are going to merge this and this that
17:31 - is why I am saying you cannot merge this
17:33 - 15 with 8 or 15 with 24 but it's not
17:37 - like that if this 5 and 15 is 1 list and
17:40 - you are going to merge this with 8 no we
17:43 - are going to more we are going to merge
17:45 - these list with its adjacent lest only
17:48 - and when you are going to draw this
17:51 - recursive tree then you come to know
17:53 - that how we are going to merge these sub
17:55 - lists and how you are going to divide
17:57 - these sub lists fine
17:59 - now this sub list would be merged this
18:02 - and this now this list would be 5 15 and
18:06 - 24 5 15 and 24 now fine
18:11 - now now control would go to here only
18:14 - now this one is done 0 to 2 now list 0
18:18 - to 2 ways what 5 15 and 24 the merging
18:21 - has been done now control would go to
18:23 - here only merge so 3 to 4
18:27 - now again recursive cool so control
18:30 - would go to 3 to 3 1 element is there 3
18:33 - 3 that is 8 we are having 8 now control
18:37 - would go to here for and for one element
18:39 - is there that is 1 only now control
18:42 - would go to this much we are going to
18:45 - merge 3 2 3 3 2 3 methyl of 8 and then 4
18:49 - to 4 that is 1 so we are going to merge
18:51 - these two and the result would be 1 & 8
18:55 - fine so here we go toward 1 & 8
19:00 - after merging I am going to discuss this
19:02 - merging method also now control would go
19:06 - to here only now this one is done now
19:09 - control would go to this merge now we
19:10 - are going to merge from 0 to 2 0 to 2
19:13 - this one and 0 to 2 the list is this one
19:16 - we have got this list fine and from 3 to
19:19 - 4 3 to 4 the list is 1 & 8 now we are
19:22 - going to merge this 5 15 24 with 1 & 8
19:27 - fine and after merging of this to now
19:30 - the list would be
19:33 - this one five eight fifteen and twenty
19:38 - four and this step you are going to find
19:42 - out this result because when you are to
19:45 - sort when you are merging two sorted sub
19:47 - lists then dessert the result would also
19:49 - be a sorted list fine
19:52 - now now this one is done now again we
19:56 - have done from zero to four now control
19:59 - would go to from five to eight now again
20:02 - the same processor would be there the
20:04 - control would go to recursive call is
20:05 - the other from five to six then from 5
20:07 - to 5 then here six to six then merging
20:10 - would be done then again back to seven
20:12 - to eight then this one this one this one
20:15 - and then finally merging of these lists
20:17 - fine so here merging of these two then
20:21 - merge them of these two then finally
20:23 - this and this merging of these two fine
20:27 - and ultimately you will get one complete
20:30 - sorted list fine now I am going to
20:35 - discuss with you how this merge function
20:37 - is going to be executed now check we are
20:40 - going to merge first of all these two
20:43 - and how merging would be done two sub
20:46 - lists are there we are going to compare
20:49 - the first element of these sub lists
20:51 - fifteen and five which one is less five
20:53 - is less so we are going to put five
20:55 - first of all then we will put what 15 so
20:59 - this is the new produced sub list sorted
21:02 - sub list fine now this would be this
21:06 - would be merged with this 24 this 24 now
21:11 - the new sub list would be 515 in one sub
21:15 - list three or five and fifteen in one
21:17 - way or 24 now compare five for 24 which
21:19 - one is less five so we will put 5 here
21:21 - then 15 with 24 15 is less then we were
21:24 - going to put 24 this is the new sub list
21:26 - now now eight with this one and the new
21:31 - sub list would would be one and eight
21:33 - now this with this one and eight so
21:37 - finally the new sorted sub list would be
21:44 - see compare five with this one which one
21:46 - is less one one then here we have eight
21:50 - here we have five five with this eight
21:52 - five then eight then 15 then we have
21:56 - twenty four fine same here we have three
22:02 - and sixteen here after merging we will
22:04 - get ten and twenty after merging of
22:08 - these two what you will get three ten
22:12 - sixteen and then twenty now we have two
22:16 - halves one is this one and one is this
22:19 - one now finally you are going to merge
22:21 - these two and ultimately you will get
22:24 - what one list that would be sorted fine
22:30 - and then we will stop what merging fine
22:33 - now see now this sub list are there and
22:36 - this sub list is there now how merging
22:39 - is to be done let us see so now we are
22:43 - having two pointers one is suppose a
22:47 - pointer that will be pointed to this
22:49 - lower bound one is this J pointer and
22:52 - two sub lists are there one is this and
22:54 - one is this one maybe you can say this
22:55 - is left and this is right sub list
22:57 - another list is there we are going to
23:00 - produce another sub list sorted sub list
23:02 - find another pointer is there that is K
23:07 - which is at the starting of this sub
23:10 - list fine and how many elements would be
23:14 - there in the sub list total of this and
23:16 - this one let us suppose here we are
23:19 - having M element here we are having n
23:21 - elements so total would be what M plus n
23:24 - elements fine so this merging this
23:28 - merging function the time complexity for
23:30 - this merging function would be what
23:32 - theta M plus in M is number of elements
23:38 - in one sorted sub list and is number of
23:41 - elements in another sorted sub list when
23:43 - you are going to add these elements into
23:46 - this one then how many elements would be
23:48 - there in this key in this sub list M
23:49 - plus n so time complexity for this merge
23:52 - function would be theta M plus N
23:56 - fine now how merging is to be done first
23:58 - step is we are going to compare now
24:02 - first element of this with this but you
24:07 - can say suppose name is L this name is R
24:09 - so now we are going to compare L of I
24:12 - with L R of G and that which element of
24:17 - it element which is less we are going to
24:19 - put that element into this sub list fine
24:22 - so 1 & 3 which one is less 1 so we are
24:25 - going to put 1 here next step is we are
24:29 - going to increment this K now K is at
24:32 - this place and we have placed 1 here so
24:35 - now we are going to increment this I
24:37 - also now II's at this place now again
24:41 - compare L of I with our of J 5 and 3
24:45 - which one is less 3 so we are we are
24:47 - going to put 3 here again we are
24:51 - increment this K and we are increment
24:54 - now this J because we have put this 3
24:58 - here only fine now again compare L of
25:03 - i-5 with our of J that is 10 5 is less
25:07 - than 10 so we are going to put 5 here on
25:10 - increment K K is now at this place and
25:14 - increment I now now again compare it
25:20 - with this 10 it is less than 10 so we
25:23 - are going to put 8 in this new sub list
25:26 - now increment this k now k K's at this
25:31 - place and increment also I fine now
25:36 - again compare 15 with this 10 which one
25:38 - is less pen so we are going to put in in
25:41 - this sub list and increment this J now
25:44 - J's at this place and increment this ki
25:47 - now he is here now again compare 15 with
25:51 - this 16 is because here and J is here
25:54 - only 15 is less than 16 so we are going
25:56 - to put 15 here so now increment I and
26:01 - increment K 24 and 16 which one is less
26:06 - 16 so we are going to put 16 here
26:09 - now increment this.j and increment this
26:14 - K fine now 24 and 20 which one is less
26:19 - 20 so we are going to put 20 at this
26:21 - place now increment this K and if you
26:25 - increment this J now J is greater than
26:29 - this upper bound fine
26:31 - it means this list is now exhausted
26:34 - means you have put you have already put
26:36 - this element all the element of this sub
26:39 - list into the new list sorted sub list
26:42 - fine so this is now done now what you
26:46 - have to do now one element of this sub
26:48 - list is remaining now you simply simply
26:51 - put this element into the surplus 24
26:55 - fine and we increment I so increment is
26:58 - also now greater than this element so
27:00 - this one is also done now if suppose
27:02 - here 25 is also there 30 is also there
27:07 - now what you will do now see this list
27:11 - is done now so you simply put all the
27:13 - remaining elements of this sub list into
27:16 - this one 24 25 and 30 like this fine
27:20 - here in this case we have only one
27:22 - element left over so we simply put 24
27:24 - here on so this is now the sorted list
27:29 - fine after merging move these sub lists
27:32 - or this is if this is how the merging is
27:34 - to be done fine so now if you write down
27:37 - the code for this merging technique then
27:39 - how we will write see we are having
27:43 - function word merge fine array we are
27:48 - going to pass lower bound then we are
27:50 - going to pass mid and then upper bound
27:54 - fine
27:55 - now next is see we are going to take I J
28:00 - and K 3 variables and I is equal to from
28:08 - lower bound and J would be J would be
28:11 - from mid plus 1 because see here mid is
28:15 - what for so J is from here 5 so J would
28:18 - be from
28:20 - mid plus 1 and K would be is equal to
28:25 - from lower bound only from 0 only now
28:28 - next what you are going to check is you
28:32 - are going to write down a loop while
28:36 - this is less than equal to mid this i is
28:41 - less than equal to mid and plus this J
28:46 - value is less than equal to upper bound
28:49 - J less than equal to upper bound in that
28:54 - case only you are going to compare these
28:56 - elements and you are going to put the
28:58 - element which is lesser into this new
29:01 - array fine so now you compare if if a of
29:09 - a of IFC name of the series a a of I is
29:18 - less than and equal to a or J fine
29:26 - because the air is this array name is a
29:30 - only so a of I is less than equal to
29:33 - this a of J then what you will put you
29:36 - will put this a of I into this array so
29:39 - we are going to take another array that
29:41 - his name is B so B of K see we have
29:46 - taken one variable
29:48 - okay so B of K is equal to a of I fine
29:53 - and next what we have done I plus plus
29:56 - and K plus plus right else
30:04 - and suppose this a of I is not less than
30:08 - used a this this a of J is less than
30:11 - your file then what he will put you will
30:12 - put this value into here only
30:15 - so else what you will do in B of K you
30:19 - will put a oz j not a o file and then
30:24 - you will increment J plus plus and a
30:29 - plus plus fine
30:31 - so say in both the cases we have we have
30:34 - that what K plus plus and K plus plus so
30:37 - if you will not write here then you
30:39 - simply write here k plus plus you can no
30:46 - need to write here only you simply write
30:48 - out of this if and else you simply write
30:50 - k plus plus because in both the
30:52 - conditions you are going to do what k
30:54 - plus plus k plus 1 you can say fine so
31:00 - this is to be this this processor is
31:02 - going to repeat until we have I less
31:05 - than equal to mid and J less than equal
31:07 - to upper bound fine now next next
31:10 - condition is what suppose we have
31:13 - reached J is greater than upper bound
31:16 - now we have already put all the elements
31:19 - of this sub list into this one but still
31:22 - some elements of this this sub list is
31:25 - remaining then what you will do you
31:26 - simply put all these elements here only
31:28 - so you have to check that condition also
31:30 - fine you know how to check that thing if
31:34 - now I am going to take suppose one
31:37 - condition is I am going to take this I
31:39 - has been reached to its beyond to its
31:43 - limit so suppose I is greater then mid
31:50 - because I should be less than equal to
31:52 - mid now I has been breached to greater
31:55 - than mid means I has been reached here
31:57 - or it means all the elements of this sub
31:59 - list has been put here only now only
32:02 - some some elements of this are remaining
32:04 - may be some elements of this list are
32:06 - remain fine
32:07 - so if this condition is there then then
32:10 - what you will do you will put now all
32:12 - the remaining leftover elements of this
32:14 - sub list to Haran so now what
32:17 - right while J less than equal to upper
32:22 - bound
32:24 - while J less than equal to upper bound
32:26 - on fine because if J is also greater
32:29 - than upper bound then no need to then
32:32 - obviously there is no left or element so
32:33 - no need to put these elements here on
32:35 - you fine
32:36 - so you will write down that condition
32:38 - also while J less than equal to upper
32:40 - bound fine then only you will put what
32:44 - in B of K you will put a or J and then
32:51 - you load jo j + + + k + + I'm short of
33:00 - the space that is why I am writing
33:02 - multiple statements in one line fine and
33:04 - here you'll enclose this while loop okay
33:09 - now second case is there here I has been
33:13 - reached to greater than this mid else
33:18 - here if has been closed
33:20 - else if J has J has reached to its upper
33:27 - bound limit beyond - it upper bound
33:29 - limit that is J is suppose now greater
33:31 - than upper bound so now what do you what
33:35 - you will do
33:35 - else else you will check else may be
33:42 - some elements some left or elements are
33:44 - there in this sub list so you will check
33:46 - while I less than equal to mid in that
33:53 - case you will you'll do it in B of K you
33:57 - will put a of I you will copy all the
34:01 - values here on you now fine
34:03 - and you will do I plus plus and ka plus
34:07 - plus this is ending of this while loop
34:10 - and this is ending of this else loop
34:13 - fine now see we have taken another array
34:17 - that is B and the original array is a so
34:22 - now this B suppose this is B so now this
34:25 - is sorted array you simply copy all
34:27 - these values to this a simply round
34:29 - right down of
34:30 - for like this for K is equal to lower
34:37 - bound K less than equal to upper bound
34:40 - and k plus plus and simply copy in a of
34:45 - K you will copy would be of K all the
34:48 - values from B do and this is done now
34:52 - and after that you will close this merge
34:55 - function okay I know this is very
35:00 - congested because I have a shortage of
35:02 - the space but I I hope you got the
35:05 - concept of this merge function and the
35:08 - time complexity for the small sort is
35:09 - both in worst case and best case it is
35:12 - order of n log n so I'll make another
35:19 - video on this time complexity half this
35:22 - time complexity is order of n log and
35:24 - both in quicksort and mergesort so this
35:26 - is all about merge sort algorithm see if
35:29 - you know the logic of this merge
35:31 - function then simply you can easily
35:34 - write down the coding for this merge
35:35 - sort this is the main funder this is the
35:38 - main you can see the backbone of this
35:39 - merge sort algorithm fine so this is all
35:42 - about merge so in next video I am going
35:44 - to discuss with you heapsort so till
35:46 - then bye-bye

Cleaned transcript:

so the topic is mergesort see we have already discussed quicksort so in quicksort the main idea was or you can say the backbone of that sorting technique is the partition method in merge sort the backbone of this technique is or the main front line this technique is merge processor okay so in this video I am going to discuss with you the working of this merge sort with help of an example and we are going to write down a piece of food for this sorting technique okay so this sorting techniques also works on divide and conquer technique as in quicksort technique fine now what is that technique in this case the complete area you can say the complete list is divided into sub lists fine or you can say the complete complete list is divided into n sub lists and each sub list is having one element or you can say will will keep on dividing the list into sub lists and till be cut and until we get the sub list having one element only fine after that we are going to merge the sub list and we will keep on merging the sub list fine to adjacent sub list you can say to produce a new sorted sub list and we'll keep on merging the sub list until big until we get one complete sub list and that sub list would be sorted sub list so the first step is dividing the given list into sub lists fine second step is merging of those sub lists to get a one complete sorted sub list sorry one complete sorted list so these are two steps main steps see let us take an example and see how this merge sort will work so let us take this example we are having this array array name is a we are having nine elements and these are the elements you are going to sort these elements in ascending order applying this merge sort so first step is we are going to divide this list or this array into two equal sub arrays fine equal sub arrays means you have to find out the position and you are going to divide this array from that mid position fine see how to find out a mid position 0 + 8 C 0 is lower bound this one is your upper bound is 0 + 8 is 8 8 divided by 2 that is 4 so 10 4 0 2 4 1 sublist is there like this you can write we are going to divide it into two sub lists 15 5 24 8 n 1 0 1 2 3 4 from 0 to 4 we are having 1 sub list and from 5 to 8 we are having another sub list 5 6 7 8 like this ok still this this sub list is having in how many elements five elements but we are going to divide the sub list till we get a sub list having one element so we are further going to divide the sub list okay into two halves 0 + 4 that is 4 4 divided by 2 that is 2 so my position is 2 from 0 to 2 15 5 + 24 this is 1 sub list and another sub list would be 8 + 1 from 0 1 2 here we have 3 to 4 right this will be again divided into two parts and 3 16 would be in one sub array and this 10 + 20 would be in another sub array fine again this list would be divided in two parts middle middle is 1 0 plus 2 is 2 2 divided by 2 that is 1 so 15 and 5 this would be in one list and this 24 would be in another list same this would be divided into two halves fine and this would be 8 and this would be one sub list will be having one element this would also be divided into two halves one is having one element three one is having one element sixteen here one is having element 10 and 1 is having element 20 now this one is having element 15 another is having element five fine now we cannot further divide these sub lists why so because each sub list is having only one element and that is the condition you have to stop dividing you will keep on dividing the sub list until you until each sub list is having only one element now each sub list is having only one element now next second step was you have to merge these sub lists so now till now this divide the first step is over now second step is is what for merging okay now if I write down the algorithm then how we will write C merge sort we are going to take a function merge suit is array we are going to pass lower bound and upper bound this is lower bound and this one is upper bound right and if lower bound is less than upper bound it means at least that array is having two element lower bound is less than upper bound if two elements are there if two elements are then then you are going to divide that particular list into sub lists okay and then each each sub list is having only one element so now if this condition is true now next is we are going to divide the array into two halves equal halves so for that thing you have to calculate mid element how to calculate mid element mid as equal to lower bound plus upper bound / fine now we are again going to recursively call merge sort on array a and from lower bound to may see from lower bound zero to mid hair mid is what for because 0 + 8 0 + 8 divided by 2 that is 4 so mid is equal to 4 so 1 1 half is from 0 to mid and next half is from 5 to 8 that is mid plus 1 to upper bound so next is mergesort on array a from mid plus 1 to upper bound right and this is what recursive call we are going to recursively now again we are going to divide this into two halves from 0 to mid to mid plus 1 to this one again we are going to divide into two halves so this is a recursive call to left part n to right part fine finally after that we are going to merge these arrays fine so after this merge sort next next is what a method that is merged we are going to merge these arrays now in merge we are going to pass in a we are going to we are going to merge these two halves so from lower bound to mid 1/2 is from lower bound lower bound to mid and another is from mid plus 1 to upper bound so from mid plus 1 to upper bound so you are just going to pass these parameters lower bound mid and upper bound fine so this is the merge sort now here the main thing is you have to write down the code for this merge function that this backbone of this merge sort is this merge function how we are going to merge these Ares ok now if if you I this is the recursive code fine this is recursive call if you if you draw our recursion tree for this this numerical then how you will draw see first of all we are going to call merge sort suppose I am going to write mas only fine Eddie a I'm not going to pass away I'm going to pass this lower bound and upper bound lower bound is zero upper bound is it fine lower bound is less than upper bound yes that is true then you calculate made made is equal to zero plus a divided by two that is for fine again merge three statements are there this this and this so I'm going to divide into in this into three parts so here we have again merge sort merge sort I'm going to write a mess for my soul lower bound to mid lower bound is 0 mid is for fine again second is mergesort mid plus 1 that is 5 upper bound is 8 and next is this merge would be merge would be lower bound is 0 mid is 4 and upper bound is 8 from 0 to 4 and 5 to 8 we are going to merge these arrays but after sorting of these sub arrays fine now from 0 to 4 again recursively merge so much so it would be called from 0 to 4 0 is less than 4 yes calculate mate mate is equal to 0 plus for the divide by 2 that is 2 midpoint is 2 now again call this merge sort now see M is 0 to 2 minutes now here again M is 3 to 4 now here we have merge 0 then made is 2 then for 0 to 2 and + 3 to 4 we are going to merge these two halves now next is see this one from 0 to 2 0 is less than yes calculate mid 0 plus 2 2 divided by 2 that is 1 min is 1 again for a merge sort zero two middles one merge sort zero mate is one then mid plus one two only one element we have now now here we have merging of zero to one and then to fine now here again 0 & 1 0 is less than 1 yes calculate midpoint midpoint is what 0 plus 1 divided by 2 that is 1 divided by 2 that is 0 0 is midpoint fine so here we call merge sort 0 middle element is 0 because 0 plus 1 that is 1 1 divided by 2 is 0 and then again merge sort 1 to 1 and again we are going to call merge methadone 0 metal point is lower bound is 0 mate is also 0 and upper bound is 1 from 0 0 to 1 to 1 fine here we have 2 that is one element is there only so we are not going to divide this anymore because lower bound is upper bound is also who is less than 2 no this condition is not true so we are not going to divide this this is worse now come to this point 3 is lower bound upper bound 3 is less than 4 yes then we are going to divide this into three parts see 3 is less than 4 yes find out midpoint 3 plus 4 that is 7 7 divided by 2 is 3 only fine so here we are going to call merge sort lower bound is 3 mid is also 3 second is merge sort 4 to 4 and this one is merged 3 3 & 4 fine 3 3 lower bound is 3 upper bound is 3 3 is less than 3 no 4 is less than food no we are not going to divide this merged this then again we have this merged then finally this one merge so 5 8 5 is less than 8 lower bound is less than 8 yes we are going to divide this one now now see calculate midpoint 8 plus 5 that is 13 13 divided by 2 that is 6 we have so middle point is 6 mergesort 5 to 6 then mergesort 7 to 8 and then we are having merge 5 6 & 8 then again come to records equal to this 1 5 2 6 5 is less than 6 yes again divide this one into 3 parts calculate a midpoint 6 plus 5 is 11 11 by divided by 2 is 5 so merge so 5 to 5 then merge sort 6 to upper bound is 6 then we are going to call merge 5 then 5 and then 6 fine lower bound is 5 mid is also 5 and upper bound is six now seven 8 7 is less than this it yes this condition is true to again divide this into three parts now I'm going to divide it here only so now first is mergesort 7 plus 8 calculate midpoint 7 plus 8 is 15 divided by 2 is 7 so 7 is midpoint 7 to 7 then merge sort mid plus 1 8 to 8 and then we are going to merge 7 7 8 he and finally merge 5 6 again finally merge 0 4 & 8 so this is the recursive tree now how this is going to be called see first of all massive of 0 to 8 here we have first cold would we do this function 0 to 4 we are going to first of all call the merge sort on 0 to 4 again for first sorting of this one we are supposed to cool this one again we are going to hold this one 0 to 2 for sorting off from 0 to 2 we are going to divide this again so here we go from 0 one only now for sorting of zero then zero then one element we are going to divide this into two halves only if you so here we are going to call this one M is 0 0 and M is 1 and 1 0 0 means we are having only one element now 0 0 that is 15 here we have 15 and here we have only 5 because we cannot further divide it fine so this one is done this one is done now next step is now control would go to this merge now merging of 0 to 0 0 to 0 is 15 and 0 or you can say 0 to 0 then 1 to 1 1 to 1 is 5 then you are going to merge this 15 and 5 now how this merging is to be done see two sub lists are there which are already sorted you are going to merge those sub lists and you are going to produce a new sub list and that new sub list is also in sorted order fine so after merging of this 15 and 5 the new sub list would be 5 and 15 right how they are going to merge I am going to explain that processor also but for now you have to keep in mind that you two sorted sub lists are there you are going to merge those sorted sub lists so the new new produced sub list would be its sorted order so this would be 5 and 15 so after merging the list would be 5 and 15 5 and 15 done now now the control would go to here only ms 2 n 2 2 n 2 so this is only one element is there 2 into that is 24 fine now this one is done now 24 is there 24 is there now control will go to here only merge of 0 to 1 0 to 1 this list and this list is what 5 and 15 and from tutututututu is 24 so now we are going to merge this and this that is why I am saying you cannot merge this 15 with 8 or 15 with 24 but it's not like that if this 5 and 15 is 1 list and you are going to merge this with 8 no we are going to more we are going to merge these list with its adjacent lest only and when you are going to draw this recursive tree then you come to know that how we are going to merge these sub lists and how you are going to divide these sub lists fine now this sub list would be merged this and this now this list would be 5 15 and 24 5 15 and 24 now fine now now control would go to here only now this one is done 0 to 2 now list 0 to 2 ways what 5 15 and 24 the merging has been done now control would go to here only merge so 3 to 4 now again recursive cool so control would go to 3 to 3 1 element is there 3 3 that is 8 we are having 8 now control would go to here for and for one element is there that is 1 only now control would go to this much we are going to merge 3 2 3 3 2 3 methyl of 8 and then 4 to 4 that is 1 so we are going to merge these two and the result would be 1 & 8 fine so here we go toward 1 & 8 after merging I am going to discuss this merging method also now control would go to here only now this one is done now control would go to this merge now we are going to merge from 0 to 2 0 to 2 this one and 0 to 2 the list is this one we have got this list fine and from 3 to 4 3 to 4 the list is 1 & 8 now we are going to merge this 5 15 24 with 1 & 8 fine and after merging of this to now the list would be this one five eight fifteen and twenty four and this step you are going to find out this result because when you are to sort when you are merging two sorted sub lists then dessert the result would also be a sorted list fine now now this one is done now again we have done from zero to four now control would go to from five to eight now again the same processor would be there the control would go to recursive call is the other from five to six then from 5 to 5 then here six to six then merging would be done then again back to seven to eight then this one this one this one and then finally merging of these lists fine so here merging of these two then merge them of these two then finally this and this merging of these two fine and ultimately you will get one complete sorted list fine now I am going to discuss with you how this merge function is going to be executed now check we are going to merge first of all these two and how merging would be done two sub lists are there we are going to compare the first element of these sub lists fifteen and five which one is less five is less so we are going to put five first of all then we will put what 15 so this is the new produced sub list sorted sub list fine now this would be this would be merged with this 24 this 24 now the new sub list would be 515 in one sub list three or five and fifteen in one way or 24 now compare five for 24 which one is less five so we will put 5 here then 15 with 24 15 is less then we were going to put 24 this is the new sub list now now eight with this one and the new sub list would would be one and eight now this with this one and eight so finally the new sorted sub list would be see compare five with this one which one is less one one then here we have eight here we have five five with this eight five then eight then 15 then we have twenty four fine same here we have three and sixteen here after merging we will get ten and twenty after merging of these two what you will get three ten sixteen and then twenty now we have two halves one is this one and one is this one now finally you are going to merge these two and ultimately you will get what one list that would be sorted fine and then we will stop what merging fine now see now this sub list are there and this sub list is there now how merging is to be done let us see so now we are having two pointers one is suppose a pointer that will be pointed to this lower bound one is this J pointer and two sub lists are there one is this and one is this one maybe you can say this is left and this is right sub list another list is there we are going to produce another sub list sorted sub list find another pointer is there that is K which is at the starting of this sub list fine and how many elements would be there in the sub list total of this and this one let us suppose here we are having M element here we are having n elements so total would be what M plus n elements fine so this merging this merging function the time complexity for this merging function would be what theta M plus in M is number of elements in one sorted sub list and is number of elements in another sorted sub list when you are going to add these elements into this one then how many elements would be there in this key in this sub list M plus n so time complexity for this merge function would be theta M plus N fine now how merging is to be done first step is we are going to compare now first element of this with this but you can say suppose name is L this name is R so now we are going to compare L of I with L R of G and that which element of it element which is less we are going to put that element into this sub list fine so 1 & 3 which one is less 1 so we are going to put 1 here next step is we are going to increment this K now K is at this place and we have placed 1 here so now we are going to increment this I also now II's at this place now again compare L of I with our of J 5 and 3 which one is less 3 so we are we are going to put 3 here again we are increment this K and we are increment now this J because we have put this 3 here only fine now again compare L of i5 with our of J that is 10 5 is less than 10 so we are going to put 5 here on increment K K is now at this place and increment I now now again compare it with this 10 it is less than 10 so we are going to put 8 in this new sub list now increment this k now k K's at this place and increment also I fine now again compare 15 with this 10 which one is less pen so we are going to put in in this sub list and increment this J now J's at this place and increment this ki now he is here now again compare 15 with this 16 is because here and J is here only 15 is less than 16 so we are going to put 15 here so now increment I and increment K 24 and 16 which one is less 16 so we are going to put 16 here now increment this.j and increment this K fine now 24 and 20 which one is less 20 so we are going to put 20 at this place now increment this K and if you increment this J now J is greater than this upper bound fine it means this list is now exhausted means you have put you have already put this element all the element of this sub list into the new list sorted sub list fine so this is now done now what you have to do now one element of this sub list is remaining now you simply simply put this element into the surplus 24 fine and we increment I so increment is also now greater than this element so this one is also done now if suppose here 25 is also there 30 is also there now what you will do now see this list is done now so you simply put all the remaining elements of this sub list into this one 24 25 and 30 like this fine here in this case we have only one element left over so we simply put 24 here on so this is now the sorted list fine after merging move these sub lists or this is if this is how the merging is to be done fine so now if you write down the code for this merging technique then how we will write see we are having function word merge fine array we are going to pass lower bound then we are going to pass mid and then upper bound fine now next is see we are going to take I J and K 3 variables and I is equal to from lower bound and J would be J would be from mid plus 1 because see here mid is what for so J is from here 5 so J would be from mid plus 1 and K would be is equal to from lower bound only from 0 only now next what you are going to check is you are going to write down a loop while this is less than equal to mid this i is less than equal to mid and plus this J value is less than equal to upper bound J less than equal to upper bound in that case only you are going to compare these elements and you are going to put the element which is lesser into this new array fine so now you compare if if a of a of IFC name of the series a a of I is less than and equal to a or J fine because the air is this array name is a only so a of I is less than equal to this a of J then what you will put you will put this a of I into this array so we are going to take another array that his name is B so B of K see we have taken one variable okay so B of K is equal to a of I fine and next what we have done I plus plus and K plus plus right else and suppose this a of I is not less than used a this this a of J is less than your file then what he will put you will put this value into here only so else what you will do in B of K you will put a oz j not a o file and then you will increment J plus plus and a plus plus fine so say in both the cases we have we have that what K plus plus and K plus plus so if you will not write here then you simply write here k plus plus you can no need to write here only you simply write out of this if and else you simply write k plus plus because in both the conditions you are going to do what k plus plus k plus 1 you can say fine so this is to be this this processor is going to repeat until we have I less than equal to mid and J less than equal to upper bound fine now next next condition is what suppose we have reached J is greater than upper bound now we have already put all the elements of this sub list into this one but still some elements of this this sub list is remaining then what you will do you simply put all these elements here only so you have to check that condition also fine you know how to check that thing if now I am going to take suppose one condition is I am going to take this I has been reached to its beyond to its limit so suppose I is greater then mid because I should be less than equal to mid now I has been breached to greater than mid means I has been reached here or it means all the elements of this sub list has been put here only now only some some elements of this are remaining may be some elements of this list are remain fine so if this condition is there then then what you will do you will put now all the remaining leftover elements of this sub list to Haran so now what right while J less than equal to upper bound while J less than equal to upper bound on fine because if J is also greater than upper bound then no need to then obviously there is no left or element so no need to put these elements here on you fine so you will write down that condition also while J less than equal to upper bound fine then only you will put what in B of K you will put a or J and then you load jo j + + + k + + I'm short of the space that is why I am writing multiple statements in one line fine and here you'll enclose this while loop okay now second case is there here I has been reached to greater than this mid else here if has been closed else if J has J has reached to its upper bound limit beyond it upper bound limit that is J is suppose now greater than upper bound so now what do you what you will do else else you will check else may be some elements some left or elements are there in this sub list so you will check while I less than equal to mid in that case you will you'll do it in B of K you will put a of I you will copy all the values here on you now fine and you will do I plus plus and ka plus plus this is ending of this while loop and this is ending of this else loop fine now see we have taken another array that is B and the original array is a so now this B suppose this is B so now this is sorted array you simply copy all these values to this a simply round right down of for like this for K is equal to lower bound K less than equal to upper bound and k plus plus and simply copy in a of K you will copy would be of K all the values from B do and this is done now and after that you will close this merge function okay I know this is very congested because I have a shortage of the space but I I hope you got the concept of this merge function and the time complexity for the small sort is both in worst case and best case it is order of n log n so I'll make another video on this time complexity half this time complexity is order of n log and both in quicksort and mergesort so this is all about merge sort algorithm see if you know the logic of this merge function then simply you can easily write down the coding for this merge sort this is the main funder this is the main you can see the backbone of this merge sort algorithm fine so this is all about merge so in next video I am going to discuss with you heapsort so till then byebye
