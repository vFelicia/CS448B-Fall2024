With timestamps:

00:00 - so in this lecture we are going to see
00:02 - how to convert infix expression into
00:05 - prefix expression in the previous video
00:07 - I have discussed the infix to postfix
00:10 - conversion using step now we will see
00:13 - the in fixed to prefix conversion using
00:15 - stack right see here also without stack
00:19 - you can convert from in fixed to prefix
00:22 - like we have discussed in the previous
00:23 - case see let us take this example I have
00:27 - same example I am taking that I have
00:29 - taken in the previous video right so
00:31 - here also you should know the precedence
00:33 - and associativity of the operators this
00:35 - is the prerequisite of this video okay
00:38 - right now we are going to follow those
00:40 - precedence and associativity rules first
00:42 - of all see check out the precedence of
00:44 - these operators which one is higher
00:46 - precedence this multiplication is having
00:48 - higher precedence right so first of all
00:50 - you need to solve this expression that
00:53 - is B into C see these are what operands
00:56 - this is what operator right now prefix
01:01 - expression means if this is B into C
01:05 - means these are operands this is what
01:07 - operator in prefix this operator should
01:10 - be before these or prints in postfix
01:14 - this operator should be after these
01:16 - operands pre means per la Poste means
01:19 - both me you can relate it with prepaid
01:23 - mobile and post paid mobile right and in
01:27 - fixed means this operator is in between
01:30 - these operands that is in fixed
01:32 - expression so this is what in fixed
01:34 - expression now this it is so this is
01:36 - higher so first of all you are you have
01:38 - to solve this one so prefix of this is
01:40 - what estwick B into C right now this
01:46 - says what one operand now we have plus
01:49 - this operator and this is what another
01:51 - operand this operand this open we have
01:53 - two operand and in between these open we
01:55 - have now plus this is what operator now
01:58 - we are going to solve for this one
02:00 - because I have left with only one
02:02 - operator now now for prefix this
02:04 - operator should be before these these
02:06 - operands a and second operand is this
02:09 - one means Asterix
02:10 - B si
02:12 - right so this is what you can say a
02:14 - prefix for the syntax right in this case
02:17 - also in first scan this will be solved
02:21 - in second sense scan again we will solve
02:24 - for this + right so this there are
02:27 - multiple scans to solve this problem
02:29 - without using staff now here in this
02:32 - case I am solving this this is a smaller
02:34 - expression if this is the expression
02:36 - then here multiple scans would be there
02:38 - may be 10 or maybe 20 15 I cannot say
02:41 - right now rather than scanning it
02:45 - multiple times because this process is
02:47 - you know very time-consuming process
02:48 - very lengthy process so we should follow
02:52 - a method in which we scan only once from
02:56 - here to here and after reaching at the
03:00 - end of this expression we will get our
03:02 - output you can say we will get our
03:04 - prefix expression we don't need to scan
03:07 - this expression multiple times right so
03:10 - that is that would be what efficient
03:12 - algorithm so that is possible using
03:14 - stamp that is why here I will discuss
03:17 - with you
03:17 - conversion of in fixed to prefix we
03:19 - using stack we will also discuss to tell
03:22 - you our answer we will also discuss how
03:24 - you can convert this expression without
03:26 - using step at last first of all I will
03:29 - convert this after that I will write
03:32 - down all the rules here only so now this
03:35 - conversion is also same almost same as
03:38 - the infix to postfix conversion but the
03:41 - difference is what first of all you need
03:44 - to reverse this in fixed conversion if
03:46 - you are converting this input prefix in
03:49 - that case only right so first of all
03:51 - reverse this one means we will start
03:53 - writing from here so here we have Q so
03:57 - here you write Q then after that plus T
04:02 - multiplication we then divide then you
04:05 - then divide then W then again
04:07 - multiplication now this is what closing
04:10 - parenthesis so here also I am writing
04:12 - closing parenthesis right now this is
04:15 - what the reverse of this in fixed
04:17 - expression now somewhere it is written
04:20 - that here in the in fixed in the reverse
04:23 - of the same fix
04:24 - convert sorry reverse these parentheses
04:27 - also if this is closing parentheses in
04:30 - the in fix here write down it as opening
04:32 - and here write down it as closing like
04:35 - this but here I'm not going to follow
04:38 - that process right that is also fine you
04:42 - can do something like this after that
04:43 - convert this into postfix and after that
04:45 - reverse that postfix expression but I am
04:47 - NOT going to do this I'm going to follow
04:49 - the second approach right this is now
04:51 - our reverse in fix expression now see
04:54 - same we are going to take one step if
04:57 - operator that will be found then we are
05:00 - using stack for pushing those operators
05:02 - and if operand is there then directly we
05:05 - are going to print those up cooperates
05:09 - right now now scan this reverse in fix
05:14 - expression from left to right you can
05:16 - scan it from right to left also and
05:18 - after that also you can get the prefix
05:20 - expression so there are many ways to or
05:22 - three ways to convert infix to prefix
05:24 - right this is one of all the possible
05:26 - ways right now here we have Q so we are
05:30 - not going to push anything into the
05:32 - stack if operand is there directly print
05:34 - it fine next plus this is what operator
05:39 - now see is there anything in the step no
05:41 - directly push it now we have Q in this
05:45 - prefix expression only now we have P
05:48 - nothing to push in the staff directly
05:50 - right down here print it right now we
05:53 - have a strict operator or multiplication
05:56 - operator you can say now check if in
05:59 - staff I have plus of the stat is this
06:01 - one now we are going to check the
06:03 - precedence see now the if the incoming
06:06 - operator is having higher precedence
06:09 - then the top of the step then what you
06:12 - will do simply push this operator here
06:15 - means plus into and here we have Q P now
06:21 - next is V so no need to write down
06:24 - anything in the staff directly write
06:26 - down this one here next is divine now
06:30 - see check out the top of the stack is
06:32 - multiplication right and precedence of
06:35 - this and this divide and multiply
06:37 - having same precedence in that case
06:40 - check out the associativity now
06:41 - associativity of this is what left to
06:45 - right so if associativity is left to
06:47 - right then simply push the incoming
06:51 - operator into the strength right but
06:55 - that is not a case in infix to postfix
06:57 - conversion in that case if associativity
06:59 - is left to right then pop out this one
07:02 - right and again check the incoming
07:05 - operator with the new top of the stack
07:07 - but here the rule is different because
07:09 - we are converting in fixed to prefix now
07:12 - right so now here we have Q T and V now
07:16 - we have u means simply write down here V
07:21 - you now again we have divided check out
07:24 - the top of the stack is having divided
07:25 - same precedence operator is there
07:27 - incoming operator is the same precedence
07:28 - of this operator now check out the
07:31 - society row little left to right
07:32 - in that case simply push it right and
07:36 - here I have Q tu ba u now next is after
07:42 - this one I have W now stack would be as
07:47 - a tease and here we will append this W
07:51 - right now asterisk now check out again
07:55 - same precedence associativity is also
07:57 - left to right no need to pop out no need
07:59 - to do anything simply push it into the
08:01 - stack right now after this see now I
08:06 - have closing parenthesis now in this
08:09 - case if you find any closing parenthesis
08:11 - simply put that parenthesis into the
08:14 - strength right in previous case in fixed
08:20 - to postfix what we have done if opening
08:22 - parenthesis is there then push it into
08:24 - the stack if closing parenthesis is
08:26 - there then pop out the stack one by one
08:29 - right till you reach till you find the
08:32 - opening parenthesis corresponding to
08:35 - that closing parenthesis but here the
08:36 - rule is different reverse now simply
08:39 - push it into the stack right now here we
08:42 - have now after this we have P no need to
08:46 - do anything sin
08:47 - we append this P here next is
08:52 - exponential now see here we have closing
08:56 - parentheses right so if any operator
09:00 - comes after this closing parenthesis
09:02 - simply push that into the stack no need
09:05 - to check out any parent any precedence
09:08 - right now simply push it after this we
09:15 - have au now directly you will write o
09:19 - here and the stack would be unaffected
09:23 - right after ona I have what opening
09:28 - parenthesis now in this case if you find
09:32 - any opening parenthesis if the that the
09:35 - next symbol is opening parenthesis then
09:37 - what you will do
09:38 - then from the stack pop out all the
09:41 - operators one by one right till you find
09:45 - the closing parenthesis corresponding to
09:48 - this opening parenthesis right here the
09:51 - rule is reverse now see we have top of
09:55 - the stack is having exponent so first of
09:58 - all pop out this one right next is what
10:03 - now we find closing parenthesis now stop
10:07 - no need to pop out anything right and no
10:10 - need to write down these parenthesis
10:11 - into the stack now the remaining stake
10:13 - is plus hystrix divided divided and
10:16 - history
10:17 - now after this we have plus so now next
10:20 - symbol is plus right now check out the
10:24 - top of the stack is Astrix and this you
10:27 - can say your multiplication this is
10:29 - having higher precedence and the
10:30 - incoming operator is having lower
10:32 - precedence then the operator which is at
10:34 - the top of the step then you cannot push
10:37 - it here first of all pop out this top of
10:40 - the stack right then again check this
10:43 - one with the new top of the stack now
10:45 - once you pop out this one and you will
10:48 - append this or you can say you can print
10:50 - it now after this one so now the prefix
10:53 - would be the prefix expression would be
10:55 - no multiplication we have formed out now
10:58 - in the staff in the stack I have
11:01 - if this is the incoming operator plus
11:03 - now again check the new talk of the
11:05 - snake is this one now again check the
11:06 - prefer the precedence
11:07 - still this is incoming operator is
11:10 - having lower precedence in the top of
11:12 - the stack so you cannot push it again
11:14 - pop right now we will pop out this one
11:17 - like this right now new top of the stack
11:21 - is this one again check but still the
11:23 - same precedence of this is higher so you
11:26 - cannot put here the plus again pop out
11:28 - of this one now check out with this one
11:31 - same plus is having lower precedence
11:33 - than the top of the stick then pop out
11:36 - this one also now in the stack I have
11:39 - plus now check out the precedence these
11:41 - are having same precedence now check out
11:42 - the associativity associativity is what
11:44 - left to right if left to right then no
11:46 - need to pop out this thing simply push
11:48 - the incoming operator now we have two
11:51 - plus in the step right now after this
11:54 - plus I have n so stack would be
11:56 - unaffected and here we will append this
12:00 - afternoon we have again is trick now
12:03 - this is humming multiplication is having
12:05 - higher precedence then the top of the
12:07 - stack right if higher precedence then
12:09 - you can simply push it and this
12:13 - expression would be same now after this
12:16 - one I have M so this is what operand no
12:19 - need to push anything in the step simply
12:22 - will append this into this expression
12:25 - now we have - now check out this one
12:29 - with the top of the stacks now here we
12:31 - have multiplication so now this incoming
12:34 - operator is having lower precedence than
12:37 - the top of the stack so you cannot push
12:39 - it what you need to do first of all pop
12:41 - out this thing this operator right so
12:44 - here we have now this one now in this
12:47 - trap I have plus and plus but again this
12:50 - is the new top of the stack again check
12:52 - out with this one now plus and minuses
12:54 - having same precedence check out the
12:56 - society that is left to right if left to
12:58 - right simply push this operator here the
13:01 - incoming operator into the staff now
13:03 - after that I have a so now this is
13:07 - operand simply append this one here
13:11 - after this I have plus now check out
13:14 - with this one here we have - both are
13:18 - having same precedence check out the
13:19 - society left to right simply if left to
13:22 - right simply push it now next is okay so
13:28 - in the stack I have this one and
13:30 - directly you will write down K here now
13:33 - you have reached till end of this
13:35 - expression now what you will do check
13:37 - out the strap and pop the stack pop out
13:41 - the operators from the stack till the
13:45 - stack becomes empty right now first of
13:48 - all pop out this plus now I am writing
13:51 - this here plus 4 pound this one after
13:56 - that minus then plus then plus right now
13:59 - stack is empty now stop so now see this
14:03 - is not done yet right now what you need
14:05 - to do you have to reverse this
14:08 - expression right so for reversing what
14:11 - you will do scan this from right to left
14:13 - plus and write down from here plus plus
14:16 - minus plus now this is the final prefix
14:20 - expression for this post
14:22 - the desam fixed expression now this is
14:25 - the conversion using stack now we will
14:27 - discuss conversion without stack right
14:30 - and we will compare our answer with this
14:32 - one whether we are getting getting the
14:34 - same answer or not fine see so now this
14:37 - has a given in fixed expression no need
14:39 - to convert it into that reverse and fix
14:41 - expression you need to reverse it
14:42 - say simply scan this one right and find
14:46 - out which operator is having higher
14:47 - precedence highest precedence so we know
14:50 - the parenthesis are having higher
14:51 - precedence right out of all the operator
14:54 - present here so fine
14:55 - so first of all solve this one convert
14:58 - this into prefix what should be the
15:00 - prefix here the sub operator should be
15:03 - before these operands so this this is
15:07 - not a prefix of this one so this is now
15:10 - one operand this complete will act as a
15:13 - oprand now next although this this is
15:16 - the operator which is having second
15:18 - highest but this thing we have already
15:20 - solved because this is within these
15:22 - parentheses this operator all right so
15:25 - now after this we have
15:27 - this multiplication and divide these are
15:30 - having higher precedence so now here
15:32 - both multiplication and divide both are
15:34 - having same precedence so check out the
15:36 - society were associating associativity
15:38 - is left to right now left to right means
15:41 - we will start scanning from left and
15:43 - this is the first multiplication so
15:46 - first of all you need to solve this one
15:49 - right so for this one for this operator
15:52 - you can see our parents are this one and
15:54 - this one so convert it into prefix first
15:57 - of all so for this one prefix is in
15:59 - second skin in first skin we have done
16:01 - this thing in second skin this would be
16:04 - MN now this is what complete operand 1
16:08 - opened right now stand this one from
16:11 - left to right because these are having
16:13 - left to right associativity right now
16:15 - another is this one fine so now you need
16:19 - to solve this one for this operator for
16:21 - prints are what see one operand is this
16:24 - one W another apprentice this one means
16:27 - after solving this one we have got this
16:30 - operand right so now one operand is this
16:33 - one one operand is this one right now
16:36 - how to convert this you can say this is
16:38 - something like this this is one operand
16:44 - this is another operand and this is what
16:46 - operator so the prefix of this one is
16:48 - Astrix then this operand opie then W
16:52 - this would be the case right so now here
16:55 - what you can write this one here you
16:57 - will write asterisk this is the operand
17:01 - and here you will write W right so this
17:03 - is not the complete operand so this is
17:05 - now complete or print roughly I am doing
17:07 - this thing I am NOT writing each for
17:09 - each scan right so that would be very
17:11 - lengthy now next is now after this one
17:16 - this from left to right this is the
17:19 - operator that is this divide we will
17:21 - solve this division right for this
17:23 - degrees in the operators sorry the
17:25 - operands are one is U and one operand is
17:29 - this complete operand right because
17:32 - after solving this this we have got so
17:34 - this is something like you can say write
17:36 - like this w and
17:38 - here we have this operator and here we
17:40 - have you so this is one operand this is
17:42 - another operant this is operator so for
17:44 - doing the prefix of this one you will do
17:47 - what this operator should be before
17:49 - these operands right so this is
17:51 - something like this here
17:53 - I hope you are getting this so this is
17:57 - now a complete operand so how you can
17:59 - write it right on this thing here here
18:02 - you will write down the wide and W and Q
18:06 - so now this is a complete orbit right
18:09 - this is another operator now next next
18:13 - is this one from left to right next we
18:15 - will find we have found this division
18:17 - operator for this division the
18:20 - operator the operands are one is we and
18:23 - one is this complete right so now this
18:27 - after this divide after this we write
18:31 - this is one operand this is another so
18:32 - have you will convert this into prefix
18:35 - simply put this operator before these
18:39 - opens means here you will put before
18:42 - this operand and here we will write
18:44 - tweak so now this is what a complete
18:48 - footprint and here we have hystrix
18:52 - him and this is another operand right
18:55 - now after this we have this
18:58 - multiplication operator right so now for
19:00 - this operator operands are one is T
19:02 - right and one is this complete operand
19:05 - so here you can say here we have Astrix
19:07 - and a way of T so when is this operand
19:09 - one is this one so put this operator
19:12 - before these operands to get a prefix
19:15 - for this expression so now here you will
19:18 - write istrict and here you write T so
19:21 - now this is this is a complete operand
19:24 - right now we are done we have solved all
19:27 - the multiplication and divide operators
19:31 - here now next precedence is of plus and
19:33 - minus but with a here we have multiple
19:36 - plus and minus so which one you will
19:38 - solve first same check the associativity
19:40 - associativity is left to right so scan
19:42 - this from left to right right stamp
19:44 - while scan you will get we are getting
19:46 - this plus first so you will solve this
19:48 - one first right so now for this Plus
19:51 - this is
19:52 - open this is the open one and two two
19:54 - opens are there so four prefix you will
19:56 - write here plus before this K and N and
19:59 - this is what a complete open now this is
20:02 - what another you can sell better we have
20:06 - found that is - no so now you will solve
20:08 - this - for this - now see for this - the
20:12 - operands are one is this complete and
20:16 - one is this one that is because this I
20:19 - have already converted into prefix that
20:20 - is this one so here you can say here we
20:23 - have - right for this - this is one
20:25 - operand this is another operand so you
20:27 - simply put this - before these operands
20:30 - so now this is what complete operand
20:33 - right now here now we have this + so
20:37 - solve this one for this plus C one
20:40 - operand is we have solved this one one
20:42 - operand is this complete right this
20:45 - complete for this plus and second is
20:49 - what second is what is this one up to P
20:51 - because we have solved till t plus we
20:54 - haven't solved right
20:55 - so now you can visualize it something
20:59 - like this this is one operand here after
21:02 - this we have plus and this has another
21:04 - oprand till P so how you will convert
21:06 - this put this plus before these operands
21:10 - so here we will write class right and
21:13 - after that these operands now we are
21:16 - left with this plus so here you can say
21:18 - this + n cube for this plus one operand
21:21 - is this complete right
21:23 - this complete from here to here and one
21:25 - is Q how will convert it into graphics
21:28 - simply put this plus before both the
21:31 - operands that is + you will write here
21:33 - and here simply will write Q so this is
21:38 - now the prefix expression for this
21:41 - inference without using stack and now we
21:43 - can compare this with this when I guess
21:45 - both are same so I guess you have
21:47 - analyzed now that for getting this
21:50 - prefix from this in fix expression using
21:53 - this approach without using stack you
21:54 - need to or you can see the compiler need
21:56 - to scan this infix expression multiple
21:59 - times it's not like that in one scan
22:01 - only you can get this prefix as I guess
22:03 - you have analyzed here
22:04 - but in when you are using stack in that
22:07 - case compiler need to scan only once
22:09 - this expression from left to right right
22:11 - so now it's up to you which approach
22:14 - you're going to follow so now I guess no
22:16 - need to write down the rules here
22:18 - because if you get it how to convert
22:21 - this into this you can write down the
22:23 - steps because obviously I am going to
22:25 - write down the steps only and if you
22:27 - know how to convert it right so you can
22:29 - easily write down those steps
22:31 - first of all reverse this infix
22:32 - expression right then scan it from left
22:35 - to right if operand is there simply
22:38 - printed if operator is there then what
22:40 - you will check out the stack if stack is
22:42 - empty or in the stack we have closing
22:45 - parenthesis right then simply push the
22:48 - dot operator into the stack right if
22:50 - that is not the case if spec is not
22:52 - empty then check out the precedence of
22:54 - the incoming operator if the precedence
22:56 - of incoming operator is higher than the
22:59 - precedence of the top of the stack then
23:01 - simply push the incoming operator into
23:03 - the stack right but second another rule
23:07 - is what if the precedence of incoming
23:09 - operator is less then the operator which
23:12 - is present at the top of the step then
23:14 - what we will do pop from the stack and
23:16 - print it again check the incoming
23:19 - operator with the new top of the stack
23:21 - right and if presidents of both operator
23:25 - the incoming operator and the top of the
23:27 - stack operator is same then check out
23:28 - the associativity rule right
23:30 - if associativity is left to right simply
23:32 - push the incoming operator into the
23:34 - stack if associativity is right to left
23:36 - then first of all pop from the strap and
23:39 - then again check the incoming operator
23:41 - with the new top of the stack right
23:43 - something like this I guess you can
23:44 - easily write down these rules no need to
23:46 - write on these rules here and after that
23:48 - yes one more thing is important point is
23:50 - what after getting this thing you need
23:52 - to reverse this expression also now this
23:54 - is the final your you can say that
23:57 - prefix expression fine so now next video
23:59 - and discuss with you about binary search
24:01 - trees right cells in the next video tell
24:03 - them of why I take

Cleaned transcript:

so in this lecture we are going to see how to convert infix expression into prefix expression in the previous video I have discussed the infix to postfix conversion using step now we will see the in fixed to prefix conversion using stack right see here also without stack you can convert from in fixed to prefix like we have discussed in the previous case see let us take this example I have same example I am taking that I have taken in the previous video right so here also you should know the precedence and associativity of the operators this is the prerequisite of this video okay right now we are going to follow those precedence and associativity rules first of all see check out the precedence of these operators which one is higher precedence this multiplication is having higher precedence right so first of all you need to solve this expression that is B into C see these are what operands this is what operator right now prefix expression means if this is B into C means these are operands this is what operator in prefix this operator should be before these or prints in postfix this operator should be after these operands pre means per la Poste means both me you can relate it with prepaid mobile and post paid mobile right and in fixed means this operator is in between these operands that is in fixed expression so this is what in fixed expression now this it is so this is higher so first of all you are you have to solve this one so prefix of this is what estwick B into C right now this says what one operand now we have plus this operator and this is what another operand this operand this open we have two operand and in between these open we have now plus this is what operator now we are going to solve for this one because I have left with only one operator now now for prefix this operator should be before these these operands a and second operand is this one means Asterix B si right so this is what you can say a prefix for the syntax right in this case also in first scan this will be solved in second sense scan again we will solve for this + right so this there are multiple scans to solve this problem without using staff now here in this case I am solving this this is a smaller expression if this is the expression then here multiple scans would be there may be 10 or maybe 20 15 I cannot say right now rather than scanning it multiple times because this process is you know very timeconsuming process very lengthy process so we should follow a method in which we scan only once from here to here and after reaching at the end of this expression we will get our output you can say we will get our prefix expression we don't need to scan this expression multiple times right so that is that would be what efficient algorithm so that is possible using stamp that is why here I will discuss with you conversion of in fixed to prefix we using stack we will also discuss to tell you our answer we will also discuss how you can convert this expression without using step at last first of all I will convert this after that I will write down all the rules here only so now this conversion is also same almost same as the infix to postfix conversion but the difference is what first of all you need to reverse this in fixed conversion if you are converting this input prefix in that case only right so first of all reverse this one means we will start writing from here so here we have Q so here you write Q then after that plus T multiplication we then divide then you then divide then W then again multiplication now this is what closing parenthesis so here also I am writing closing parenthesis right now this is what the reverse of this in fixed expression now somewhere it is written that here in the in fixed in the reverse of the same fix convert sorry reverse these parentheses also if this is closing parentheses in the in fix here write down it as opening and here write down it as closing like this but here I'm not going to follow that process right that is also fine you can do something like this after that convert this into postfix and after that reverse that postfix expression but I am NOT going to do this I'm going to follow the second approach right this is now our reverse in fix expression now see same we are going to take one step if operator that will be found then we are using stack for pushing those operators and if operand is there then directly we are going to print those up cooperates right now now scan this reverse in fix expression from left to right you can scan it from right to left also and after that also you can get the prefix expression so there are many ways to or three ways to convert infix to prefix right this is one of all the possible ways right now here we have Q so we are not going to push anything into the stack if operand is there directly print it fine next plus this is what operator now see is there anything in the step no directly push it now we have Q in this prefix expression only now we have P nothing to push in the staff directly right down here print it right now we have a strict operator or multiplication operator you can say now check if in staff I have plus of the stat is this one now we are going to check the precedence see now the if the incoming operator is having higher precedence then the top of the step then what you will do simply push this operator here means plus into and here we have Q P now next is V so no need to write down anything in the staff directly write down this one here next is divine now see check out the top of the stack is multiplication right and precedence of this and this divide and multiply having same precedence in that case check out the associativity now associativity of this is what left to right so if associativity is left to right then simply push the incoming operator into the strength right but that is not a case in infix to postfix conversion in that case if associativity is left to right then pop out this one right and again check the incoming operator with the new top of the stack but here the rule is different because we are converting in fixed to prefix now right so now here we have Q T and V now we have u means simply write down here V you now again we have divided check out the top of the stack is having divided same precedence operator is there incoming operator is the same precedence of this operator now check out the society row little left to right in that case simply push it right and here I have Q tu ba u now next is after this one I have W now stack would be as a tease and here we will append this W right now asterisk now check out again same precedence associativity is also left to right no need to pop out no need to do anything simply push it into the stack right now after this see now I have closing parenthesis now in this case if you find any closing parenthesis simply put that parenthesis into the strength right in previous case in fixed to postfix what we have done if opening parenthesis is there then push it into the stack if closing parenthesis is there then pop out the stack one by one right till you reach till you find the opening parenthesis corresponding to that closing parenthesis but here the rule is different reverse now simply push it into the stack right now here we have now after this we have P no need to do anything sin we append this P here next is exponential now see here we have closing parentheses right so if any operator comes after this closing parenthesis simply push that into the stack no need to check out any parent any precedence right now simply push it after this we have au now directly you will write o here and the stack would be unaffected right after ona I have what opening parenthesis now in this case if you find any opening parenthesis if the that the next symbol is opening parenthesis then what you will do then from the stack pop out all the operators one by one right till you find the closing parenthesis corresponding to this opening parenthesis right here the rule is reverse now see we have top of the stack is having exponent so first of all pop out this one right next is what now we find closing parenthesis now stop no need to pop out anything right and no need to write down these parenthesis into the stack now the remaining stake is plus hystrix divided divided and history now after this we have plus so now next symbol is plus right now check out the top of the stack is Astrix and this you can say your multiplication this is having higher precedence and the incoming operator is having lower precedence then the operator which is at the top of the step then you cannot push it here first of all pop out this top of the stack right then again check this one with the new top of the stack now once you pop out this one and you will append this or you can say you can print it now after this one so now the prefix would be the prefix expression would be no multiplication we have formed out now in the staff in the stack I have if this is the incoming operator plus now again check the new talk of the snake is this one now again check the prefer the precedence still this is incoming operator is having lower precedence in the top of the stack so you cannot push it again pop right now we will pop out this one like this right now new top of the stack is this one again check but still the same precedence of this is higher so you cannot put here the plus again pop out of this one now check out with this one same plus is having lower precedence than the top of the stick then pop out this one also now in the stack I have plus now check out the precedence these are having same precedence now check out the associativity associativity is what left to right if left to right then no need to pop out this thing simply push the incoming operator now we have two plus in the step right now after this plus I have n so stack would be unaffected and here we will append this afternoon we have again is trick now this is humming multiplication is having higher precedence then the top of the stack right if higher precedence then you can simply push it and this expression would be same now after this one I have M so this is what operand no need to push anything in the step simply will append this into this expression now we have now check out this one with the top of the stacks now here we have multiplication so now this incoming operator is having lower precedence than the top of the stack so you cannot push it what you need to do first of all pop out this thing this operator right so here we have now this one now in this trap I have plus and plus but again this is the new top of the stack again check out with this one now plus and minuses having same precedence check out the society that is left to right if left to right simply push this operator here the incoming operator into the staff now after that I have a so now this is operand simply append this one here after this I have plus now check out with this one here we have both are having same precedence check out the society left to right simply if left to right simply push it now next is okay so in the stack I have this one and directly you will write down K here now you have reached till end of this expression now what you will do check out the strap and pop the stack pop out the operators from the stack till the stack becomes empty right now first of all pop out this plus now I am writing this here plus 4 pound this one after that minus then plus then plus right now stack is empty now stop so now see this is not done yet right now what you need to do you have to reverse this expression right so for reversing what you will do scan this from right to left plus and write down from here plus plus minus plus now this is the final prefix expression for this post the desam fixed expression now this is the conversion using stack now we will discuss conversion without stack right and we will compare our answer with this one whether we are getting getting the same answer or not fine see so now this has a given in fixed expression no need to convert it into that reverse and fix expression you need to reverse it say simply scan this one right and find out which operator is having higher precedence highest precedence so we know the parenthesis are having higher precedence right out of all the operator present here so fine so first of all solve this one convert this into prefix what should be the prefix here the sub operator should be before these operands so this this is not a prefix of this one so this is now one operand this complete will act as a oprand now next although this this is the operator which is having second highest but this thing we have already solved because this is within these parentheses this operator all right so now after this we have this multiplication and divide these are having higher precedence so now here both multiplication and divide both are having same precedence so check out the society were associating associativity is left to right now left to right means we will start scanning from left and this is the first multiplication so first of all you need to solve this one right so for this one for this operator you can see our parents are this one and this one so convert it into prefix first of all so for this one prefix is in second skin in first skin we have done this thing in second skin this would be MN now this is what complete operand 1 opened right now stand this one from left to right because these are having left to right associativity right now another is this one fine so now you need to solve this one for this operator for prints are what see one operand is this one W another apprentice this one means after solving this one we have got this operand right so now one operand is this one one operand is this one right now how to convert this you can say this is something like this this is one operand this is another operand and this is what operator so the prefix of this one is Astrix then this operand opie then W this would be the case right so now here what you can write this one here you will write asterisk this is the operand and here you will write W right so this is not the complete operand so this is now complete or print roughly I am doing this thing I am NOT writing each for each scan right so that would be very lengthy now next is now after this one this from left to right this is the operator that is this divide we will solve this division right for this degrees in the operators sorry the operands are one is U and one operand is this complete operand right because after solving this this we have got so this is something like you can say write like this w and here we have this operator and here we have you so this is one operand this is another operant this is operator so for doing the prefix of this one you will do what this operator should be before these operands right so this is something like this here I hope you are getting this so this is now a complete operand so how you can write it right on this thing here here you will write down the wide and W and Q so now this is a complete orbit right this is another operator now next next is this one from left to right next we will find we have found this division operator for this division the operator the operands are one is we and one is this complete right so now this after this divide after this we write this is one operand this is another so have you will convert this into prefix simply put this operator before these opens means here you will put before this operand and here we will write tweak so now this is what a complete footprint and here we have hystrix him and this is another operand right now after this we have this multiplication operator right so now for this operator operands are one is T right and one is this complete operand so here you can say here we have Astrix and a way of T so when is this operand one is this one so put this operator before these operands to get a prefix for this expression so now here you will write istrict and here you write T so now this is this is a complete operand right now we are done we have solved all the multiplication and divide operators here now next precedence is of plus and minus but with a here we have multiple plus and minus so which one you will solve first same check the associativity associativity is left to right so scan this from left to right right stamp while scan you will get we are getting this plus first so you will solve this one first right so now for this Plus this is open this is the open one and two two opens are there so four prefix you will write here plus before this K and N and this is what a complete open now this is what another you can sell better we have found that is no so now you will solve this for this now see for this the operands are one is this complete and one is this one that is because this I have already converted into prefix that is this one so here you can say here we have right for this this is one operand this is another operand so you simply put this before these operands so now this is what complete operand right now here now we have this + so solve this one for this plus C one operand is we have solved this one one operand is this complete right this complete for this plus and second is what second is what is this one up to P because we have solved till t plus we haven't solved right so now you can visualize it something like this this is one operand here after this we have plus and this has another oprand till P so how you will convert this put this plus before these operands so here we will write class right and after that these operands now we are left with this plus so here you can say this + n cube for this plus one operand is this complete right this complete from here to here and one is Q how will convert it into graphics simply put this plus before both the operands that is + you will write here and here simply will write Q so this is now the prefix expression for this inference without using stack and now we can compare this with this when I guess both are same so I guess you have analyzed now that for getting this prefix from this in fix expression using this approach without using stack you need to or you can see the compiler need to scan this infix expression multiple times it's not like that in one scan only you can get this prefix as I guess you have analyzed here but in when you are using stack in that case compiler need to scan only once this expression from left to right right so now it's up to you which approach you're going to follow so now I guess no need to write down the rules here because if you get it how to convert this into this you can write down the steps because obviously I am going to write down the steps only and if you know how to convert it right so you can easily write down those steps first of all reverse this infix expression right then scan it from left to right if operand is there simply printed if operator is there then what you will check out the stack if stack is empty or in the stack we have closing parenthesis right then simply push the dot operator into the stack right if that is not the case if spec is not empty then check out the precedence of the incoming operator if the precedence of incoming operator is higher than the precedence of the top of the stack then simply push the incoming operator into the stack right but second another rule is what if the precedence of incoming operator is less then the operator which is present at the top of the step then what we will do pop from the stack and print it again check the incoming operator with the new top of the stack right and if presidents of both operator the incoming operator and the top of the stack operator is same then check out the associativity rule right if associativity is left to right simply push the incoming operator into the stack if associativity is right to left then first of all pop from the strap and then again check the incoming operator with the new top of the stack right something like this I guess you can easily write down these rules no need to write on these rules here and after that yes one more thing is important point is what after getting this thing you need to reverse this expression also now this is the final your you can say that prefix expression fine so now next video and discuss with you about binary search trees right cells in the next video tell them of why I take
