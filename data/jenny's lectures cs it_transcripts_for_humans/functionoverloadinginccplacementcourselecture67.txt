With timestamps:

00:00 - hey everyone I hope you are safe and
00:02 - doing good so in the series of learning
00:03 - C++ programming language we're
00:05 - discussing functions in C++ in previous
00:07 - video we have seen what are default
00:08 - arguments right how to use how to pass
00:10 - default arguments uh in functions so the
00:13 - next topic is function
00:15 - overloading this is also uh an important
00:18 - feature of functions right basically we
00:21 - have uh four oops uh concept or four
00:24 - oops pillars we can say abstraction
00:27 - classes and uh objects encapsulation and
00:31 - polymorphism that we'll see in detail in
00:33 - later videos right so this overloading
00:35 - is a part of polymorphism right we'll
00:38 - discuss in brief what are function
00:39 - overloading how to use how to achieve
00:41 - function overloading with help of
00:43 - program right but polymorphism we will
00:45 - see in later videos when we're
00:47 - discussing uh oops concept right so now
00:51 - see in this video we'll
00:52 - see what are basically why function
00:55 - overloading need of function overloading
00:58 - this thing is important if you
01:00 - studying any concept then what is need
01:02 - of that concept that feature right that
01:05 - is important so this thing we'll see in
01:07 - this video right now see you know what
01:10 - are function how to declare function how
01:11 - to define how to call function Basics
01:13 - are clear to you guys right see if I
01:16 - write something like this so now you can
01:19 - differentiate like this is function
01:21 - prototype or function declaration this
01:23 - is function calling and this is function
01:26 - definition right now if in your program
01:30 - you have two or more function with same
01:33 - name like in my program I have display
01:35 - one more function I have
01:36 - display right name is same but
01:40 - parameters you are passing those are
01:42 - different maybe the data type of
01:44 - parameter is different or maybe number
01:45 - of parameters are different right that
01:48 - thing is known as function
01:51 - overloading right see let me show you if
01:53 - in my program I have one more function
01:56 - display and here I have like string
02:02 - so in my program I have two functions
02:05 - with same name display display but
02:07 - parameters are different here I'm
02:09 - passing int here I'm passing string so
02:11 - obviously definition will be different
02:13 - here void display string Str Str and
02:16 - they see out I'll uh display St Str
02:18 - right and whenever you call then display
02:20 - maybe you'll pass next gen so while
02:23 - calling this I'll pass J A
02:27 - String this is a c style string this is
02:30 - also
02:31 - fine this is uh accepting uh expecting a
02:36 - C++ string like the string object but
02:39 - you are passing C style string a string
02:41 - lateral that is also fine it will be
02:43 - converted to C++ style string or a
02:46 - string object also you can pass right
02:48 - and same the definition is also some
02:52 - something different from this like
02:55 - string variable name is Str Str and I'm
02:57 - just printing here C out St Str
03:01 - right so in one program in the same
03:04 - scope or in one program I have two
03:06 - functions with same name but parameters
03:08 - are different so this is function
03:10 - overloading so why you need function
03:12 - overloading see sometimes if you want to
03:14 - display or if you want to print integer
03:16 - value suppose two I also want to print
03:19 - Jenny then I want to print like maybe
03:22 - 10.2 or double value or a character
03:24 - value also sometimes right so rather
03:29 - than
03:30 - taking different different function name
03:32 - like for printing integer I will take
03:36 - maybe print int and here the function
03:40 - the argument then print
03:43 - double then print
03:47 - string print character so you have to
03:51 - take four different names right and you
03:54 - have to remember like these four
03:56 - different names and all so rather than
03:58 - this using function overloading we can
04:01 - take only single name that is print
04:04 - print only
04:07 - right
04:08 - and if you want to print integer you
04:11 - just pass your int if you want to print
04:13 - string you just pass your string if you
04:15 - want to print double just print uh pass
04:18 - double as an argument and that's it
04:20 - right so function name is same but we
04:23 - will Define here for these four things
04:26 - four different functions right but fun
04:29 - function name would be same only the
04:32 - different uh difference is in the type
04:35 - of the argument or the type of the
04:38 - parameter you take for this we will take
04:40 - int for this we will take string here
04:42 - for this we will take double here for
04:44 - this we will take here
04:46 - character right so this is like the
04:49 - program would be more readable rather
04:51 - than having four different name just
04:53 - take one simple same name so program
04:57 - would be more readable and maintainable
04:59 - and it will increase the reusability of
05:02 - the program as well right that is why we
05:04 - use function overloading so you don't
05:06 - have to rather than you don't have to
05:08 - remember the user you don't have to
05:10 - remember the exact name for the
05:11 - functions because name is same only the
05:14 - argument you pass that is different and
05:16 - the
05:17 - compiler will automatically call the
05:21 - best match I mean at compile time the
05:23 - compiler chooses which which function
05:27 - overloads to call based sh the type and
05:31 - the number of argument you pass right
05:34 - that is had of compiler that will choose
05:37 - right out of suppose here we have
05:39 - display so if I call this display two so
05:42 - the compiler chooses which function to
05:44 - call this int based on the type of
05:48 - parameter if this is the function
05:50 - calling so at this time compiler will
05:52 - choose which function to call this
05:54 - function based on the argument the type
05:57 - of argument you pass that is uh string
05:59 - so it will will call this not this right
06:02 - you don't have to remember the exact
06:03 - name maybe here you have to take like
06:05 - display int display
06:07 - string so rather than remembering
06:10 - different different name you just have
06:12 - to remember only one name same name
06:14 - display that is you can say advantage of
06:16 - using function overloading right now the
06:20 - function overloading we can achieve in
06:22 - three forms based on the number of
06:25 - parameter you passed based on the type
06:26 - of parameter you passed and based on the
06:28 - order of the parameters you passed right
06:32 - remember this if if you write something
06:35 - like this right if I like here in fun
06:39 - and void fun maybe you think this is
06:43 - function overloading because return type
06:45 - of the function is different
06:47 - no we cannot achieve function
06:49 - overloading based on the function return
06:51 - time this this will give
06:54 - er only you can achieve only you can
06:56 - differentiate the function only you can
06:58 - achieve the function overload
07:00 - based on the parameter list either the
07:02 - number of parameter or the type of
07:04 - parameter or the order of parameter
07:05 - sequence of parameter not with the
07:08 - return type of the function this you
07:10 - have to remember this is not function
07:12 - overloading this will give error right
07:14 - so now let me show you all these things
07:16 - how to achieve function overloading with
07:18 - the help of program so first we will
07:21 - see overloading using different type of
07:25 - parameters right okay now let's take two
07:29 - two function void suppose we have
07:31 - function
07:33 - display and one I'm taking same name
07:39 - display with
07:41 - the
07:43 - string data type right so if you're
07:46 - using string better to include that
07:50 - header
07:52 - string okay one is display okay here int
07:59 - int and string the name of the parameter
08:02 - is optional you can pass because this is
08:03 - just
08:04 - function declaration and after main
08:07 - suppose I'm defining this
08:09 - function
08:10 - display for INT so int a here in
08:14 - definition name of the variable is
08:16 - compulsory so in a I'm taking
08:19 - and just passing just you know printing
08:23 - here whatever the value right that's it
08:29 - and
08:31 - for second display I'll take string
08:34 - maybe St Str and here just display that
08:37 - whatever string you
08:40 - pass so while calling let's call this
08:45 - display I'll call this display and in
08:49 - second one I will just pass J
09:03 - okay so we are having here two function
09:06 - with same name but different
09:08 - differentials the type of parameter you
09:12 - pass in one I'm passing INT in second
09:14 - I'm passing string so whenever the
09:17 - control will go to main function the
09:19 - first is display three So based on the
09:21 - type of the parameter the compiler
09:22 - chooses which function to call this
09:24 - function because here the type is the
09:27 - argument you are passing is integer so
09:29 - in a this function would be called let's
09:32 - run this and I'll show you what output
09:35 - you will get here see printing int value
09:37 - let me just clear the previous output
09:40 - and printing integer value three
09:42 - printing string value
09:43 - gen right so this is how we can achieve
09:46 - overloading based on the different type
09:48 - of parameter now number of parameter you
09:51 - can achieve function overloading using
09:54 - different you know sorry the different
09:56 - number of parameters so let's take one
09:59 - more thing here suppose we are taking
10:01 - one more example here I'm taking
10:04 - function add and in one I'm
10:08 - passing three parameter and second I'm
10:12 - passing two two and three see the
10:15 - parameter type is same data type int int
10:18 - but number of parameter are different so
10:20 - this is also this is how also we can
10:22 - achieve function overloading right based
10:25 - on different number of parameters type
10:27 - is same doesn't matter
10:30 - numbers are different right so here I'll
10:33 - just pass two and three only two and for
10:36 - second I'll pass 2 comma 3A
10:41 - 4 okay now this is just Declaration of
10:44 - the function let's define these
10:47 - functions okay see now whenever you call
10:52 - this add 2 three so the compiler will
10:54 - call this one the number of parameter
10:56 - are two so this function would be called
10:58 - right when you you write this at 2 3 4
11:01 - then at this time compiler chooses to
11:03 - call this function ABC with three
11:07 - parameters so let's run this and see
11:09 - what output you will get here five and N
11:12 - yeah this is also function overloading
11:14 - right plus you can acheve overloading
11:17 - with uh that different sequence of
11:21 - parameters so if I take here like int
11:25 - one
11:25 - more add and there I'm taking int and
11:28 - one is
11:32 - double this is also function overloading
11:35 - right so if I call here add suppose
11:38 - first I'm passing three then
11:45 - 10.4 this will not give any error sorry
11:49 - point it's
11:50 - 10.4 right and suppose one more
11:55 - definition void add
12:11 - let's run this and I'll show you what
12:12 - output you will get here see three
12:14 - output 13.4 as well right and if I take
12:18 - here
12:19 - void
12:22 - add first is double second is
12:26 - in let's comment out previous
12:37 - to so here int double and here number of
12:40 - parameter type of parameter both are
12:42 - same but sequence is different in first
12:44 - one I passing int and after that double
12:47 - but in second I'm passing first double
12:49 - then int so this is also function
12:51 - overloading right this will also work
12:54 - fine so let's just comment out these two
12:57 - function definition
13:04 - and just call add now first is 34 Point
13:08 - suppose 5 and second is
13:11 - 1
13:12 - s right if you do not Define the second
13:17 - function I just Define one int a and
13:20 - this also this one only right not
13:25 - this so let's run this and I'll show you
13:27 - what output you will get see see 13.4
13:30 - and
13:31 - 35 why so because why calling this it's
13:34 - okay we are calling like this function
13:36 - in a and double so a plus b it will do
13:39 - 13.4 in second case first was we are
13:43 - passing double value and here it is
13:46 - expecting an INT value so it's okay it
13:48 - will do automatically type conversion
13:49 - the truncation of its 0.5 so it will
13:53 - take only 34 34 would be assigned to
13:55 - this int and it double one would be
13:57 - assigned so it will give 35
14:00 - right so if exact match doesn't f
14:04 - doesn't found the compiler is not able
14:05 - to find the exact match so it will find
14:07 - the best possible match type conversion
14:10 - would be done right according to that
14:12 - the best possible match would be find
14:14 - the best possible matches this one only
14:16 - because double would be truncated to int
14:20 - right but if I have here the exact match
14:25 - double and int let's define this second
14:28 - one also
14:29 - so this is the exact match so in this
14:31 - case it will give
14:33 - 35 uh like 35.5
14:38 - 35.5 so it is finding exact match so
14:41 - this function would be called right okay
14:44 - now order of sequence of this parameter
14:47 - can also be used for overloading so some
14:48 - rules are to achieve function
14:50 - overloading first one the function name
14:52 - should be same or I can say must be same
14:55 - function name second thing the the this
14:59 - uh the type of parameters must be
15:02 - different or number of parameters must
15:06 - be different or sequence of parameters
15:09 - must be
15:10 - different right otherwise it will give
15:12 - error or let me just show you one more
15:14 - example here see here I have void print
15:18 - in print see function name is same
15:21 - return type is different right so here
15:24 - void print I'm just printing high in int
15:27 - print I'm just returning a right I'm
15:29 - just calling print here and for this int
15:33 - because it is returning integer value so
15:34 - I will accept that value in a variable
15:37 - of type integer that is X print this and
15:40 - see out X right but it will give error
15:42 - see the red line cannot overload
15:44 - functions distinguished by return type
15:47 - alone right here only the difference is
15:50 - return type is different everything is
15:52 - same but this is how you cannot achieve
15:54 - function
15:55 - overloading right at least the parameter
16:00 - should be maybe the number of parameter
16:01 - should be different type of parameter
16:02 - should be different or the order of
16:04 - parameter should be different then you
16:06 - can achieve function overloading right
16:08 - so function return type is not you know
16:11 - the single factor with that you can
16:13 - achieve function overloading this you
16:15 - need to remember right
16:17 - now third thing we have discussed uh all
16:21 - the three ways to achieve function
16:22 - overring but here you can have some
16:26 - ambiguities while you know doing this
16:28 - while ACH function overloading now some
16:31 - causes ofun that ambiguities are maybe
16:34 - the type conversion maybe you are using
16:36 - function with default argument maybe you
16:37 - are using function with pass by
16:39 - reference three reason can be there for
16:42 - that ambiguity you get right so let me
16:45 - just tell you this thing with example
16:47 - first if you have because of type
16:50 - conversion you can get function
16:51 - ambiguity let me just show you this
16:53 - thing with example see here I have one
16:55 - example there I have function print
16:59 - in this I'm passing
17:01 - INT in void print I'm passing float in
17:05 - print I'm passing string three print I
17:07 - have right and this is the definition
17:11 - for integer I'm just printing a for
17:14 - string the string value whatever you
17:15 - pass for float whatever float value you
17:17 - pass that would be printed so while
17:19 - calling I'm just passing first print 10
17:23 - so ideally according to us it should
17:25 - call like 10 is integer value so this in
17:29 - so it will print print integer value a
17:31 - 10.2 this is float value so it should
17:33 - call this float so printing this
17:37 - printing double value D and it should
17:39 - print 10.2 right and third if I call
17:42 - like print and Jenny or rather than C
17:47 - style string if I take here
17:50 - one string object Str Str is equal to
17:54 - jeny and that object sorry
17:57 - not 8 also you can use but let's take a
18:01 - meaningful name s Str and here just pass
18:04 - print s Str an object string object C++
18:07 - string object right so it should call
18:09 - this and it should print s strj but it
18:12 - will give an error to you guys let me
18:15 - show you that
18:17 - error okay this is not the exact
18:20 - error this is the error call of
18:23 - overloaded print double is
18:26 - ambiguous here 10.
18:29 - because in C++ all the floating Point
18:32 - number are treated as
18:34 - double right not float double by default
18:39 - right so there is type conversion from
18:42 - float to double so it is considering
18:44 - like 10.2 is not float it's double right
18:47 - so the exit match the compiler wants to
18:50 - call so but there is no double here int
18:53 - float string we are passing float here
18:55 - int here string here not double so
18:57 - there's no exact match found so compiler
19:00 - will call now the best possible match
19:03 - right so now this double can be treated
19:07 - as a float as well as truncated and
19:10 - treated as
19:12 - ink right so that is why this this error
19:17 - you are getting this call Print double
19:22 - in line number 15 is ambiguous right it
19:25 - can call the Sprint also it can call the
19:27 - Sprint float also so a compiler doesn't
19:31 - know which one to call either this or
19:33 - this so that is why it is giving
19:36 - ambiguous see while you're dragging your
19:39 - mouse to here then more than one
19:41 - instance of overload function print
19:43 - matches the argument list this also and
19:46 - this also con and floting but if you if
19:50 - you write here rather than float
19:54 - double so this is the exact match here
19:57 - rather than float
20:01 - double this will not give any
20:03 - error 10.2 is considered as double by
20:06 - default in C++ yeah we have this a print
20:09 - function with a double parameter so it
20:12 - will exactly match it is going to find
20:16 - and it will just print 10.2 integer
20:19 - value 10 10.2 string value
20:22 - J so while using function overloading
20:25 - you need to be very careful of these
20:27 - implicitly type conver type of thing
20:30 - right otherwise you will get error this
20:32 - is a drawback of using function
20:33 - overloading you have to be very careful
20:36 - second is if you're using function with
20:38 - default arguments let me show you that
20:40 - example also see one example we have
20:42 - here we have two function add and add in
20:44 - one I'm passing int int two parameter
20:47 - I'll pass two argument and in second I
20:49 - have int int int three parameter but one
20:52 - is default I'm taking one default if you
20:54 - will not pass anything then third
20:55 - argument it will take zero so here I'm
20:58 - passing default argument but in this
20:59 - case it will give error see while
21:02 - calling this add 2 three or let me just
21:05 - comment out these things two and three
21:08 - here you see red line more than one
21:10 - instance of overloaded function ad
21:12 - matches the argument list this one is
21:14 - also matches this one is also matches
21:16 - now which one to call function is the
21:18 - compiler doesn't know is not able to
21:20 - decide which one to call let me just run
21:22 - this and show you see the call of
21:25 - overloaded function add in in is
21:27 - ambiguous
21:29 - right because you are passing only two
21:31 - argument so this is matching with this
21:34 - also in ab and with this also because in
21:37 - this case also you are passing only two
21:39 - argument you will pass so by default the
21:41 - third argument it will take zero so
21:43 - third argument here it will take zero
21:45 - right so this is also ambiguity type of
21:48 - thing right so while using default
21:52 - arguments also you have to be very
21:53 - careful you can get this type of
21:55 - ambiguity error you got this right third
21:58 - thing if you use function with by uh
22:01 - with pass by reference in that case also
22:04 - you can get ambig error let me show you
22:05 - that thing also see here we have two
22:08 - function one is fun there will will pass
22:11 - int and another is fun they will passing
22:13 - like int and M per pass by reference we
22:15 - have discussed call by variable call by
22:17 - reference right call by reference we can
22:19 - achieve with by two ways like either
22:21 - using reference variable or using
22:22 - pointers here we are using reference
22:24 - variable right please watch out that
22:26 - video first if you are not aware about
22:28 - what is call by reference call call by
22:30 - value and what is reference variable so
22:33 - in in main so we have defined these two
22:35 - function fun there we passing just int a
22:38 - integer uh value I'm just printing a and
22:42 - here reference variable you are creating
22:44 - int h perent b and just we are calling B
22:48 - right and while calling we have int X is
22:51 - equal to 6 and we are just calling we're
22:53 - passing X here so like six we are
22:55 - passing so in this case also it is
22:57 - giving an ER like more than one instance
22:59 - of overloaded function fun matches the
23:02 - argument list this is also matching this
23:04 - is also matching so which function to
23:06 - call let me just run this and show you
23:08 - the output call of overloaded add in in
23:12 - okay let me just save this first and now
23:16 - run this see Call of overloaded fun in
23:21 - this m operator is ambiguous now
23:24 - compiler doesn't know which function to
23:25 - call because there is no syntactical
23:28 - difference between this fun in a and fun
23:31 - int m per B this is just reference
23:33 - variable reference variable means it's
23:35 - just an alas of the variable like
23:39 - whatever you will pass here x just
23:41 - another name right so this x this is
23:45 - also matching this is also matching in
23:48 - reference variable when you use then you
23:49 - simply pass here a variable not any
23:52 - address of variable or anything right so
23:55 - in this case also you are getting
23:56 - ambiguity error three reasons of of
23:58 - getting ambiguity error in while you are
24:01 - doing function overloading this thing
24:02 - you need to take care while you are
24:04 - doing function overloading in your
24:05 - program right so yeah we can say is this
24:08 - function overloading is a powerful
24:09 - feature in programming this will
24:11 - increase the readability of the code
24:13 - because you use only with only single
24:15 - function name you can achieve different
24:16 - different task you can do different
24:18 - different task based on the different
24:21 - parameters only right the function name
24:22 - is same so it increase the flexibility
24:24 - and reusability of your code right but
24:28 - obiously disadvantages are what you have
24:30 - to be more careful because there would
24:32 - be ambiguity error also so this thing
24:35 - you need to remember here right and
24:38 - compiler dependency also when you port
24:40 - your program from one compiler to
24:41 - another there maybe you can get some
24:43 - because of the some rules you get
24:45 - unpredictable results while you are you
24:48 - know achieving or doing function
24:50 - overloading in your program and
24:52 - debugging is also sometimes difficult
24:54 - because uh sometimes the error doesn't
24:56 - show exactly which function overload is
25:00 - causing that error so this is all about
25:02 - function overloading I hope you got this
25:04 - right so in the next video we'll see
25:05 - some coding exercise based on functions
25:07 - and function overloading right so now
25:10 - I'll see you in the next Tut bye take
25:12 - care

Cleaned transcript:

hey everyone I hope you are safe and doing good so in the series of learning C++ programming language we're discussing functions in C++ in previous video we have seen what are default arguments right how to use how to pass default arguments uh in functions so the next topic is function overloading this is also uh an important feature of functions right basically we have uh four oops uh concept or four oops pillars we can say abstraction classes and uh objects encapsulation and polymorphism that we'll see in detail in later videos right so this overloading is a part of polymorphism right we'll discuss in brief what are function overloading how to use how to achieve function overloading with help of program right but polymorphism we will see in later videos when we're discussing uh oops concept right so now see in this video we'll see what are basically why function overloading need of function overloading this thing is important if you studying any concept then what is need of that concept that feature right that is important so this thing we'll see in this video right now see you know what are function how to declare function how to define how to call function Basics are clear to you guys right see if I write something like this so now you can differentiate like this is function prototype or function declaration this is function calling and this is function definition right now if in your program you have two or more function with same name like in my program I have display one more function I have display right name is same but parameters you are passing those are different maybe the data type of parameter is different or maybe number of parameters are different right that thing is known as function overloading right see let me show you if in my program I have one more function display and here I have like string so in my program I have two functions with same name display display but parameters are different here I'm passing int here I'm passing string so obviously definition will be different here void display string Str Str and they see out I'll uh display St Str right and whenever you call then display maybe you'll pass next gen so while calling this I'll pass J A String this is a c style string this is also fine this is uh accepting uh expecting a C++ string like the string object but you are passing C style string a string lateral that is also fine it will be converted to C++ style string or a string object also you can pass right and same the definition is also some something different from this like string variable name is Str Str and I'm just printing here C out St Str right so in one program in the same scope or in one program I have two functions with same name but parameters are different so this is function overloading so why you need function overloading see sometimes if you want to display or if you want to print integer value suppose two I also want to print Jenny then I want to print like maybe 10.2 or double value or a character value also sometimes right so rather than taking different different function name like for printing integer I will take maybe print int and here the function the argument then print double then print string print character so you have to take four different names right and you have to remember like these four different names and all so rather than this using function overloading we can take only single name that is print print only right and if you want to print integer you just pass your int if you want to print string you just pass your string if you want to print double just print uh pass double as an argument and that's it right so function name is same but we will Define here for these four things four different functions right but fun function name would be same only the different uh difference is in the type of the argument or the type of the parameter you take for this we will take int for this we will take string here for this we will take double here for this we will take here character right so this is like the program would be more readable rather than having four different name just take one simple same name so program would be more readable and maintainable and it will increase the reusability of the program as well right that is why we use function overloading so you don't have to rather than you don't have to remember the user you don't have to remember the exact name for the functions because name is same only the argument you pass that is different and the compiler will automatically call the best match I mean at compile time the compiler chooses which which function overloads to call based sh the type and the number of argument you pass right that is had of compiler that will choose right out of suppose here we have display so if I call this display two so the compiler chooses which function to call this int based on the type of parameter if this is the function calling so at this time compiler will choose which function to call this function based on the argument the type of argument you pass that is uh string so it will will call this not this right you don't have to remember the exact name maybe here you have to take like display int display string so rather than remembering different different name you just have to remember only one name same name display that is you can say advantage of using function overloading right now the function overloading we can achieve in three forms based on the number of parameter you passed based on the type of parameter you passed and based on the order of the parameters you passed right remember this if if you write something like this right if I like here in fun and void fun maybe you think this is function overloading because return type of the function is different no we cannot achieve function overloading based on the function return time this this will give er only you can achieve only you can differentiate the function only you can achieve the function overload based on the parameter list either the number of parameter or the type of parameter or the order of parameter sequence of parameter not with the return type of the function this you have to remember this is not function overloading this will give error right so now let me show you all these things how to achieve function overloading with the help of program so first we will see overloading using different type of parameters right okay now let's take two two function void suppose we have function display and one I'm taking same name display with the string data type right so if you're using string better to include that header string okay one is display okay here int int and string the name of the parameter is optional you can pass because this is just function declaration and after main suppose I'm defining this function display for INT so int a here in definition name of the variable is compulsory so in a I'm taking and just passing just you know printing here whatever the value right that's it and for second display I'll take string maybe St Str and here just display that whatever string you pass so while calling let's call this display I'll call this display and in second one I will just pass J okay so we are having here two function with same name but different differentials the type of parameter you pass in one I'm passing INT in second I'm passing string so whenever the control will go to main function the first is display three So based on the type of the parameter the compiler chooses which function to call this function because here the type is the argument you are passing is integer so in a this function would be called let's run this and I'll show you what output you will get here see printing int value let me just clear the previous output and printing integer value three printing string value gen right so this is how we can achieve overloading based on the different type of parameter now number of parameter you can achieve function overloading using different you know sorry the different number of parameters so let's take one more thing here suppose we are taking one more example here I'm taking function add and in one I'm passing three parameter and second I'm passing two two and three see the parameter type is same data type int int but number of parameter are different so this is also this is how also we can achieve function overloading right based on different number of parameters type is same doesn't matter numbers are different right so here I'll just pass two and three only two and for second I'll pass 2 comma 3A 4 okay now this is just Declaration of the function let's define these functions okay see now whenever you call this add 2 three so the compiler will call this one the number of parameter are two so this function would be called right when you you write this at 2 3 4 then at this time compiler chooses to call this function ABC with three parameters so let's run this and see what output you will get here five and N yeah this is also function overloading right plus you can acheve overloading with uh that different sequence of parameters so if I take here like int one more add and there I'm taking int and one is double this is also function overloading right so if I call here add suppose first I'm passing three then 10.4 this will not give any error sorry point it's 10.4 right and suppose one more definition void add let's run this and I'll show you what output you will get here see three output 13.4 as well right and if I take here void add first is double second is in let's comment out previous to so here int double and here number of parameter type of parameter both are same but sequence is different in first one I passing int and after that double but in second I'm passing first double then int so this is also function overloading right this will also work fine so let's just comment out these two function definition and just call add now first is 34 Point suppose 5 and second is 1 s right if you do not Define the second function I just Define one int a and this also this one only right not this so let's run this and I'll show you what output you will get see see 13.4 and 35 why so because why calling this it's okay we are calling like this function in a and double so a plus b it will do 13.4 in second case first was we are passing double value and here it is expecting an INT value so it's okay it will do automatically type conversion the truncation of its 0.5 so it will take only 34 34 would be assigned to this int and it double one would be assigned so it will give 35 right so if exact match doesn't f doesn't found the compiler is not able to find the exact match so it will find the best possible match type conversion would be done right according to that the best possible match would be find the best possible matches this one only because double would be truncated to int right but if I have here the exact match double and int let's define this second one also so this is the exact match so in this case it will give 35 uh like 35.5 35.5 so it is finding exact match so this function would be called right okay now order of sequence of this parameter can also be used for overloading so some rules are to achieve function overloading first one the function name should be same or I can say must be same function name second thing the the this uh the type of parameters must be different or number of parameters must be different or sequence of parameters must be different right otherwise it will give error or let me just show you one more example here see here I have void print in print see function name is same return type is different right so here void print I'm just printing high in int print I'm just returning a right I'm just calling print here and for this int because it is returning integer value so I will accept that value in a variable of type integer that is X print this and see out X right but it will give error see the red line cannot overload functions distinguished by return type alone right here only the difference is return type is different everything is same but this is how you cannot achieve function overloading right at least the parameter should be maybe the number of parameter should be different type of parameter should be different or the order of parameter should be different then you can achieve function overloading right so function return type is not you know the single factor with that you can achieve function overloading this you need to remember right now third thing we have discussed uh all the three ways to achieve function overring but here you can have some ambiguities while you know doing this while ACH function overloading now some causes ofun that ambiguities are maybe the type conversion maybe you are using function with default argument maybe you are using function with pass by reference three reason can be there for that ambiguity you get right so let me just tell you this thing with example first if you have because of type conversion you can get function ambiguity let me just show you this thing with example see here I have one example there I have function print in this I'm passing INT in void print I'm passing float in print I'm passing string three print I have right and this is the definition for integer I'm just printing a for string the string value whatever you pass for float whatever float value you pass that would be printed so while calling I'm just passing first print 10 so ideally according to us it should call like 10 is integer value so this in so it will print print integer value a 10.2 this is float value so it should call this float so printing this printing double value D and it should print 10.2 right and third if I call like print and Jenny or rather than C style string if I take here one string object Str Str is equal to jeny and that object sorry not 8 also you can use but let's take a meaningful name s Str and here just pass print s Str an object string object C++ string object right so it should call this and it should print s strj but it will give an error to you guys let me show you that error okay this is not the exact error this is the error call of overloaded print double is ambiguous here 10. because in C++ all the floating Point number are treated as double right not float double by default right so there is type conversion from float to double so it is considering like 10.2 is not float it's double right so the exit match the compiler wants to call so but there is no double here int float string we are passing float here int here string here not double so there's no exact match found so compiler will call now the best possible match right so now this double can be treated as a float as well as truncated and treated as ink right so that is why this this error you are getting this call Print double in line number 15 is ambiguous right it can call the Sprint also it can call the Sprint float also so a compiler doesn't know which one to call either this or this so that is why it is giving ambiguous see while you're dragging your mouse to here then more than one instance of overload function print matches the argument list this also and this also con and floting but if you if you write here rather than float double so this is the exact match here rather than float double this will not give any error 10.2 is considered as double by default in C++ yeah we have this a print function with a double parameter so it will exactly match it is going to find and it will just print 10.2 integer value 10 10.2 string value J so while using function overloading you need to be very careful of these implicitly type conver type of thing right otherwise you will get error this is a drawback of using function overloading you have to be very careful second is if you're using function with default arguments let me show you that example also see one example we have here we have two function add and add in one I'm passing int int two parameter I'll pass two argument and in second I have int int int three parameter but one is default I'm taking one default if you will not pass anything then third argument it will take zero so here I'm passing default argument but in this case it will give error see while calling this add 2 three or let me just comment out these things two and three here you see red line more than one instance of overloaded function ad matches the argument list this one is also matches this one is also matches now which one to call function is the compiler doesn't know is not able to decide which one to call let me just run this and show you see the call of overloaded function add in in is ambiguous right because you are passing only two argument so this is matching with this also in ab and with this also because in this case also you are passing only two argument you will pass so by default the third argument it will take zero so third argument here it will take zero right so this is also ambiguity type of thing right so while using default arguments also you have to be very careful you can get this type of ambiguity error you got this right third thing if you use function with by uh with pass by reference in that case also you can get ambig error let me show you that thing also see here we have two function one is fun there will will pass int and another is fun they will passing like int and M per pass by reference we have discussed call by variable call by reference right call by reference we can achieve with by two ways like either using reference variable or using pointers here we are using reference variable right please watch out that video first if you are not aware about what is call by reference call call by value and what is reference variable so in in main so we have defined these two function fun there we passing just int a integer uh value I'm just printing a and here reference variable you are creating int h perent b and just we are calling B right and while calling we have int X is equal to 6 and we are just calling we're passing X here so like six we are passing so in this case also it is giving an ER like more than one instance of overloaded function fun matches the argument list this is also matching this is also matching so which function to call let me just run this and show you the output call of overloaded add in in okay let me just save this first and now run this see Call of overloaded fun in this m operator is ambiguous now compiler doesn't know which function to call because there is no syntactical difference between this fun in a and fun int m per B this is just reference variable reference variable means it's just an alas of the variable like whatever you will pass here x just another name right so this x this is also matching this is also matching in reference variable when you use then you simply pass here a variable not any address of variable or anything right so in this case also you are getting ambiguity error three reasons of of getting ambiguity error in while you are doing function overloading this thing you need to take care while you are doing function overloading in your program right so yeah we can say is this function overloading is a powerful feature in programming this will increase the readability of the code because you use only with only single function name you can achieve different different task you can do different different task based on the different parameters only right the function name is same so it increase the flexibility and reusability of your code right but obiously disadvantages are what you have to be more careful because there would be ambiguity error also so this thing you need to remember here right and compiler dependency also when you port your program from one compiler to another there maybe you can get some because of the some rules you get unpredictable results while you are you know achieving or doing function overloading in your program and debugging is also sometimes difficult because uh sometimes the error doesn't show exactly which function overload is causing that error so this is all about function overloading I hope you got this right so in the next video we'll see some coding exercise based on functions and function overloading right so now I'll see you in the next Tut bye take care
