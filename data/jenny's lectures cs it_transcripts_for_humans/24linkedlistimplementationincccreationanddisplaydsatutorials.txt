With timestamps:

00:00 - video is for this topic is you should
00:02 - know the basics of link list what is
00:04 - link list how to represent a link list
00:06 - or you should know the what a singly
00:07 - linked list basically when we say linked
00:09 - list then we are talking about singly
00:11 - linked list right so we are going to
00:13 - implement singly linked list here fine
00:15 - plus you should know what is dynamic
00:18 - memory allocation and how to use the
00:20 - Mellow function in c language right as
00:23 - well as you should have the knowledge of
00:25 - pointers plus structure what is
00:27 - structure data type in c language how to
00:30 - access the structure members right using
00:34 - that structure variable also plus
00:37 - pointer also fine so now first of all we
00:41 - will see the logical view of a linked
00:43 - list I am going to create a linked list
00:44 - here I am just going to draw a linked
00:46 - list here having three nodes only so
00:49 - this is you can see a logical view of a
00:51 - linked list having three nodes this
00:52 - compute is known as a node what is a
00:54 - linked list how to represent this I have
00:56 - already discussed I will provide you the
00:57 - link of that video in the cyber and you
00:59 - can check out there in the last node in
01:01 - the address part see two parts of a node
01:03 - are there this one is data part this
01:06 - node this part of the node is going to
01:08 - store actual data and this part is going
01:10 - to store address address of next node
01:13 - right that is why here I am going to
01:15 - show two hundred here I am going to
01:16 - store three hundred hundred two hundred
01:17 - three hundred are random addresses those
01:21 - addresses are in hexadecimal form this
01:23 - is just for your understanding purpose
01:25 - so see in the last node address part is
01:28 - going to contain a zero because it is
01:29 - not going to point any node further
01:31 - right so it it means it is having null
01:35 - fine this is just a logical
01:38 - representation of linked list now how we
01:41 - are going to map this logical view in
01:43 - programming how to write a C program
01:46 - right initially we don't have any node
01:49 - fine and this is what a head pointer
01:52 - head pointer is going to store address
01:54 - of first node always we are going to
01:57 - have in program when you are writing a
01:59 - program in that case you have to
02:01 - maintain what this head pointer now see
02:04 - first of all we don't have any node in
02:07 - the linked list right and we are going
02:08 - to create a linked list having three
02:10 - nodes you are going to create this one
02:11 - and
02:12 - that we are going to display the content
02:15 - of the nodes that is 5 4 & 9 right we
02:18 - are going to see that in coding so now
02:21 - first of all we have to create a node
02:23 - fine now how to create a node using a
02:27 - user-defined data type that is structure
02:29 - that we have already discussed now how
02:31 - to write on that thing see you are going
02:34 - to write struct keyword then this tag
02:37 - that is node this complete is what now
02:40 - our data type we are going to define
02:41 - your own data type fine
02:43 - data type of this node now this node is
02:45 - going to contain two parts one is this
02:48 - integer part and this one is what is
02:50 - going to contain address and for address
02:53 - we are going to take what pointer
02:54 - variable always so first part would be
02:57 - int suppose we are going to take data or
03:01 - a or b your number as you can as you
03:04 - wish fine now next s your pointer this
03:07 - pointer now the data type should be this
03:09 - pointer is going to store address of
03:11 - next node fine and the type of this is
03:14 - what struct noddle that is why I am
03:17 - going to write here struct node estwick
03:22 - and suppose the pointer name is next you
03:25 - can say link or as you wish fine so now
03:29 - this is what you have just defined your
03:31 - data type it's not that you have you
03:34 - have created this node no not now the
03:37 - memory has not been allocated this is
03:39 - just what you have defined your own data
03:42 - type right that is a struct node fine
03:45 - now what you will do you have to
03:47 - maintain this head node also because
03:49 - this is what the main thing this is
03:51 - going to have the address of first node
03:53 - then you can traverse the list so this
03:55 - is the main thing so now you have to
03:58 - this is what a head pointer because it
04:00 - is going to store address address of
04:01 - this node fine so how to declare this
04:05 - pointer see we will write what struct
04:09 - node astrick and suppose the pointer
04:14 - name I am going to take head why I am
04:16 - writing this struct node here because
04:19 - see here you will write what always we
04:22 - will write if you write int star P it
04:25 - may
04:26 - this pointer is going to store address
04:27 - of integer variable right this is
04:30 - pointer to int so this is what this this
04:32 - pointer head pointer is going to store
04:34 - address off and node and the data type
04:38 - of this node is what struct node so here
04:40 - we always write down the data type of
04:42 - that variable or that thing whose
04:44 - address this pointer is going to store
04:46 - fine so in C language we are going to
04:49 - write struct node if you don't write
04:51 - don't use type def fine in C++ you can
04:55 - simply write this node that is fine but
04:58 - here I am discussing C language fine now
05:01 - we have created this head node initially
05:04 - suppose we don't have any node in the
05:07 - list so initially what head pointer will
05:10 - store head is going to contain word 0 or
05:15 - you can say null now we are going to
05:17 - create a node fine now you will write
05:20 - something such that memories to be
05:23 - allocated for this node so now here we
05:26 - are going to use what a dynamic memory
05:27 - allocation that is malloc function in C
05:29 - language they are going to use malloc
05:30 - function in C++ you can use new keyword
05:33 - fine now how you can use malloc function
05:36 - see the syntax is what you simply write
05:40 - mellow and in break it you will write
05:45 - what the size how much memory you want
05:48 - right so how much memory we want here
05:52 - the size of this according to the size
05:55 - of this node fine so here you will write
05:59 - size of and in break it you will write
06:02 - what C data type of this node is what
06:05 - struct node so here you will write data
06:09 - type that is struct node fine so how
06:14 - much memory is to be allocated sizeof
06:16 - struct node sizeof struct node the data
06:19 - type is struct node in this struct node
06:22 - we are having one variable data that is
06:25 - of integer type that is 4 bytes and one
06:28 - is pointer in 32-bit compiler 4 bytes is
06:30 - to be allocated in 64 8 bytes so 6 4
06:34 - plus 4 that is 8
06:35 - it's complete block of eight bytes would
06:38 - be allocated dynamically now see this
06:41 - malloc is what what it is going to
06:43 - return my locus a method or a function
06:45 - which is going to return a pointer to
06:48 - the starting address of that memory
06:51 - block because memory block of eight
06:53 - bytes has been allocated fine so it is
06:56 - going to return a pointer to the
06:59 - starting address of that a memory block
07:01 - fine so malloc is going to return what
07:03 - pointer or you can say it is going to
07:05 - return a void pointer so now what this
07:08 - malloc is going to return C it is going
07:11 - to create a node in the memory a block
07:14 - of how many how many bytes eight bytes
07:18 - right here for for this and four for
07:20 - this and suppose address of this is
07:22 - hundred I am going to take see this this
07:25 - complete block is humming how many bytes
07:27 - eight bytes and the address so first
07:29 - byte is what hundred so that is why I am
07:31 - taking about addresses hundred so it is
07:32 - going to return what hundred address
07:35 - starting address of this blow now we are
07:37 - going to store this hundred this is an
07:40 - address so we need what a pointer
07:42 - variable to store this fine so we have
07:45 - to create one another pointer variable
07:47 - that is here we are going to create a
07:51 - strict new node this is what another
07:56 - pointer variable one is head and one is
07:58 - what we are going to take new node
08:00 - whenever whenever we are going to create
08:01 - a new node we are going to take this one
08:03 - the address of that node we are going to
08:06 - store in this pointer variable fine
08:09 - because my loop is always going to
08:11 - return what pointer to the starting
08:13 - address and it is going to return what
08:14 - void pointer see this new node you can
08:18 - say here we are we are going to take
08:20 - this is what new node this is just a
08:24 - pointer now whatever they dress the
08:27 - malloc function is going to return we're
08:28 - going to store that address into this
08:31 - new node pointer that is pointer to node
08:33 - but it is going to return what void
08:34 - pointer to show you how to typecast this
08:36 - one fine
08:38 - so for typecasting here you will write
08:40 - what struct node Asterix because we are
08:46 - dealing with a pointer to
08:48 - no fine and that dress we are going to
08:50 - store in new note address the type is
08:54 - this this is what a pointer to node so
08:58 - the type is what struct node s string
09:01 - fine so now this is how the we are going
09:04 - to dynamically allocate the memory now
09:06 - this block has been allocated of eight
09:09 - bytes and a new node now we have
09:12 - hundreds so it is going to point here so
09:15 - now we have created a node but we don't
09:18 - have any data here so you can ask from
09:20 - the user for the data and for how you
09:26 - will write using scan if you are going
09:28 - to take the input from the user so the
09:32 - data type is int so we are going to use
09:34 - percentage D and now C you cannot
09:38 - directly write here hash in this address
09:40 - of and data we cannot directly access
09:42 - the members of this structure fine you
09:45 - if we are accessing the members of this
09:48 - structure using what using this pointer
09:52 - then what is the that centex
09:55 - brace off C using this pointer variable
09:58 - we are going to access this node fine
10:02 - because we have just to the address of
10:03 - this node so how you write the pointer
10:07 - name new node then you will write what
10:11 - this arrow symbol and now you will write
10:14 - that name of that variable the name of
10:18 - that structure member that is data this
10:21 - is how you can access the members of a
10:24 - structure using pointer fine
10:27 - using node operated you can also use but
10:30 - here I am using this arrow method
10:33 - because this is what easy to use now
10:35 - suppose user has entered what this file
10:37 - so here you will write what fine and in
10:40 - this here now we have only one node so
10:44 - here you can insert one now on 0 so here
10:47 - you can insert a 0 so here you can write
10:49 - what this new node arrow operator and
10:56 - for this part this is what the pointer
10:59 - pointer name is next so here you can
11:01 - write
11:01 - next is equal to zero so this is how we
11:05 - are going to access the structural
11:06 - member see this this address part also
11:08 - we can access using this pointer so you
11:10 - are going to use the name of that
11:12 - pointer then arrow prater and then the
11:14 - name of this part is what we have taken
11:16 - what next for this this part so next is
11:19 - equal to zero now see now we have
11:22 - created this node we have inserted the
11:24 - data now we are going to put this node
11:26 - in the linked list fine initially see
11:28 - what we have done head is equal to zero
11:31 - see initially you can see here we have
11:34 - head and it is going to contain zero now
11:37 - next thing is you have to point this to
11:41 - this right so now you have to store this
11:46 - address into this head fine now how we
11:50 - are going to store this address is there
11:52 - what in this pointer that is it new node
11:54 - so simply you can write head is equal to
11:57 - new node so here now hundred is there
12:00 - and this is also going to point here now
12:02 - new node is also here and head is also
12:05 - here so now the list is having only one
12:07 - node that is this one and head is going
12:10 - to contain address of this so how we can
12:12 - write this head as equal to new road so
12:15 - simply here you can write head is equal
12:18 - to new node fine the standard will be
12:23 - stored here and this is going to point
12:24 - here now fine now suppose you are going
12:27 - to insert one are you going to create
12:29 - another node and you are going to insert
12:30 - here but in that case
12:32 - head is not null see in this case at
12:35 - starting his head is equal to null that
12:37 - is why we have simply done this thing if
12:40 - head is equal to mod null then what you
12:42 - will do so here you will write one
12:44 - condition before this if head is equal
12:48 - to is equal to null then you can do this
12:53 - thing then that is fine else if n is
12:56 - equal to North null then what you will
12:58 - do now suppose we have created one more
13:00 - node using this code also fine we are
13:04 - going to if we are going to write down
13:06 - that thing also how this program is
13:08 - going to run again
13:09 - how the score is going to run again and
13:11 - again see suppose again this line is
13:14 - going to execute new node is equal to
13:15 - this thing then in that case again one
13:18 - node is going to create it fine and
13:20 - suppose address is now 200
13:23 - so now 200 is now going to assign in
13:25 - this new node so now in this new node we
13:27 - have what 200 so this is now not going
13:31 - to point here now now suppose this is
13:33 - our new node and this is now going to
13:35 - point here because we have created one
13:37 - more node now now we are going to enter
13:39 - the data now suppose for we have enter
13:41 - for is going to store here and in the
13:43 - next part here we are going to store
13:44 - what 0 right so now we have created one
13:49 - more node and they are going to insert
13:51 - we are going to insert this node in the
13:53 - list also because here we have only one
13:55 - node in the list head and this one so
13:59 - here we are going to store this new node
14:01 - so you have to update the pointers now
14:03 - in this case head is equal to not null
14:05 - head is going having 100 the address of
14:09 - the first node so this we cannot do now
14:12 - fine if you don't write this condition
14:15 - and you simply write head is equal to
14:17 - new new node then in this case also now
14:20 - head is going to contain head is equal
14:21 - to new node so head is going to contain
14:23 - now 200 fine
14:26 - so this is this link is going to be
14:28 - destroyed and now head is going to point
14:30 - here but that thing we don't want fine
14:33 - because you are going to insert this now
14:36 - here so you cannot destroy this link so
14:40 - simply you cannot write this thing that
14:43 - is why we are going to write this
14:44 - condition if head is equal to null then
14:46 - you can write this thing then it is
14:48 - right if head is equal to not null then
14:50 - what you will do now see so now to
14:52 - insert this newly created node here in
14:55 - the list what you will have to update we
14:58 - are going to store address of this this
15:00 - newly created node here that is 200 here
15:05 - it means now this is now going to point
15:07 - what here fine so in the list we have
15:10 - this one and this one to move fine
15:13 - so simply how you can access this part
15:16 - this structure because this node is
15:19 - having datatype structure so you cannot
15:21 - simply
15:21 - except this one how you can access using
15:23 - arrow Prater fine using pointer the
15:26 - pointer of this node is what head
15:28 - pointer so you can write here head this
15:33 - arrow Prater in see when you are writing
15:35 - a program then you can simply write -
15:37 - and that angular bracket fine and then
15:40 - name of this pointer is water next next
15:44 - is equal to what here you are going to
15:46 - store 200 that is whatever is in there
15:49 - new node is equal to new node so now we
15:54 - are thinking that this is now done fine
15:57 - now list is having these two nodes fine
16:00 - now the problem comes when you are going
16:02 - to create one third node now suppose the
16:04 - program has been executed again and one
16:07 - another node has been created this one
16:11 - when this line is to be executed one
16:13 - another node has to be created suppose
16:15 - address is 300 and in this we have
16:18 - suppose nine and here we have zero and
16:21 - now the new node now the new node is
16:23 - going to contain 300 so now then you
16:25 - know what is going to contain 300 so
16:28 - this is now going to point here now
16:30 - right we have inserted the data and this
16:33 - also we have initialized to 0 now if
16:35 - head is equal to 0 but head is not 0
16:38 - then we are going to here into else part
16:41 - now how we are going to insert this
16:43 - newly created node here after this now
16:46 - in else node whatever you have written C
16:48 - head off next is equal to new node now
16:51 - head off
16:53 - next head off next is what this one
16:55 - because this head pointer is having 100
16:57 - so we can access this this is pointer to
17:00 - this node so head next head next means
17:03 - this one so now here we are going to
17:05 - store new node the new node is going to
17:07 - contain 300 so here we can insert now
17:09 - according to this we are going to insert
17:11 - 300 so that is why this link has been
17:14 - destroyed and now this is going to point
17:16 - here but this is not actually done
17:21 - because this is first second then and
17:24 - after that we are going to insert this
17:26 - third node but according to this coding
17:30 - we have lost the link to this node now
17:33 - this node is not in the
17:34 - so now this you cannot write so the
17:37 - solution of this problem is what you
17:40 - have to take one extra another pointer
17:43 - here we are going to take one pointer
17:47 - that is M one more pointer now see what
17:51 - is the role of this temp C we cannot
17:54 - move this head pointer we cannot change
17:56 - the ED this value of this head pointer
17:59 - because if you are going to change this
18:00 - value then you will you will lose the
18:02 - link or reference to this first node
18:04 - that we cannot afford so we cannot
18:07 - change the value of this head node this
18:10 - is going to be permanent
18:11 - fine now this temp this pointer this
18:15 - this value you can change suppose at
18:18 - first temp is going to point here next
18:21 - it is going to point here next is it is
18:23 - going to point here so you cannot you
18:25 - can change the value of this M pointer
18:30 - when you are going to traverse the list
18:32 - then we are then also it we are going to
18:34 - Traverse using this temp only because we
18:36 - cannot change this head value see this
18:39 - new node pointer is what it is just
18:41 - going to contain the address or the
18:43 - pointer to the newly created node fine
18:46 - and head node is going to contain
18:48 - address off
18:49 - sorry head pointer is going to contain
18:51 - address so first node fine
18:53 - so for tray were saying the list
18:55 - obviously we need one an extra pointer
18:58 - we cannot change this head node we
19:00 - cannot use this new node pointer because
19:02 - this is only going to have address of
19:04 - newly created node that is we are going
19:06 - to create this we are going to take
19:08 - another pointer that is kept fine now
19:11 - you have to modify your according a
19:13 - little bit see here you cannot write
19:15 - this line here what you will write temp
19:18 - of next is equal to new node right and
19:21 - here it's starting
19:23 - if head is equal to 0 head is equal to
19:25 - new node as well as we are going to
19:27 - initialize this temp temp is also going
19:30 - to point here so head is equal to temp
19:35 - is equal to new node right
19:42 - so now head is also going to point here
19:45 - plus one extra temp is also there extra
19:49 - pointer is also there another pointer
19:51 - temp temp is also going to continue note
19:53 - that is hundred now temp is also
19:56 - pointing to first note both head and
19:59 - temp we cannot move this head we can we
20:01 - can move this temp now right now here we
20:06 - can write temp of next because this node
20:08 - is having two pointer this one this one
20:10 - so you can access this node using this
20:12 - template so temp of next is equal to new
20:16 - node that is 200 fine when we were
20:19 - creating when we're inserting this
20:21 - second node fine press plus what you
20:24 - will write here temp is equal to new
20:28 - node now we are going to move this temp
20:32 - temp is equal to new node at this time
20:34 - at this time temp was 200 right when we
20:39 - are creating this second node that is
20:41 - here so now
20:42 - MP is going to contain 200 right so now
20:46 - temp is going to point here fine and new
20:54 - node is also having two hundred now when
20:58 - you are going to create this third node
21:00 - suppose we have created this third node
21:01 - now new node is going to contain 300
21:05 - when the third node is going to create
21:07 - because new node is equal to this one so
21:10 - now new node is going to point here this
21:12 - is now our newly created node right so
21:15 - how you can insert this node here after
21:17 - this node see now you can see this line
21:19 - is correct if head is equal to no this
21:21 - condition is not true right
21:23 - so in else path in else part you write
21:25 - temp of next is equal to new node now
21:28 - temp is having two hundred so using this
21:31 - temp you can access the both the parts
21:34 - of this node right so temp of next means
21:37 - this one so here you will write new node
21:40 - value of new node is three hundred so
21:42 - here you will insert three hundred so
21:45 - now it is going to point here to the
21:49 - newly created node fine so this is fine
21:52 - now
21:52 - first no first node second node and
21:54 - third node
21:55 - right that is why we are taking this
21:58 - third pointer variable I hope now you
22:01 - have the idea why we are taking these
22:02 - three pointers now we are going to move
22:05 - the stem fine now temp is going to
22:08 - create now temp is going to have this
22:11 - new node that is 300 value is now 300
22:14 - now temp is not going to point here now
22:17 - temp is going to point where to this one
22:21 - to the third node in the list fine and
22:24 - if we create another node obviously
22:27 - simply now temp next temp next means
22:30 - here here you can insert the address of
22:33 - newly created node fine
22:35 - so this is now the proper logic this is
22:38 - how you will write this so now we have
22:40 - created these three nodes so I am going
22:42 - to run this thing now so now this is our
22:44 - list temp is pointing here new node is
22:46 - also pointing here and head is pointing
22:48 - here now see now you want to implement a
22:52 - program something like this you want to
22:54 - ask from the user do you want to
22:55 - continue if user press 1 then you are
22:59 - going to create another node fine
23:01 - again this code is going to run if user
23:03 - press 0 it means where you are not going
23:07 - to create another node now we are going
23:09 - to print these values fine so for that
23:12 - what you will write after this what you
23:13 - will write you will ask from the user
23:15 - printf do you want to continue for
23:21 - taking input you are using scanf address
23:24 - sorry percentage D address off now
23:32 - suppose we are we are going to take one
23:34 - variable of choice and here we are going
23:36 - to store the choice of the user either 0
23:38 - or 1 0 means we are not going to
23:40 - continue one means he wants to continue
23:43 - he wants to create another node now you
23:44 - have to be clear this choice variables
23:46 - so here you can declare int choice right
23:53 - now if user press 1 it means again this
23:58 - code is going to run fine
24:00 - so now we we have to write this code
24:02 - into while loop fine so where you will
24:06 - write this while loop here before
24:08 - this new node because if user press one
24:11 - then one another node is to be created
24:14 - it means that another node is to be
24:16 - created using this line so before this
24:18 - line you will write while and in bracket
24:21 - you will write choice
24:22 - so after this line into choice and
24:25 - before this line in the program you will
24:27 - write while choice I don't have enough
24:30 - space that is why I am writing here
24:32 - something like this fine
24:33 - while choice and you will thus break it
24:37 - and after this after this bracket you
24:39 - will write that you will write this line
24:40 - new code is equal to this one so now
24:42 - this while loop you are going to close
24:44 - here now using this code you can create
24:47 - as many node as you want
24:49 - now next thing is you want to print you
24:51 - want to traverse the list how you are
24:54 - going to traverse from here you first of
24:57 - all note you can say you are going to
24:58 - print the values 5 then this 4 then this
25:00 - 9 we cannot move this head pointer so
25:05 - that is why again now at last impose
25:08 - here so again you are going to
25:10 - initialize this temp from here right so
25:13 - in temp
25:14 - first of all you are going to store temp
25:16 - is equal to head now in temp we are
25:21 - having hundreds so now temp is pointing
25:25 - here
25:27 - so now you are going to print 5 4 8 9 so
25:30 - here you write a while loop while M not
25:36 - equal to none fine till then you are
25:41 - going to run this loop and you will
25:43 - print this value this value that is a
25:46 - data so now we can not directly print
25:49 - this 5 you cannot directly access this
25:50 - data you can access this this member of
25:53 - the structure using this pointer fine so
25:56 - now you are going to print this 5 so
25:58 - simply you will write printf after that
26:02 - you will write M this temp an operator
26:06 - and name is what data name of this
26:09 - variable is what data now this is going
26:12 - to 0.5
26:13 - sorry this is now going to print this 5
26:16 - right now we are going to print this for
26:19 - but we cannot directly print this for 5
26:22 - so we are going to move temp now here
26:26 - right so now temp is equal to temp next
26:35 - see temp of next the value is going to
26:38 - store in M temp next M phase one hundred
26:41 - so temp is going to point here M next
26:43 - means 200 so now 200 is going to store
26:46 - in M so here you will store now 200 now
26:49 - this is going to point here
26:53 - right again condition while temp is
26:58 - equal to not null temp is now 200 so it
27:01 - is not null so now print temp data means
27:03 - temp data that is 4 it is going to print
27:05 - now 4 again temp of next temp of next is
27:09 - 300 so now 300 is going to store in temp
27:11 - that is here you will store 300 so now
27:14 - temp is going to point here
27:16 - so now temp in or not now yes temp is
27:19 - not null condition is true now again
27:21 - print temp of data that is 9 would be
27:23 - printed first 5 then 4 then 9 would be
27:26 - printed now temp of next temp of next
27:28 - means 0 0 would be a sign here temp now
27:31 - tempo is going to contain 0 so now while
27:35 - temp
27:35 - not equal to null now this condition is
27:37 - not true now we are not going to print
27:39 - here because now temp is what null
27:41 - tempis is 0 so now simply you are going
27:44 - to exit so here you can write get CH and
27:47 - this comes this this coder you are going
27:50 - to write in void main main function fine
27:55 - or you can simply create a function of
27:58 - create node or display fine and you can
28:02 - write down this coding into those
28:04 - functions and you can call those
28:06 - functions into this main function but
28:07 - you can directly write down this coding
28:09 - in the main function and if you want to
28:11 - print how many nodes are there in the
28:13 - list then you can take a simple variable
28:16 - that is count you can declare here in
28:18 - two choice and into count and in this
28:20 - while loop you can write down one more
28:22 - step that is count plus plus you can
28:25 - initialize the count at starting in town
28:28 - tis equal to 0 fine here only and here
28:31 - count plus plus and after this while
28:33 - loop you can
28:34 - to the scum value printer percentage DL
28:36 - count so the three would be printed
28:39 - because here in this case we have three
28:41 - nodes so this is how you can create node
28:43 - and traverse the list I hope you got the
28:46 - concept in next video we'll discuss how
28:48 - to insert newly created node in the list
28:51 - at beginning also at any position also
28:55 - and at end of the list fine so I'll see
28:58 - in the next video till / take

Cleaned transcript:

video is for this topic is you should know the basics of link list what is link list how to represent a link list or you should know the what a singly linked list basically when we say linked list then we are talking about singly linked list right so we are going to implement singly linked list here fine plus you should know what is dynamic memory allocation and how to use the Mellow function in c language right as well as you should have the knowledge of pointers plus structure what is structure data type in c language how to access the structure members right using that structure variable also plus pointer also fine so now first of all we will see the logical view of a linked list I am going to create a linked list here I am just going to draw a linked list here having three nodes only so this is you can see a logical view of a linked list having three nodes this compute is known as a node what is a linked list how to represent this I have already discussed I will provide you the link of that video in the cyber and you can check out there in the last node in the address part see two parts of a node are there this one is data part this node this part of the node is going to store actual data and this part is going to store address address of next node right that is why here I am going to show two hundred here I am going to store three hundred hundred two hundred three hundred are random addresses those addresses are in hexadecimal form this is just for your understanding purpose so see in the last node address part is going to contain a zero because it is not going to point any node further right so it it means it is having null fine this is just a logical representation of linked list now how we are going to map this logical view in programming how to write a C program right initially we don't have any node fine and this is what a head pointer head pointer is going to store address of first node always we are going to have in program when you are writing a program in that case you have to maintain what this head pointer now see first of all we don't have any node in the linked list right and we are going to create a linked list having three nodes you are going to create this one and that we are going to display the content of the nodes that is 5 4 & 9 right we are going to see that in coding so now first of all we have to create a node fine now how to create a node using a userdefined data type that is structure that we have already discussed now how to write on that thing see you are going to write struct keyword then this tag that is node this complete is what now our data type we are going to define your own data type fine data type of this node now this node is going to contain two parts one is this integer part and this one is what is going to contain address and for address we are going to take what pointer variable always so first part would be int suppose we are going to take data or a or b your number as you can as you wish fine now next s your pointer this pointer now the data type should be this pointer is going to store address of next node fine and the type of this is what struct noddle that is why I am going to write here struct node estwick and suppose the pointer name is next you can say link or as you wish fine so now this is what you have just defined your data type it's not that you have you have created this node no not now the memory has not been allocated this is just what you have defined your own data type right that is a struct node fine now what you will do you have to maintain this head node also because this is what the main thing this is going to have the address of first node then you can traverse the list so this is the main thing so now you have to this is what a head pointer because it is going to store address address of this node fine so how to declare this pointer see we will write what struct node astrick and suppose the pointer name I am going to take head why I am writing this struct node here because see here you will write what always we will write if you write int star P it may this pointer is going to store address of integer variable right this is pointer to int so this is what this this pointer head pointer is going to store address off and node and the data type of this node is what struct node so here we always write down the data type of that variable or that thing whose address this pointer is going to store fine so in C language we are going to write struct node if you don't write don't use type def fine in C++ you can simply write this node that is fine but here I am discussing C language fine now we have created this head node initially suppose we don't have any node in the list so initially what head pointer will store head is going to contain word 0 or you can say null now we are going to create a node fine now you will write something such that memories to be allocated for this node so now here we are going to use what a dynamic memory allocation that is malloc function in C language they are going to use malloc function in C++ you can use new keyword fine now how you can use malloc function see the syntax is what you simply write mellow and in break it you will write what the size how much memory you want right so how much memory we want here the size of this according to the size of this node fine so here you will write size of and in break it you will write what C data type of this node is what struct node so here you will write data type that is struct node fine so how much memory is to be allocated sizeof struct node sizeof struct node the data type is struct node in this struct node we are having one variable data that is of integer type that is 4 bytes and one is pointer in 32bit compiler 4 bytes is to be allocated in 64 8 bytes so 6 4 plus 4 that is 8 it's complete block of eight bytes would be allocated dynamically now see this malloc is what what it is going to return my locus a method or a function which is going to return a pointer to the starting address of that memory block because memory block of eight bytes has been allocated fine so it is going to return a pointer to the starting address of that a memory block fine so malloc is going to return what pointer or you can say it is going to return a void pointer so now what this malloc is going to return C it is going to create a node in the memory a block of how many how many bytes eight bytes right here for for this and four for this and suppose address of this is hundred I am going to take see this this complete block is humming how many bytes eight bytes and the address so first byte is what hundred so that is why I am taking about addresses hundred so it is going to return what hundred address starting address of this blow now we are going to store this hundred this is an address so we need what a pointer variable to store this fine so we have to create one another pointer variable that is here we are going to create a strict new node this is what another pointer variable one is head and one is what we are going to take new node whenever whenever we are going to create a new node we are going to take this one the address of that node we are going to store in this pointer variable fine because my loop is always going to return what pointer to the starting address and it is going to return what void pointer see this new node you can say here we are we are going to take this is what new node this is just a pointer now whatever they dress the malloc function is going to return we're going to store that address into this new node pointer that is pointer to node but it is going to return what void pointer to show you how to typecast this one fine so for typecasting here you will write what struct node Asterix because we are dealing with a pointer to no fine and that dress we are going to store in new note address the type is this this is what a pointer to node so the type is what struct node s string fine so now this is how the we are going to dynamically allocate the memory now this block has been allocated of eight bytes and a new node now we have hundreds so it is going to point here so now we have created a node but we don't have any data here so you can ask from the user for the data and for how you will write using scan if you are going to take the input from the user so the data type is int so we are going to use percentage D and now C you cannot directly write here hash in this address of and data we cannot directly access the members of this structure fine you if we are accessing the members of this structure using what using this pointer then what is the that centex brace off C using this pointer variable we are going to access this node fine because we have just to the address of this node so how you write the pointer name new node then you will write what this arrow symbol and now you will write that name of that variable the name of that structure member that is data this is how you can access the members of a structure using pointer fine using node operated you can also use but here I am using this arrow method because this is what easy to use now suppose user has entered what this file so here you will write what fine and in this here now we have only one node so here you can insert one now on 0 so here you can insert a 0 so here you can write what this new node arrow operator and for this part this is what the pointer pointer name is next so here you can write next is equal to zero so this is how we are going to access the structural member see this this address part also we can access using this pointer so you are going to use the name of that pointer then arrow prater and then the name of this part is what we have taken what next for this this part so next is equal to zero now see now we have created this node we have inserted the data now we are going to put this node in the linked list fine initially see what we have done head is equal to zero see initially you can see here we have head and it is going to contain zero now next thing is you have to point this to this right so now you have to store this address into this head fine now how we are going to store this address is there what in this pointer that is it new node so simply you can write head is equal to new node so here now hundred is there and this is also going to point here now new node is also here and head is also here so now the list is having only one node that is this one and head is going to contain address of this so how we can write this head as equal to new road so simply here you can write head is equal to new node fine the standard will be stored here and this is going to point here now fine now suppose you are going to insert one are you going to create another node and you are going to insert here but in that case head is not null see in this case at starting his head is equal to null that is why we have simply done this thing if head is equal to mod null then what you will do so here you will write one condition before this if head is equal to is equal to null then you can do this thing then that is fine else if n is equal to North null then what you will do now suppose we have created one more node using this code also fine we are going to if we are going to write down that thing also how this program is going to run again how the score is going to run again and again see suppose again this line is going to execute new node is equal to this thing then in that case again one node is going to create it fine and suppose address is now 200 so now 200 is now going to assign in this new node so now in this new node we have what 200 so this is now not going to point here now now suppose this is our new node and this is now going to point here because we have created one more node now now we are going to enter the data now suppose for we have enter for is going to store here and in the next part here we are going to store what 0 right so now we have created one more node and they are going to insert we are going to insert this node in the list also because here we have only one node in the list head and this one so here we are going to store this new node so you have to update the pointers now in this case head is equal to not null head is going having 100 the address of the first node so this we cannot do now fine if you don't write this condition and you simply write head is equal to new new node then in this case also now head is going to contain head is equal to new node so head is going to contain now 200 fine so this is this link is going to be destroyed and now head is going to point here but that thing we don't want fine because you are going to insert this now here so you cannot destroy this link so simply you cannot write this thing that is why we are going to write this condition if head is equal to null then you can write this thing then it is right if head is equal to not null then what you will do now see so now to insert this newly created node here in the list what you will have to update we are going to store address of this this newly created node here that is 200 here it means now this is now going to point what here fine so in the list we have this one and this one to move fine so simply how you can access this part this structure because this node is having datatype structure so you cannot simply except this one how you can access using arrow Prater fine using pointer the pointer of this node is what head pointer so you can write here head this arrow Prater in see when you are writing a program then you can simply write and that angular bracket fine and then name of this pointer is water next next is equal to what here you are going to store 200 that is whatever is in there new node is equal to new node so now we are thinking that this is now done fine now list is having these two nodes fine now the problem comes when you are going to create one third node now suppose the program has been executed again and one another node has been created this one when this line is to be executed one another node has to be created suppose address is 300 and in this we have suppose nine and here we have zero and now the new node now the new node is going to contain 300 so now then you know what is going to contain 300 so this is now going to point here now right we have inserted the data and this also we have initialized to 0 now if head is equal to 0 but head is not 0 then we are going to here into else part now how we are going to insert this newly created node here after this now in else node whatever you have written C head off next is equal to new node now head off next head off next is what this one because this head pointer is having 100 so we can access this this is pointer to this node so head next head next means this one so now here we are going to store new node the new node is going to contain 300 so here we can insert now according to this we are going to insert 300 so that is why this link has been destroyed and now this is going to point here but this is not actually done because this is first second then and after that we are going to insert this third node but according to this coding we have lost the link to this node now this node is not in the so now this you cannot write so the solution of this problem is what you have to take one extra another pointer here we are going to take one pointer that is M one more pointer now see what is the role of this temp C we cannot move this head pointer we cannot change the ED this value of this head pointer because if you are going to change this value then you will you will lose the link or reference to this first node that we cannot afford so we cannot change the value of this head node this is going to be permanent fine now this temp this pointer this this value you can change suppose at first temp is going to point here next it is going to point here next is it is going to point here so you cannot you can change the value of this M pointer when you are going to traverse the list then we are then also it we are going to Traverse using this temp only because we cannot change this head value see this new node pointer is what it is just going to contain the address or the pointer to the newly created node fine and head node is going to contain address off sorry head pointer is going to contain address so first node fine so for tray were saying the list obviously we need one an extra pointer we cannot change this head node we cannot use this new node pointer because this is only going to have address of newly created node that is we are going to create this we are going to take another pointer that is kept fine now you have to modify your according a little bit see here you cannot write this line here what you will write temp of next is equal to new node right and here it's starting if head is equal to 0 head is equal to new node as well as we are going to initialize this temp temp is also going to point here so head is equal to temp is equal to new node right so now head is also going to point here plus one extra temp is also there extra pointer is also there another pointer temp temp is also going to continue note that is hundred now temp is also pointing to first note both head and temp we cannot move this head we can we can move this temp now right now here we can write temp of next because this node is having two pointer this one this one so you can access this node using this template so temp of next is equal to new node that is 200 fine when we were creating when we're inserting this second node fine press plus what you will write here temp is equal to new node now we are going to move this temp temp is equal to new node at this time at this time temp was 200 right when we are creating this second node that is here so now MP is going to contain 200 right so now temp is going to point here fine and new node is also having two hundred now when you are going to create this third node suppose we have created this third node now new node is going to contain 300 when the third node is going to create because new node is equal to this one so now new node is going to point here this is now our newly created node right so how you can insert this node here after this node see now you can see this line is correct if head is equal to no this condition is not true right so in else path in else part you write temp of next is equal to new node now temp is having two hundred so using this temp you can access the both the parts of this node right so temp of next means this one so here you will write new node value of new node is three hundred so here you will insert three hundred so now it is going to point here to the newly created node fine so this is fine now first no first node second node and third node right that is why we are taking this third pointer variable I hope now you have the idea why we are taking these three pointers now we are going to move the stem fine now temp is going to create now temp is going to have this new node that is 300 value is now 300 now temp is not going to point here now temp is going to point where to this one to the third node in the list fine and if we create another node obviously simply now temp next temp next means here here you can insert the address of newly created node fine so this is now the proper logic this is how you will write this so now we have created these three nodes so I am going to run this thing now so now this is our list temp is pointing here new node is also pointing here and head is pointing here now see now you want to implement a program something like this you want to ask from the user do you want to continue if user press 1 then you are going to create another node fine again this code is going to run if user press 0 it means where you are not going to create another node now we are going to print these values fine so for that what you will write after this what you will write you will ask from the user printf do you want to continue for taking input you are using scanf address sorry percentage D address off now suppose we are we are going to take one variable of choice and here we are going to store the choice of the user either 0 or 1 0 means we are not going to continue one means he wants to continue he wants to create another node now you have to be clear this choice variables so here you can declare int choice right now if user press 1 it means again this code is going to run fine so now we we have to write this code into while loop fine so where you will write this while loop here before this new node because if user press one then one another node is to be created it means that another node is to be created using this line so before this line you will write while and in bracket you will write choice so after this line into choice and before this line in the program you will write while choice I don't have enough space that is why I am writing here something like this fine while choice and you will thus break it and after this after this bracket you will write that you will write this line new code is equal to this one so now this while loop you are going to close here now using this code you can create as many node as you want now next thing is you want to print you want to traverse the list how you are going to traverse from here you first of all note you can say you are going to print the values 5 then this 4 then this 9 we cannot move this head pointer so that is why again now at last impose here so again you are going to initialize this temp from here right so in temp first of all you are going to store temp is equal to head now in temp we are having hundreds so now temp is pointing here so now you are going to print 5 4 8 9 so here you write a while loop while M not equal to none fine till then you are going to run this loop and you will print this value this value that is a data so now we can not directly print this 5 you cannot directly access this data you can access this this member of the structure using this pointer fine so now you are going to print this 5 so simply you will write printf after that you will write M this temp an operator and name is what data name of this variable is what data now this is going to 0.5 sorry this is now going to print this 5 right now we are going to print this for but we cannot directly print this for 5 so we are going to move temp now here right so now temp is equal to temp next see temp of next the value is going to store in M temp next M phase one hundred so temp is going to point here M next means 200 so now 200 is going to store in M so here you will store now 200 now this is going to point here right again condition while temp is equal to not null temp is now 200 so it is not null so now print temp data means temp data that is 4 it is going to print now 4 again temp of next temp of next is 300 so now 300 is going to store in temp that is here you will store 300 so now temp is going to point here so now temp in or not now yes temp is not null condition is true now again print temp of data that is 9 would be printed first 5 then 4 then 9 would be printed now temp of next temp of next means 0 0 would be a sign here temp now tempo is going to contain 0 so now while temp not equal to null now this condition is not true now we are not going to print here because now temp is what null tempis is 0 so now simply you are going to exit so here you can write get CH and this comes this this coder you are going to write in void main main function fine or you can simply create a function of create node or display fine and you can write down this coding into those functions and you can call those functions into this main function but you can directly write down this coding in the main function and if you want to print how many nodes are there in the list then you can take a simple variable that is count you can declare here in two choice and into count and in this while loop you can write down one more step that is count plus plus you can initialize the count at starting in town tis equal to 0 fine here only and here count plus plus and after this while loop you can to the scum value printer percentage DL count so the three would be printed because here in this case we have three nodes so this is how you can create node and traverse the list I hope you got the concept in next video we'll discuss how to insert newly created node in the list at beginning also at any position also and at end of the list fine so I'll see in the next video till / take
