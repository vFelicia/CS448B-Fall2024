With timestamps:

00:00 - so in the series of da lectures today i
00:03 - am going to talk about the
00:04 - characteristics of an algorithm
00:06 - i have already discussed what is an
00:08 - algorithm and how to analyze an
00:10 - algorithm means the types of analysis
00:12 - of an algorithm like priority analysis
00:14 - of and positivity analysis
00:16 - right and in this video we will discuss
00:18 - about the properties of an algorithm
00:20 - so ah basically you can say many
00:22 - properties are there but generally what
00:25 - we read in the book are there are five
00:26 - properties of an algorithm
00:28 - first one is input it means
00:32 - an algorithm can have zero or more
00:36 - inputs
00:36 - it's not like that algorithm must have
00:39 - at least one input no
00:41 - there may be an algorithm which which
00:43 - accept no
00:44 - input like what if you want to print
00:47 - uh hello world in that case the input is
00:50 - what
00:51 - nothing you are just printing hello
00:53 - world
00:54 - there is only output there is no input
00:57 - right so algorithm
00:59 - may contain zero input and suppose let
01:01 - us take an example of
01:02 - uh you are writing an algorithm of sum
01:05 - of two numbers
01:05 - in that case input is two numbers two
01:08 - inputs are there
01:10 - right so you can say algorithm can have
01:12 - either zero input or
01:14 - more inputs zero or more well-defined
01:17 - inputs
01:18 - second one is output so we cannot say
01:22 - that
01:22 - algorithm can have zero output means no
01:25 - output would be there
01:26 - no algorithm should have at least
01:29 - one output maybe input may be zero like
01:32 - in hello world
01:33 - input is nothing but output is what yes
01:35 - one output is there you are printing
01:37 - hello world
01:38 - so an algorithm should have at least
01:41 - one output maybe more than one output
01:44 - can be there but at least one output
01:47 - see if there is no output of an
01:49 - algorithm then obviously what is use of
01:50 - that
01:51 - algorithm why we are writing that
01:53 - algorithm right
01:55 - third is what unambiguous
01:59 - or you can say definiteness what does
02:01 - this mean see
02:03 - obviously in algorithm we are writing
02:04 - algorithm is what are the sequence of
02:06 - instruction or steps so every
02:08 - instruction must be clear there should
02:11 - be no ambiguity
02:12 - in those instructions now what does that
02:16 - mean
02:16 - see suppose if you are writing
02:20 - read if you are writing an algorithm for
02:23 - sum of two numbers and you are writing
02:25 - statement
02:26 - read means what what are you reading
02:29 - this is what unambiguous statement it is
02:31 - having multiple meanings and if you will
02:33 - write
02:34 - read a read b
02:37 - it means this statement is having a
02:39 - clear meaning we are reading a
02:41 - variable a we are reading another value
02:43 - for another variable
02:45 - b right so every statement
02:48 - must have a single meaning only one
02:52 - meaning
02:53 - every it means every statement must be
02:56 - unambiguous
02:57 - there should be no ambiguity it should
02:59 - be very clear
03:00 - you can take that real life example in
03:02 - the previous video also i have taken
03:03 - that example like suppose you are
03:05 - if you are preparing t that is also you
03:07 - are you in that case also you are
03:08 - following
03:09 - some steps right and this is what a kind
03:11 - of algorithm
03:12 - so in that case if you say like take a
03:15 - pan
03:15 - put it on flame and add now add means
03:19 - what
03:20 - what to add maybe you can add salt or
03:22 - anything else
03:24 - so that add step that instruction is
03:27 - having multiple meanings that is
03:29 - ambiguous we are not clear about that if
03:32 - you say add water
03:33 - add tea leaves add sugar add milk
03:36 - that has clear statements clear
03:38 - instructions there is no ambiguity
03:40 - right so same in the case of algorithm
03:42 - every instruction must be clear and
03:44 - precise there should be no ambiguity
03:46 - right i hope you got this mind next one
03:49 - is
03:50 - finite finiteness means what
03:54 - every algorithm must contains finite
03:57 - number of
03:58 - steps means the steps must be countable
04:02 - it's not like that you are writing steps
04:05 - infinite steps are there right there is
04:07 - no end
04:08 - like you can take this example if you
04:10 - are writing in program and if you will
04:12 - say while one and if you here print
04:15 - something
04:16 - then this is always true so this would
04:20 - be an infinite
04:21 - loop right it is not going to end until
04:25 - you
04:26 - forcefully terminate it right
04:29 - so it should not be a case something
04:31 - like this
04:32 - every algorithm must have finite number
04:35 - of steps
04:36 - and every instruction within that
04:38 - algorithm
04:40 - must take finite amount of time for
04:43 - execution right it's not like that there
04:46 - is
04:47 - this kind of thing like infinite loop is
04:50 - there
04:50 - so this instruction is having taking
04:52 - mult ah taking infinite
04:55 - time you have to forcefully stop this so
04:58 - algorithm
04:59 - must terminate after a finite number of
05:02 - steps next one is effectiveness
05:06 - means it should perform that task for
05:09 - which
05:10 - you have written that algorithm it
05:12 - should be effective
05:13 - it shouldn't contain any unnecessary
05:16 - statements
05:17 - like the same example that algorithm for
05:20 - t is what
05:20 - four or five number of steps right but
05:23 - those steps are effective ultimately you
05:25 - will get an output ultimately you will
05:27 - get
05:27 - t like for example let us take this
05:29 - example
05:30 - sum of two numbers and here you will
05:33 - write sum is equal to a plus b
05:35 - and here you can print sum
05:38 - here you can say start and here you can
05:40 - say end
05:42 - so this is what in simple algorithm so
05:44 - that output of this algorithm would be
05:46 - obviously the sum of these two numbers
05:48 - it is effective
05:50 - and it is not containing any unnecessary
05:52 - statements like i am not
05:53 - writing here read c because i am not
05:56 - using c
05:57 - anywhere and one more point you can also
06:00 - add like
06:00 - every statement every instruction in
06:02 - that algorithm must be feasible it
06:04 - should not be
06:05 - imaginary right so for those who are
06:07 - interested in competitive coding i just
06:09 - want to inform you that
06:10 - an academy in collaboration with code
06:12 - chef have launched
06:14 - a course to learn competitive
06:15 - programming they'll focus specifically
06:17 - on competitive
06:18 - competitive programming right in that
06:20 - course you can attend
06:21 - live videos live sessions and if you are
06:24 - not able to attend the live session then
06:26 - you can watch the recorded session as
06:29 - well
06:30 - and these uh videos these lectures would
06:32 - be provided by the top
06:34 - educators by the top faculties those who
06:37 - are already
06:38 - toppers of acm icpc and many of
06:41 - them are working in mncs like flipkart
06:43 - and google
06:44 - and they'll teach you all the important
06:46 - topics for competitive
06:48 - programming like dynamic programming
06:49 - greedy algorithm string analysis
06:51 - and all as well as they'll teach you how
06:54 - to solve a particular type of problem
06:56 - like
06:56 - how to solve this type of dynamic
06:58 - programming problem
06:59 - right and if you like their free classes
07:02 - then you can go for their
07:03 - paid subscriptions they will give you
07:05 - the proper structured course
07:07 - so this is the pricing detail and here
07:10 - if you use
07:10 - my code then you will get 10 percent
07:12 - discount my code i'll provide you in the
07:15 - description box you can check out there
07:17 - plus one more thing here if you go for
07:19 - the paid subscription you can then
07:21 - also watch the upcoming uh lectures like
07:24 - on what
07:24 - date another lecture upcoming lecture
07:26 - would be there
07:27 - right so the the link of this course and
07:31 - my code i'll provide you in the
07:32 - description box you can check out there
07:34 - and
07:34 - if you like it then you can go for it so
07:37 - now that's it for this video in the next
07:38 - video i'm going to discuss about
07:40 - asymptotic notations so now i'll see you
07:43 - in the next video till then bye take
07:53 - care

Cleaned transcript:

so in the series of da lectures today i am going to talk about the characteristics of an algorithm i have already discussed what is an algorithm and how to analyze an algorithm means the types of analysis of an algorithm like priority analysis of and positivity analysis right and in this video we will discuss about the properties of an algorithm so ah basically you can say many properties are there but generally what we read in the book are there are five properties of an algorithm first one is input it means an algorithm can have zero or more inputs it's not like that algorithm must have at least one input no there may be an algorithm which which accept no input like what if you want to print uh hello world in that case the input is what nothing you are just printing hello world there is only output there is no input right so algorithm may contain zero input and suppose let us take an example of uh you are writing an algorithm of sum of two numbers in that case input is two numbers two inputs are there right so you can say algorithm can have either zero input or more inputs zero or more welldefined inputs second one is output so we cannot say that algorithm can have zero output means no output would be there no algorithm should have at least one output maybe input may be zero like in hello world input is nothing but output is what yes one output is there you are printing hello world so an algorithm should have at least one output maybe more than one output can be there but at least one output see if there is no output of an algorithm then obviously what is use of that algorithm why we are writing that algorithm right third is what unambiguous or you can say definiteness what does this mean see obviously in algorithm we are writing algorithm is what are the sequence of instruction or steps so every instruction must be clear there should be no ambiguity in those instructions now what does that mean see suppose if you are writing read if you are writing an algorithm for sum of two numbers and you are writing statement read means what what are you reading this is what unambiguous statement it is having multiple meanings and if you will write read a read b it means this statement is having a clear meaning we are reading a variable a we are reading another value for another variable b right so every statement must have a single meaning only one meaning every it means every statement must be unambiguous there should be no ambiguity it should be very clear you can take that real life example in the previous video also i have taken that example like suppose you are if you are preparing t that is also you are you in that case also you are following some steps right and this is what a kind of algorithm so in that case if you say like take a pan put it on flame and add now add means what what to add maybe you can add salt or anything else so that add step that instruction is having multiple meanings that is ambiguous we are not clear about that if you say add water add tea leaves add sugar add milk that has clear statements clear instructions there is no ambiguity right so same in the case of algorithm every instruction must be clear and precise there should be no ambiguity right i hope you got this mind next one is finite finiteness means what every algorithm must contains finite number of steps means the steps must be countable it's not like that you are writing steps infinite steps are there right there is no end like you can take this example if you are writing in program and if you will say while one and if you here print something then this is always true so this would be an infinite loop right it is not going to end until you forcefully terminate it right so it should not be a case something like this every algorithm must have finite number of steps and every instruction within that algorithm must take finite amount of time for execution right it's not like that there is this kind of thing like infinite loop is there so this instruction is having taking mult ah taking infinite time you have to forcefully stop this so algorithm must terminate after a finite number of steps next one is effectiveness means it should perform that task for which you have written that algorithm it should be effective it shouldn't contain any unnecessary statements like the same example that algorithm for t is what four or five number of steps right but those steps are effective ultimately you will get an output ultimately you will get t like for example let us take this example sum of two numbers and here you will write sum is equal to a plus b and here you can print sum here you can say start and here you can say end so this is what in simple algorithm so that output of this algorithm would be obviously the sum of these two numbers it is effective and it is not containing any unnecessary statements like i am not writing here read c because i am not using c anywhere and one more point you can also add like every statement every instruction in that algorithm must be feasible it should not be imaginary right so for those who are interested in competitive coding i just want to inform you that an academy in collaboration with code chef have launched a course to learn competitive programming they'll focus specifically on competitive competitive programming right in that course you can attend live videos live sessions and if you are not able to attend the live session then you can watch the recorded session as well and these uh videos these lectures would be provided by the top educators by the top faculties those who are already toppers of acm icpc and many of them are working in mncs like flipkart and google and they'll teach you all the important topics for competitive programming like dynamic programming greedy algorithm string analysis and all as well as they'll teach you how to solve a particular type of problem like how to solve this type of dynamic programming problem right and if you like their free classes then you can go for their paid subscriptions they will give you the proper structured course so this is the pricing detail and here if you use my code then you will get 10 percent discount my code i'll provide you in the description box you can check out there plus one more thing here if you go for the paid subscription you can then also watch the upcoming uh lectures like on what date another lecture upcoming lecture would be there right so the the link of this course and my code i'll provide you in the description box you can check out there and if you like it then you can go for it so now that's it for this video in the next video i'm going to discuss about asymptotic notations so now i'll see you in the next video till then bye take care
