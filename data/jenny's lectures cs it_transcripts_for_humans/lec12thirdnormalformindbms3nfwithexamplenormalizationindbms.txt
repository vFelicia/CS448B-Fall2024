With timestamps:

00:00 - so far in the series we have discussed
00:02 - about first normal form and second
00:05 - normal form right how to find out that a
00:07 - particular relation is in first normal
00:09 - form of vertical the given relation is
00:11 - in second normal form or not right all
00:13 - the rules so first NF and all they're
00:15 - also second NF right now still we have
00:20 - some drawback in second normal form so
00:22 - why we need third normal form because of
00:25 - those topics now I will tell you in this
00:27 - video that what are the drawbacks in
00:29 - second normal form and that drawbacks we
00:32 - will remove in third normal form and how
00:34 - to remove those drawbacks right first is
00:38 - obviously redundancy first of all in we
00:41 - have redundancy in the table then we
00:43 - remove the redundancy by first normal
00:45 - form then again we do second in normal
00:48 - form to remove the redundancy right
00:49 - still we have some redundancy if table
00:53 - or relation is in second normal form and
00:55 - because of that redundancy some
00:58 - anomalies may exist right now what kind
01:00 - of anomaly can be there in second in
01:02 - normal form right first of all we'll
01:04 - discuss that thing after that we will
01:06 - discuss with the help of that relation
01:08 - that a particular relation is given
01:09 - functional dependencies are given then
01:11 - how to find out that this relation is in
01:14 - third normal form or not right now see
01:19 - suppose I am taking out this relation or
01:22 - the stable student having these
01:23 - attributes of a student and only primary
01:26 - key is what student ID right I am
01:28 - considering here that frequency only one
01:31 - candidate key that is s ID so that would
01:34 - be primary key right student ID no more
01:38 - candidate he is there now here see this
01:43 - is in second normal form this relation
01:45 - is in second normal form now how can you
01:49 - say that because I haven't given any
01:50 - functional dependency right and in the
01:52 - previous video I have checked using that
01:54 - functional dependency right in the
01:56 - previous video I have told you one more
01:58 - important point about second and F is
02:00 - that if the candidate key right is
02:05 - having only one attribute although lucky
02:10 - knee we have only one candidate key
02:11 - suppose three candidate keys are there
02:13 - and all
02:13 - candidate fees are having only one
02:15 - attribute C candidate key is also having
02:18 - one attribute if candidate is having one
02:21 - attribute than that as you can say
02:23 - simple candidate key if it is having
02:26 - more than one attribute two three four
02:29 - then that is known as composite key
02:34 - right I hope you got now what is
02:37 - composite key now see if the kind of
02:40 - candidate key is having only one
02:42 - attribute then definitely that relation
02:45 - would be in second normal phone now why
02:48 - so because in second normal form there
02:50 - should be no partial dependency right
02:52 - and obviously it is in first normal form
02:56 - it should be in first NF and now by
02:58 - default we consider that given
03:00 - relational day we table would be in
03:01 - first NF so and by looking at this table
03:04 - also you can see this is in first NF now
03:07 - partial dependency is what if proper
03:10 - subset of candidate key determines
03:12 - non-prime attribute then only that is
03:16 - partial dependency right this condition
03:19 - is only of prime sorry partial
03:22 - dependency if this is the case here
03:24 - proper subset of candidate he this side
03:26 - non-prime attribute right it's not like
03:29 - that it is proper subset of candidate
03:30 - here and here we have prime attribute
03:32 - then also partial dependency no left
03:35 - side should be proper subset of
03:36 - candidate K right side must be non-prime
03:40 - attribute then only it is known as
03:42 - partial dependency now if only one
03:44 - attribute is there then obviously no
03:46 - proper subset is possible of this
03:48 - candidate if no proper subset is
03:49 - possible then we will never get this
03:51 - kind of partial dependency here so this
03:53 - is in second NF right but still what can
03:56 - be the problem in this table if your
03:58 - database is in second normal form that
04:00 - is also not considered as a good
04:02 - database why so because see here what
04:06 - you can see here the functional
04:08 - dependency is C using pin code I can
04:12 - determine state and Country right so
04:18 - this is the functional dependency
04:19 - present here and how to check that a
04:21 - particular functional dependency is
04:22 - valid or not that also we have discussed
04:24 - in the previous video you can check out
04:25 - that video
04:26 - sigh button right now it's a fine pin
04:29 - code and the pin code is not any key
04:31 - here no cannot candidate key here right
04:34 - it's if not can you get key that it is
04:36 - non-prime attribute right state and
04:38 - country are also known prime attributes
04:40 - non prime attributes are those which are
04:42 - not a part of any candidate key so here
04:43 - the primary Bute is only s ID because it
04:46 - is only the part of candidate key right
04:48 - now see if you want to change the pin
04:52 - code here right it means what you need
04:58 - to do here also you need to do you need
05:00 - to change the pin code here also you
05:01 - need to change the pin code and suppose
05:04 - because of pin code you need to change
05:05 - the state also so here also you need to
05:07 - state change here also change here also
05:09 - change right I am taking a small table
05:12 - in which I am having only three rows
05:15 - where we have status Ariana and I'm only
05:18 - changing changing the pin code of these
05:20 - three tuples so in all the three tuples
05:23 - you need to change the state as well
05:25 - suppose this through this situation is
05:28 - in five hundred rows so in all the five
05:30 - hundred rows you need to update this
05:32 - change right this is what are the
05:35 - redundancy now here you can see this is
05:37 - one redundancy right so here you can
05:41 - have update anomalies we have already
05:46 - discussed what are three anomalies
05:48 - insert update and delete in the previous
05:50 - one of the previous video right I'll
05:52 - provide you the link of the complete
05:54 - playlist of BBFS in the description box
05:56 - you can check out all the previous
05:58 - videos right so because of this
06:00 - redundancy we have update anomaly here
06:02 - although the table is in second NF still
06:05 - there are some redundancy
06:06 - still we have update anomaly if table is
06:09 - in second NF so to remove this one what
06:12 - you can do you can divide this table
06:14 - right in two tables another table you
06:17 - can make which contains state country
06:20 - and pin code like this this is the
06:22 - second table I have I have taken this
06:26 - dependency right and I have decomposed
06:29 - this table into two parts one table will
06:31 - contain SIDS name DOB pin code and total
06:35 - credit note state and country
06:37 - table will contain state country hand
06:39 - pin code right so now if you will change
06:43 - the pin code here at the three place you
06:46 - need note to change that state at the
06:49 - three three place right only you can
06:51 - change here one at one couple and here
06:54 - only you can change the state right so
06:56 - now here we have removed this redundancy
06:59 - redundant data although in one column
07:02 - obviously we have the spin code we have
07:04 - to link these tables using foreign key
07:07 - that also we'll discuss later
07:09 - I am just giving you a overview here so
07:12 - now we have removed the update anomaly
07:15 - now why this problem comes see now this
07:19 - is very important point why this problem
07:21 - comes obviously because of redundancy
07:23 - but because of redundancy what what
07:25 - functional dependency is there because
07:27 - of that it brought the problem occurs
07:29 - because of this functional dependency
07:32 - because here pin code is determining
07:35 - state and country and pin code as
07:38 - non-prime attribute state and country
07:40 - also known prime attribute non-prime
07:43 - attribute is determining non-prime
07:46 - attribute right so this functional
07:51 - dependency this type of functional
07:52 - dependency caused the problem here you
07:55 - have to remove it remove that and this
07:58 - functional dependency is known as
08:00 - transitive dependency right if
08:04 - transitive dependency is there in the
08:06 - table then that table is not in third
08:09 - normal form so now how can you how can
08:11 - you say that our relation is in third
08:13 - normal form if and only if first one it
08:18 - is in second normal form that is for
08:20 - sure
08:20 - second point is it does not contain any
08:25 - transitive dependency right two points
08:29 - are there let me write so these are two
08:31 - conditions for a relation to beam third
08:34 - normal form first one it should be
08:35 - second normal form you can say a
08:38 - relation here is in third normal form if
08:41 - and only if first one it is in it is in
08:43 - for second order form second one is
08:45 - there is no transitive dependency or
08:47 - specifically you can say there is no
08:49 - transitive dependency for
08:51 - non-prime attribute right now what is
08:54 - transitive dependency see if our
08:57 - relation relation we have a determines B
09:00 - and B determines C right so this is
09:05 - transitive dependency because if this
09:07 - and this is given you can say that a
09:08 - will determine C this is what up
09:10 - obviously you know this is transitive
09:11 - dependency right now here is also known
09:15 - prime attribute and C is also known
09:17 - prime attribute if this is a case then
09:20 - only you can say that in the relation we
09:22 - have transitive dependency present so
09:24 - here how can you write it if obviously
09:28 - the ill they'll ask you in gate or net
09:30 - or they will give you one relation and
09:32 - set of functional dependencies so if in
09:34 - the that set of functional dependency
09:35 - you find out a dependent dependency
09:37 - something like this a non-prime
09:39 - attribute to determining a non-prime
09:40 - attribute then this is transitive
09:43 - dependency it means that relation is not
09:45 - in third order form you have to check
09:47 - this only both side left hand side and
09:50 - right hand side both side must be
09:52 - non-prime attribute if any one is prime
09:55 - attribute then there would be problem
09:57 - see if this side is prime a tribute on
10:00 - this side this side we have known prime
10:02 - attribute then this will create a
10:03 - problem for second normal form because
10:05 - this is what a partial dependency if the
10:08 - side is a part of candidate key right
10:11 - subset of candidate here and this side
10:12 - we have non-prime attribute then this is
10:14 - partial dependency if this is the case
10:16 - then that would not be in second normal
10:18 - form right so obviously if not second
10:21 - normal form then that is not in third
10:23 - normal form so now here suppose here we
10:27 - have candidate key and here we have
10:29 - non-prime attribute then that is there
10:33 - would be no problem this is not you can
10:35 - say a transitive dependency and here
10:38 - suppose maybe you can get like this here
10:40 - we have a non-prime attribute and it is
10:42 - determining a prime a tribute may be
10:44 - sometimes then this is also not
10:46 - transitive dependency for transitive
10:48 - dependency you must check both side must
10:51 - be known prime attributes that's it
10:54 - right now let us take one example now
10:57 - let us consider this example now before
10:59 - that see you can also write down like
11:02 - this other table is in third normal form
11:04 - if and only if for each of its
11:08 - functional dependencies right and these
11:10 - functional dependencies should be known
11:12 - trivial for each of its known trivial
11:15 - functional dependency if any functional
11:17 - dependency is given something like this
11:18 - a B determines a right then will not
11:22 - consider this case for each non-trivial
11:25 - functional dependency at least one of
11:29 - the following conditions hold
11:31 - see there are two condition but at least
11:33 - one condition
11:34 - it's not compulsory that these two
11:37 - conditions must be hold in this
11:39 - functional dependency at least one
11:41 - either left hand side is super key left
11:45 - hand side means this one right
11:47 - that determinant on right hand side is
11:51 - prime attribute means the dependent
11:55 - prime at his prime attribute at least
11:57 - one of these conditions hold you can
11:59 - write down something like this or you
12:01 - can write down something like this for
12:02 - this obviously for finding the non-prime
12:04 - attribute or you can say for finding the
12:05 - super here the prime attributes you must
12:08 - need to find out the candidate key that
12:10 - is very important point that also you
12:11 - have discussed in one of the previous
12:13 - video right how to find out candidate
12:15 - key C ABCD closer you can take all the
12:19 - attribute first of all definitely it
12:21 - will find out all the attributes so you
12:23 - can say that ABCD is super key now find
12:27 - out candidate key try to discard the
12:28 - elements the attributes here CA is
12:31 - determining B so you can discard be a
12:34 - determining BB will determine C so a
12:37 - will determine C so you can discard C
12:39 - because we have a C will determine B so
12:42 - by transitivity property a will
12:44 - determine D we have a so you can discard
12:46 - D so we have only a so a is what super
12:49 - key you can check if the attribute
12:52 - closure of a is having all the
12:54 - attributes of the relation then
12:55 - definitely it is it is a super key you
12:57 - can say a will determine itself right by
13:00 - a flexibility proper property a will
13:02 - determine B we have a so I can determine
13:04 - B using B I can determine C using C I
13:07 - can determine DS all that reboots are
13:08 - there in the tribute closer okay so a is
13:10 - what can it super key now as a candidate
13:13 - key definitely a would be candidate E Y
13:16 - so because
13:17 - no proper subset is possible of a is
13:19 - only single likely having one single
13:20 - attribute right so this is what
13:22 - candidate key now we have got one
13:24 - candidate he so means prime attributes
13:26 - we have board that is one that is a now
13:30 - check out more entities are possible
13:32 - here or not in this relation how to
13:34 - check out this thing if the prime
13:36 - attribute is present at the right hand
13:38 - side of the functional dependencies then
13:40 - definitely there will be more candidate
13:42 - keys and we you have to find those out
13:44 - right but here check is prime attribute
13:48 - is a present on the right hand side no
13:50 - no no so now there is no more candidate
13:53 - key now we have only one candidate key
13:55 - that is a in this relation right and
13:59 - this is prime a tribute now you can
14:01 - check this condition this kind of
14:04 - dependency present here or not if yes
14:07 - then this relation is not in third
14:09 - normal form right check out check the
14:12 - first two dependency a is a non-prime
14:15 - attribute no it is prime attribute so
14:17 - this is what this is not we can say that
14:20 - this is a transitive dependency no right
14:23 - so this is not a transitive dependency
14:26 - now check out this one B yes it is
14:29 - non-prime attribute but only checking B
14:31 - you can't say that this is transitive
14:33 - dependency you have to check the right
14:34 - hand side also because there also there
14:37 - should be non-prime attribute C C is
14:39 - also non-prime attribute so this is
14:41 - transitive dependency see is non-prime
14:43 - attribute B is non-prime attribute so
14:45 - this is also transitive dependency so
14:48 - two transitive dependencies are there so
14:50 - this relation is not in third normal
14:52 - form right this is in second normal form
14:56 - because by default I have taken these
14:58 - type of functional dependencies so that
15:01 - this is in second NF you can check out
15:03 - this also because if candidate is having
15:06 - only one attribute then definitely that
15:08 - relation would be in second normal form
15:10 - so this is also in second hand sorry not
15:12 - in third but only second NF or here if
15:16 - you will not check like this so you can
15:18 - check like this check these two
15:20 - condition first one is left hand side is
15:22 - at least one condition must hold for
15:24 - each non-trivial functional dependency
15:27 - see these are known trivial functional
15:28 - dependencies right trivial I guess you
15:31 - know that if X determine Y then Y is
15:33 - what subset of X this is what trivial
15:36 - functional dependency right now see
15:39 - left-hand side is super he check out for
15:41 - this one left-hand side is super key yes
15:43 - right no need to check the right-hand
15:45 - side only one condition at least one
15:48 - condition must hold for the relation to
15:50 - be in third normal form so check out for
15:53 - second functional dependency left-hand
15:54 - side is it super key no B is not super
15:57 - key now check for right hand side right
15:59 - hand side is prime attribute no so
16:02 - neither this nor this one is present in
16:06 - this for this functional dependency so
16:08 - this is transitive dependency this is
16:10 - also because left hand side check it is
16:12 - super key is that super key no so now
16:14 - right hand side is D primate reviews the
16:16 - primate reboot no so neither this nor
16:19 - this one is holding here right now it is
16:23 - also transitive dependency see here why
16:25 - I am saying that C is not a super key
16:27 - obviously if you find out the C closer
16:30 - then what it contains it will determine
16:32 - C itself by reflexivity property and
16:35 - using the functional dependency C can
16:37 - determine B nothing else
16:39 - so attribute closer is containing only
16:40 - see you do not all the attributes so C
16:42 - cannot be a super key right now let's
16:44 - take a different type of example so let
16:47 - us take this example here we have ABCDE
16:49 - F attributes and these two functional
16:51 - dependencies are given right now first
16:53 - of all obviously find out the candidate
16:55 - key here now candidate he is this closer
17:00 - would contain all the attributes so this
17:02 - is oh definitely a super key now try to
17:03 - discard the attributes from here see the
17:06 - functional dependency a B is determining
17:08 - cdef right so we have a B so using a B I
17:12 - can determine C D F so I can discard
17:14 - from here right can i discard anything
17:17 - else B D is determining if but we don't
17:19 - have we have only B we don't have D
17:21 - right so obviously we can cannot discard
17:24 - now anything so now a B you can find out
17:28 - a be closer would also contain all the
17:30 - attributes so this is what a super key
17:31 - now find out it is a candidate key or
17:33 - not how to find out proper subset would
17:36 - be a and B check out these are super key
17:39 - or not
17:40 - hey closer and be closer a closer will
17:44 - determine itself hey nothing else
17:47 - because here both abies data-mining CD
17:49 - here but we have only a not be right so
17:51 - this is not a super here now be closer
17:53 - will determine B only B so this is also
17:56 - not a super key so you can say that a B
17:58 - is candidate key right now we go to one
18:01 - candidate key that is a B and prime
18:04 - attributes huh
18:06 - here a comma B not yet more candidate
18:11 - keys are there or not how to check prime
18:13 - attributes check out the primary boots
18:15 - are aware of available on the right hand
18:17 - side or not is a available on the right
18:19 - hand side know is be available on the
18:22 - right hand side know it means there is
18:24 - only one candidate key no more candidate
18:26 - keys are present in this relation right
18:28 - and prime attributes are a and B non
18:31 - prime attributes are cdef right now
18:34 - check out for this dependency is this
18:36 - type of type of dependency present here
18:38 - or not
18:39 - see first of all this thing is this a B
18:42 - is non-prime attribute no a be our prime
18:44 - attribute so this is what not a
18:47 - transitive dependency right no need to
18:49 - check the right hand side because if
18:50 - this side is not NP a so no need to
18:53 - check for this side now check for this
18:56 - dependency C B and B now here see this
19:00 - point you need to clear out this point
19:02 - to very carefully both B and B is this
19:06 - non-prime attribute now we will say that
19:08 - B is prime attribute right but B is not
19:13 - a prime attribute so this will consider
19:15 - as non-prime attribute and right hand
19:19 - side is F F is what it's a non-prime
19:22 - attribute so here also non-prime
19:23 - attribute here also non-prime attribute
19:25 - so this is violating the condition so
19:28 - this relation is not in third normal
19:30 - form right I hope you got now if you you
19:35 - find the mix of Prime and non-prime
19:37 - attribute then you will consider it what
19:39 - a non-prime attribute complete because b
19:42 - d complete is not prime attributed d is
19:45 - not in climb attribute so we'll consider
19:47 - it as non-prime attribute right so this
19:49 - is not in third normal form
19:51 - suppose I'm going to modify it a little
19:53 - bit suppose I have I am having a more
19:55 - functional dependency that is a
19:57 - determine D so now check for this one
20:01 - also suppose I am taking this one also
20:03 - so for this functional dependency
20:05 - left-hand side is non Prime attribute no
20:08 - it is what Prime attribute is what crime
20:11 - attribute right so no need to check the
20:13 - right-hand side this is not violating
20:16 - that property this is what we can we
20:19 - cannot say that this is a transitive
20:20 - dependency right here only which
20:23 - dependency is violating the condition
20:26 - because of this dependency this relation
20:28 - is not in third normal form B not
20:30 - because of this dependency right make
20:33 - this thing very clear that both sides
20:35 - should be non-prime attribute non-prime
20:37 - attribute and this a is prime attribute
20:40 - so no need to check this one or you can
20:42 - check this one left hand side is super
20:44 - key guess a is super key so no need to
20:45 - check the right-hand side right so now
20:48 - see if this other case if this is the
20:50 - case then check for the second normal
20:53 - form here because this relation is now
20:56 - in not in second in normal form right C
21:00 - is determining B is what candidate he is
21:04 - a B or you can say primary key is also
21:07 - even a proper subset of candidate he is
21:09 - a and this is determining unknown prime
21:12 - attributed D is what a non-prime
21:14 - attribute so this is a case of partial
21:16 - dependency here this is partial
21:19 - dependency so if this is a case then
21:22 - this relation is not in second in normal
21:24 - form so definitely it cannot be in third
21:26 - normal form right now here obviously I'm
21:29 - not taking this one now check this is
21:33 - partial dependency or not see BD is it a
21:39 - proper subset of candidate key candidate
21:42 - is a B proper subset of candidate key
21:45 - one is a one is B although we have B
21:48 - here but we have des also this complete
21:52 - should be a proper subset of candidate
21:54 - here so this is not a proper subset of
21:57 - candidate he right so this is not a
22:00 - partial dependency
22:02 - right so this is in second a normal form
22:04 - but not in third normal form because
22:07 - this is transitive dependency I hope now
22:11 - you got all the points about this so now
22:14 - how you can say that third and F is
22:16 - better than second NF in two and if we
22:18 - have one anomaly that is update anomaly
22:21 - because of some redundancy there right
22:22 - that is drawback
22:24 - so now third and F will remove all the
22:26 - anomalies insert delete as well as
22:28 - update anomaly so now you can say that
22:31 - this that is why we say that this third
22:34 - normal form is adequate normal form for
22:38 - your database means if your database is
22:40 - in third and if then you can say that it
22:42 - is a good database design although we
22:45 - have more normal forms are there bcnf
22:48 - fourth fifth be KNF that also will
22:50 - discuss one by one later now I hope you
22:53 - got what is third normal form and how to
22:54 - find out that particular relation is in
22:56 - third NF or not
22:57 - now this is question for you this is the
22:59 - relation these are functional
23:01 - dependencies and you need to check out
23:03 - is this relation is in second normal
23:06 - form as well as in third normal form or
23:08 - not right you need to tell me fine now
23:12 - if you want me to discuss more questions
23:15 - on these normal form you can mail me
23:17 - your questions on my mail id or you can
23:20 - just tell me in the comment box I will
23:22 - discuss some more questions also so now
23:25 - how to convert a given relation in into
23:28 - third NF third normal form that thing we
23:31 - will discuss later after discussing the
23:32 - decomposition process means lossless and
23:34 - or say decomposition right in the next
23:37 - video I'll discuss what is bcnf and
23:39 - after that I will discuss about a
23:40 - decomposition process so now I'll see in
23:43 - the next video till then bye-bye take
23:44 - care

Cleaned transcript:

so far in the series we have discussed about first normal form and second normal form right how to find out that a particular relation is in first normal form of vertical the given relation is in second normal form or not right all the rules so first NF and all they're also second NF right now still we have some drawback in second normal form so why we need third normal form because of those topics now I will tell you in this video that what are the drawbacks in second normal form and that drawbacks we will remove in third normal form and how to remove those drawbacks right first is obviously redundancy first of all in we have redundancy in the table then we remove the redundancy by first normal form then again we do second in normal form to remove the redundancy right still we have some redundancy if table or relation is in second normal form and because of that redundancy some anomalies may exist right now what kind of anomaly can be there in second in normal form right first of all we'll discuss that thing after that we will discuss with the help of that relation that a particular relation is given functional dependencies are given then how to find out that this relation is in third normal form or not right now see suppose I am taking out this relation or the stable student having these attributes of a student and only primary key is what student ID right I am considering here that frequency only one candidate key that is s ID so that would be primary key right student ID no more candidate he is there now here see this is in second normal form this relation is in second normal form now how can you say that because I haven't given any functional dependency right and in the previous video I have checked using that functional dependency right in the previous video I have told you one more important point about second and F is that if the candidate key right is having only one attribute although lucky knee we have only one candidate key suppose three candidate keys are there and all candidate fees are having only one attribute C candidate key is also having one attribute if candidate is having one attribute than that as you can say simple candidate key if it is having more than one attribute two three four then that is known as composite key right I hope you got now what is composite key now see if the kind of candidate key is having only one attribute then definitely that relation would be in second normal phone now why so because in second normal form there should be no partial dependency right and obviously it is in first normal form it should be in first NF and now by default we consider that given relational day we table would be in first NF so and by looking at this table also you can see this is in first NF now partial dependency is what if proper subset of candidate key determines nonprime attribute then only that is partial dependency right this condition is only of prime sorry partial dependency if this is the case here proper subset of candidate he this side nonprime attribute right it's not like that it is proper subset of candidate here and here we have prime attribute then also partial dependency no left side should be proper subset of candidate K right side must be nonprime attribute then only it is known as partial dependency now if only one attribute is there then obviously no proper subset is possible of this candidate if no proper subset is possible then we will never get this kind of partial dependency here so this is in second NF right but still what can be the problem in this table if your database is in second normal form that is also not considered as a good database why so because see here what you can see here the functional dependency is C using pin code I can determine state and Country right so this is the functional dependency present here and how to check that a particular functional dependency is valid or not that also we have discussed in the previous video you can check out that video sigh button right now it's a fine pin code and the pin code is not any key here no cannot candidate key here right it's if not can you get key that it is nonprime attribute right state and country are also known prime attributes non prime attributes are those which are not a part of any candidate key so here the primary Bute is only s ID because it is only the part of candidate key right now see if you want to change the pin code here right it means what you need to do here also you need to do you need to change the pin code here also you need to change the pin code and suppose because of pin code you need to change the state also so here also you need to state change here also change here also change right I am taking a small table in which I am having only three rows where we have status Ariana and I'm only changing changing the pin code of these three tuples so in all the three tuples you need to change the state as well suppose this through this situation is in five hundred rows so in all the five hundred rows you need to update this change right this is what are the redundancy now here you can see this is one redundancy right so here you can have update anomalies we have already discussed what are three anomalies insert update and delete in the previous one of the previous video right I'll provide you the link of the complete playlist of BBFS in the description box you can check out all the previous videos right so because of this redundancy we have update anomaly here although the table is in second NF still there are some redundancy still we have update anomaly if table is in second NF so to remove this one what you can do you can divide this table right in two tables another table you can make which contains state country and pin code like this this is the second table I have I have taken this dependency right and I have decomposed this table into two parts one table will contain SIDS name DOB pin code and total credit note state and country table will contain state country hand pin code right so now if you will change the pin code here at the three place you need note to change that state at the three three place right only you can change here one at one couple and here only you can change the state right so now here we have removed this redundancy redundant data although in one column obviously we have the spin code we have to link these tables using foreign key that also we'll discuss later I am just giving you a overview here so now we have removed the update anomaly now why this problem comes see now this is very important point why this problem comes obviously because of redundancy but because of redundancy what what functional dependency is there because of that it brought the problem occurs because of this functional dependency because here pin code is determining state and country and pin code as nonprime attribute state and country also known prime attribute nonprime attribute is determining nonprime attribute right so this functional dependency this type of functional dependency caused the problem here you have to remove it remove that and this functional dependency is known as transitive dependency right if transitive dependency is there in the table then that table is not in third normal form so now how can you how can you say that our relation is in third normal form if and only if first one it is in second normal form that is for sure second point is it does not contain any transitive dependency right two points are there let me write so these are two conditions for a relation to beam third normal form first one it should be second normal form you can say a relation here is in third normal form if and only if first one it is in it is in for second order form second one is there is no transitive dependency or specifically you can say there is no transitive dependency for nonprime attribute right now what is transitive dependency see if our relation relation we have a determines B and B determines C right so this is transitive dependency because if this and this is given you can say that a will determine C this is what up obviously you know this is transitive dependency right now here is also known prime attribute and C is also known prime attribute if this is a case then only you can say that in the relation we have transitive dependency present so here how can you write it if obviously the ill they'll ask you in gate or net or they will give you one relation and set of functional dependencies so if in the that set of functional dependency you find out a dependent dependency something like this a nonprime attribute to determining a nonprime attribute then this is transitive dependency it means that relation is not in third order form you have to check this only both side left hand side and right hand side both side must be nonprime attribute if any one is prime attribute then there would be problem see if this side is prime a tribute on this side this side we have known prime attribute then this will create a problem for second normal form because this is what a partial dependency if the side is a part of candidate key right subset of candidate here and this side we have nonprime attribute then this is partial dependency if this is the case then that would not be in second normal form right so obviously if not second normal form then that is not in third normal form so now here suppose here we have candidate key and here we have nonprime attribute then that is there would be no problem this is not you can say a transitive dependency and here suppose maybe you can get like this here we have a nonprime attribute and it is determining a prime a tribute may be sometimes then this is also not transitive dependency for transitive dependency you must check both side must be known prime attributes that's it right now let us take one example now let us consider this example now before that see you can also write down like this other table is in third normal form if and only if for each of its functional dependencies right and these functional dependencies should be known trivial for each of its known trivial functional dependency if any functional dependency is given something like this a B determines a right then will not consider this case for each nontrivial functional dependency at least one of the following conditions hold see there are two condition but at least one condition it's not compulsory that these two conditions must be hold in this functional dependency at least one either left hand side is super key left hand side means this one right that determinant on right hand side is prime attribute means the dependent prime at his prime attribute at least one of these conditions hold you can write down something like this or you can write down something like this for this obviously for finding the nonprime attribute or you can say for finding the super here the prime attributes you must need to find out the candidate key that is very important point that also you have discussed in one of the previous video right how to find out candidate key C ABCD closer you can take all the attribute first of all definitely it will find out all the attributes so you can say that ABCD is super key now find out candidate key try to discard the elements the attributes here CA is determining B so you can discard be a determining BB will determine C so a will determine C so you can discard C because we have a C will determine B so by transitivity property a will determine D we have a so you can discard D so we have only a so a is what super key you can check if the attribute closure of a is having all the attributes of the relation then definitely it is it is a super key you can say a will determine itself right by a flexibility proper property a will determine B we have a so I can determine B using B I can determine C using C I can determine DS all that reboots are there in the tribute closer okay so a is what can it super key now as a candidate key definitely a would be candidate E Y so because no proper subset is possible of a is only single likely having one single attribute right so this is what candidate key now we have got one candidate he so means prime attributes we have board that is one that is a now check out more entities are possible here or not in this relation how to check out this thing if the prime attribute is present at the right hand side of the functional dependencies then definitely there will be more candidate keys and we you have to find those out right but here check is prime attribute is a present on the right hand side no no no so now there is no more candidate key now we have only one candidate key that is a in this relation right and this is prime a tribute now you can check this condition this kind of dependency present here or not if yes then this relation is not in third normal form right check out check the first two dependency a is a nonprime attribute no it is prime attribute so this is what this is not we can say that this is a transitive dependency no right so this is not a transitive dependency now check out this one B yes it is nonprime attribute but only checking B you can't say that this is transitive dependency you have to check the right hand side also because there also there should be nonprime attribute C C is also nonprime attribute so this is transitive dependency see is nonprime attribute B is nonprime attribute so this is also transitive dependency so two transitive dependencies are there so this relation is not in third normal form right this is in second normal form because by default I have taken these type of functional dependencies so that this is in second NF you can check out this also because if candidate is having only one attribute then definitely that relation would be in second normal form so this is also in second hand sorry not in third but only second NF or here if you will not check like this so you can check like this check these two condition first one is left hand side is at least one condition must hold for each nontrivial functional dependency see these are known trivial functional dependencies right trivial I guess you know that if X determine Y then Y is what subset of X this is what trivial functional dependency right now see lefthand side is super he check out for this one lefthand side is super key yes right no need to check the righthand side only one condition at least one condition must hold for the relation to be in third normal form so check out for second functional dependency lefthand side is it super key no B is not super key now check for right hand side right hand side is prime attribute no so neither this nor this one is present in this for this functional dependency so this is transitive dependency this is also because left hand side check it is super key is that super key no so now right hand side is D primate reviews the primate reboot no so neither this nor this one is holding here right now it is also transitive dependency see here why I am saying that C is not a super key obviously if you find out the C closer then what it contains it will determine C itself by reflexivity property and using the functional dependency C can determine B nothing else so attribute closer is containing only see you do not all the attributes so C cannot be a super key right now let's take a different type of example so let us take this example here we have ABCDE F attributes and these two functional dependencies are given right now first of all obviously find out the candidate key here now candidate he is this closer would contain all the attributes so this is oh definitely a super key now try to discard the attributes from here see the functional dependency a B is determining cdef right so we have a B so using a B I can determine C D F so I can discard from here right can i discard anything else B D is determining if but we don't have we have only B we don't have D right so obviously we can cannot discard now anything so now a B you can find out a be closer would also contain all the attributes so this is what a super key now find out it is a candidate key or not how to find out proper subset would be a and B check out these are super key or not hey closer and be closer a closer will determine itself hey nothing else because here both abies datamining CD here but we have only a not be right so this is not a super here now be closer will determine B only B so this is also not a super key so you can say that a B is candidate key right now we go to one candidate key that is a B and prime attributes huh here a comma B not yet more candidate keys are there or not how to check prime attributes check out the primary boots are aware of available on the right hand side or not is a available on the right hand side know is be available on the right hand side know it means there is only one candidate key no more candidate keys are present in this relation right and prime attributes are a and B non prime attributes are cdef right now check out for this dependency is this type of type of dependency present here or not see first of all this thing is this a B is nonprime attribute no a be our prime attribute so this is what not a transitive dependency right no need to check the right hand side because if this side is not NP a so no need to check for this side now check for this dependency C B and B now here see this point you need to clear out this point to very carefully both B and B is this nonprime attribute now we will say that B is prime attribute right but B is not a prime attribute so this will consider as nonprime attribute and right hand side is F F is what it's a nonprime attribute so here also nonprime attribute here also nonprime attribute so this is violating the condition so this relation is not in third normal form right I hope you got now if you you find the mix of Prime and nonprime attribute then you will consider it what a nonprime attribute complete because b d complete is not prime attributed d is not in climb attribute so we'll consider it as nonprime attribute right so this is not in third normal form suppose I'm going to modify it a little bit suppose I have I am having a more functional dependency that is a determine D so now check for this one also suppose I am taking this one also so for this functional dependency lefthand side is non Prime attribute no it is what Prime attribute is what crime attribute right so no need to check the righthand side this is not violating that property this is what we can we cannot say that this is a transitive dependency right here only which dependency is violating the condition because of this dependency this relation is not in third normal form B not because of this dependency right make this thing very clear that both sides should be nonprime attribute nonprime attribute and this a is prime attribute so no need to check this one or you can check this one left hand side is super key guess a is super key so no need to check the righthand side right so now see if this other case if this is the case then check for the second normal form here because this relation is now in not in second in normal form right C is determining B is what candidate he is a B or you can say primary key is also even a proper subset of candidate he is a and this is determining unknown prime attributed D is what a nonprime attribute so this is a case of partial dependency here this is partial dependency so if this is a case then this relation is not in second in normal form so definitely it cannot be in third normal form right now here obviously I'm not taking this one now check this is partial dependency or not see BD is it a proper subset of candidate key candidate is a B proper subset of candidate key one is a one is B although we have B here but we have des also this complete should be a proper subset of candidate here so this is not a proper subset of candidate he right so this is not a partial dependency right so this is in second a normal form but not in third normal form because this is transitive dependency I hope now you got all the points about this so now how you can say that third and F is better than second NF in two and if we have one anomaly that is update anomaly because of some redundancy there right that is drawback so now third and F will remove all the anomalies insert delete as well as update anomaly so now you can say that this that is why we say that this third normal form is adequate normal form for your database means if your database is in third and if then you can say that it is a good database design although we have more normal forms are there bcnf fourth fifth be KNF that also will discuss one by one later now I hope you got what is third normal form and how to find out that particular relation is in third NF or not now this is question for you this is the relation these are functional dependencies and you need to check out is this relation is in second normal form as well as in third normal form or not right you need to tell me fine now if you want me to discuss more questions on these normal form you can mail me your questions on my mail id or you can just tell me in the comment box I will discuss some more questions also so now how to convert a given relation in into third NF third normal form that thing we will discuss later after discussing the decomposition process means lossless and or say decomposition right in the next video I'll discuss what is bcnf and after that I will discuss about a decomposition process so now I'll see in the next video till then byebye take care
