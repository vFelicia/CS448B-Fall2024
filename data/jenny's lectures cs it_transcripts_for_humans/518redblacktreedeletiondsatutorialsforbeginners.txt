With timestamps:

00:00 - so the topic is deletion in red-black
00:02 - trees see we have already discussed
00:04 - introduction to red-black tree as well
00:06 - as insertion in red-black trees so first
00:10 - of all go through that video that what
00:11 - is red-black tree if you know what is
00:13 - red-black trees then it would be easy
00:15 - for you to get this topic that is how to
00:18 - perform deletion in red-black tree as
00:19 - well as how to perform insertion right
00:22 - what is red-black tree it is a binary
00:24 - search tree or you can say it is a
00:25 - self-balancing binary search tree with
00:28 - some extra properties what are those
00:30 - properties root would be black second
00:33 - property was one there should not be any
00:35 - two adjacent red nodes means if parent
00:39 - is red then its children should be black
00:42 - third property was what that in each
00:45 - path from any node to its descendant nil
00:49 - node there should be same number of
00:51 - black nodes these three are important
00:54 - properties of red black tree right now
00:57 - how to perform deletion in red black
01:00 - tree see in case of insertion what we
01:02 - have done we simply follow the rules of
01:05 - binary search tree insertion right and
01:09 - if tree is empty then we create a black
01:12 - node and we will simply insert that node
01:14 - in the tree
01:15 - if tree is not empty then what you will
01:18 - do we always create a node in red color
01:22 - and we will insert as a leaf node then
01:26 - in that case which property is going to
01:28 - be violated that red red conflict
01:31 - property but if because if parent is red
01:33 - and always we will insert a node in red
01:36 - color then parent and child would be red
01:39 - but this should not be a case in that
01:41 - black tree right so for solving for
01:45 - resolving that conflict we need to do
01:47 - some rotations or 3-coloring fine now
01:50 - here in relation out of these three
01:53 - important properties of red black tree
01:55 - which property is going to be violated
01:57 - right see if you are going to delete a
02:01 - red node then there would not be any
02:03 - problem just to delete that node and
02:07 - exit right but if you delete a black
02:11 - node in that case
02:13 - which property is going to be violated
02:15 - that the number of black node in each
02:17 - path from any node to its descendant nil
02:21 - node would be same should be seen that
02:24 - property would be violated if you delete
02:27 - a black node because if you delete a
02:28 - black node then in that path the number
02:31 - of black node would be less than the
02:34 - other paths then you need to take care
02:37 - of that property so first resolving that
02:39 - issue you need to do some rotations
02:43 - maybe some recoloring as well many cases
02:46 - are there we will see all the cases
02:48 - simplest cases what if you want to
02:51 - delete the red node simply delete it no
02:54 - need to do anything but if you want to
02:57 - delete a node and that node is black
02:59 - node in that case you need to do
03:01 - something now in deletion the very first
03:04 - step is what you have to perform just
03:07 - standard a binary search tree deletion
03:10 - right now how to delete see I have
03:14 - already discussed insertion and deletion
03:15 - in binary search tree you can check out
03:18 - that video in the cybertor right suppose
03:20 - I am taking this is a binary search tree
03:21 - and here you want to delete this to L
03:25 - first of all we need to search 12 where
03:28 - is 2 L industry we have the address of
03:30 - the root node we are going to start from
03:32 - here 2 L is greater than 10 so we know
03:35 - that 2 L would be here in the right
03:39 - subtree of this and no need to check the
03:42 - left subtree right now again 15 mins 2 L
03:46 - is less than 15 so just go left so here
03:49 - you find to it right now if the node you
03:52 - want to delete is having no children I
03:56 - am just considering I'm just taking okay
03:58 - so binary search tree I'm not taking red
04:00 - black tree here all right so simply
04:03 - delete it no need to do anything right
04:05 - now second case was if the node you want
04:08 - to believe is having only one child
04:10 - suppose I want to delete this 7 first of
04:12 - all search this 7 right compare with
04:14 - this 10 less than 10 so we are going to
04:18 - to the left of the strength now here you
04:20 - got 7 of 7 is having only one child no
04:23 - problem what you will do see
04:25 - now see seven is what an internal node
04:28 - so one thing you need to take care when
04:32 - you are going to perform deletion in
04:33 - binary search tree all in red black tree
04:35 - we do not delete internal nodes right
04:40 - we always delete leaf nodes now seven is
04:44 - what internal nodes so you are not going
04:45 - to delete this node you are going to
04:47 - replace it now you are going to replace
04:50 - it with its child because it is having
04:53 - only one child so here you put nine now
04:57 - here we have nine and nine two lines are
04:59 - there now recursively you are going to
05:01 - call the delete function on this child
05:04 - and now we are going to delete this
05:06 - child all right so after deletion this
05:09 - is the binary search tree internal nodes
05:14 - we are not going to delete only we will
05:16 - delete the leaf nodes internal nodes is
05:19 - going to be replaced with its children
05:23 - right with which shall Charlie you need
05:26 - to take care of that thing now third
05:28 - case was if suppose I want to delete
05:30 - suppose this ten now n is having two
05:34 - children now we are we will replace this
05:37 - ten with which children with nine or
05:40 - fifteen or with what this thing you need
05:43 - to take care now here two cases are
05:44 - there either you can replace it with its
05:47 - inorder predecessor or inorder successor
05:50 - two cases are there so these two
05:53 - approaches are there suppose I'm
05:55 - replacing the stand with its inorder
05:57 - predecessor predecessor means in order
05:59 - predecessor means the largest element
06:02 - from the left subtree of that node
06:05 - because i am i want to replace this 10
06:08 - so find out the left subtree of this 10
06:10 - and from that left subtree the largest
06:13 - element would be the inorder predecessor
06:16 - means here we have only one element that
06:18 - is nine so you can replace this with
06:20 - nine or if you follow this approach if
06:23 - you will follow this approach then you
06:24 - are going to replace this 10 with its
06:26 - inorder successor now how to find
06:28 - inorder successor the smallest element
06:31 - from the right subtree of that node
06:34 - right I want to replace this 10 or you
06:37 - can say I want to delete this
06:38 - so the right sub-tree of this 10 is this
06:41 - one now the smallest element from the
06:43 - right subtrees 2n so we are going to
06:45 - replace this 10 with this 12 see how to
06:47 - find this in order predecessor successor
06:49 - and how to replace that node this thing
06:52 - we have already discussed in detail when
06:54 - we were discussing the BST insertion and
06:57 - deletion so you can check out that video
06:59 - in the description box as well right now
07:02 - first step is in this in this deletion
07:05 - in red black trees would simply perform
07:07 - standard BST deletion right the same
07:10 - rules here we have discussed these rules
07:12 - would be followed after that you need to
07:15 - take care of that property that is that
07:17 - red black property of the string so now
07:21 - we will see all the cases one by one
07:23 - with the help of example and at last you
07:26 - will also discuss that we will take
07:29 - example of one red black tree and we
07:31 - will apply the deletion operation and we
07:33 - will discuss all the cases in one
07:35 - example right now first step is simply
07:38 - perform BST deletion so you should know
07:40 - how to perform BST deletion right
07:42 - suppose I am taking this as a red black
07:45 - tree now you can see this is a red black
07:47 - tree because this is a binary search
07:48 - tree first of all root is black know red
07:51 - red conflict is there and height you can
07:55 - say that from any node the path every
07:58 - path from the node to its descendent nil
08:00 - is having same number of black nodes
08:03 - right now here the case one is what if
08:07 - the node you want to believe is a red in
08:10 - that case just delete it this is the
08:12 - simplest case and deletion right so
08:16 - suppose here I want to delete 30 now
08:19 - first step is you need to search where
08:22 - is 30 means binary search you need to
08:24 - apply here compared with this root
08:26 - because I am having the address of the
08:28 - root node only right 30 is greater than
08:31 - 10 go to the right side that is greater
08:33 - than 20 go to the right side here we got
08:35 - 30 right and this node is ha this is
08:40 - what leaf node or here somewhere it is
08:42 - also written that because obviously we
08:44 - are we are having here null null here
08:46 - also null null and null or you can say
08:50 - nil and all the nil
08:51 - nodes are having color black right now
08:55 - if you want to delete this 30 and it is
08:58 - humming only nil children know not
09:02 - knowledge children is there so now and
09:04 - the red is the color is red so simply
09:07 - delete it right and if you delete it so
09:12 - here somewhere it is also written that
09:13 - when you delete it then simply replace
09:16 - it with this either of its nil children
09:19 - so here you can write nil and this is
09:22 - also in black in color so you can see it
09:26 - is still a red black tree right root is
09:29 - black in every path see here you can say
09:31 - here we have one in two black node 1 in
09:33 - 2 here also 1 & 2 & 1 & 2 somewhere
09:36 - they count that one two and three this
09:38 - nil also has a black node but here I'm
09:40 - not counting this thing or some
09:42 - somewhere it is counted that they don't
09:45 - count this root in the path because this
09:49 - is always black so they count this 1 1 &
09:51 - 2 1 & 2 1 & 2 & 1 & 2 it's up to you
09:54 - have you you are going to count but the
09:56 - logic would be correct right so now the
09:59 - node was red we simply deleted it no
10:02 - need to do anything now here I am
10:04 - writing simply like this I'm not writing
10:06 - the null nodes because these are null
10:09 - node so no need to write down those
10:11 - notes right now second case is now
10:15 - suppose here I want to delete 20 now
10:20 - search where is 20 greater than 10 so
10:23 - here I got 20 but 20 is what is having
10:26 - one child so it is internal node so you
10:30 - cannot delete this 20 internal we cannot
10:33 - delete internal nodes we can replace
10:35 - those nodes so now with which node you
10:40 - are going to replace this 20 because it
10:42 - is having only one child so just follow
10:46 - the rules of BST deletion we are going
10:49 - to replace this 20 where this 30 now
10:51 - Here I am writing 30 now 30 is read but
10:56 - here I am not recoloring it this is
10:59 - still black why so because here we are
11:03 - not going to believe this
11:04 - node and if you will not delete this
11:08 - node then this node still having its
11:12 - color black we are just replacing the
11:15 - value now rather than 20 here we have
11:19 - replaced to this 30 we are not deleting
11:22 - this node so that is why internal node
11:25 - will always preserve its color its
11:29 - retain its color if it is black it would
11:32 - be black if it is red internal node is
11:34 - red it would be red because the common
11:36 - sense is what if you don't delete any
11:38 - node then obviously the color of that
11:40 - node would be same now right so we are
11:44 - just replacing this we are putting this
11:46 - 30 here now we have 230 here now apply
11:49 - that delete function on its inorder
11:52 - successor or you can see on the children
11:55 - all right so now delete this one this is
11:58 - red so if the node to be deleted is red
12:01 - this is leaf node now so we can simply
12:03 - delete it right we can delete leaf node
12:06 - we cannot delete internal nodes so
12:08 - simply delete it
12:09 - I am NOT replacing this with rights nil
12:12 - children or you can do it something like
12:14 - this here nil nil nil and name so here
12:17 - what you can write if the node to be
12:19 - deleted it is rather than just deleted
12:21 - and if the node you want to believe is
12:24 - black with one child in color red then
12:29 - simply replace that node with its child
12:32 - right and delete that child because
12:36 - child is red so simply you can delete
12:38 - that and that node would be having its
12:40 - own color because we are not going to
12:42 - change this its color right now let us
12:45 - take few more example of this case so
12:48 - here in this example I want to delete
12:50 - suppose 30 now search where is 30 start
12:54 - from the root 30 is greater than 10 so
12:55 - to the right of this root now here I go
12:58 - to 30 but this is what internal node
13:00 - here you can see this is having left and
13:02 - right both the child so the case is what
13:05 - either you can select in order
13:06 - predecessor to replace this or inorder
13:08 - successor here i am following the
13:10 - approach where i am going to select
13:11 - inorder successor right now see this 30
13:16 - is internal node so we cannot delete
13:18 - you can only replace it we will delete
13:20 - the DF node this point is very important
13:23 - you need to take care of this point so
13:25 - now that inorder successor would be what
13:27 - the smallest element from the right
13:30 - subtree of that node because I want to
13:32 - delete this 30 so the right subtree of
13:34 - this node is this one smallest element
13:36 - is 38 so we will replace this way this
13:39 - 38 means rather than 30 here you will
13:41 - write 38 but the color would be same see
13:45 - it is internal node you are not going to
13:46 - delete the node that is why the color
13:49 - would be as a tease if 30 it's not like
13:53 - that if 38 is black or it's red then you
13:55 - are going to take the color of 38 only
13:58 - know the internal node will having its
14:00 - own color so we are not going to change
14:02 - its color that would be red only now
14:04 - that on that inorder successor now you
14:07 - are going to call recursively that
14:09 - delete function here now can you delete
14:12 - this 38 yes obviously it is the leaf
14:14 - node and it is red so simply delete it
14:18 - you not no need to do anything so you
14:20 - can simply delete it right or you can
14:24 - say here we will replace the 30th with
14:26 - it's nil children so nearly black each
14:28 - node is humming male children right as
14:31 - you can see this is still a red black
14:33 - tree no red it conflicted is there in
14:36 - each path we are having same number of
14:37 - black nodes and do this black right let
14:40 - us take another example now let us take
14:43 - this example here also see this is a red
14:45 - black tree you can check out all the
14:47 - properties now here also I want to
14:48 - believe this 30 first of all search
14:50 - where is 30 it is greater than 10 so
14:53 - here I got 30 now it is having two
14:54 - children now I will replace it with its
14:57 - inorder successor you know the successor
14:58 - is what from the right subtree of this
15:01 - 30 find out the smallest element
15:02 - smallest element from this is what 35
15:05 - right so now here you will write 35 35
15:11 - right and it will it is black so it is
15:13 - going to contain its own color right
15:15 - because it is internal node we will not
15:17 - delete internal own now the problem is
15:20 - we have 235 now on that inorder
15:23 - successor called the delete function
15:25 - recursively not now you want to believe
15:27 - this one right but this is still having
15:29 - one child
15:31 - so we will not believe this we will
15:33 - replace this so here we will write 38
15:38 - and it will contain its own color right
15:41 - it's not like that 38 is red so we are
15:43 - going to make it red no it is internal
15:46 - node will not delete this so it is
15:47 - having its own color now 38 38 now again
15:51 - recursively call or delete function on
15:53 - this 38 now it is red so simply deleted
15:57 - right so as you can see this is still a
16:00 - red black tree right so not the problem
16:05 - comes when you will delete a black node
16:07 - and that black node is having black
16:09 - children right so there for double black
16:13 - situation will arise and the main task
16:15 - here is what you need to convert that
16:18 - double black into single black and for
16:21 - that you need to have some cases so
16:24 - we'll discuss all the cases with the
16:26 - help of example now now suppose here I
16:29 - want to delete this 20 right first of
16:32 - all search where is 20 to the right of
16:34 - this 10 it is having two children so
16:36 - which with which children you are going
16:38 - to replace it with inorder successor
16:39 - from the right subtree find out the
16:42 - minimum element in the right subtree we
16:43 - have only 30 so we are going to replace
16:45 - it with 30 right and we are not deleting
16:48 - this one so we are just replacing it so
16:51 - it will contain its own color right
16:53 - we're not going to affect this color now
16:56 - again called lead function on its
16:58 - inorder successor now if you delete this
17:01 - 30 obviously this leaf node so you can
17:04 - delete it but here the situation is what
17:06 - it is black it is not red so it's not
17:09 - like that you simply delete it no why so
17:13 - they can see this is having nil nil all
17:16 - are having it's nil children and these
17:20 - nil are black so by default if this is
17:23 - red what we have done we simply replace
17:26 - it with its nail children but here this
17:30 - is black you want to delete this node
17:32 - this is black and you will replace it
17:34 - with it's nil children and the nil
17:37 - children is also black so now this is
17:41 - situation of double black so if you
17:43 - delete
17:44 - and you will replace it with its nil so
17:48 - it's own color was black and the
17:50 - children color is also black so it is
17:53 - now double black this is the case now
17:57 - what you can say it is now DB double
18:00 - black note you need to take care of this
18:03 - node now this is the main problem in
18:05 - deletion in red block right now you need
18:07 - to convert it into single block Y so see
18:09 - now check out in each path here we have
18:12 - two black node here also we have two
18:14 - black nodes but here we have only one
18:17 - black node because we obviously we are
18:20 - not going to count this nil node so you
18:22 - will not count this nel node so in this
18:24 - path from here to this nil node we have
18:27 - only one black node so the main property
18:31 - which is violated here is what because
18:35 - of the listeners of black node in this
18:38 - path we have one less black node so it
18:41 - has it has affected the black height no
18:44 - you need to take care of this thing now
18:45 - so here we have multiple cases right now
18:49 - see first case is simple if the root is
18:53 - double black so simply remove double
18:56 - black right suppose because of some
19:00 - situations you got double black at the
19:04 - root right this is root this is double
19:08 - black and here we have left subtree and
19:12 - here we are right subtree right no need
19:15 - to do anything
19:16 - simply remove this double black and make
19:18 - it single duck right this situation will
19:21 - discuss with the help of example this is
19:22 - the simplest case in this scenario right
19:25 - next situation is what now if the node
19:30 - is double black right so to resolve this
19:34 - conflict we will always check its
19:38 - sibling right see in case of insertion
19:42 - we have checked the uncle of that node
19:46 - right I guess you remember or you can
19:49 - say that parents sibling according to
19:52 - that we decided which rotation or which
19:54 - case we need to follow but here when we
19:57 - will
19:57 - check the sibling of that double black
20:00 - note and according to that we will
20:01 - decide which case you are going to apply
20:03 - right now first case in this key in this
20:07 - is what if the double black nodes
20:10 - sibling is black and both its children
20:16 - are also black so let us take that
20:18 - example so now let us take this example
20:22 - here in this example this is a red black
20:24 - tree and here I want to believe this
20:26 - from here I want to delete 15 right so
20:28 - search where is 15 to the right of the
20:31 - stain to the left of this 20 here we
20:32 - were 15 now see we cannot simply delete
20:36 - this 15 it is a leaf node and you cannot
20:38 - delete it like this because it is having
20:41 - color black if it is red then you can
20:43 - delete it it is having two nil children
20:46 - which are also black this is also having
20:49 - nil nil in the land name now if you will
20:52 - delete this one then you will replace
20:54 - this with its children one of its
20:56 - children that is nil and this is black
20:59 - and the children color is also black so
21:01 - this is now you can say double black DB
21:06 - right I'm not showing these Nell
21:09 - children so now in this path from here
21:11 - to here because obviously we are not
21:13 - going to count the snell while we are
21:16 - counting the black node in the path so
21:18 - it is having only one black node here we
21:21 - have one into here we have one and two
21:22 - so now we need to solve this problem now
21:24 - to solve this problem this double black
21:27 - node will always check its sibling
21:32 - sibling is 30 check the color of sibling
21:35 - it is black right and sibling children
21:39 - are two nil and nil and color of nil
21:43 - children is also black as we know right
21:46 - so now BB's sibling is black and both
21:50 - its children are black so this is the
21:53 - situation now now what does DB will do
21:56 - see here you can relate it with this
22:00 - example that red means if someone is
22:02 - angry then
22:03 - his face becomes you know red so 20 is
22:08 - angry if someone is cool then he is
22:12 - black right now this is double black
22:17 - means this is also a problem you cannot
22:20 - be so much cool or come sometimes you
22:24 - need to be angry sometimes you need to
22:25 - show your anger right so this is a
22:28 - problem double black says question is
22:30 - also not good so now it will see he will
22:34 - see its sibling it is black cool he is
22:38 - cool
22:39 - so this the sibling doesn't need any
22:43 - black color now because it is already in
22:46 - black its children is also black so now
22:49 - all the three are black so he cannot
22:53 - give its extra black to either of these
22:57 - three nodes neither to its sibling no to
23:00 - its children now what he will do he will
23:05 - ask to its parent right and obviously he
23:09 - will give its extra black or you can say
23:12 - that its problem to its parent right so
23:16 - now here first of all remove this BB so
23:20 - it is simply single black now and add
23:24 - black woods parent so now parent is red
23:27 - so parent becomes black right now what
23:33 - you will do when it's sibling come to
23:38 - know that he has given his problem to
23:42 - parent then what the sibling becomes
23:46 - angry right that why you are giving you
23:49 - why you are troubling our parent fine so
23:52 - now it will become red now the steps are
23:57 - what if this is a situation then what we
24:00 - have done
24:01 - simply remove this BB first of all and
24:07 - what we have done done add black to its
24:13 - parent
24:16 - and black boots this was double black
24:18 - node to its parent right now here also
24:21 - pool situations can be there if the
24:23 - parent is already black then it will
24:25 - become double black and if the parent is
24:27 - red then it will become single black
24:29 - here the parent was red so here also two
24:32 - situations are there if the other than
24:37 - parent I'm writing P P is red now next
24:42 - thing what we have done the sibling
24:44 - becomes now red so now next step is what
24:48 - make sibling red sibling means sibling
24:55 - of double black node because double
24:57 - black node is having problem number are
24:58 - discussing the cases on this double
25:00 - black so sibling means double black
25:02 - sibling becomes now red right now if
25:07 - still the problem of double black exists
25:09 - then we will apply some other cases
25:11 - right so now and what are these other
25:15 - cases that thing also we will discuss
25:17 - one by one right now here see there is
25:20 - no double black problem exist now right
25:22 - so now it is done so we can remove the
25:25 - snow this is also nil so you can remove
25:27 - it so now as you can see this is a red
25:30 - black tree rudest root is black in this
25:33 - path one and two blacks one in two
25:35 - blacks one in two here also one and two
25:37 - and one and two right now if the parent
25:40 - was red sorry the parent is black so it
25:43 - would become double black and here still
25:45 - the double double black situation is
25:46 - there so we will apply some other cases
25:48 - right that him also will discuss I hope
25:51 - you go to these points so now here let
25:54 - us discuss this case that parent is
25:56 - already black so it will become divided
25:57 - black see let us take this case this is
26:00 - a red black tree perfect by new trees
26:02 - there and all the nodes are black so
26:03 - this is a red black tree now delete here
26:06 - 15 see 15 is black so you cannot simply
26:09 - delete it because it is having two nil
26:12 - children those are black so we will
26:14 - replace this 15 with it's nil children
26:16 - so Nell is also black and this is
26:18 - already black so it will become double
26:20 - black so now here this is Nell and it
26:23 - will become now you can say double black
26:25 - so here the situation is there the
26:27 - problem is there because see
26:29 - in this path we have only one end to
26:31 - black notes and all the other parts are
26:34 - having three black notes right because
26:36 - this is nil we are not going to count it
26:38 - so now we need to take care of this
26:40 - thing so now apply the cases check out
26:43 - the double black sibling sibling is
26:45 - black the two children of sibling is
26:48 - also black so this is the case right now
26:51 - here what you will do simple first step
26:53 - is remove dB remove double black so it
26:56 - is now single black right and it is now
27:03 - give its black extra black to its parent
27:07 - right same you can discuss that see this
27:12 - is what black means cool red means angry
27:15 - so now this is what a double cool so
27:18 - that is also a problem he'll ask to its
27:21 - sibling but sibling is cool he doesn't
27:24 - know need any black node or you can say
27:26 - no more coolness he needs children is
27:30 - also black so they don't need any extra
27:32 - black so what it will do it will ask to
27:35 - it's obviously parent right because if
27:38 - children is in problem so he'll go to it
27:41 - he'll go to his parent right so now
27:44 - he'll go to his parent and give its
27:47 - extra black or give its problem to its
27:49 - parent so now parent becomes double
27:52 - black why so because parent is already
27:55 - black so it means it becomes double
27:57 - black and it becomes now single black
27:59 - now sibling becomes red sibling becomes
28:03 - angry why so because he'll say why you
28:06 - are giving your own problem to our
28:08 - parent why you are troubling your parent
28:11 - so now it becomes red sibling becomes
28:14 - angry makes sibling red now here still
28:19 - DB exists in this case right so you need
28:22 - to follow some other case now which case
28:25 - you need to apply here see this is the
28:27 - node which is having problem so he'll
28:30 - check its sibling sibling is black
28:32 - children both children are black so he
28:36 - they they don't need any extra black
28:39 - because they are already cool so now
28:41 - what
28:43 - he'll ask to its parents means he will
28:46 - give its problem to parent right so
28:50 - parent is already black so now you can
28:52 - say first of all remove this DB it has
28:55 - become now single black and parent
28:57 - becomes now double black because parent
28:59 - is already black now after doing this
29:04 - now sibling becomes angry why so because
29:06 - he'll say why you are giving your own
29:08 - problem to our parent right so now it
29:11 - will become red from black to red now
29:15 - the situation
29:16 - see now here still inner problem we have
29:19 - double black situation now which case is
29:22 - there identify the cases now see double
29:25 - black is what root root is double black
29:27 - this is root so simply remove double
29:30 - black no need to do anything
29:31 - so simply remove it and it will become
29:33 - single black right and that's it so you
29:37 - can see this is water red black tree you
29:40 - can count the black nodes 1 & 2 1 & 2
29:43 - here also 1 & 2 and here also 1 & 2
29:45 - because this is nil
29:46 - so we will simply delete it so here also
29:49 - 1 & 2 right now check out the next case
29:54 - so now let us take this case and here
29:57 - this is a red black tree and from here I
29:59 - want to believe this 15 right now such
30:03 - where is 15 here you got 15 but you
30:05 - cannot simply delete it because this is
30:07 - black so now after deleting this 15 it
30:10 - will become because obviously it is
30:12 - having Nell children we will replace
30:14 - this with this nil and it will become
30:16 - now double black because it is already
30:18 - black and its children is also black
30:20 - with which you are going to replace it
30:22 - so it will double black now now find out
30:24 - which case you need to apply to find out
30:26 - the cases simply check the sibling of
30:29 - double black right check the sibling of
30:32 - double black after that after that you
30:35 - will check the this children of the
30:38 - sibling right the children which is away
30:41 - from double black and after that you
30:43 - will check this children these cases
30:46 - also we will discuss now we have already
30:48 - discussed this case when sibling and its
30:50 - children were black now second case is
30:53 - now here the sibling of double black is
30:55 - ready so this case is their right here
30:59 - we have discussed two sub cases right
31:01 - now this is red now what you will do see
31:04 - it means the sibling of double black is
31:07 - angry so now he wants his sibling to
31:11 - come down right now
31:14 - he cannot directly go to his sibling
31:17 - mean generally suppose two brothers are
31:19 - there so if one is angry so second
31:22 - brother will go to his parent and ask
31:26 - his parent to for his brother come down
31:29 - right now he lasts to its parent and he
31:33 - will send his parent to his brother to
31:38 - come down his brother right or you can
31:40 - say is sibling now when the parent will
31:43 - go and tell him to come down then it
31:48 - will become black right but in that
31:51 - process the parent will become angry so
31:55 - parent will become red because generally
31:58 - it happens when you are angry and your
32:00 - parent comes to calm you down
32:03 - to pull you down then they will become
32:06 - angry and then after that you will be
32:08 - like silent so now we are going to swap
32:14 - the colors now the the sibling becomes
32:16 - red to black but parents become from
32:19 - black to red first step is this one
32:22 - right but still the problems is their BB
32:25 - problem is their double black problem is
32:26 - there now second step is what the parent
32:30 - will rotate in the double black node
32:35 - direction right second step is this one
32:38 - so now after rotation the parent will
32:41 - rotate towards this direction because
32:45 - this children of parent is having
32:47 - problem this child is having problem so
32:49 - parent will go will always rotate
32:51 - towards the the child who is having
32:55 - problem right so now this rotation you
32:58 - can say the left rotation or you can say
33:00 - in the direction of BB the parent will
33:03 - rotate now after rotation the tree would
33:05 - become after rotation 20 would be down
33:09 - third
33:09 - we'll go up 30 is black 30 is having
33:13 - right child does 40 and now 30 is up 20
33:18 - is down so 20 is to the left of this one
33:21 - and here we have to the left of 20 we
33:24 - have null that is double black 20 is
33:26 - what red now where 25 will go 25 is to
33:30 - the left of 30 and to the right of 20
33:33 - right this is black this is black and
33:37 - this is black and this would be same
33:39 - this side would be same right now still
33:43 - after rotation still we have double
33:45 - black problem so now you need to again
33:48 - check which case you need to apply right
33:51 - so now this case in this case steps
33:54 - would be what first of all what we have
33:57 - done we have swapped color of its
34:00 - sibling and parent right so now here you
34:03 - can write swap colors of parent or you
34:10 - can say double black parent of double
34:13 - black right and it's sibling properly
34:16 - you can write this thing so parent and
34:22 - it's sibling right after swapping the
34:28 - colors we have done rotations rotations
34:30 - in this direction in DB direction right
34:34 - see this case is having its mirror image
34:37 - if bb's in this direction in that case
34:39 - this will rotate in this direction that
34:40 - thing also we will discuss right that is
34:42 - why I am saying that rotate the parent
34:44 - towards bv direction see here parent
34:48 - parent off you can write down properly
34:51 - parent of double black node in double
34:53 - black node direction right I am writing
34:56 - it in short cut and again reapply cases
34:59 - right now this is the scenario here
35:01 - which case you need to apply check out
35:03 - still we have double black situation now
35:06 - check out the to find out which case we
35:08 - need to apply check out the sibling of
35:10 - double black sibling is black now check
35:13 - out the children children is also nil
35:15 - and male that is black and black so this
35:16 - case you need to apply now write what is
35:19 - this case simply remove DB here we have
35:23 - means one black oniy right and add black
35:27 - to its parent so he'll give its problem
35:30 - to its parent the parent is red so it
35:33 - becomes black right this is the case
35:37 - parent is red it becomes black and after
35:40 - that sibling makes sibling red so now
35:43 - sibling becomes angry that why you are
35:45 - giving your problem to our parent so
35:48 - sibling becomes angry now
35:49 - now if still DB exists but in this case
35:52 - there is no DB problem exists now this
35:54 - is the final tree after deleting this 15
36:01 - and as you can say this is now a red
36:04 - black tree from here this is null so you
36:06 - can delete it now what can be the next
36:10 - case
36:11 - so now we'll discuss the case 5 let us
36:13 - take this example right this is a red
36:16 - black tree and from here I want to
36:17 - delete this one in one example I'm I
36:20 - want to discuss more than this one case
36:23 - two or three cases I'll discuss now see
36:25 - if you delete this one right first of
36:29 - all search where is one this is black so
36:31 - we will replace it with its null null
36:34 - node and it will become double black now
36:36 - right so here we have the problem now
36:39 - find out which case you need to apply to
36:41 - find out this thing just check the
36:43 - sibling of double black sibling is what
36:45 - black now children of the sibling say
36:49 - this is also black this is also black
36:51 - because these are new so now this case
36:54 - you will apply first of all right so now
36:57 - he'll give its problem to its parent so
37:00 - now remove this double black this would
37:02 - become single black now null and a
37:04 - parent is black already black so it
37:06 - would become now double black right now
37:09 - still problem of double black exists now
37:12 - reapply cases now find out which case
37:15 - you need to apply now this is the node
37:18 - which is having problem now check out
37:20 - the sibling of this node that is 30
37:22 - which is black right now check out this
37:26 - node sorry this children of sibling see
37:29 - it is having two children which children
37:32 - is near to this double black node this
37:35 - one and which is
37:36 - are from this this one so first you will
37:39 - check sibling this is black now the
37:41 - child who is far from double black this
37:46 - situation siblings child who is far from
37:50 - double black this child is far from
37:52 - double black this is near so this is
37:54 - black right and the child which is near
37:57 - to double black is red and there but the
38:00 - near child of double black is red now
38:03 - this is the case now here what you need
38:06 - to do see here I'm not writing left
38:08 - child or right cell because all the case
38:10 - in this case or all the cases are having
38:12 - its mirror image right so if you write
38:15 - down the left and right child then that
38:17 - would create a problem in mirror image
38:18 - so that thing also I will discuss the
38:20 - mirror image of this thing fine now see
38:24 - the siblings child is red means he's
38:28 - angry right now this double black node
38:32 - will ask to its sibling to go to his
38:35 - child and cool him down right so now the
38:42 - parent will go to its children and cool
38:44 - him down but in this process the parent
38:47 - would become angry so you can say we
38:49 - will swap the color of sibling and its
38:52 - child so now this becomes black means
38:56 - cool down and this would become angry
39:00 - right this is the first step now
39:03 - rotation in this case also rotation
39:06 - would be required so now 30 becomes red
39:08 - right or you can say that he becomes
39:10 - angry and why he becomes angry because
39:13 - of because his sibling 30 sibling is 5
39:16 - because his sibling ask him to go to his
39:20 - hot chill to his child and cool him down
39:24 - that is why he becomes angry so you can
39:26 - say he becomes angry with its sibling
39:30 - that is why 30 would rotate in opposite
39:33 - direction to its sibling right not in
39:36 - this direction opposite direction to its
39:38 - sibling now the tree would be something
39:42 - like this so now when you will rotate
39:44 - this 30 in this right direction and 30
39:46 - would be downward and 25 would
39:49 - go up so 25 has here now having color
39:53 - black 30 is to the right of 25 if not as
39:56 - 30 is having color red here we have 40
40:00 - and through the left of 25 we have 20
40:03 - with color black and to the right of 25
40:06 - they are 28 to the right of 25 and to
40:08 - that now to the left of 30 that is here
40:11 - we are 20 and that is an black color now
40:14 - still we have problem of double deluxe
40:18 - situation now again you need to find out
40:21 - which case you need to apply right and
40:24 - after case 5 definitely you need to
40:27 - apply case 6 that is for sure right here
40:32 - we have applied case 5 first of all we
40:34 - applied case 3 then we apply case 5 and
40:37 - now you need to apply case 6 now what is
40:40 - case 6 see first of all write down the
40:44 - steps of this case I'm writing the steps
40:47 - here because see this step is very
40:49 - simple and this is very simple because
40:50 - if node is deleted you want to read it
40:52 - as read simply delete it so I'm writing
40:55 - the steps of this case here first of all
40:59 - what we have done we simply swap color
41:03 - off see this one and this one right
41:06 - means color of DB's sibling when it's
41:13 - child who is near to dB now after
41:18 - swapping the colors what we have done we
41:20 - have rotate the sibling of this BB in
41:22 - opposite direction to D be not in the
41:25 - direction of DB so now and now still the
41:28 - double black problem exists and
41:29 - definitely you need to apply case 6 so
41:32 - here you can write down apply case 6
41:36 - right now what is is 6 C so now I will
41:40 - discuss case 6 after applying case 5
41:43 - this should become this thing I guess
41:45 - this would be red right because when you
41:50 - will this double black this node will
41:53 - give its extra black book parent then
41:55 - the sibling becomes angry or you can say
41:57 - it becomes red now this is nel so you
41:59 - can delete it so now this is the tree
42:02 - now here what is case six now we'll
42:04 - discuss see this is not having double
42:07 - black situation now check out the
42:09 - sibling of double black this is black
42:10 - now this is having two children so first
42:13 - of all you will check the child who is
42:15 - far from double black say this is far
42:18 - from double black this is near to double
42:20 - so now this far child is red now now Moe
42:25 - need to check this child right if you
42:27 - find this is red now you have to do
42:29 - something now you can say this siblings
42:32 - the for child or you can say this child
42:33 - is angry so now he'll not directly go to
42:37 - his sibling and ask to cool his children
42:40 - down if the this this was this case this
42:42 - was the case if this chil the near the
42:45 - near children was red then he will ask
42:47 - to its sibling to go to his child and
42:51 - cool him down right now this is the far
42:53 - child so he'll ask to its parent to go
42:56 - and calm down his children right now if
43:01 - the parent will go in that case we will
43:04 - swap the parent and siblings colors here
43:08 - both are having black and black so
43:10 - swapping does not affect anything
43:12 - now if situation is something like this
43:14 - if this is red and this is obviously
43:15 - black in that case this will become
43:18 - black this would become red but here
43:20 - this is not the case both are black so
43:23 - no swapping would be there right now
43:25 - again next step is what now he'll rotate
43:29 - towards DB direction because in this
43:33 - case 10 then is the one who went to cool
43:38 - him down
43:39 - right so this would rotate in this case
43:42 - 30 rotated why so because 30 went to
43:47 - cool his children down that is why he
43:50 - will rotate and he was sibling of double
43:53 - black that is why rotate in opposite
43:54 - direction right and it is parent of
43:57 - double black so parent always rotate
43:59 - towards the child which is having
44:02 - problem right so now this is having
44:04 - problem so he will rotate towards this
44:06 - direction right now after rotation the
44:10 - tree would become
44:11 - ten would rotate it towards this
44:12 - direction 25 would go upward 25 is black
44:17 - now here we have 30 40 28 20 is to the
44:23 - left of 25 but to the left of 25 when
44:25 - you will rotate this tree so now here we
44:27 - have 10 so now 20 would be to the right
44:30 - of 10 and 5 is still having the problem
44:35 - of double black and here we have 7 that
44:37 - is red and this is black this is black
44:40 - black 30 is red sorry this was black and
44:46 - this is black now next step is what this
44:49 - remove this double black why so because
44:51 - see this double black node can push his
44:56 - double black problem upwards not
44:58 - downwards now the problem was the fire
45:01 - child was red so he will give its extra
45:04 - black to 30 so the 30 would become now
45:07 - black and this would become single black
45:11 - and that's it now you can see this is a
45:15 - red black tree right after applying a 6
45:18 - so now these are all the cases and these
45:21 - cases are having its mirror image also
45:24 - like this here the DB is in this
45:27 - direction but suppose DB is in this
45:29 - direction and this direction and we have
45:32 - sibling of this DB right so now the far
45:36 - child of DB would be this one and the
45:38 - near child will be this one right so you
45:41 - need to take care of this thing also but
45:43 - apply the same rules in mirror image
45:45 - also right so now we will take one
45:47 - example and we will discuss the deletion
45:49 - process in red black tree now let us
45:51 - take this example one by when we are
45:53 - going to delete these numbers so this is
45:55 - a red black tree as you can see now
45:56 - first of all delete 55 search where is
45:59 - 55 from the root 55 is greater than this
46:02 - one less than this one so here we go to
46:04 - 55 right you cannot directly delete it
46:06 - because this is black node right and
46:09 - children obviously nil and nil those are
46:11 - also black so if you will delete this
46:13 - thing so we will replace this with nail
46:16 - and
46:17 - black so that is why it will become
46:19 - double black because this was already
46:22 - black now the problem is there now you
46:24 - have to convert it into single black now
46:26 - apply find out which case you need to
46:28 - apply to find out this thing simply you
46:31 - need to do you need to check out the
46:33 - sibling of double black sibling is red
46:35 - it means this case for you need to apply
46:38 - it means sibling is angry right so now
46:42 - he can see he can give its extra black
46:46 - to its sibling but right now cannot give
46:49 - because these are at same level and it
46:51 - can push its problem to upwards only
46:55 - right not downwards and not at the same
46:58 - level right so now he'll ask to its
47:01 - parent to go and cool his brother or
47:06 - it's his sibling down right so now
47:08 - parent will go so that is why the parent
47:12 - now become red and now it becomes black
47:15 - because during this process parent
47:18 - become angry and that child who was
47:22 - angry becomes cool down now now parent
47:25 - is angry
47:26 - so now parent will rotate in which
47:29 - direction parent will always rotate in
47:31 - the direction the child in the direction
47:33 - of the child who is having problem and
47:35 - now this child is having problem right
47:37 - so parent will rotate in this direction
47:39 - so 65 would go downward 70 would go
47:42 - upward right so now that tree would be
47:45 - something like this so now this is the
47:47 - tree after applying case for still we
47:50 - have DB problem see we have done
47:53 - swapping of parent color of the parent
47:56 - and its sibling rotate parent in baby's
47:59 - direction now you have to reapply cases
48:01 - now again check which case you can apply
48:03 - so now in this case now DB is this one
48:07 - this node is having DB problem so first
48:09 - of all check the sibling sibling is
48:11 - black now check the the child who is far
48:15 - from this TV that is nil that is black
48:17 - and this is also nil that is black so
48:20 - now you will apply case 3 this is black
48:23 - this is black this is black right so now
48:26 - he cannot give its extra black to any of
48:29 - these so now what
48:31 - he'll push his problem upwards he'll
48:33 - push the extra black boots parent of
48:36 - this week right so now the parent is red
48:39 - see 65 is red so now this parent becomes
48:43 - black and this would become single black
48:47 - and this is null that is why you can
48:50 - delete it means we will not write this
48:52 - thing right we have solved the problem
48:55 - now one more step one more step is what
48:57 - now this children has given its problem
49:00 - to parent now after looking this one the
49:04 - sibling becomes angry he will say why
49:06 - you are giving your problem to our
49:08 - parent right so now this was black so it
49:11 - would become now red right so now this
49:15 - is the tree because here now we don't
49:17 - have any double black problem so after
49:20 - deleting this 55 this as the final red
49:22 - loctite
49:23 - so now next you delete 30 so suppose
49:26 - this is no 20 this is 30 so now we need
49:29 - to delete this one first of all find out
49:32 - where is 30 less than 50 so here we got
49:34 - 30 now 30 is having two children so we
49:37 - will replace it with inorder successor
49:39 - you know the successor is 35 because in
49:42 - the right subtree only one node is there
49:44 - that is 35 so we will replace this 30
49:46 - with this 35 right and if you are going
49:50 - to replace it we are not going to
49:52 - believe the internal node that is why it
49:53 - will having its own color that is black
49:56 - only now 35 35 to 35 are there so now we
49:59 - recursively hold delete on this inorder
50:02 - successor right so we can not directly
50:04 - delete it because it is already black so
50:07 - now we will replace it with nil and it
50:10 - would become now double black right now
50:14 - the problem occurs now which case you
50:16 - need to apply see now check the siblings
50:19 - of double block now sibling of double
50:21 - black is this one so this is black it's
50:24 - first of all check the fire child this
50:28 - would be nil that is black near child
50:30 - this is also black now again you will
50:32 - apply here this one case 3 now in case 3
50:36 - what does the situation see now this
50:39 - double black will push it's problem
50:42 - upward you can say to its parent
50:44 - because these are all black no red is
50:47 - there right sibling and it's children so
50:51 - now he'll give extra black to its
50:54 - parents so now it 35 could become double
50:58 - black right some I'm I'm updating here
51:00 - only now this is 35 so this would become
51:03 - double black because this was already
51:04 - black and one extra black he has given
51:08 - to its parent so it would become double
51:11 - black now it would become single black
51:13 - that as null so if it is null so you can
51:16 - no need to write down the nun now after
51:19 - seeing this the sibling of double black
51:21 - would become angry that why you are
51:23 - giving your problem to our parent so
51:26 - that is why it will become red right now
51:30 - still the problem occurs now double
51:33 - black problem is here now again check
51:36 - out which case we need to apply now
51:37 - check out the sibling of this one
51:39 - sibling is black right now check out the
51:42 - far child from this double black this is
51:45 - also black now check out the near child
51:47 - this is also black
51:48 - now again you will apply this case only
51:50 - right now it will give its extra black
51:55 - to its parent right now the parent would
51:59 - become double black now 50 would become
52:01 - double black and it will become single
52:03 - block that is 35 only after seeing this
52:06 - the sibling of double black was this one
52:08 - this would become angry so it would
52:10 - become black to red now the double black
52:14 - situation still exists but here the
52:17 - double black is the root is double black
52:19 - so in that case you will do what simply
52:22 - remove the padlock right so simply
52:25 - remove it double black and 50 is become
52:28 - single black now so now this is the tree
52:32 - after deleting 30 so this as you can see
52:35 - it's a red black tree
52:36 - now from here delete 90 where is 90 here
52:40 - we have 90 see now the node of you want
52:43 - to delete is a red so you can simply
52:45 - delete it no need to do anything right
52:48 - because this is red and if you will
52:50 - replace it with nil then that would be a
52:54 - single black only no double black
52:56 - situation is there no need to write down
52:58 - so you can directly delete this 90 right
53:01 - now next we want to delete 80 from here
53:05 - now you will see the mirror image of the
53:08 - case we have discussed earlier see if
53:12 - you want to believe but this is already
53:13 - black node so you cannot simply delete
53:16 - it right we will replace it with its nil
53:19 - and it would become now double black now
53:22 - here the problem exists now you need to
53:25 - convert it into single black right now
53:28 - check out the sibling of double black
53:29 - that is 65 is the sibling sibling is
53:32 - black in color right after that check
53:35 - out the child of the sibling which is
53:37 - far from double black so this child is
53:40 - far from double black and this is nil
53:42 - and this is black only nil is always
53:45 - black right now check out the child
53:47 - which is near to the double black this
53:49 - is red now now which case you need to
53:52 - apply see this one now these are the
53:55 - steps now what you will do see now he
53:58 - will ask to its sibling that go to your
54:00 - child and cool him down because he is
54:03 - angry right so now he'll go to a chilled
54:07 - to a child and cool him down that is why
54:09 - it become now black but now he become
54:15 - red right now he was the one who went to
54:21 - cooled his children to cool his child
54:25 - down that is why he will rotate now so
54:28 - now he will rotate because he was the
54:31 - one who went to cool him to cool his
54:35 - child down so that is why he will rotate
54:37 - now he will rotate in opposite direction
54:39 - to DB why so because he asked to go him
54:45 - to a child and pull him down that is why
54:48 - he becomes angry now he is angry with
54:50 - his sibling also so now he will rotate
54:52 - in opposite direction to this DB so now
54:55 - the child so now the tree would become
54:58 - now it will rotate in opposite direction
55:00 - who 68 would go upward and 65-foot go
55:03 - downward now 65 is red and 68 is black
55:06 - and this is still a double black problem
55:10 - right and say
55:12 - these red now see applied k-6 because
55:16 - once you apply case five definitely you
55:19 - will reach to a situation where you need
55:21 - to apply case six now k-6 is what this
55:24 - is the problem node having problem DB
55:28 - problem so check out the sibling that is
55:29 - black now check out the child which is
55:31 - far from DB which is red for our child
55:35 - is red so that is why we breach to case
55:37 - six ultimately now applies case six now
55:40 - what you will do now see he lost to
55:44 - parent his parent to go and come his
55:48 - child down right now he will not
55:51 - directly ask to sibling to go to its
55:53 - children he lost to paint because this
55:56 - child is far from DB right now parent
56:01 - will go right so that is why we are
56:04 - going to swap the color of parent and
56:07 - its sibling so now see parent is red so
56:11 - it will become black and it is black so
56:13 - it will become red right after swapping
56:17 - colour of parent and sibling rotate now
56:20 - he was the one who went to calm his
56:25 - children down right so now that is why
56:28 - he will rotate now so now his parent of
56:31 - double black and parent will always
56:33 - rotate in the direction of DB right
56:35 - because this child is having problem so
56:38 - parent will need to rotate in the
56:39 - direction of the children which is
56:41 - having problem right so now after
56:43 - rotation three would be something like
56:45 - this 70 would go downward 68 would go
56:48 - upwards 68 is now red
56:50 - now after rotation remove DB so DB is
56:53 - this one so remove this thing this would
56:55 - become only null that is one black and
56:58 - change the color of red child see the
57:02 - red child was this one because because
57:05 - of the sixty five was red right
57:08 - so sixty five the fire child was red so
57:10 - it would become now black so 65 now
57:12 - becomes black see now it will push its
57:16 - problem upward right so 65 is one level
57:19 - up up from this so he can give one extra
57:22 - black to 65 now right so now
57:24 - only null so you can remove it no need
57:27 - to write it down so now this is the tree
57:28 - as you can see this is now a red black
57:30 - tree after deleting what 80 now we will
57:33 - delete 50 50 is having to child so we
57:38 - will replace it with its inorder
57:39 - successor
57:40 - you know the successor is what from the
57:42 - right subtree find out the smallest
57:43 - smallest is 65 so here you will write 65
57:47 - you are not deleting this we are
57:49 - replacing the value only so it would
57:50 - become it would remain it would you know
57:53 - retain its color right that is black now
57:56 - 265 are there so we will call
57:58 - recursively the delete function on this
58:00 - inorder successor so we will delete this
58:02 - one but this is black so you cannot
58:04 - directly delete it so it would become
58:05 - now double black right so now which case
58:11 - you need to apply sibling check out the
58:13 - sibling which is black check out the
58:15 - fart child of sibling that is nel that
58:17 - is black left child that does Anil that
58:19 - is also black now which case you need to
58:22 - apply case 3 in this case he will push
58:26 - its problem or you can say it's extra
58:28 - black boots parent right now parent is
58:31 - red so it would become now black right
58:35 - and it would become single black now
58:38 - after seeing this one the sibling
58:40 - becomes angry or you can say becomes red
58:43 - that why you are giving your problem to
58:45 - a parent right so now this is null or
58:48 - single black so you can delete it no
58:50 - need to write down the null so now this
58:52 - is that we after deleting 50 now next I
58:56 - want to delete 35 see where is 35 less
58:59 - than 65 here we have 35 right 35 is
59:02 - having one child that is red child so
59:05 - simply first of all we will replace this
59:08 - 35 whether it's child that is 15 but the
59:12 - color would be saying that is black
59:14 - because we are not going to believe the
59:17 - node we are just replacing the value
59:18 - right now we need to delete this 15
59:22 - right so now 15 is red so you can simply
59:25 - delete it no need to do anything so this
59:27 - is now a red black tree right now next
59:30 - digit 15 here we have 15 15 is black and
59:35 - it is having two nil child the
59:38 - are also black so you cannot directly
59:39 - delete it right so we will replace it
59:43 - with null and it would become not double
59:45 - black now check which case when you to
59:48 - apply double black sibling is black
59:52 - check out the fart child for child of
59:54 - double black is red now the situation is
59:57 - this one sorry situation is this one
60:00 - case six directly you need to apply case
60:02 - six now right now what you need to do so
60:07 - now he'll ask to its parent to go and
60:09 - ask you can say his sibling to pull his
60:12 - child down he will not directly ask to
60:14 - its sibling in this case if the cases
60:16 - for child is red if near child is red
60:19 - then he will directly ask to sibling to
60:22 - go and pull his child down right now if
60:26 - parent will go then parent and we will
60:29 - swap the color of parent and this
60:31 - sibling but both are black so no need to
60:33 - do any swapping right now after this
60:36 - after swapping this parent will rotate
60:39 - in which direction towards DB direction
60:43 - so now the situation would be sixty five
60:46 - would be rotated towards this 68 would
60:48 - go upward sixty it is black here we have
60:51 - 70 which is red 65 is black and here we
60:56 - have now double black right now now see
61:02 - this this child was red he was angry
61:05 - right the far child 70 so now the 70 is
61:08 - one level upwards to double black so now
61:10 - if he can give its extra black to this
61:13 - 70 spoon of 70 becomes black and it
61:16 - would become single black so you can
61:17 - remove it no need to write down this
61:19 - thing so this is the tree after deleting
61:21 - 15 so this is now you can see a red
61:23 - black tree so now suppose if you delete
61:26 - 65 I want to believe 65 see where is 65
61:29 - here we have but this is black you
61:31 - cannot directly delete it right so after
61:34 - deleting this this would become would be
61:35 - replaced by a null so it would become
61:37 - now double bla now check out which case
61:39 - you need to apply check out the sibling
61:41 - which is black the first child is also
61:43 - black the near child is also black
61:45 - because both are not so which case we
61:46 - need to apply this thing now he will
61:50 - push its problem to its parent that is
61:53 - the extra black he will give to its
61:55 - parent now parent is already black so it
61:57 - would become double black right and now
62:02 - it would become single black right so
62:04 - that's this is null so no need to write
62:06 - down this thing now after seeing this
62:08 - situation that the sibling becomes red
62:11 - sibling becomes angry now still double
62:15 - black problem exists in our tree so now
62:18 - double black root is now double black so
62:20 - simply remove it no need to do anything
62:22 - simply remove double black now suppose
62:26 - if you delete 68 in that case what you
62:29 - will do 68 is having only one child so
62:32 - first of all you will replace this with
62:35 - its child that is 70 and we will simply
62:38 - replace it the change the color would be
62:40 - same internal node will be retain its
62:43 - own color right now we delete this one
62:46 - so this is red so you can simply delete
62:48 - it right so this is how we are going to
62:52 - perform delete operation in red black
62:54 - tree I hope I have discussed all the
62:56 - cases with the help of an example if you
62:58 - have any problem then you can write me
63:00 - down in the coming box right so now I
63:02 - will see in the next video till then bye
63:04 - bye take

Cleaned transcript:

so the topic is deletion in redblack trees see we have already discussed introduction to redblack tree as well as insertion in redblack trees so first of all go through that video that what is redblack tree if you know what is redblack trees then it would be easy for you to get this topic that is how to perform deletion in redblack tree as well as how to perform insertion right what is redblack tree it is a binary search tree or you can say it is a selfbalancing binary search tree with some extra properties what are those properties root would be black second property was one there should not be any two adjacent red nodes means if parent is red then its children should be black third property was what that in each path from any node to its descendant nil node there should be same number of black nodes these three are important properties of red black tree right now how to perform deletion in red black tree see in case of insertion what we have done we simply follow the rules of binary search tree insertion right and if tree is empty then we create a black node and we will simply insert that node in the tree if tree is not empty then what you will do we always create a node in red color and we will insert as a leaf node then in that case which property is going to be violated that red red conflict property but if because if parent is red and always we will insert a node in red color then parent and child would be red but this should not be a case in that black tree right so for solving for resolving that conflict we need to do some rotations or 3coloring fine now here in relation out of these three important properties of red black tree which property is going to be violated right see if you are going to delete a red node then there would not be any problem just to delete that node and exit right but if you delete a black node in that case which property is going to be violated that the number of black node in each path from any node to its descendant nil node would be same should be seen that property would be violated if you delete a black node because if you delete a black node then in that path the number of black node would be less than the other paths then you need to take care of that property so first resolving that issue you need to do some rotations maybe some recoloring as well many cases are there we will see all the cases simplest cases what if you want to delete the red node simply delete it no need to do anything but if you want to delete a node and that node is black node in that case you need to do something now in deletion the very first step is what you have to perform just standard a binary search tree deletion right now how to delete see I have already discussed insertion and deletion in binary search tree you can check out that video in the cybertor right suppose I am taking this is a binary search tree and here you want to delete this to L first of all we need to search 12 where is 2 L industry we have the address of the root node we are going to start from here 2 L is greater than 10 so we know that 2 L would be here in the right subtree of this and no need to check the left subtree right now again 15 mins 2 L is less than 15 so just go left so here you find to it right now if the node you want to delete is having no children I am just considering I'm just taking okay so binary search tree I'm not taking red black tree here all right so simply delete it no need to do anything right now second case was if the node you want to believe is having only one child suppose I want to delete this 7 first of all search this 7 right compare with this 10 less than 10 so we are going to to the left of the strength now here you got 7 of 7 is having only one child no problem what you will do see now see seven is what an internal node so one thing you need to take care when you are going to perform deletion in binary search tree all in red black tree we do not delete internal nodes right we always delete leaf nodes now seven is what internal nodes so you are not going to delete this node you are going to replace it now you are going to replace it with its child because it is having only one child so here you put nine now here we have nine and nine two lines are there now recursively you are going to call the delete function on this child and now we are going to delete this child all right so after deletion this is the binary search tree internal nodes we are not going to delete only we will delete the leaf nodes internal nodes is going to be replaced with its children right with which shall Charlie you need to take care of that thing now third case was if suppose I want to delete suppose this ten now n is having two children now we are we will replace this ten with which children with nine or fifteen or with what this thing you need to take care now here two cases are there either you can replace it with its inorder predecessor or inorder successor two cases are there so these two approaches are there suppose I'm replacing the stand with its inorder predecessor predecessor means in order predecessor means the largest element from the left subtree of that node because i am i want to replace this 10 so find out the left subtree of this 10 and from that left subtree the largest element would be the inorder predecessor means here we have only one element that is nine so you can replace this with nine or if you follow this approach if you will follow this approach then you are going to replace this 10 with its inorder successor now how to find inorder successor the smallest element from the right subtree of that node right I want to replace this 10 or you can say I want to delete this so the right subtree of this 10 is this one now the smallest element from the right subtrees 2n so we are going to replace this 10 with this 12 see how to find this in order predecessor successor and how to replace that node this thing we have already discussed in detail when we were discussing the BST insertion and deletion so you can check out that video in the description box as well right now first step is in this in this deletion in red black trees would simply perform standard BST deletion right the same rules here we have discussed these rules would be followed after that you need to take care of that property that is that red black property of the string so now we will see all the cases one by one with the help of example and at last you will also discuss that we will take example of one red black tree and we will apply the deletion operation and we will discuss all the cases in one example right now first step is simply perform BST deletion so you should know how to perform BST deletion right suppose I am taking this as a red black tree now you can see this is a red black tree because this is a binary search tree first of all root is black know red red conflict is there and height you can say that from any node the path every path from the node to its descendent nil is having same number of black nodes right now here the case one is what if the node you want to believe is a red in that case just delete it this is the simplest case and deletion right so suppose here I want to delete 30 now first step is you need to search where is 30 means binary search you need to apply here compared with this root because I am having the address of the root node only right 30 is greater than 10 go to the right side that is greater than 20 go to the right side here we got 30 right and this node is ha this is what leaf node or here somewhere it is also written that because obviously we are we are having here null null here also null null and null or you can say nil and all the nil nodes are having color black right now if you want to delete this 30 and it is humming only nil children know not knowledge children is there so now and the red is the color is red so simply delete it right and if you delete it so here somewhere it is also written that when you delete it then simply replace it with this either of its nil children so here you can write nil and this is also in black in color so you can see it is still a red black tree right root is black in every path see here you can say here we have one in two black node 1 in 2 here also 1 & 2 & 1 & 2 somewhere they count that one two and three this nil also has a black node but here I'm not counting this thing or some somewhere it is counted that they don't count this root in the path because this is always black so they count this 1 1 & 2 1 & 2 1 & 2 & 1 & 2 it's up to you have you you are going to count but the logic would be correct right so now the node was red we simply deleted it no need to do anything now here I am writing simply like this I'm not writing the null nodes because these are null node so no need to write down those notes right now second case is now suppose here I want to delete 20 now search where is 20 greater than 10 so here I got 20 but 20 is what is having one child so it is internal node so you cannot delete this 20 internal we cannot delete internal nodes we can replace those nodes so now with which node you are going to replace this 20 because it is having only one child so just follow the rules of BST deletion we are going to replace this 20 where this 30 now Here I am writing 30 now 30 is read but here I am not recoloring it this is still black why so because here we are not going to believe this node and if you will not delete this node then this node still having its color black we are just replacing the value now rather than 20 here we have replaced to this 30 we are not deleting this node so that is why internal node will always preserve its color its retain its color if it is black it would be black if it is red internal node is red it would be red because the common sense is what if you don't delete any node then obviously the color of that node would be same now right so we are just replacing this we are putting this 30 here now we have 230 here now apply that delete function on its inorder successor or you can see on the children all right so now delete this one this is red so if the node to be deleted is red this is leaf node now so we can simply delete it right we can delete leaf node we cannot delete internal nodes so simply delete it I am NOT replacing this with rights nil children or you can do it something like this here nil nil nil and name so here what you can write if the node to be deleted it is rather than just deleted and if the node you want to believe is black with one child in color red then simply replace that node with its child right and delete that child because child is red so simply you can delete that and that node would be having its own color because we are not going to change this its color right now let us take few more example of this case so here in this example I want to delete suppose 30 now search where is 30 start from the root 30 is greater than 10 so to the right of this root now here I go to 30 but this is what internal node here you can see this is having left and right both the child so the case is what either you can select in order predecessor to replace this or inorder successor here i am following the approach where i am going to select inorder successor right now see this 30 is internal node so we cannot delete you can only replace it we will delete the DF node this point is very important you need to take care of this point so now that inorder successor would be what the smallest element from the right subtree of that node because I want to delete this 30 so the right subtree of this node is this one smallest element is 38 so we will replace this way this 38 means rather than 30 here you will write 38 but the color would be same see it is internal node you are not going to delete the node that is why the color would be as a tease if 30 it's not like that if 38 is black or it's red then you are going to take the color of 38 only know the internal node will having its own color so we are not going to change its color that would be red only now that on that inorder successor now you are going to call recursively that delete function here now can you delete this 38 yes obviously it is the leaf node and it is red so simply delete it you not no need to do anything so you can simply delete it right or you can say here we will replace the 30th with it's nil children so nearly black each node is humming male children right as you can see this is still a red black tree no red it conflicted is there in each path we are having same number of black nodes and do this black right let us take another example now let us take this example here also see this is a red black tree you can check out all the properties now here also I want to believe this 30 first of all search where is 30 it is greater than 10 so here I got 30 now it is having two children now I will replace it with its inorder successor you know the successor is what from the right subtree of this 30 find out the smallest element smallest element from this is what 35 right so now here you will write 35 35 right and it will it is black so it is going to contain its own color right because it is internal node we will not delete internal own now the problem is we have 235 now on that inorder successor called the delete function recursively not now you want to believe this one right but this is still having one child so we will not believe this we will replace this so here we will write 38 and it will contain its own color right it's not like that 38 is red so we are going to make it red no it is internal node will not delete this so it is having its own color now 38 38 now again recursively call or delete function on this 38 now it is red so simply deleted right so as you can see this is still a red black tree right so not the problem comes when you will delete a black node and that black node is having black children right so there for double black situation will arise and the main task here is what you need to convert that double black into single black and for that you need to have some cases so we'll discuss all the cases with the help of example now now suppose here I want to delete this 20 right first of all search where is 20 to the right of this 10 it is having two children so which with which children you are going to replace it with inorder successor from the right subtree find out the minimum element in the right subtree we have only 30 so we are going to replace it with 30 right and we are not deleting this one so we are just replacing it so it will contain its own color right we're not going to affect this color now again called lead function on its inorder successor now if you delete this 30 obviously this leaf node so you can delete it but here the situation is what it is black it is not red so it's not like that you simply delete it no why so they can see this is having nil nil all are having it's nil children and these nil are black so by default if this is red what we have done we simply replace it with its nail children but here this is black you want to delete this node this is black and you will replace it with it's nil children and the nil children is also black so now this is situation of double black so if you delete and you will replace it with its nil so it's own color was black and the children color is also black so it is now double black this is the case now what you can say it is now DB double black note you need to take care of this node now this is the main problem in deletion in red block right now you need to convert it into single block Y so see now check out in each path here we have two black node here also we have two black nodes but here we have only one black node because we obviously we are not going to count this nil node so you will not count this nel node so in this path from here to this nil node we have only one black node so the main property which is violated here is what because of the listeners of black node in this path we have one less black node so it has it has affected the black height no you need to take care of this thing now so here we have multiple cases right now see first case is simple if the root is double black so simply remove double black right suppose because of some situations you got double black at the root right this is root this is double black and here we have left subtree and here we are right subtree right no need to do anything simply remove this double black and make it single duck right this situation will discuss with the help of example this is the simplest case in this scenario right next situation is what now if the node is double black right so to resolve this conflict we will always check its sibling right see in case of insertion we have checked the uncle of that node right I guess you remember or you can say that parents sibling according to that we decided which rotation or which case we need to follow but here when we will check the sibling of that double black note and according to that we will decide which case you are going to apply right now first case in this key in this is what if the double black nodes sibling is black and both its children are also black so let us take that example so now let us take this example here in this example this is a red black tree and here I want to believe this from here I want to delete 15 right so search where is 15 to the right of the stain to the left of this 20 here we were 15 now see we cannot simply delete this 15 it is a leaf node and you cannot delete it like this because it is having color black if it is red then you can delete it it is having two nil children which are also black this is also having nil nil in the land name now if you will delete this one then you will replace this with its children one of its children that is nil and this is black and the children color is also black so this is now you can say double black DB right I'm not showing these Nell children so now in this path from here to here because obviously we are not going to count the snell while we are counting the black node in the path so it is having only one black node here we have one into here we have one and two so now we need to solve this problem now to solve this problem this double black node will always check its sibling sibling is 30 check the color of sibling it is black right and sibling children are two nil and nil and color of nil children is also black as we know right so now BB's sibling is black and both its children are black so this is the situation now now what does DB will do see here you can relate it with this example that red means if someone is angry then his face becomes you know red so 20 is angry if someone is cool then he is black right now this is double black means this is also a problem you cannot be so much cool or come sometimes you need to be angry sometimes you need to show your anger right so this is a problem double black says question is also not good so now it will see he will see its sibling it is black cool he is cool so this the sibling doesn't need any black color now because it is already in black its children is also black so now all the three are black so he cannot give its extra black to either of these three nodes neither to its sibling no to its children now what he will do he will ask to its parent right and obviously he will give its extra black or you can say that its problem to its parent right so now here first of all remove this BB so it is simply single black now and add black woods parent so now parent is red so parent becomes black right now what you will do when it's sibling come to know that he has given his problem to parent then what the sibling becomes angry right that why you are giving you why you are troubling our parent fine so now it will become red now the steps are what if this is a situation then what we have done simply remove this BB first of all and what we have done done add black to its parent and black boots this was double black node to its parent right now here also pool situations can be there if the parent is already black then it will become double black and if the parent is red then it will become single black here the parent was red so here also two situations are there if the other than parent I'm writing P P is red now next thing what we have done the sibling becomes now red so now next step is what make sibling red sibling means sibling of double black node because double black node is having problem number are discussing the cases on this double black so sibling means double black sibling becomes now red right now if still the problem of double black exists then we will apply some other cases right so now and what are these other cases that thing also we will discuss one by one right now here see there is no double black problem exist now right so now it is done so we can remove the snow this is also nil so you can remove it so now as you can see this is a red black tree rudest root is black in this path one and two blacks one in two blacks one in two here also one and two and one and two right now if the parent was red sorry the parent is black so it would become double black and here still the double double black situation is there so we will apply some other cases right that him also will discuss I hope you go to these points so now here let us discuss this case that parent is already black so it will become divided black see let us take this case this is a red black tree perfect by new trees there and all the nodes are black so this is a red black tree now delete here 15 see 15 is black so you cannot simply delete it because it is having two nil children those are black so we will replace this 15 with it's nil children so Nell is also black and this is already black so it will become double black so now here this is Nell and it will become now you can say double black so here the situation is there the problem is there because see in this path we have only one end to black notes and all the other parts are having three black notes right because this is nil we are not going to count it so now we need to take care of this thing so now apply the cases check out the double black sibling sibling is black the two children of sibling is also black so this is the case right now here what you will do simple first step is remove dB remove double black so it is now single black right and it is now give its black extra black to its parent right same you can discuss that see this is what black means cool red means angry so now this is what a double cool so that is also a problem he'll ask to its sibling but sibling is cool he doesn't know need any black node or you can say no more coolness he needs children is also black so they don't need any extra black so what it will do it will ask to it's obviously parent right because if children is in problem so he'll go to it he'll go to his parent right so now he'll go to his parent and give its extra black or give its problem to its parent so now parent becomes double black why so because parent is already black so it means it becomes double black and it becomes now single black now sibling becomes red sibling becomes angry why so because he'll say why you are giving your own problem to our parent why you are troubling your parent so now it becomes red sibling becomes angry makes sibling red now here still DB exists in this case right so you need to follow some other case now which case you need to apply here see this is the node which is having problem so he'll check its sibling sibling is black children both children are black so he they they don't need any extra black because they are already cool so now what he'll ask to its parents means he will give its problem to parent right so parent is already black so now you can say first of all remove this DB it has become now single black and parent becomes now double black because parent is already black now after doing this now sibling becomes angry why so because he'll say why you are giving your own problem to our parent right so now it will become red from black to red now the situation see now here still inner problem we have double black situation now which case is there identify the cases now see double black is what root root is double black this is root so simply remove double black no need to do anything so simply remove it and it will become single black right and that's it so you can see this is water red black tree you can count the black nodes 1 & 2 1 & 2 here also 1 & 2 and here also 1 & 2 because this is nil so we will simply delete it so here also 1 & 2 right now check out the next case so now let us take this case and here this is a red black tree and from here I want to believe this 15 right now such where is 15 here you got 15 but you cannot simply delete it because this is black so now after deleting this 15 it will become because obviously it is having Nell children we will replace this with this nil and it will become now double black because it is already black and its children is also black with which you are going to replace it so it will double black now now find out which case you need to apply to find out the cases simply check the sibling of double black right check the sibling of double black after that after that you will check the this children of the sibling right the children which is away from double black and after that you will check this children these cases also we will discuss now we have already discussed this case when sibling and its children were black now second case is now here the sibling of double black is ready so this case is their right here we have discussed two sub cases right now this is red now what you will do see it means the sibling of double black is angry so now he wants his sibling to come down right now he cannot directly go to his sibling mean generally suppose two brothers are there so if one is angry so second brother will go to his parent and ask his parent to for his brother come down right now he lasts to its parent and he will send his parent to his brother to come down his brother right or you can say is sibling now when the parent will go and tell him to come down then it will become black right but in that process the parent will become angry so parent will become red because generally it happens when you are angry and your parent comes to calm you down to pull you down then they will become angry and then after that you will be like silent so now we are going to swap the colors now the the sibling becomes red to black but parents become from black to red first step is this one right but still the problems is their BB problem is their double black problem is there now second step is what the parent will rotate in the double black node direction right second step is this one so now after rotation the parent will rotate towards this direction because this children of parent is having problem this child is having problem so parent will go will always rotate towards the the child who is having problem right so now this rotation you can say the left rotation or you can say in the direction of BB the parent will rotate now after rotation the tree would become after rotation 20 would be down third we'll go up 30 is black 30 is having right child does 40 and now 30 is up 20 is down so 20 is to the left of this one and here we have to the left of 20 we have null that is double black 20 is what red now where 25 will go 25 is to the left of 30 and to the right of 20 right this is black this is black and this is black and this would be same this side would be same right now still after rotation still we have double black problem so now you need to again check which case you need to apply right so now this case in this case steps would be what first of all what we have done we have swapped color of its sibling and parent right so now here you can write swap colors of parent or you can say double black parent of double black right and it's sibling properly you can write this thing so parent and it's sibling right after swapping the colors we have done rotations rotations in this direction in DB direction right see this case is having its mirror image if bb's in this direction in that case this will rotate in this direction that thing also we will discuss right that is why I am saying that rotate the parent towards bv direction see here parent parent off you can write down properly parent of double black node in double black node direction right I am writing it in short cut and again reapply cases right now this is the scenario here which case you need to apply check out still we have double black situation now check out the to find out which case we need to apply check out the sibling of double black sibling is black now check out the children children is also nil and male that is black and black so this case you need to apply now write what is this case simply remove DB here we have means one black oniy right and add black to its parent so he'll give its problem to its parent the parent is red so it becomes black right this is the case parent is red it becomes black and after that sibling makes sibling red so now sibling becomes angry that why you are giving your problem to our parent so sibling becomes angry now now if still DB exists but in this case there is no DB problem exists now this is the final tree after deleting this 15 and as you can say this is now a red black tree from here this is null so you can delete it now what can be the next case so now we'll discuss the case 5 let us take this example right this is a red black tree and from here I want to delete this one in one example I'm I want to discuss more than this one case two or three cases I'll discuss now see if you delete this one right first of all search where is one this is black so we will replace it with its null null node and it will become double black now right so here we have the problem now find out which case you need to apply to find out this thing just check the sibling of double black sibling is what black now children of the sibling say this is also black this is also black because these are new so now this case you will apply first of all right so now he'll give its problem to its parent so now remove this double black this would become single black now null and a parent is black already black so it would become now double black right now still problem of double black exists now reapply cases now find out which case you need to apply now this is the node which is having problem now check out the sibling of this node that is 30 which is black right now check out this node sorry this children of sibling see it is having two children which children is near to this double black node this one and which is are from this this one so first you will check sibling this is black now the child who is far from double black this situation siblings child who is far from double black this child is far from double black this is near so this is black right and the child which is near to double black is red and there but the near child of double black is red now this is the case now here what you need to do see here I'm not writing left child or right cell because all the case in this case or all the cases are having its mirror image right so if you write down the left and right child then that would create a problem in mirror image so that thing also I will discuss the mirror image of this thing fine now see the siblings child is red means he's angry right now this double black node will ask to its sibling to go to his child and cool him down right so now the parent will go to its children and cool him down but in this process the parent would become angry so you can say we will swap the color of sibling and its child so now this becomes black means cool down and this would become angry right this is the first step now rotation in this case also rotation would be required so now 30 becomes red right or you can say that he becomes angry and why he becomes angry because of because his sibling 30 sibling is 5 because his sibling ask him to go to his hot chill to his child and cool him down that is why he becomes angry so you can say he becomes angry with its sibling that is why 30 would rotate in opposite direction to its sibling right not in this direction opposite direction to its sibling now the tree would be something like this so now when you will rotate this 30 in this right direction and 30 would be downward and 25 would go up so 25 has here now having color black 30 is to the right of 25 if not as 30 is having color red here we have 40 and through the left of 25 we have 20 with color black and to the right of 25 they are 28 to the right of 25 and to that now to the left of 30 that is here we are 20 and that is an black color now still we have problem of double deluxe situation now again you need to find out which case you need to apply right and after case 5 definitely you need to apply case 6 that is for sure right here we have applied case 5 first of all we applied case 3 then we apply case 5 and now you need to apply case 6 now what is case 6 see first of all write down the steps of this case I'm writing the steps here because see this step is very simple and this is very simple because if node is deleted you want to read it as read simply delete it so I'm writing the steps of this case here first of all what we have done we simply swap color off see this one and this one right means color of DB's sibling when it's child who is near to dB now after swapping the colors what we have done we have rotate the sibling of this BB in opposite direction to D be not in the direction of DB so now and now still the double black problem exists and definitely you need to apply case 6 so here you can write down apply case 6 right now what is is 6 C so now I will discuss case 6 after applying case 5 this should become this thing I guess this would be red right because when you will this double black this node will give its extra black book parent then the sibling becomes angry or you can say it becomes red now this is nel so you can delete it so now this is the tree now here what is case six now we'll discuss see this is not having double black situation now check out the sibling of double black this is black now this is having two children so first of all you will check the child who is far from double black say this is far from double black this is near to double so now this far child is red now now Moe need to check this child right if you find this is red now you have to do something now you can say this siblings the for child or you can say this child is angry so now he'll not directly go to his sibling and ask to cool his children down if the this this was this case this was the case if this chil the near the near children was red then he will ask to its sibling to go to his child and cool him down right now this is the far child so he'll ask to its parent to go and calm down his children right now if the parent will go in that case we will swap the parent and siblings colors here both are having black and black so swapping does not affect anything now if situation is something like this if this is red and this is obviously black in that case this will become black this would become red but here this is not the case both are black so no swapping would be there right now again next step is what now he'll rotate towards DB direction because in this case 10 then is the one who went to cool him down right so this would rotate in this case 30 rotated why so because 30 went to cool his children down that is why he will rotate and he was sibling of double black that is why rotate in opposite direction right and it is parent of double black so parent always rotate towards the child which is having problem right so now this is having problem so he will rotate towards this direction right now after rotation the tree would become ten would rotate it towards this direction 25 would go upward 25 is black now here we have 30 40 28 20 is to the left of 25 but to the left of 25 when you will rotate this tree so now here we have 10 so now 20 would be to the right of 10 and 5 is still having the problem of double black and here we have 7 that is red and this is black this is black black 30 is red sorry this was black and this is black now next step is what this remove this double black why so because see this double black node can push his double black problem upwards not downwards now the problem was the fire child was red so he will give its extra black to 30 so the 30 would become now black and this would become single black and that's it now you can see this is a red black tree right after applying a 6 so now these are all the cases and these cases are having its mirror image also like this here the DB is in this direction but suppose DB is in this direction and this direction and we have sibling of this DB right so now the far child of DB would be this one and the near child will be this one right so you need to take care of this thing also but apply the same rules in mirror image also right so now we will take one example and we will discuss the deletion process in red black tree now let us take this example one by when we are going to delete these numbers so this is a red black tree as you can see now first of all delete 55 search where is 55 from the root 55 is greater than this one less than this one so here we go to 55 right you cannot directly delete it because this is black node right and children obviously nil and nil those are also black so if you will delete this thing so we will replace this with nail and black so that is why it will become double black because this was already black now the problem is there now you have to convert it into single black now apply find out which case you need to apply to find out this thing simply you need to do you need to check out the sibling of double black sibling is red it means this case for you need to apply it means sibling is angry right so now he can see he can give its extra black to its sibling but right now cannot give because these are at same level and it can push its problem to upwards only right not downwards and not at the same level right so now he'll ask to its parent to go and cool his brother or it's his sibling down right so now parent will go so that is why the parent now become red and now it becomes black because during this process parent become angry and that child who was angry becomes cool down now now parent is angry so now parent will rotate in which direction parent will always rotate in the direction the child in the direction of the child who is having problem and now this child is having problem right so parent will rotate in this direction so 65 would go downward 70 would go upward right so now that tree would be something like this so now this is the tree after applying case for still we have DB problem see we have done swapping of parent color of the parent and its sibling rotate parent in baby's direction now you have to reapply cases now again check which case you can apply so now in this case now DB is this one this node is having DB problem so first of all check the sibling sibling is black now check the the child who is far from this TV that is nil that is black and this is also nil that is black so now you will apply case 3 this is black this is black this is black right so now he cannot give its extra black to any of these so now what he'll push his problem upwards he'll push the extra black boots parent of this week right so now the parent is red see 65 is red so now this parent becomes black and this would become single black and this is null that is why you can delete it means we will not write this thing right we have solved the problem now one more step one more step is what now this children has given its problem to parent now after looking this one the sibling becomes angry he will say why you are giving your problem to our parent right so now this was black so it would become now red right so now this is the tree because here now we don't have any double black problem so after deleting this 55 this as the final red loctite so now next you delete 30 so suppose this is no 20 this is 30 so now we need to delete this one first of all find out where is 30 less than 50 so here we got 30 now 30 is having two children so we will replace it with inorder successor you know the successor is 35 because in the right subtree only one node is there that is 35 so we will replace this 30 with this 35 right and if you are going to replace it we are not going to believe the internal node that is why it will having its own color that is black only now 35 35 to 35 are there so now we recursively hold delete on this inorder successor right so we can not directly delete it because it is already black so now we will replace it with nil and it would become now double black right now the problem occurs now which case you need to apply see now check the siblings of double block now sibling of double black is this one so this is black it's first of all check the fire child this would be nil that is black near child this is also black now again you will apply here this one case 3 now in case 3 what does the situation see now this double black will push it's problem upward you can say to its parent because these are all black no red is there right sibling and it's children so now he'll give extra black to its parents so now it 35 could become double black right some I'm I'm updating here only now this is 35 so this would become double black because this was already black and one extra black he has given to its parent so it would become double black now it would become single black that as null so if it is null so you can no need to write down the nun now after seeing this the sibling of double black would become angry that why you are giving your problem to our parent so that is why it will become red right now still the problem occurs now double black problem is here now again check out which case we need to apply now check out the sibling of this one sibling is black right now check out the far child from this double black this is also black now check out the near child this is also black now again you will apply this case only right now it will give its extra black to its parent right now the parent would become double black now 50 would become double black and it will become single block that is 35 only after seeing this the sibling of double black was this one this would become angry so it would become black to red now the double black situation still exists but here the double black is the root is double black so in that case you will do what simply remove the padlock right so simply remove it double black and 50 is become single black now so now this is the tree after deleting 30 so this as you can see it's a red black tree now from here delete 90 where is 90 here we have 90 see now the node of you want to delete is a red so you can simply delete it no need to do anything right because this is red and if you will replace it with nil then that would be a single black only no double black situation is there no need to write down so you can directly delete this 90 right now next we want to delete 80 from here now you will see the mirror image of the case we have discussed earlier see if you want to believe but this is already black node so you cannot simply delete it right we will replace it with its nil and it would become now double black now here the problem exists now you need to convert it into single black right now check out the sibling of double black that is 65 is the sibling sibling is black in color right after that check out the child of the sibling which is far from double black so this child is far from double black and this is nil and this is black only nil is always black right now check out the child which is near to the double black this is red now now which case you need to apply see this one now these are the steps now what you will do see now he will ask to its sibling that go to your child and cool him down because he is angry right so now he'll go to a chilled to a child and cool him down that is why it become now black but now he become red right now he was the one who went to cooled his children to cool his child down that is why he will rotate now so now he will rotate because he was the one who went to cool him to cool his child down so that is why he will rotate now he will rotate in opposite direction to DB why so because he asked to go him to a child and pull him down that is why he becomes angry now he is angry with his sibling also so now he will rotate in opposite direction to this DB so now the child so now the tree would become now it will rotate in opposite direction who 68 would go upward and 65foot go downward now 65 is red and 68 is black and this is still a double black problem right and say these red now see applied k6 because once you apply case five definitely you will reach to a situation where you need to apply case six now k6 is what this is the problem node having problem DB problem so check out the sibling that is black now check out the child which is far from DB which is red for our child is red so that is why we breach to case six ultimately now applies case six now what you will do now see he lost to parent his parent to go and come his child down right now he will not directly ask to sibling to go to its children he lost to paint because this child is far from DB right now parent will go right so that is why we are going to swap the color of parent and its sibling so now see parent is red so it will become black and it is black so it will become red right after swapping colour of parent and sibling rotate now he was the one who went to calm his children down right so now that is why he will rotate now so now his parent of double black and parent will always rotate in the direction of DB right because this child is having problem so parent will need to rotate in the direction of the children which is having problem right so now after rotation three would be something like this 70 would go downward 68 would go upwards 68 is now red now after rotation remove DB so DB is this one so remove this thing this would become only null that is one black and change the color of red child see the red child was this one because because of the sixty five was red right so sixty five the fire child was red so it would become now black so 65 now becomes black see now it will push its problem upward right so 65 is one level up up from this so he can give one extra black to 65 now right so now only null so you can remove it no need to write it down so now this is the tree as you can see this is now a red black tree after deleting what 80 now we will delete 50 50 is having to child so we will replace it with its inorder successor you know the successor is what from the right subtree find out the smallest smallest is 65 so here you will write 65 you are not deleting this we are replacing the value only so it would become it would remain it would you know retain its color right that is black now 265 are there so we will call recursively the delete function on this inorder successor so we will delete this one but this is black so you cannot directly delete it so it would become now double black right so now which case you need to apply sibling check out the sibling which is black check out the fart child of sibling that is nel that is black left child that does Anil that is also black now which case you need to apply case 3 in this case he will push its problem or you can say it's extra black boots parent right now parent is red so it would become now black right and it would become single black now after seeing this one the sibling becomes angry or you can say becomes red that why you are giving your problem to a parent right so now this is null or single black so you can delete it no need to write down the null so now this is that we after deleting 50 now next I want to delete 35 see where is 35 less than 65 here we have 35 right 35 is having one child that is red child so simply first of all we will replace this 35 whether it's child that is 15 but the color would be saying that is black because we are not going to believe the node we are just replacing the value right now we need to delete this 15 right so now 15 is red so you can simply delete it no need to do anything so this is now a red black tree right now next digit 15 here we have 15 15 is black and it is having two nil child the are also black so you cannot directly delete it right so we will replace it with null and it would become not double black now check which case when you to apply double black sibling is black check out the fart child for child of double black is red now the situation is this one sorry situation is this one case six directly you need to apply case six now right now what you need to do so now he'll ask to its parent to go and ask you can say his sibling to pull his child down he will not directly ask to its sibling in this case if the cases for child is red if near child is red then he will directly ask to sibling to go and pull his child down right now if parent will go then parent and we will swap the color of parent and this sibling but both are black so no need to do any swapping right now after this after swapping this parent will rotate in which direction towards DB direction so now the situation would be sixty five would be rotated towards this 68 would go upward sixty it is black here we have 70 which is red 65 is black and here we have now double black right now now see this this child was red he was angry right the far child 70 so now the 70 is one level upwards to double black so now if he can give its extra black to this 70 spoon of 70 becomes black and it would become single black so you can remove it no need to write down this thing so this is the tree after deleting 15 so this is now you can see a red black tree so now suppose if you delete 65 I want to believe 65 see where is 65 here we have but this is black you cannot directly delete it right so after deleting this this would become would be replaced by a null so it would become now double bla now check out which case you need to apply check out the sibling which is black the first child is also black the near child is also black because both are not so which case we need to apply this thing now he will push its problem to its parent that is the extra black he will give to its parent now parent is already black so it would become double black right and now it would become single black right so that's this is null so no need to write down this thing now after seeing this situation that the sibling becomes red sibling becomes angry now still double black problem exists in our tree so now double black root is now double black so simply remove it no need to do anything simply remove double black now suppose if you delete 68 in that case what you will do 68 is having only one child so first of all you will replace this with its child that is 70 and we will simply replace it the change the color would be same internal node will be retain its own color right now we delete this one so this is red so you can simply delete it right so this is how we are going to perform delete operation in red black tree I hope I have discussed all the cases with the help of an example if you have any problem then you can write me down in the coming box right so now I will see in the next video till then bye bye take
