With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're going to be learning
00:02 - how to run code concurrently using the
00:04 - threading module now this has been a
00:06 - highly requested video for some time now
00:08 - so I'm glad that I finally am getting
00:10 - around to this now I'm also going to be
00:11 - doing a follow-up video showing how to
00:13 - run code in parallel using the multi
00:15 - processing module and we'll also look at
00:17 - when you would want to use one over the
00:19 - other now if you don't know the
00:21 - difference between threading and multi
00:22 - processing then you should have a grasp
00:24 - on the difference between those once
00:26 - we're finished up now I would like to
00:27 - mention that we do have a sponsor for
00:29 - this video and that is brilliant dot org
00:31 - so I really want to thank brilliant for
00:33 - sponsoring this video and it would be
00:34 - great if you all could check them out
00:36 - using the link in the description
00:37 - section below and support the sponsors
00:38 - and I'll talk more about their services
00:40 - in just a bit
00:41 - so with that said let's go ahead and get
00:43 - started ok so first why would we want to
00:45 - use threading so basically we want to
00:47 - use threading whenever it's going to
00:49 - significantly speed up our program now
00:51 - this speed-up comes from running
00:53 - different tasks concurrently and we'll
00:55 - talk more about concurrency and what
00:57 - that means in just a second now speed
01:00 - ups aren't really guaranteed so it
01:02 - really just depends on what you're doing
01:03 - so in this video we're gonna start off
01:05 - with a basic example where we learn how
01:08 - to run some simple sleep methods
01:10 - concurrently but then we'll finish up
01:12 - with a real-world example where we
01:13 - download some high resolution images
01:15 - from the internet now I want to show
01:17 - that real world example because you know
01:19 - personally when I watch tutorials that
01:21 - only show how it works with a basic
01:22 - example then I always feel like it
01:24 - doesn't really not that I don't walk
01:26 - away with any actual useful knowledge so
01:29 - we'll use the sleep method to get a good
01:30 - idea of how to use threading and then
01:32 - we'll be sure to go over the more
01:33 - complicated real world example of
01:35 - downloading images online so let's go
01:37 - ahead and get started so I have a
01:39 - starting script open up here and if
01:41 - you'd like to follow along then I'll be
01:42 - sure to have a link to this code in the
01:44 - description section below as well and
01:45 - like I said we'll start with a very
01:47 - simple example and see how this works
01:49 - and then build up to more realistic
01:51 - examples so for the script here I'm just
01:54 - importing the time method and then I am
01:56 - starting a counter this is just so we
01:58 - can measure how long this entire script
02:00 - takes so you really don't have to pay
02:02 - attention at least on these lines here
02:04 - but then we just have a simple function
02:06 - called do something and this is printing
02:08 - that we're going to sleep for one second
02:10 - then we actually sleep for a second and
02:11 - then I print that we are done
02:13 - and then we are running that function
02:15 - and then I am getting the finished time
02:18 - here and then I'm printing out that our
02:20 - script finished and I'm printing out the
02:22 - total number of seconds okay so if I run
02:24 - the code that we have right now we can
02:26 - see that it said that we're sleeping for
02:28 - one second that we're done sleeping and
02:29 - that we finished in one second and that
02:32 - sounds about right since we're running
02:33 - the do something function one time and
02:35 - that's sleeping for one second and if we
02:38 - were to run that function twice then our
02:41 - program will likely take two seconds so
02:43 - let's go ahead and see that so I'm just
02:45 - going to copy that and execute that
02:47 - function again and if I run this then we
02:50 - can see sleeping for a second sleeping
02:52 - for a second finished in a little over
02:54 - two seconds so we can see that each time
02:56 - we run the do something function it's
02:58 - adding about one second to our script
03:00 - but it's not really doing anything on
03:02 - the CPU in that function it's just
03:04 - sleeping so our script is just waiting
03:06 - around sleeping for a second and once
03:08 - that's done it moves on to run that next
03:11 - function and set around sits around
03:13 - waiting for another second sleeping and
03:14 - then at that point we're basically done
03:17 - and our script finishes now I created a
03:19 - quick graphic here to represent what
03:22 - this looks like so let me pull this open
03:24 - here in my browser so basically this is
03:26 - what our script looks like right now
03:27 - we're running a function here and then
03:30 - it is sleeping for one second but this
03:32 - is just us sitting around waiting and
03:34 - after that second we run another
03:36 - function here and then it comes up here
03:38 - and waits
03:38 - another second and then finally we are
03:40 - done and running everything in order
03:42 - like this is called running it
03:44 - synchronously and so anytime our program
03:47 - is running synchronously it actually
03:49 - isn't doing much on the CPU and it's
03:51 - just waiting around like this and that's
03:53 - usually a good sign of when we can get
03:55 - some benefits from using threading and
03:57 - concurrency
03:57 - now these are called CPU bound and i/o
04:00 - bound task now CPU bound tasks are
04:03 - things that are crunching a lot of
04:05 - numbers and using the CPU and the i/o
04:07 - bound tasks are things that are just
04:09 - waiting for input and output operations
04:11 - to be completed and not really using the
04:13 - CPU all that much so some other examples
04:15 - of i/o bound tasks include you know
04:18 - reading and writing from the file system
04:20 - and other file system operations network
04:23 - operations downloading stuff online and
04:25 - things like that
04:26 - when it comes to threading we're gonna
04:28 - see benefits when our tasks are IO bound
04:30 - which again means that we're doing a lot
04:32 - of waiting around for input and output
04:35 - operations like you know reading data
04:37 - from disk or network operations now if
04:40 - our tasks are doing a lot of data
04:41 - crunching and our CPU bound then we're
04:44 - not going to get that much of a benefit
04:45 - from using threading as a matter of fact
04:47 - so some programs actually run slower
04:50 - using threads because of the added
04:52 - overhead cost when they're creating and
04:55 - destroying different threads now if a
04:56 - task is CPU bound then we'll likely want
04:59 - to use multi processing and run it in
05:01 - parallel instead and again we're gonna
05:03 - take a look at that in the next video so
05:05 - when we run something concurrently using
05:07 - threads it's not actually going to run
05:09 - the code at the same time it just gives
05:11 - the illusion of running code at the same
05:13 - time because when it comes to a point
05:15 - where it's just waiting around it's just
05:17 - going to go ahead and move forward with
05:19 - the script and run other code while the
05:21 - i/o operations finish and I've got
05:23 - another graphic put together of what
05:25 - this looks like so here's an example of
05:27 - what our code would look like when we
05:29 - use threading so we're gonna run this
05:31 - function and we can see that it comes up
05:33 - here and waits a second but as soon as
05:35 - that starts waiting our code is just
05:37 - gonna move on and go ahead and run
05:39 - another function while we're waiting for
05:41 - this one second to be done sleeping and
05:43 - then we kick off this other second so
05:45 - these are actually overlapped here but
05:48 - we never actually ran any of this code
05:50 - at the same time it's just going to give
05:52 - the illusion of running the code at the
05:53 - same time and then finally we can see
05:55 - that we are done a little bit sooner now
05:58 - this graph isn't a scale you know these
06:00 - weights here would actually be much
06:02 - shorter okay so now that we've actually
06:04 - talked about concurrency and when to use
06:06 - threads now let's see how to actually do
06:08 - this with our current script
06:10 - so first let's import the threading
06:12 - module now this is in the standard
06:14 - library so we don't need to install
06:16 - anything so I'm going to come up here to
06:18 - the top and I'm just going to import
06:21 - threading now I'm going to show an older
06:24 - way of how to do threading first so that
06:26 - we can get a good idea of what's going
06:27 - on but if it seems confusing at first
06:29 - then definitely stick around because I'm
06:31 - also going to show some newer ways of
06:33 - doing threading using pools that allow
06:36 - us to add threading to our programs with
06:38 - a lot fewer lines
06:39 - of code okay so first instead of running
06:42 - the do something function twice in a row
06:44 - like this let's instead turn both of
06:46 - these into threads so to do this I'm
06:49 - going to create two threads for both of
06:51 - these so to do this I'm just going to
06:53 - overwrite where we are setting these
06:54 - functions here and I'm gonna create one
06:56 - thread called t1 and this is going to be
06:59 - threading dot thread and now we want to
07:02 - set a target and our target is the
07:05 - function that we want to run and that is
07:07 - the do something function now we
07:08 - actually want to pass in the function
07:10 - here we don't want to execute the
07:12 - function so don't put on parentheses
07:14 - like this we just want to pass in the
07:16 - function by itself uh neck's acute 'add
07:18 - okay so now let me copy this line and
07:20 - let's create another thread so I will
07:22 - call this t2 and we will keep everything
07:26 - else the same we're just creating a
07:28 - thread with that target of do something
07:30 - okay so at this point we've created two
07:33 - thread objects but we're not actually
07:35 - running that code so if I run this then
07:38 - we can see that it finished immediately
07:39 - but nothing from our function got
07:41 - printed out so our function actually
07:43 - didn't run so in order to get our
07:45 - threads to run we need to use the start
07:47 - method on each thread so here below T -
07:51 - I'm just gonna say t1 dot start and t2
07:55 - dot start and that will actually run our
07:59 - thread but it not might not actually do
08:02 - exactly what we think it'll do so if we
08:04 - run this right now then we can see that
08:07 - it now runs the functions and we can see
08:09 - that it printed out the first lines from
08:12 - both of those functions here let me make
08:13 - this a little larger so it printed out
08:15 - that both of our threads were going to
08:17 - sleep for a second and then it said that
08:19 - our script was finished in zero seconds
08:21 - and then it printed out that it's done
08:23 - sleeping now our script actually took
08:25 - around one second to complete but the
08:27 - reason that it says that it completed in
08:29 - zero seconds is because it started both
08:31 - of those threads and while the threads
08:33 - were sleeping our script ran
08:35 - concurrently and continued on with the
08:37 - rest of the script so it immediately
08:39 - came down and calculated our finish time
08:42 - here and printed out our last print
08:44 - statement as our threads were still
08:45 - sleeping and then once that one second
08:48 - was up our threads continued on and both
08:50 - printed that they were done sleeping now
08:52 - what if we
08:53 - our threads to finish before we
08:54 - calculated the finish time and before we
08:57 - printed out that our script was finished
08:58 - so in order to do this we can use the
09:01 - join method so to do this just below our
09:03 - starts I'm also going to run the join
09:06 - method on both of these and that will
09:08 - make sure that they complete before
09:10 - moving on to calculate the finish time
09:12 - and to print out this statement here
09:15 - so if I save this and run it then we can
09:18 - see that both of our threads started at
09:20 - almost the exact same time and then they
09:22 - both printed out that they were done
09:24 - sleeping after a second and then our
09:26 - script continued on to print that our
09:28 - script finished after one second now if
09:31 - using threads seems a bit complicated
09:32 - right now
09:33 - then definitely stick around until the
09:35 - end of the video because we're gonna see
09:36 - an easier way of how to do what we're
09:38 - doing here but I think it's important to
09:40 - understand what this is doing so far
09:42 - even if we use other methods where we
09:44 - don't manually call these start and join
09:46 - methods okay so right now we're not
09:48 - really getting that big of a speed-up
09:50 - here so our code ran in two seconds
09:52 - before and now it's running in one
09:55 - second but that's because our function
09:57 - doesn't take too long and we're only
09:58 - running it twice but what if we wanted
10:01 - to run our function ten times well if we
10:03 - were to run our code synchronously where
10:05 - it runs one after the other then we can
10:08 - take a guess that it would take about
10:09 - ten seconds since one would have to
10:11 - finish before another started but if we
10:13 - ran this with threads then it should
10:16 - still be around one second to complete
10:18 - so let's go ahead and see an example
10:20 - with this now instead of manually
10:21 - creating ten different threads let's
10:23 - instead create and start these threads
10:25 - and a loop so to do this I'm going to
10:28 - come up here and copy this threading
10:31 - part here and now I'm just going to
10:34 - remove everything that we had here
10:35 - before and now I'm just going to create
10:38 - a loop so I'll say for underscore in
10:40 - range of ten and then I'm gonna say T
10:45 - for our thread is equal to threading dot
10:48 - thread with a target of do something and
10:51 - now let's also start that thread within
10:53 - our loop now if none of you have ever
10:55 - seen an underscore in Python here
10:58 - basically this just means it's a
10:59 - throwaway variable because all we want
11:01 - to do is a loop over these ten numbers
11:04 - here but we're not actually doing
11:05 - anything with it
11:06 - I just have an underscore variable so
11:09 - that just to say that we're not using
11:11 - anything within the loop okay so now we
11:13 - have our loop here and our threads are
11:14 - starting but we can't actually do a tea
11:17 - or a thread dot join within the loop
11:20 - because it would join on the thread
11:22 - before looping through and creating and
11:24 - starting the next thread so it would
11:26 - basically be the same as running the
11:28 - code synchronously so we need a way that
11:30 - we can start all of these threads in one
11:32 - loop and then loop through the threads
11:34 - again and run the join method on them so
11:37 - that they all finish before the end of
11:38 - our script so to do this we can append
11:41 - each thread that we create to a list of
11:43 - threads so above the for loop here I'm
11:46 - going to create a list of threads and
11:49 - this is just going to be empty for now
11:51 - and now below T dot start I'm going to
11:54 - say threads dot append and we will
11:58 - append each thread that we started so
12:01 - now once we go through this loop we
12:03 - should have a list of all these threads
12:05 - that we started so now let's run join on
12:07 - all of those so I'll say for thread in
12:11 - threads and then we will do a thread dot
12:17 - join ok so now we're actually running
12:20 - this do something function ten times and
12:22 - it sleeps for one second every time but
12:25 - since we're using threads it's just
12:27 - going to keep moving forward each time
12:29 - we sleep so instead of taking ten
12:31 - seconds let's run this and see how long
12:33 - it takes so we can see all those got
12:35 - kicked off and our scripts still
12:37 - finished in just one second okay so
12:40 - that's pretty good so we've already
12:41 - taken a script that normally would take
12:43 - ten seconds and we've instead finished
12:45 - it in one second okay so now let's look
12:48 - at how we can pass in arguments into our
12:50 - function so right now we're running a
12:52 - function that doesn't accept any
12:54 - arguments but let's add a couple real
12:56 - quick so we can see what this looks like
12:57 - so right now we're just sleeping for one
12:59 - second but let's add an argument that
13:02 - specifies how long we actually want to
13:04 - sleep so up here and our dosomething
13:07 - function I'm going to pass in an
13:08 - argument and I'll just call this seconds
13:11 - and now I will say that we are sleeping
13:14 - for however many seconds and this needs
13:18 - to now be
13:20 - and F string so that we can pass in the
13:22 - variable like that and now instead of
13:25 - sleeping for one second we'll sleep for
13:27 - the number of seconds that we passed in
13:30 - as a variable here and just so this
13:32 - doesn't say sleeping for 10 second or
13:35 - something like that let's also say that
13:37 - this could be seconds as well okay okay
13:39 - so now our function is expecting an
13:41 - argument for the number of seconds to
13:43 - sleep so let's pass in seconds as an
13:46 - argument and we need to pass that in as
13:48 - a list of arguments so down here where
13:51 - we create our thread this is where we're
13:53 - going to pass in our arguments so this
13:55 - is just an args argument and we will
13:58 - pass this in as a list now we only have
14:00 - one argument so this is just going to be
14:02 - a list of one value so let's sleep for
14:05 - 1.5 seconds and stell and instead so now
14:08 - we should expect our function to take
14:10 - about 1.5 seconds every time so if I
14:13 - save this and run it then we can see
14:15 - that now we are finished with our entire
14:19 - script in 1.5 seconds and this still ran
14:22 - at this function ten times so normally
14:24 - this would take 15 seconds if we were
14:26 - growing this synchronously but now we're
14:28 - finishing it in 1.5 seconds okay so I
14:31 - said before that I was going to show you
14:32 - the older way of doing threads and then
14:35 - I'd also show you what I believe is a
14:37 - faster and easier way of doing this now
14:39 - I still wanted to show you the manual
14:41 - way of creating these threads because I
14:43 - think this can still be useful depending
14:45 - on what you're doing but I also think
14:47 - it's better to learn this manual way
14:49 - first to understand a little bit better
14:51 - of what's going on in the background but
14:54 - in Python 3.2 they added something
14:56 - called a thread pool executor and in a
14:59 - lot of cases this is going to be an
15:00 - easier and more efficient way to run
15:02 - these threads and it also allows us to
15:04 - easily switch over to using multiple
15:07 - processes instead of threads as well
15:09 - depending on the problem that we're
15:11 - trying to solve so let's replace what we
15:14 - currently have and instead use this
15:16 - thread pool executors now this is
15:18 - actually not in the threading module
15:20 - it's in the concurrent futures module so
15:23 - at the top instead of using importing
15:26 - the threading module I'm going to import
15:29 - and I don't think I even need threading
15:31 - anymore so I'm just going to import
15:33 - current dot futures and when we use this
15:37 - thread pool executors it's usually best
15:39 - to use this with a context manager so
15:42 - above our threads list here I'm just
15:44 - going to do the same thing that we
15:45 - already have
15:46 - using the concurrent futures module
15:49 - instead so to do this I'm just gonna say
15:51 - with and let me go ahead and exit out so
15:54 - we can see a little bit more of the
15:55 - screen here so I'm gonna say with
15:57 - concurrent dot futures dot and this is
16:01 - thread pull whoops let me spell that
16:04 - correctly thread pull executors and we
16:09 - will say as executor there and now with
16:14 - our executors there are a couple of
16:16 - different methods that we can use so if
16:18 - we want to execute the function once at
16:20 - a time then we can use the submit method
16:23 - so the submit method schedules a
16:25 - function to be executed and returns a
16:27 - future object so let's add this in and
16:30 - I'll explain this a little bit more so
16:32 - I'll say F 1 is equal to executors dot
16:36 - submit and we will now pass in the
16:40 - function and the arguments so I'm gonna
16:43 - say do something is the function that we
16:45 - want to run and we'll just pass in an
16:48 - argument of one for one second so again
16:51 - the submit method schedules a function
16:53 - to be executed and returns a future
16:55 - object now a future object basically
16:58 - encapsulate s' the execution of our
17:00 - function and allows us to check in on it
17:03 - after it's been scheduled so we can
17:05 - check that it's running or if it's done
17:07 - and also check the result so if we grab
17:10 - the result then it'll give us the return
17:12 - value of the function now right now
17:14 - we're just printing out values and not
17:16 - returning anything but let me add a
17:18 - return value so that we can grab that so
17:21 - instead of printing out that we are done
17:23 - sleeping here instead let me return that
17:26 - string of done sleeping and okay let me
17:30 - take out these parentheses here okay so
17:33 - now we are returning that string instead
17:35 - of printing it out so if we still want
17:38 - to print that then we need to print the
17:40 - return value of that function so let's
17:42 - grab that by using the result method so
17:45 - here within
17:46 - the context manager I'm just going to
17:49 - say print and we will print f1 dot
17:52 - result now if we run the result method
17:55 - here then it will actually wait around
17:57 - until the function completes
17:59 - okay so let's comment out what we had
18:01 - before
18:02 - so all of this code here is how we did
18:04 - threads previously and now let's run
18:08 - this code with our new thread pool
18:11 - executors here okay so we can see that
18:13 - that works and that's a lot less code
18:15 - than we had down here that's commented
18:17 - out and if we wanted to run this
18:19 - multiple times then we could run submit
18:22 - multiple times as well so above our f1
18:27 - result let me create another future
18:31 - object here so this will be F two we'll
18:35 - just keep everything else the same and
18:36 - now let's also print out the f2 result
18:41 - so if I save that and run it then we can
18:45 - see both of those got kicked off at the
18:46 - same time and that we finished our
18:48 - script in one second and if we wanted to
18:50 - run this ten times like we did before
18:52 - then we likely wouldn't want to run
18:54 - submit ten two different times so we
18:56 - could use a loop like we did before so
18:59 - instead of running one at a time I'm
19:01 - instead going to use a loop and we could
19:04 - use a regular loop like we did before
19:05 - but I'll go ahead and use a list
19:08 - comprehension to create these instead so
19:10 - we could say let me just copy this
19:14 - entire submit line here and instead I'm
19:18 - going to say results is equal to and now
19:22 - let's create a list comprehension so I'm
19:25 - going to say that we want to run
19:26 - executors dot submit with our do
19:29 - something function and an argument of
19:31 - one second four and then just an
19:34 - underscore for two as a throwaway
19:36 - variable in range of ten now if you've
19:40 - never used a list comprehensions before
19:41 - then I do have a separate video on that
19:44 - if you'd like to see exactly how this
19:46 - works but again if you're not familiar
19:47 - with list comprehensions then you can
19:50 - use a regular for loop like we did down
19:52 - here at the bottom okay so now we've
19:54 - created a list comprehension that's
19:56 - running our submit function ten
19:57 - different times with an argument of one
19:59 - sec
20:00 - now in order to get these results we can
20:02 - actually use another function from the
20:04 - concurrent futures module called as
20:06 - completed now this will give us an
20:08 - iterator that we can loop over that will
20:11 - yield the results of our threads as they
20:13 - are completed so I think this is a
20:15 - really useful method so to use this we
20:18 - can just say I'm going to get rid of our
20:21 - lines here and I'm just going to say for
20:23 - F in concurrent dot futures and then dot
20:29 - as underscore completed and we want to
20:32 - pass in our results list here to our as
20:36 - completed method and within this list we
20:39 - can just say print F dot result so if we
20:44 - run this then we can see that it still R
20:47 - in it ran that ten times and if we
20:50 - scroll down to the bottom here then we
20:51 - can see that it still ran this in one
20:53 - second now to prove that these are
20:55 - actually coming in as they're completed
20:57 - let me actually pass in a different
20:59 - range of seconds for our threads to
21:01 - sleep and those should print out in the
21:03 - order that they complete so I'll create
21:05 - a list of seconds to sleep here so above
21:09 - our results I'm just going to create
21:11 - another list and I will call this sex is
21:15 - equal to and I'll do five four three two
21:18 - and one
21:19 - and now instead of use passing in one
21:23 - here I'm instead going to pass in a
21:25 - second for a second in our list of
21:31 - seconds and I'm also going to print out
21:34 - the seconds in the return statement as
21:35 - well that way we can see which ones are
21:38 - finishing and in what order so I'm going
21:40 - to make this an F string as well and
21:42 - just here at the end I will just print
21:45 - out the seconds argument that we are
21:47 - passing in so again what our list
21:50 - comprehension here is doing is we are
21:53 - submitting this do something second with
21:55 - this argument of SEC and we are doing
21:58 - that for each value of seconds in this
22:00 - seconds list so this should get
22:02 - submitted five times with a 5 4 3 2 and
22:05 - a 1 so if I save this and run it then we
22:09 - can see that it says sleeping 5 seconds
22:12 - 4 3 but then
22:13 - the order that he's finished was that it
22:15 - was done sleeping for one second first
22:17 - then two then three them for them five
22:19 - and our total script took five seconds
22:22 - to complete now we actually started the
22:24 - five-second thread first but since we
22:26 - use that as completed method it printed
22:29 - out our results in the order that they
22:31 - completed okay so with the submit method
22:33 - its submitting each function once at a
22:36 - time now in order to run submit on an
22:38 - entire list then we need to do a loop or
22:41 - a comprehension like we did here but if
22:43 - you're familiar with the built-in map
22:45 - method in Python then there's actually
22:47 - something similar that we can do with
22:49 - threads where we can use a map method to
22:52 - run our function over a list of values
22:54 - now if you're familiar with that
22:55 - built-in Python map method then this is
22:58 - actually very similar except it uses
23:00 - threads instead so it runs the function
23:03 - with every item of the interval that we
23:06 - pass in so let's say that I want to map
23:09 - our function to our list of seconds so
23:11 - to do this we could say here let me let
23:16 - me just overwrite all of this that we
23:17 - have now and instead I will use a map
23:20 - method and say results is equal to
23:23 - executors dot map and we want to map the
23:27 - do something function and we want to
23:30 - pass in our iterator of seconds here so
23:34 - again what map is going to do is it is
23:36 - going to run the do something function
23:38 - with every value in this list of seconds
23:41 - here now when we use the submit method
23:44 - it returned a future object and when we
23:47 - use map it instead returns the results
23:50 - now it's going to still run those
23:52 - threads concurrently but instead of
23:54 - running the results as they completed
23:56 - like we saw before map is going to
23:59 - return the results and the order that
24:01 - they were started so to loop over these
24:03 - results we can just say for result in
24:08 - results and then let's just print out
24:11 - that result so if I run this then we can
24:15 - see that it started off all of our
24:17 - sleeps but nothing has returned yet and
24:20 - then it returned the done sleeping for
24:23 - five seconds four three two one
24:26 - so we can see that all of
24:27 - threads kicked off at pretty much the
24:28 - same time but then it looked like they
24:31 - completed all at the same time as well
24:33 - now they didn't actually all complete at
24:36 - the same time but when you loop over
24:38 - your results using map like we did here
24:40 - then it returns the results and the
24:42 - order that they were started so since we
24:44 - slept for five seconds first then we
24:47 - waited for that one to finish before
24:49 - printing out the other results but it
24:52 - still didn't slow us down at all we can
24:54 - see that our entire script still took
24:56 - about five seconds in total to finish
24:58 - now another thing to point out here is
25:00 - that if our function raises an exception
25:02 - then it won't actually raise the
25:04 - exception while running the thread the
25:07 - exception will be raised when its value
25:09 - is retrieved from this results iterator
25:11 - so if you need to handle exceptions then
25:14 - you can do that within the iterator if
25:16 - you'd like now if you'd like to learn
25:18 - more about handling exceptions then I do
25:20 - have a more in-depth video if you'd like
25:22 - to learn more about that and I'll be
25:24 - sure to leave a link to that video in
25:25 - the description section below for anyone
25:28 - who is interested now even if we don't
25:30 - grab all of our results within the
25:32 - context manager here it's still going to
25:34 - automatically join all of those and let
25:37 - them finish after the context manager
25:39 - ends so if we comment out where we're
25:42 - printing the results and I run this then
25:46 - we can see that it still waits until
25:48 - these are done until it gets down to the
25:51 - end of our script so it didn't do like
25:52 - it did before when we didn't have joins
25:54 - and say that we finished in zero seconds
25:56 - even though it actually wasn't finished
25:58 - yet so it's still waited for the threads
26:00 - in that thread pool to complete before
26:02 - printing out that our script was done
26:04 - okay so now that we've looked at a basic
26:07 - example using sleep now let's take a
26:09 - look at a more real-world example of
26:11 - where threading would be useful so I've
26:13 - got another script open here where I'm
26:15 - not using threading at the moment so let
26:18 - me pull this up and let's take a look at
26:20 - what this is doing and again I'm gonna
26:22 - have a link to this code in the
26:23 - description section below for anyone who
26:25 - wants to follow along so this is a
26:27 - script that goes out and downloads some
26:29 - high resolution photos from unsplash now
26:32 - if you don't know what unsplash is it's
26:34 - a website that has some really nice free
26:36 - photos available for anyone to use so
26:39 - let me go over this script and
26:41 - show how someone might do this normally
26:44 - so normally you might have a bunch of
26:46 - image URLs here that you want to
26:48 - download and now let's say we actually
26:50 - want to download those so somebody might
26:52 - say okay so for each image URL and our
26:55 - image URLs let's use the request library
26:58 - to go out and get that content and now
27:01 - I'm just doing some string parsing here
27:03 - to parse out the image name which would
27:05 - just be this section right here so I'm
27:07 - grabbing the image name and then putting
27:09 - a dot jpg on to the end of that and now
27:11 - I'm opening a file here in byte mode and
27:14 - then I am writing those image bytes that
27:17 - we downloaded from the internet onto our
27:19 - file system and then we're just printing
27:21 - out here that our image was downloaded
27:23 - okay so this script should go all
27:25 - through all of these image URLs and
27:27 - download all of these images into my
27:30 - current directory so if I run this right
27:33 - now then let's see how long this takes
27:35 - now we can see that these are
27:37 - downloading and I do have this pulled up
27:39 - here in my file system as well so we can
27:42 - see that it is going out and downloading
27:44 - these but it's downloading them one at a
27:46 - time so there should be 15 total here so
27:50 - once this is finished
27:51 - then we can get an idea of how long this
27:53 - took and it should be done any second
27:56 - now okay so we can see that this
27:59 - finished in 23 seconds to download those
28:02 - 15 high-resolution photos online now
28:06 - when we're downloading a lot of things
28:07 - online this is actually a great
28:09 - candidate to use threading because this
28:11 - is one of those IO bound operations that
28:13 - is actually spending a lot of time just
28:16 - waiting around it's not it's going out
28:18 - and waiting for a response from the site
28:20 - and it's not moving on to the next URL
28:23 - until that gets an entire response back
28:26 - so if we use threads that then it can
28:28 - actually go ahead and move on to the
28:31 - next URL while that's waiting around for
28:33 - a response and we can make other
28:35 - requests at the same time okay so now
28:37 - let's see how we can change this code
28:39 - that someone might normally write and
28:41 - instead change this to where it's using
28:44 - threads instead and see if we can speed
28:46 - this up so first let's think about what
28:48 - we're doing here
28:49 - so we're looping over our list of image
28:52 - URLs and then using the request
28:55 - library to download those one at a time
28:57 - so if we remember from our previous
28:59 - example this would be a pretty good
29:01 - candidate for the threading pull map for
29:05 - the threading pull map method where we
29:07 - can pass in a function and a list and
29:10 - have that function run with every value
29:13 - in that list
29:14 - and if that doesn't make sense right now
29:15 - then well it should make more sense once
29:18 - we actually change this code here but
29:20 - first we're gonna have to actually
29:22 - create a function that will download the
29:25 - data from a single URL so to do that we
29:28 - can just say I'm just going to change
29:30 - this for loop here and I'm gonna turn
29:32 - this into a function so I'm gonna say
29:34 - download underscore image and we want to
29:38 - pass in an argument of the image URL and
29:42 - everything within this function can just
29:44 - stay the same because we were looping
29:45 - over that before and now we just turn
29:49 - that into a function where we are just
29:51 - downloading one image URL at a time so
29:53 - it's basically the same thing as our for
29:55 - loop for now ok so now that we have a
29:57 - function that downloads one image at a
29:59 - time now we can create a thread pool and
30:02 - map our list of URLs using that function
30:05 - that we just created
30:06 - so first let's import the concurrent
30:09 - futures module so that we can use that
30:10 - so here at the top I'm going to actually
30:14 - let me put this below time here I will
30:16 - import concurrent dot futures and now
30:21 - down here below our function let's
30:25 - create a thread pool executor so just
30:28 - like before that was concurrent dot
30:31 - futures and we're using this within a
30:33 - context manager we want this to be a
30:35 - thread pool executors make sure I spell
30:39 - that correctly and we will say as
30:43 - executor therefore our context manager
30:46 - okay so now if we use that map method so
30:50 - I'm going to say executors dot map and
30:52 - we want to run this function and let's
30:58 - pass in our list of image URLs and again
31:03 - just to go over this one more time the
31:06 - map method here what it
31:08 - do is it will run this download image
31:10 - function with each value in this image
31:13 - URLs list but since we're using a thread
31:16 - pool executors it's going to actually
31:18 - down those download those with a
31:20 - different thread for each one so just
31:23 - with those small changes this will
31:25 - actually use threads and make those
31:27 - requests asynchronously instead of
31:29 - synchronously like we saw before so now
31:32 - if I run this code to download all these
31:36 - images again then we can see that these
31:38 - are coming in a lot faster because it's
31:40 - using threads instead of doing this
31:42 - synchronously so now we can see that it
31:44 - finished in five seconds instead and if
31:47 - you remember before we ran that it was
31:48 - taking 23 seconds so that's a pretty
31:51 - significant speed-up and this would be
31:53 - even more significant if we were doing
31:55 - even more requests so the speed ups can
31:58 - be you know pretty drastic depending on
32:00 - what we're actually doing now what would
32:03 - be an example of something that wouldn't
32:05 - be i/o bound well if something is doing
32:07 - a lot of computation then threads
32:10 - actually wouldn't be ideal for that type
32:12 - of task so if we are processing the
32:14 - photos and resizing them and things like
32:17 - that instead of just downloading them
32:18 - from line then the threads wouldn't
32:21 - actually speed that up all that much so
32:24 - that would actually be an example of
32:25 - something that is CPU bound and not IO
32:27 - bound and like I said before in those
32:30 - kinds of scenarios threads can actually
32:32 - slow down our script instead because the
32:35 - threads have some overhead when being
32:36 - created and destroyed so it really
32:39 - depends on what you're doing and what
32:40 - are to decide if the right choice to
32:43 - speed up your program is threading or
32:45 - multi-processing
32:46 - so when you're doing something that
32:47 - requires a lot of processing then we can
32:50 - use multi processing instead of
32:52 - threading so with that said in the next
32:54 - video let's go ahead and process these
32:57 - photos that we just downloaded and do
32:59 - some image manipulation to them and then
33:01 - we can take a look at the multi
33:03 - processing module to see how we can
33:05 - speed up that task as well that way we
33:08 - can see the difference between threading
33:10 - and multi processing and when you might
33:12 - want to use one over the other now
33:14 - before we finish up here I'd like to
33:16 - mention the sponsor of this video and
33:17 - that is brilliant org so we've been
33:20 - talking a lot about thread
33:22 - and multiprocessing and these topics are
33:24 - especially useful in the field of data
33:26 - science and data science is a field that
33:29 - is growing at a very rapid pace if you'd
33:32 - like to learn more about programming and
33:33 - data science then I would definitely
33:35 - recommend checking out brilliant org so
33:37 - brilliant is a problem-solving website
33:39 - that helps you understand underlying
33:41 - concepts by actively working through
33:43 - guided lessons and they've recently
33:45 - added some brand-new interactive content
33:48 - that makes solving puzzles and
33:50 - challenges even more fun and hands-on
33:52 - and if you'd like to learn more about
33:53 - data science and programming with Python
33:55 - then I would recommend checking out
33:57 - their new probability course that covers
33:59 - everything from the basics to real-world
34:01 - applications and also fun things like
34:04 - casino games they even use Python in
34:06 - their statistics courses and will quiz
34:08 - you on how to correctly analyze the data
34:11 - within the language so they're guided
34:13 - lessons will challenge you but you also
34:14 - have the ability to get hints or even
34:16 - solutions if you need them it's really
34:18 - tailored towards understanding the
34:20 - material they even have a coding barment
34:22 - built into their website so that you can
34:24 - run code directly in the browser and
34:26 - that is a great complement to watching
34:28 - my tutorials because you can apply what
34:30 - you've learned in their active
34:31 - problem-solving environment and that
34:33 - helps to solidify that knowledge so to
34:35 - support my channel and learn more about
34:37 - brilliant you can go to brilliant org
34:39 - forge / CMS to sign up for free and also
34:43 - the first 200 people that go to that
34:45 - link will get 20% off the annual premium
34:48 - subscription and you can find that link
34:49 - in the description section below and
34:51 - again that is brilliant dot org forge /
34:54 - CMS okay so I think that is going to do
34:57 - it for this video I hope you feel like
34:59 - you've got a good idea of how to use the
35:00 - threading module and how we can use this
35:02 - to speed up our scripts now there are
35:04 - some more advanced topics that we could
35:06 - cover in the future with threads such as
35:08 - thread local data race conditions locks
35:11 - and things like that but we'll save that
35:13 - for a future video if anyone is
35:14 - interested and like I said in the next
35:17 - video we'll see how to use the multi
35:18 - processing module to do the same thing
35:20 - that we did in this video but instead
35:23 - the task will be image processing
35:25 - instead of downloading images but if
35:28 - anyone has any questions about what we
35:29 - covered in this video then feel free to
35:31 - ask in the comment section below and
35:32 - I'll do my best to answer those and if
35:34 - you enjoy these tutorials and would like
35:35 - to spore
35:36 - them then there are several ways you can
35:37 - do that the easiest ways to simply like
35:39 - the video and give it a thumbs up and
35:40 - also it's a huge help to share these
35:42 - videos with anyone who you think would
35:43 - find them useful and if you have the
35:44 - means you can contribute to patreon and
35:46 - there's a link to that page in the
35:48 - description section below be sure to
35:49 - subscribe for future videos and thank
35:51 - you all for watching
36:02 - you

Cleaned transcript:

hey there how's it going everybody in this video we're going to be learning how to run code concurrently using the threading module now this has been a highly requested video for some time now so I'm glad that I finally am getting around to this now I'm also going to be doing a followup video showing how to run code in parallel using the multi processing module and we'll also look at when you would want to use one over the other now if you don't know the difference between threading and multi processing then you should have a grasp on the difference between those once we're finished up now I would like to mention that we do have a sponsor for this video and that is brilliant dot org so I really want to thank brilliant for sponsoring this video and it would be great if you all could check them out using the link in the description section below and support the sponsors and I'll talk more about their services in just a bit so with that said let's go ahead and get started ok so first why would we want to use threading so basically we want to use threading whenever it's going to significantly speed up our program now this speedup comes from running different tasks concurrently and we'll talk more about concurrency and what that means in just a second now speed ups aren't really guaranteed so it really just depends on what you're doing so in this video we're gonna start off with a basic example where we learn how to run some simple sleep methods concurrently but then we'll finish up with a realworld example where we download some high resolution images from the internet now I want to show that real world example because you know personally when I watch tutorials that only show how it works with a basic example then I always feel like it doesn't really not that I don't walk away with any actual useful knowledge so we'll use the sleep method to get a good idea of how to use threading and then we'll be sure to go over the more complicated real world example of downloading images online so let's go ahead and get started so I have a starting script open up here and if you'd like to follow along then I'll be sure to have a link to this code in the description section below as well and like I said we'll start with a very simple example and see how this works and then build up to more realistic examples so for the script here I'm just importing the time method and then I am starting a counter this is just so we can measure how long this entire script takes so you really don't have to pay attention at least on these lines here but then we just have a simple function called do something and this is printing that we're going to sleep for one second then we actually sleep for a second and then I print that we are done and then we are running that function and then I am getting the finished time here and then I'm printing out that our script finished and I'm printing out the total number of seconds okay so if I run the code that we have right now we can see that it said that we're sleeping for one second that we're done sleeping and that we finished in one second and that sounds about right since we're running the do something function one time and that's sleeping for one second and if we were to run that function twice then our program will likely take two seconds so let's go ahead and see that so I'm just going to copy that and execute that function again and if I run this then we can see sleeping for a second sleeping for a second finished in a little over two seconds so we can see that each time we run the do something function it's adding about one second to our script but it's not really doing anything on the CPU in that function it's just sleeping so our script is just waiting around sleeping for a second and once that's done it moves on to run that next function and set around sits around waiting for another second sleeping and then at that point we're basically done and our script finishes now I created a quick graphic here to represent what this looks like so let me pull this open here in my browser so basically this is what our script looks like right now we're running a function here and then it is sleeping for one second but this is just us sitting around waiting and after that second we run another function here and then it comes up here and waits another second and then finally we are done and running everything in order like this is called running it synchronously and so anytime our program is running synchronously it actually isn't doing much on the CPU and it's just waiting around like this and that's usually a good sign of when we can get some benefits from using threading and concurrency now these are called CPU bound and i/o bound task now CPU bound tasks are things that are crunching a lot of numbers and using the CPU and the i/o bound tasks are things that are just waiting for input and output operations to be completed and not really using the CPU all that much so some other examples of i/o bound tasks include you know reading and writing from the file system and other file system operations network operations downloading stuff online and things like that when it comes to threading we're gonna see benefits when our tasks are IO bound which again means that we're doing a lot of waiting around for input and output operations like you know reading data from disk or network operations now if our tasks are doing a lot of data crunching and our CPU bound then we're not going to get that much of a benefit from using threading as a matter of fact so some programs actually run slower using threads because of the added overhead cost when they're creating and destroying different threads now if a task is CPU bound then we'll likely want to use multi processing and run it in parallel instead and again we're gonna take a look at that in the next video so when we run something concurrently using threads it's not actually going to run the code at the same time it just gives the illusion of running code at the same time because when it comes to a point where it's just waiting around it's just going to go ahead and move forward with the script and run other code while the i/o operations finish and I've got another graphic put together of what this looks like so here's an example of what our code would look like when we use threading so we're gonna run this function and we can see that it comes up here and waits a second but as soon as that starts waiting our code is just gonna move on and go ahead and run another function while we're waiting for this one second to be done sleeping and then we kick off this other second so these are actually overlapped here but we never actually ran any of this code at the same time it's just going to give the illusion of running the code at the same time and then finally we can see that we are done a little bit sooner now this graph isn't a scale you know these weights here would actually be much shorter okay so now that we've actually talked about concurrency and when to use threads now let's see how to actually do this with our current script so first let's import the threading module now this is in the standard library so we don't need to install anything so I'm going to come up here to the top and I'm just going to import threading now I'm going to show an older way of how to do threading first so that we can get a good idea of what's going on but if it seems confusing at first then definitely stick around because I'm also going to show some newer ways of doing threading using pools that allow us to add threading to our programs with a lot fewer lines of code okay so first instead of running the do something function twice in a row like this let's instead turn both of these into threads so to do this I'm going to create two threads for both of these so to do this I'm just going to overwrite where we are setting these functions here and I'm gonna create one thread called t1 and this is going to be threading dot thread and now we want to set a target and our target is the function that we want to run and that is the do something function now we actually want to pass in the function here we don't want to execute the function so don't put on parentheses like this we just want to pass in the function by itself uh neck's acute 'add okay so now let me copy this line and let's create another thread so I will call this t2 and we will keep everything else the same we're just creating a thread with that target of do something okay so at this point we've created two thread objects but we're not actually running that code so if I run this then we can see that it finished immediately but nothing from our function got printed out so our function actually didn't run so in order to get our threads to run we need to use the start method on each thread so here below T I'm just gonna say t1 dot start and t2 dot start and that will actually run our thread but it not might not actually do exactly what we think it'll do so if we run this right now then we can see that it now runs the functions and we can see that it printed out the first lines from both of those functions here let me make this a little larger so it printed out that both of our threads were going to sleep for a second and then it said that our script was finished in zero seconds and then it printed out that it's done sleeping now our script actually took around one second to complete but the reason that it says that it completed in zero seconds is because it started both of those threads and while the threads were sleeping our script ran concurrently and continued on with the rest of the script so it immediately came down and calculated our finish time here and printed out our last print statement as our threads were still sleeping and then once that one second was up our threads continued on and both printed that they were done sleeping now what if we our threads to finish before we calculated the finish time and before we printed out that our script was finished so in order to do this we can use the join method so to do this just below our starts I'm also going to run the join method on both of these and that will make sure that they complete before moving on to calculate the finish time and to print out this statement here so if I save this and run it then we can see that both of our threads started at almost the exact same time and then they both printed out that they were done sleeping after a second and then our script continued on to print that our script finished after one second now if using threads seems a bit complicated right now then definitely stick around until the end of the video because we're gonna see an easier way of how to do what we're doing here but I think it's important to understand what this is doing so far even if we use other methods where we don't manually call these start and join methods okay so right now we're not really getting that big of a speedup here so our code ran in two seconds before and now it's running in one second but that's because our function doesn't take too long and we're only running it twice but what if we wanted to run our function ten times well if we were to run our code synchronously where it runs one after the other then we can take a guess that it would take about ten seconds since one would have to finish before another started but if we ran this with threads then it should still be around one second to complete so let's go ahead and see an example with this now instead of manually creating ten different threads let's instead create and start these threads and a loop so to do this I'm going to come up here and copy this threading part here and now I'm just going to remove everything that we had here before and now I'm just going to create a loop so I'll say for underscore in range of ten and then I'm gonna say T for our thread is equal to threading dot thread with a target of do something and now let's also start that thread within our loop now if none of you have ever seen an underscore in Python here basically this just means it's a throwaway variable because all we want to do is a loop over these ten numbers here but we're not actually doing anything with it I just have an underscore variable so that just to say that we're not using anything within the loop okay so now we have our loop here and our threads are starting but we can't actually do a tea or a thread dot join within the loop because it would join on the thread before looping through and creating and starting the next thread so it would basically be the same as running the code synchronously so we need a way that we can start all of these threads in one loop and then loop through the threads again and run the join method on them so that they all finish before the end of our script so to do this we can append each thread that we create to a list of threads so above the for loop here I'm going to create a list of threads and this is just going to be empty for now and now below T dot start I'm going to say threads dot append and we will append each thread that we started so now once we go through this loop we should have a list of all these threads that we started so now let's run join on all of those so I'll say for thread in threads and then we will do a thread dot join ok so now we're actually running this do something function ten times and it sleeps for one second every time but since we're using threads it's just going to keep moving forward each time we sleep so instead of taking ten seconds let's run this and see how long it takes so we can see all those got kicked off and our scripts still finished in just one second okay so that's pretty good so we've already taken a script that normally would take ten seconds and we've instead finished it in one second okay so now let's look at how we can pass in arguments into our function so right now we're running a function that doesn't accept any arguments but let's add a couple real quick so we can see what this looks like so right now we're just sleeping for one second but let's add an argument that specifies how long we actually want to sleep so up here and our dosomething function I'm going to pass in an argument and I'll just call this seconds and now I will say that we are sleeping for however many seconds and this needs to now be and F string so that we can pass in the variable like that and now instead of sleeping for one second we'll sleep for the number of seconds that we passed in as a variable here and just so this doesn't say sleeping for 10 second or something like that let's also say that this could be seconds as well okay okay so now our function is expecting an argument for the number of seconds to sleep so let's pass in seconds as an argument and we need to pass that in as a list of arguments so down here where we create our thread this is where we're going to pass in our arguments so this is just an args argument and we will pass this in as a list now we only have one argument so this is just going to be a list of one value so let's sleep for 1.5 seconds and stell and instead so now we should expect our function to take about 1.5 seconds every time so if I save this and run it then we can see that now we are finished with our entire script in 1.5 seconds and this still ran at this function ten times so normally this would take 15 seconds if we were growing this synchronously but now we're finishing it in 1.5 seconds okay so I said before that I was going to show you the older way of doing threads and then I'd also show you what I believe is a faster and easier way of doing this now I still wanted to show you the manual way of creating these threads because I think this can still be useful depending on what you're doing but I also think it's better to learn this manual way first to understand a little bit better of what's going on in the background but in Python 3.2 they added something called a thread pool executor and in a lot of cases this is going to be an easier and more efficient way to run these threads and it also allows us to easily switch over to using multiple processes instead of threads as well depending on the problem that we're trying to solve so let's replace what we currently have and instead use this thread pool executors now this is actually not in the threading module it's in the concurrent futures module so at the top instead of using importing the threading module I'm going to import and I don't think I even need threading anymore so I'm just going to import current dot futures and when we use this thread pool executors it's usually best to use this with a context manager so above our threads list here I'm just going to do the same thing that we already have using the concurrent futures module instead so to do this I'm just gonna say with and let me go ahead and exit out so we can see a little bit more of the screen here so I'm gonna say with concurrent dot futures dot and this is thread pull whoops let me spell that correctly thread pull executors and we will say as executor there and now with our executors there are a couple of different methods that we can use so if we want to execute the function once at a time then we can use the submit method so the submit method schedules a function to be executed and returns a future object so let's add this in and I'll explain this a little bit more so I'll say F 1 is equal to executors dot submit and we will now pass in the function and the arguments so I'm gonna say do something is the function that we want to run and we'll just pass in an argument of one for one second so again the submit method schedules a function to be executed and returns a future object now a future object basically encapsulate s' the execution of our function and allows us to check in on it after it's been scheduled so we can check that it's running or if it's done and also check the result so if we grab the result then it'll give us the return value of the function now right now we're just printing out values and not returning anything but let me add a return value so that we can grab that so instead of printing out that we are done sleeping here instead let me return that string of done sleeping and okay let me take out these parentheses here okay so now we are returning that string instead of printing it out so if we still want to print that then we need to print the return value of that function so let's grab that by using the result method so here within the context manager I'm just going to say print and we will print f1 dot result now if we run the result method here then it will actually wait around until the function completes okay so let's comment out what we had before so all of this code here is how we did threads previously and now let's run this code with our new thread pool executors here okay so we can see that that works and that's a lot less code than we had down here that's commented out and if we wanted to run this multiple times then we could run submit multiple times as well so above our f1 result let me create another future object here so this will be F two we'll just keep everything else the same and now let's also print out the f2 result so if I save that and run it then we can see both of those got kicked off at the same time and that we finished our script in one second and if we wanted to run this ten times like we did before then we likely wouldn't want to run submit ten two different times so we could use a loop like we did before so instead of running one at a time I'm instead going to use a loop and we could use a regular loop like we did before but I'll go ahead and use a list comprehension to create these instead so we could say let me just copy this entire submit line here and instead I'm going to say results is equal to and now let's create a list comprehension so I'm going to say that we want to run executors dot submit with our do something function and an argument of one second four and then just an underscore for two as a throwaway variable in range of ten now if you've never used a list comprehensions before then I do have a separate video on that if you'd like to see exactly how this works but again if you're not familiar with list comprehensions then you can use a regular for loop like we did down here at the bottom okay so now we've created a list comprehension that's running our submit function ten different times with an argument of one sec now in order to get these results we can actually use another function from the concurrent futures module called as completed now this will give us an iterator that we can loop over that will yield the results of our threads as they are completed so I think this is a really useful method so to use this we can just say I'm going to get rid of our lines here and I'm just going to say for F in concurrent dot futures and then dot as underscore completed and we want to pass in our results list here to our as completed method and within this list we can just say print F dot result so if we run this then we can see that it still R in it ran that ten times and if we scroll down to the bottom here then we can see that it still ran this in one second now to prove that these are actually coming in as they're completed let me actually pass in a different range of seconds for our threads to sleep and those should print out in the order that they complete so I'll create a list of seconds to sleep here so above our results I'm just going to create another list and I will call this sex is equal to and I'll do five four three two and one and now instead of use passing in one here I'm instead going to pass in a second for a second in our list of seconds and I'm also going to print out the seconds in the return statement as well that way we can see which ones are finishing and in what order so I'm going to make this an F string as well and just here at the end I will just print out the seconds argument that we are passing in so again what our list comprehension here is doing is we are submitting this do something second with this argument of SEC and we are doing that for each value of seconds in this seconds list so this should get submitted five times with a 5 4 3 2 and a 1 so if I save this and run it then we can see that it says sleeping 5 seconds 4 3 but then the order that he's finished was that it was done sleeping for one second first then two then three them for them five and our total script took five seconds to complete now we actually started the fivesecond thread first but since we use that as completed method it printed out our results in the order that they completed okay so with the submit method its submitting each function once at a time now in order to run submit on an entire list then we need to do a loop or a comprehension like we did here but if you're familiar with the builtin map method in Python then there's actually something similar that we can do with threads where we can use a map method to run our function over a list of values now if you're familiar with that builtin Python map method then this is actually very similar except it uses threads instead so it runs the function with every item of the interval that we pass in so let's say that I want to map our function to our list of seconds so to do this we could say here let me let me just overwrite all of this that we have now and instead I will use a map method and say results is equal to executors dot map and we want to map the do something function and we want to pass in our iterator of seconds here so again what map is going to do is it is going to run the do something function with every value in this list of seconds here now when we use the submit method it returned a future object and when we use map it instead returns the results now it's going to still run those threads concurrently but instead of running the results as they completed like we saw before map is going to return the results and the order that they were started so to loop over these results we can just say for result in results and then let's just print out that result so if I run this then we can see that it started off all of our sleeps but nothing has returned yet and then it returned the done sleeping for five seconds four three two one so we can see that all of threads kicked off at pretty much the same time but then it looked like they completed all at the same time as well now they didn't actually all complete at the same time but when you loop over your results using map like we did here then it returns the results and the order that they were started so since we slept for five seconds first then we waited for that one to finish before printing out the other results but it still didn't slow us down at all we can see that our entire script still took about five seconds in total to finish now another thing to point out here is that if our function raises an exception then it won't actually raise the exception while running the thread the exception will be raised when its value is retrieved from this results iterator so if you need to handle exceptions then you can do that within the iterator if you'd like now if you'd like to learn more about handling exceptions then I do have a more indepth video if you'd like to learn more about that and I'll be sure to leave a link to that video in the description section below for anyone who is interested now even if we don't grab all of our results within the context manager here it's still going to automatically join all of those and let them finish after the context manager ends so if we comment out where we're printing the results and I run this then we can see that it still waits until these are done until it gets down to the end of our script so it didn't do like it did before when we didn't have joins and say that we finished in zero seconds even though it actually wasn't finished yet so it's still waited for the threads in that thread pool to complete before printing out that our script was done okay so now that we've looked at a basic example using sleep now let's take a look at a more realworld example of where threading would be useful so I've got another script open here where I'm not using threading at the moment so let me pull this up and let's take a look at what this is doing and again I'm gonna have a link to this code in the description section below for anyone who wants to follow along so this is a script that goes out and downloads some high resolution photos from unsplash now if you don't know what unsplash is it's a website that has some really nice free photos available for anyone to use so let me go over this script and show how someone might do this normally so normally you might have a bunch of image URLs here that you want to download and now let's say we actually want to download those so somebody might say okay so for each image URL and our image URLs let's use the request library to go out and get that content and now I'm just doing some string parsing here to parse out the image name which would just be this section right here so I'm grabbing the image name and then putting a dot jpg on to the end of that and now I'm opening a file here in byte mode and then I am writing those image bytes that we downloaded from the internet onto our file system and then we're just printing out here that our image was downloaded okay so this script should go all through all of these image URLs and download all of these images into my current directory so if I run this right now then let's see how long this takes now we can see that these are downloading and I do have this pulled up here in my file system as well so we can see that it is going out and downloading these but it's downloading them one at a time so there should be 15 total here so once this is finished then we can get an idea of how long this took and it should be done any second now okay so we can see that this finished in 23 seconds to download those 15 highresolution photos online now when we're downloading a lot of things online this is actually a great candidate to use threading because this is one of those IO bound operations that is actually spending a lot of time just waiting around it's not it's going out and waiting for a response from the site and it's not moving on to the next URL until that gets an entire response back so if we use threads that then it can actually go ahead and move on to the next URL while that's waiting around for a response and we can make other requests at the same time okay so now let's see how we can change this code that someone might normally write and instead change this to where it's using threads instead and see if we can speed this up so first let's think about what we're doing here so we're looping over our list of image URLs and then using the request library to download those one at a time so if we remember from our previous example this would be a pretty good candidate for the threading pull map for the threading pull map method where we can pass in a function and a list and have that function run with every value in that list and if that doesn't make sense right now then well it should make more sense once we actually change this code here but first we're gonna have to actually create a function that will download the data from a single URL so to do that we can just say I'm just going to change this for loop here and I'm gonna turn this into a function so I'm gonna say download underscore image and we want to pass in an argument of the image URL and everything within this function can just stay the same because we were looping over that before and now we just turn that into a function where we are just downloading one image URL at a time so it's basically the same thing as our for loop for now ok so now that we have a function that downloads one image at a time now we can create a thread pool and map our list of URLs using that function that we just created so first let's import the concurrent futures module so that we can use that so here at the top I'm going to actually let me put this below time here I will import concurrent dot futures and now down here below our function let's create a thread pool executor so just like before that was concurrent dot futures and we're using this within a context manager we want this to be a thread pool executors make sure I spell that correctly and we will say as executor therefore our context manager okay so now if we use that map method so I'm going to say executors dot map and we want to run this function and let's pass in our list of image URLs and again just to go over this one more time the map method here what it do is it will run this download image function with each value in this image URLs list but since we're using a thread pool executors it's going to actually down those download those with a different thread for each one so just with those small changes this will actually use threads and make those requests asynchronously instead of synchronously like we saw before so now if I run this code to download all these images again then we can see that these are coming in a lot faster because it's using threads instead of doing this synchronously so now we can see that it finished in five seconds instead and if you remember before we ran that it was taking 23 seconds so that's a pretty significant speedup and this would be even more significant if we were doing even more requests so the speed ups can be you know pretty drastic depending on what we're actually doing now what would be an example of something that wouldn't be i/o bound well if something is doing a lot of computation then threads actually wouldn't be ideal for that type of task so if we are processing the photos and resizing them and things like that instead of just downloading them from line then the threads wouldn't actually speed that up all that much so that would actually be an example of something that is CPU bound and not IO bound and like I said before in those kinds of scenarios threads can actually slow down our script instead because the threads have some overhead when being created and destroyed so it really depends on what you're doing and what are to decide if the right choice to speed up your program is threading or multiprocessing so when you're doing something that requires a lot of processing then we can use multi processing instead of threading so with that said in the next video let's go ahead and process these photos that we just downloaded and do some image manipulation to them and then we can take a look at the multi processing module to see how we can speed up that task as well that way we can see the difference between threading and multi processing and when you might want to use one over the other now before we finish up here I'd like to mention the sponsor of this video and that is brilliant org so we've been talking a lot about thread and multiprocessing and these topics are especially useful in the field of data science and data science is a field that is growing at a very rapid pace if you'd like to learn more about programming and data science then I would definitely recommend checking out brilliant org so brilliant is a problemsolving website that helps you understand underlying concepts by actively working through guided lessons and they've recently added some brandnew interactive content that makes solving puzzles and challenges even more fun and handson and if you'd like to learn more about data science and programming with Python then I would recommend checking out their new probability course that covers everything from the basics to realworld applications and also fun things like casino games they even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language so they're guided lessons will challenge you but you also have the ability to get hints or even solutions if you need them it's really tailored towards understanding the material they even have a coding barment built into their website so that you can run code directly in the browser and that is a great complement to watching my tutorials because you can apply what you've learned in their active problemsolving environment and that helps to solidify that knowledge so to support my channel and learn more about brilliant you can go to brilliant org forge / CMS to sign up for free and also the first 200 people that go to that link will get 20% off the annual premium subscription and you can find that link in the description section below and again that is brilliant dot org forge / CMS okay so I think that is going to do it for this video I hope you feel like you've got a good idea of how to use the threading module and how we can use this to speed up our scripts now there are some more advanced topics that we could cover in the future with threads such as thread local data race conditions locks and things like that but we'll save that for a future video if anyone is interested and like I said in the next video we'll see how to use the multi processing module to do the same thing that we did in this video but instead the task will be image processing instead of downloading images but if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to spore them then there are several ways you can do that the easiest ways to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute to patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
