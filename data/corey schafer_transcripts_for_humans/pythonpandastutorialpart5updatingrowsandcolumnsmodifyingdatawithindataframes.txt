With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're going to be learning
00:02 - how to alter existing rows and columns
00:04 - in our data frames so in the last video
00:06 - we learned how to filter out specific
00:08 - information and we can use those
00:10 - techniques here to also modify our data
00:12 - so we'll learn how to update the data
00:14 - for our rows and our columns and in the
00:16 - next video we'll also learn how to add
00:19 - and remove rows and columns from our
00:21 - data frames now I'd like to mention that
00:23 - we do have a sponsor for this series of
00:24 - videos and that is brilliant org so I
00:27 - really want to thank brilliant for
00:28 - sponsoring this series and it would be
00:30 - great if you all can check them out
00:31 - using the link in the description
00:32 - section below and support the sponsors
00:34 - and I'll talk more about their services
00:35 - and just a bit so with that said let's
00:38 - go ahead and get started ok so let's
00:40 - look at how to update data within our
00:42 - rows and columns the last couple of
00:44 - videos we've already seen how we can
00:46 - filter specific data but now let's take
00:48 - a look at those same concepts and use
00:51 - them to make changes to our data so
00:53 - let's look at updating columns first and
00:55 - then we'll update some rows so I
00:58 - currently have my snippets file open
00:59 - here that we've seen in previous videos
01:01 - so that we can see what this looks like
01:03 - on a smaller data set before seeing how
01:05 - to do this on our larger data set with
01:08 - that stackoverflow Survey data
01:10 - now before we modify the columns let's
01:12 - take a look at these first using the
01:14 - columns attribute that we've seen in
01:16 - previous videos so let me add a new cell
01:19 - here down at the bottom we can look at
01:21 - the columns just by saying DF . columns
01:24 - and we can see that we just have three
01:26 - columns here so our column names are
01:29 - first last and email so let's say that
01:32 - we wanted to update the columns to be a
01:33 - little more specific
01:35 - so let's say that I wanted this to be
01:36 - first name instead of first so there's a
01:39 - couple of ways that we can do this so
01:41 - first if we want to rename all of the
01:43 - columns then we can simply do an
01:45 - assignment using the columns attribute
01:47 - that I just used so in order to do this
01:49 - I could just use an assignment here and
01:52 - just pass in a list so I could just pass
01:55 - in a list of all the different columns
01:57 - that I want these to be so I'll call
01:59 - this first name last name and I'll just
02:02 - keep email the same so if I run this
02:04 - let's now look at these columns again
02:07 - and now we can see that those column
02:09 - names have changed and if I actually
02:10 - look at the data frame here then they
02:13 - show up
02:14 - changed in the data frame as well now I
02:16 - almost never use this because this is
02:18 - used for when you're passing in
02:20 - different names for all of your columns
02:21 - I usually only need to change the names
02:24 - of a few different columns now one thing
02:26 - that is a lot more common is the need to
02:28 - change something specific about each
02:30 - column in our data frame so for example
02:33 - maybe your columns are all uppercase and
02:36 - you want them to be lowercase or vice
02:39 - versa or maybe your columns your column
02:41 - names have spaces and you want to
02:43 - replace the spaces in the column names
02:45 - with an underscore in this case we can
02:48 - use a list comprehension so for example
02:51 - let's say that I wanted to uppercase all
02:53 - of the column names here so in order to
02:56 - do this I could use a list comprehension
02:58 - and I could just say DF columns is equal
03:02 - to and now we'll just say like X dot
03:05 - upper for X in DF columns so if I print
03:13 - out that data frame after making that
03:15 - change then we can see that now all of
03:18 - our column names have been translated to
03:21 - uppercase now another thing that you
03:23 - might want to do is remove spaces and
03:25 - replace them with underscores especially
03:28 - if you like using the dot notation to
03:30 - access a column name that doesn't work
03:33 - if there are you know spaces in the
03:36 - column name because that's just not
03:37 - correct syntax so if you wanted to
03:40 - replace spaces with underscores instead
03:44 - then what you could do is just do
03:47 - something similar here and say DF
03:49 - columns is equal to DF dot columns dot
03:53 - STR we're using the STR method on this
03:56 - columns series here and then we can use
03:59 - the replace method from that string
04:02 - class so I can just pass in a space and
04:06 - say that we want to replace all those
04:08 - spaces with underscores now this isn't
04:11 - going to make any changes in our
04:12 - specific data frame because all of ours
04:14 - already have underscores if I reverse
04:17 - this and I did an underscore and then a
04:20 - space then we can see that now we
04:23 - replaced all those underscores with
04:24 - spaces that's probably not what you want
04:27 - though
04:27 - I would rather have underscores instead
04:29 - of spaces so if we do it this way then
04:32 - that's how you replace all of those but
04:34 - let me go ahead and set these columns
04:36 - back to the way that they were before
04:38 - I like lowercase so I'm going to change
04:40 - those back to lowercase there and now
04:44 - everything that we've seen so far
04:45 - applies to every one of our columns but
04:48 - what if we only wanted to change some
04:50 - columns well in this case we can use the
04:52 - rename method and just pass in a
04:55 - dictionary of the columns that we want
04:57 - to change so if I want to set the first
04:59 - name and last name back to what they
05:02 - were before then I could say D F dot
05:05 - rename and now we can just pass in the
05:09 - columns and we're going to pass in a
05:11 - dictionary of what we want here so the
05:13 - key is going to be the old value so I'll
05:16 - set first name back to first so the
05:19 - value is going to be the new value for
05:22 - that column name so we're going to map
05:25 - first name to first and then I will map
05:28 - last name here to last so I just have to
05:33 - put that in as a value there and now if
05:37 - I run this now then it might look like
05:40 - it worked but if I look at my data frame
05:42 - then those changes actually didn't go
05:44 - through this is another one of those
05:46 - methods where if we actually want that
05:48 - place to or if we want that change to
05:50 - take place then we have to say in place
05:53 - is equal to true because it'll just let
05:56 - us kind of see what it would look like
05:57 - if it worked but it's not actually going
05:59 - to change it so saying in place equals
06:01 - to true we'll make that change go
06:03 - through so now if I rerun this again
06:05 - then we can see that those column names
06:06 - are set back to the way that they were
06:08 - okay so that's a quick look at updating
06:10 - our columns now let's take a look at
06:12 - updating the data in our rows and we'll
06:15 - spend the majority of video learning how
06:17 - to update data in our rows since there's
06:19 - so much more that we can do here
06:20 - so first let's look at how to update a
06:23 - single value now in the previous video
06:25 - we saw how we can look up values using
06:28 - loke and I'll oak and we'll use that as
06:30 - our starting point for setting values as
06:33 - well so let's grab the row for John Doe
06:36 - right here it's row number two let's
06:40 - grab that
06:41 - and change his last name to Smith so in
06:44 - order to grab that row we can simply
06:46 - grab that row with the index label too
06:49 - so we can say D F dot Lok of 2 if I run
06:54 - that then we can see that we get that
06:55 - row of first name John last name doe and
06:59 - if you wanted to use a conditional like
07:01 - we saw in the last video to grab that
07:02 - row then that's definitely possible -
07:04 - you can do that as well now we could
07:07 - have said you know give me rows where
07:09 - the first name is equal to John and the
07:11 - last name is equal to dou if we wanted
07:13 - to do that as a conditional so now in
07:16 - order to update this information there
07:18 - are a couple ways that we can do this we
07:20 - can just pass in all of the new values
07:22 - for this row by passing in a list so I
07:25 - could just say that this row I want to
07:28 - set this equal to and then pass in all
07:30 - the new values so I'll say that I want
07:32 - to keep John the same I want his last
07:34 - name to be equal to Smith and then let's
07:36 - also change his email as well so John
07:38 - Smith at email com so if I run this and
07:42 - then we look at our data frame then we
07:46 - can see that now that last row has a new
07:49 - last name and a new email address now
07:51 - what if we had a lot of columns but we
07:54 - only wanted to change a couple of values
07:56 - so imagine you know with our survey data
07:58 - we have 85 different columns so it would
08:01 - be a pain if we wanted to change a
08:02 - single row and we had to pass in it or a
08:04 - single column and we had to pass in this
08:06 - huge list of 85 different values you
08:09 - know that would really suck to need to
08:11 - pass in that entire list just to change
08:13 - those couple of values so in this case
08:15 - we can just specify the exact columns
08:18 - using lok and again we saw this before
08:21 - when learning how to use the lok to
08:24 - filter data so if I wanted to just
08:26 - change the last name and email then
08:28 - first let's just grab those specific
08:31 - values so I can say D F dot Lok and then
08:35 - I can pass in a 2 for the rows then if
08:38 - you remember that we can also pass in a
08:39 - list as the second value here for the
08:42 - columns that we want so I'll say that I
08:44 - want the last and I want the email so if
08:48 - I run this then we can see that we just
08:49 - get the last name and we just get the
08:52 - email and now we can change this as well
08:54 - you
08:55 - using the same method that we used here
08:56 - above but we don't need to pass in this
09:00 - the values that are staying the same so
09:02 - I don't need to pass in that John value
09:05 - anymore since we're not changing that so
09:07 - let's change this back to dough just to
09:09 - make sure that this worked so John Doe
09:12 - at email com
09:13 - so now if I run this that should have
09:16 - made the assignment and now if I look at
09:18 - our data frame then we can see that
09:20 - those were set back so now we have John
09:21 - Doe and John Doe at email comm ok and
09:25 - finally here now let's just look at how
09:27 - to change a single value you might be
09:29 - able to guess how it be done but what we
09:32 - can do is just pass in a single row in a
09:35 - single column and just change that value
09:37 - we don't need to pass in a list so just
09:40 - to change that one value I will copy
09:43 - this line here but now I don't want a
09:46 - list of these columns let's just change
09:48 - the last name so this won't be a list
09:51 - anymore now I'm just saying that I want
09:53 - Row two the column of last and we'll
09:56 - just set that equal to Smith whoops let
09:59 - me put that in the string there so if I
10:03 - run that then we look at our data frame
10:05 - then we can see that it only changed
10:07 - that one value now pandas does have
10:10 - another indexer called @ and this is
10:13 - specifically meant for changing or
10:15 - looking up a single value now honestly I
10:18 - just used dot lok from these most of the
10:21 - time but the option is there if you want
10:23 - it I'm assuming it's there for
10:25 - performance reasons so if I wanted to
10:27 - change this back since this is just a
10:30 - single value then instead of using dot
10:33 - Lok then I could all you also use dot @
10:35 - so I'll do this exact same assignment
10:38 - here and I'll change this back to doe
10:40 - but instead of dot Lok I'm gonna say dot
10:42 - @ and let's just set that back and then
10:46 - if I look at the data frame then we can
10:48 - see that that worked as well and I'll be
10:50 - honest here I'll have to look at the
10:51 - documentation I'm not really sure why we
10:54 - would use dot @ instead of dot lok when
10:57 - we only need to get or set a single
10:59 - value maybe it's for performance reasons
11:01 - but I personally find myself using lok
11:04 - and i lok even for single values i
11:06 - actually did look it up in the pandas
11:08 - documentation
11:08 - but all it says there is that it's there
11:11 - and that it's similar to dot Lok it
11:13 - doesn't provide any actual justification
11:16 - as to why we'd use it but I wanted you
11:18 - know that it's available since it's
11:20 - awfully obviously there for a reason and
11:22 - hasn't been deprecated yet okay so now
11:25 - let me show you one mistake that is very
11:28 - common and that is when people try to
11:30 - change a value without using one of
11:33 - these indexers without using dot lok or
11:36 - dot @ so let me show you what this error
11:38 - or this warning would look like so let's
11:41 - say that we have a large data frame
11:43 - where we want to find this John Doe
11:45 - person and changed their last name to
11:47 - Smith so one way that we could do this
11:49 - is to use a filter to grab that specific
11:52 - row so I will come down here to the
11:55 - bottom and I'll just create a filter
11:57 - here and I will say that the email
12:01 - column of the data frame equals equals
12:05 - John Doe at email com that is the filter
12:11 - that we're looking for so if I apply
12:13 - this filter to my data frame just you
12:17 - passing it in directly to the brackets
12:19 - like this then we saw in the last video
12:21 - whoops and this is filt not filter since
12:24 - filter is a built-in Python keyword so
12:27 - if I pass in that filt variable there
12:30 - directly into the brackets again we saw
12:33 - this in the last video if I run this
12:35 - then we can see that that works for
12:36 - looking up these values so that actually
12:39 - returned a data frame there that just
12:41 - has a single row so we could grab that
12:43 - last name column just by accessing that
12:47 - last name from that data frame that was
12:50 - returned so if I run this then that
12:53 - works as well we can see that we got
12:54 - that doe value and finally you might
12:57 - think that in order to change this last
13:00 - name to Smith that we could just come up
13:02 - here and say okay we got that value now
13:05 - I want to set that equal to Smith so if
13:08 - I run this then you can see that this
13:10 - big warning pops up here and if we look
13:13 - at this warning it says that we get this
13:16 - setting with copy warning okay so we got
13:20 - warning but did it actually make that
13:22 - change to our data frame so let's look
13:25 - at our data frame here okay so we tried
13:27 - to change that last name to Smith I've
13:29 - know we know we've been going back and
13:31 - forth between these last names here but
13:33 - it was doe and then we tried to change
13:35 - it to Smith and that did not work so it
13:38 - didn't make that change when we did the
13:40 - assignment this way now the reason that
13:41 - it didn't work here is a little
13:43 - complicated
13:44 - essentially it's because the way that
13:46 - we're doing it here requires multiple
13:48 - operations in the background which can
13:51 - determine whether pandas returns a view
13:53 - or a copy of our data frame so when our
13:56 - value isn't getting set it's because
13:58 - it's getting set on a temporary object
14:00 - that's just getting tossed out
14:02 - immediately after so pandas does a lot
14:05 - better job of explaining this a specific
14:07 - warning and they have a little link here
14:09 - down to the documentation directly
14:11 - within the warning itself so if you want
14:14 - to learn more about this then you can
14:16 - just click on that warning or go to this
14:17 - link and it explains it in a lot more
14:20 - detail but the moral of the story here
14:21 - is that when you're setting values just
14:24 - use dot lok or the dot at indexers that
14:27 - we've already seen and you shouldn't
14:29 - have any problems so we could rerun this
14:31 - same operation up here at the top and
14:35 - actually let me just copy this so that
14:37 - if anybody I will put this notebook out
14:41 - here on after I'm done with this and if
14:43 - people want to see this exact error then
14:45 - I will leave that cell there so we could
14:49 - rerun this exact same operation but
14:51 - instead of using these brackets directly
14:54 - here I can just say D F dot Lok and then
14:58 - I want to apply those filters to my rows
15:02 - and then I want to grab the last name
15:05 - column as well so if I run it this way
15:09 - instead and then we look at our data
15:13 - frame then we can see that that tit
15:15 - changed did go through so we were able
15:17 - to apply that filter and then set that
15:20 - last name equal to Smith in that data
15:21 - frame so if you ever get these warnings
15:24 - like this that just pop-up then
15:25 - definitely don't ignore them because you
15:28 - know in this case it didn't even
15:30 - actually set the value that we thought
15:31 - that we were setting so you really need
15:33 - to be careful with stuff
15:34 - like that okay so that's how we would
15:37 - update a single row of data but how
15:39 - would we update multiple rows of data
15:41 - well there's a couple of different ways
15:43 - that we could do this so for our for our
15:46 - first example let's just assume that we
15:49 - want to change all of the email
15:50 - addresses so that they are lowercase so
15:53 - this might be something that you want to
15:54 - do to make the email addresses easier to
15:57 - search so to do this we could just
15:59 - assign that column to the lowercase
16:02 - value of itself so first let me grab
16:05 - those lowercase values and to do this we
16:09 - could just say DF and then we could
16:12 - access that email column and then that's
16:16 - going to return a series and then we can
16:18 - just use this dot STR class on the
16:21 - series and use the lower method on that
16:26 - string class so if I run this then we
16:28 - can see what this returns is a lowercase
16:31 - version of all these emails if I look up
16:33 - here in the original data frame then
16:35 - these have mixed casing in there and now
16:37 - these are all lowercase now this just
16:40 - returns the lowercase values of these
16:42 - emails it didn't actually make that
16:43 - change now in order to make that change
16:46 - we can simply assign that column to this
16:49 - value so what I could do here is I could
16:52 - just say DF email is equal to DF e mail
16:57 - dot string dot lowercase so if I run
17:00 - this and then we look at our data frame
17:04 - now those changes actually did go
17:06 - through and all of our emails are now
17:08 - lowercase so that's one way that we can
17:10 - change multiple rows at once but maybe
17:13 - we want to do something a little more
17:14 - advanced so there are several ways that
17:17 - we can do this and we'll go over all
17:19 - four popular methods in order to do this
17:22 - and a lot of people get these four
17:23 - methods confused
17:25 - so let's go over each one individually
17:26 - and try to explain them in detail and
17:29 - there's definitely a good reason why
17:31 - people get these confused because
17:33 - they're very similar in what they do so
17:36 - the four methods that I'm going to be
17:38 - talking about are apply and map and
17:42 - apply map and replace whoops let me
17:47 - spell that correctly
17:48 - place so first let's take a look at
17:51 - apply so apply is used for calling a
17:55 - function on our values and apply can
17:58 - work on either a data frame or a series
18:00 - object and the behavior might be a
18:02 - little different than you expect for
18:04 - each of those different objects so first
18:06 - let's look at how apply works for a
18:09 - series so when we use this on a series
18:12 - it can apply a function to every value
18:14 - in our series so for example let's say
18:17 - that I want to see the length of all of
18:19 - our email addresses maybe we have a
18:21 - website and we want to make sure that
18:23 - none of the email addresses are too long
18:25 - or something like that so I can apply
18:27 - the L en the length function to each
18:31 - value in our series by doing something
18:34 - like this I can say DF and access that
18:37 - email column and then I can say dot
18:39 - apply Lin so we'll apply that Lin
18:42 - function and when I run that what we can
18:46 - see what it's doing here is it saying
18:48 - okay the Lin of the first row email
18:51 - addresses was 23 so I've never actually
18:53 - counted up the characters in my email
18:55 - address but it's telling me it's 23 and
18:57 - then this one says it's 17 and then it
19:00 - says this one is 17 so that's a quick
19:02 - little way that we can use apply to grab
19:04 - some information about our data but we
19:06 - can also use this to update values as
19:08 - well so in this example I'm just going
19:11 - to create a simple function that returns
19:13 - the uppercase version of our email but
19:16 - the function can be as complicated as
19:17 - you want it to be
19:19 - so let me write a simple function here
19:22 - that does what I want it to do so I'm
19:25 - gonna say let's say I'll call this
19:27 - function update email and this will take
19:30 - in an email value here and then I'll
19:34 - just return that email in uppercase so
19:37 - email dot upper so let me run this now
19:40 - again this is a super basic example here
19:42 - if I really wanted to uppercase the
19:44 - email addresses then I would just do the
19:46 - same thing that we did before when we
19:48 - made them lowercase but I just am using
19:51 - this as an example here so when we apply
19:53 - functions it's usually to do some more
19:55 - advanced updates than what we're doing
19:58 - here but let's apply this function to
20:00 - our email column so
20:02 - to do this we could say DF and access
20:06 - that email column dot apply and then we
20:10 - can pass in that update email function
20:13 - that we just wrote now we don't want to
20:16 - execute this function so you don't want
20:18 - to put parentheses here you just want to
20:20 - pass in the function without parentheses
20:22 - so that we're passing in the function
20:24 - itself and not an executed version of
20:26 - itself okay so let me run this cell and
20:30 - we can see that now we're getting back a
20:32 - series here of our email addresses in
20:35 - uppercase now if this doesn't actually
20:38 - change our values or change our rows
20:41 - like we saw before so to do this we can
20:43 - just assign that to our column so I can
20:46 - just take what we wrote here and then I
20:49 - can just set that series equal to that
20:53 - series with that applied function so if
20:56 - I run that and then we look at our data
20:58 - frame then we can see that now our email
21:00 - addresses are all uppercase now again
21:02 - this was a pretty simple function here
21:04 - all we did was return this email dot
21:07 - upper now for simple function so for
21:09 - simple functions like this you might see
21:12 - people use lambda functions as well now
21:15 - if you're not familiar with lambda
21:16 - functions basically they are anonymous
21:18 - functions with a specific name or
21:21 - without a specific name that we can use
21:23 - for things like this so here's what it
21:25 - would look like in this example so let's
21:28 - say that I wanted to convert these back
21:30 - to lowercase so what I could do is I
21:33 - will just grab this here now I'm going
21:36 - to use a pass n a lambda function here
21:38 - to dot apply instead of passing in that
21:41 - other function that we wrote so I'll say
21:43 - lambda and the synth if you're not
21:45 - familiar with Landa functions then the
21:47 - syntax can be a little weird here but
21:50 - basically we just have a no-name
21:51 - function here and then what we want to
21:53 - return so I want to return X dot lower
21:57 - of that argument that we get passed in
22:00 - so if I run that and then look at our
22:02 - data frame again then now we can see
22:04 - that we have the lowercase version of
22:06 - our email so if you're more comfortable
22:09 - writing regular functions then you can
22:11 - do it this way but if you are
22:13 - comfortable writing lambda functions and
22:15 - your function
22:15 - isn't too complicated then you can
22:17 - always do it this way like we did here
22:19 - now we're working with strings here but
22:22 - you can also use this with numbers where
22:25 - we can run any type of calculations that
22:27 - we want as well okay so this is how
22:29 - apply works on series objects so now
22:33 - let's look at how apply works with data
22:35 - frames so far we've only been using this
22:38 - with a series so anytime we access a
22:41 - column like this that returns a series
22:43 - and again when we ran apply on the
22:46 - series it ran a function on all of the
22:49 - values in that series now when we run
22:52 - apply on a data frame it runs a function
22:55 - on each row or column of that data frame
22:58 - so let's see what this looks like and it
23:00 - should make more sense so let me grab
23:03 - the example of above where we ran the
23:05 - Len function right here and let me copy
23:12 - this and paste this down here and then
23:15 - we'll take a look at what this looks
23:16 - like when a data frame so again what
23:18 - this gave us was the length of each
23:20 - value in that email series so you might
23:24 - think that you can run this same apply
23:26 - method on the entire data frame and it
23:28 - will give us the length of each value in
23:30 - the data frame but that's not what it
23:32 - does so let's see what that gives us so
23:35 - instead of accessing a specific column
23:37 - let's just say DF not apply and pass in
23:41 - that Lin function so if I run this then
23:44 - we get this response that you might not
23:46 - expect so what's going on here is that
23:49 - it's not applying the length function to
23:51 - every value in the data frame it's
23:53 - actually applying the length function to
23:56 - each series in the data frame
23:57 - specifically the columns so basically
24:00 - what this is telling us is that our
24:02 - first name column has a length of 3 so
24:05 - if we look up here at first we can see
24:07 - that first has three values it's telling
24:09 - us that last has three values and email
24:12 - has three values so that's just the
24:14 - number of rows in each column and we can
24:17 - get that same result for a specific
24:19 - series if we manually check the length
24:21 - of one of these so if I was to say Lin
24:25 - access one of these columns and ran this
24:28 - then we can see that gives us three so
24:31 - that's basically what apply is doing
24:33 - here on the data frame but it's doing it
24:35 - for every column and you can also have
24:38 - this apply to rows as well if you change
24:40 - the axis so we can change the axis here
24:44 - and say no I want to do this on the rows
24:46 - whoops and I put row I meant to put rows
24:49 - so if I run this oh and I made another
24:52 - mistake here
24:52 - I actually didn't mean to put rows roses
24:54 - the default I meant to put columns so if
24:57 - I put columns then we can see that now
24:59 - we get three as well but now what it's
25:02 - doing here is it's counting it this way
25:04 - so it's saying okay one or row zero has
25:07 - three values but it's saying okay those
25:10 - values are Corrie Schafer and then the
25:12 - email it's not counting it downward so
25:15 - basically we want to use functions that
25:17 - will make sense to be used on a series
25:20 - object when using a ply on an entire
25:23 - data frame so for example let's say that
25:25 - we wanted to grab the minimum value from
25:28 - each column well series objects have a
25:30 - min method so we could pass that in to
25:33 - apply and see the minimum value for each
25:36 - series now in our sample data frame we
25:39 - have all string values so if we grab the
25:41 - minimum value from a series of strings
25:44 - then it'll just return the one the first
25:47 - one in alphabetical order so let's see
25:49 - what this would look like so we can come
25:52 - down here and we can say D F dot apply
25:54 - and now let me pass in that series men
25:57 - method so I could say P D is what we
26:00 - imported pandas eyes P D series dot min
26:04 - so if I run this then we can see okay
26:07 - it's saying that the one that comes
26:10 - first in the alphabet in the first
26:12 - category is quarry the one that comes
26:15 - first and the last names is doe so that
26:18 - is you know that's a d these two are s's
26:20 - that make sense and then my email comes
26:22 - before these other two emails now it
26:24 - probably would have been better to take
26:26 - a look at this using a series of
26:28 - numerical data instead because with
26:31 - numerical data this stuff you know
26:33 - obviously makes more sense so if we used
26:35 - series dot min on numerical data
26:38 - that would obviously give us the minimum
26:40 - values for each of those numbers and we
26:43 - can use lambda functions with this as
26:45 - well but you just have to remember that
26:47 - the lambda will be working on a series
26:50 - object so if I come down here I can say
26:53 - D F dot apply and now let's pass in a
26:57 - lambda now this X here this X is going
27:01 - to be a series it's not going to be a
27:04 - value so what methods do a series have
27:07 - well a series has a min method so let's
27:11 - return the minimum value and run that
27:13 - and we can see that that gives us the
27:15 - same response that this one up here gave
27:17 - us now like I said this is kind of a
27:19 - contrived example because we could get
27:22 - these same results by using the data
27:24 - frames min method but I just wanted to
27:26 - point out how this actually works so
27:28 - this is way more useful when your data
27:31 - frame contains numerical data so for
27:34 - example we could use numpy to apply the
27:36 - square root for all of our series
27:38 - objects or any type of numerical
27:40 - analysis like that
27:42 - okay so running apply on a series
27:45 - applies a function to every value in the
27:48 - series and running apply to a data frame
27:51 - like we did here applies a function to
27:55 - every series in the data frame but you
27:57 - might be wondering if there's a way that
27:59 - we can apply a function to every
28:02 - individual element in the data frame and
28:04 - that's what apply map is used for an
28:07 - apply map only works on data frames
28:10 - series objects don't have the apply map
28:13 - method so let me show you how this is
28:16 - different so again let's use that same
28:19 - built-in length function and pass that
28:21 - in to apply map so I'll say D F dot
28:25 - apply map and now let's pass in that
28:28 - built-in length function so if I run
28:30 - this then we can see that what this does
28:32 - is that it's now applying that length
28:35 - function to each individual value in our
28:38 - data frame so the first-name had these
28:41 - many characters so first name mine was
28:43 - Cory so Co re Y that's five characters
28:46 - and then Jane and then John so those are
28:49 - four characters and we saw the length of
28:51 - the emails before
28:52 - three 1717 so that's what this is doing
28:55 - here it's applying that function to
28:57 - every individual element of our data
28:59 - frame so this might be how some of you
29:02 - expected the apply method to work on a
29:04 - data frame but instead we use apply map
29:08 - for this now I know that this can be a
29:10 - bit confusing but hopefully after seeing
29:13 - those differences it makes a little bit
29:15 - more sense of when we would want to use
29:17 - which so for example since we have an
29:20 - entire data frame full of strings in
29:22 - this example if I wanted all of them to
29:24 - be lowercase then I could just do
29:26 - something like this I could say D F dot
29:29 - apply map and then I can just pass in
29:32 - the string dot lower method so if I run
29:36 - this then we can see that now all of the
29:38 - values in that data frame are lowercase
29:40 - now if you had numerical data in your
29:42 - data frame then you would get an error
29:44 - here since you can't run string methods
29:47 - on numbers so you need to pass in a more
29:50 - complicated function that handles that
29:52 - appropriately ok so now we've looked at
29:54 - apply and apply map and hopefully those
29:56 - make more sense to you now so now let's
29:59 - look at the map method now the map
30:01 - method only works on a series so map is
30:05 - used for substituting each value in a
30:07 - series with another value so for example
30:10 - let's say that we wanted to substitute a
30:13 - couple of our first names so to do this
30:16 - I could say DF and access that first
30:20 - name column which is also a series and
30:23 - then I can use the map method on this
30:25 - and now I'm going to pass in a
30:26 - dictionary of the values that we want to
30:29 - substitute so let's say instead of
30:32 - quarry I want to pass in Chris and
30:35 - instead of Jane I wanted to pass in a
30:39 - value of Mary so if I run this then we
30:43 - can see that that returns a series where
30:46 - those first names were substituted out
30:48 - so quarry was the first value here and
30:51 - now it's Chris Jane it was is now Mary
30:54 - now one thing that I do want to point
30:56 - out here is that the values that we
30:58 - didn't substitute were converted to in a
31:01 - in values not a number of values now
31:04 - that may or may not be what we want
31:06 - and I'll show an example of this when we
31:08 - look at some real-world Stack Overflow
31:10 - examples now in this example we likely
31:13 - wouldn't want to get rid of these other
31:15 - names so you might be thinking okay well
31:17 - what if I wanted to keep John but just
31:19 - substitute these other names so if
31:21 - that's the case then instead of using
31:23 - map we can instead use the replace
31:26 - method so instead of doing what we did
31:29 - here I'll just copy this paste this in
31:32 - here instead of using map I can use
31:35 - replace and if I run this then now we
31:38 - can see that it's basically the exact
31:41 - same result here except now we actually
31:44 - have it didn't replace John within na in
31:47 - value and again everything that we've
31:50 - done here doesn't actually change the
31:52 - data frame if we wanted to set this to
31:55 - the actual column then we would have to
31:58 - do something like this we could say that
32:00 - that DF first column is equal to that
32:04 - replaced version of the data frame so if
32:06 - I run this and then I looked at our
32:08 - entire data frame then now we can see
32:11 - that those values were substituted okay
32:13 - so now that we've looked at a lot of
32:14 - different ways of updating information
32:17 - in our rows and columns now let's go
32:19 - over to our larger data set and look at
32:21 - some real-world examples of how we can
32:23 - apply what we've learned here so let me
32:25 - go over to my Stack Overflow survey data
32:28 - here so we have our Stack Overflow
32:30 - survey notebook open here that we've
32:33 - been using throughout this series and
32:35 - again if you'd like to download these
32:37 - notebooks or the Stack Overflow data in
32:39 - order to follow along then the links for
32:41 - all this are in the description section
32:43 - below
32:43 - ok so let's apply some of what we
32:46 - learned here to this data set so in the
32:48 - last video where we covered filtering we
32:50 - looked at filtering salaries over a
32:53 - certain amount and the column name for
32:55 - salary it is over here somewhere it is
32:59 - this one here converted comp now I'm
33:02 - assuming that short for converted
33:04 - compensation and that is converted to
33:06 - United States dollars so let's say that
33:09 - we wanted to rename that column to where
33:11 - it was a bit more clear so instead I'm
33:14 - going to rename this column to salary
33:16 - USD instead of converted comp
33:20 - so if we remember from earlier in the
33:21 - video we can do this with the rename
33:24 - method so if I come down here then I can
33:27 - say D F dot rename and then we can just
33:31 - pass in the columns that we want to
33:33 - rename so I'll pass in a dictionary here
33:36 - but this is only going to have one value
33:37 - so we want to change converted comp and
33:41 - we want to set that to I'll call this
33:43 - salary USD so if I run this then let me
33:49 - go over here and see if this looks good
33:52 - okay so that looks good
33:54 - that changed now after you make sure
33:56 - that it made the change that you wanted
33:58 - it to make and that it's not a mistake
34:00 - then we can actually apply that to our
34:03 - data frame by setting in place is equal
34:06 - to true now that's why in place equal to
34:09 - true is actually a good idea because
34:12 - sometimes you know when you're working
34:15 - in pandas we're always doing these
34:17 - different types of renames and filters
34:20 - and things like that and sometimes we're
34:22 - going to do things wrong so it's always
34:24 - better to check and make sure that it
34:26 - made the change that you meant to make
34:27 - first and then apply that change to your
34:31 - data frame to actually make the solidify
34:33 - those changes so now let's see if we
34:37 - have access to that salary USD column
34:41 - and if I look at that then we can see
34:43 - that we do have a salary USD column in
34:45 - this data frame so that change did work
34:47 - okay so what is something else that we
34:50 - can do here to see what we have already
34:55 - learned ok so here's an example here so
34:58 - we've looked at this hobbyist column a
35:01 - few times in this series this is a
35:03 - column where people answered on the
35:05 - survey whether they code as a hobby in
35:08 - their free time and let's look at this
35:11 - column real quick we can kind of see it
35:12 - here it has a bunch of yes yes no values
35:15 - let me actually print this out down here
35:18 - so I will access that hobbyist column
35:21 - and we can see that this is a bunch of
35:23 - yes/no values here so let's say that we
35:26 - wanted to convert these values and map
35:28 - all of the yes responses to a true
35:31 - boolean value and
35:33 - he knows to false so how would we do
35:36 - this well one way that we could do this
35:38 - is with the map method that we just
35:40 - learned about so what we could do is we
35:43 - could say DF hobbiest dot map and then
35:49 - pass in a dictionary here of the
35:52 - substitutions that we want to make so
35:54 - for the yes values I will convert this
35:56 - to a boolean of true and for the no
36:00 - values I will convert this to a boolean
36:02 - of false so if I run this then if we
36:06 - compare the results that we got up here
36:08 - and the results that we're getting down
36:10 - here we can see that all the yeses are
36:12 - mapped to true and all the noes are
36:14 - mapped to false now I don't believe
36:17 - there's actually an in-place argument
36:19 - for map so what we can do here is we can
36:24 - just set that series and set that equal
36:29 - to the mapped version of that series so
36:33 - now if I run this and look at our data
36:36 - frame now we can see that that entire
36:39 - column is now true false values instead
36:41 - of yes/no values now remember when we
36:44 - use map than anything that isn't in our
36:48 - dictionary here so anything outside of a
36:50 - yes or no answer would be converted to
36:53 - an na n value I think there are other
36:56 - columns in this survey where there are
36:58 - yes/no and not sure answers or something
37:02 - like that so if we only wanted to
37:05 - replace the yes-or-no values and leave
37:07 - the others untouched then instead we
37:10 - could use the replace method instead but
37:14 - map works for this example because I
37:16 - know that this column only has yes and
37:18 - no okay so that is a quick review of
37:22 - some of what we learned in this video
37:23 - I'm not going to go over everything
37:25 - again since this video is already
37:27 - getting a little long but I did want to
37:30 - show you some examples of how updating
37:32 - values works when and how this can be
37:35 - applied to real-world data like this
37:38 - survey okay so before we end here I
37:40 - would like to mention that we do have a
37:43 - sponsor for this video and that sponsor
37:45 - is brilliant
37:46 - org so in this series we've been
37:49 - learning about pandas and how to analyze
37:50 - data and python and brilliant would be
37:53 - an excellent way to supplement what you
37:54 - learn here with their hands-on courses
37:56 - they have some excellent courses and
37:58 - lessons that do a deep dive on how to
37:59 - think about and analyze data correctly
38:01 - for data analysis fundamentals I would
38:04 - really recommend checking out their
38:05 - statistics course which shows you how to
38:07 - analyze graphs and determine
38:08 - significance in the data and I would
38:10 - also recommend their machine learning
38:12 - course which takes data analysis to a
38:14 - new level well you'll learn about the
38:16 - techniques being used that allow
38:17 - machines to make decisions where there's
38:19 - just too many variables for a human to
38:21 - consider so to support my channel and
38:23 - learn more about brilliant you can go to
38:25 - brilliant org Forge slash CMS to sign up
38:28 - for free and also the first 200 people
38:30 - they go to that link will get 20% off
38:32 - the annual premium subscription and you
38:35 - can find that link in the description
38:36 - section below
38:37 - again that's brilliant org forge slash
38:40 - CMS ok so I think that's going to do it
38:44 - for this panda svitavy contains in
38:53 - specific spots and then going a little
38:55 - more advanced when we learned about
38:56 - apply map and apply map now I know that
39:00 - those can be confusing to some people
39:02 - but hopefully you feel like you got an
39:04 - understanding of how each of those work
39:06 - now originally I was also going to show
39:09 - how to add and remove rows and columns
39:11 - in this video but this is getting a bit
39:14 - long so I'm just going to save that for
39:16 - our next video so in the next video
39:18 - we'll learn how to add and remove rows
39:20 - and columns from our data frame and that
39:22 - should be a much shorter video but if
39:25 - anyone has any questions about what we
39:26 - covered in this video then feel free to
39:28 - ask in the comment section below and
39:29 - I'll do my best to answer those and if
39:31 - you enjoy these tutorials and would like
39:32 - to support them then there are several
39:34 - ways you can do that the easiest ways to
39:36 - simply like the video and give it a
39:37 - thumbs up and it's always a huge help to
39:39 - share these videos with anyone who you
39:41 - think would find them useful and if you
39:42 - have the means you can contribute
39:43 - through patreon and there's a link to
39:45 - that page and at scripts in section
39:46 - below be sure to subscribe for future
39:48 - videos and thank you all for watching
39:51 - you
40:00 - you

Cleaned transcript:

hey there how's it going everybody in this video we're going to be learning how to alter existing rows and columns in our data frames so in the last video we learned how to filter out specific information and we can use those techniques here to also modify our data so we'll learn how to update the data for our rows and our columns and in the next video we'll also learn how to add and remove rows and columns from our data frames now I'd like to mention that we do have a sponsor for this series of videos and that is brilliant org so I really want to thank brilliant for sponsoring this series and it would be great if you all can check them out using the link in the description section below and support the sponsors and I'll talk more about their services and just a bit so with that said let's go ahead and get started ok so let's look at how to update data within our rows and columns the last couple of videos we've already seen how we can filter specific data but now let's take a look at those same concepts and use them to make changes to our data so let's look at updating columns first and then we'll update some rows so I currently have my snippets file open here that we've seen in previous videos so that we can see what this looks like on a smaller data set before seeing how to do this on our larger data set with that stackoverflow Survey data now before we modify the columns let's take a look at these first using the columns attribute that we've seen in previous videos so let me add a new cell here down at the bottom we can look at the columns just by saying DF . columns and we can see that we just have three columns here so our column names are first last and email so let's say that we wanted to update the columns to be a little more specific so let's say that I wanted this to be first name instead of first so there's a couple of ways that we can do this so first if we want to rename all of the columns then we can simply do an assignment using the columns attribute that I just used so in order to do this I could just use an assignment here and just pass in a list so I could just pass in a list of all the different columns that I want these to be so I'll call this first name last name and I'll just keep email the same so if I run this let's now look at these columns again and now we can see that those column names have changed and if I actually look at the data frame here then they show up changed in the data frame as well now I almost never use this because this is used for when you're passing in different names for all of your columns I usually only need to change the names of a few different columns now one thing that is a lot more common is the need to change something specific about each column in our data frame so for example maybe your columns are all uppercase and you want them to be lowercase or vice versa or maybe your columns your column names have spaces and you want to replace the spaces in the column names with an underscore in this case we can use a list comprehension so for example let's say that I wanted to uppercase all of the column names here so in order to do this I could use a list comprehension and I could just say DF columns is equal to and now we'll just say like X dot upper for X in DF columns so if I print out that data frame after making that change then we can see that now all of our column names have been translated to uppercase now another thing that you might want to do is remove spaces and replace them with underscores especially if you like using the dot notation to access a column name that doesn't work if there are you know spaces in the column name because that's just not correct syntax so if you wanted to replace spaces with underscores instead then what you could do is just do something similar here and say DF columns is equal to DF dot columns dot STR we're using the STR method on this columns series here and then we can use the replace method from that string class so I can just pass in a space and say that we want to replace all those spaces with underscores now this isn't going to make any changes in our specific data frame because all of ours already have underscores if I reverse this and I did an underscore and then a space then we can see that now we replaced all those underscores with spaces that's probably not what you want though I would rather have underscores instead of spaces so if we do it this way then that's how you replace all of those but let me go ahead and set these columns back to the way that they were before I like lowercase so I'm going to change those back to lowercase there and now everything that we've seen so far applies to every one of our columns but what if we only wanted to change some columns well in this case we can use the rename method and just pass in a dictionary of the columns that we want to change so if I want to set the first name and last name back to what they were before then I could say D F dot rename and now we can just pass in the columns and we're going to pass in a dictionary of what we want here so the key is going to be the old value so I'll set first name back to first so the value is going to be the new value for that column name so we're going to map first name to first and then I will map last name here to last so I just have to put that in as a value there and now if I run this now then it might look like it worked but if I look at my data frame then those changes actually didn't go through this is another one of those methods where if we actually want that place to or if we want that change to take place then we have to say in place is equal to true because it'll just let us kind of see what it would look like if it worked but it's not actually going to change it so saying in place equals to true we'll make that change go through so now if I rerun this again then we can see that those column names are set back to the way that they were okay so that's a quick look at updating our columns now let's take a look at updating the data in our rows and we'll spend the majority of video learning how to update data in our rows since there's so much more that we can do here so first let's look at how to update a single value now in the previous video we saw how we can look up values using loke and I'll oak and we'll use that as our starting point for setting values as well so let's grab the row for John Doe right here it's row number two let's grab that and change his last name to Smith so in order to grab that row we can simply grab that row with the index label too so we can say D F dot Lok of 2 if I run that then we can see that we get that row of first name John last name doe and if you wanted to use a conditional like we saw in the last video to grab that row then that's definitely possible you can do that as well now we could have said you know give me rows where the first name is equal to John and the last name is equal to dou if we wanted to do that as a conditional so now in order to update this information there are a couple ways that we can do this we can just pass in all of the new values for this row by passing in a list so I could just say that this row I want to set this equal to and then pass in all the new values so I'll say that I want to keep John the same I want his last name to be equal to Smith and then let's also change his email as well so John Smith at email com so if I run this and then we look at our data frame then we can see that now that last row has a new last name and a new email address now what if we had a lot of columns but we only wanted to change a couple of values so imagine you know with our survey data we have 85 different columns so it would be a pain if we wanted to change a single row and we had to pass in it or a single column and we had to pass in this huge list of 85 different values you know that would really suck to need to pass in that entire list just to change those couple of values so in this case we can just specify the exact columns using lok and again we saw this before when learning how to use the lok to filter data so if I wanted to just change the last name and email then first let's just grab those specific values so I can say D F dot Lok and then I can pass in a 2 for the rows then if you remember that we can also pass in a list as the second value here for the columns that we want so I'll say that I want the last and I want the email so if I run this then we can see that we just get the last name and we just get the email and now we can change this as well you using the same method that we used here above but we don't need to pass in this the values that are staying the same so I don't need to pass in that John value anymore since we're not changing that so let's change this back to dough just to make sure that this worked so John Doe at email com so now if I run this that should have made the assignment and now if I look at our data frame then we can see that those were set back so now we have John Doe and John Doe at email comm ok and finally here now let's just look at how to change a single value you might be able to guess how it be done but what we can do is just pass in a single row in a single column and just change that value we don't need to pass in a list so just to change that one value I will copy this line here but now I don't want a list of these columns let's just change the last name so this won't be a list anymore now I'm just saying that I want Row two the column of last and we'll just set that equal to Smith whoops let me put that in the string there so if I run that then we look at our data frame then we can see that it only changed that one value now pandas does have another indexer called @ and this is specifically meant for changing or looking up a single value now honestly I just used dot lok from these most of the time but the option is there if you want it I'm assuming it's there for performance reasons so if I wanted to change this back since this is just a single value then instead of using dot Lok then I could all you also use dot @ so I'll do this exact same assignment here and I'll change this back to doe but instead of dot Lok I'm gonna say dot @ and let's just set that back and then if I look at the data frame then we can see that that worked as well and I'll be honest here I'll have to look at the documentation I'm not really sure why we would use dot @ instead of dot lok when we only need to get or set a single value maybe it's for performance reasons but I personally find myself using lok and i lok even for single values i actually did look it up in the pandas documentation but all it says there is that it's there and that it's similar to dot Lok it doesn't provide any actual justification as to why we'd use it but I wanted you know that it's available since it's awfully obviously there for a reason and hasn't been deprecated yet okay so now let me show you one mistake that is very common and that is when people try to change a value without using one of these indexers without using dot lok or dot @ so let me show you what this error or this warning would look like so let's say that we have a large data frame where we want to find this John Doe person and changed their last name to Smith so one way that we could do this is to use a filter to grab that specific row so I will come down here to the bottom and I'll just create a filter here and I will say that the email column of the data frame equals equals John Doe at email com that is the filter that we're looking for so if I apply this filter to my data frame just you passing it in directly to the brackets like this then we saw in the last video whoops and this is filt not filter since filter is a builtin Python keyword so if I pass in that filt variable there directly into the brackets again we saw this in the last video if I run this then we can see that that works for looking up these values so that actually returned a data frame there that just has a single row so we could grab that last name column just by accessing that last name from that data frame that was returned so if I run this then that works as well we can see that we got that doe value and finally you might think that in order to change this last name to Smith that we could just come up here and say okay we got that value now I want to set that equal to Smith so if I run this then you can see that this big warning pops up here and if we look at this warning it says that we get this setting with copy warning okay so we got warning but did it actually make that change to our data frame so let's look at our data frame here okay so we tried to change that last name to Smith I've know we know we've been going back and forth between these last names here but it was doe and then we tried to change it to Smith and that did not work so it didn't make that change when we did the assignment this way now the reason that it didn't work here is a little complicated essentially it's because the way that we're doing it here requires multiple operations in the background which can determine whether pandas returns a view or a copy of our data frame so when our value isn't getting set it's because it's getting set on a temporary object that's just getting tossed out immediately after so pandas does a lot better job of explaining this a specific warning and they have a little link here down to the documentation directly within the warning itself so if you want to learn more about this then you can just click on that warning or go to this link and it explains it in a lot more detail but the moral of the story here is that when you're setting values just use dot lok or the dot at indexers that we've already seen and you shouldn't have any problems so we could rerun this same operation up here at the top and actually let me just copy this so that if anybody I will put this notebook out here on after I'm done with this and if people want to see this exact error then I will leave that cell there so we could rerun this exact same operation but instead of using these brackets directly here I can just say D F dot Lok and then I want to apply those filters to my rows and then I want to grab the last name column as well so if I run it this way instead and then we look at our data frame then we can see that that tit changed did go through so we were able to apply that filter and then set that last name equal to Smith in that data frame so if you ever get these warnings like this that just popup then definitely don't ignore them because you know in this case it didn't even actually set the value that we thought that we were setting so you really need to be careful with stuff like that okay so that's how we would update a single row of data but how would we update multiple rows of data well there's a couple of different ways that we could do this so for our for our first example let's just assume that we want to change all of the email addresses so that they are lowercase so this might be something that you want to do to make the email addresses easier to search so to do this we could just assign that column to the lowercase value of itself so first let me grab those lowercase values and to do this we could just say DF and then we could access that email column and then that's going to return a series and then we can just use this dot STR class on the series and use the lower method on that string class so if I run this then we can see what this returns is a lowercase version of all these emails if I look up here in the original data frame then these have mixed casing in there and now these are all lowercase now this just returns the lowercase values of these emails it didn't actually make that change now in order to make that change we can simply assign that column to this value so what I could do here is I could just say DF email is equal to DF e mail dot string dot lowercase so if I run this and then we look at our data frame now those changes actually did go through and all of our emails are now lowercase so that's one way that we can change multiple rows at once but maybe we want to do something a little more advanced so there are several ways that we can do this and we'll go over all four popular methods in order to do this and a lot of people get these four methods confused so let's go over each one individually and try to explain them in detail and there's definitely a good reason why people get these confused because they're very similar in what they do so the four methods that I'm going to be talking about are apply and map and apply map and replace whoops let me spell that correctly place so first let's take a look at apply so apply is used for calling a function on our values and apply can work on either a data frame or a series object and the behavior might be a little different than you expect for each of those different objects so first let's look at how apply works for a series so when we use this on a series it can apply a function to every value in our series so for example let's say that I want to see the length of all of our email addresses maybe we have a website and we want to make sure that none of the email addresses are too long or something like that so I can apply the L en the length function to each value in our series by doing something like this I can say DF and access that email column and then I can say dot apply Lin so we'll apply that Lin function and when I run that what we can see what it's doing here is it saying okay the Lin of the first row email addresses was 23 so I've never actually counted up the characters in my email address but it's telling me it's 23 and then this one says it's 17 and then it says this one is 17 so that's a quick little way that we can use apply to grab some information about our data but we can also use this to update values as well so in this example I'm just going to create a simple function that returns the uppercase version of our email but the function can be as complicated as you want it to be so let me write a simple function here that does what I want it to do so I'm gonna say let's say I'll call this function update email and this will take in an email value here and then I'll just return that email in uppercase so email dot upper so let me run this now again this is a super basic example here if I really wanted to uppercase the email addresses then I would just do the same thing that we did before when we made them lowercase but I just am using this as an example here so when we apply functions it's usually to do some more advanced updates than what we're doing here but let's apply this function to our email column so to do this we could say DF and access that email column dot apply and then we can pass in that update email function that we just wrote now we don't want to execute this function so you don't want to put parentheses here you just want to pass in the function without parentheses so that we're passing in the function itself and not an executed version of itself okay so let me run this cell and we can see that now we're getting back a series here of our email addresses in uppercase now if this doesn't actually change our values or change our rows like we saw before so to do this we can just assign that to our column so I can just take what we wrote here and then I can just set that series equal to that series with that applied function so if I run that and then we look at our data frame then we can see that now our email addresses are all uppercase now again this was a pretty simple function here all we did was return this email dot upper now for simple function so for simple functions like this you might see people use lambda functions as well now if you're not familiar with lambda functions basically they are anonymous functions with a specific name or without a specific name that we can use for things like this so here's what it would look like in this example so let's say that I wanted to convert these back to lowercase so what I could do is I will just grab this here now I'm going to use a pass n a lambda function here to dot apply instead of passing in that other function that we wrote so I'll say lambda and the synth if you're not familiar with Landa functions then the syntax can be a little weird here but basically we just have a noname function here and then what we want to return so I want to return X dot lower of that argument that we get passed in so if I run that and then look at our data frame again then now we can see that we have the lowercase version of our email so if you're more comfortable writing regular functions then you can do it this way but if you are comfortable writing lambda functions and your function isn't too complicated then you can always do it this way like we did here now we're working with strings here but you can also use this with numbers where we can run any type of calculations that we want as well okay so this is how apply works on series objects so now let's look at how apply works with data frames so far we've only been using this with a series so anytime we access a column like this that returns a series and again when we ran apply on the series it ran a function on all of the values in that series now when we run apply on a data frame it runs a function on each row or column of that data frame so let's see what this looks like and it should make more sense so let me grab the example of above where we ran the Len function right here and let me copy this and paste this down here and then we'll take a look at what this looks like when a data frame so again what this gave us was the length of each value in that email series so you might think that you can run this same apply method on the entire data frame and it will give us the length of each value in the data frame but that's not what it does so let's see what that gives us so instead of accessing a specific column let's just say DF not apply and pass in that Lin function so if I run this then we get this response that you might not expect so what's going on here is that it's not applying the length function to every value in the data frame it's actually applying the length function to each series in the data frame specifically the columns so basically what this is telling us is that our first name column has a length of 3 so if we look up here at first we can see that first has three values it's telling us that last has three values and email has three values so that's just the number of rows in each column and we can get that same result for a specific series if we manually check the length of one of these so if I was to say Lin access one of these columns and ran this then we can see that gives us three so that's basically what apply is doing here on the data frame but it's doing it for every column and you can also have this apply to rows as well if you change the axis so we can change the axis here and say no I want to do this on the rows whoops and I put row I meant to put rows so if I run this oh and I made another mistake here I actually didn't mean to put rows roses the default I meant to put columns so if I put columns then we can see that now we get three as well but now what it's doing here is it's counting it this way so it's saying okay one or row zero has three values but it's saying okay those values are Corrie Schafer and then the email it's not counting it downward so basically we want to use functions that will make sense to be used on a series object when using a ply on an entire data frame so for example let's say that we wanted to grab the minimum value from each column well series objects have a min method so we could pass that in to apply and see the minimum value for each series now in our sample data frame we have all string values so if we grab the minimum value from a series of strings then it'll just return the one the first one in alphabetical order so let's see what this would look like so we can come down here and we can say D F dot apply and now let me pass in that series men method so I could say P D is what we imported pandas eyes P D series dot min so if I run this then we can see okay it's saying that the one that comes first in the alphabet in the first category is quarry the one that comes first and the last names is doe so that is you know that's a d these two are s's that make sense and then my email comes before these other two emails now it probably would have been better to take a look at this using a series of numerical data instead because with numerical data this stuff you know obviously makes more sense so if we used series dot min on numerical data that would obviously give us the minimum values for each of those numbers and we can use lambda functions with this as well but you just have to remember that the lambda will be working on a series object so if I come down here I can say D F dot apply and now let's pass in a lambda now this X here this X is going to be a series it's not going to be a value so what methods do a series have well a series has a min method so let's return the minimum value and run that and we can see that that gives us the same response that this one up here gave us now like I said this is kind of a contrived example because we could get these same results by using the data frames min method but I just wanted to point out how this actually works so this is way more useful when your data frame contains numerical data so for example we could use numpy to apply the square root for all of our series objects or any type of numerical analysis like that okay so running apply on a series applies a function to every value in the series and running apply to a data frame like we did here applies a function to every series in the data frame but you might be wondering if there's a way that we can apply a function to every individual element in the data frame and that's what apply map is used for an apply map only works on data frames series objects don't have the apply map method so let me show you how this is different so again let's use that same builtin length function and pass that in to apply map so I'll say D F dot apply map and now let's pass in that builtin length function so if I run this then we can see that what this does is that it's now applying that length function to each individual value in our data frame so the firstname had these many characters so first name mine was Cory so Co re Y that's five characters and then Jane and then John so those are four characters and we saw the length of the emails before three 1717 so that's what this is doing here it's applying that function to every individual element of our data frame so this might be how some of you expected the apply method to work on a data frame but instead we use apply map for this now I know that this can be a bit confusing but hopefully after seeing those differences it makes a little bit more sense of when we would want to use which so for example since we have an entire data frame full of strings in this example if I wanted all of them to be lowercase then I could just do something like this I could say D F dot apply map and then I can just pass in the string dot lower method so if I run this then we can see that now all of the values in that data frame are lowercase now if you had numerical data in your data frame then you would get an error here since you can't run string methods on numbers so you need to pass in a more complicated function that handles that appropriately ok so now we've looked at apply and apply map and hopefully those make more sense to you now so now let's look at the map method now the map method only works on a series so map is used for substituting each value in a series with another value so for example let's say that we wanted to substitute a couple of our first names so to do this I could say DF and access that first name column which is also a series and then I can use the map method on this and now I'm going to pass in a dictionary of the values that we want to substitute so let's say instead of quarry I want to pass in Chris and instead of Jane I wanted to pass in a value of Mary so if I run this then we can see that that returns a series where those first names were substituted out so quarry was the first value here and now it's Chris Jane it was is now Mary now one thing that I do want to point out here is that the values that we didn't substitute were converted to in a in values not a number of values now that may or may not be what we want and I'll show an example of this when we look at some realworld Stack Overflow examples now in this example we likely wouldn't want to get rid of these other names so you might be thinking okay well what if I wanted to keep John but just substitute these other names so if that's the case then instead of using map we can instead use the replace method so instead of doing what we did here I'll just copy this paste this in here instead of using map I can use replace and if I run this then now we can see that it's basically the exact same result here except now we actually have it didn't replace John within na in value and again everything that we've done here doesn't actually change the data frame if we wanted to set this to the actual column then we would have to do something like this we could say that that DF first column is equal to that replaced version of the data frame so if I run this and then I looked at our entire data frame then now we can see that those values were substituted okay so now that we've looked at a lot of different ways of updating information in our rows and columns now let's go over to our larger data set and look at some realworld examples of how we can apply what we've learned here so let me go over to my Stack Overflow survey data here so we have our Stack Overflow survey notebook open here that we've been using throughout this series and again if you'd like to download these notebooks or the Stack Overflow data in order to follow along then the links for all this are in the description section below ok so let's apply some of what we learned here to this data set so in the last video where we covered filtering we looked at filtering salaries over a certain amount and the column name for salary it is over here somewhere it is this one here converted comp now I'm assuming that short for converted compensation and that is converted to United States dollars so let's say that we wanted to rename that column to where it was a bit more clear so instead I'm going to rename this column to salary USD instead of converted comp so if we remember from earlier in the video we can do this with the rename method so if I come down here then I can say D F dot rename and then we can just pass in the columns that we want to rename so I'll pass in a dictionary here but this is only going to have one value so we want to change converted comp and we want to set that to I'll call this salary USD so if I run this then let me go over here and see if this looks good okay so that looks good that changed now after you make sure that it made the change that you wanted it to make and that it's not a mistake then we can actually apply that to our data frame by setting in place is equal to true now that's why in place equal to true is actually a good idea because sometimes you know when you're working in pandas we're always doing these different types of renames and filters and things like that and sometimes we're going to do things wrong so it's always better to check and make sure that it made the change that you meant to make first and then apply that change to your data frame to actually make the solidify those changes so now let's see if we have access to that salary USD column and if I look at that then we can see that we do have a salary USD column in this data frame so that change did work okay so what is something else that we can do here to see what we have already learned ok so here's an example here so we've looked at this hobbyist column a few times in this series this is a column where people answered on the survey whether they code as a hobby in their free time and let's look at this column real quick we can kind of see it here it has a bunch of yes yes no values let me actually print this out down here so I will access that hobbyist column and we can see that this is a bunch of yes/no values here so let's say that we wanted to convert these values and map all of the yes responses to a true boolean value and he knows to false so how would we do this well one way that we could do this is with the map method that we just learned about so what we could do is we could say DF hobbiest dot map and then pass in a dictionary here of the substitutions that we want to make so for the yes values I will convert this to a boolean of true and for the no values I will convert this to a boolean of false so if I run this then if we compare the results that we got up here and the results that we're getting down here we can see that all the yeses are mapped to true and all the noes are mapped to false now I don't believe there's actually an inplace argument for map so what we can do here is we can just set that series and set that equal to the mapped version of that series so now if I run this and look at our data frame now we can see that that entire column is now true false values instead of yes/no values now remember when we use map than anything that isn't in our dictionary here so anything outside of a yes or no answer would be converted to an na n value I think there are other columns in this survey where there are yes/no and not sure answers or something like that so if we only wanted to replace the yesorno values and leave the others untouched then instead we could use the replace method instead but map works for this example because I know that this column only has yes and no okay so that is a quick review of some of what we learned in this video I'm not going to go over everything again since this video is already getting a little long but I did want to show you some examples of how updating values works when and how this can be applied to realworld data like this survey okay so before we end here I would like to mention that we do have a sponsor for this video and that sponsor is brilliant org so in this series we've been learning about pandas and how to analyze data and python and brilliant would be an excellent way to supplement what you learn here with their handson courses they have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly for data analysis fundamentals I would really recommend checking out their statistics course which shows you how to analyze graphs and determine significance in the data and I would also recommend their machine learning course which takes data analysis to a new level well you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider so to support my channel and learn more about brilliant you can go to brilliant org Forge slash CMS to sign up for free and also the first 200 people they go to that link will get 20% off the annual premium subscription and you can find that link in the description section below again that's brilliant org forge slash CMS ok so I think that's going to do it for this panda svitavy contains in specific spots and then going a little more advanced when we learned about apply map and apply map now I know that those can be confusing to some people but hopefully you feel like you got an understanding of how each of those work now originally I was also going to show how to add and remove rows and columns in this video but this is getting a bit long so I'm just going to save that for our next video so in the next video we'll learn how to add and remove rows and columns from our data frame and that should be a much shorter video but if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest ways to simply like the video and give it a thumbs up and it's always a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page and at scripts in section below be sure to subscribe for future videos and thank you all for watching you you
