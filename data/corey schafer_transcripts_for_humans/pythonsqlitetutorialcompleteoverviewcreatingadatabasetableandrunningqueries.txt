With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're going to be learning
00:02 - how to work with SQL light now as filo
00:05 - light is extremely useful when you need
00:06 - some database functionality and don't
00:08 - want to spin up a full-fledged database
00:10 - like my sequel or Postgres so you can
00:13 - use SQL Lite for small to medium sized
00:15 - applications where your database is just
00:17 - going to live on disk or you can use it
00:19 - for testing and prototyping out an
00:22 - application and if you have the need to
00:23 - move up to a larger database then you
00:25 - can later port that over and SQL Lite is
00:28 - actually part of the standard library so
00:30 - there's no need to even install anything
00:32 - and we can just start working with it
00:33 - right out of the box and it's extremely
00:35 - easy to use because your database can
00:37 - just be a simple file or it can even be
00:39 - an in-memory database that just lives in
00:42 - RAM now one thing I want to point out is
00:44 - that this video is just going to focus
00:45 - on using SQL Lite and not how to program
00:48 - the SQL language itself so I'm going to
00:50 - assume that anyone watching this video
00:52 - has some basic knowledge of SQL and if
00:54 - you don't know SQL then I do have a
00:56 - short series on getting started with the
00:58 - basics okay so let's go ahead and get
01:00 - started so first of all I have some
01:02 - sample code here so that we have
01:03 - something to work with when creating our
01:05 - SQL Lite database now this sample code
01:08 - is from my object-oriented series and if
01:10 - you don't know how to use classes or
01:12 - what this code is doing then don't
01:13 - really worry about that you don't have
01:15 - to understand it for this video it's
01:17 - just going to be something that we can
01:18 - add to our database and actually have
01:20 - two files here in our current directory
01:22 - one of these is the employee PI module
01:25 - that contains our employee class that
01:27 - we're looking at right now and the other
01:29 - file here is called SQLite demo and
01:32 - that's where we're going to learn how to
01:33 - use SQLite so if I open up that SQLite
01:36 - demo then we just have a blank script
01:39 - here so right now let's not worry about
01:40 - the employee class and instead just jump
01:42 - right into working with SQL Lite let's
01:45 - say that we want to create an
01:46 - application where we have employees and
01:48 - we want to be able to add update and
01:50 - delete employees from our database as
01:53 - well as being able to grab employee
01:55 - information from that database so in
01:57 - order to prototype out this application
01:59 - let's use SQL Lite so this is in the
02:02 - standard library so we can just go ahead
02:03 - and import this without installing
02:05 - anything so we can say import SQL Lite 3
02:08 - and there's only one L there and now we
02:11 - need a connection object that represents
02:13 - our data
02:13 - so I'll go ahead and create a variable
02:15 - here named Khan and set that equal to
02:18 - SQL light 3 dot Connect now within the
02:23 - connect method here we can either pass
02:25 - in a file where we want to store our
02:27 - data or we can even make an end memory
02:29 - database do an in-memory database we'll
02:32 - have a string here and say : memory and
02:35 - another : so that's how you would do an
02:37 - in-memory database but for our example
02:39 - we're going to instead use a file name
02:41 - and for this file name we're going to
02:44 - call this employee dot DB so now with
02:48 - just these two lines of code if I go
02:50 - ahead and run this then I know that the
02:52 - files in my directory here are a little
02:54 - small for you to see but it did create
02:56 - this employee dot DB file here in our
02:59 - directory now I want to point out that
03:00 - if you're following along with me and
03:02 - you're using sublime text like I'm using
03:04 - then I believe sublime text hides these
03:06 - dot DB files by default and I have
03:09 - unhidden that on my machine so if you
03:11 - don't see that then you might not want
03:13 - to actually check the file system
03:14 - because that files most likely there
03:17 - even if you don't see it within sublime
03:19 - text
03:19 - now that dot DB file isn't something
03:21 - you'll be able to open up and understand
03:24 - it'll look just kind of like gibberish
03:26 - if we look at the contents of that file
03:28 - but sequel Lite knows what to do with it
03:30 - and that's all that matters so when we
03:32 - run that connect method it creates that
03:34 - file even if it doesn't exist and if it
03:36 - does exist then it just connects so I
03:39 - can go ahead and run this code again and
03:41 - you can see that we didn't get any
03:42 - errors anything even though that
03:44 - employee dot DB file already exists ok
03:47 - so now that we have a connection let's
03:49 - create a cursor which allows us to
03:52 - execute some SQL commands so to create a
03:55 - cursor then we can just create a
03:57 - variable here and I'm just going to call
03:59 - this variable C and I'm going to set
04:01 - this equal to Khan for our connection
04:03 - dot cursor now that we have a cursor we
04:07 - can start running SQL commands using the
04:10 - execute method so we know that we want
04:13 - an employee's table so let's go ahead
04:15 - and create that so let's create an
04:17 - employee table that holds an employee's
04:20 - first-name lastname and pay so to do
04:23 - this we'll do C for the cursor that we
04:26 - created C
04:27 - dot execute and then the SQL command
04:31 - that we want to run so we'll say create
04:34 - now one thing to point out here is that
04:36 - I'm wrapping this SQL and three quotes
04:39 - on each side and if you're not familiar
04:41 - that is called a docstring and it's
04:43 - going to allow us to write a string
04:45 - that's multiple lines without any
04:47 - special breaks or anything like that
04:49 - some people like to do this differently
04:51 - than using the doc strings but this is
04:54 - how they do it in the Python
04:55 - documentation so I'd say that it's fun
04:57 - and when I'll write a statement that's
04:59 - just a single line then I'm just going
05:01 - to use the regular quotes for a string
05:03 - and not the doc string so just in case
05:05 - you are wondering what I was doing there
05:07 - so anyways the command that we want to
05:09 - run is create table and we want to
05:12 - create an employee's table and now let's
05:14 - put in some parentheses here and specify
05:17 - our columns so our first column we want
05:21 - to be the first name so we'll just call
05:24 - that column first and now we want to
05:26 - give this column a data type so SQL Lite
05:30 - has different data types than what you
05:32 - might be used to with other databases
05:34 - and there's not very many of them here
05:36 - and I have the data types page pulled up
05:39 - here in the documentation and you can
05:41 - see here under section 2 that there are
05:44 - basically five different ones to work
05:46 - with here so we have null integer real
05:49 - text and blob so for our first name
05:53 - column we're going to use text and for
05:56 - the last name column we're going to use
05:58 - text and then for the pay we could
06:00 - choose either real which is a floating
06:02 - point value or an integer and I think
06:05 - I'm going to go ahead and just use an
06:06 - integer even though that doesn't give us
06:08 - decimal point values so with that said
06:10 - let's go ahead and set these so we want
06:12 - first equal to text and then we want a
06:17 - last for the last name we want to set
06:20 - that as a txt also and then we also want
06:23 - a pay column and to pay let's set that
06:26 - as an integer now I'm going to go ahead
06:28 - and actually indent this over to be even
06:31 - with that and save that so now that we
06:34 - have our SQL statement to create our
06:36 - table now let's do a couple more things
06:38 - before actually running this and what I
06:40 - want to do here
06:41 - as I want to do a con for the connection
06:44 - not commit now realize there that I'm
06:47 - doing a connection not commit and not
06:50 - the C for the cursor so this commits the
06:53 - current transaction and it's easy to
06:55 - forget this step a lot of people leave
06:57 - that out so if you aren't seeing
06:59 - something in the database that you think
07:01 - should be there and make sure that
07:02 - you're committing your changes and also
07:04 - at the end here it's a good practice to
07:06 - close the connection to the database and
07:09 - we can do that with a con dot close so
07:12 - now let's go ahead and execute all of
07:14 - this code and we didn't get any errors
07:17 - when we ran that so that's good so that
07:19 - created our employees table and that
07:21 - will be obvious if we try to run this
07:24 - code again
07:24 - because if I try to run this code again
07:26 - now you can see that this time we did
07:28 - get an error and if we look at the error
07:31 - here it's saying that the table
07:33 - employees already exist so that's good
07:36 - so with that little bit of code we're
07:38 - already able to interact with the
07:40 - database we didn't have to install
07:42 - anything or start any servers or
07:44 - anything like that
07:44 - so let's comment out that line where we
07:47 - create our employees table and start
07:50 - adding some data to this database so now
07:54 - that we have that table let's add an
07:56 - employee to that database and for now
07:58 - let's just go ahead and type this in
08:00 - instead of using our sample employee
08:02 - class that I showed you earlier so above
08:05 - our commit statement here let's say C
08:09 - for our cursor C not execute now I'm
08:13 - just going to use regular single quotes
08:14 - because this will fit on one line I'm
08:16 - just going to say insert into employees
08:20 - values and now I want to fill in those
08:22 - that first column last column and pay
08:25 - column so I'll do the name as Cori and a
08:30 - comma last name as Schaffer and for pay
08:33 - I'll just make up 50,000 there so now if
08:37 - I run this code then we didn't get any
08:39 - error so that's good and to the best of
08:41 - our knowledge that data was inserted
08:43 - into our employee database but let's
08:46 - find out let's go ahead and find out by
08:48 - querying the database for that employee
08:50 - so to do this we're going to execute a
08:52 - select statement so I'll comment
08:55 - out this insert statement here and now
08:59 - let's create our select statement so at
09:02 - first I'm just going to hard-code in of
09:04 - what we're looking for and I'll do that
09:06 - by saying C dot execute and now we're
09:09 - going to type in our sequel command so
09:12 - I'll so I'll say select star from
09:15 - employees and I'll put in a where clause
09:18 - here to find that employee so I'll say
09:20 - where last equals Schaeffer and save
09:24 - that now that select statement is going
09:26 - to provide some results that we can
09:28 - iterate through so to iterate through
09:30 - that query result then we can use a few
09:34 - different methods here so we have C dot
09:37 - fetch one and what that will do is it
09:42 - will get the next row and our results
09:44 - and only return that row and if there's
09:48 - no more rows available then it just
09:50 - returns none so we have fetch one we
09:53 - also have fetch many and this takes an
09:56 - argument of a number so say you said
09:58 - fetch many five so what that will do is
10:01 - it will return that number of rows as a
10:04 - list and if there are no more rows
10:06 - available then it will just return an
10:08 - empty list and lastly we have fetch all
10:12 - that doesn't take any arguments and what
10:15 - that will do is it will get the
10:16 - remaining rows that are left and return
10:19 - those as a list and if there's no more
10:21 - rows then it will return an empty list
10:22 - so for our example here let's just say
10:25 - fetch one because it should only be one
10:27 - result and actually let's go ahead and
10:30 - print out that fetch one and save that
10:33 - so now if we run this then we can see
10:36 - that it returned our one entry that we
10:39 - inserted into the database and if it
10:41 - can't find any results so for example if
10:43 - I change this last name here to Smith
10:46 - instead and rerun that then you can see
10:49 - that fetch one just returned none
10:51 - because it didn't find any results so
10:54 - now I'm going to go ahead and change
10:55 - that back to the way that we had it and
10:58 - rerun that so you can see that fetch one
11:00 - just gave us that one result that one
11:03 - row if we instead did a fetch all which
11:07 - we talked about earlier now if I run
11:08 - that
11:09 - we still only have one result but now
11:11 - it's within a list so now is add one
11:14 - more employee by rerunning our insert
11:17 - statement here with some different
11:19 - values so instead I'll say Mary and I'll
11:23 - keep the last name the same and I'll
11:25 - just put 70,000 there now I believe that
11:27 - when we run our select statement here
11:29 - that it would do an auto commit of our
11:31 - insert above but just to be explicit
11:34 - let's go ahead and put a commit here so
11:37 - I'll do a con not commit and then after
11:40 - we commit that insert then it will run
11:41 - this select and since both of these
11:44 - employees have the same last name and it
11:46 - should get both of those with that
11:47 - select so if I run this and now you can
11:50 - see that our list from fetch all now has
11:53 - those two entries that have found okay
11:56 - and just so we don't insert any more
11:58 - values into our database right now I'm
12:00 - going to comment out this insert
12:02 - statement here so right now we have
12:05 - typed in the values that we are
12:07 - searching for directly into our select
12:10 - statements but the way you'll most
12:12 - likely be using this in Python is that
12:15 - you'll have some Python variables and
12:16 - you want to put the value from those
12:18 - variables into your query so to see an
12:20 - example of this let's start using that
12:22 - employee class that we looked at before
12:25 - and like I said if you don't know what
12:27 - this code is doing then don't worry too
12:28 - much about it this class just allows us
12:31 - to create employees and when we create
12:33 - an employee it comes in and it sets the
12:36 - first name last name and pay and the
12:40 - email and full name use those variables
12:42 - to create those attributes but we aren't
12:45 - going to use those in this example so
12:47 - now let's switch back to our sequel Lite
12:49 - demo here and I'm going to import that
12:52 - employee class and I can do this because
12:55 - that employee module is in the same
12:57 - directory as the script that we're
13:00 - currently in so I can just say from
13:02 - employee import that employee class and
13:06 - I'm going to spelled that there so I'll
13:08 - take that out so now above my insert
13:10 - statement here I can create a couple of
13:13 - instances of this class so for example I
13:15 - can say employee 1 is equal to employee
13:19 - and then I can pass in values for
13:22 - first last and pay so I'll just say John
13:25 - Doe and for the pay I'll say eighty
13:30 - thousand and now let me copy this and
13:32 - make a second instance of this class so
13:35 - I'll call this employee to and this will
13:38 - be Jane Doe and we'll do 90 there and we
13:41 - can access those first last and pay
13:44 - attributes by saying so we could do a
13:46 - print and I'll do the first one here
13:49 - I'll do print employee dot first and
13:52 - that will get the first name attribute
13:54 - of that instance and to get the others I
13:57 - could say dot last and hey so if I run
14:01 - that then you can see that it did print
14:03 - out the first name last name and pay of
14:06 - that instance and the extra print
14:08 - statement there is just the results of
14:10 - our select query and we still have that
14:11 - print statement in down there so
14:13 - currently these two new employees that
14:16 - we created or just Python objects and we
14:19 - haven't inserted them into our database
14:20 - yet so how would we do this so first
14:24 - let's add John Doe to the database now
14:27 - you might be tempted to do this using
14:29 - stream formatting and let me show you an
14:31 - example of what I mean here I'm going to
14:33 - take out these print statements real
14:34 - quick and I'm going to uncomment out
14:36 - this insert statement so let's say that
14:38 - with this insert statement we instead
14:41 - want to insert all those values from
14:43 - employee one and like I said you'll
14:45 - probably be tempted to use string
14:47 - formatting now you probably see me use
14:49 - string more formatting and my videos
14:50 - before but if you're not familiar with
14:52 - it then basically we're using braces as
14:55 - placeholders so instead of hard-coding
14:57 - these values in i'll put braces instead
15:00 - for each of these and then we can use
15:06 - the format method to populate those
15:09 - placeholders so for the first
15:11 - placeholder we want we want employee one
15:14 - dot first for the second one we want
15:16 - employee one last and for that last
15:19 - placeholder we want employee one dot pay
15:21 - now if you have seen this before and if
15:23 - you use string formatting a lot this is
15:25 - actually a bad practice when using
15:27 - databases in python and that this is the
15:30 - case for just about any database that
15:32 - you decide to use if you are accepting
15:34 - any values from
15:36 - user so say from like a website or
15:38 - something like that for example then
15:40 - this is vulnerable to SQL injection
15:43 - attacks and basically all that means is
15:45 - that there are values that I could set
15:48 - these variables equal to that could
15:50 - break the entire database and the reason
15:52 - for that is because it's not properly
15:54 - escaped so let me show you the correct
15:56 - way to do this and there's actually two
16:00 - different ways and I'll show you both
16:01 - ways here so the first way to do this is
16:04 - instead of using our regular brace
16:06 - placeholders here we can instead use
16:09 - question marks and this is a DB API
16:12 - placeholder and you also no longer need
16:15 - the quotes there to specify that it's a
16:18 - string because it will know that by the
16:19 - values that we pass in so I'm just going
16:22 - to do three question marks here as our
16:24 - placeholders and now I'm going to first
16:27 - I'm going to go ahead and copy these
16:28 - values and now I'm going to totally get
16:30 - rid of the dot format and instead what
16:33 - we're going to do is we're going to pass
16:34 - in another argument to this execute
16:37 - method so I'll just put in a comma there
16:39 - and for the second argument I'll pass in
16:42 - a tuple of all the values so I'll put a
16:46 - tuple passing all those values now one
16:48 - thing that I do want to note here is
16:50 - that even if you're only passing in one
16:53 - value into a placeholder you still need
16:55 - to put it within a tuple which can look
16:58 - a little strange and I'll show you how
17:00 - that looks when we run our select
17:02 - statement in just a second so I'm not
17:04 - going to run this quite yet I'm going to
17:05 - show you the second way that we can use
17:07 - the second proper way to use these
17:09 - placeholders so I'm going to do another
17:11 - insert statement for our second employee
17:15 - here Jane Doe and this second way of
17:17 - doing the proper placeholders is my
17:19 - personal favorite so instead of these
17:21 - question marks we're instead going to
17:23 - put a colon and a name describing the
17:26 - placeholder so for example I'll do colon
17:29 - first and colon last and then colon pay
17:34 - and now we're still passing in a second
17:37 - argument to the execute method but
17:39 - instead of a tuple it's going to be a
17:41 - dictionary and the dictionary keys are
17:44 - going to be the names of each of these
17:46 - placeholders in our SQL and the values
17:49 - will be what
17:50 - we want those placeholders to be so in
17:52 - this example this would be like I said
17:55 - this will be a dictionary now
17:56 - and now our keys will be all of these
17:59 - values that we want to fill in and the
18:02 - values of those dictionaries will be
18:05 - what we want those keys to be equal to
18:08 - or what we want those placeholders to be
18:10 - equal to so first so let me go ahead and
18:12 - copy this a couple of times so now I
18:16 - also want this to fill in that last
18:19 - placeholder and we want that to be not
18:21 - last and we want to fill in that pay
18:23 - placeholder so we'll do that pay and now
18:27 - we wanted to insert the second employee
18:30 - here so instead of employee one this is
18:32 - going to be employed - now this line is
18:35 - getting a little long here so if you
18:36 - wanted to break this up onto another
18:38 - line you could I think I'm just going to
18:40 - leave it the way it is for now now even
18:42 - though this one is longer the reason
18:44 - that I like this method of doing the
18:46 - placeholders is because when you only
18:48 - have one placeholder value I think it's
18:51 - a lot more readable and we'll look at
18:53 - that when we run our select ment
18:54 - statements but for now let's go ahead
18:56 - and run this code and get these
18:59 - employees added to our database I'm
19:01 - going to go ahead and run that and we're
19:03 - still printing out the Select statement
19:05 - from before but now I'm going to go
19:07 - ahead and comment out these insert
19:10 - statements so now for this select
19:12 - statement instead of searching for the
19:14 - last name of Schafer
19:15 - let's also run a select statement that
19:17 - searches for the last name of DOE and
19:20 - we'll go ahead and use both methods of
19:22 - using placeholders just like we did just
19:24 - so that we can get the hang of how to
19:26 - use both of those and how they both look
19:28 - so instead of hard-coding in Schaefer
19:32 - here I'll instead use the question mark
19:35 - placeholder that we use before so I'll
19:37 - say last equals question mark and now
19:41 - the value that I want for that will just
19:44 - be the string Schafer and like I said
19:46 - this is one value so we still have to
19:48 - make it a tuple so we have to put a
19:50 - comma here within those parentheses to
19:53 - turn that into a tuple now that's why I
19:54 - said that the question mark approach
19:56 - looks a little strange with one value
19:58 - because you still have to put it inside
20:00 - a tuple and that comma is needed or else
20:03 - you'll get in
20:03 - err and I've just always thought that it
20:05 - looks a little strange okay so using the
20:08 - other approach so I'm going to go ahead
20:09 - and copy this these lines here and we'll
20:15 - do another select statement below but
20:18 - now we're going to use that other
20:19 - placeholder approach and we'll do
20:21 - another select searching for the last
20:23 - name of dough so to do that we can say
20:26 - where last is equal to : last and now
20:30 - the way that we fill out this second
20:31 - argument is it's a dictionary and we
20:34 - want to say that use this key last which
20:37 - code is going to fill in that
20:38 - placeholder and we say that we want to
20:40 - search for the value of dough and like I
20:43 - said I think that this is a little more
20:45 - readable because even with the one value
20:48 - it's a little more obvious that we're
20:50 - saying okay we want this last
20:52 - placeholder here to have the value of
20:55 - dough so now if I go ahead and run the
20:58 - code that we have now then you can see
21:01 - that our fetch all after the first query
21:04 - gave us the two entries that we added
21:07 - earlier in the video and the fetch all
21:09 - after the second query gave us the
21:12 - values that we added using the instances
21:14 - of our employee class up here okay so
21:17 - we're just about finished up but let me
21:19 - show you one more thing here that I
21:21 - think you'll find useful in working with
21:23 - SQL Lite before I said that when we
21:27 - first make our connection up here at the
21:29 - top you can actually set this connection
21:31 - equal to memory and the way that we do
21:34 - that again is I'm going to go ahead and
21:36 - fill this in it's a : memory and then
21:39 - another : now what that's going to do is
21:41 - it will give us a database that lives
21:44 - and ran and that's useful for testing if
21:46 - you want a fresh clean database on every
21:49 - run so for example now I can uncomment
21:52 - out my create table here and also I'm
21:56 - going to uncomment out these insert
21:58 - statements so now if I run this code
22:00 - then you can see that we didn't get any
22:03 - errors and that's because it starts
22:05 - completely fresh so every time it
22:08 - creates this table and inserts these
22:11 - employees from scratch and you can just
22:13 - run this multiple times and not get any
22:16 - errors
22:17 - like you know the table already exists
22:19 - or anything like that and it also want
22:21 - won't insert multiple values since it
22:23 - starts fresh every time so I'll go ahead
22:24 - and rerun this again
22:26 - and you can see that we got the same
22:27 - result now since this did start from
22:29 - scratch one of our select statements
22:32 - here isn't returning any values because
22:34 - we overrode those insert statements from
22:36 - earlier so there are no longer any
22:39 - employees with the last name Schafer so
22:41 - the end memory database is nice when
22:43 - you're testing and you don't want to
22:44 - keep deleting a database file over and
22:47 - over and over it just automatically
22:49 - gives you a fresh slate and when you're
22:51 - ready then you can just pass in a file
22:53 - and then your database will be stored
22:55 - just like we did earlier in the video so
22:57 - with our database and memory let's
22:59 - quickly prototype out a basic
23:00 - application where we use our created
23:02 - table to insert select update and delete
23:06 - employees from a database just so we can
23:08 - tie everything together and also show
23:10 - you a little trick when we do this to
23:11 - make our executions more pythonic so to
23:14 - do this I'm going to create four
23:16 - functions here right above where we
23:19 - create our employees and just so you
23:21 - don't have to watch me type these out
23:23 - I'm actually going to grab these from my
23:25 - snippets here so I'm going to copy these
23:27 - over and I'm going to paste these right
23:28 - above our creative employees so we're
23:31 - going to have some very simple functions
23:33 - here where we're going to be able to
23:34 - insert employees to the database get an
23:37 - employee by their name update and
23:40 - employees pay and delete an employee so
23:43 - for the insert employees function I'm
23:45 - going to copy and paste one of our
23:48 - insertions from down here and just
23:50 - modify it slightly so I'll copy this
23:53 - second insertion here and put it in here
23:56 - now instead of inserting this exact
23:58 - instance now I'm going to insert the
24:01 - employee that we pass here into this
24:03 - function which is EMP and here's a
24:06 - little tip for making your SQL Lite code
24:08 - a bit more pythonic it's kind of a pain
24:10 - that we need to remember to commit these
24:12 - after every insert update or delete now
24:15 - if you know about contacts managers
24:16 - using the with statement then you might
24:19 - be wondering if there's a way that we
24:21 - can use these with SQL Lite and there is
24:23 - so if you don't know about context
24:25 - managers basically they're a way for us
24:27 - to manage a setup and teardown of
24:29 - resources
24:30 - automatically it's common to see these
24:32 - when using things like files also
24:34 - because people don't want to remember to
24:36 - close files every time they open one and
24:38 - with SQL Lite connection objects can be
24:41 - used as context managers that
24:42 - automatically commit or rollback
24:44 - transactions so transactions will
24:46 - automatically be committed unless
24:48 - there's an exception and then it will
24:50 - automatically be rolled back so to do
24:53 - this with SQLite we can say with con
24:56 - which is our connection and then within
24:59 - this block we just want to put our
25:01 - execute statement and now since we're
25:03 - executing it this insertion from within
25:05 - our context manager we no longer have
25:07 - the need for a commit statement after
25:09 - this so now this is done so now for our
25:13 - get employee by name function let's grab
25:16 - our select statement from down here
25:18 - towards the bottom and I'll just grab
25:20 - this one here and paste that in now
25:23 - instead of searching specifically for
25:25 - the last name of though let's instead
25:27 - search for the last name that's passed
25:29 - here into this function which is this
25:31 - last name variable so I'll remove dough
25:34 - and search for that last name that gets
25:36 - passed into that function now our select
25:38 - statements never needed to be committed
25:40 - so this doesn't need to be within a
25:41 - context manager like our inserts updates
25:44 - and deletes now if we wanted to return
25:47 - just one employee then we could do a
25:49 - fetch one but let's go ahead and return
25:52 - all of the employees with this last name
25:54 - so we'll say return C dot fetch all so
26:00 - now I think we're kind of getting the
26:02 - hang of how this works so instead of
26:04 - watching me type in the rest of these
26:06 - functions I'm going to go ahead and just
26:08 - grab these completed functions here from
26:10 - our snippets and I'm going to go ahead
26:12 - and paste these in here now just a quick
26:15 - look at what our functions are doing
26:16 - here
26:17 - this update pay function takes in an
26:19 - employee and a pay and we are using a
26:22 - context manager here since we're
26:23 - executing an update statement and we're
26:25 - basically just setting the employees pay
26:28 - where their first name and last name
26:30 - equal the first name and last name of
26:33 - the employee that we pass in and for our
26:35 - remove employee here we're using a
26:37 - context manager again since we're
26:39 - executing a delete statement and we're
26:41 - just deleting an employee where the
26:43 - first-name and
26:44 - last name equal the first name and last
26:46 - name of the employee we pass in so now
26:48 - let's delete all of the code from
26:49 - earlier and instead use these new
26:51 - functions so I'm going to keep the
26:53 - employees that we create there now I'm
26:55 - going to delete everything except where
26:57 - we close our connection so now I can
26:59 - insert both of these employees into the
27:01 - database just by using our new insert
27:03 - employee function so I'll insert the
27:06 - first employee and then I'll copy that
27:08 - and I'll insert the second employee and
27:10 - save that and now just like earlier
27:12 - let's grab all of the employees with the
27:14 - last name of those so I'll say employees
27:17 - equal get employees by name and we'll
27:21 - cert we'll pass in no for that name and
27:24 - then we will just go ahead and print
27:26 - those employee results so let's go ahead
27:30 - and run this and see if this is working
27:31 - up to this point okay so we got both of
27:33 - our employees that we inserted so now
27:36 - let's update the pay of one of our
27:38 - employees so we'll we'll set so I'll do
27:40 - an update pay and we'll set employee
27:43 - two's pay - let's just say 95 thousand
27:47 - and last thing let's also delete an
27:49 - employee so we will use our remove
27:52 - employ function and we'll remove
27:53 - employee one and now let's rerun that
27:57 - same get employees by name after we do
28:01 - all these updates and deletions and save
28:03 - that so now if I run this then we can
28:06 - see that the second time we print the
28:08 - results that John Doe has been removed
28:12 - and Jane those pay was updated to 95
28:15 - thousand so that kind of gives you an
28:17 - idea for how you can use these functions
28:19 - to do this work for you so that you
28:21 - don't have to keep writing these same
28:24 - statements over and over so I think
28:26 - that's going to do it for this video
28:27 - hopefully now you have a pretty good
28:29 - idea for how you can get up and running
28:31 - with SQLite now there's plenty more to
28:33 - do with SQLite that we didn't cover in
28:34 - this video such as doing bulk inserts
28:37 - and things like that
28:38 - so definitely give it a look once you
28:40 - have everything from this video down
28:41 - then picking those skills up will be
28:43 - easy now another great thing about
28:45 - SQLite is that it also works with SQL
28:47 - alchemy now if you don't know what SQL
28:49 - alchemy is it's a popular ORM for Python
28:52 - it that abstract away a lot of
28:53 - differences between databases and I'll
28:56 - probably be doing a video on that and
28:57 - the
28:58 - as well but you could use SQL alchemy
29:00 - with SQL light to get everything
29:02 - prototype doubt in your application and
29:04 - when you're ready you could easily just
29:06 - replace that with a Postgres or my
29:08 - sequel database without changing hardly
29:10 - any of the code so if anyone has any
29:12 - questions about what we covered in this
29:14 - video then feel free to ask in the
29:15 - comment section below and I'll do my
29:16 - best to answer those now if you enjoy
29:18 - these tutorials and would like to
29:19 - support them then there are some ways
29:21 - you can do that the easiest way is to
29:22 - simply like the video and give it a
29:24 - thumbs up and also it's a huge help to
29:25 - share these videos with anyone who you
29:27 - think would find them useful and if you
29:28 - have the means you can contribute
29:30 - through patreon and there's a link to
29:31 - that page in the description section
29:32 - below be sure to subscribe for future
29:34 - videos and thank you all for watching
29:47 - you

Cleaned transcript:

hey there how's it going everybody in this video we're going to be learning how to work with SQL light now as filo light is extremely useful when you need some database functionality and don't want to spin up a fullfledged database like my sequel or Postgres so you can use SQL Lite for small to medium sized applications where your database is just going to live on disk or you can use it for testing and prototyping out an application and if you have the need to move up to a larger database then you can later port that over and SQL Lite is actually part of the standard library so there's no need to even install anything and we can just start working with it right out of the box and it's extremely easy to use because your database can just be a simple file or it can even be an inmemory database that just lives in RAM now one thing I want to point out is that this video is just going to focus on using SQL Lite and not how to program the SQL language itself so I'm going to assume that anyone watching this video has some basic knowledge of SQL and if you don't know SQL then I do have a short series on getting started with the basics okay so let's go ahead and get started so first of all I have some sample code here so that we have something to work with when creating our SQL Lite database now this sample code is from my objectoriented series and if you don't know how to use classes or what this code is doing then don't really worry about that you don't have to understand it for this video it's just going to be something that we can add to our database and actually have two files here in our current directory one of these is the employee PI module that contains our employee class that we're looking at right now and the other file here is called SQLite demo and that's where we're going to learn how to use SQLite so if I open up that SQLite demo then we just have a blank script here so right now let's not worry about the employee class and instead just jump right into working with SQL Lite let's say that we want to create an application where we have employees and we want to be able to add update and delete employees from our database as well as being able to grab employee information from that database so in order to prototype out this application let's use SQL Lite so this is in the standard library so we can just go ahead and import this without installing anything so we can say import SQL Lite 3 and there's only one L there and now we need a connection object that represents our data so I'll go ahead and create a variable here named Khan and set that equal to SQL light 3 dot Connect now within the connect method here we can either pass in a file where we want to store our data or we can even make an end memory database do an inmemory database we'll have a string here and say memory and another so that's how you would do an inmemory database but for our example we're going to instead use a file name and for this file name we're going to call this employee dot DB so now with just these two lines of code if I go ahead and run this then I know that the files in my directory here are a little small for you to see but it did create this employee dot DB file here in our directory now I want to point out that if you're following along with me and you're using sublime text like I'm using then I believe sublime text hides these dot DB files by default and I have unhidden that on my machine so if you don't see that then you might not want to actually check the file system because that files most likely there even if you don't see it within sublime text now that dot DB file isn't something you'll be able to open up and understand it'll look just kind of like gibberish if we look at the contents of that file but sequel Lite knows what to do with it and that's all that matters so when we run that connect method it creates that file even if it doesn't exist and if it does exist then it just connects so I can go ahead and run this code again and you can see that we didn't get any errors anything even though that employee dot DB file already exists ok so now that we have a connection let's create a cursor which allows us to execute some SQL commands so to create a cursor then we can just create a variable here and I'm just going to call this variable C and I'm going to set this equal to Khan for our connection dot cursor now that we have a cursor we can start running SQL commands using the execute method so we know that we want an employee's table so let's go ahead and create that so let's create an employee table that holds an employee's firstname lastname and pay so to do this we'll do C for the cursor that we created C dot execute and then the SQL command that we want to run so we'll say create now one thing to point out here is that I'm wrapping this SQL and three quotes on each side and if you're not familiar that is called a docstring and it's going to allow us to write a string that's multiple lines without any special breaks or anything like that some people like to do this differently than using the doc strings but this is how they do it in the Python documentation so I'd say that it's fun and when I'll write a statement that's just a single line then I'm just going to use the regular quotes for a string and not the doc string so just in case you are wondering what I was doing there so anyways the command that we want to run is create table and we want to create an employee's table and now let's put in some parentheses here and specify our columns so our first column we want to be the first name so we'll just call that column first and now we want to give this column a data type so SQL Lite has different data types than what you might be used to with other databases and there's not very many of them here and I have the data types page pulled up here in the documentation and you can see here under section 2 that there are basically five different ones to work with here so we have null integer real text and blob so for our first name column we're going to use text and for the last name column we're going to use text and then for the pay we could choose either real which is a floating point value or an integer and I think I'm going to go ahead and just use an integer even though that doesn't give us decimal point values so with that said let's go ahead and set these so we want first equal to text and then we want a last for the last name we want to set that as a txt also and then we also want a pay column and to pay let's set that as an integer now I'm going to go ahead and actually indent this over to be even with that and save that so now that we have our SQL statement to create our table now let's do a couple more things before actually running this and what I want to do here as I want to do a con for the connection not commit now realize there that I'm doing a connection not commit and not the C for the cursor so this commits the current transaction and it's easy to forget this step a lot of people leave that out so if you aren't seeing something in the database that you think should be there and make sure that you're committing your changes and also at the end here it's a good practice to close the connection to the database and we can do that with a con dot close so now let's go ahead and execute all of this code and we didn't get any errors when we ran that so that's good so that created our employees table and that will be obvious if we try to run this code again because if I try to run this code again now you can see that this time we did get an error and if we look at the error here it's saying that the table employees already exist so that's good so with that little bit of code we're already able to interact with the database we didn't have to install anything or start any servers or anything like that so let's comment out that line where we create our employees table and start adding some data to this database so now that we have that table let's add an employee to that database and for now let's just go ahead and type this in instead of using our sample employee class that I showed you earlier so above our commit statement here let's say C for our cursor C not execute now I'm just going to use regular single quotes because this will fit on one line I'm just going to say insert into employees values and now I want to fill in those that first column last column and pay column so I'll do the name as Cori and a comma last name as Schaffer and for pay I'll just make up 50,000 there so now if I run this code then we didn't get any error so that's good and to the best of our knowledge that data was inserted into our employee database but let's find out let's go ahead and find out by querying the database for that employee so to do this we're going to execute a select statement so I'll comment out this insert statement here and now let's create our select statement so at first I'm just going to hardcode in of what we're looking for and I'll do that by saying C dot execute and now we're going to type in our sequel command so I'll so I'll say select star from employees and I'll put in a where clause here to find that employee so I'll say where last equals Schaeffer and save that now that select statement is going to provide some results that we can iterate through so to iterate through that query result then we can use a few different methods here so we have C dot fetch one and what that will do is it will get the next row and our results and only return that row and if there's no more rows available then it just returns none so we have fetch one we also have fetch many and this takes an argument of a number so say you said fetch many five so what that will do is it will return that number of rows as a list and if there are no more rows available then it will just return an empty list and lastly we have fetch all that doesn't take any arguments and what that will do is it will get the remaining rows that are left and return those as a list and if there's no more rows then it will return an empty list so for our example here let's just say fetch one because it should only be one result and actually let's go ahead and print out that fetch one and save that so now if we run this then we can see that it returned our one entry that we inserted into the database and if it can't find any results so for example if I change this last name here to Smith instead and rerun that then you can see that fetch one just returned none because it didn't find any results so now I'm going to go ahead and change that back to the way that we had it and rerun that so you can see that fetch one just gave us that one result that one row if we instead did a fetch all which we talked about earlier now if I run that we still only have one result but now it's within a list so now is add one more employee by rerunning our insert statement here with some different values so instead I'll say Mary and I'll keep the last name the same and I'll just put 70,000 there now I believe that when we run our select statement here that it would do an auto commit of our insert above but just to be explicit let's go ahead and put a commit here so I'll do a con not commit and then after we commit that insert then it will run this select and since both of these employees have the same last name and it should get both of those with that select so if I run this and now you can see that our list from fetch all now has those two entries that have found okay and just so we don't insert any more values into our database right now I'm going to comment out this insert statement here so right now we have typed in the values that we are searching for directly into our select statements but the way you'll most likely be using this in Python is that you'll have some Python variables and you want to put the value from those variables into your query so to see an example of this let's start using that employee class that we looked at before and like I said if you don't know what this code is doing then don't worry too much about it this class just allows us to create employees and when we create an employee it comes in and it sets the first name last name and pay and the email and full name use those variables to create those attributes but we aren't going to use those in this example so now let's switch back to our sequel Lite demo here and I'm going to import that employee class and I can do this because that employee module is in the same directory as the script that we're currently in so I can just say from employee import that employee class and I'm going to spelled that there so I'll take that out so now above my insert statement here I can create a couple of instances of this class so for example I can say employee 1 is equal to employee and then I can pass in values for first last and pay so I'll just say John Doe and for the pay I'll say eighty thousand and now let me copy this and make a second instance of this class so I'll call this employee to and this will be Jane Doe and we'll do 90 there and we can access those first last and pay attributes by saying so we could do a print and I'll do the first one here I'll do print employee dot first and that will get the first name attribute of that instance and to get the others I could say dot last and hey so if I run that then you can see that it did print out the first name last name and pay of that instance and the extra print statement there is just the results of our select query and we still have that print statement in down there so currently these two new employees that we created or just Python objects and we haven't inserted them into our database yet so how would we do this so first let's add John Doe to the database now you might be tempted to do this using stream formatting and let me show you an example of what I mean here I'm going to take out these print statements real quick and I'm going to uncomment out this insert statement so let's say that with this insert statement we instead want to insert all those values from employee one and like I said you'll probably be tempted to use string formatting now you probably see me use string more formatting and my videos before but if you're not familiar with it then basically we're using braces as placeholders so instead of hardcoding these values in i'll put braces instead for each of these and then we can use the format method to populate those placeholders so for the first placeholder we want we want employee one dot first for the second one we want employee one last and for that last placeholder we want employee one dot pay now if you have seen this before and if you use string formatting a lot this is actually a bad practice when using databases in python and that this is the case for just about any database that you decide to use if you are accepting any values from user so say from like a website or something like that for example then this is vulnerable to SQL injection attacks and basically all that means is that there are values that I could set these variables equal to that could break the entire database and the reason for that is because it's not properly escaped so let me show you the correct way to do this and there's actually two different ways and I'll show you both ways here so the first way to do this is instead of using our regular brace placeholders here we can instead use question marks and this is a DB API placeholder and you also no longer need the quotes there to specify that it's a string because it will know that by the values that we pass in so I'm just going to do three question marks here as our placeholders and now I'm going to first I'm going to go ahead and copy these values and now I'm going to totally get rid of the dot format and instead what we're going to do is we're going to pass in another argument to this execute method so I'll just put in a comma there and for the second argument I'll pass in a tuple of all the values so I'll put a tuple passing all those values now one thing that I do want to note here is that even if you're only passing in one value into a placeholder you still need to put it within a tuple which can look a little strange and I'll show you how that looks when we run our select statement in just a second so I'm not going to run this quite yet I'm going to show you the second way that we can use the second proper way to use these placeholders so I'm going to do another insert statement for our second employee here Jane Doe and this second way of doing the proper placeholders is my personal favorite so instead of these question marks we're instead going to put a colon and a name describing the placeholder so for example I'll do colon first and colon last and then colon pay and now we're still passing in a second argument to the execute method but instead of a tuple it's going to be a dictionary and the dictionary keys are going to be the names of each of these placeholders in our SQL and the values will be what we want those placeholders to be so in this example this would be like I said this will be a dictionary now and now our keys will be all of these values that we want to fill in and the values of those dictionaries will be what we want those keys to be equal to or what we want those placeholders to be equal to so first so let me go ahead and copy this a couple of times so now I also want this to fill in that last placeholder and we want that to be not last and we want to fill in that pay placeholder so we'll do that pay and now we wanted to insert the second employee here so instead of employee one this is going to be employed now this line is getting a little long here so if you wanted to break this up onto another line you could I think I'm just going to leave it the way it is for now now even though this one is longer the reason that I like this method of doing the placeholders is because when you only have one placeholder value I think it's a lot more readable and we'll look at that when we run our select ment statements but for now let's go ahead and run this code and get these employees added to our database I'm going to go ahead and run that and we're still printing out the Select statement from before but now I'm going to go ahead and comment out these insert statements so now for this select statement instead of searching for the last name of Schafer let's also run a select statement that searches for the last name of DOE and we'll go ahead and use both methods of using placeholders just like we did just so that we can get the hang of how to use both of those and how they both look so instead of hardcoding in Schaefer here I'll instead use the question mark placeholder that we use before so I'll say last equals question mark and now the value that I want for that will just be the string Schafer and like I said this is one value so we still have to make it a tuple so we have to put a comma here within those parentheses to turn that into a tuple now that's why I said that the question mark approach looks a little strange with one value because you still have to put it inside a tuple and that comma is needed or else you'll get in err and I've just always thought that it looks a little strange okay so using the other approach so I'm going to go ahead and copy this these lines here and we'll do another select statement below but now we're going to use that other placeholder approach and we'll do another select searching for the last name of dough so to do that we can say where last is equal to last and now the way that we fill out this second argument is it's a dictionary and we want to say that use this key last which code is going to fill in that placeholder and we say that we want to search for the value of dough and like I said I think that this is a little more readable because even with the one value it's a little more obvious that we're saying okay we want this last placeholder here to have the value of dough so now if I go ahead and run the code that we have now then you can see that our fetch all after the first query gave us the two entries that we added earlier in the video and the fetch all after the second query gave us the values that we added using the instances of our employee class up here okay so we're just about finished up but let me show you one more thing here that I think you'll find useful in working with SQL Lite before I said that when we first make our connection up here at the top you can actually set this connection equal to memory and the way that we do that again is I'm going to go ahead and fill this in it's a memory and then another now what that's going to do is it will give us a database that lives and ran and that's useful for testing if you want a fresh clean database on every run so for example now I can uncomment out my create table here and also I'm going to uncomment out these insert statements so now if I run this code then you can see that we didn't get any errors and that's because it starts completely fresh so every time it creates this table and inserts these employees from scratch and you can just run this multiple times and not get any errors like you know the table already exists or anything like that and it also want won't insert multiple values since it starts fresh every time so I'll go ahead and rerun this again and you can see that we got the same result now since this did start from scratch one of our select statements here isn't returning any values because we overrode those insert statements from earlier so there are no longer any employees with the last name Schafer so the end memory database is nice when you're testing and you don't want to keep deleting a database file over and over and over it just automatically gives you a fresh slate and when you're ready then you can just pass in a file and then your database will be stored just like we did earlier in the video so with our database and memory let's quickly prototype out a basic application where we use our created table to insert select update and delete employees from a database just so we can tie everything together and also show you a little trick when we do this to make our executions more pythonic so to do this I'm going to create four functions here right above where we create our employees and just so you don't have to watch me type these out I'm actually going to grab these from my snippets here so I'm going to copy these over and I'm going to paste these right above our creative employees so we're going to have some very simple functions here where we're going to be able to insert employees to the database get an employee by their name update and employees pay and delete an employee so for the insert employees function I'm going to copy and paste one of our insertions from down here and just modify it slightly so I'll copy this second insertion here and put it in here now instead of inserting this exact instance now I'm going to insert the employee that we pass here into this function which is EMP and here's a little tip for making your SQL Lite code a bit more pythonic it's kind of a pain that we need to remember to commit these after every insert update or delete now if you know about contacts managers using the with statement then you might be wondering if there's a way that we can use these with SQL Lite and there is so if you don't know about context managers basically they're a way for us to manage a setup and teardown of resources automatically it's common to see these when using things like files also because people don't want to remember to close files every time they open one and with SQL Lite connection objects can be used as context managers that automatically commit or rollback transactions so transactions will automatically be committed unless there's an exception and then it will automatically be rolled back so to do this with SQLite we can say with con which is our connection and then within this block we just want to put our execute statement and now since we're executing it this insertion from within our context manager we no longer have the need for a commit statement after this so now this is done so now for our get employee by name function let's grab our select statement from down here towards the bottom and I'll just grab this one here and paste that in now instead of searching specifically for the last name of though let's instead search for the last name that's passed here into this function which is this last name variable so I'll remove dough and search for that last name that gets passed into that function now our select statements never needed to be committed so this doesn't need to be within a context manager like our inserts updates and deletes now if we wanted to return just one employee then we could do a fetch one but let's go ahead and return all of the employees with this last name so we'll say return C dot fetch all so now I think we're kind of getting the hang of how this works so instead of watching me type in the rest of these functions I'm going to go ahead and just grab these completed functions here from our snippets and I'm going to go ahead and paste these in here now just a quick look at what our functions are doing here this update pay function takes in an employee and a pay and we are using a context manager here since we're executing an update statement and we're basically just setting the employees pay where their first name and last name equal the first name and last name of the employee that we pass in and for our remove employee here we're using a context manager again since we're executing a delete statement and we're just deleting an employee where the firstname and last name equal the first name and last name of the employee we pass in so now let's delete all of the code from earlier and instead use these new functions so I'm going to keep the employees that we create there now I'm going to delete everything except where we close our connection so now I can insert both of these employees into the database just by using our new insert employee function so I'll insert the first employee and then I'll copy that and I'll insert the second employee and save that and now just like earlier let's grab all of the employees with the last name of those so I'll say employees equal get employees by name and we'll cert we'll pass in no for that name and then we will just go ahead and print those employee results so let's go ahead and run this and see if this is working up to this point okay so we got both of our employees that we inserted so now let's update the pay of one of our employees so we'll we'll set so I'll do an update pay and we'll set employee two's pay let's just say 95 thousand and last thing let's also delete an employee so we will use our remove employ function and we'll remove employee one and now let's rerun that same get employees by name after we do all these updates and deletions and save that so now if I run this then we can see that the second time we print the results that John Doe has been removed and Jane those pay was updated to 95 thousand so that kind of gives you an idea for how you can use these functions to do this work for you so that you don't have to keep writing these same statements over and over so I think that's going to do it for this video hopefully now you have a pretty good idea for how you can get up and running with SQLite now there's plenty more to do with SQLite that we didn't cover in this video such as doing bulk inserts and things like that so definitely give it a look once you have everything from this video down then picking those skills up will be easy now another great thing about SQLite is that it also works with SQL alchemy now if you don't know what SQL alchemy is it's a popular ORM for Python it that abstract away a lot of differences between databases and I'll probably be doing a video on that and the as well but you could use SQL alchemy with SQL light to get everything prototype doubt in your application and when you're ready you could easily just replace that with a Postgres or my sequel database without changing hardly any of the code so if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those now if you enjoy these tutorials and would like to support them then there are some ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
