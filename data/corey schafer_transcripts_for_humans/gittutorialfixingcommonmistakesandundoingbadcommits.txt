With timestamps:

00:00 - hey how's it going everybody in this
00:02 - video we're going to be looking at a few
00:03 - common scenarios in git where you can
00:06 - find yourself needing to undo some
00:08 - mistakes or even roll back some bad
00:11 - commits um now some of these commands
00:13 - will change the git history and some
00:15 - will not and we're going to take a look
00:17 - at exactly what that means here in a
00:19 - second now this will be a slightly more
00:21 - advanced git walkthr and uh we're going
00:24 - to assume that you already know the
00:26 - basic uh command line functionality of
00:28 - git um if you aren't familiar with basic
00:31 - git commands or how git works I do have
00:33 - a video on getting started with Git in
00:35 - the command line if you would like to
00:37 - watch that video first but with that
00:39 - said let's go ahead and get started uh
00:42 - so let's take a look at the sample
00:44 - repository that I have set up here so if
00:46 - I do an ls- LA within this directory you
00:50 - can see that I have this calc. py file
00:53 - and I also have that cal. py file pulled
00:55 - up in my text editor over here and you
00:57 - can also see that we have theget
01:00 - uh directory here which just means that
01:02 - we are within a git repository so now if
01:05 - I run a git status you can see that
01:08 - currently our working directory is clean
01:11 - if I do a get log then you can see that
01:13 - we've only had one commit so far it's
01:15 - just the initial commit and also if I
01:18 - run a git Branch uh you can see that we
01:23 - have another Branch here called subtract
01:25 - feature um so both uh the subtract
01:28 - feature branch and the master Branch are
01:30 - currently exactly the same they both
01:32 - only have that one initial commit um but
01:35 - for now we're not going to bother with
01:37 - the subtract feature Branch we'll take a
01:39 - look at that uh here in a little bit so
01:41 - let's look at our first example of a
01:43 - mistake that you might want to undo um
01:46 - so first we're going to say that we've
01:48 - made changes to a file and after a while
01:51 - we realize that we don't want any of the
01:53 - changes that we've made so whatever
01:55 - whatever we've done it just isn't right
01:57 - and we want to go back to the way things
02:00 - were uh so for this example I'm just
02:02 - going to uh type in a bunch of gibberish
02:06 - here into uh the text editor but more
02:10 - realistically uh in the real world this
02:12 - would likely be a bunch of code that for
02:14 - one reason or another just isn't right
02:16 - and you want to go back to the way that
02:18 - things were um so uh for this example if
02:21 - I go over here and do a get status you
02:24 - can see that we have modified the file
02:26 - if I do a get diff you can see all the
02:30 - gibberish lines that we've put in there
02:32 - um now the way that we can fix this is
02:34 - to just use a simple G checkout uh so
02:38 - what I'm going to do here is a get
02:41 - checkout calc. py and if I hit enter
02:45 - there now if I do a get status you can
02:48 - see that our working directory is clean
02:50 - and if I do a get diff you can see that
02:54 - we don't have any changes and if I go
02:56 - over here to the file and uh this
02:58 - reloads over here you can see that we
02:59 - are back to the way that things were
03:02 - after we made our initial commit so now
03:05 - let's actually make some changes to our
03:06 - file that we do want to commit to our
03:08 - repository um so I'm going to come in
03:10 - here and change the subtract function
03:12 - and I'm just going to do a return x
03:15 - minus y so that's what we want so now
03:18 - I'm going to go back over here to our
03:20 - terminal now if I run a get status you
03:24 - can see that the file has been modified
03:26 - in the working directory and I'm going
03:28 - to add that to the staging area and now
03:31 - if I do another G status you can see
03:33 - that that file is ready to be committed
03:35 - so now I'm going to go ahead and commit
03:38 - this file um but let's say that we make
03:41 - a get commit and I accidentally mess up
03:44 - our commit message so I'm going to say
03:47 - that we completed the multiply function
03:50 - which is wrong because we uh completed
03:53 - the subtract function so I'm going to go
03:55 - ahead and commit that with the bad
03:57 - commit message so now if I do a get log
04:00 - you can see that we've made the commit
04:03 - but the message is wrong so uh how do we
04:07 - modify this message without doing
04:09 - another commit well to do that uh we can
04:12 - just do another commit with the-- amend
04:15 - option so if I do a get commit D- amend
04:21 - then I can type in dasm for my message
04:24 - and I'm just going to say completed
04:27 - subtract function
04:30 - so now if I do a get log here you can
04:33 - see that uh we haven't added any more
04:35 - commits we still just have the two
04:37 - commits but we have changed this uh
04:40 - commit message on our last commit which
04:43 - is what we wanted now I do need to point
04:45 - out that this unique hash here is
04:48 - different than it was before we changed
04:50 - the commit message now that's because
04:53 - the commit message is part of the commit
04:56 - and changing it will also change the
04:58 - hash and when the hash changes that
05:01 - means that it changed the git history um
05:04 - so we only want to ever change the git
05:06 - history when we are the only ones who
05:08 - have had access to the changes that
05:10 - we've made um so if we've pushed our
05:13 - changes for other people to see and pull
05:15 - from then we do not want to change the
05:18 - get history because it can cause
05:19 - problems with their repositories so
05:22 - later in this video we're going to look
05:23 - at some ways in which we can make
05:25 - Corrections without changing the get
05:27 - history but as long as we're the only
05:29 - ones who have seen our changes then
05:31 - changing the history isn't necessarily a
05:34 - bad thing and it also makes for cleaner
05:36 - commits um so in the case of a bad
05:39 - commit message this is likely something
05:41 - that you'll notice right away and can
05:43 - fix it right on the spot like we just
05:45 - did now kind of a similar scenario is
05:49 - that instead of accidentally committing
05:50 - the wrong message uh let's say that we
05:52 - accidentally left off a file that we
05:55 - meant to commit so in this example let's
05:57 - say that I meant to create a get ignore
06:00 - file and I wanted to add it to that last
06:02 - commit so I'm going to create a do get
06:05 - ignore file here and now let me go ahead
06:08 - and run a get status and also let me add
06:13 - that to the staging area so I'll do the
06:17 - get add. GE ignore so now it's in our
06:19 - staging area but we don't want to make a
06:21 - new commit Let's uh so for this example
06:24 - we're saying that we wanted that to be a
06:26 - part of the last commit so again we're
06:29 - just going to do the get commit D- amend
06:33 - like we did before but this time it's
06:35 - going to do it with a file so if I hit
06:37 - enter here now it's going to bring up
06:39 - this interactive editor where we can
06:41 - change the get commit message if we want
06:44 - now notice here that this is the same
06:46 - get commit message uh from our previous
06:49 - commit now we don't want to change the
06:51 - message in this case so I'm just going
06:53 - to uh save and close out so now I'm
06:56 - going to do a get log and you can see
06:58 - that we still just have the two commits
07:01 - that we had before now if I do a g log
07:06 - D- stat um this will show us the files
07:10 - that were changed within the commit and
07:12 - you can see here that the get ignore
07:15 - file is now part of the last commit
07:18 - where we did the uh completed the subtra
07:21 - subtract function now once again just to
07:23 - point out uh this unique hash is now
07:27 - different so we once again changed to
07:29 - get history so just one more time uh
07:32 - just to remind you only do this type of
07:34 - thing if you haven't pushed your changes
07:36 - yet to other people so now if I do a get
07:40 - log and then I do a get Branch um so now
07:45 - we see our subtract Fe feature branch
07:47 - and now uh just say that it hits us all
07:49 - of a sudden that we've been making all
07:51 - of these commits to the master Branch by
07:54 - accident uh really we've been meaning to
07:57 - make these commits to our subtract
07:59 - teacher Branch now this is a fairly
08:01 - common mistake to commit to the wrong
08:03 - Branch because when you switch back and
08:05 - forth sometimes you just forget exactly
08:07 - where you are and um end up committing
08:10 - to uh the wrong Branch by accident so
08:13 - how do we move this commit uh right here
08:16 - this 1B 818 how do we move that commit
08:20 - to our feature Branch now to be clear
08:22 - here exactly what we want to do is our
08:25 - goal is to move this commit to our
08:28 - subtract feed teach branch and then we
08:31 - want to return our Master Branch back to
08:33 - the state of only having the single
08:36 - initial commit so the way that we're
08:38 - going to do this is we're going to use
08:40 - get cherry pick and cherry pick creates
08:43 - a new commit based off of our original
08:46 - so in this case our original is going to
08:48 - be uh this top commit here now cherry
08:51 - pick only creates a new commit based off
08:54 - of that commit it doesn't delete the
08:57 - original after it cherry-picks it so let
08:59 - me clear my screen here and so the
09:02 - process that you go through to do a get
09:03 - cherry pick is first you want to do a
09:06 - get log uh because we want to grab the
09:10 - the hash of the commit that we want to
09:11 - cherry pick um so we don't have to grab
09:14 - the entire hash usually six or seven
09:16 - characters is fine uh so I'm just going
09:18 - to copy this here and now I want to do a
09:23 - get checkout on my subtract feature
09:26 - Branch so now I'm going to switch to my
09:28 - subtract feature branch and now from
09:31 - that Branch if I do a get log you can
09:34 - see that we only have the initial commit
09:37 - now I'm going to do a get cherry pick
09:40 - and I'm going to paste in the hash that
09:43 - I had copied from the master Branch so
09:46 - now if I hit enter there and now I do a
09:49 - get log now you can see that we brought
09:53 - that commit for the complete subtract
09:55 - function we brought that commit over to
09:57 - our subtract feature branch so now we
09:59 - have that commit on our feature Branch
10:01 - but it still exists on our Master Branch
10:03 - because cherry pick doesn't delete
10:05 - commits um but we don't want that commit
10:08 - on our Master Branch we never meant to
10:10 - commit it there to begin with so how do
10:12 - we get rid of it so to do this we're
10:14 - going to use a git reset so I'm going to
10:17 - do a git checkout on master and now I'm
10:22 - going to do a get log so that we can see
10:25 - the commits that we have now there are
10:27 - three different types of resets that we
10:29 - should know about uh these are get reset
10:33 - soft get reset mixed which is the
10:36 - default and get reset hard um so first
10:40 - let's run through all of these so first
10:42 - let's run get reset soft to try to
10:45 - return uh to our initial commit so I'm
10:48 - going to grab the hash from this initial
10:50 - commit and copy that and now I'm going
10:53 - to do a get reset D- soft and then I'm
10:58 - going to paste in that hash of our
10:59 - initial commit so now if I do a get log
11:04 - you can see that we no longer have that
11:06 - second commit which is good that's what
11:08 - we wanted um but let's also look at our
11:12 - get status now you can see that we have
11:14 - some files in our staging area so soft
11:17 - will reset us back to the commit that we
11:20 - specified but it will keep our changes
11:22 - that we've made in the staging directory
11:25 - uh so we didn't lose any of our work so
11:27 - in this case our work refer to the
11:30 - addition of theg ignore file and the
11:33 - modifications that we made to the cal.
11:35 - py file so that is a soft reset uh let's
11:39 - look at a mixed reset which is the
11:42 - default um so again I'm going to grab
11:45 - the hash of the initial commit and this
11:47 - time let's do a get reset and I'm just
11:50 - going to paste in the hash because
11:52 - without any additional options it will
11:54 - default to mixed so let's go ahead and
11:56 - run that and now let's look at our get
12:01 - log we only have the one commit which is
12:03 - good but now if I do a get status you
12:06 - can see just like get reset soft it kept
12:09 - the changes um however now these changes
12:12 - aren't in the staging area now they're
12:14 - in the working directory so it's very
12:16 - similar to get reset soft but the files
12:19 - are either put in the staging or working
12:22 - directory based on which one you specify
12:25 - but in this example we we really don't
12:27 - want our changes um we really just want
12:29 - to go back to that initial commit and
12:32 - have everything the way that they were
12:34 - um so again let's copy the initial
12:38 - commit hash and this time we're going to
12:40 - try a get reset hard so get reset hard
12:44 - is going to make all of our tracked
12:47 - files match the state that they were in
12:50 - uh at the hash that we specify and you
12:52 - have to be careful with get reset hard
12:54 - because it will get rid of your changes
12:56 - but in this example that's what we
12:58 - that's what we want so I'm going to do a
13:00 - get reset D- hard and paste in that hash
13:05 - and now if I do a get log you can see
13:08 - that we have the one commit and now I'm
13:11 - going to run get status so notice that
13:14 - the modifications that we made to the
13:16 - calc. py file are gone um but that theg
13:20 - ignore file is still there now if you
13:22 - remember I said that the git reset hard
13:25 - reverts all of the tracked files back to
13:27 - the state that they were but but it
13:29 - leaves any untracked files alone so we
13:33 - can uh see here that we still have some
13:35 - leftovers with the get reset hard uh but
13:38 - luckily getting rid of untracked files
13:40 - is extremely simple so to get rid of
13:42 - untracked files we can just use get
13:45 - clean so if I do a get clean and then
13:48 - I'm going to specify the D and the F
13:51 - option so the D option gets rid of any
13:54 - untracked directories and the F gets rid
13:56 - of any untracked files so if I run that
13:59 - now if I do a get status you can see
14:03 - that our working directory is clean and
14:05 - thatg ignore file is gone now that clean
14:08 - command is a good command to know U
14:10 - because it actually comes in handy more
14:12 - often than You' think um for example one
14:15 - time I was accidentally uh I
14:17 - accidentally unzipped a file within my
14:19 - git repository and it created just a ton
14:22 - of untracked files and subdirectories
14:25 - and I could have gone through and tried
14:26 - to pick all those out manually and
14:28 - delete all of them but the easiest way
14:30 - to remove all those untracked files is
14:32 - just with this single get clean command
14:36 - okay so we learned that the get reset
14:39 - hard totally totally deletes all of our
14:42 - changes uh but what if you accidentally
14:44 - ran that and it turns out that you did
14:47 - need some of those changes so let's
14:48 - pretend for the sake of this walk
14:50 - through that we don't have uh those
14:52 - changes still saved to the subtract
14:54 - feature branch and we thought that the
14:56 - reset deleted all of the changes that
14:58 - we've made
14:59 - so if you did run a get reset hard on
15:02 - some changes that you really needed then
15:05 - are you completely out of luck well not
15:07 - entirely so you could be out of luck if
15:10 - a lot of uh time has gone by since you
15:13 - ran that get reset um I don't know the
15:16 - exact amount of time but I think get
15:18 - garbage collects uh those commits after
15:22 - 30 days or so um but get ref log is what
15:26 - we're going to want to use here so get
15:28 - ref log shows commits in the order of
15:31 - when you last reference them so let me
15:34 - run a get ref log here and you can see
15:38 - that it kind of shows us exactly a
15:41 - walkthrough of exactly what we've been
15:43 - doing so you can see here at the bottom
15:45 - is where I made my initial commit and
15:47 - then we committed our complete multiply
15:51 - multiply function which was wrong and
15:53 - then you can even see where you amended
15:55 - commits so this was an amended commit
15:57 - where we changed our message and another
15:59 - amend that's where we added the do get
16:01 - ignore file and it shows us that we
16:04 - checked out and moved from Master to
16:06 - subtract feature and then did our cherry
16:08 - pick and our checkout and then our reset
16:11 - now if you'd accidentally got rid of
16:13 - files that you didn't mean to get rid of
16:15 - then so for this example I'm going to
16:17 - grab the hash before the reset and copy
16:20 - that and I'm going to do a get checkout
16:24 - of that hash and now from here I'm going
16:27 - to run a get log so you can see when I
16:30 - run a get log from this hash uh that we
16:33 - have our changes back this is the commit
16:36 - that we reset and got rid of all those
16:39 - changes now right now we are in a
16:41 - detached head State now I'm not going to
16:43 - go fully into what this means uh but
16:47 - basically it means that we aren't on a
16:49 - branch uh and where we currently are it
16:52 - will be trashed at some point in the
16:54 - future uh so to save these changes we
16:57 - need to make a branch from it so from
16:59 - here I'm going to do a get branch and
17:02 - I'm just going to call this backup and
17:04 - now if I run get Branch command to look
17:07 - at all my branches you can see that
17:09 - currently we're in a detached head State
17:12 - and that's we'll get garbage collected
17:14 - at some point and now we have our Master
17:16 - Branch our subtract feature Branch we
17:18 - also have this backup Branch so now let
17:21 - me check out the master branch and now
17:26 - from the master Branch if I do a get
17:29 - Branch you can see that we still have
17:31 - our backup Branch so those changes that
17:34 - we thought that we'd lost uh now we have
17:37 - those in this Branch here so just to
17:39 - confirm that we still have those changes
17:41 - uh let's do a get checkout of that
17:44 - backup branch and now from here let's do
17:47 - a get log and now you can see that we
17:49 - have those changes that we thought that
17:51 - we'd lost so the get ref log can really
17:55 - be a lifesaver if you thought that you
17:58 - had lost some critical files that you
18:01 - really didn't mean to delete or that if
18:03 - you accidentally did a reset on
18:05 - something um The Ref log can really help
18:08 - you out if you know how to use it okay
18:11 - so in these examples so far I mentioned
18:13 - that you shouldn't change the get
18:15 - history if other people have pulled
18:17 - those changes already uh well what if
18:20 - you are in a situation where you really
18:22 - need to undo some commits but other
18:25 - people have already pulled those changes
18:27 - so in a situation like that you're going
18:29 - to want to use get revert uh revert
18:32 - creates new commits to reverse the
18:35 - effect of some earlier commits uh so
18:38 - this way you don't rewrite any history
18:40 - just to clarify that it's not going to
18:42 - modify or delete our existing commits
18:45 - that we've made it's going to create new
18:48 - commits on top of those uh that
18:49 - completely undo all of the changes so
18:52 - that our history remains intact so just
18:55 - to show an example of this I'm going to
18:57 - run a git log and you you can see that
18:59 - we have our two commits here so now what
19:02 - if this completed subtract function uh I
19:05 - wanted to undo that but other people
19:07 - have already checked that out well uh I
19:10 - can just copy the hash here and I'm
19:12 - going to do a get revert and then paste
19:16 - in that hash and now it's going to come
19:18 - up here with a message and I'm just
19:20 - going to save that and exit out of that
19:22 - and now if I close out of there and do a
19:25 - get log you can see that we now have
19:29 - three commits and these two bottom
19:32 - commits are completely untouched both of
19:35 - their hashes are still the same as they
19:37 - were before the revert now we have this
19:39 - additional commit that says that it
19:42 - reverted the complete subtract function
19:45 - so if I go over here to my cal. py file
19:48 - and reload it you can see that it's uh
19:50 - it undid that return statement that we
19:52 - typed in um now one nice little trick
19:55 - with uh the git diff command is that if
19:59 - I do a if I do a git log here and then I
20:02 - do a git diff of this
20:07 - hash and this hash here it's going to
20:11 - show me the difference between the
20:13 - complete subtract function commit and
20:16 - then the uh reverted version of that so
20:19 - you can see that whenever I compare
20:21 - these two commits uh all it did was go
20:23 - in here and it complet it saw all the
20:26 - changes that uh we made in our
20:29 - complete subtract function commit and
20:31 - then it just redid or undid those so for
20:34 - that commit we took out the past line
20:37 - and added in the return xus Y Line and
20:41 - in the revert it took out the return xus
20:44 - Y and added in the pass so it just did
20:46 - the complete opposite so now whenever
20:48 - you push these changes and somebody else
20:51 - um pulls those down uh their history is
20:54 - not going to be corrupted because all of
20:57 - this history is the same and all they're
20:59 - going to get is these are these new
21:01 - commits that undid those uh previous
21:03 - commits well that about does it for this
21:06 - video I hope that these uh G tips on how
21:09 - to undo some of your mistakes and roll
21:12 - back some previous commits I hope that
21:14 - this was useful for you all um if you do
21:16 - have any questions just ask in the
21:18 - comment section below uh be sure to
21:20 - subscribe for future get videos and
21:22 - thank you for watching

Cleaned transcript:

hey how's it going everybody in this video we're going to be looking at a few common scenarios in git where you can find yourself needing to undo some mistakes or even roll back some bad commits um now some of these commands will change the git history and some will not and we're going to take a look at exactly what that means here in a second now this will be a slightly more advanced git walkthr and uh we're going to assume that you already know the basic uh command line functionality of git um if you aren't familiar with basic git commands or how git works I do have a video on getting started with Git in the command line if you would like to watch that video first but with that said let's go ahead and get started uh so let's take a look at the sample repository that I have set up here so if I do an ls LA within this directory you can see that I have this calc. py file and I also have that cal. py file pulled up in my text editor over here and you can also see that we have theget uh directory here which just means that we are within a git repository so now if I run a git status you can see that currently our working directory is clean if I do a get log then you can see that we've only had one commit so far it's just the initial commit and also if I run a git Branch uh you can see that we have another Branch here called subtract feature um so both uh the subtract feature branch and the master Branch are currently exactly the same they both only have that one initial commit um but for now we're not going to bother with the subtract feature Branch we'll take a look at that uh here in a little bit so let's look at our first example of a mistake that you might want to undo um so first we're going to say that we've made changes to a file and after a while we realize that we don't want any of the changes that we've made so whatever whatever we've done it just isn't right and we want to go back to the way things were uh so for this example I'm just going to uh type in a bunch of gibberish here into uh the text editor but more realistically uh in the real world this would likely be a bunch of code that for one reason or another just isn't right and you want to go back to the way that things were um so uh for this example if I go over here and do a get status you can see that we have modified the file if I do a get diff you can see all the gibberish lines that we've put in there um now the way that we can fix this is to just use a simple G checkout uh so what I'm going to do here is a get checkout calc. py and if I hit enter there now if I do a get status you can see that our working directory is clean and if I do a get diff you can see that we don't have any changes and if I go over here to the file and uh this reloads over here you can see that we are back to the way that things were after we made our initial commit so now let's actually make some changes to our file that we do want to commit to our repository um so I'm going to come in here and change the subtract function and I'm just going to do a return x minus y so that's what we want so now I'm going to go back over here to our terminal now if I run a get status you can see that the file has been modified in the working directory and I'm going to add that to the staging area and now if I do another G status you can see that that file is ready to be committed so now I'm going to go ahead and commit this file um but let's say that we make a get commit and I accidentally mess up our commit message so I'm going to say that we completed the multiply function which is wrong because we uh completed the subtract function so I'm going to go ahead and commit that with the bad commit message so now if I do a get log you can see that we've made the commit but the message is wrong so uh how do we modify this message without doing another commit well to do that uh we can just do another commit with the amend option so if I do a get commit D amend then I can type in dasm for my message and I'm just going to say completed subtract function so now if I do a get log here you can see that uh we haven't added any more commits we still just have the two commits but we have changed this uh commit message on our last commit which is what we wanted now I do need to point out that this unique hash here is different than it was before we changed the commit message now that's because the commit message is part of the commit and changing it will also change the hash and when the hash changes that means that it changed the git history um so we only want to ever change the git history when we are the only ones who have had access to the changes that we've made um so if we've pushed our changes for other people to see and pull from then we do not want to change the get history because it can cause problems with their repositories so later in this video we're going to look at some ways in which we can make Corrections without changing the get history but as long as we're the only ones who have seen our changes then changing the history isn't necessarily a bad thing and it also makes for cleaner commits um so in the case of a bad commit message this is likely something that you'll notice right away and can fix it right on the spot like we just did now kind of a similar scenario is that instead of accidentally committing the wrong message uh let's say that we accidentally left off a file that we meant to commit so in this example let's say that I meant to create a get ignore file and I wanted to add it to that last commit so I'm going to create a do get ignore file here and now let me go ahead and run a get status and also let me add that to the staging area so I'll do the get add. GE ignore so now it's in our staging area but we don't want to make a new commit Let's uh so for this example we're saying that we wanted that to be a part of the last commit so again we're just going to do the get commit D amend like we did before but this time it's going to do it with a file so if I hit enter here now it's going to bring up this interactive editor where we can change the get commit message if we want now notice here that this is the same get commit message uh from our previous commit now we don't want to change the message in this case so I'm just going to uh save and close out so now I'm going to do a get log and you can see that we still just have the two commits that we had before now if I do a g log D stat um this will show us the files that were changed within the commit and you can see here that the get ignore file is now part of the last commit where we did the uh completed the subtra subtract function now once again just to point out uh this unique hash is now different so we once again changed to get history so just one more time uh just to remind you only do this type of thing if you haven't pushed your changes yet to other people so now if I do a get log and then I do a get Branch um so now we see our subtract Fe feature branch and now uh just say that it hits us all of a sudden that we've been making all of these commits to the master Branch by accident uh really we've been meaning to make these commits to our subtract teacher Branch now this is a fairly common mistake to commit to the wrong Branch because when you switch back and forth sometimes you just forget exactly where you are and um end up committing to uh the wrong Branch by accident so how do we move this commit uh right here this 1B 818 how do we move that commit to our feature Branch now to be clear here exactly what we want to do is our goal is to move this commit to our subtract feed teach branch and then we want to return our Master Branch back to the state of only having the single initial commit so the way that we're going to do this is we're going to use get cherry pick and cherry pick creates a new commit based off of our original so in this case our original is going to be uh this top commit here now cherry pick only creates a new commit based off of that commit it doesn't delete the original after it cherrypicks it so let me clear my screen here and so the process that you go through to do a get cherry pick is first you want to do a get log uh because we want to grab the the hash of the commit that we want to cherry pick um so we don't have to grab the entire hash usually six or seven characters is fine uh so I'm just going to copy this here and now I want to do a get checkout on my subtract feature Branch so now I'm going to switch to my subtract feature branch and now from that Branch if I do a get log you can see that we only have the initial commit now I'm going to do a get cherry pick and I'm going to paste in the hash that I had copied from the master Branch so now if I hit enter there and now I do a get log now you can see that we brought that commit for the complete subtract function we brought that commit over to our subtract feature branch so now we have that commit on our feature Branch but it still exists on our Master Branch because cherry pick doesn't delete commits um but we don't want that commit on our Master Branch we never meant to commit it there to begin with so how do we get rid of it so to do this we're going to use a git reset so I'm going to do a git checkout on master and now I'm going to do a get log so that we can see the commits that we have now there are three different types of resets that we should know about uh these are get reset soft get reset mixed which is the default and get reset hard um so first let's run through all of these so first let's run get reset soft to try to return uh to our initial commit so I'm going to grab the hash from this initial commit and copy that and now I'm going to do a get reset D soft and then I'm going to paste in that hash of our initial commit so now if I do a get log you can see that we no longer have that second commit which is good that's what we wanted um but let's also look at our get status now you can see that we have some files in our staging area so soft will reset us back to the commit that we specified but it will keep our changes that we've made in the staging directory uh so we didn't lose any of our work so in this case our work refer to the addition of theg ignore file and the modifications that we made to the cal. py file so that is a soft reset uh let's look at a mixed reset which is the default um so again I'm going to grab the hash of the initial commit and this time let's do a get reset and I'm just going to paste in the hash because without any additional options it will default to mixed so let's go ahead and run that and now let's look at our get log we only have the one commit which is good but now if I do a get status you can see just like get reset soft it kept the changes um however now these changes aren't in the staging area now they're in the working directory so it's very similar to get reset soft but the files are either put in the staging or working directory based on which one you specify but in this example we we really don't want our changes um we really just want to go back to that initial commit and have everything the way that they were um so again let's copy the initial commit hash and this time we're going to try a get reset hard so get reset hard is going to make all of our tracked files match the state that they were in uh at the hash that we specify and you have to be careful with get reset hard because it will get rid of your changes but in this example that's what we that's what we want so I'm going to do a get reset D hard and paste in that hash and now if I do a get log you can see that we have the one commit and now I'm going to run get status so notice that the modifications that we made to the calc. py file are gone um but that theg ignore file is still there now if you remember I said that the git reset hard reverts all of the tracked files back to the state that they were but but it leaves any untracked files alone so we can uh see here that we still have some leftovers with the get reset hard uh but luckily getting rid of untracked files is extremely simple so to get rid of untracked files we can just use get clean so if I do a get clean and then I'm going to specify the D and the F option so the D option gets rid of any untracked directories and the F gets rid of any untracked files so if I run that now if I do a get status you can see that our working directory is clean and thatg ignore file is gone now that clean command is a good command to know U because it actually comes in handy more often than You' think um for example one time I was accidentally uh I accidentally unzipped a file within my git repository and it created just a ton of untracked files and subdirectories and I could have gone through and tried to pick all those out manually and delete all of them but the easiest way to remove all those untracked files is just with this single get clean command okay so we learned that the get reset hard totally totally deletes all of our changes uh but what if you accidentally ran that and it turns out that you did need some of those changes so let's pretend for the sake of this walk through that we don't have uh those changes still saved to the subtract feature branch and we thought that the reset deleted all of the changes that we've made so if you did run a get reset hard on some changes that you really needed then are you completely out of luck well not entirely so you could be out of luck if a lot of uh time has gone by since you ran that get reset um I don't know the exact amount of time but I think get garbage collects uh those commits after 30 days or so um but get ref log is what we're going to want to use here so get ref log shows commits in the order of when you last reference them so let me run a get ref log here and you can see that it kind of shows us exactly a walkthrough of exactly what we've been doing so you can see here at the bottom is where I made my initial commit and then we committed our complete multiply multiply function which was wrong and then you can even see where you amended commits so this was an amended commit where we changed our message and another amend that's where we added the do get ignore file and it shows us that we checked out and moved from Master to subtract feature and then did our cherry pick and our checkout and then our reset now if you'd accidentally got rid of files that you didn't mean to get rid of then so for this example I'm going to grab the hash before the reset and copy that and I'm going to do a get checkout of that hash and now from here I'm going to run a get log so you can see when I run a get log from this hash uh that we have our changes back this is the commit that we reset and got rid of all those changes now right now we are in a detached head State now I'm not going to go fully into what this means uh but basically it means that we aren't on a branch uh and where we currently are it will be trashed at some point in the future uh so to save these changes we need to make a branch from it so from here I'm going to do a get branch and I'm just going to call this backup and now if I run get Branch command to look at all my branches you can see that currently we're in a detached head State and that's we'll get garbage collected at some point and now we have our Master Branch our subtract feature Branch we also have this backup Branch so now let me check out the master branch and now from the master Branch if I do a get Branch you can see that we still have our backup Branch so those changes that we thought that we'd lost uh now we have those in this Branch here so just to confirm that we still have those changes uh let's do a get checkout of that backup branch and now from here let's do a get log and now you can see that we have those changes that we thought that we'd lost so the get ref log can really be a lifesaver if you thought that you had lost some critical files that you really didn't mean to delete or that if you accidentally did a reset on something um The Ref log can really help you out if you know how to use it okay so in these examples so far I mentioned that you shouldn't change the get history if other people have pulled those changes already uh well what if you are in a situation where you really need to undo some commits but other people have already pulled those changes so in a situation like that you're going to want to use get revert uh revert creates new commits to reverse the effect of some earlier commits uh so this way you don't rewrite any history just to clarify that it's not going to modify or delete our existing commits that we've made it's going to create new commits on top of those uh that completely undo all of the changes so that our history remains intact so just to show an example of this I'm going to run a git log and you you can see that we have our two commits here so now what if this completed subtract function uh I wanted to undo that but other people have already checked that out well uh I can just copy the hash here and I'm going to do a get revert and then paste in that hash and now it's going to come up here with a message and I'm just going to save that and exit out of that and now if I close out of there and do a get log you can see that we now have three commits and these two bottom commits are completely untouched both of their hashes are still the same as they were before the revert now we have this additional commit that says that it reverted the complete subtract function so if I go over here to my cal. py file and reload it you can see that it's uh it undid that return statement that we typed in um now one nice little trick with uh the git diff command is that if I do a if I do a git log here and then I do a git diff of this hash and this hash here it's going to show me the difference between the complete subtract function commit and then the uh reverted version of that so you can see that whenever I compare these two commits uh all it did was go in here and it complet it saw all the changes that uh we made in our complete subtract function commit and then it just redid or undid those so for that commit we took out the past line and added in the return xus Y Line and in the revert it took out the return xus Y and added in the pass so it just did the complete opposite so now whenever you push these changes and somebody else um pulls those down uh their history is not going to be corrupted because all of this history is the same and all they're going to get is these are these new commits that undid those uh previous commits well that about does it for this video I hope that these uh G tips on how to undo some of your mistakes and roll back some previous commits I hope that this was useful for you all um if you do have any questions just ask in the comment section below uh be sure to subscribe for future get videos and thank you for watching
