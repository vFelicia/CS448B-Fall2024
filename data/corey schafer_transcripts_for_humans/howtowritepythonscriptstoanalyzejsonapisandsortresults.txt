With timestamps:

00:00 - hey there how's it going everybody so I
00:01 - was putting together a tutorial on how
00:03 - to use homebrew which is a package
00:05 - manager for the Mac operating system and
00:07 - while I was doing that video I was
00:09 - looking through the packages that were
00:10 - available in homebrew so that's the page
00:13 - that I have open here and they have all
00:15 - of the packages that are available on
00:17 - their core repo right here through the
00:19 - browser with a little description of
00:21 - each one and if I click on one of these
00:24 - packages then it takes me to a page with
00:27 - more details about that package now one
00:30 - interesting piece of information here if
00:32 - I scroll down a bit is the analytics
00:35 - where they have the total number of
00:36 - installations for certain time frames so
00:39 - they have the total installations for
00:41 - the last 30 days the last 90 days and
00:44 - the last 365 days so I started wondering
00:47 - if there was a way that I could find out
00:50 - what their most popular packages were
00:52 - now I didn't see any kind of sorting
00:54 - functionality on their site so I didn't
00:56 - think that it existed it did exist but
00:58 - I'll get to that in just a second so
01:01 - since I didn't think that this
01:03 - information existed I figured that it
01:05 - would be a good idea for a real-world
01:07 - project where we could build a solution
01:09 - to this on our own so I actually went
01:12 - out and created a script that sorts
01:14 - these packages by their popularity
01:16 - manually but after I did that I
01:18 - discovered that they actually have this
01:20 - information available if you look hard
01:22 - enough for it so that is the page that I
01:24 - have open here so on their analytics
01:27 - page here they have pages for their most
01:29 - installed packages and again I found
01:31 - this pretty hard to find that's why I
01:33 - didn't know it existed before writing my
01:35 - own script to this it's not linked
01:37 - anywhere on the page with their
01:39 - available packages and on their website
01:41 - it's at the very bottom closed down
01:43 - close to their footer but it does exist
01:45 - so if I click on their install requests
01:49 - for the last 30 days for example so I'll
01:53 - do the install on request events here
01:55 - for the last 30 days by the way I
01:57 - believe that the install on request
01:59 - means that the package was explicitly
02:01 - installed and wasn't installed as a
02:03 - dependency or anything like that
02:05 - so that's what I'm most interested in so
02:08 - we can see the most installed packages
02:09 - for the last 30 days on this page here
02:12 - so
02:12 - like I said I wrote a script to do this
02:14 - manually without knowing that this
02:16 - existed and I figured that I could still
02:18 - make a video showing how I got this
02:20 - information manually and then we can
02:22 - compare it to their version here to make
02:24 - sure that it's working properly so if
02:26 - you're trying to learn something then I
02:28 - definitely think it's a good idea to try
02:30 - to come up with your own solutions to
02:31 - problems like these anytime you run into
02:33 - them even if they solution already
02:35 - exists not only is it good practice but
02:38 - you're also solving a problem that
02:40 - you're actually interested in and you're
02:43 - going to feel a bit more sense of pride
02:45 - after you've done this as well so let me
02:48 - show you how I came up with my own
02:49 - solution to these most popular packages
02:52 - based solely on what they have in their
02:55 - package information listed over here so
02:58 - like I said in their list of packages
03:00 - here I didn't see any sorting
03:02 - functionality or a way to get to the
03:04 - most installed packages but I did see
03:06 - that they had some JSON API s
03:08 - that contains some information so we can
03:11 - see on this page for this specific
03:12 - package that they have a JSON API for
03:16 - this specific package so I'm going to
03:18 - open this up in a new tab and the URL
03:21 - for this is ford slash api forged slash
03:24 - formula forge slash the name of the
03:27 - package JSON so let me make this a
03:29 - little larger here
03:30 - now this isn't formatted so it's a bit
03:32 - jumbled together and difficult to read
03:34 - but this JSON has the analytics
03:37 - available from that for this specific
03:39 - package so if I hit ctrl F to do a
03:43 - search and then search for 30-days then
03:46 - we can see that we have the 30 days for
03:48 - the installs the 30 days for the
03:50 - installs on request and the 30 day total
03:55 - for the build errors now like I said a
03:56 - bit ago I think the difference between
03:58 - install and install or in requests is
04:01 - that installing requests is a package
04:04 - that is installed explicitly and doesn't
04:06 - count you know being installed as a
04:08 - dependency so that's what I'm gonna be
04:10 - after in this video ok so this is the
04:13 - JSON for this particular package but we
04:16 - want to compare the analytics of all the
04:18 - packages so let's go back to the main
04:22 - page here so let me make this a little
04:24 - smaller
04:25 - here I'm gonna go back to their full
04:27 - list of packages and now that we're back
04:29 - on their main page for all of their
04:31 - packages in their core repository we can
04:34 - see that there's also a JSON API here as
04:37 - well so this is probably for all of the
04:40 - packages so let me open this up and I'm
04:42 - gonna open this up in a new tab as well
04:44 - and this takes a little longer to load
04:47 - since there are more packages okay so
04:49 - this is a large JSON file here that
04:51 - contains information on all of the
04:54 - packages but it doesn't contain the
04:56 - analytics now let's create a new Python
04:59 - script so that we can get begin to
05:02 - analyze some of the data that they
05:03 - provide here and so that we can read
05:05 - this a little bit better so what I'm
05:07 - gonna do is I'm gonna copy the URL to
05:09 - this JSON here for all of these packages
05:12 - so I'm gonna copy that and I have a
05:14 - blank Python script open up here in
05:16 - sublime and this is a script that I just
05:19 - created in a folder on my desktop so for
05:22 - this script I'm gonna be using the
05:23 - request library now I already have a
05:26 - request installed but if you don't have
05:28 - it installed then you can install it
05:30 - with a simple pip install so once you
05:33 - have request installed I'm just going to
05:35 - import that so I'll import request and
05:38 - now let's grab the contents from that
05:40 - JSON URL that we copied from the browser
05:43 - so to do this I can simply say R is
05:46 - equal to request dot git and I want to
05:50 - get that URL for all of the packages for
05:56 - that JSON and once we get a response
05:58 - from that URL we can parse out that JSON
06:01 - simply by saying let's say I'll call
06:03 - this packages underscore JSON I'll set
06:06 - that equal to R which is the request R
06:08 - dot JSON now if you're not familiar with
06:12 - how to use the request library then I do
06:14 - have a detailed video on how to use
06:17 - these requests and responses if you're
06:19 - interested and I'll leave a link to that
06:20 - video in the description section below
06:22 - in this video I'm going to focus more on
06:24 - solving the problem rather than going
06:26 - into deep details about each step okay
06:29 - so now that we have that large JSON
06:32 - object that we got from their API so we
06:35 - don't really know what information that
06:37 - has on
06:38 - each package just yet so let's go ahead
06:40 - and take a look now I could just print
06:43 - this out but it would be all jumbled
06:44 - together just like we saw in our browser
06:46 - so let's see what that looks like so
06:49 - I'll say print and I'll just print that
06:52 - package is JSON without any formatting
06:55 - so if I run that then it's going to take
06:58 - a while to print all of this information
06:59 - out here but if I make this a little
07:02 - larger then we can see that this is all
07:04 - just jumbled together here okay so
07:06 - that's pretty hard to read so let's
07:08 - clean this up a bit now when working
07:10 - with JSON data we can use the JSON
07:12 - module to dump this to a string and we
07:16 - can tell the string how we want it to be
07:18 - formatted so to do this let's import the
07:21 - JSON module so I will import JSON here
07:26 - at the top and now I'm just going to
07:29 - overwrite my print statement here and
07:32 - now I'm going to say packages underscore
07:35 - string is equal to and then I'll do json
07:38 - dot dump s which will dump this object
07:42 - here into a string and the json that i
07:46 - wanted up is packages json and i also
07:50 - want to do an indent equal to two and
07:53 - that will make the formatting a bit
07:56 - better so now i'm going to print that
08:00 - packages underscore string and i'll save
08:03 - that and run it and now this should
08:06 - print out in a more formatted response
08:09 - now i also have a detailed video on
08:11 - working with json data if you'd like to
08:14 - see more details about what we're doing
08:15 - here so i'll also leave a link to that
08:18 - video in the description section below
08:19 - as well okay so when we run that we can
08:22 - see that it's formatted and a bunch much
08:24 - better and more readable way now so I
08:26 - can tell from the ending square bracket
08:29 - at the end here in our output that this
08:32 - JSON is a list of values and it looks
08:36 - like this is a list of all of the
08:39 - packages let me make this a bit larger
08:41 - here so that we can see this a bit
08:44 - better so if we look at the information
08:47 - for one package here then we can look
08:50 - through the information that
08:52 - provides but it doesn't look like which
08:55 - see we have a name full name aliases we
08:58 - have a description but if I keep
09:00 - scrolling down it's got different URLs
09:02 - for them and stuff like that but I don't
09:04 - see anything for analytics and then this
09:08 - specific package runs out right here and
09:10 - then it moves on to the next package
09:12 - with name full name description but I
09:14 - don't see any analytics now since I know
09:17 - that this JSON is a list of packages let
09:20 - me simplify this a bit just by dumping
09:22 - the first package from that list to our
09:25 - string so if I make this a little
09:28 - smaller here instead of dumping all of
09:30 - these packages from this packages JSON
09:33 - here since I know this is a list of
09:35 - packages I can just jump that first
09:37 - index which should be the first package
09:40 - so if I save that and run it then if we
09:43 - can see from the output here that this
09:45 - is no longer list it's just a single
09:47 - object and that object is just going to
09:50 - be the first package that we got back
09:53 - from that JSON and this package is
09:54 - actually the one that we opened up in
09:56 - the browser because it was at the top of
09:58 - the list okay so now we have a list of
10:01 - the available packages but still no
10:04 - analytic data but we know that each
10:06 - package has its own JSON with the
10:09 - analytic data because we saw that in the
10:11 - browser so let's go back to the browser
10:13 - and look at the naming convention of the
10:16 - API for each package so let me open up
10:19 - the browser here I'm going to close down
10:22 - these two here and I'm going to click on
10:25 - a specific package again so that we can
10:27 - see what a the JSON looks like for that
10:31 - specific package so I'm going to open
10:32 - this up and let me copy this and now I'm
10:36 - going to paste that URL into sublime so
10:39 - that we can read it a bit better so I'm
10:41 - just going to paste it down here at the
10:43 - bottom as a comment okay so this URL
10:46 - that we have here was what gave us the
10:48 - JSON for all of the packages and the URL
10:51 - that I just grabbed and pasted here is
10:53 - the JSON for this specific a to PS
10:57 - package and this JSON like we saw
11:00 - earlier does have the analytics data for
11:03 - that specific package so let's look at
11:06 - how the
11:06 - URL is formatted so we have the base of
11:09 - the URL here and then we have forged
11:12 - slash API ford slash formula and then
11:15 - Forge slash the name of the package a
11:18 - two PS followed by a dot JSON so if I
11:23 - look at down here at the information in
11:26 - the JSON that we got back from all of
11:28 - the packages that does contain the
11:30 - package name here so maybe we can use
11:34 - that package name to generate our own
11:36 - URL to then grab the JSON specific to a
11:40 - particular package so let me show you
11:43 - what I mean
11:43 - so I'm going to grab the package name
11:46 - from this first package simply by saying
11:49 - underneath the package JSON here I'm
11:53 - going to say package underscore name is
11:55 - equal to packages JSON and I'm going to
12:00 - access that first package and now I'm
12:03 - gonna access the name key from that
12:06 - first package and now let's generate a
12:09 - URL by using the naming convention that
12:12 - we just got from the browser so I'm just
12:15 - going to take the URL that we paste it
12:16 - in here and turn it into a string so I'm
12:19 - going to uncomment it and I'm going to
12:22 - highlight it and put it within single
12:24 - quotes to turn it into a string
12:26 - let me also copy that and paste it up
12:29 - here and now I'm going to replace this
12:33 - package name with our package name
12:35 - variable so to do this I'm going to use
12:38 - an F string which allows us to put
12:40 - variables directly into our string so
12:43 - I'm going to say package underscore URL
12:47 - is equal to and then I'm going to put an
12:50 - F to indicate that this is an F string
12:52 - and now where we have the package name
12:55 - here in the URL I'm going to get rid of
12:57 - the hard-coded one that's actually in
12:59 - there now and I'm going to instead
13:02 - replace that with our package name that
13:04 - we got from the JSON data here so now
13:10 - let's make a request to that URL that we
13:13 - just generated and see if we get the
13:15 - analytics data for this single package
13:17 - so to do this I'm just going to say
13:20 - r is equal to request dot get and I want
13:25 - to get this package URL and then I can
13:29 - just say I'll call this package
13:31 - underscore JSON instead of packages
13:33 - underscore JSON I'll say package
13:36 - underscore JSON is equal to r dot JSON
13:39 - and that is the response JSON from the
13:43 - request made to that single package URL
13:45 - and now I'm going to take the same logic
13:47 - that we use to print the formatted data
13:49 - out before and use this with our new
13:52 - JSON for this particular package so I'm
13:55 - going to call this package string
13:57 - instead of packages string and also what
14:01 - the data that I want to dump to a string
14:03 - I want this to be packages JSON or I'm
14:08 - sorry package JSON and I don't need to
14:10 - access any index because it's not a list
14:13 - of values it should just be the JSON for
14:15 - that particular package so if I save
14:19 - that and run it then it looks like we
14:21 - did get a response back
14:23 - if I scroll up to the top here the name
14:25 - of the package that we got is that a to
14:27 - PS so we did get the right information
14:30 - and if I scroll down here towards the
14:32 - bottom then we can see that we have the
14:35 - analytics here so we have the analytics
14:38 - for the installations for the past 30 90
14:41 - and 365 days and we also have the
14:43 - analytics for the install on request so
14:46 - it looks like we did get the information
14:47 - that we want for that one package okay
14:50 - so now let's look at how we would access
14:51 - those analytics specifically so I'm
14:54 - gonna make this a little larger here and
14:56 - just scroll up a little bit so if we
14:58 - look at this dictionary then it's within
15:01 - a key named analytics and then we want
15:05 - the analytics for the number of installs
15:07 - on request so with an within analytics
15:11 - here we have a key called install on
15:16 - requests and then with install on
15:18 - requests we have keys for 30 D which is
15:22 - 30 days 90 D which is 90 days and 365 D
15:26 - which is 365 days and within each key
15:30 - for those days there is another key with
15:33 - the package
15:34 - so in this case it's a two PS and then
15:38 - the value of that key contains the
15:41 - number of installations on request okay
15:44 - so we've got a couple of layers to dig
15:46 - down through here but let's see how we
15:48 - grab those values so I'm gonna make this
15:50 - a little smaller again and I can scroll
15:53 - up to where we have that analytics key
15:56 - so I'm going to overwrite a print
15:58 - statement here and instead I'm going to
16:01 - try to get the installs for 30 90 and
16:05 - 365 days so first I'll do installs
16:08 - underscore 30 is equal to and that's
16:11 - going to be equal to package.json which
16:14 - is the dictionary of this JSON data and
16:17 - now I want to access the analytics key
16:20 - and within that analytics key there's
16:23 - another dictionary and I want to access
16:25 - the install underscore on underscore
16:29 - request key so install on request key
16:32 - and any time you need to know where you
16:35 - need to go you can check down here in
16:37 - your output so we have analytics we have
16:39 - install or request and now we want the
16:43 - 30 days so that's a key of 30 d so I'll
16:46 - now access that key of 30 d and now
16:50 - within 30 d we have another key that is
16:54 - the package name now we actually have
16:56 - the package name in a variable so
16:59 - instead of hard-coding that I'll just
17:01 - copy package name and paste that in
17:03 - there and now the value of that key
17:05 - should be the information that we're
17:07 - after that is the number of installs on
17:10 - request for the last 30 days now let me
17:13 - just copy this logic here and I'm going
17:15 - to use this for the installations for
17:18 - the last 90 and 365 days as well so I'll
17:21 - call this variable installs underscore
17:24 - 90 and here instead of the 30 D key I'm
17:28 - going to access the 90 D key and here
17:31 - this last one I'll call installs
17:33 - underscore 365 and I will access the 365
17:38 - D key there so so far we have the
17:41 - package name and the analytics data for
17:45 - three different date
17:47 - now I think I also want to grab the
17:49 - description of this package so that we
17:51 - know what the package is meant to do so
17:54 - what peer underneath the package name
17:56 - I'm going to copy this and paste under
18:00 - here I'm gonna also grab the package
18:02 - description so this will be package
18:04 - underscore I'll just say DSC and the key
18:08 - that we want to access let's see that
18:11 - was DSC if you forgot what that was you
18:14 - could go back and look at that JSON but
18:16 - I've got it written down here that
18:18 - that's what that key is for the
18:20 - description so yeah if if you forget
18:23 - that you can always go back and look at
18:24 - the original JSON okay so now let's
18:26 - print out all of this data that we have
18:29 - so far to make sure it all looks correct
18:31 - for this single package so I'm going to
18:33 - print out the package name the package
18:36 - description I'm also going to print out
18:39 - the installs for 30 installs for 90 and
18:43 - installs for 365 now before I run this
18:47 - the values that we should get for 39 day
18:50 - and 365 should be 109 324 and 1410 that
18:56 - we can see in the output currently so
18:58 - I'm going to save this and run it and if
19:01 - I run this then we can see that we get
19:03 - the package name this is the description
19:05 - here and then we got 109 324 1410 so
19:10 - that's what we expected okay perfect so
19:11 - now we have the information that we want
19:13 - for this one package so now let's see if
19:16 - we can do it for all of the packages now
19:18 - this is going to require me to go to a
19:20 - lot of different URLs to see how many
19:23 - URLs that this is going to try to go to
19:25 - we can print the length of our packages
19:28 - JSON list that we have here at the top
19:31 - so let me comment out this stuff here
19:34 - that we have at the bottom underneath
19:36 - the package packages JSON up and I also
19:41 - need to comment these out as well I want
19:44 - to comment everything below the package
19:45 - is JSON here and let me print how many
19:48 - packages we're going to need to analyze
19:50 - and to do that I will just print the le
19:52 - in which will give me the link of this
19:55 - packages list here so if I save that and
19:58 - run it then we can see that there are
20:00 - four thousand seven
20:01 - and 18 packages now the way that we're
20:04 - doing this right now that means that
20:06 - we're gonna have to make requests to the
20:09 - individual Jason's for 4718 packages now
20:13 - if anyone has ever watched my video on
20:15 - web scraping I mentioned that it's not
20:17 - very considerate to hammer a server with
20:20 - a lot of different requests at one time
20:22 - so some api's even may have limits on
20:25 - how often they'll allow you to make a
20:27 - request I didn't see any limits in
20:29 - homebrews API documentation but it's
20:32 - still nice to be as courteous as
20:34 - possible now these are pretty
20:35 - lightweight JSON responses that will be
20:38 - requesting show it so it shouldn't put
20:40 - too much strain on their site but I
20:42 - still think it would be a good idea to
20:43 - just put in a very slight delay before
20:45 - each request so that it's not hammering
20:48 - these requests one after another so to
20:50 - do this I'm going to sleep between each
20:53 - request and for the amount of time that
20:55 - I'm going to sleep for I'm just going to
20:57 - use the amount of time that it took me
20:59 - to get a response from the site that way
21:02 - if the responses start slowing down then
21:05 - it's just going to make our program
21:06 - sleep longer between requests so that
21:09 - we're not slamming their API so let's
21:11 - see how we can do this so first we want
21:14 - to loop over all of the packages so in
21:16 - order to do this I'm going to overwrite
21:18 - this print statement here I'm just going
21:20 - to say for package in packages JSON
21:25 - since that is a list of all of the
21:28 - packages and now I'm going to reuse all
21:32 - of this logic here let me get rid of the
21:34 - output for now so that we can see all of
21:36 - this I'm going to uncomment out all of
21:39 - this and I'm going to just reuse all of
21:44 - this logic and indent this in our for
21:46 - loop and now I need to make a couple of
21:48 - changes here so now that I'm within this
21:50 - for loop we are accessing the
21:54 - information for this package variable
21:56 - instead of packages underscore JSON so
21:59 - right here where I'm accessing the first
22:02 - package from that list instead since
22:05 - we're in a loop now I'm just going to
22:06 - access the name for that specific
22:08 - package and also the description for
22:11 - that specific package so we changed
22:13 - those two lines there
22:14 - now I also want to let's see this line
22:18 - looks good this line looks good this
22:20 - one's good
22:21 - we're no longer using this as to test
22:25 - anymore so we can just get rid of the
22:27 - packaged string and now all of this
22:30 - information is information that should
22:33 - apply to all of these packages now now
22:35 - before I put in any sleep statements or
22:38 - anything like that
22:39 - I'm just going to see if this looks like
22:41 - it's going to work so this should print
22:43 - out all of the install analytics for the
22:47 - different package packages right now so
22:49 - I'm just going to run this for a second
22:51 - and then immediately kill it after I get
22:53 - a few responses now if you're following
22:55 - along with this video then please don't
22:57 - follow along with this part if you don't
22:59 - know how to kill your program because
23:01 - otherwise it will go out and make those
23:04 - 4700 requests and we aren't even
23:07 - capturing that information in any way
23:09 - right now so it would be a long wait for
23:11 - nothing
23:12 - so I'm gonna run this quickly as a test
23:14 - and then I'm just going to immediately
23:16 - kill it so I will run this and I can see
23:18 - some responses coming in so I'm going to
23:20 - kill it
23:20 - with ctrl C okay so it looks like we
23:23 - were getting that information for
23:25 - different packages we have the different
23:27 - package names here we have the
23:30 - descriptions here and then we have the
23:32 - installs for the last 30 90 and 365 days
23:37 - okay so that's perfect so now we want to
23:39 - capture this information in some way and
23:41 - also put in that sleep between each
23:44 - request now I think the best way to
23:46 - capture this information will be to
23:49 - create a list of dictionaries and then
23:52 - we can save that entire list of
23:53 - dictionaries to a file on our own
23:55 - machine so you might be wondering why
23:57 - would I want to save this list of
23:59 - dictionaries to my own machine when I
24:01 - could just analyze the data on the spot
24:03 - without saving a file well the reason I
24:06 - want to do that is because you know
24:08 - maybe you'll want to revisit the data or
24:10 - analyze it in a different way after
24:11 - we've downloaded at once and it will be
24:13 - much easier and faster to analyze that
24:16 - single file on our own computer then it
24:18 - would be to go out and request those
24:20 - 4700 JSON files each time we want to
24:23 - look at something in a different way so
24:24 - for now our main goal is to capture this
24:27 - information
24:28 - and save it to our own custom JSON file
24:31 - so to do this above our for loop I'm
24:34 - going to create an empty list and I'm
24:37 - going to call this empty list results
24:40 - and I'll just set this equal to an empty
24:42 - list okay and now within our for loop
24:45 - let me close the output again here so
24:47 - that we can see within our for loop
24:49 - after we've grabbed the installations
24:52 - for the last 30 90 and 365 days we'll
24:56 - put that into a dictionary and let's
24:59 - make this a Mista nested dictionary so
25:02 - first we'll have keys for the package
25:04 - name and description so I'll say data is
25:07 - equal to and we want this to be a
25:09 - dictionary so first I'll have a key for
25:12 - the name and the value I will just have
25:14 - as package name and I'll put in a comma
25:18 - and now we want a key for the
25:21 - description so I'll just call this DSC
25:23 - just like they had it and I will put in
25:25 - the package description and now for the
25:28 - analytics let's just use the same keys
25:30 - and values from the day that we pulled
25:33 - down from their API so I will have
25:36 - another key here and I will call this
25:39 - analytics and for the value I'll make
25:42 - this another dictionary and this
25:45 - dictionary will have a key for 30d which
25:49 - will be our installs of the last 30 days
25:54 - we also want I'm just going to copy this
25:57 - line here to make this go faster we also
26:00 - want a key of 90 D for the installs of
26:03 - the last 90 days and lastly we want a
26:07 - key for 365 D and those will be the
26:12 - installations of the last 365 days now
26:15 - again in this video I'm analyzing the
26:17 - installs on requests but you can analyze
26:20 - whatever you want with this script so
26:22 - instead if you would if you would also
26:24 - like to add the analytics for the
26:26 - regular installs then you could grab
26:29 - that data from the original JSON you
26:32 - could also grab the built number of
26:33 - build errors and things like that
26:35 - anything that you want to add to this
26:36 - it's completely customizable so I'm just
26:39 - using the install zone request for the
26:41 - last there
26:42 - and 365 days okay and I can take out
26:45 - that last comma there since we don't
26:47 - have any more keys after that okay so
26:49 - now that we have that information for
26:51 - that single package
26:52 - let's append that data to our results
26:55 - list so we're still here within the for
26:59 - loop I'm going to say results dot append
27:01 - and I want to append this data to that
27:05 - results list and we'll go over this one
27:08 - more time in just a second so that we're
27:09 - sure that we understand everything
27:11 - that's going on so far but for now let
27:13 - me go ahead and add in that sleep delay
27:15 - after we've appended that data and that
27:18 - will make our program sleep for just a
27:20 - little bit before it advances the loop
27:23 - and makes the next web request so to do
27:25 - this I'm going to import the time module
27:28 - since that's how we do sleep so I'm
27:32 - going to import time and now after the
27:37 - we appended the data to our results I'm
27:40 - just going to say time dot sleep and I
27:43 - want to sleep for the amount of time
27:46 - that it took me to get the response that
27:48 - way if the responses start slowing down
27:50 - for any reason let's say it takes five
27:52 - seconds to get a response back then that
27:55 - would mean that our program would start
27:57 - sleeping five seconds before we make
27:59 - make the next response so it's just a
28:01 - way to kind of give a buffer and to take
28:04 - it easy on the server if it starts to
28:07 - look like it's slowing down for any
28:08 - reason so to do this the response object
28:11 - for requests I actually have a nice
28:13 - built-in function that does this for us
28:17 - so this response is just set to R here
28:20 - so I'm going to say that we want to
28:22 - sleep for our dot elapsed and elapsed is
28:27 - a time delta so with time delta we can
28:29 - just do total underscore seconds and
28:32 - that is a method so we want to put
28:35 - parentheses there to execute total
28:36 - seconds okay so now let's do a quick
28:38 - recap here so that we understand
28:40 - everything that we've done so far so I'm
28:43 - going to come up here so we have our
28:45 - empty results list and then we have our
28:48 - for loop here where we're looping over
28:50 - all of the packages that we got back
28:52 - from that initial request
28:55 - and we are you know getting information
28:57 - from those packages such as the package
28:59 - name and the description and then we are
29:01 - making a request to the URL for that
29:05 - specific packages JSON file that
29:08 - contains the analytics and then we are
29:11 - parsing out the information that we want
29:13 - from that specific JSON file and then we
29:16 - are creating a dictionary and putting in
29:20 - our own custom information here so we're
29:21 - setting the name the description and the
29:24 - analytics for that one specific package
29:26 - and then we are appending that one
29:29 - specific package to our results list so
29:31 - after this for loop finishes we should
29:34 - have a list of all of the packages with
29:38 - all of this information here so to show
29:40 - you what this looks like and also to
29:42 - test that this is working the way that
29:44 - we expect it to so far I'm going to add
29:46 - a break statement underneath our time
29:50 - dot sleep now what that's going to do is
29:53 - it's going to run through our for loop
29:55 - one time and after it runs through that
29:57 - first time it's going to hit that break
29:59 - statement and the break statement will
30:01 - then tell Python just to break out of
30:03 - the for loop and continue on with the
30:06 - code after the for loop so once we break
30:09 - out of that for loop let's print out the
30:11 - results or let's print out the results
30:13 - list to see what it looks like at that
30:15 - time so I'm going to get rid of this
30:18 - print statement here and now I'm going
30:21 - to go down a couple lines here I'm going
30:22 - to uninvent here back to the main level
30:24 - and that will take us out of that for
30:27 - loop and I'm just going to print out the
30:29 - results list
30:31 - so if I save that and run what we have
30:34 - so far then we can see that right now we
30:37 - just have a list that contains that
30:39 - first package and it just contains the
30:41 - first one because we put that break
30:43 - statement in the for loop there now once
30:46 - we take that break statement out then
30:48 - our list will contain that information
30:50 - for all of those packages but before we
30:52 - take that break statement out let's go
30:55 - ahead and add the logic for saving that
30:57 - list of dictionaries to a JSON file so
31:00 - that we can make sure that it works with
31:02 - what we have now so notice as I'm
31:05 - developing this script I'm building this
31:07 - up to the final result
31:09 - a little bit at a time and I'm always
31:11 - doing it with small chunks of test data
31:13 - so if I were to just take out the break
31:16 - statement and write up the code for
31:18 - saving the JSON file without testing it
31:20 - first then it could spend a ton of time
31:23 - downloading all of that data only to
31:25 - crash at the very end and that would
31:28 - just unnecessarily waste a lot of our
31:30 - time when we would when we could have
31:32 - just tested it with a little bit of data
31:34 - first okay so to do this to go ahead and
31:38 - write this JSON file we can simply I'm
31:42 - going to remove this print statement so
31:44 - I'm going to say with open to open a new
31:47 - file and I will just call this package
31:50 - underscore info dot JSON and we want to
31:55 - open this in write mode and I will just
31:58 - call this F and within this context
32:01 - manager I'll say json dot dump and we
32:05 - use dump when we're dumping to a file we
32:07 - use dump s when we're dumping to a
32:09 - string so we're going to do json dot
32:11 - dump we want to dump that results list
32:14 - we want to dump that to F which is our
32:18 - open file and we also want to put in an
32:21 - indent equal to two here and that will
32:23 - just make our file nice and formatted so
32:26 - if I save this and run it then that
32:30 - should create a package info JSON file
32:33 - in our current directory so by current
32:36 - directory I mean the directory where
32:38 - this current script lives so let me open
32:42 - this up so in the sidebar here I have
32:44 - the directory open where I'm running
32:46 - this script and we can see that there is
32:48 - a package underscore info dot JSON so if
32:52 - I open that up this is what got written
32:54 - to that file okay so we can see that
32:56 - this file looks good this is what we
32:58 - expected so now we can try to remove
33:01 - that break statement from our for loop
33:03 - and it should go through all of those
33:05 - packages and add them to our JSON file
33:07 - now before I run this I'm also going to
33:09 - put in some print statements so that we
33:11 - can keep track of where we currently are
33:12 - and I'm also going to time how long it
33:15 - takes to go through all of these URLs so
33:18 - first I'm going to
33:20 - put in a print statement that gives us
33:23 - some feedback that things are still
33:25 - going well so I will before the break
33:29 - statement here I'll say print and I'm
33:31 - going to print out an F string and I'm
33:33 - just going to say that we got the
33:37 - package name and then I'll also say how
33:41 - long it took so we got the package name
33:43 - in the total second so I'll say r dot
33:47 - elapsed time dot total seconds there and
33:50 - then after that placeholder I also say
33:52 - seconds okay and now I'm also going to
33:55 - time the entire loop so up here before
33:59 - our for loop I'm gonna say t1 is equal
34:05 - to time dot perf underscore counter this
34:09 - is just a way to get accurate timings in
34:12 - Python so I'm going to copy that
34:14 - and then after the loop I'm gonna say
34:18 - and this is outside of the loop I'm
34:21 - gonna say t2 is equal to time dot perf
34:23 - counter and then we can just print out
34:27 - before we write the JSON file I'll print
34:30 - out an F string and I'll say finished in
34:33 - and we will do t2 minus t1 seconds so
34:39 - what this is doing here is we're
34:40 - starting a counter or a timer before the
34:43 - for loop let's say it takes 20 minutes
34:46 - to go through that for loop then we're
34:48 - measuring the time afterwards so then
34:49 - we're going to say t2 minus t1 if it
34:53 - took 20 minutes then it will give us 20
34:56 - minutes in seconds there okay now
34:58 - finally I'm going to remove the break
35:00 - statement from our for loop and run the
35:03 - script so hopefully this will go out and
35:05 - grab everything that we wanted and then
35:07 - save it to our JSON file so let me take
35:10 - out the break statement there and let me
35:13 - save this and run it and see if this
35:16 - looks like it's working okay so we can
35:19 - see that it's going out and getting the
35:21 - data for these individual packages and
35:24 - it looks like this is working nicely now
35:28 - this is going to take a while because
35:29 - there are you know so many packages to
35:32 - go through to get the data that we want
35:34 - so I'm going to pause the video and then
35:36 - I'll pick this back up once this is
35:40 - finished and we'll see how long this
35:42 - took okay so I pause the video and I let
35:45 - that script finish and it looks like it
35:47 - finished in about 1,400 seconds so let's
35:51 - see if I open up my calculator that is
35:53 - about fourteen hundred divided by sixty
35:58 - that's about twenty four and a half
35:59 - minutes that it took to go out and pull
36:02 - down the JSON of all of those package
36:05 - files now if we hadn't put in the sleep
36:08 - statement then it probably would have
36:09 - done it and about half that time because
36:11 - we were essentially doubling the time
36:13 - that it took since we were sleeping for
36:16 - the amount of time that each response
36:18 - the time that took for each response but
36:20 - we can see that we didn't get any errors
36:21 - or anything so that's a good sign so now
36:24 - we should have all of that data saved
36:26 - into our JSON file in the same directory
36:28 - as our current script so let me check
36:31 - that out and so I'll reopen this package
36:33 - info JSON and if we look at this file we
36:36 - can see that it looks like we have all
36:38 - of this information for all of these
36:40 - packages so this is looking pretty good
36:43 - so we have each package name we have the
36:46 - descriptions and we have the analytics
36:48 - for each one so now we can actually do
36:51 - what we first set out to do and use this
36:53 - data to determine what the most popular
36:56 - or homebrew packages are so to do this
36:58 - I'm going to create a new script and
37:00 - I'll just create this in the same
37:02 - directory that we are currently in so
37:04 - I'll say new file and I'm gonna call
37:06 - this let's just call this popular dot pi
37:09 - or something like that
37:11 - and within this file I'm going to first
37:13 - load that JSON file that we just
37:15 - generated so to do that I'm going to
37:17 - import JSON and to open that file I'll
37:22 - say with open and that was package
37:25 - underscore info dot JSON and we want to
37:29 - open that in read mode we can put that
37:32 - in explicitly if we want but read is the
37:34 - default so either way you want to do
37:36 - that so I'll say as f so f is our Open
37:40 - File there now I'll say data is equal to
37:43 - JSON load when we want to load JSON data
37:48 - from
37:48 - file we use load and I want to load from
37:51 - F which is our JSON file okay so if I
37:55 - print this data then it should now be a
37:58 - Python list of all of our dictionaries
38:01 - so let's print that out to check so I'll
38:04 - say print and I want to be out of that
38:07 - with statement there so print data so if
38:11 - I save that and run it then we can see
38:14 - that this looks good it is a list of all
38:16 - of that data okay so now all we have to
38:20 - do is sort this list but we're going to
38:22 - need to write a custom sorting function
38:25 - because Python doesn't know what this
38:27 - data is or how we want it sorted so we
38:29 - need to tell it how we want this sorted
38:32 - now I have a separate more detailed
38:34 - video on how to do custom sorting so
38:36 - I'll leave a link to that video in the
38:38 - description section below but for this
38:39 - example I'll just show you how we can
38:42 - sort this specific list so first I'm
38:44 - going to create a function that will be
38:47 - what we want to use to sort the list so
38:49 - I'm going to remove this print statement
38:52 - here now I'm going to create this
38:55 - sorting function at the top of this file
38:57 - let me close the output here so we can
38:59 - see a little bit better so I'm going to
39:01 - create a function here and I'm just
39:03 - going to call this function install sort
39:06 - and we want to pass in a package as an
39:11 - argument to this function and now we
39:13 - need to return the value that we want to
39:16 - sort on so depending on whether we want
39:18 - to sort by 30 90 or 365 days we'll have
39:23 - to return that value
39:24 - so first let's sort by 30 day installs
39:28 - so I'll just say return package and we
39:33 - want to access the analytics key of each
39:37 - package and we want to return the
39:41 - thirty-day key value from that package
39:45 - and again if you don't know how these
39:46 - sorting functions work then definitely
39:48 - watch my more detailed video on sorting
39:51 - sorting objects so that you can know
39:53 - exactly what's going on here now this is
39:55 - actually going to sort these in
39:57 - ascending order with how we have this
39:59 - right now
40:00 - so packages that have
40:02 - zero installs will be at the beginning
40:04 - and packages with a lot of installs will
40:06 - be at the end now I'd rather see the
40:08 - packages with a lot of installs at the
40:10 - beginning but that's no problem we can
40:12 - simply say reverse equals true when we
40:14 - actually sort this so this function is
40:18 - finished up and now we can go ahead and
40:20 - sort this now we have two ways that we
40:22 - can sort this data we can either sort it
40:24 - in place using the sort method or we can
40:28 - keep the original data unsorted and
40:30 - capture the sorted data in a new
40:32 - variable using the sorted function now
40:35 - I'm just going to sort the data in place
40:37 - in this example so that means we don't
40:39 - have to create a new variable so in
40:42 - order to do this I'm just going to do
40:43 - this here at the bottom I'll say data
40:45 - dot sort and now we want to say key is
40:49 - equal to and this is going to be the
40:51 - function that we use to sort this data
40:54 - so I'm going to pass in the function of
40:57 - install sort now we want to pass in the
40:59 - function itself we don't want to execute
41:01 - the function so we're not putting
41:03 - parentheses here to execute the function
41:05 - we are leaving parentheses off and
41:07 - passing in the function itself and now
41:10 - we also want to set reverse equal to
41:14 - true because like I said this sorting
41:17 - function is going to sort in ascending
41:19 - order we want those in descending order
41:21 - so we'll say reverse is equal to true so
41:24 - now that data should be that should be a
41:28 - sorted list with the most installed
41:30 - packages of the last 30 days at the
41:32 - beginning of the list so let's print
41:35 - this sorted list out and I want this to
41:37 - be readable so I'm going to use the JSON
41:39 - module to dump this to a formatted JSON
41:42 - string just like we did earlier in this
41:45 - video so to do that I'm just going to
41:47 - say data underscore STR is equal to json
41:51 - dot dump s to dump this to a string and
41:55 - we want to dump that data list and I'm
41:58 - going to say indent is equal to two to
42:00 - make sure that that string is properly
42:01 - formatted now I will just print out that
42:05 - data string so if I save that and run it
42:09 - oops accidentally pasted something in
42:11 - there if I save that and run it now let
42:14 - me
42:15 - roll all the way up to the top here
42:18 - gonna have to use this over here then we
42:21 - should see the most installed packages
42:23 - of the last 30 days so we have node we
42:27 - have Python we have get W get yarn so
42:32 - that's pretty interesting and if we look
42:34 - at the 30-day totals so this is you know
42:38 - 250,000 here 254 okay so this was 255
42:42 - 254 142 140 so it does look like this is
42:47 - in descending order so that's good now
42:49 - let's compare this to their version on
42:51 - their website to see if this looks
42:54 - similar to what they have so this is the
42:57 - analytics for install on request for the
43:01 - last 30 days
43:01 - we have node Python get W get yarn so
43:05 - those are the same ones that we saw and
43:06 - for the numbers here we have 255 250 for
43:10 - 140 to 140 the results that we got in
43:15 - our custom script now I do think that
43:17 - the way that we build up our custom
43:18 - script does allow us to have some
43:20 - additional functionality that I don't
43:21 - think that they have in their online API
43:23 - for this analytics data so for example
43:26 - if I go back to their website here let
43:29 - me open up the browser again so here is
43:32 - their JSON API for their analytics data
43:36 - for the last 30 days so if I look at
43:38 - this let me make this a little bit
43:40 - larger here I know that this is probably
43:42 - hard for you to see but all they have
43:45 - here are the numbers so number one the
43:48 - rankings and the formula so node is
43:51 - number one they have the counts which we
43:53 - have as well but you can see here that
43:55 - they don't have a description for the
43:58 - package it's just the package name the
44:00 - count and the percentage of downloads so
44:03 - if we wanted to know the description of
44:05 - these packages then we'd have to go to
44:07 - them one by one but with our custom
44:09 - script that we built we do have these
44:11 - descriptions so that also allows us to
44:14 - that allows us to filter by descriptions
44:17 - as well so if I go back to my script let
44:21 - me make this page a little smaller here
44:23 - if I go back to my script then I could
44:26 - simply write a list comprehension here
44:29 - filter out the data based on a certain
44:31 - description so let's say that I only
44:33 - wanted packages that had the word video
44:36 - in the description so in order to do
44:39 - that I could say something like data is
44:41 - equal to and now we'll use a list
44:43 - comprehension and now I can simply say
44:45 - something like item for item in data if
44:51 - the text video let me spell that
44:54 - correctly is in the item description and
44:59 - that description key is des C is how we
45:03 - set it up now if you're unfamiliar with
45:05 - how list comprehensions work then I do
45:07 - have a separate video on those in detail
45:09 - as well and I'll be sure to link a link
45:11 - to that video also in the description
45:13 - section below
45:14 - but what this list comprehension is
45:16 - doing is it's just saying that we want
45:17 - all of the items in data our data list
45:21 - if the item has a description with video
45:25 - in that description so that's what that
45:27 - list comprehension is doing so if I save
45:30 - this and run it and now go up here to
45:33 - the top let me see we got still kind of
45:37 - a long list here so now we can see all
45:39 - of the packages for the last 30 days
45:44 - with video in the description so these
45:46 - are the top packages so we have ffmpeg
45:49 - play recorded convert and stream audio
45:51 - and video youtube-dl download YouTube
45:54 - videos from the command line you know
45:57 - vp8 vp9 video codec so that's pretty
46:01 - nice that we have this kind of
46:02 - functionality in our custom script here
46:04 - so if we wanted to get the top packages
46:09 - for the last 365 days with the word
46:12 - video in the item description and let's
46:16 - also just take the top 5 of these
46:19 - packages so if we wanted to just take
46:21 - the top 5 then we could use list slicing
46:24 - just to access those first 5 values so
46:27 - here where I'm dumping the data list to
46:30 - a string I can simply use list slicing
46:34 - and say that I only want up to the fifth
46:37 - item so if I save that and run it then
46:40 - now we're not going to have nearly as
46:41 - many items here we just
46:43 - have five or we should that's one two
46:45 - three four five okay and so the top
46:50 - packages for last year youtube-dl is the
46:53 - top one then ffmpeg media info and
46:56 - handbrake okay so that's pretty neat
46:59 - okay so now let me close down that
47:03 - output there okay so that's pretty much
47:05 - it for the manual script that I wrote to
47:07 - sort homebrew packages by popularity
47:09 - like I said I wrote this script before I
47:11 - knew that they had an API that already
47:13 - existed with most of this information
47:15 - but as we saw with being able to narrow
47:18 - down packages with a certain description
47:19 - this definitely has some uses that we
47:22 - can't get from their existing API or at
47:24 - least I don't think that it exists with
47:26 - their current API I could be wrong about
47:28 - that so all in all I definitely think
47:30 - that it was worth the time to write this
47:32 - up
47:33 - also as you build something like this
47:35 - you're gonna get some practice maybe
47:37 - using some tools that you haven't used
47:38 - in a while and it's always good to take
47:40 - on real-world projects like this in
47:42 - order to keep your skills sharp but with
47:44 - that said I think that it's going to do
47:46 - it for this video hopefully you found
47:47 - this interesting and learn some new
47:49 - tricks for solving problems like this
47:50 - that you might run into and projects
47:52 - like this can always be expanded further
47:55 - and further you know you could use
47:57 - matplotlib to graph these out in some
47:58 - cool way or analyze some other part of
48:01 - the data that we're getting from our
48:03 - file or anything like that but if anyone
48:06 - has any questions about what we covered
48:08 - in this video then feel free to ask in
48:09 - the comment section below and I'll do my
48:11 - best to answer those and if you enjoy
48:12 - these tutorials and would like to
48:14 - support them then there are several ways
48:15 - you can do that the easiest ways to
48:16 - simply like the video and give it a
48:18 - thumbs up and also it's a huge help to
48:20 - share these videos with anyone who you
48:21 - think would find them useful and if you
48:22 - have the means you can contribute
48:23 - through patreon and there's a link to
48:25 - that page in the description section
48:26 - below be sure to subscribe for future
48:28 - videos and thank you all for watching
48:31 - you
48:40 - you

Cleaned transcript:

hey there how's it going everybody so I was putting together a tutorial on how to use homebrew which is a package manager for the Mac operating system and while I was doing that video I was looking through the packages that were available in homebrew so that's the page that I have open here and they have all of the packages that are available on their core repo right here through the browser with a little description of each one and if I click on one of these packages then it takes me to a page with more details about that package now one interesting piece of information here if I scroll down a bit is the analytics where they have the total number of installations for certain time frames so they have the total installations for the last 30 days the last 90 days and the last 365 days so I started wondering if there was a way that I could find out what their most popular packages were now I didn't see any kind of sorting functionality on their site so I didn't think that it existed it did exist but I'll get to that in just a second so since I didn't think that this information existed I figured that it would be a good idea for a realworld project where we could build a solution to this on our own so I actually went out and created a script that sorts these packages by their popularity manually but after I did that I discovered that they actually have this information available if you look hard enough for it so that is the page that I have open here so on their analytics page here they have pages for their most installed packages and again I found this pretty hard to find that's why I didn't know it existed before writing my own script to this it's not linked anywhere on the page with their available packages and on their website it's at the very bottom closed down close to their footer but it does exist so if I click on their install requests for the last 30 days for example so I'll do the install on request events here for the last 30 days by the way I believe that the install on request means that the package was explicitly installed and wasn't installed as a dependency or anything like that so that's what I'm most interested in so we can see the most installed packages for the last 30 days on this page here so like I said I wrote a script to do this manually without knowing that this existed and I figured that I could still make a video showing how I got this information manually and then we can compare it to their version here to make sure that it's working properly so if you're trying to learn something then I definitely think it's a good idea to try to come up with your own solutions to problems like these anytime you run into them even if they solution already exists not only is it good practice but you're also solving a problem that you're actually interested in and you're going to feel a bit more sense of pride after you've done this as well so let me show you how I came up with my own solution to these most popular packages based solely on what they have in their package information listed over here so like I said in their list of packages here I didn't see any sorting functionality or a way to get to the most installed packages but I did see that they had some JSON API s that contains some information so we can see on this page for this specific package that they have a JSON API for this specific package so I'm going to open this up in a new tab and the URL for this is ford slash api forged slash formula forge slash the name of the package JSON so let me make this a little larger here now this isn't formatted so it's a bit jumbled together and difficult to read but this JSON has the analytics available from that for this specific package so if I hit ctrl F to do a search and then search for 30days then we can see that we have the 30 days for the installs the 30 days for the installs on request and the 30 day total for the build errors now like I said a bit ago I think the difference between install and install or in requests is that installing requests is a package that is installed explicitly and doesn't count you know being installed as a dependency so that's what I'm gonna be after in this video ok so this is the JSON for this particular package but we want to compare the analytics of all the packages so let's go back to the main page here so let me make this a little smaller here I'm gonna go back to their full list of packages and now that we're back on their main page for all of their packages in their core repository we can see that there's also a JSON API here as well so this is probably for all of the packages so let me open this up and I'm gonna open this up in a new tab as well and this takes a little longer to load since there are more packages okay so this is a large JSON file here that contains information on all of the packages but it doesn't contain the analytics now let's create a new Python script so that we can get begin to analyze some of the data that they provide here and so that we can read this a little bit better so what I'm gonna do is I'm gonna copy the URL to this JSON here for all of these packages so I'm gonna copy that and I have a blank Python script open up here in sublime and this is a script that I just created in a folder on my desktop so for this script I'm gonna be using the request library now I already have a request installed but if you don't have it installed then you can install it with a simple pip install so once you have request installed I'm just going to import that so I'll import request and now let's grab the contents from that JSON URL that we copied from the browser so to do this I can simply say R is equal to request dot git and I want to get that URL for all of the packages for that JSON and once we get a response from that URL we can parse out that JSON simply by saying let's say I'll call this packages underscore JSON I'll set that equal to R which is the request R dot JSON now if you're not familiar with how to use the request library then I do have a detailed video on how to use these requests and responses if you're interested and I'll leave a link to that video in the description section below in this video I'm going to focus more on solving the problem rather than going into deep details about each step okay so now that we have that large JSON object that we got from their API so we don't really know what information that has on each package just yet so let's go ahead and take a look now I could just print this out but it would be all jumbled together just like we saw in our browser so let's see what that looks like so I'll say print and I'll just print that package is JSON without any formatting so if I run that then it's going to take a while to print all of this information out here but if I make this a little larger then we can see that this is all just jumbled together here okay so that's pretty hard to read so let's clean this up a bit now when working with JSON data we can use the JSON module to dump this to a string and we can tell the string how we want it to be formatted so to do this let's import the JSON module so I will import JSON here at the top and now I'm just going to overwrite my print statement here and now I'm going to say packages underscore string is equal to and then I'll do json dot dump s which will dump this object here into a string and the json that i wanted up is packages json and i also want to do an indent equal to two and that will make the formatting a bit better so now i'm going to print that packages underscore string and i'll save that and run it and now this should print out in a more formatted response now i also have a detailed video on working with json data if you'd like to see more details about what we're doing here so i'll also leave a link to that video in the description section below as well okay so when we run that we can see that it's formatted and a bunch much better and more readable way now so I can tell from the ending square bracket at the end here in our output that this JSON is a list of values and it looks like this is a list of all of the packages let me make this a bit larger here so that we can see this a bit better so if we look at the information for one package here then we can look through the information that provides but it doesn't look like which see we have a name full name aliases we have a description but if I keep scrolling down it's got different URLs for them and stuff like that but I don't see anything for analytics and then this specific package runs out right here and then it moves on to the next package with name full name description but I don't see any analytics now since I know that this JSON is a list of packages let me simplify this a bit just by dumping the first package from that list to our string so if I make this a little smaller here instead of dumping all of these packages from this packages JSON here since I know this is a list of packages I can just jump that first index which should be the first package so if I save that and run it then if we can see from the output here that this is no longer list it's just a single object and that object is just going to be the first package that we got back from that JSON and this package is actually the one that we opened up in the browser because it was at the top of the list okay so now we have a list of the available packages but still no analytic data but we know that each package has its own JSON with the analytic data because we saw that in the browser so let's go back to the browser and look at the naming convention of the API for each package so let me open up the browser here I'm going to close down these two here and I'm going to click on a specific package again so that we can see what a the JSON looks like for that specific package so I'm going to open this up and let me copy this and now I'm going to paste that URL into sublime so that we can read it a bit better so I'm just going to paste it down here at the bottom as a comment okay so this URL that we have here was what gave us the JSON for all of the packages and the URL that I just grabbed and pasted here is the JSON for this specific a to PS package and this JSON like we saw earlier does have the analytics data for that specific package so let's look at how the URL is formatted so we have the base of the URL here and then we have forged slash API ford slash formula and then Forge slash the name of the package a two PS followed by a dot JSON so if I look at down here at the information in the JSON that we got back from all of the packages that does contain the package name here so maybe we can use that package name to generate our own URL to then grab the JSON specific to a particular package so let me show you what I mean so I'm going to grab the package name from this first package simply by saying underneath the package JSON here I'm going to say package underscore name is equal to packages JSON and I'm going to access that first package and now I'm gonna access the name key from that first package and now let's generate a URL by using the naming convention that we just got from the browser so I'm just going to take the URL that we paste it in here and turn it into a string so I'm going to uncomment it and I'm going to highlight it and put it within single quotes to turn it into a string let me also copy that and paste it up here and now I'm going to replace this package name with our package name variable so to do this I'm going to use an F string which allows us to put variables directly into our string so I'm going to say package underscore URL is equal to and then I'm going to put an F to indicate that this is an F string and now where we have the package name here in the URL I'm going to get rid of the hardcoded one that's actually in there now and I'm going to instead replace that with our package name that we got from the JSON data here so now let's make a request to that URL that we just generated and see if we get the analytics data for this single package so to do this I'm just going to say r is equal to request dot get and I want to get this package URL and then I can just say I'll call this package underscore JSON instead of packages underscore JSON I'll say package underscore JSON is equal to r dot JSON and that is the response JSON from the request made to that single package URL and now I'm going to take the same logic that we use to print the formatted data out before and use this with our new JSON for this particular package so I'm going to call this package string instead of packages string and also what the data that I want to dump to a string I want this to be packages JSON or I'm sorry package JSON and I don't need to access any index because it's not a list of values it should just be the JSON for that particular package so if I save that and run it then it looks like we did get a response back if I scroll up to the top here the name of the package that we got is that a to PS so we did get the right information and if I scroll down here towards the bottom then we can see that we have the analytics here so we have the analytics for the installations for the past 30 90 and 365 days and we also have the analytics for the install on request so it looks like we did get the information that we want for that one package okay so now let's look at how we would access those analytics specifically so I'm gonna make this a little larger here and just scroll up a little bit so if we look at this dictionary then it's within a key named analytics and then we want the analytics for the number of installs on request so with an within analytics here we have a key called install on requests and then with install on requests we have keys for 30 D which is 30 days 90 D which is 90 days and 365 D which is 365 days and within each key for those days there is another key with the package so in this case it's a two PS and then the value of that key contains the number of installations on request okay so we've got a couple of layers to dig down through here but let's see how we grab those values so I'm gonna make this a little smaller again and I can scroll up to where we have that analytics key so I'm going to overwrite a print statement here and instead I'm going to try to get the installs for 30 90 and 365 days so first I'll do installs underscore 30 is equal to and that's going to be equal to package.json which is the dictionary of this JSON data and now I want to access the analytics key and within that analytics key there's another dictionary and I want to access the install underscore on underscore request key so install on request key and any time you need to know where you need to go you can check down here in your output so we have analytics we have install or request and now we want the 30 days so that's a key of 30 d so I'll now access that key of 30 d and now within 30 d we have another key that is the package name now we actually have the package name in a variable so instead of hardcoding that I'll just copy package name and paste that in there and now the value of that key should be the information that we're after that is the number of installs on request for the last 30 days now let me just copy this logic here and I'm going to use this for the installations for the last 90 and 365 days as well so I'll call this variable installs underscore 90 and here instead of the 30 D key I'm going to access the 90 D key and here this last one I'll call installs underscore 365 and I will access the 365 D key there so so far we have the package name and the analytics data for three different date now I think I also want to grab the description of this package so that we know what the package is meant to do so what peer underneath the package name I'm going to copy this and paste under here I'm gonna also grab the package description so this will be package underscore I'll just say DSC and the key that we want to access let's see that was DSC if you forgot what that was you could go back and look at that JSON but I've got it written down here that that's what that key is for the description so yeah if if you forget that you can always go back and look at the original JSON okay so now let's print out all of this data that we have so far to make sure it all looks correct for this single package so I'm going to print out the package name the package description I'm also going to print out the installs for 30 installs for 90 and installs for 365 now before I run this the values that we should get for 39 day and 365 should be 109 324 and 1410 that we can see in the output currently so I'm going to save this and run it and if I run this then we can see that we get the package name this is the description here and then we got 109 324 1410 so that's what we expected okay perfect so now we have the information that we want for this one package so now let's see if we can do it for all of the packages now this is going to require me to go to a lot of different URLs to see how many URLs that this is going to try to go to we can print the length of our packages JSON list that we have here at the top so let me comment out this stuff here that we have at the bottom underneath the package packages JSON up and I also need to comment these out as well I want to comment everything below the package is JSON here and let me print how many packages we're going to need to analyze and to do that I will just print the le in which will give me the link of this packages list here so if I save that and run it then we can see that there are four thousand seven and 18 packages now the way that we're doing this right now that means that we're gonna have to make requests to the individual Jason's for 4718 packages now if anyone has ever watched my video on web scraping I mentioned that it's not very considerate to hammer a server with a lot of different requests at one time so some api's even may have limits on how often they'll allow you to make a request I didn't see any limits in homebrews API documentation but it's still nice to be as courteous as possible now these are pretty lightweight JSON responses that will be requesting show it so it shouldn't put too much strain on their site but I still think it would be a good idea to just put in a very slight delay before each request so that it's not hammering these requests one after another so to do this I'm going to sleep between each request and for the amount of time that I'm going to sleep for I'm just going to use the amount of time that it took me to get a response from the site that way if the responses start slowing down then it's just going to make our program sleep longer between requests so that we're not slamming their API so let's see how we can do this so first we want to loop over all of the packages so in order to do this I'm going to overwrite this print statement here I'm just going to say for package in packages JSON since that is a list of all of the packages and now I'm going to reuse all of this logic here let me get rid of the output for now so that we can see all of this I'm going to uncomment out all of this and I'm going to just reuse all of this logic and indent this in our for loop and now I need to make a couple of changes here so now that I'm within this for loop we are accessing the information for this package variable instead of packages underscore JSON so right here where I'm accessing the first package from that list instead since we're in a loop now I'm just going to access the name for that specific package and also the description for that specific package so we changed those two lines there now I also want to let's see this line looks good this line looks good this one's good we're no longer using this as to test anymore so we can just get rid of the packaged string and now all of this information is information that should apply to all of these packages now now before I put in any sleep statements or anything like that I'm just going to see if this looks like it's going to work so this should print out all of the install analytics for the different package packages right now so I'm just going to run this for a second and then immediately kill it after I get a few responses now if you're following along with this video then please don't follow along with this part if you don't know how to kill your program because otherwise it will go out and make those 4700 requests and we aren't even capturing that information in any way right now so it would be a long wait for nothing so I'm gonna run this quickly as a test and then I'm just going to immediately kill it so I will run this and I can see some responses coming in so I'm going to kill it with ctrl C okay so it looks like we were getting that information for different packages we have the different package names here we have the descriptions here and then we have the installs for the last 30 90 and 365 days okay so that's perfect so now we want to capture this information in some way and also put in that sleep between each request now I think the best way to capture this information will be to create a list of dictionaries and then we can save that entire list of dictionaries to a file on our own machine so you might be wondering why would I want to save this list of dictionaries to my own machine when I could just analyze the data on the spot without saving a file well the reason I want to do that is because you know maybe you'll want to revisit the data or analyze it in a different way after we've downloaded at once and it will be much easier and faster to analyze that single file on our own computer then it would be to go out and request those 4700 JSON files each time we want to look at something in a different way so for now our main goal is to capture this information and save it to our own custom JSON file so to do this above our for loop I'm going to create an empty list and I'm going to call this empty list results and I'll just set this equal to an empty list okay and now within our for loop let me close the output again here so that we can see within our for loop after we've grabbed the installations for the last 30 90 and 365 days we'll put that into a dictionary and let's make this a Mista nested dictionary so first we'll have keys for the package name and description so I'll say data is equal to and we want this to be a dictionary so first I'll have a key for the name and the value I will just have as package name and I'll put in a comma and now we want a key for the description so I'll just call this DSC just like they had it and I will put in the package description and now for the analytics let's just use the same keys and values from the day that we pulled down from their API so I will have another key here and I will call this analytics and for the value I'll make this another dictionary and this dictionary will have a key for 30d which will be our installs of the last 30 days we also want I'm just going to copy this line here to make this go faster we also want a key of 90 D for the installs of the last 90 days and lastly we want a key for 365 D and those will be the installations of the last 365 days now again in this video I'm analyzing the installs on requests but you can analyze whatever you want with this script so instead if you would if you would also like to add the analytics for the regular installs then you could grab that data from the original JSON you could also grab the built number of build errors and things like that anything that you want to add to this it's completely customizable so I'm just using the install zone request for the last there and 365 days okay and I can take out that last comma there since we don't have any more keys after that okay so now that we have that information for that single package let's append that data to our results list so we're still here within the for loop I'm going to say results dot append and I want to append this data to that results list and we'll go over this one more time in just a second so that we're sure that we understand everything that's going on so far but for now let me go ahead and add in that sleep delay after we've appended that data and that will make our program sleep for just a little bit before it advances the loop and makes the next web request so to do this I'm going to import the time module since that's how we do sleep so I'm going to import time and now after the we appended the data to our results I'm just going to say time dot sleep and I want to sleep for the amount of time that it took me to get the response that way if the responses start slowing down for any reason let's say it takes five seconds to get a response back then that would mean that our program would start sleeping five seconds before we make make the next response so it's just a way to kind of give a buffer and to take it easy on the server if it starts to look like it's slowing down for any reason so to do this the response object for requests I actually have a nice builtin function that does this for us so this response is just set to R here so I'm going to say that we want to sleep for our dot elapsed and elapsed is a time delta so with time delta we can just do total underscore seconds and that is a method so we want to put parentheses there to execute total seconds okay so now let's do a quick recap here so that we understand everything that we've done so far so I'm going to come up here so we have our empty results list and then we have our for loop here where we're looping over all of the packages that we got back from that initial request and we are you know getting information from those packages such as the package name and the description and then we are making a request to the URL for that specific packages JSON file that contains the analytics and then we are parsing out the information that we want from that specific JSON file and then we are creating a dictionary and putting in our own custom information here so we're setting the name the description and the analytics for that one specific package and then we are appending that one specific package to our results list so after this for loop finishes we should have a list of all of the packages with all of this information here so to show you what this looks like and also to test that this is working the way that we expect it to so far I'm going to add a break statement underneath our time dot sleep now what that's going to do is it's going to run through our for loop one time and after it runs through that first time it's going to hit that break statement and the break statement will then tell Python just to break out of the for loop and continue on with the code after the for loop so once we break out of that for loop let's print out the results or let's print out the results list to see what it looks like at that time so I'm going to get rid of this print statement here and now I'm going to go down a couple lines here I'm going to uninvent here back to the main level and that will take us out of that for loop and I'm just going to print out the results list so if I save that and run what we have so far then we can see that right now we just have a list that contains that first package and it just contains the first one because we put that break statement in the for loop there now once we take that break statement out then our list will contain that information for all of those packages but before we take that break statement out let's go ahead and add the logic for saving that list of dictionaries to a JSON file so that we can make sure that it works with what we have now so notice as I'm developing this script I'm building this up to the final result a little bit at a time and I'm always doing it with small chunks of test data so if I were to just take out the break statement and write up the code for saving the JSON file without testing it first then it could spend a ton of time downloading all of that data only to crash at the very end and that would just unnecessarily waste a lot of our time when we would when we could have just tested it with a little bit of data first okay so to do this to go ahead and write this JSON file we can simply I'm going to remove this print statement so I'm going to say with open to open a new file and I will just call this package underscore info dot JSON and we want to open this in write mode and I will just call this F and within this context manager I'll say json dot dump and we use dump when we're dumping to a file we use dump s when we're dumping to a string so we're going to do json dot dump we want to dump that results list we want to dump that to F which is our open file and we also want to put in an indent equal to two here and that will just make our file nice and formatted so if I save this and run it then that should create a package info JSON file in our current directory so by current directory I mean the directory where this current script lives so let me open this up so in the sidebar here I have the directory open where I'm running this script and we can see that there is a package underscore info dot JSON so if I open that up this is what got written to that file okay so we can see that this file looks good this is what we expected so now we can try to remove that break statement from our for loop and it should go through all of those packages and add them to our JSON file now before I run this I'm also going to put in some print statements so that we can keep track of where we currently are and I'm also going to time how long it takes to go through all of these URLs so first I'm going to put in a print statement that gives us some feedback that things are still going well so I will before the break statement here I'll say print and I'm going to print out an F string and I'm just going to say that we got the package name and then I'll also say how long it took so we got the package name in the total second so I'll say r dot elapsed time dot total seconds there and then after that placeholder I also say seconds okay and now I'm also going to time the entire loop so up here before our for loop I'm gonna say t1 is equal to time dot perf underscore counter this is just a way to get accurate timings in Python so I'm going to copy that and then after the loop I'm gonna say and this is outside of the loop I'm gonna say t2 is equal to time dot perf counter and then we can just print out before we write the JSON file I'll print out an F string and I'll say finished in and we will do t2 minus t1 seconds so what this is doing here is we're starting a counter or a timer before the for loop let's say it takes 20 minutes to go through that for loop then we're measuring the time afterwards so then we're going to say t2 minus t1 if it took 20 minutes then it will give us 20 minutes in seconds there okay now finally I'm going to remove the break statement from our for loop and run the script so hopefully this will go out and grab everything that we wanted and then save it to our JSON file so let me take out the break statement there and let me save this and run it and see if this looks like it's working okay so we can see that it's going out and getting the data for these individual packages and it looks like this is working nicely now this is going to take a while because there are you know so many packages to go through to get the data that we want so I'm going to pause the video and then I'll pick this back up once this is finished and we'll see how long this took okay so I pause the video and I let that script finish and it looks like it finished in about 1,400 seconds so let's see if I open up my calculator that is about fourteen hundred divided by sixty that's about twenty four and a half minutes that it took to go out and pull down the JSON of all of those package files now if we hadn't put in the sleep statement then it probably would have done it and about half that time because we were essentially doubling the time that it took since we were sleeping for the amount of time that each response the time that took for each response but we can see that we didn't get any errors or anything so that's a good sign so now we should have all of that data saved into our JSON file in the same directory as our current script so let me check that out and so I'll reopen this package info JSON and if we look at this file we can see that it looks like we have all of this information for all of these packages so this is looking pretty good so we have each package name we have the descriptions and we have the analytics for each one so now we can actually do what we first set out to do and use this data to determine what the most popular or homebrew packages are so to do this I'm going to create a new script and I'll just create this in the same directory that we are currently in so I'll say new file and I'm gonna call this let's just call this popular dot pi or something like that and within this file I'm going to first load that JSON file that we just generated so to do that I'm going to import JSON and to open that file I'll say with open and that was package underscore info dot JSON and we want to open that in read mode we can put that in explicitly if we want but read is the default so either way you want to do that so I'll say as f so f is our Open File there now I'll say data is equal to JSON load when we want to load JSON data from file we use load and I want to load from F which is our JSON file okay so if I print this data then it should now be a Python list of all of our dictionaries so let's print that out to check so I'll say print and I want to be out of that with statement there so print data so if I save that and run it then we can see that this looks good it is a list of all of that data okay so now all we have to do is sort this list but we're going to need to write a custom sorting function because Python doesn't know what this data is or how we want it sorted so we need to tell it how we want this sorted now I have a separate more detailed video on how to do custom sorting so I'll leave a link to that video in the description section below but for this example I'll just show you how we can sort this specific list so first I'm going to create a function that will be what we want to use to sort the list so I'm going to remove this print statement here now I'm going to create this sorting function at the top of this file let me close the output here so we can see a little bit better so I'm going to create a function here and I'm just going to call this function install sort and we want to pass in a package as an argument to this function and now we need to return the value that we want to sort on so depending on whether we want to sort by 30 90 or 365 days we'll have to return that value so first let's sort by 30 day installs so I'll just say return package and we want to access the analytics key of each package and we want to return the thirtyday key value from that package and again if you don't know how these sorting functions work then definitely watch my more detailed video on sorting sorting objects so that you can know exactly what's going on here now this is actually going to sort these in ascending order with how we have this right now so packages that have zero installs will be at the beginning and packages with a lot of installs will be at the end now I'd rather see the packages with a lot of installs at the beginning but that's no problem we can simply say reverse equals true when we actually sort this so this function is finished up and now we can go ahead and sort this now we have two ways that we can sort this data we can either sort it in place using the sort method or we can keep the original data unsorted and capture the sorted data in a new variable using the sorted function now I'm just going to sort the data in place in this example so that means we don't have to create a new variable so in order to do this I'm just going to do this here at the bottom I'll say data dot sort and now we want to say key is equal to and this is going to be the function that we use to sort this data so I'm going to pass in the function of install sort now we want to pass in the function itself we don't want to execute the function so we're not putting parentheses here to execute the function we are leaving parentheses off and passing in the function itself and now we also want to set reverse equal to true because like I said this sorting function is going to sort in ascending order we want those in descending order so we'll say reverse is equal to true so now that data should be that should be a sorted list with the most installed packages of the last 30 days at the beginning of the list so let's print this sorted list out and I want this to be readable so I'm going to use the JSON module to dump this to a formatted JSON string just like we did earlier in this video so to do that I'm just going to say data underscore STR is equal to json dot dump s to dump this to a string and we want to dump that data list and I'm going to say indent is equal to two to make sure that that string is properly formatted now I will just print out that data string so if I save that and run it oops accidentally pasted something in there if I save that and run it now let me roll all the way up to the top here gonna have to use this over here then we should see the most installed packages of the last 30 days so we have node we have Python we have get W get yarn so that's pretty interesting and if we look at the 30day totals so this is you know 250,000 here 254 okay so this was 255 254 142 140 so it does look like this is in descending order so that's good now let's compare this to their version on their website to see if this looks similar to what they have so this is the analytics for install on request for the last 30 days we have node Python get W get yarn so those are the same ones that we saw and for the numbers here we have 255 250 for 140 to 140 the results that we got in our custom script now I do think that the way that we build up our custom script does allow us to have some additional functionality that I don't think that they have in their online API for this analytics data so for example if I go back to their website here let me open up the browser again so here is their JSON API for their analytics data for the last 30 days so if I look at this let me make this a little bit larger here I know that this is probably hard for you to see but all they have here are the numbers so number one the rankings and the formula so node is number one they have the counts which we have as well but you can see here that they don't have a description for the package it's just the package name the count and the percentage of downloads so if we wanted to know the description of these packages then we'd have to go to them one by one but with our custom script that we built we do have these descriptions so that also allows us to that allows us to filter by descriptions as well so if I go back to my script let me make this page a little smaller here if I go back to my script then I could simply write a list comprehension here filter out the data based on a certain description so let's say that I only wanted packages that had the word video in the description so in order to do that I could say something like data is equal to and now we'll use a list comprehension and now I can simply say something like item for item in data if the text video let me spell that correctly is in the item description and that description key is des C is how we set it up now if you're unfamiliar with how list comprehensions work then I do have a separate video on those in detail as well and I'll be sure to link a link to that video also in the description section below but what this list comprehension is doing is it's just saying that we want all of the items in data our data list if the item has a description with video in that description so that's what that list comprehension is doing so if I save this and run it and now go up here to the top let me see we got still kind of a long list here so now we can see all of the packages for the last 30 days with video in the description so these are the top packages so we have ffmpeg play recorded convert and stream audio and video youtubedl download YouTube videos from the command line you know vp8 vp9 video codec so that's pretty nice that we have this kind of functionality in our custom script here so if we wanted to get the top packages for the last 365 days with the word video in the item description and let's also just take the top 5 of these packages so if we wanted to just take the top 5 then we could use list slicing just to access those first 5 values so here where I'm dumping the data list to a string I can simply use list slicing and say that I only want up to the fifth item so if I save that and run it then now we're not going to have nearly as many items here we just have five or we should that's one two three four five okay and so the top packages for last year youtubedl is the top one then ffmpeg media info and handbrake okay so that's pretty neat okay so now let me close down that output there okay so that's pretty much it for the manual script that I wrote to sort homebrew packages by popularity like I said I wrote this script before I knew that they had an API that already existed with most of this information but as we saw with being able to narrow down packages with a certain description this definitely has some uses that we can't get from their existing API or at least I don't think that it exists with their current API I could be wrong about that so all in all I definitely think that it was worth the time to write this up also as you build something like this you're gonna get some practice maybe using some tools that you haven't used in a while and it's always good to take on realworld projects like this in order to keep your skills sharp but with that said I think that it's going to do it for this video hopefully you found this interesting and learn some new tricks for solving problems like this that you might run into and projects like this can always be expanded further and further you know you could use matplotlib to graph these out in some cool way or analyze some other part of the data that we're getting from our file or anything like that but if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest ways to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you you
