With timestamps:

00:00 - hey there how's it going everybody so a
00:01 - few weeks ago I released a video on ten
00:04 - Python tips and tricks for writing
00:05 - better code and a lot of you said that
00:07 - you found that video pretty helpful so
00:09 - in this video I've compiled together
00:10 - another list of topics that I thought
00:12 - would be beneficial and that's the five
00:14 - most common mistakes I see from people
00:15 - when using Python and how to avoid those
00:17 - now I get questions every day from
00:19 - people who follow along with my videos
00:21 - and a lot of the questions have to do
00:23 - with the mistakes that we're going to
00:24 - discuss in this video and it's not
00:25 - always obvious what the problem is so
00:28 - we're going to look at the cause and
00:29 - solution to all of these now we do have
00:31 - a sponsor for this video and that skill
00:33 - share calm so I'd like to thank them for
00:35 - supporting the channel and it'd be great
00:36 - if you all could check them out using
00:37 - the link in the description section
00:39 - below and support the sponsors and I'll
00:41 - talk more about their services in just a
00:42 - bit so with that said let's go ahead and
00:44 - get started okay so the first mistake
00:46 - that I'm going to talk about is one that
00:48 - I see a lot with people who are brand
00:49 - new to Python now if you're not new to
00:51 - Python then definitely stick around
00:53 - because we're going to talk about some
00:54 - more advanced issues as well but this is
00:56 - one that I definitely see among people
00:58 - who are just getting started out and
00:59 - that is when people mix tabs and spaces
01:02 - or are inconsistent with their tabs and
01:04 - spaces and that leads to indentation
01:06 - errors so I have a file open up here so
01:09 - let's take a look at what this looks
01:11 - like now the reason that I say that this
01:13 - is usually a mistake by people who are
01:14 - just starting out is because once you
01:16 - get your development environment set up
01:18 - properly then it's almost impossible to
01:20 - run into this problem but people who are
01:22 - just starting out might use some basic
01:24 - text editor where it's possible to mix
01:26 - tabs and spaces so I have my sublime
01:28 - text set up to convert all of my tabs to
01:31 - spaces but let me turn that off and show
01:33 - you what this does so up here in my
01:36 - sublime text settings I'm going to
01:37 - change the settings now if I have more
01:39 - settings here then don't worry about it
01:41 - but I am we can see here that I have
01:43 - mine that set up the translate tabs to
01:46 - spaces and I'm just going to set that to
01:48 - false and now let's see what happens
01:50 - when we mix these so now I just have a
01:52 - basic program here that just loops
01:55 - through a list and squares the numbers
01:57 - so on this line I'm going to unand int
01:59 - this and I'm going to use a tab for that
02:02 - line now for this next line I'm going to
02:05 - uninvent that and I'm going to use
02:06 - spaces for that line so I have one tab
02:09 - here and I have four spaces here so this
02:12 - program just looking at
02:13 - it actually looks correct there's
02:15 - nothing that I can see here that looks
02:16 - wrong but if I run this I'm going to
02:20 - save it and run it we can see that we
02:22 - get an error down here that says
02:23 - indentation err unand dent does not
02:26 - match any outer indentation level and
02:28 - really that exact message might not be
02:30 - very helpful either there's a couple of
02:32 - other indentation errors that give you
02:33 - different messages now if you're new to
02:35 - Python then you're not going to have any
02:37 - clue what that means especially whenever
02:39 - everything just looks fine in your
02:41 - programmatic clients now imagine that
02:43 - this module was a lot larger we just
02:45 - have two indentations here but imagine
02:48 - that we have you know five hundred or
02:50 - thousand lines of code it's going to be
02:52 - almost impossible to go through there
02:54 - and figure out which ones are using tabs
02:56 - and which ones are using spaces so
02:58 - instead of trying to go through and fix
03:00 - those manually I would just highly
03:02 - recommend simply upgrading your editor
03:04 - or IDE that you're using so any good
03:06 - editor for python is going to be able to
03:08 - convert your tabs to spaces
03:10 - automatically so I'm using sublime text
03:12 - but you can set this up in vs code
03:15 - PyCharm Eclipse or whatever it is that
03:18 - you use if you're not using an editor
03:20 - that can do this then I recommend
03:22 - getting a new editor so I'm going to go
03:24 - back in sublime text you do this by
03:27 - changing your settings here and it's
03:29 - just a changed setting where you can set
03:32 - translate tabs to spaces and I'm going
03:34 - to set that to true and now I think I
03:37 - have to make a change to resave this but
03:40 - let's redo this so I'm going to tab that
03:44 - line and I'm going to do spaces on that
03:47 - line now even though those were
03:49 - different if I save this and run it then
03:51 - we can see that our program still works
03:53 - and that is because sublime text
03:55 - automatically changed this tab here to 4
03:58 - spaces so that works nicely now on top
04:01 - of having an editor that does this for
04:03 - you I would also recommend using a tool
04:05 - like pilant that catches more mistakes
04:07 - like this for you that are easy to miss
04:10 - just by looking at your program ok so
04:12 - now let's move on to some slightly more
04:14 - advanced problems so one big problem
04:16 - that I see is when people name their
04:17 - Python modules the same name as
04:20 - something that they're trying to import
04:21 - now when you do this your module with
04:23 - the same name takes higher priority then
04:26 - the modules from the standard
04:27 - library or the modules that you
04:29 - installed using pip so let's see an
04:31 - example of what this would look like so
04:33 - let's say that I have a project where I
04:35 - want to create a Python module that will
04:38 - do some mathematical calculations for me
04:40 - so I'm going to create a new module in
04:42 - my current directory so a new file here
04:46 - and I'm just going to call this math dot
04:48 - pi and now I'm going to use radians and
04:52 - a sine function from the math module in
04:54 - the standard library to make some
04:56 - calculations so I'm going to say from
04:58 - math which is a module in the standard
05:00 - library import radians and I'm also
05:04 - going to import the sine function and
05:07 - then I'll just grab the radians of 90
05:10 - degrees so I'll say rads is equal to
05:12 - radians of 90 degrees and now let's
05:16 - print out the sine of those radians if
05:20 - you don't know the math here don't worry
05:22 - about it that's not what I'm actually
05:24 - that's not what the tutorial is about
05:25 - it's about how the imports are working
05:27 - here so this should print out one here
05:31 - because that is what the sign of these
05:34 - radians should be equal to so if I save
05:36 - this and run it then it seems like this
05:38 - is a nice simple script but now it's
05:41 - saying that we get an import error
05:43 - cannot import named radians for math now
05:46 - this is strange because the math module
05:48 - is in the standard library there's no
05:50 - reason that it shouldn't be able to find
05:52 - that but the reason is because we named
05:54 - our own module math dot pi and python is
05:57 - trying to import radians and sine from
06:00 - our own module instead of the standard
06:03 - library so to fix this all we have to do
06:06 - is rename our module so I'm going to
06:08 - come over here into I know that this
06:10 - sidebar is hard to see here but down
06:12 - here we can say see that our current
06:14 - module is named math.pi I'm just going
06:16 - to rename this to project dot PI and now
06:20 - if I save this and run it then we can
06:23 - see that it runs just fine because it
06:24 - was actually importing the radians and
06:27 - sine from the standard library math
06:29 - module instead of trying to import it
06:31 - from our math module now this is usually
06:33 - pretty easy to catch when you
06:35 - accidentally name something the same as
06:37 - a module from the standard library
06:38 - because if you can't import a module
06:40 - from the standard
06:41 - library then it's pretty limited as to
06:43 - what the problems could be and this is
06:45 - one of them but if this was a package
06:47 - that we pip installed like flask or
06:49 - Django then this could possibly take
06:52 - more time to figure out so there are a
06:54 - lot of times that I've tried to help
06:55 - people debug a problem where they're
06:57 - trying to write a flask application or
06:59 - something like that and they have flask
07:01 - and salt
07:01 - installed and they're using the right
07:03 - version of Python but when they go to
07:05 - import flask it throws an import error
07:07 - and sometimes it takes me a while to
07:09 - figure it out because they only send me
07:11 - their code but not their file name so my
07:14 - initial reaction or my initial intuition
07:16 - with import errors is that it's probably
07:19 - something with their path it's an issue
07:21 - with their path but then later I'll
07:23 - finally realize that they named their
07:25 - module flask dot PI and that's going to
07:28 - interfere with the flask that they're
07:30 - trying to import so if you ever get an
07:32 - import error then it can definitely be
07:34 - an issue with your path and I've made
07:35 - videos on that in the past but sometimes
07:38 - it's as simple as having your file name
07:40 - the same thing as the module that you're
07:41 - trying to import now we can also make
07:43 - naming mistakes when we're trying to
07:45 - name a variable and that's whenever we
07:47 - name a variable the same thing as
07:49 - something else that you'd like to use so
07:50 - there's nothing that prevents us from
07:52 - creating a variable with the same name
07:54 - as something else in Python so for
07:56 - example let's say that instead of
07:58 - calling our variable here RADS
08:00 - let's just say that i wasn't really
08:02 - thinking at the time and instead i just
08:04 - called that radians but radians is the
08:07 - same name as the function that we're
08:09 - importing here so if I change that
08:13 - variable there and I also change the
08:15 - print statement there to use those
08:17 - radians if I save that and run it then
08:20 - the code still runs and it looks like it
08:22 - works fine but now let's try to use the
08:24 - radians function again further down so
08:27 - I'm going to comment out this print
08:29 - statement and I'm going to say you know
08:31 - rad 45 is equal to radians of 45 degrees
08:36 - and now let's print out rad 45 if I save
08:40 - that and run it then now it's giving us
08:43 - an issue here and this might not make
08:44 - sense immediately it's saying float
08:46 - object is not callable now the reason is
08:49 - because we created a variable up here
08:51 - called radians that is equal to
08:54 - radians of 90 degrees which is some
08:57 - float value so anytime we reference
09:00 - radians
09:00 - after that assignment it's going to use
09:03 - that radians variable and not the
09:05 - radians function that we imported so
09:07 - that's why when we say that we want the
09:09 - radians of 45 degrees Python is telling
09:12 - us that radians isn't a function it's a
09:15 - float value and the float value isn't
09:16 - callable like we're trying to call it
09:18 - here so a lot of people get frustrated
09:20 - with Python when things like this happen
09:22 - to them for the first time but Python
09:24 - isn't a compiled language in the sense
09:26 - where it's going to pick these things up
09:28 - before we run the code and it also
09:31 - doesn't hold your hand and give the
09:32 - developer those types of restrictions it
09:35 - gives you a lot of freedom but sometimes
09:37 - that freedom allows us to do things like
09:39 - this where we don't think that we should
09:41 - actually be able to do this like
09:43 - overriding a function like this but it's
09:45 - just how it works so that freedom allows
09:47 - us to do a lot of cool things with
09:49 - Python and allows us to write code very
09:50 - quickly but we can also step on our own
09:52 - toes if we aren't careful so we can see
09:55 - if I simply named this something else
09:58 - like rad 90 or rads or something like
10:01 - that and run that then we can see that
10:03 - now it works fine okay so the next thing
10:06 - that I've seen some people get tripped
10:07 - up on is mutable default arguments and I
10:10 - had an example of this in my
10:11 - object-oriented series where I had a
10:13 - function that added employees to a list
10:15 - and a lot of people ask me why I just
10:17 - didn't pass in an empty list as a
10:19 - default argument and I told them it was
10:21 - because of this problem with mutable
10:23 - default arguments and we'll see why in
10:26 - an example here that's similar to the
10:28 - one that I had in that video so let me
10:30 - close down my output here and also close
10:33 - my sidebar so here we have a function
10:35 - called add employee
10:37 - so let me explain what this function is
10:39 - meant to do so it takes in a single
10:42 - employee and also an employee list as
10:46 - arguments and it's simply going to add
10:49 - that employee to this employee list and
10:52 - then print that list but we can see here
10:54 - that the employee list has a default
10:57 - value equal to an empty list so if we
11:01 - don't pass an employee list to the
11:03 - function then it should just create a
11:05 - new list for us from scratch so let's
11:08 - see
11:08 - what this does so I have an existing
11:10 - list of employees down here so let me
11:13 - add a new employee to that list using
11:16 - that add employee function so I'm just
11:18 - going to say add employee and I'll add
11:21 - Cory as the employee and the list that
11:24 - we want to add this to is just going to
11:26 - be this emps list here so if I run this
11:31 - then it should print out this employee
11:33 - list here with this new employee added
11:36 - on so if I save that and run it then we
11:38 - can see that that looks good we have our
11:39 - existing list and that employee was
11:41 - appended to that list okay but now let's
11:44 - add a couple of employees without
11:45 - providing an existing list so I'm going
11:48 - to take away our existing list and now
11:51 - it should just use this empty list as a
11:54 - default so now let me add a couple here
11:57 - so I'll add Cory and I'll also add John
12:00 - so we would think that both times we run
12:03 - this that we'll get a new list of one
12:06 - person because we're not passing in an
12:08 - existing list so it should use an empty
12:11 - list by default for both of these each
12:13 - time the function is called but if I run
12:16 - this we can see that our first value
12:18 - created a new list but our second add
12:21 - employee here it got added on to that
12:25 - list well which is kind of strange and
12:28 - this will actually keep going so if I
12:30 - add a another employee here and I'm
12:33 - still not providing an existing list it
12:35 - should be creating a new list every time
12:37 - but each time the list just gets longer
12:39 - and longer and keeps appending to the
12:41 - same list even though we should have
12:44 - that empty list by default so what's
12:46 - going on here is that in Python default
12:49 - arguments are evaluated once at the time
12:52 - it creates the function so it's not
12:54 - actually creating a new empty list each
12:57 - time we run the function now you won't
13:00 - notice this with immutable types like
13:01 - strings and things like that but with
13:04 - mutable data types like a list and it's
13:07 - using the same list that it created when
13:09 - the function was defined so what do what
13:13 - do we do here if we want to be sure that
13:15 - we get an empty list each time so to do
13:17 - this instead we're going to want to do
13:20 - something like this so
13:22 - instead of passing in an immutable
13:24 - default type and lists are mutable we
13:28 - just want to pass in Employee List is
13:30 - equal to none and now down here within
13:34 - the function we can say if employee list
13:37 - is none or you can say if not employee
13:41 - list either one then we can create an
13:44 - employee list equal to a new empty list
13:48 - so now that this is actually within the
13:51 - function this will get run every time
13:53 - the function is run because like I said
13:55 - these only get evaluated once when we
13:58 - initialize the function so now if I run
14:01 - this that we can see that it works as
14:03 - expected it creates a new empty list
14:06 - each time we add an employee without an
14:08 - existing employee list and this should
14:10 - still work the same as before as well if
14:13 - we do and provide an employee list
14:16 - already then it just gets tacked on to
14:19 - that existing list so this is how you do
14:21 - mutable default arguments now this
14:24 - doesn't only give us unexpected problems
14:25 - with lists when I said that default
14:28 - arguments are executed once when the
14:29 - function is created and not each time
14:31 - the function is called then you can
14:33 - probably think of some other examples
14:35 - where this might not give us what you
14:37 - think is the desired behavior so for
14:39 - example let's say that I have a function
14:41 - like I have commented out down here let
14:45 - me just get rid of our current example
14:47 - here and I will uncomment this other
14:51 - example that I've created here so here I
14:54 - have a function called display time and
14:56 - it will print out a time in a specific
14:59 - format that I have specified here now it
15:03 - takes time as an argument and time has a
15:07 - default value here set to date/time dot
15:11 - now and that is if we don't provide a
15:14 - time then it will use date/time now as
15:18 - the default time so you might expect
15:20 - that every time we run this function it
15:22 - gets the current time if we don't
15:24 - provide one but I'm running this a few
15:27 - times down here at the bottom and
15:28 - sleeping between each function call for
15:31 - one second so if I run this then we
15:34 - might expect
15:36 - this second would be incrementing by one
15:39 - each time because we're sleeping a
15:41 - second between each function call here
15:43 - but we can see that each time it ran it
15:45 - didn't update the time like you might
15:47 - expect
15:48 - now the reason just like before is
15:50 - because it only executes those default
15:52 - arguments once when the function is
15:54 - declared and not each time the function
15:56 - is run so again in order to do this we
16:00 - would instead just need to move this
16:02 - into the function itself so I could do
16:04 - something like this I could just say
16:06 - time is equal to none and if time is
16:10 - none then let's just set the time equal
16:15 - to date/time dot now so now if I run
16:20 - this then we can see that it sleeps one
16:24 - second between the function calls but it
16:27 - actually got the current time since we
16:29 - didn't provide it one so actually
16:31 - knowing how those default arguments work
16:32 - is one thing that I see that trips up a
16:34 - lot of people okay so moving on another
16:37 - question that I get asked a lot and a
16:39 - common mistake that I see is when people
16:41 - don't fully understand how iterators
16:43 - work and how they're exhausted so this
16:46 - is especially true with a lot of people
16:48 - moving from Python to over to Python 3
16:50 - because more things within Python 3 now
16:53 - behave like generators because those are
16:56 - more efficient but it does cause people
16:58 - some confusion so let's take a look at
17:00 - what I mean here so let me close down
17:02 - the output down here so within this file
17:05 - I'm using an example that I've used in
17:08 - videos before I have a list of regular
17:11 - names from comic book characters and I
17:12 - have another list of their superhero
17:14 - names and the two lists are related so
17:17 - the first item of the names list goes
17:19 - with the first item of the superheroes
17:22 - list and they have corresponding indexes
17:24 - that we can use the zip function for
17:26 - like I'm doing here so once I use that
17:29 - zip function then I'm going to print out
17:31 - the result here so first let me show you
17:34 - what this used to print out in Python 2
17:37 - so let me go up here and change my build
17:40 - system and I'm gonna switch over to
17:42 - Python 2 so now I'm using Python 2 so if
17:46 - I run this then by using Python 2 we can
17:48 - see that we get a
17:49 - of those paired items and that's what
17:52 - zip does it zipped up the first item of
17:54 - the names list with the first item of
17:56 - the superhero list so we have Peter
17:59 - Parker and spider-man then Clark Kent
18:01 - and Superman and so on so what if I
18:04 - wanted to loop over these one at a time
18:06 - and print them out if I wanted to do
18:09 - that then I could just simply loop over
18:12 - them and that's what I'm doing in this
18:13 - commented section here so let me
18:15 - uncomment out this here and I'm actually
18:18 - using the format method here because I'm
18:21 - using Python 2 and F strings won't work
18:23 - in Python 2 so we can see that we have a
18:25 - placeholder here with the first value of
18:29 - the identity which should be Peter
18:31 - Parker and then we have another
18:33 - placeholder for the second value which
18:35 - is spider-man and we're looping over all
18:37 - of these here so it should print those
18:39 - out one at a time so they make this a
18:42 - little larger here and we can see that
18:44 - that is what it does okay so that seems
18:46 - pretty standard for how we would expect
18:49 - this stuff to work but now let me switch
18:51 - over to Python 3 a lot of people just
18:53 - try to directly run their code from
18:56 - Python 2 in Python 3 and expect the same
18:58 - results but with things like zip they
19:02 - might behave a bit differently so now
19:04 - I've switched over to using Python 3 and
19:06 - now let me run this same code so it kind
19:10 - of looks the same we still are looping
19:12 - through the values here but now whenever
19:14 - we print it out these identities we
19:16 - instead get this zip object instead of
19:19 - that entire list of those zip titles
19:22 - so what's going on here is that python 3
19:24 - no longer returns all of those values at
19:27 - once and that's good for efficiency
19:29 - because if this was a huge list of you
19:32 - know millions of values then we're going
19:34 - to save memory but it might not be what
19:36 - you expect now if you watch my videos on
19:39 - generators and in raters then you know
19:41 - that we can get all of those values at
19:43 - once but we'll have to cast them to a
19:46 - list so let me create a list of our zip
19:49 - object here so I'm just going to pass
19:51 - that into a list here so now if I save
19:55 - that and run it then now we get that
19:57 - full list of our zip items but now it's
20:01 - no longer looping through and print
20:03 - these items here within our loop so this
20:06 - is where a lot of people usually get
20:07 - frustrated if they don't know what's
20:09 - going on now I have a lot of older
20:11 - videos on Python too where people try to
20:13 - follow along in Python 3 and they run
20:15 - into issue issues just like this and you
20:18 - know leave comments and send me emails
20:19 - asking me what's going on so what's
20:21 - happening here is that zip is an
20:23 - iterator like I said and iterators can
20:26 - be exhausted and that means that we can
20:28 - loop through and access that our values
20:30 - one time but then we can't do it again
20:33 - so that might not make sense but like I
20:35 - said it all comes down to performance
20:37 - and efficiency and really once you know
20:40 - that it really isn't a big deal you can
20:42 - still do everything that you used to be
20:44 - able to do but you just have to do it in
20:46 - a slightly different way so here we're
20:49 - converting our zip object to a list and
20:51 - then trying to loop over that same zip
20:54 - object again but we've already exhausted
20:56 - the zip the zip object when we converted
20:59 - it to a list at this line here when we
21:02 - did this it looped through all those
21:04 - values and converted them to a list and
21:06 - then we printed them out so now when
21:08 - we're trying to loop over that here it's
21:11 - not working because this has been
21:12 - exhausted and there's no more values
21:14 - left here but if you wanted to print the
21:16 - values out and also loop over them then
21:18 - we could simply convert it to a list
21:20 - from the start and then print that list
21:22 - and then loop over it just like we would
21:24 - with any other list so instead of
21:27 - printing out this list of identities
21:29 - here and not capturing that value
21:31 - instead I'm just going to convert this
21:34 - to a list from the start and now we've
21:36 - captured that into a list here so now I
21:39 - can print out those identities and also
21:43 - loop over them because now this is a
21:44 - list and lists are not exhausted like
21:47 - other iterators or generators so now if
21:50 - we run this then we can see that we get
21:51 - the same result that we got in Python 2
21:53 - now if you'd like more details on how
21:55 - generators and iterators work then I do
21:57 - have videos on both of those topics in
22:00 - this video I just really wanted to touch
22:02 - on the confusion that I see from some
22:03 - people on not understanding how
22:05 - iterators can be exhausted and when they
22:08 - are why you can no longer access those
22:10 - values again a second time through ok so
22:14 - now the last thing that I want to
22:15 - discuss
22:16 - is imports and a bad practice that I see
22:18 - sometimes that can cause some errors and
22:21 - even if the code doesn't cause errors it
22:23 - can definitely make it harder to debug
22:25 - your code so the bad practice that I'm
22:27 - talking about is using an asterisks when
22:30 - doing imports now if you don't know what
22:32 - using an asterisks on imports does
22:35 - basically it just imports everything
22:37 - from a given module so for example I
22:39 - could import a module by doing something
22:42 - like this I could do import OS and then
22:45 - if I wanted to rename a file then I
22:48 - could do something like OS dot
22:51 - rename and then we could just pass in a
22:54 - file name here so for every function
22:57 - from the OS module I would have to say
23:00 - OS dot and then the function name like
23:02 - we're doing here Oh s dot meaning but we
23:04 - can also import functions one out of
23:06 - time to where we don't need to use OS
23:09 - dot so for example if I just wanted to
23:11 - use rename a file name then instead I
23:14 - could say from OS import rename and now
23:19 - we no longer need to say oh s dot rename
23:22 - we can simply just use the rename
23:24 - function but for each additional
23:25 - function that I wanted to use I would
23:28 - have to add that on to the import so if
23:30 - I wanted to use the remove function to
23:33 - remove a file then I would have to add
23:35 - that to my imports here so from OS
23:38 - import rename and import remove and then
23:41 - I'm also going to be able to use that
23:42 - remove function now we can also use an
23:44 - asterisk on the import to just simply
23:47 - import everything but this is a bad
23:49 - practice most of the time unless you
23:51 - really know what you're doing but
23:53 - sometimes people just want to be able to
23:54 - use everything and not think about it so
23:56 - they'll just come up here and say from
23:58 - OS import asterisk import star and that
24:02 - will allow us to use rename and remove
24:05 - and anything else that is in the OS
24:08 - module without using OS dot ok but why
24:11 - is this a bad practice so first of all
24:13 - it can make your code hard to debug
24:15 - so if our module was 500 lines of code
24:18 - here and halfway down I used this rename
24:21 - function then other people reading our
24:23 - code or even us in the future when we
24:25 - come back to read our code we're gonna
24:26 - wonder you know where is this rename
24:28 - function come
24:29 - from I need to go read that and see
24:32 - where its declared so that I can
24:33 - understand what it's doing but they're
24:35 - not going to know where it was declared
24:37 - because it's hidden within this
24:38 - asterisks and it isn't it's explicit if
24:41 - we were to actually say from OS import
24:44 - rename then we could come up to the top
24:46 - and say all okay there is where that
24:47 - rename function is coming from we
24:49 - imported it from the OS module now not
24:51 - only does it make it hard to debug but
24:53 - it can also introduce errors into our
24:55 - code whenever there are two functions
24:57 - with the same name so for example let's
25:00 - say I did something like this what if I
25:02 - said from HTML import star and then from
25:06 - glob import star both of these are
25:10 - standard library modules and I'm
25:12 - importing everything from both of those
25:14 - modules but the HTML and the glob
25:17 - modules both have an escape function and
25:20 - one escapes HTML special characters from
25:24 - the HTML module and the other escapes
25:27 - special characters in a path and that's
25:29 - from the glob module so in this case
25:31 - which escape module is actually getting
25:33 - imported so the HTML xscape function
25:37 - will be overwritten by the glob escape
25:40 - function so if I was to say print help
25:43 - on escape if I save that and run it then
25:48 - we can see that our output down here
25:49 - says help on function escape in the
25:52 - module glob so by importing using these
25:55 - asterisks it's just extremely easy to
25:57 - confuse people reading your code and
25:59 - it's a pain to debug and also it can
26:01 - cause issues like this so anytime you
26:05 - need to actually import from a module
26:07 - then it's better to instead just import
26:11 - it explicitly so if I wanted to import
26:13 - both of these then I could just say
26:15 - import escape and import escape now
26:19 - those are still going to be overwritten
26:21 - so we have to rename these so I could
26:23 - say import as h underscore escape and as
26:26 - g underscore escape and now when we use
26:30 - the HTML escape we would use this one
26:32 - and when we use the glove escape we
26:34 - would use this one or if you wanted to
26:36 - just import the entire module then you
26:39 - could just say you know import HTML and
26:41 - import
26:43 - glob and then when you use those you
26:45 - could just use HTML that escape and use
26:50 - glob dot escape so that is the best way
26:54 - to do it definitely you're just going to
26:56 - confuse people and opt you skate your
26:59 - code if you use those asterisks imports
27:01 - okay so before we in this video I want
27:03 - to mention the sponsor for this video
27:05 - and that is Skillshare Skillshare is an
27:08 - online learning community with more than
27:10 - 25,000 classes in tech business design
27:13 - and a lot of other topics they have over
27:16 - 7 million students so far and they have
27:17 - new courses coming out on a regular
27:19 - basis now my audience would most likely
27:21 - be interested in their programming
27:23 - courses and you can see here that they
27:25 - have classes in data science data
27:27 - visualization they have some courses in
27:29 - introduction to programming and computer
27:31 - science deep learning and neural
27:34 - networks using Python they have some SQL
27:37 - courses and all kinds of different
27:39 - popular series that you can find it
27:41 - useful
27:41 - now I'm also frequently asked how I make
27:44 - youtube videos and if I have any tips
27:46 - for any of you who would like to start a
27:48 - channel now I may do some videos like
27:50 - these in the future
27:52 - but Skillshare is really the place to go
27:54 - to learn about something like this they
27:55 - have courses specifically on YouTube and
27:58 - how to grow that as a business and if
28:00 - you're more focused on film production
28:02 - rather than YouTube itself then they
28:04 - also have a wide variety of courses on
28:06 - videography and photography as well so I
28:09 - want to thank Skillshare for sponsoring
28:11 - this video and it would be great if you
28:12 - could go and check them out and support
28:14 - the sponsors for this channel and
28:15 - they've provided me with a sign-up link
28:17 - that I'll post in the description
28:18 - section below and the first 500 people
28:20 - to sign up using that link will get two
28:22 - free months of Skillshare premium so
28:24 - that you can check it out and see how
28:26 - you like it ok so I think that it's
28:28 - going to do it for this video I hope
28:29 - that you found it useful to go over this
28:31 - overview of some of the most common
28:32 - mistakes that I usually see and also I'm
28:35 - interested if there are any problems
28:36 - that I didn't cover here that you run
28:38 - into in your daily coding so if you want
28:40 - be sure to comment those in the
28:41 - description section below now if anyone
28:43 - has any questions about what we covered
28:45 - here then feel free to ask in the
28:46 - comment section below and I'll do my
28:47 - best to answer those and if you enjoy
28:49 - these tutorials and would like to
28:50 - support them then there are several ways
28:51 - you can do that the easiest ways to
28:53 - simply like the video and give it a
28:54 - thumbs up and also it's a huge help to
28:56 - share these video
28:57 - with anyone who you think wouldn't find
28:58 - them useful and if you have the means
28:59 - you can contribute through patreon and
29:01 - there's a link to that page in the
29:02 - description section below be sure to
29:04 - subscribe for future videos and thank
29:05 - you all for watching
29:17 - you

Cleaned transcript:

hey there how's it going everybody so a few weeks ago I released a video on ten Python tips and tricks for writing better code and a lot of you said that you found that video pretty helpful so in this video I've compiled together another list of topics that I thought would be beneficial and that's the five most common mistakes I see from people when using Python and how to avoid those now I get questions every day from people who follow along with my videos and a lot of the questions have to do with the mistakes that we're going to discuss in this video and it's not always obvious what the problem is so we're going to look at the cause and solution to all of these now we do have a sponsor for this video and that skill share calm so I'd like to thank them for supporting the channel and it'd be great if you all could check them out using the link in the description section below and support the sponsors and I'll talk more about their services in just a bit so with that said let's go ahead and get started okay so the first mistake that I'm going to talk about is one that I see a lot with people who are brand new to Python now if you're not new to Python then definitely stick around because we're going to talk about some more advanced issues as well but this is one that I definitely see among people who are just getting started out and that is when people mix tabs and spaces or are inconsistent with their tabs and spaces and that leads to indentation errors so I have a file open up here so let's take a look at what this looks like now the reason that I say that this is usually a mistake by people who are just starting out is because once you get your development environment set up properly then it's almost impossible to run into this problem but people who are just starting out might use some basic text editor where it's possible to mix tabs and spaces so I have my sublime text set up to convert all of my tabs to spaces but let me turn that off and show you what this does so up here in my sublime text settings I'm going to change the settings now if I have more settings here then don't worry about it but I am we can see here that I have mine that set up the translate tabs to spaces and I'm just going to set that to false and now let's see what happens when we mix these so now I just have a basic program here that just loops through a list and squares the numbers so on this line I'm going to unand int this and I'm going to use a tab for that line now for this next line I'm going to uninvent that and I'm going to use spaces for that line so I have one tab here and I have four spaces here so this program just looking at it actually looks correct there's nothing that I can see here that looks wrong but if I run this I'm going to save it and run it we can see that we get an error down here that says indentation err unand dent does not match any outer indentation level and really that exact message might not be very helpful either there's a couple of other indentation errors that give you different messages now if you're new to Python then you're not going to have any clue what that means especially whenever everything just looks fine in your programmatic clients now imagine that this module was a lot larger we just have two indentations here but imagine that we have you know five hundred or thousand lines of code it's going to be almost impossible to go through there and figure out which ones are using tabs and which ones are using spaces so instead of trying to go through and fix those manually I would just highly recommend simply upgrading your editor or IDE that you're using so any good editor for python is going to be able to convert your tabs to spaces automatically so I'm using sublime text but you can set this up in vs code PyCharm Eclipse or whatever it is that you use if you're not using an editor that can do this then I recommend getting a new editor so I'm going to go back in sublime text you do this by changing your settings here and it's just a changed setting where you can set translate tabs to spaces and I'm going to set that to true and now I think I have to make a change to resave this but let's redo this so I'm going to tab that line and I'm going to do spaces on that line now even though those were different if I save this and run it then we can see that our program still works and that is because sublime text automatically changed this tab here to 4 spaces so that works nicely now on top of having an editor that does this for you I would also recommend using a tool like pilant that catches more mistakes like this for you that are easy to miss just by looking at your program ok so now let's move on to some slightly more advanced problems so one big problem that I see is when people name their Python modules the same name as something that they're trying to import now when you do this your module with the same name takes higher priority then the modules from the standard library or the modules that you installed using pip so let's see an example of what this would look like so let's say that I have a project where I want to create a Python module that will do some mathematical calculations for me so I'm going to create a new module in my current directory so a new file here and I'm just going to call this math dot pi and now I'm going to use radians and a sine function from the math module in the standard library to make some calculations so I'm going to say from math which is a module in the standard library import radians and I'm also going to import the sine function and then I'll just grab the radians of 90 degrees so I'll say rads is equal to radians of 90 degrees and now let's print out the sine of those radians if you don't know the math here don't worry about it that's not what I'm actually that's not what the tutorial is about it's about how the imports are working here so this should print out one here because that is what the sign of these radians should be equal to so if I save this and run it then it seems like this is a nice simple script but now it's saying that we get an import error cannot import named radians for math now this is strange because the math module is in the standard library there's no reason that it shouldn't be able to find that but the reason is because we named our own module math dot pi and python is trying to import radians and sine from our own module instead of the standard library so to fix this all we have to do is rename our module so I'm going to come over here into I know that this sidebar is hard to see here but down here we can say see that our current module is named math.pi I'm just going to rename this to project dot PI and now if I save this and run it then we can see that it runs just fine because it was actually importing the radians and sine from the standard library math module instead of trying to import it from our math module now this is usually pretty easy to catch when you accidentally name something the same as a module from the standard library because if you can't import a module from the standard library then it's pretty limited as to what the problems could be and this is one of them but if this was a package that we pip installed like flask or Django then this could possibly take more time to figure out so there are a lot of times that I've tried to help people debug a problem where they're trying to write a flask application or something like that and they have flask and salt installed and they're using the right version of Python but when they go to import flask it throws an import error and sometimes it takes me a while to figure it out because they only send me their code but not their file name so my initial reaction or my initial intuition with import errors is that it's probably something with their path it's an issue with their path but then later I'll finally realize that they named their module flask dot PI and that's going to interfere with the flask that they're trying to import so if you ever get an import error then it can definitely be an issue with your path and I've made videos on that in the past but sometimes it's as simple as having your file name the same thing as the module that you're trying to import now we can also make naming mistakes when we're trying to name a variable and that's whenever we name a variable the same thing as something else that you'd like to use so there's nothing that prevents us from creating a variable with the same name as something else in Python so for example let's say that instead of calling our variable here RADS let's just say that i wasn't really thinking at the time and instead i just called that radians but radians is the same name as the function that we're importing here so if I change that variable there and I also change the print statement there to use those radians if I save that and run it then the code still runs and it looks like it works fine but now let's try to use the radians function again further down so I'm going to comment out this print statement and I'm going to say you know rad 45 is equal to radians of 45 degrees and now let's print out rad 45 if I save that and run it then now it's giving us an issue here and this might not make sense immediately it's saying float object is not callable now the reason is because we created a variable up here called radians that is equal to radians of 90 degrees which is some float value so anytime we reference radians after that assignment it's going to use that radians variable and not the radians function that we imported so that's why when we say that we want the radians of 45 degrees Python is telling us that radians isn't a function it's a float value and the float value isn't callable like we're trying to call it here so a lot of people get frustrated with Python when things like this happen to them for the first time but Python isn't a compiled language in the sense where it's going to pick these things up before we run the code and it also doesn't hold your hand and give the developer those types of restrictions it gives you a lot of freedom but sometimes that freedom allows us to do things like this where we don't think that we should actually be able to do this like overriding a function like this but it's just how it works so that freedom allows us to do a lot of cool things with Python and allows us to write code very quickly but we can also step on our own toes if we aren't careful so we can see if I simply named this something else like rad 90 or rads or something like that and run that then we can see that now it works fine okay so the next thing that I've seen some people get tripped up on is mutable default arguments and I had an example of this in my objectoriented series where I had a function that added employees to a list and a lot of people ask me why I just didn't pass in an empty list as a default argument and I told them it was because of this problem with mutable default arguments and we'll see why in an example here that's similar to the one that I had in that video so let me close down my output here and also close my sidebar so here we have a function called add employee so let me explain what this function is meant to do so it takes in a single employee and also an employee list as arguments and it's simply going to add that employee to this employee list and then print that list but we can see here that the employee list has a default value equal to an empty list so if we don't pass an employee list to the function then it should just create a new list for us from scratch so let's see what this does so I have an existing list of employees down here so let me add a new employee to that list using that add employee function so I'm just going to say add employee and I'll add Cory as the employee and the list that we want to add this to is just going to be this emps list here so if I run this then it should print out this employee list here with this new employee added on so if I save that and run it then we can see that that looks good we have our existing list and that employee was appended to that list okay but now let's add a couple of employees without providing an existing list so I'm going to take away our existing list and now it should just use this empty list as a default so now let me add a couple here so I'll add Cory and I'll also add John so we would think that both times we run this that we'll get a new list of one person because we're not passing in an existing list so it should use an empty list by default for both of these each time the function is called but if I run this we can see that our first value created a new list but our second add employee here it got added on to that list well which is kind of strange and this will actually keep going so if I add a another employee here and I'm still not providing an existing list it should be creating a new list every time but each time the list just gets longer and longer and keeps appending to the same list even though we should have that empty list by default so what's going on here is that in Python default arguments are evaluated once at the time it creates the function so it's not actually creating a new empty list each time we run the function now you won't notice this with immutable types like strings and things like that but with mutable data types like a list and it's using the same list that it created when the function was defined so what do what do we do here if we want to be sure that we get an empty list each time so to do this instead we're going to want to do something like this so instead of passing in an immutable default type and lists are mutable we just want to pass in Employee List is equal to none and now down here within the function we can say if employee list is none or you can say if not employee list either one then we can create an employee list equal to a new empty list so now that this is actually within the function this will get run every time the function is run because like I said these only get evaluated once when we initialize the function so now if I run this that we can see that it works as expected it creates a new empty list each time we add an employee without an existing employee list and this should still work the same as before as well if we do and provide an employee list already then it just gets tacked on to that existing list so this is how you do mutable default arguments now this doesn't only give us unexpected problems with lists when I said that default arguments are executed once when the function is created and not each time the function is called then you can probably think of some other examples where this might not give us what you think is the desired behavior so for example let's say that I have a function like I have commented out down here let me just get rid of our current example here and I will uncomment this other example that I've created here so here I have a function called display time and it will print out a time in a specific format that I have specified here now it takes time as an argument and time has a default value here set to date/time dot now and that is if we don't provide a time then it will use date/time now as the default time so you might expect that every time we run this function it gets the current time if we don't provide one but I'm running this a few times down here at the bottom and sleeping between each function call for one second so if I run this then we might expect this second would be incrementing by one each time because we're sleeping a second between each function call here but we can see that each time it ran it didn't update the time like you might expect now the reason just like before is because it only executes those default arguments once when the function is declared and not each time the function is run so again in order to do this we would instead just need to move this into the function itself so I could do something like this I could just say time is equal to none and if time is none then let's just set the time equal to date/time dot now so now if I run this then we can see that it sleeps one second between the function calls but it actually got the current time since we didn't provide it one so actually knowing how those default arguments work is one thing that I see that trips up a lot of people okay so moving on another question that I get asked a lot and a common mistake that I see is when people don't fully understand how iterators work and how they're exhausted so this is especially true with a lot of people moving from Python to over to Python 3 because more things within Python 3 now behave like generators because those are more efficient but it does cause people some confusion so let's take a look at what I mean here so let me close down the output down here so within this file I'm using an example that I've used in videos before I have a list of regular names from comic book characters and I have another list of their superhero names and the two lists are related so the first item of the names list goes with the first item of the superheroes list and they have corresponding indexes that we can use the zip function for like I'm doing here so once I use that zip function then I'm going to print out the result here so first let me show you what this used to print out in Python 2 so let me go up here and change my build system and I'm gonna switch over to Python 2 so now I'm using Python 2 so if I run this then by using Python 2 we can see that we get a of those paired items and that's what zip does it zipped up the first item of the names list with the first item of the superhero list so we have Peter Parker and spiderman then Clark Kent and Superman and so on so what if I wanted to loop over these one at a time and print them out if I wanted to do that then I could just simply loop over them and that's what I'm doing in this commented section here so let me uncomment out this here and I'm actually using the format method here because I'm using Python 2 and F strings won't work in Python 2 so we can see that we have a placeholder here with the first value of the identity which should be Peter Parker and then we have another placeholder for the second value which is spiderman and we're looping over all of these here so it should print those out one at a time so they make this a little larger here and we can see that that is what it does okay so that seems pretty standard for how we would expect this stuff to work but now let me switch over to Python 3 a lot of people just try to directly run their code from Python 2 in Python 3 and expect the same results but with things like zip they might behave a bit differently so now I've switched over to using Python 3 and now let me run this same code so it kind of looks the same we still are looping through the values here but now whenever we print it out these identities we instead get this zip object instead of that entire list of those zip titles so what's going on here is that python 3 no longer returns all of those values at once and that's good for efficiency because if this was a huge list of you know millions of values then we're going to save memory but it might not be what you expect now if you watch my videos on generators and in raters then you know that we can get all of those values at once but we'll have to cast them to a list so let me create a list of our zip object here so I'm just going to pass that into a list here so now if I save that and run it then now we get that full list of our zip items but now it's no longer looping through and print these items here within our loop so this is where a lot of people usually get frustrated if they don't know what's going on now I have a lot of older videos on Python too where people try to follow along in Python 3 and they run into issue issues just like this and you know leave comments and send me emails asking me what's going on so what's happening here is that zip is an iterator like I said and iterators can be exhausted and that means that we can loop through and access that our values one time but then we can't do it again so that might not make sense but like I said it all comes down to performance and efficiency and really once you know that it really isn't a big deal you can still do everything that you used to be able to do but you just have to do it in a slightly different way so here we're converting our zip object to a list and then trying to loop over that same zip object again but we've already exhausted the zip the zip object when we converted it to a list at this line here when we did this it looped through all those values and converted them to a list and then we printed them out so now when we're trying to loop over that here it's not working because this has been exhausted and there's no more values left here but if you wanted to print the values out and also loop over them then we could simply convert it to a list from the start and then print that list and then loop over it just like we would with any other list so instead of printing out this list of identities here and not capturing that value instead I'm just going to convert this to a list from the start and now we've captured that into a list here so now I can print out those identities and also loop over them because now this is a list and lists are not exhausted like other iterators or generators so now if we run this then we can see that we get the same result that we got in Python 2 now if you'd like more details on how generators and iterators work then I do have videos on both of those topics in this video I just really wanted to touch on the confusion that I see from some people on not understanding how iterators can be exhausted and when they are why you can no longer access those values again a second time through ok so now the last thing that I want to discuss is imports and a bad practice that I see sometimes that can cause some errors and even if the code doesn't cause errors it can definitely make it harder to debug your code so the bad practice that I'm talking about is using an asterisks when doing imports now if you don't know what using an asterisks on imports does basically it just imports everything from a given module so for example I could import a module by doing something like this I could do import OS and then if I wanted to rename a file then I could do something like OS dot rename and then we could just pass in a file name here so for every function from the OS module I would have to say OS dot and then the function name like we're doing here Oh s dot meaning but we can also import functions one out of time to where we don't need to use OS dot so for example if I just wanted to use rename a file name then instead I could say from OS import rename and now we no longer need to say oh s dot rename we can simply just use the rename function but for each additional function that I wanted to use I would have to add that on to the import so if I wanted to use the remove function to remove a file then I would have to add that to my imports here so from OS import rename and import remove and then I'm also going to be able to use that remove function now we can also use an asterisk on the import to just simply import everything but this is a bad practice most of the time unless you really know what you're doing but sometimes people just want to be able to use everything and not think about it so they'll just come up here and say from OS import asterisk import star and that will allow us to use rename and remove and anything else that is in the OS module without using OS dot ok but why is this a bad practice so first of all it can make your code hard to debug so if our module was 500 lines of code here and halfway down I used this rename function then other people reading our code or even us in the future when we come back to read our code we're gonna wonder you know where is this rename function come from I need to go read that and see where its declared so that I can understand what it's doing but they're not going to know where it was declared because it's hidden within this asterisks and it isn't it's explicit if we were to actually say from OS import rename then we could come up to the top and say all okay there is where that rename function is coming from we imported it from the OS module now not only does it make it hard to debug but it can also introduce errors into our code whenever there are two functions with the same name so for example let's say I did something like this what if I said from HTML import star and then from glob import star both of these are standard library modules and I'm importing everything from both of those modules but the HTML and the glob modules both have an escape function and one escapes HTML special characters from the HTML module and the other escapes special characters in a path and that's from the glob module so in this case which escape module is actually getting imported so the HTML xscape function will be overwritten by the glob escape function so if I was to say print help on escape if I save that and run it then we can see that our output down here says help on function escape in the module glob so by importing using these asterisks it's just extremely easy to confuse people reading your code and it's a pain to debug and also it can cause issues like this so anytime you need to actually import from a module then it's better to instead just import it explicitly so if I wanted to import both of these then I could just say import escape and import escape now those are still going to be overwritten so we have to rename these so I could say import as h underscore escape and as g underscore escape and now when we use the HTML escape we would use this one and when we use the glove escape we would use this one or if you wanted to just import the entire module then you could just say you know import HTML and import glob and then when you use those you could just use HTML that escape and use glob dot escape so that is the best way to do it definitely you're just going to confuse people and opt you skate your code if you use those asterisks imports okay so before we in this video I want to mention the sponsor for this video and that is Skillshare Skillshare is an online learning community with more than 25,000 classes in tech business design and a lot of other topics they have over 7 million students so far and they have new courses coming out on a regular basis now my audience would most likely be interested in their programming courses and you can see here that they have classes in data science data visualization they have some courses in introduction to programming and computer science deep learning and neural networks using Python they have some SQL courses and all kinds of different popular series that you can find it useful now I'm also frequently asked how I make youtube videos and if I have any tips for any of you who would like to start a channel now I may do some videos like these in the future but Skillshare is really the place to go to learn about something like this they have courses specifically on YouTube and how to grow that as a business and if you're more focused on film production rather than YouTube itself then they also have a wide variety of courses on videography and photography as well so I want to thank Skillshare for sponsoring this video and it would be great if you could go and check them out and support the sponsors for this channel and they've provided me with a signup link that I'll post in the description section below and the first 500 people to sign up using that link will get two free months of Skillshare premium so that you can check it out and see how you like it ok so I think that it's going to do it for this video I hope that you found it useful to go over this overview of some of the most common mistakes that I usually see and also I'm interested if there are any problems that I didn't cover here that you run into in your daily coding so if you want be sure to comment those in the description section below now if anyone has any questions about what we covered here then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest ways to simply like the video and give it a thumbs up and also it's a huge help to share these video with anyone who you think wouldn't find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
