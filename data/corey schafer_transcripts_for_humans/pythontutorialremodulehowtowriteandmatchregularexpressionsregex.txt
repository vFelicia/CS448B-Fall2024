With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're gonna learn how to work
00:02 - with regular expressions in Python using
00:05 - the built in re module and sometimes
00:07 - you'll hear these called reg X's now I
00:09 - recently released a video on regular
00:11 - expressions as a standalone topic
00:12 - because they can actually be used
00:14 - independently of any one programming
00:16 - language so you can use them to search
00:18 - for text patterns within text editors
00:20 - and things like that so this video will
00:22 - use a lot of those same same examples
00:24 - that I used in that video
00:25 - except here we're going to see a lot
00:27 - more that is Python specific so if
00:29 - you've never used regular expressions
00:31 - they basically allow us to search for
00:33 - and match specific patterns of text and
00:35 - they can look extremely complicated but
00:38 - that's mainly because there's just so
00:39 - much that we can do with them so you can
00:41 - create a regular expression for just
00:43 - about any pattern of text that you can
00:44 - think of so let's look at some examples
00:46 - and see what this looks like
00:48 - so I have a Python module here that
00:49 - we're going to use to search for some
00:51 - simple patterns to start out so first of
00:53 - all to use regular expressions within
00:55 - Python we need to import the re module
00:58 - which obviously stands for regular
01:00 - expressions so I'm doing that up here on
01:02 - line one and the text that we're going
01:04 - to be searching is this multi-line
01:06 - string here so the variable name is text
01:09 - to search and we have a lot of things in
01:11 - here in this multi-line string so you
01:13 - can see at the top we have some lower
01:15 - case some upper case some digits just
01:18 - some special characters a URL phone
01:21 - numbers and some names and also have a
01:23 - simple sentence here that we're going to
01:24 - use in an example as well now before
01:27 - writing our first regular expression we
01:29 - need to know what a raw string is
01:30 - because we're going to be using these a
01:32 - lot throughout this video now a raw
01:34 - string and Python is just a string
01:36 - prefixed with an R and that tells python
01:38 - not to handle back slashes in any
01:41 - special way so for example normally back
01:44 - slashes are used to specify tabs or new
01:46 - lines and things like that so if I was
01:49 - to print out the string backslash T and
01:53 - then just the text tab so if I run this
01:56 - then we can see that Python replaced our
01:59 - backslash T with an actual tab but a raw
02:03 - string will just interpret the string
02:05 - literally so if we put an R in front of
02:08 - this string and then run this then we
02:11 - can see that the backslash is no longer
02:13 - handled in
02:13 - any special way and that's important for
02:15 - us because we want our regular
02:17 - expressions to interpret the strings
02:18 - we're passing in and not have python
02:21 - doing any anything to them first so
02:23 - we'll be using these raw strings
02:25 - throughout the video so just be aware of
02:26 - what these are okay so let's write some
02:28 - expressions and search for some patterns
02:30 - so to write our patterns I'm going to
02:32 - use the re dot compiled method the
02:34 - compiled method will allow us to
02:36 - separate out our patterns into a
02:38 - variable and also we'll make it easier
02:40 - to reuse that variable to perform
02:42 - multiple searches so to use this we can
02:45 - just say that our pattern is equal to re
02:47 - dot compile and now we can specify our
02:51 - pattern so first let's just create a
02:53 - pattern that matches some literal
02:54 - characters so if we just wanted to
02:56 - search for the literal text ABC then we
02:59 - could say our for our raw string and
03:02 - then we could just pass in the literal
03:04 - text ABC and now that we have that
03:06 - pattern specified now let's actually
03:07 - search through our text with that
03:09 - pattern so I'm going to create a
03:11 - variable here called matches and I'm
03:14 - going to set this equal to that pattern
03:16 - dot find it er and I'll explain this
03:19 - more in just a second but what we want
03:21 - to search is our very long string up
03:25 - here at the top our multi-line string
03:27 - called texts at search so I'm going to
03:29 - paste that in and now to print out all
03:31 - of our matches I'm just going to do a
03:34 - for loop and I'm gonna say for match in
03:36 - matches print out the match so if we
03:40 - save that and run it then we can see
03:42 - that this find it err method returns an
03:44 - iterator that contains all of the
03:46 - matches so we're going to look at more
03:48 - regular expression methods later in the
03:49 - video but I think that find it err is
03:51 - one of the best for gathering all of the
03:53 - matches and an easy to read format so
03:55 - each of these Mac match objects shows us
03:59 - the span and the match itself so the
04:02 - span is the beginning and end index of
04:05 - the match so when we search this text
04:07 - with this pattern using the find it err
04:09 - method it only found one match of ABC
04:13 - and it found it in our alphabet from
04:16 - indexes 1 to 4 now these indexes are
04:19 - useful because it allows us to use the
04:21 - string slicing functionality in Python
04:23 - where we could just plug in these values
04:25 - and get the
04:26 - exact match so if I was to print out our
04:30 - string from indexes one two four so I
04:33 - will print out text to search from
04:35 - indexes one two four now if I run that
04:39 - then we can see that we got ABC and that
04:42 - is the exact value that we matched now
04:44 - if you've never seen this string slicing
04:46 - functionality before and would like to
04:48 - see more of what you can do with that
04:49 - then I do have a separate video on that
04:51 - specific topic and I'll put a link to
04:53 - that in the description section below
04:54 - but for now I'll just go ahead and
04:56 - remove that now if I make my screen a
05:01 - little larger here and if we look at our
05:04 - text to search then this is the literal
05:06 - ABC that it matched right here but
05:09 - notice it didn't match this capital ABC
05:12 - and that's because this is case
05:14 - sensetive and this search right now is
05:16 - also looking specifically for ABC in
05:19 - that order
05:20 - so if we were to instead come down here
05:23 - and search for CBA and run that then you
05:27 - can see that we don't get any matches
05:28 - now if we scroll up here and look at
05:30 - this meta character section then I have
05:33 - some examples of characters that I say
05:35 - need to be escaped so say for example
05:37 - that I wanted to search for a literal
05:39 - period now if I just put a period in my
05:42 - search so if I change my pattern to
05:45 - where it is only searching for a period
05:48 - and I run this then we can see where it
05:50 - does this weird thing where it matches
05:52 - almost everything and that's because the
05:55 - dot is a special character and regular
05:56 - expressions and we'll see what that is
05:58 - in just a second but if we just want to
06:01 - actually search for a period then we
06:03 - have to escape it and we can escape
06:05 - these characters with a backslash so
06:07 - within my pattern here I'm going to put
06:10 - a backslash before the period and if I
06:13 - run that then we can see that if we look
06:15 - at all of our matches here then all of
06:18 - these matches are actual literal periods
06:20 - from our text so escaping those
06:23 - characters goes for any of these
06:25 - characters here in the meta characters
06:27 - section that I say needs to be escaped
06:29 - now one practical example of this might
06:31 - be a URL so I have a URL here that is
06:34 - quarry MS calm now if we wanted to match
06:37 - this exact URL then we would need to as
06:40 - scaped the dot in that URL by saying
06:42 - something like so I'll change my search
06:46 - pattern here and I'll just search for a
06:47 - literal quarry ms and then for the dot I
06:50 - would need to escape that dot so
06:52 - backslash dot com so if I save that and
06:55 - run it then we can see that we did match
06:57 - that URL okay so a literal search isn't
06:59 - too exciting because that's something
07:01 - that we probably already know how to do
07:02 - within Python really we want to use
07:04 - regular expressions to search for
07:06 - patterns and to do this we're going to
07:08 - use some of those meta characters that
07:10 - we were just escaping so in my snippets
07:12 - file here I have a list of values where
07:15 - we can see the types of characters that
07:16 - we can match and I'm going to split
07:18 - these into two columns so that it stays
07:20 - in view while we're going over these now
07:23 - I'll just move this over here and then
07:25 - go back to my simple file example that
07:28 - we were just looking at okay so now
07:29 - let's walk through each of these and see
07:31 - what we can match using regular
07:33 - expressions so we can see that the dot
07:35 - which we kind of looked at a little bit
07:37 - ago the dot matches any character except
07:40 - a newline so if I come in here and just
07:42 - put a literal dot for our regular
07:46 - expression with no backslash then if we
07:48 - run this then we can see that all of our
07:51 - matches match just about any character
07:53 - except it doesn't match new lines so
07:55 - it's matching all of the characters up
07:57 - here in our text to search that is not a
08:00 - new line so you can see that we have a
08:02 - lot of those matches
08:04 - now the backslash D matches any digit
08:07 - between 0 and 9 so if I put in a
08:10 - backslash D for our pattern here and run
08:13 - that then you can see that all of our
08:15 - matches are digits between 0 and 9 so
08:19 - there's not as many but you can see that
08:22 - they're all digits now the uppercase D
08:24 - matches anything that is not a digit and
08:27 - you'll see that this is kind of a common
08:29 - theme with these special characters here
08:32 - so you can see that the capital W
08:34 - matches not a word we haven't gone over
08:37 - that yet but the capital S matches not a
08:39 - whitespace so the capital letters
08:41 - basically negate whatever the lowercase
08:44 - version means so capital D is not a
08:47 - digit so if we put that in as our
08:49 - pattern and save that and run it then
08:52 - you can see that we have a lot
08:53 - matches here but all of these are
08:55 - matches that are not a digit so you
08:58 - won't find any digits here in our
09:00 - matches
09:00 - now the lowercase W is a pretty common
09:02 - search this is for a word character and
09:05 - a word character is anything that is a
09:08 - lowercase letter an uppercase letter a
09:11 - digit or an underscore so if we search
09:14 - for a backslash lowercase W and run that
09:17 - then you can see that all of these are
09:19 - either going to be lowercase letters
09:22 - uppercase letters digits which we have
09:25 - some digits here or underscores I don't
09:27 - think I have any underscores and our
09:29 - text to search so just like I was saying
09:31 - before the uppercase W will match
09:33 - anything that is not a word character so
09:36 - it's basically the opposite so I will
09:38 - search for an uppercase W if we run that
09:40 - then we can see that these are
09:41 - everything that are not our word
09:44 - characters so we have no lowercase
09:45 - letters no uppercase letters no digits
09:47 - and no underscores the backslash S here
09:50 - matches any white space so that consists
09:53 - of spaces tabs and new lines so if I put
09:57 - in a lowercase s here for our search and
10:00 - run that then you can see that we get
10:01 - all spaces new lines which are these
10:04 - backslash ends and I don't think I have
10:07 - any tabs in here but it would match tabs
10:09 - as well
10:09 - now the uppercase s matches anything
10:11 - that's not whitespace so anything that's
10:13 - not a space or a tab or a new line so if
10:16 - we search for that and run it then you
10:18 - can see that we might have a lot of
10:19 - matches in here but none of these are
10:20 - spaces or tabs or new lines now the
10:23 - one's a little bit lower here these are
10:25 - a little bit different now these are
10:27 - called anchors they don't actually match
10:29 - any characters but rather invisible
10:32 - positions before or after characters and
10:35 - we can use this in conjunction with
10:37 - other patterns for searching for so
10:39 - first we have this backslash B which is
10:42 - a word boundary and word boundaries are
10:44 - indicated by whitespace or a non
10:46 - alphanumeric character so for example if
10:49 - I scroll up here into our text to search
10:52 - you can see that I have these three Haws
10:54 - right here now let's say that we wanted
10:56 - to match all of the Haase that have a
10:58 - word boundary directly before so we can
11:01 - search that if we go down here to our
11:03 - pattern I can search that by saying
11:05 - backslash B
11:07 - which is our word boundary and then that
11:09 - literal text that we're searching for so
11:10 - I'll just search for ha and if I save
11:12 - that and run it then we can see that it
11:14 - matched two of these and I'm gonna
11:16 - scroll up here and show you which ones
11:18 - because it's not entirely clear just by
11:20 - glancing at the spans but it's matching
11:23 - the first one here because the start of
11:26 - the line is a word boundary and it's
11:28 - also matching the second one here
11:31 - because this space is also a word
11:34 - boundary now it's not matching this last
11:36 - one because there's no word boundary
11:39 - before it this is in the middle of a
11:41 - word now if we replace our search
11:43 - instead of a lowercase B we use an
11:45 - uppercase B and save that and run it
11:48 - then you can see that we have one match
11:50 - because that is matching all of these
11:52 - haws that do not have a word boundary
11:54 - before it so if we scroll up here to the
11:56 - top then basically it's just the
11:58 - opposite of our last search so it's
12:00 - matching this last one because it is the
12:02 - only one that does not have a word
12:03 - boundary before it okay so moving on we
12:06 - have this caret and this dollar sign and
12:08 - the caret will match a position that is
12:11 - the beginning of a string and the dollar
12:14 - sign will match a position that is the
12:16 - end of the string so if I scroll down
12:18 - here to our pattern then I have a small
12:20 - sentence variable here that I'm going to
12:22 - use to demonstrate this so let me spread
12:25 - this over here a little bit so that that
12:26 - fits on one line again now I'm gonna
12:29 - change the text that we're searching to
12:31 - this sentence instead of the text to
12:33 - search so I'm gonna paste that in there
12:35 - now first we'll look at the caret which
12:37 - is the anchor for the beginning of a
12:39 - string so if I was to search a pattern
12:41 - and say let's say so a caret and then
12:44 - I'm going to search for the literal text
12:46 - start so if I run that then we can see
12:49 - that it's searching for the literal text
12:50 - start that is at the beginning of that
12:52 - string of that sentence so if I change
12:55 - this to something that is not at the
12:58 - start then run that then you can see
13:01 - that now we get no match so this pattern
13:04 - here is actually in our sentence but the
13:06 - character says that it has to be at the
13:08 - start so if I undo that then we can see
13:10 - that that matched our start string there
13:13 - because it is at the beginning of the
13:16 - string and we can do something similar
13:18 - to match the end of the string using
13:20 - the dollar sign so if I search for the
13:22 - literal text e in D and then follow that
13:27 - with a dollar sign and then save that
13:30 - and run it then you can see that it
13:31 - matched this text here that's at the end
13:33 - of our string because we have the dollar
13:36 - sign there now if I was to replace this
13:39 - with something that is in our string but
13:41 - it is not at the end of the string and
13:44 - run that then you can see that even
13:46 - though we have A's in this string it
13:47 - doesn't match because it's not at the
13:49 - end okay so now I'm going to change our
13:51 - search back to the text to search and
13:53 - now we're going to look at some
13:55 - practical examples so I'm just gonna
13:57 - move this snippets file back here to one
14:00 - panel and we will keep looking at that
14:03 - throughout the video then I'll go back
14:05 - to my simple dot pie here so now let's
14:07 - say that we wanted to match these phone
14:10 - numbers here within our multi-line
14:12 - string so let's write some regular
14:14 - expressions to do this now we can't just
14:16 - type in a literal search because they're
14:18 - all different now they have a similar
14:21 - pattern but they're not all the same
14:22 - digits so in this case we would need to
14:25 - use the meta characters instead of
14:27 - literal characters now we just have the
14:30 - pattern of three digits here and then a
14:33 - dash and this one has a period and then
14:35 - we have three more digits and then a
14:37 - dash or a period and then four digits so
14:41 - let's go ahead and create the pattern to
14:43 - match this so I'll try to fit both of
14:45 - these in to the screen here at once so
14:48 - we know that we can match any digit with
14:49 - a backslash d now that will match any
14:52 - single digit in the text like we saw
14:54 - before but with a phone number we can
14:56 - start off start off by matching three
14:58 - digits in a row so I'm going to put in
15:00 - three backslash deeds there so now if we
15:02 - run it at this point then you can see
15:04 - that all of our matches are all the
15:06 - three different combinations of three
15:08 - digits in our text to search Oh actually
15:10 - they're in a row so if I go up here to
15:12 - the top then you can see first it
15:13 - matched one two three and then four five
15:15 - six as the next one and then seven eight
15:17 - nine and then it moves down to the three
15:19 - digits of our phone number so that's a
15:21 - little bit closer but we need to
15:23 - complete this pattern so now that we're
15:25 - matching those first three digits now
15:26 - we're getting to the point and our phone
15:28 - number where we can match either a dash
15:30 - or a dot so for now let's just match any
15:33 - character now if we remember from our
15:36 - snippets that dot will match any
15:38 - character so if I just put this in after
15:41 - our three digits and that should match
15:42 - the hyphen or the dot but it should also
15:45 - match anything else so now let's
15:47 - continue and match the next three digits
15:49 - so just three more backslash DS and then
15:51 - we get to the point where we're going to
15:54 - match another dash or a dot so we'll
15:56 - just put in another dot to match any
15:58 - character there and now we're gonna
16:00 - match four more digits so for backslash
16:03 - DS so if I save that and run it then we
16:06 - can see that it matched let me make this
16:08 - a little smaller here then we can see
16:10 - that it matched both of our phone
16:12 - numbers from our text up here so now
16:15 - we're starting to see how this could be
16:16 - pretty powerful so I have a data dot
16:19 - text file here and this has a bunch of
16:22 - fake names and numbers and addresses and
16:25 - emails so let's open this file in Python
16:28 - and then run our regular expression
16:30 - against its contents and see if we can
16:33 - parse out the phone numbers from this
16:35 - text file so first to open this file let
16:37 - me scroll down here to the bottom and
16:39 - I'll put these in here so first we want
16:41 - to open the file and we can do that with
16:43 - with open and that is data dot txt and
16:48 - it's in the same directory so we can
16:49 - just spell it out like that without a
16:51 - full path and then we want to read this
16:53 - file as f now if you're unfamiliar with
16:56 - file objects then I do have a separate
16:58 - video on that as well and I'll leave a
17:00 - link to that in a description section
17:02 - below
17:03 - so now let's read in the contents of
17:04 - this file so I'm going to create a new
17:06 - variable here and call this contents and
17:09 - then we're going to set this equal to
17:10 - this F which is our file F dot read and
17:14 - that'll read in all of the contents and
17:15 - now to search the contents of that file
17:17 - for our pattern using our regular
17:19 - expression we can just copy our previous
17:22 - match here so I'm going to copy in this
17:25 - line to get our matches and paste that
17:27 - in and also I'm going to cut this out
17:31 - and move this up here and copy comment
17:36 - that out for now and paste that in down
17:39 - here ok so what we're doing here is
17:41 - we're reading in the contents of that
17:42 - file and now we're using the same
17:45 - pattern that we used up here to match
17:46 - our
17:47 - numbers in our text and now we want to
17:49 - search our contents instead of that text
17:53 - to search and then we're just going to
17:55 - print out all of those matches and we've
17:57 - got these matches comment it out so
17:59 - those shouldn't show anything so I will
18:01 - go ahead and run this okay so it looks
18:04 - like we are getting a unicode decode
18:07 - error I'm not sure why that's the case
18:09 - because everything in that data text
18:12 - file should be ASCII characters so to
18:15 - fix this really fast I'm just going to
18:17 - put in an encoding equals utf-8 now I
18:22 - will fix this by the time that I put
18:24 - these files up so you shouldn't have to
18:26 - do this part I'm not sure why that is
18:29 - seeing a Unicode character in there but
18:31 - now that should solve it so if I save
18:33 - that and run it now we can see that
18:36 - we're getting all of our phone number
18:38 - matches from that data dot txt file so
18:41 - we can already see how using these
18:42 - regular expressions can be extremely
18:44 - useful for parsing information from our
18:47 - data ok so now going back to our text
18:49 - within this symbol file so I'm going to
18:51 - comment out the matches from the file
18:54 - there and uncomment out our matches from
18:58 - this file so now let's say that we only
19:00 - wanted to match a phone number if it had
19:03 - a dash or a dot so right now this
19:05 - pattern will match any separator that is
19:08 - here because we are using the period in
19:11 - our matches which matches any character
19:13 - so if I put another number in here that
19:16 - uses a different separator so for
19:18 - example let me put another number that
19:21 - uses like an asterisk for a separator so
19:25 - if I save that and run it then you can
19:28 - see that our pattern is currently
19:30 - grabbing that phone number as well so to
19:32 - only match the dash or the dot we can
19:34 - use something called a character set and
19:36 - a character set uses these square
19:39 - brackets with the characters that we
19:40 - want to match so I'm going to put in the
19:43 - square square brackets here and now the
19:45 - characters that we want to match in this
19:47 - position and we want to match a dash or
19:49 - a dot so I'm also going to replace this
19:52 - period which used to match any character
19:54 - now we're putting in a character set and
19:56 - we only want to match a dash or a dot so
19:59 - now if I save this and
20:01 - then you can see that we're still
20:02 - matching our first two numbers here that
20:04 - have a dash and a dot but we're not
20:06 - matching this third number that has that
20:08 - asterisk because this is not in our
20:10 - character set also you probably noticed
20:12 - that we didn't need to escape our dot
20:14 - within a character set and that's
20:16 - because character sets have some
20:17 - slightly different rules you can escape
20:20 - these characters if you'd like but it
20:21 - just makes it a little bit more
20:22 - difficult to read now even though the
20:24 - character set has multiple characters in
20:26 - the set it's still only matching one
20:29 - character in our text so it's matching a
20:32 - character that is either a dash or a dot
20:35 - now if I was to put two dashes up here
20:39 - in one of these numbers and save that
20:41 - and run it then you can see it doesn't
20:42 - match that because it only matches this
20:44 - first dash and that it moves right on to
20:47 - looking for another digit and that's
20:49 - something that can throw people off when
20:51 - they first start working with regular
20:53 - expressions because if you look at these
20:55 - character sets you can see a lot of
20:56 - different characters in here in this one
20:58 - we only have two characters in the
21:00 - character set but we'll see some sets
21:02 - later that are much larger but even
21:04 - though we have multiple characters in
21:06 - these sets it still only matches one
21:08 - character up here in our text so just
21:10 - keep that in mind because sometimes it
21:12 - can throw people off when they have you
21:14 - know long character sets that kind of
21:17 - look like something like this but all of
21:18 - this would still only match one
21:20 - character so now let me make sure that
21:23 - that number is back to normal and save
21:26 - that so to look at another example of a
21:28 - character set let's say that we only
21:30 - wanted to match 800 and 900 numbers so
21:34 - let me copy two of these numbers here
21:36 - and I will separate these with a dash
21:40 - and I'm going to make this one here an
21:44 - 800 number and then I'll make this one
21:47 - here a 900 number so I'll save that and
21:50 - go down here to the bottom now to match
21:52 - 800 or 900 numbers we're gonna have to
21:54 - change our first three digits here so
21:56 - the first digit it's going to be either
21:58 - an 8 or 9 so that's a good use for a
22:01 - character set so we'll create a
22:02 - character set and match either an 8 or a
22:04 - 9 and now the next two digits are just
22:08 - both going to be literal zeros so I'll
22:10 - put literal zeros in there save that and
22:12 - run it you can see for all of our
22:14 - matches it
22:14 - printed out only the 800 and 900 numbers
22:17 - so now if I perform that same search on
22:19 - the data file that we used before so
22:21 - I'll copy out our our comment out our
22:25 - matches there that we're looping through
22:27 - and uncomment our data txt file now this
22:29 - is still using the same pattern and we
22:31 - just changed that pattern to match 800
22:33 - and 900 numbers so if I run this then
22:36 - that same code now should only print out
22:38 - the 800 and 900 numbers from that file
22:40 - and you can see from our matches here
22:42 - that that's what we get so that's pretty
22:43 - cool to be able to now match these more
22:46 - detail to patterns so now I'm going to
22:48 - remove this file section I believe
22:50 - that's the last we're going to use that
22:51 - and uncomment out that loop there now
22:55 - within a character set the dash is
22:57 - actually a special character as well
22:59 - when it is put at the beginning or in it
23:02 - will just match the literal - character
23:04 - but when placed between values it can
23:07 - specify a range of values so for example
23:09 - we know that the backslash D matches any
23:12 - digit but if we only wanted to match
23:14 - digits between 1 and 5 to do that we
23:18 - could just change our entire pattern
23:20 - here to be a character set and if we
23:22 - just put in a 1 - 5 then with this dash
23:26 - between those values that's now going to
23:28 - specify a range so if I save that and
23:32 - run it if we look at our matches here
23:34 - all of our matches are going to be
23:35 - digits between 1 and 5 and we can use
23:38 - this for letters as well so if we wanted
23:40 - to match lowercase a through Z then we
23:43 - can just match let a lowercase a through
23:46 - lowercase Z so if I save that and run it
23:49 - and you'll see that all of our matches
23:50 - down here are lowercase letters now if
23:53 - we wanted to match uppercase and
23:54 - lowercase letters then we can just put
23:56 - these ranges back-to-back so right after
23:59 - the lowercase a through Z then I can
24:01 - also just put in a range of uppercase a
24:04 - through Z so if I save that and run it
24:06 - now you can see that all of our matches
24:08 - down here are either going to be
24:09 - uppercase letters or lowercase letters
24:12 - and you could keep adding to that and
24:14 - add digits onto there if you'd like as
24:16 - well
24:17 - now another special character in our
24:19 - character set is the carrot so if you
24:22 - put a carrot at the beginning then I
24:24 - mentioned before that outside of the
24:26 - character set the
24:28 - matches the beginning of a string but
24:30 - within a character set it negates the
24:33 - set and matches everything that is not
24:35 - in that character set so for example
24:38 - when I put the carrot before this
24:40 - character set here it's going to now
24:43 - match everything that is not a lowercase
24:45 - or uppercase letter so if we run this
24:48 - then we can see that we get a lot of
24:50 - matches we get a lot of new lines and
24:52 - digits and spaces and things like that
24:56 - but none of these are lower or upper
24:58 - case letters so let's add to our text to
25:01 - search here and let's say that we wanted
25:05 - to match the words cat mat Pat and all
25:10 - other three-letter words that end in 80
25:13 - but we don't want to match the word bat
25:16 - now to write a regular expression for
25:18 - that instead of specifying all the
25:20 - characters except for a B we could just
25:23 - use our negation there of the character
25:26 - set and just say that we want everything
25:29 - that is not a B followed by a literal a
25:33 - T so if we run that then we can see that
25:36 - for our matches we matched cat mat Pat
25:39 - but we did not match this bat and that
25:42 - is because that carrot negates that
25:44 - character set of only this B character
25:46 - okay so now I'm going to remove those
25:48 - from our text now everything that we've
25:51 - looked at has involved single characters
25:53 - so far so for example this is saying
25:57 - match any single character that isn't a
26:00 - B followed by an a followed by a T but
26:05 - we can use things called quantifiers to
26:08 - match more than one character at once so
26:10 - let's go back to our original phone
26:12 - number expression from earlier and will
26:15 - match any character for the separator
26:18 - for now so I'm going to fill in that
26:21 - pattern so we want three digits just a
26:24 - period to match any character for a
26:26 - separator three more digits a period for
26:29 - any separator and then four digits so
26:31 - just make sure we type that correctly
26:33 - let me save that and run it and you can
26:35 - see that we're still matching these
26:36 - numbers just fine but you can see that
26:38 - we're searching for all of our digits
26:39 - one character at a time
26:41 - and it's easy to make mistakes when you
26:43 - have a lot of these to type out but we
26:46 - can use something called a quantifier to
26:48 - match multiple characters at a time so
26:50 - let me open up my snippets file again
26:52 - here and I'm going to again open this up
26:56 - into two columns and move this over now
26:58 - let me scroll down to the quantifiers
27:00 - and read through these and also let me
27:02 - go to my simple example back here again
27:04 - so that we can see this okay so our
27:08 - first quantifier here we have an
27:09 - asterisk and an asterisk will match zero
27:12 - or more of the pattern that we're
27:14 - looking for now a plus sign will match
27:17 - one or more the question mark will match
27:20 - zero or one and if we use these curly
27:24 - braces with a number inside that will
27:27 - match that exact number of the pattern
27:29 - if we use these curly braces with two
27:32 - numbers separated by a comma that will
27:34 - match a range of numbers and that first
27:36 - number is the minimum and the second
27:38 - number is the maximum so for our phone
27:40 - number over here
27:41 - this would be a good case to use exact
27:43 - numbers so instead of writing all of
27:46 - these out I can just go back here to
27:47 - this first digit that we want to match I
27:50 - could put in curly braces and say that I
27:52 - want to match three of those digits and
27:54 - I can do the same thing for the second
27:58 - section of digits there and then for the
28:00 - last we want to match four digits at the
28:02 - end so I can save that and run it and
28:04 - you can see that we still get the same
28:06 - result so that allows us to specify the
28:08 - amount of digits that we're looking for
28:10 - without needing to type them all out and
28:12 - possibly making a mistake along the way
28:14 - now here we're matching exact numbers
28:16 - but sometimes we don't know the exact
28:18 - number and we'll need to use these other
28:20 - quantifiers so for example down here at
28:23 - the bottom of our text we have these
28:25 - names and some lines start with the
28:29 - prefix of mr some start with Miss and
28:32 - some start with misses so let's say that
28:34 - we wanted to write a pattern that would
28:36 - match these prefixes and the entire name
28:39 - that comes afterward so to start off
28:41 - easy let's first start by just matching
28:44 - the names that start with mr now we can
28:46 - see that some of these have a period
28:48 - after the prefix and some do not so mr.
28:51 - Smith does not have a period here so
28:53 - to handle this let's see if I can fit
28:55 - all of this in here I'm gonna cut off
28:57 - our loop but that's okay so to write our
29:01 - pattern here we want to search for mr
29:03 - and we want to have a period after here
29:07 - so if we run this right now then you see
29:10 - that we have two matches but there are
29:13 - three misters up here so it's matching
29:15 - both of these mysteries that have the
29:17 - period after the prefix but this one is
29:20 - not currently matching now to match that
29:22 - we need to say that the period after the
29:25 - prefix is optional and we can use the
29:28 - question mark quantifier to do this
29:30 - which tells our pattern that we want to
29:32 - match either zero or one of those
29:35 - characters so if I put a question mark
29:37 - after our period there and then rerun
29:41 - that then we can see that now it is
29:42 - matching those m RS without the period
29:45 - so now to complete this pattern now
29:47 - after that optional period we have a
29:49 - space and now we're running into
29:52 - uppercase letters said to match
29:54 - uppercase letters we can use a character
29:56 - set like we looked at before and we can
29:58 - just pass in a capital A through a
30:00 - capital Z to match all the uppercase
30:03 - letters so now if we run this then we
30:05 - can see that we are matching up to the
30:08 - first letter of the Matt of the last
30:10 - name for all of these names now at this
30:12 - point we have a decision to make after
30:14 - the first uppercase letter we've
30:16 - completely matched the name for mr. t
30:20 - that we can see here but we still need
30:22 - to match the rest of our other names so
30:24 - we could say that we will match any word
30:27 - character after that uppercase letter
30:29 - and we can do that with a backslash W
30:33 - after that first uppercase letter and
30:35 - now we need to decide what quantifier we
30:37 - want to use for our word characters so
30:40 - we could use the plus sign quantifier
30:41 - which would match one or more of these
30:43 - word characters so if I put in a plus
30:46 - sign here and run this we can see that
30:48 - when we do that it matches mr. Schaefer
30:50 - and mr. Smith but it doesn't match mr. t
30:53 - because mr. t doesn't have a word
30:55 - character after that first uppercase
30:57 - character so a better solution here
30:59 - might be to use the asterisk quantifier
31:02 - which allows us to match zero or more of
31:04 - these word characters follow
31:06 - that first upper case so if I save that
31:08 - and run it now you can see that now that
31:11 - it's matching zero or more it includes
31:13 - mr. t in there and the other names now I
31:16 - know that we've covered a lot so far but
31:17 - we've just got a few more concepts to go
31:19 - and then we'll look at some examples
31:20 - that wrap everything together so we
31:23 - still haven't matched our miss or misses
31:25 - names up here so how would we do that
31:27 - now you might think that we should use a
31:29 - character set that matches either an R
31:32 - or an S after the after the M and
31:35 - there's probably some ways that we could
31:36 - do that and get it to work but it would
31:38 - be a bit ugly because then we'd have to
31:41 - match an optional s after that for the
31:44 - misses as well I think a better solution
31:46 - here would be to use a group now we
31:49 - haven't looked at groups yet but groups
31:51 - allow us to match several different
31:53 - patterns so to create a group we use
31:55 - parentheses and within the parentheses
31:58 - we can match some patterns so let's say
32:02 - that we wanted to match a literal R
32:04 - after the M and then we can use this
32:07 - vertical bar character which is
32:10 - basically an or so we can say R or a
32:13 - literal s and then another vertical bar
32:16 - and then we can say or a literal RS so
32:20 - now we have three different patterns
32:21 - here capital M followed by either an R
32:25 - and s or an RS so now with that little
32:28 - change if I save that and run it and
32:30 - pull this up a little bit now you can
32:32 - see that now we are matching all of our
32:34 - names now I was just saving some
32:36 - characters by doing it this way if you
32:38 - think it's more easy to read then we
32:40 - could have also put the M within this
32:42 - group as well so I could have just put
32:45 - an entire group here at the beginning
32:46 - and said mr. miss whoops miss or misses
32:52 - so it adds more characters but it's also
32:54 - a little bit more clear exactly what
32:56 - those groups are matching if we move
32:58 - that M within at the group there and if
33:01 - we save that and run it then we can see
33:02 - that we still get the same results now
33:04 - these groups can actually be used to
33:05 - capture sections of your matched regular
33:07 - expression and that's something what
33:09 - that will look at in just a minute but
33:11 - for now let's do a quick recap of
33:12 - everything that we've learned so far by
33:14 - looking at some examples that
33:16 - incorporates all of these things
33:17 - together so I'm going
33:18 - open up this emails dot PI file here and
33:21 - I might make the text just a little
33:23 - smaller so that we can fit everything in
33:25 - one window
33:26 - so I've got a file here where I have
33:28 - this emails variable and we have three
33:31 - different email addresses within this
33:34 - string that are fairly different emails
33:36 - now let's try to write a regular
33:37 - expression that will match all of these
33:39 - emails so let's match the first email
33:42 - address first so let's go ahead and come
33:45 - down here into our pattern where we are
33:49 - doing the re compile and now we want to
33:51 - put our regular expression pattern
33:53 - within here so first let's just match
33:55 - everything before the @ symbol here and
33:58 - we can see that everything before that @
34:00 - symbol there just uppercase and
34:02 - lowercase letters so to match uppercase
34:05 - and lowercase letters we can just use a
34:06 - character set with a lowercase 8th or a
34:09 - lowercase Z followed by an uppercase a
34:12 - through an uppercase C and now we want
34:15 - to match one or more of those until we
34:17 - hit the @ symbol so to match one or more
34:19 - we can use the plus sign and we want to
34:21 - match one or more of those all the way
34:23 - up until we hit the @ symbol and we can
34:26 - just put in a literal @ symbol for that
34:28 - now after the @ symbol we have only
34:30 - lowercase letters but let's go ahead and
34:32 - put uppercase letters in that character
34:34 - set as well so we'll do lowercase
34:36 - letters with a lowercase 8th through Z
34:38 - and an uppercase a through Z and again
34:42 - we'll put in a plus sign to match one or
34:44 - more of those and then finally we'll
34:46 - match those all the way up until we hit
34:48 - this dot-com itself so for now we can
34:51 - just put in a literal match for that so
34:54 - I could say backslash dot to literally
34:56 - match that dot there and then just a
34:59 - com4 com so if we save that and run it
35:03 - then we can see that we matched that
35:04 - first email address now just to get some
35:07 - more space here I think we're done with
35:08 - the snippets file for now so I'm going
35:10 - to bring this back over here go to view
35:12 - and make this a single column again and
35:15 - go back to my emails file so now that
35:17 - we're matching the first address here
35:18 - let's build this up so that it matches
35:20 - the other two as well now it looks like
35:23 - it's not matching the second address
35:24 - because we need to allow a period in the
35:27 - first part of the expression because we
35:29 - have a period right here so we can add
35:32 - to the character set of the first part
35:35 - just by putting a dot in that first part
35:38 - of the character set there and another
35:40 - thing that's different is that this ends
35:42 - with a dot e-d-u instead of a dot com so
35:45 - to match that we could just match a
35:48 - group here so I will wrap this calm in
35:52 - parentheses to create a group and we can
35:54 - say that we want to want match calm and
35:57 - use the vertical bar as an or and say or
36:00 - dot edu so if we save that and run it
36:03 - you can see that now we are matching
36:05 - that second address as well okay so good
36:07 - so we're building this up a little bit
36:09 - at a time so finally to match our final
36:11 - address it looks like we need to allow
36:14 - numbers and a hyphen in the characters
36:17 - before the @ symbol so again we can just
36:21 - add this to our character set so we can
36:23 - come here to our ranges and add the
36:26 - digits 0 through 9 onto the end of that
36:28 - and we also want to put a hyphen at the
36:32 - end of that character set and it looks
36:34 - like we also have a hyphen and our
36:36 - domain here so this is the character set
36:39 - for our domain so we can add in - 2
36:41 - there as well and lastly instead of
36:45 - a.com or a descendant net so let's add
36:48 - that to our group here so we'll just put
36:50 - in another vertical bar and add in
36:52 - dotnet so if we save that and run it
36:54 - then you can see that now we're matching
36:56 - all three of our email addresses now
36:58 - with something like email addresses it
37:00 - can be pretty tough writing your own
37:01 - regular expression from scratch but
37:03 - there are a lot of these available
37:04 - online and once we learn how to write
37:07 - regular expressions then we should be
37:09 - able to read them and figure out what
37:11 - they'll match now I've always found that
37:13 - reading other people's regular
37:15 - expressions to be a lot harder than
37:16 - writing them but let's look take a look
37:18 - at one and see if we can do this so
37:20 - there is a regular expression that I
37:22 - pulled off line that matches email
37:24 - addresses and I have this here in my
37:26 - snippets file at the bottom so let me
37:28 - copy this over and paste it in as our
37:33 - expression and let's walk through this
37:34 - so first of all just let me save it and
37:36 - run it to make sure that it still
37:38 - matches all three of our email addresses
37:39 - and it does now this looks a little
37:42 - intimidating but really these are just
37:43 - some large character sets here so
37:46 - first we have a character set that
37:48 - matches all lowercase letters all
37:50 - uppercase letters all digits then we
37:53 - have its matching an underscore a period
37:56 - a plus sign or a hyphen and then we have
37:59 - a plus sign that will match one or more
38:01 - of any of those characters in the
38:03 - character set and it matches those all
38:05 - the way up until it hits our @ symbol
38:07 - now after the @ symbol for the domain we
38:10 - have another large character set here
38:12 - and this matches any lowercase any
38:14 - uppercase any digits or any hyphens now
38:17 - I don't know a lot about email addresses
38:19 - but I'm assuming that since they left
38:20 - out the underscore the period and the
38:22 - plus sign that these aren't valid for a
38:24 - domain so then that is followed by a
38:26 - plus sign here that will match one or
38:29 - more of any of these characters and the
38:31 - character set all the way up until it
38:34 - hits the last period in that period is
38:36 - escaped with a backslash and then after
38:39 - that dot it will we have another
38:42 - character set which will match any
38:44 - lowercase uppercase digits hyphens or
38:48 - another dot and that plus sign will
38:51 - match one or more of any of those
38:53 - characters so reading regular
38:55 - expressions written by other people is
38:57 - probably one of the hardest parts of all
38:59 - this but if you walk through it bit by
39:00 - bit then you should be able to break it
39:02 - down like that for just about any
39:04 - pattern okay so the last concept that
39:06 - I'd like to look at in this video is how
39:08 - to capture information from groups now
39:10 - we've already seen how to match groups
39:12 - but we can actually use the information
39:14 - captured from those groups so to show an
39:17 - example of this I'm going to open up
39:18 - this file here called URLs dot PI and
39:21 - again let me take this down just a
39:25 - little bit here so that we can fit
39:26 - everything okay so with these URLs here
39:29 - we can see that some of these URLs are
39:31 - HTTP some are HTTPS some of them have
39:36 - www for the domain and some do not so
39:39 - they're pretty inconsistent so let's say
39:41 - that for each of these URLs we only
39:43 - wanted to grab the domain name followed
39:46 - by the top-level domain so in this case
39:48 - it would be you know for example
39:50 - google.com or Cory M s calm or
39:52 - youtube.com or nasa.gov and we just
39:55 - wanted to ignore everything else so
39:57 - let's see how we can do this so first
39:59 - let's write and Express
40:00 - that actually matches these URLs so we
40:03 - can say in our re dot compiled here
40:06 - we're creating our regular expression
40:08 - pattern so we can say http/2 match a
40:11 - literal HTTP now some of these have
40:14 - HTTPS and some do not
40:17 - so we want to match an S but put a
40:19 - question mark after it because if you
40:21 - remember the question mark matches 0 or
40:24 - 1 so basically it makes that s optional
40:26 - so then after that optional s we want to
40:29 - match a colon forward slash forward
40:32 - slash and now here we have an optional
40:34 - ww some have WWE and some do not
40:38 - now you may be thinking that what we
40:40 - could use a character set or something
40:43 - here but it's actually going to be best
40:44 - to use a group because within a group we
40:48 - can just say that that entire www with
40:51 - the dot and remember we have to escape
40:53 - that with a backslash a backslash dot
40:55 - that entire group is optional so just to
40:59 - make sure we're on the correct path if
41:00 - we save this and run it now you can see
41:02 - that we're all the way up to the domain
41:04 - name on all of these matches so far so
41:07 - let's go ahead and continue so now to
41:09 - match the domain name we can just match
41:11 - any word character so we'll just put a
41:14 - backslash W to match a word character
41:16 - and then a plus to match one or more of
41:18 - those and we want to want match one or
41:21 - more word characters all the way up to
41:23 - the dot so we will put in a backslash
41:27 - dot there to match that now we want to
41:30 - match the top level domain which is calm
41:32 - or gov so we can just match word
41:36 - characters again and one or more of
41:38 - those with a period after that so if we
41:40 - save that and run it then you can see
41:43 - that now we are matching the entire URL
41:45 - for all of these URLs that we have
41:47 - listed ok but remember that the point
41:49 - here was to use our groups to capture
41:52 - some information from the URLs so let's
41:54 - capture the domain name and the
41:56 - top-level domain and by the top-level
41:58 - domain again I mean the dot-com or the
42:01 - dot gov so to capture these sections we
42:03 - can just put them in a group by
42:05 - surrounding them with parentheses so for
42:08 - example this section here was our match
42:11 - for the domain name so I
42:13 - just surround that in parentheses there
42:17 - and then our top-level domain we want to
42:20 - include the dot so this would be the
42:22 - dot-com or the dot gov so we'll put the
42:25 - parentheses before the dot and then here
42:28 - at the very end so since we just added
42:30 - groups to an existing expression that
42:33 - shouldn't actually change our results so
42:34 - if we rerun this we can see that we
42:36 - still get the same results there but now
42:39 - we actually have three different groups
42:40 - so the first group is the optional ww
42:44 - the second group is our the word
42:46 - characters that make up the domain name
42:48 - and the third group is the top-level
42:50 - domain which is the dot-com or the dot
42:52 - gov now there's also a group 0 and group
42:55 - 0 is everything that we captured so in
42:58 - this case it's just the entire URL so
43:01 - this would be group 0 here so to show
43:03 - this our match object down here that we
43:07 - are iterating through this match object
43:10 - actually has a group method and we can
43:12 - pass in the index of the group that we
43:15 - want to see so we can say dot group to
43:19 - use that group method and now we can
43:21 - print out group 0 by just doing group 0
43:24 - so if we print that out then like I said
43:26 - group 0 is the entire match so that's
43:29 - just the entire URL now if we printed
43:32 - group 1 this should be the optional ww
43:35 - so if we save that and run it then we
43:38 - can see that the URLs that have aaww dot
43:42 - print that out as the group and the ones
43:45 - that don't just print out none values so
43:48 - our group 2 here should be our domain
43:50 - name so if I print out group 2 and run
43:53 - that then we can see that that's what we
43:55 - got so we got Google query MS YouTube
43:58 - and NASA now group 3 should be our top
44:00 - level domains so if we print out group 3
44:03 - and run that then you can see that we
44:05 - get calm calm calm and gov now we can
44:08 - use something called a back reference to
44:10 - reference our captured group and it's
44:12 - basically just a shorthand for accessing
44:15 - these group indexes so the regular
44:18 - expression module has a sub method that
44:21 - we can use to perform a substitution so
44:24 - let's see what this looks like and we
44:27 - can
44:27 - substitute in these back references
44:30 - which reference the groups so for
44:32 - example let's just show an example and
44:34 - that will become more clear so I can
44:36 - create a sub URLs variable here and I
44:40 - will set that equal to pattern dot sub
44:43 - and now we want to pass in the
44:45 - substitution so the substitution that we
44:48 - want to use are these back references
44:51 - that reference these groups so we wanted
44:54 - to replace these URLs with the domain
44:56 - name and the top-level domain so the
44:58 - domain name was group 2 and we use these
45:01 - back references with a back slash and
45:04 - then the number of the group so we want
45:06 - to replace these with a back slash 2
45:09 - which is that a domain name and then a
45:11 - back slash 3 which is the top-level
45:14 - domain and now we need to pass in the
45:17 - text that we want to replace so let me
45:19 - walk through this one more time just
45:20 - because that can be a little computing
45:22 - so here we are creating a pattern and
45:25 - this pattern as we saw matches all of
45:27 - our URLs here in our string and then our
45:30 - subdue our LS we are using that pattern
45:33 - to substitute out group 2 and group 3
45:38 - for all of our matches in URLs so every
45:41 - time it finds a match it will replace
45:43 - that match with group 2 which is the
45:45 - domain name and then group 3 which is
45:47 - the top-level domain so now just to show
45:50 - how that worked let's print out that
45:52 - subd URLs and save that and print it out
45:56 - and scroll up here and we can see that
45:58 - that returned a new string with all
46:00 - those substitutions made so if you had a
46:03 - large document of things that you wanted
46:05 - to reformat like this then learning how
46:07 - to do this with regular expressions
46:08 - could save you a ton of time and allow
46:11 - you to do that within just a couple of
46:13 - minutes okay so we're really close to
46:14 - being finished up here we should now
46:17 - have a pretty good understanding of
46:19 - working with regular expressions in
46:21 - Python but we've been using this find it
46:23 - err method throughout the whole video
46:25 - and that's because I think it does the
46:27 - best job of showing all the matches and
46:29 - the location of those matches but there
46:31 - are other methods that we can use for
46:33 - different purposes so let's take a quick
46:35 - look at some of those so first we have
46:38 - the find all method
46:40 - with the find it er method that we were
46:42 - using it returns match objects with
46:45 - extra information and functionality but
46:47 - find all will just return the matches as
46:50 - a list of strings now if it's matching
46:53 - groups then it will only return the
46:55 - groups so in the example we're currently
46:58 - using a pattern where we match those
47:01 - names and we have a group here at the
47:04 - beginning for the prefix so this is only
47:06 - going to match that group so if I save
47:09 - this and run it then you can see that it
47:11 - only prints out that first group and if
47:14 - there are multiple groups then it would
47:16 - return a list of tuples and the tuples
47:19 - would contain all of the groups now if
47:21 - there are no groups then it would just
47:23 - return all of the matches in a list of
47:25 - strings so if I was to change this to
47:28 - this pattern here to our previous phone
47:31 - number example so I'll do a digit of
47:34 - with a quantifier of three then just a
47:37 - dot to match any character digit with a
47:39 - quantifier of three any character and a
47:41 - digit with a quantifier of four if we
47:44 - save that and run it then you can see
47:46 - that it prints out just a list of all of
47:48 - our phone numbers so that's one way to
47:50 - print out all of your matches that you
47:52 - match but personally I like the find it
47:55 - err method a little bit more because it
47:57 - comes with that extra functionality of
47:59 - that match object so next we have the
48:01 - match method now match will determine if
48:04 - the regular expression matches at the
48:06 - beginning of the string so for example
48:09 - let's change our pattern to search for
48:11 - our simple sentence here and we'll just
48:14 - search for the literal string of start
48:17 - and we want to search that sentence
48:21 - variable so instead of that text to
48:22 - search will put sentence in there and
48:24 - instead of find all we want to see what
48:27 - the match method does so let's save that
48:29 - and run it so we got an error here
48:31 - because match doesn't return an iterable
48:33 - like find it or find all it just returns
48:36 - the first match and if there isn't a
48:39 - match then it returns none so instead of
48:41 - looping through our result we can just
48:44 - print out that matches variable so we'll
48:46 - just print out matches there and save
48:50 - that and run it and we can see that it
48:52 - returns that match object with
48:54 - match now this only matches things at
48:57 - the beginning of strings so if we were
48:59 - to search for something else that is in
49:02 - this sentence so I'll search for this
49:04 - sentence pattern right here if I save
49:06 - that and run it then we can see that it
49:08 - returns none because it's only seeing if
49:11 - this is matching at the beginning of
49:14 - that string if we want to search for
49:15 - matches within the entire string then we
49:18 - can use the search method now I'm not
49:21 - sure why they have a match method when
49:23 - regular expressions themselves have the
49:25 - caret to specify match results at the
49:28 - beginning of strings but I'm sure that
49:30 - there's probably some reason that I
49:32 - don't know of so if we wanted to search
49:34 - the entire string for that pattern then
49:37 - we can use the search method instead and
49:41 - just like match this only prints out the
49:43 - first match that it finds so if I save
49:46 - that and run it then we can see that it
49:47 - printed out that match object with the
49:50 - match there now if we search for
49:52 - something that doesn't match then this
49:54 - just returns none as well so if we
49:56 - search for something like D and E 4 does
49:59 - not exist if we save that and run it you
50:01 - can see that it just returns none since
50:03 - it didn't find any of those patterns in
50:06 - our sentence okay so the very last thing
50:09 - that I want to cover in this video and
50:11 - we'll cover it very quickly is flags and
50:13 - we can use flags to make our lives a bit
50:16 - easier when working with regular
50:18 - expressions in Python and you may see
50:20 - some of these at some point when you
50:22 - start using them more often so let's go
50:24 - ahead and take a look so for example
50:26 - let's say that we wanted to match a word
50:28 - but match it whether it was in uppercase
50:31 - or lowercase or a mixture of both so for
50:34 - example if I wanted to match the word
50:37 - start and our sentence but each letter
50:40 - could be uppercase or lowercase then
50:42 - normally to create a pattern like this
50:44 - you would have to do something like you
50:47 - know a character set that started with
50:49 - an uppercase s or a lowercase s and then
50:52 - followed by an uppercase T or a
50:55 - lowercase T and then an uppercase a or a
50:59 - lowercase a and you kind of get the
51:01 - point but since that's kind of a pain
51:03 - instead we can just search for that
51:05 - literal text and I'll just put those in
51:07 - all lower
51:08 - and then we can just add a flag to our
51:11 - pattern here so for this we want to use
51:13 - the ignore case flag so we can either
51:16 - write this out so this is going to be re
51:18 - dot this is gonna be all caps here
51:21 - ignore case and if we save that and run
51:24 - it then you can see that even though our
51:26 - pattern here has a lowercase s and this
51:28 - has an uppercase s it still matches that
51:31 - pattern because we have our ignore case
51:33 - flag here and there are short hands for
51:35 - these flags as well so instead of
51:36 - writing out ignore case I could just put
51:39 - a capital i' there if i save that and
51:41 - run it that you can see that we get the
51:43 - same result now there are several
51:44 - different flags and we won't go over
51:46 - them all but there is you know there's a
51:49 - multi-line flag that allows us to use
51:52 - the caret and the dollar sign to match
51:54 - the beginning and end of each line in a
51:56 - multi-line string rather than just the
51:59 - beginning or end of the string there is
52:01 - also a verbose flag that allows you to
52:03 - add whitespace and add comments directly
52:06 - within your pattern which could help you
52:08 - break up complicated patterns into
52:10 - easy-to-understand segments now there
52:12 - are more flags but those are probably
52:14 - the most common and I think I'll cover
52:16 - flags further in a more advanced video
52:18 - now there's a lot of advanced features
52:20 - that we could go over with regular
52:21 - expressions in Python and judging from
52:23 - my last regular expressions video there
52:25 - seems to be a big interest in learning
52:27 - advanced expressions so I'll be sure to
52:29 - put together an advanced video covering
52:31 - those topics in the near future but
52:33 - hopefully now you feel pretty
52:34 - comfortable with being able to read and
52:36 - write these regular expressions within
52:38 - Python but if anyone does have any
52:40 - questions about what we covered in this
52:41 - video then feel free to ask in the
52:43 - comment section below and I'll do my
52:45 - best to answer those and if you enjoy
52:46 - these tutorials and would like to
52:47 - support them then there are some ways
52:49 - you can do that the easiest way is to
52:51 - simply like the video and give it a
52:52 - thumbs up also it's a huge help to share
52:54 - these videos with anyone who you think
52:55 - would find them useful and if you have
52:57 - the means you can contribute through
52:58 - patreon and there's a link to that page
53:00 - and it's scripts in section below be
53:02 - sure to subscribe for future videos and
53:04 - thank you all for watching
53:15 - you

Cleaned transcript:

hey there how's it going everybody in this video we're gonna learn how to work with regular expressions in Python using the built in re module and sometimes you'll hear these called reg X's now I recently released a video on regular expressions as a standalone topic because they can actually be used independently of any one programming language so you can use them to search for text patterns within text editors and things like that so this video will use a lot of those same same examples that I used in that video except here we're going to see a lot more that is Python specific so if you've never used regular expressions they basically allow us to search for and match specific patterns of text and they can look extremely complicated but that's mainly because there's just so much that we can do with them so you can create a regular expression for just about any pattern of text that you can think of so let's look at some examples and see what this looks like so I have a Python module here that we're going to use to search for some simple patterns to start out so first of all to use regular expressions within Python we need to import the re module which obviously stands for regular expressions so I'm doing that up here on line one and the text that we're going to be searching is this multiline string here so the variable name is text to search and we have a lot of things in here in this multiline string so you can see at the top we have some lower case some upper case some digits just some special characters a URL phone numbers and some names and also have a simple sentence here that we're going to use in an example as well now before writing our first regular expression we need to know what a raw string is because we're going to be using these a lot throughout this video now a raw string and Python is just a string prefixed with an R and that tells python not to handle back slashes in any special way so for example normally back slashes are used to specify tabs or new lines and things like that so if I was to print out the string backslash T and then just the text tab so if I run this then we can see that Python replaced our backslash T with an actual tab but a raw string will just interpret the string literally so if we put an R in front of this string and then run this then we can see that the backslash is no longer handled in any special way and that's important for us because we want our regular expressions to interpret the strings we're passing in and not have python doing any anything to them first so we'll be using these raw strings throughout the video so just be aware of what these are okay so let's write some expressions and search for some patterns so to write our patterns I'm going to use the re dot compiled method the compiled method will allow us to separate out our patterns into a variable and also we'll make it easier to reuse that variable to perform multiple searches so to use this we can just say that our pattern is equal to re dot compile and now we can specify our pattern so first let's just create a pattern that matches some literal characters so if we just wanted to search for the literal text ABC then we could say our for our raw string and then we could just pass in the literal text ABC and now that we have that pattern specified now let's actually search through our text with that pattern so I'm going to create a variable here called matches and I'm going to set this equal to that pattern dot find it er and I'll explain this more in just a second but what we want to search is our very long string up here at the top our multiline string called texts at search so I'm going to paste that in and now to print out all of our matches I'm just going to do a for loop and I'm gonna say for match in matches print out the match so if we save that and run it then we can see that this find it err method returns an iterator that contains all of the matches so we're going to look at more regular expression methods later in the video but I think that find it err is one of the best for gathering all of the matches and an easy to read format so each of these Mac match objects shows us the span and the match itself so the span is the beginning and end index of the match so when we search this text with this pattern using the find it err method it only found one match of ABC and it found it in our alphabet from indexes 1 to 4 now these indexes are useful because it allows us to use the string slicing functionality in Python where we could just plug in these values and get the exact match so if I was to print out our string from indexes one two four so I will print out text to search from indexes one two four now if I run that then we can see that we got ABC and that is the exact value that we matched now if you've never seen this string slicing functionality before and would like to see more of what you can do with that then I do have a separate video on that specific topic and I'll put a link to that in the description section below but for now I'll just go ahead and remove that now if I make my screen a little larger here and if we look at our text to search then this is the literal ABC that it matched right here but notice it didn't match this capital ABC and that's because this is case sensetive and this search right now is also looking specifically for ABC in that order so if we were to instead come down here and search for CBA and run that then you can see that we don't get any matches now if we scroll up here and look at this meta character section then I have some examples of characters that I say need to be escaped so say for example that I wanted to search for a literal period now if I just put a period in my search so if I change my pattern to where it is only searching for a period and I run this then we can see where it does this weird thing where it matches almost everything and that's because the dot is a special character and regular expressions and we'll see what that is in just a second but if we just want to actually search for a period then we have to escape it and we can escape these characters with a backslash so within my pattern here I'm going to put a backslash before the period and if I run that then we can see that if we look at all of our matches here then all of these matches are actual literal periods from our text so escaping those characters goes for any of these characters here in the meta characters section that I say needs to be escaped now one practical example of this might be a URL so I have a URL here that is quarry MS calm now if we wanted to match this exact URL then we would need to as scaped the dot in that URL by saying something like so I'll change my search pattern here and I'll just search for a literal quarry ms and then for the dot I would need to escape that dot so backslash dot com so if I save that and run it then we can see that we did match that URL okay so a literal search isn't too exciting because that's something that we probably already know how to do within Python really we want to use regular expressions to search for patterns and to do this we're going to use some of those meta characters that we were just escaping so in my snippets file here I have a list of values where we can see the types of characters that we can match and I'm going to split these into two columns so that it stays in view while we're going over these now I'll just move this over here and then go back to my simple file example that we were just looking at okay so now let's walk through each of these and see what we can match using regular expressions so we can see that the dot which we kind of looked at a little bit ago the dot matches any character except a newline so if I come in here and just put a literal dot for our regular expression with no backslash then if we run this then we can see that all of our matches match just about any character except it doesn't match new lines so it's matching all of the characters up here in our text to search that is not a new line so you can see that we have a lot of those matches now the backslash D matches any digit between 0 and 9 so if I put in a backslash D for our pattern here and run that then you can see that all of our matches are digits between 0 and 9 so there's not as many but you can see that they're all digits now the uppercase D matches anything that is not a digit and you'll see that this is kind of a common theme with these special characters here so you can see that the capital W matches not a word we haven't gone over that yet but the capital S matches not a whitespace so the capital letters basically negate whatever the lowercase version means so capital D is not a digit so if we put that in as our pattern and save that and run it then you can see that we have a lot matches here but all of these are matches that are not a digit so you won't find any digits here in our matches now the lowercase W is a pretty common search this is for a word character and a word character is anything that is a lowercase letter an uppercase letter a digit or an underscore so if we search for a backslash lowercase W and run that then you can see that all of these are either going to be lowercase letters uppercase letters digits which we have some digits here or underscores I don't think I have any underscores and our text to search so just like I was saying before the uppercase W will match anything that is not a word character so it's basically the opposite so I will search for an uppercase W if we run that then we can see that these are everything that are not our word characters so we have no lowercase letters no uppercase letters no digits and no underscores the backslash S here matches any white space so that consists of spaces tabs and new lines so if I put in a lowercase s here for our search and run that then you can see that we get all spaces new lines which are these backslash ends and I don't think I have any tabs in here but it would match tabs as well now the uppercase s matches anything that's not whitespace so anything that's not a space or a tab or a new line so if we search for that and run it then you can see that we might have a lot of matches in here but none of these are spaces or tabs or new lines now the one's a little bit lower here these are a little bit different now these are called anchors they don't actually match any characters but rather invisible positions before or after characters and we can use this in conjunction with other patterns for searching for so first we have this backslash B which is a word boundary and word boundaries are indicated by whitespace or a non alphanumeric character so for example if I scroll up here into our text to search you can see that I have these three Haws right here now let's say that we wanted to match all of the Haase that have a word boundary directly before so we can search that if we go down here to our pattern I can search that by saying backslash B which is our word boundary and then that literal text that we're searching for so I'll just search for ha and if I save that and run it then we can see that it matched two of these and I'm gonna scroll up here and show you which ones because it's not entirely clear just by glancing at the spans but it's matching the first one here because the start of the line is a word boundary and it's also matching the second one here because this space is also a word boundary now it's not matching this last one because there's no word boundary before it this is in the middle of a word now if we replace our search instead of a lowercase B we use an uppercase B and save that and run it then you can see that we have one match because that is matching all of these haws that do not have a word boundary before it so if we scroll up here to the top then basically it's just the opposite of our last search so it's matching this last one because it is the only one that does not have a word boundary before it okay so moving on we have this caret and this dollar sign and the caret will match a position that is the beginning of a string and the dollar sign will match a position that is the end of the string so if I scroll down here to our pattern then I have a small sentence variable here that I'm going to use to demonstrate this so let me spread this over here a little bit so that that fits on one line again now I'm gonna change the text that we're searching to this sentence instead of the text to search so I'm gonna paste that in there now first we'll look at the caret which is the anchor for the beginning of a string so if I was to search a pattern and say let's say so a caret and then I'm going to search for the literal text start so if I run that then we can see that it's searching for the literal text start that is at the beginning of that string of that sentence so if I change this to something that is not at the start then run that then you can see that now we get no match so this pattern here is actually in our sentence but the character says that it has to be at the start so if I undo that then we can see that that matched our start string there because it is at the beginning of the string and we can do something similar to match the end of the string using the dollar sign so if I search for the literal text e in D and then follow that with a dollar sign and then save that and run it then you can see that it matched this text here that's at the end of our string because we have the dollar sign there now if I was to replace this with something that is in our string but it is not at the end of the string and run that then you can see that even though we have A's in this string it doesn't match because it's not at the end okay so now I'm going to change our search back to the text to search and now we're going to look at some practical examples so I'm just gonna move this snippets file back here to one panel and we will keep looking at that throughout the video then I'll go back to my simple dot pie here so now let's say that we wanted to match these phone numbers here within our multiline string so let's write some regular expressions to do this now we can't just type in a literal search because they're all different now they have a similar pattern but they're not all the same digits so in this case we would need to use the meta characters instead of literal characters now we just have the pattern of three digits here and then a dash and this one has a period and then we have three more digits and then a dash or a period and then four digits so let's go ahead and create the pattern to match this so I'll try to fit both of these in to the screen here at once so we know that we can match any digit with a backslash d now that will match any single digit in the text like we saw before but with a phone number we can start off start off by matching three digits in a row so I'm going to put in three backslash deeds there so now if we run it at this point then you can see that all of our matches are all the three different combinations of three digits in our text to search Oh actually they're in a row so if I go up here to the top then you can see first it matched one two three and then four five six as the next one and then seven eight nine and then it moves down to the three digits of our phone number so that's a little bit closer but we need to complete this pattern so now that we're matching those first three digits now we're getting to the point and our phone number where we can match either a dash or a dot so for now let's just match any character now if we remember from our snippets that dot will match any character so if I just put this in after our three digits and that should match the hyphen or the dot but it should also match anything else so now let's continue and match the next three digits so just three more backslash DS and then we get to the point where we're going to match another dash or a dot so we'll just put in another dot to match any character there and now we're gonna match four more digits so for backslash DS so if I save that and run it then we can see that it matched let me make this a little smaller here then we can see that it matched both of our phone numbers from our text up here so now we're starting to see how this could be pretty powerful so I have a data dot text file here and this has a bunch of fake names and numbers and addresses and emails so let's open this file in Python and then run our regular expression against its contents and see if we can parse out the phone numbers from this text file so first to open this file let me scroll down here to the bottom and I'll put these in here so first we want to open the file and we can do that with with open and that is data dot txt and it's in the same directory so we can just spell it out like that without a full path and then we want to read this file as f now if you're unfamiliar with file objects then I do have a separate video on that as well and I'll leave a link to that in a description section below so now let's read in the contents of this file so I'm going to create a new variable here and call this contents and then we're going to set this equal to this F which is our file F dot read and that'll read in all of the contents and now to search the contents of that file for our pattern using our regular expression we can just copy our previous match here so I'm going to copy in this line to get our matches and paste that in and also I'm going to cut this out and move this up here and copy comment that out for now and paste that in down here ok so what we're doing here is we're reading in the contents of that file and now we're using the same pattern that we used up here to match our numbers in our text and now we want to search our contents instead of that text to search and then we're just going to print out all of those matches and we've got these matches comment it out so those shouldn't show anything so I will go ahead and run this okay so it looks like we are getting a unicode decode error I'm not sure why that's the case because everything in that data text file should be ASCII characters so to fix this really fast I'm just going to put in an encoding equals utf8 now I will fix this by the time that I put these files up so you shouldn't have to do this part I'm not sure why that is seeing a Unicode character in there but now that should solve it so if I save that and run it now we can see that we're getting all of our phone number matches from that data dot txt file so we can already see how using these regular expressions can be extremely useful for parsing information from our data ok so now going back to our text within this symbol file so I'm going to comment out the matches from the file there and uncomment out our matches from this file so now let's say that we only wanted to match a phone number if it had a dash or a dot so right now this pattern will match any separator that is here because we are using the period in our matches which matches any character so if I put another number in here that uses a different separator so for example let me put another number that uses like an asterisk for a separator so if I save that and run it then you can see that our pattern is currently grabbing that phone number as well so to only match the dash or the dot we can use something called a character set and a character set uses these square brackets with the characters that we want to match so I'm going to put in the square square brackets here and now the characters that we want to match in this position and we want to match a dash or a dot so I'm also going to replace this period which used to match any character now we're putting in a character set and we only want to match a dash or a dot so now if I save this and then you can see that we're still matching our first two numbers here that have a dash and a dot but we're not matching this third number that has that asterisk because this is not in our character set also you probably noticed that we didn't need to escape our dot within a character set and that's because character sets have some slightly different rules you can escape these characters if you'd like but it just makes it a little bit more difficult to read now even though the character set has multiple characters in the set it's still only matching one character in our text so it's matching a character that is either a dash or a dot now if I was to put two dashes up here in one of these numbers and save that and run it then you can see it doesn't match that because it only matches this first dash and that it moves right on to looking for another digit and that's something that can throw people off when they first start working with regular expressions because if you look at these character sets you can see a lot of different characters in here in this one we only have two characters in the character set but we'll see some sets later that are much larger but even though we have multiple characters in these sets it still only matches one character up here in our text so just keep that in mind because sometimes it can throw people off when they have you know long character sets that kind of look like something like this but all of this would still only match one character so now let me make sure that that number is back to normal and save that so to look at another example of a character set let's say that we only wanted to match 800 and 900 numbers so let me copy two of these numbers here and I will separate these with a dash and I'm going to make this one here an 800 number and then I'll make this one here a 900 number so I'll save that and go down here to the bottom now to match 800 or 900 numbers we're gonna have to change our first three digits here so the first digit it's going to be either an 8 or 9 so that's a good use for a character set so we'll create a character set and match either an 8 or a 9 and now the next two digits are just both going to be literal zeros so I'll put literal zeros in there save that and run it you can see for all of our matches it printed out only the 800 and 900 numbers so now if I perform that same search on the data file that we used before so I'll copy out our our comment out our matches there that we're looping through and uncomment our data txt file now this is still using the same pattern and we just changed that pattern to match 800 and 900 numbers so if I run this then that same code now should only print out the 800 and 900 numbers from that file and you can see from our matches here that that's what we get so that's pretty cool to be able to now match these more detail to patterns so now I'm going to remove this file section I believe that's the last we're going to use that and uncomment out that loop there now within a character set the dash is actually a special character as well when it is put at the beginning or in it will just match the literal character but when placed between values it can specify a range of values so for example we know that the backslash D matches any digit but if we only wanted to match digits between 1 and 5 to do that we could just change our entire pattern here to be a character set and if we just put in a 1 5 then with this dash between those values that's now going to specify a range so if I save that and run it if we look at our matches here all of our matches are going to be digits between 1 and 5 and we can use this for letters as well so if we wanted to match lowercase a through Z then we can just match let a lowercase a through lowercase Z so if I save that and run it and you'll see that all of our matches down here are lowercase letters now if we wanted to match uppercase and lowercase letters then we can just put these ranges backtoback so right after the lowercase a through Z then I can also just put in a range of uppercase a through Z so if I save that and run it now you can see that all of our matches down here are either going to be uppercase letters or lowercase letters and you could keep adding to that and add digits onto there if you'd like as well now another special character in our character set is the carrot so if you put a carrot at the beginning then I mentioned before that outside of the character set the matches the beginning of a string but within a character set it negates the set and matches everything that is not in that character set so for example when I put the carrot before this character set here it's going to now match everything that is not a lowercase or uppercase letter so if we run this then we can see that we get a lot of matches we get a lot of new lines and digits and spaces and things like that but none of these are lower or upper case letters so let's add to our text to search here and let's say that we wanted to match the words cat mat Pat and all other threeletter words that end in 80 but we don't want to match the word bat now to write a regular expression for that instead of specifying all the characters except for a B we could just use our negation there of the character set and just say that we want everything that is not a B followed by a literal a T so if we run that then we can see that for our matches we matched cat mat Pat but we did not match this bat and that is because that carrot negates that character set of only this B character okay so now I'm going to remove those from our text now everything that we've looked at has involved single characters so far so for example this is saying match any single character that isn't a B followed by an a followed by a T but we can use things called quantifiers to match more than one character at once so let's go back to our original phone number expression from earlier and will match any character for the separator for now so I'm going to fill in that pattern so we want three digits just a period to match any character for a separator three more digits a period for any separator and then four digits so just make sure we type that correctly let me save that and run it and you can see that we're still matching these numbers just fine but you can see that we're searching for all of our digits one character at a time and it's easy to make mistakes when you have a lot of these to type out but we can use something called a quantifier to match multiple characters at a time so let me open up my snippets file again here and I'm going to again open this up into two columns and move this over now let me scroll down to the quantifiers and read through these and also let me go to my simple example back here again so that we can see this okay so our first quantifier here we have an asterisk and an asterisk will match zero or more of the pattern that we're looking for now a plus sign will match one or more the question mark will match zero or one and if we use these curly braces with a number inside that will match that exact number of the pattern if we use these curly braces with two numbers separated by a comma that will match a range of numbers and that first number is the minimum and the second number is the maximum so for our phone number over here this would be a good case to use exact numbers so instead of writing all of these out I can just go back here to this first digit that we want to match I could put in curly braces and say that I want to match three of those digits and I can do the same thing for the second section of digits there and then for the last we want to match four digits at the end so I can save that and run it and you can see that we still get the same result so that allows us to specify the amount of digits that we're looking for without needing to type them all out and possibly making a mistake along the way now here we're matching exact numbers but sometimes we don't know the exact number and we'll need to use these other quantifiers so for example down here at the bottom of our text we have these names and some lines start with the prefix of mr some start with Miss and some start with misses so let's say that we wanted to write a pattern that would match these prefixes and the entire name that comes afterward so to start off easy let's first start by just matching the names that start with mr now we can see that some of these have a period after the prefix and some do not so mr. Smith does not have a period here so to handle this let's see if I can fit all of this in here I'm gonna cut off our loop but that's okay so to write our pattern here we want to search for mr and we want to have a period after here so if we run this right now then you see that we have two matches but there are three misters up here so it's matching both of these mysteries that have the period after the prefix but this one is not currently matching now to match that we need to say that the period after the prefix is optional and we can use the question mark quantifier to do this which tells our pattern that we want to match either zero or one of those characters so if I put a question mark after our period there and then rerun that then we can see that now it is matching those m RS without the period so now to complete this pattern now after that optional period we have a space and now we're running into uppercase letters said to match uppercase letters we can use a character set like we looked at before and we can just pass in a capital A through a capital Z to match all the uppercase letters so now if we run this then we can see that we are matching up to the first letter of the Matt of the last name for all of these names now at this point we have a decision to make after the first uppercase letter we've completely matched the name for mr. t that we can see here but we still need to match the rest of our other names so we could say that we will match any word character after that uppercase letter and we can do that with a backslash W after that first uppercase letter and now we need to decide what quantifier we want to use for our word characters so we could use the plus sign quantifier which would match one or more of these word characters so if I put in a plus sign here and run this we can see that when we do that it matches mr. Schaefer and mr. Smith but it doesn't match mr. t because mr. t doesn't have a word character after that first uppercase character so a better solution here might be to use the asterisk quantifier which allows us to match zero or more of these word characters follow that first upper case so if I save that and run it now you can see that now that it's matching zero or more it includes mr. t in there and the other names now I know that we've covered a lot so far but we've just got a few more concepts to go and then we'll look at some examples that wrap everything together so we still haven't matched our miss or misses names up here so how would we do that now you might think that we should use a character set that matches either an R or an S after the after the M and there's probably some ways that we could do that and get it to work but it would be a bit ugly because then we'd have to match an optional s after that for the misses as well I think a better solution here would be to use a group now we haven't looked at groups yet but groups allow us to match several different patterns so to create a group we use parentheses and within the parentheses we can match some patterns so let's say that we wanted to match a literal R after the M and then we can use this vertical bar character which is basically an or so we can say R or a literal s and then another vertical bar and then we can say or a literal RS so now we have three different patterns here capital M followed by either an R and s or an RS so now with that little change if I save that and run it and pull this up a little bit now you can see that now we are matching all of our names now I was just saving some characters by doing it this way if you think it's more easy to read then we could have also put the M within this group as well so I could have just put an entire group here at the beginning and said mr. miss whoops miss or misses so it adds more characters but it's also a little bit more clear exactly what those groups are matching if we move that M within at the group there and if we save that and run it then we can see that we still get the same results now these groups can actually be used to capture sections of your matched regular expression and that's something what that will look at in just a minute but for now let's do a quick recap of everything that we've learned so far by looking at some examples that incorporates all of these things together so I'm going open up this emails dot PI file here and I might make the text just a little smaller so that we can fit everything in one window so I've got a file here where I have this emails variable and we have three different email addresses within this string that are fairly different emails now let's try to write a regular expression that will match all of these emails so let's match the first email address first so let's go ahead and come down here into our pattern where we are doing the re compile and now we want to put our regular expression pattern within here so first let's just match everything before the @ symbol here and we can see that everything before that @ symbol there just uppercase and lowercase letters so to match uppercase and lowercase letters we can just use a character set with a lowercase 8th or a lowercase Z followed by an uppercase a through an uppercase C and now we want to match one or more of those until we hit the @ symbol so to match one or more we can use the plus sign and we want to match one or more of those all the way up until we hit the @ symbol and we can just put in a literal @ symbol for that now after the @ symbol we have only lowercase letters but let's go ahead and put uppercase letters in that character set as well so we'll do lowercase letters with a lowercase 8th through Z and an uppercase a through Z and again we'll put in a plus sign to match one or more of those and then finally we'll match those all the way up until we hit this dotcom itself so for now we can just put in a literal match for that so I could say backslash dot to literally match that dot there and then just a com4 com so if we save that and run it then we can see that we matched that first email address now just to get some more space here I think we're done with the snippets file for now so I'm going to bring this back over here go to view and make this a single column again and go back to my emails file so now that we're matching the first address here let's build this up so that it matches the other two as well now it looks like it's not matching the second address because we need to allow a period in the first part of the expression because we have a period right here so we can add to the character set of the first part just by putting a dot in that first part of the character set there and another thing that's different is that this ends with a dot edu instead of a dot com so to match that we could just match a group here so I will wrap this calm in parentheses to create a group and we can say that we want to want match calm and use the vertical bar as an or and say or dot edu so if we save that and run it you can see that now we are matching that second address as well okay so good so we're building this up a little bit at a time so finally to match our final address it looks like we need to allow numbers and a hyphen in the characters before the @ symbol so again we can just add this to our character set so we can come here to our ranges and add the digits 0 through 9 onto the end of that and we also want to put a hyphen at the end of that character set and it looks like we also have a hyphen and our domain here so this is the character set for our domain so we can add in 2 there as well and lastly instead of a.com or a descendant net so let's add that to our group here so we'll just put in another vertical bar and add in dotnet so if we save that and run it then you can see that now we're matching all three of our email addresses now with something like email addresses it can be pretty tough writing your own regular expression from scratch but there are a lot of these available online and once we learn how to write regular expressions then we should be able to read them and figure out what they'll match now I've always found that reading other people's regular expressions to be a lot harder than writing them but let's look take a look at one and see if we can do this so there is a regular expression that I pulled off line that matches email addresses and I have this here in my snippets file at the bottom so let me copy this over and paste it in as our expression and let's walk through this so first of all just let me save it and run it to make sure that it still matches all three of our email addresses and it does now this looks a little intimidating but really these are just some large character sets here so first we have a character set that matches all lowercase letters all uppercase letters all digits then we have its matching an underscore a period a plus sign or a hyphen and then we have a plus sign that will match one or more of any of those characters in the character set and it matches those all the way up until it hits our @ symbol now after the @ symbol for the domain we have another large character set here and this matches any lowercase any uppercase any digits or any hyphens now I don't know a lot about email addresses but I'm assuming that since they left out the underscore the period and the plus sign that these aren't valid for a domain so then that is followed by a plus sign here that will match one or more of any of these characters and the character set all the way up until it hits the last period in that period is escaped with a backslash and then after that dot it will we have another character set which will match any lowercase uppercase digits hyphens or another dot and that plus sign will match one or more of any of those characters so reading regular expressions written by other people is probably one of the hardest parts of all this but if you walk through it bit by bit then you should be able to break it down like that for just about any pattern okay so the last concept that I'd like to look at in this video is how to capture information from groups now we've already seen how to match groups but we can actually use the information captured from those groups so to show an example of this I'm going to open up this file here called URLs dot PI and again let me take this down just a little bit here so that we can fit everything okay so with these URLs here we can see that some of these URLs are HTTP some are HTTPS some of them have www for the domain and some do not so they're pretty inconsistent so let's say that for each of these URLs we only wanted to grab the domain name followed by the toplevel domain so in this case it would be you know for example google.com or Cory M s calm or youtube.com or nasa.gov and we just wanted to ignore everything else so let's see how we can do this so first let's write and Express that actually matches these URLs so we can say in our re dot compiled here we're creating our regular expression pattern so we can say http/2 match a literal HTTP now some of these have HTTPS and some do not so we want to match an S but put a question mark after it because if you remember the question mark matches 0 or 1 so basically it makes that s optional so then after that optional s we want to match a colon forward slash forward slash and now here we have an optional ww some have WWE and some do not now you may be thinking that what we could use a character set or something here but it's actually going to be best to use a group because within a group we can just say that that entire www with the dot and remember we have to escape that with a backslash a backslash dot that entire group is optional so just to make sure we're on the correct path if we save this and run it now you can see that we're all the way up to the domain name on all of these matches so far so let's go ahead and continue so now to match the domain name we can just match any word character so we'll just put a backslash W to match a word character and then a plus to match one or more of those and we want to want match one or more word characters all the way up to the dot so we will put in a backslash dot there to match that now we want to match the top level domain which is calm or gov so we can just match word characters again and one or more of those with a period after that so if we save that and run it then you can see that now we are matching the entire URL for all of these URLs that we have listed ok but remember that the point here was to use our groups to capture some information from the URLs so let's capture the domain name and the toplevel domain and by the toplevel domain again I mean the dotcom or the dot gov so to capture these sections we can just put them in a group by surrounding them with parentheses so for example this section here was our match for the domain name so I just surround that in parentheses there and then our toplevel domain we want to include the dot so this would be the dotcom or the dot gov so we'll put the parentheses before the dot and then here at the very end so since we just added groups to an existing expression that shouldn't actually change our results so if we rerun this we can see that we still get the same results there but now we actually have three different groups so the first group is the optional ww the second group is our the word characters that make up the domain name and the third group is the toplevel domain which is the dotcom or the dot gov now there's also a group 0 and group 0 is everything that we captured so in this case it's just the entire URL so this would be group 0 here so to show this our match object down here that we are iterating through this match object actually has a group method and we can pass in the index of the group that we want to see so we can say dot group to use that group method and now we can print out group 0 by just doing group 0 so if we print that out then like I said group 0 is the entire match so that's just the entire URL now if we printed group 1 this should be the optional ww so if we save that and run it then we can see that the URLs that have aaww dot print that out as the group and the ones that don't just print out none values so our group 2 here should be our domain name so if I print out group 2 and run that then we can see that that's what we got so we got Google query MS YouTube and NASA now group 3 should be our top level domains so if we print out group 3 and run that then you can see that we get calm calm calm and gov now we can use something called a back reference to reference our captured group and it's basically just a shorthand for accessing these group indexes so the regular expression module has a sub method that we can use to perform a substitution so let's see what this looks like and we can substitute in these back references which reference the groups so for example let's just show an example and that will become more clear so I can create a sub URLs variable here and I will set that equal to pattern dot sub and now we want to pass in the substitution so the substitution that we want to use are these back references that reference these groups so we wanted to replace these URLs with the domain name and the toplevel domain so the domain name was group 2 and we use these back references with a back slash and then the number of the group so we want to replace these with a back slash 2 which is that a domain name and then a back slash 3 which is the toplevel domain and now we need to pass in the text that we want to replace so let me walk through this one more time just because that can be a little computing so here we are creating a pattern and this pattern as we saw matches all of our URLs here in our string and then our subdue our LS we are using that pattern to substitute out group 2 and group 3 for all of our matches in URLs so every time it finds a match it will replace that match with group 2 which is the domain name and then group 3 which is the toplevel domain so now just to show how that worked let's print out that subd URLs and save that and print it out and scroll up here and we can see that that returned a new string with all those substitutions made so if you had a large document of things that you wanted to reformat like this then learning how to do this with regular expressions could save you a ton of time and allow you to do that within just a couple of minutes okay so we're really close to being finished up here we should now have a pretty good understanding of working with regular expressions in Python but we've been using this find it err method throughout the whole video and that's because I think it does the best job of showing all the matches and the location of those matches but there are other methods that we can use for different purposes so let's take a quick look at some of those so first we have the find all method with the find it er method that we were using it returns match objects with extra information and functionality but find all will just return the matches as a list of strings now if it's matching groups then it will only return the groups so in the example we're currently using a pattern where we match those names and we have a group here at the beginning for the prefix so this is only going to match that group so if I save this and run it then you can see that it only prints out that first group and if there are multiple groups then it would return a list of tuples and the tuples would contain all of the groups now if there are no groups then it would just return all of the matches in a list of strings so if I was to change this to this pattern here to our previous phone number example so I'll do a digit of with a quantifier of three then just a dot to match any character digit with a quantifier of three any character and a digit with a quantifier of four if we save that and run it then you can see that it prints out just a list of all of our phone numbers so that's one way to print out all of your matches that you match but personally I like the find it err method a little bit more because it comes with that extra functionality of that match object so next we have the match method now match will determine if the regular expression matches at the beginning of the string so for example let's change our pattern to search for our simple sentence here and we'll just search for the literal string of start and we want to search that sentence variable so instead of that text to search will put sentence in there and instead of find all we want to see what the match method does so let's save that and run it so we got an error here because match doesn't return an iterable like find it or find all it just returns the first match and if there isn't a match then it returns none so instead of looping through our result we can just print out that matches variable so we'll just print out matches there and save that and run it and we can see that it returns that match object with match now this only matches things at the beginning of strings so if we were to search for something else that is in this sentence so I'll search for this sentence pattern right here if I save that and run it then we can see that it returns none because it's only seeing if this is matching at the beginning of that string if we want to search for matches within the entire string then we can use the search method now I'm not sure why they have a match method when regular expressions themselves have the caret to specify match results at the beginning of strings but I'm sure that there's probably some reason that I don't know of so if we wanted to search the entire string for that pattern then we can use the search method instead and just like match this only prints out the first match that it finds so if I save that and run it then we can see that it printed out that match object with the match there now if we search for something that doesn't match then this just returns none as well so if we search for something like D and E 4 does not exist if we save that and run it you can see that it just returns none since it didn't find any of those patterns in our sentence okay so the very last thing that I want to cover in this video and we'll cover it very quickly is flags and we can use flags to make our lives a bit easier when working with regular expressions in Python and you may see some of these at some point when you start using them more often so let's go ahead and take a look so for example let's say that we wanted to match a word but match it whether it was in uppercase or lowercase or a mixture of both so for example if I wanted to match the word start and our sentence but each letter could be uppercase or lowercase then normally to create a pattern like this you would have to do something like you know a character set that started with an uppercase s or a lowercase s and then followed by an uppercase T or a lowercase T and then an uppercase a or a lowercase a and you kind of get the point but since that's kind of a pain instead we can just search for that literal text and I'll just put those in all lower and then we can just add a flag to our pattern here so for this we want to use the ignore case flag so we can either write this out so this is going to be re dot this is gonna be all caps here ignore case and if we save that and run it then you can see that even though our pattern here has a lowercase s and this has an uppercase s it still matches that pattern because we have our ignore case flag here and there are short hands for these flags as well so instead of writing out ignore case I could just put a capital i' there if i save that and run it that you can see that we get the same result now there are several different flags and we won't go over them all but there is you know there's a multiline flag that allows us to use the caret and the dollar sign to match the beginning and end of each line in a multiline string rather than just the beginning or end of the string there is also a verbose flag that allows you to add whitespace and add comments directly within your pattern which could help you break up complicated patterns into easytounderstand segments now there are more flags but those are probably the most common and I think I'll cover flags further in a more advanced video now there's a lot of advanced features that we could go over with regular expressions in Python and judging from my last regular expressions video there seems to be a big interest in learning advanced expressions so I'll be sure to put together an advanced video covering those topics in the near future but hopefully now you feel pretty comfortable with being able to read and write these regular expressions within Python but if anyone does have any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are some ways you can do that the easiest way is to simply like the video and give it a thumbs up also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page and it's scripts in section below be sure to subscribe for future videos and thank you all for watching you
