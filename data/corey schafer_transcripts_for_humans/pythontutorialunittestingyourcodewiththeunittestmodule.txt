With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're going to learn about
00:02 - unit testing in Python so we'll go over
00:04 - how to write tests how to setup and
00:06 - teardown your test and also some best
00:08 - practices so if you're not currently
00:10 - testing your code then it's definitely
00:11 - something that you're going to want to
00:12 - learn and start adding to your projects
00:14 - so a lot of you have probably heard of
00:16 - testing but you might not know exactly
00:18 - what it is
00:19 - testing your code is the most exciting
00:21 - thing to do but there's a reason that
00:23 - most companies and teams require their
00:24 - code to be thoroughly tested and if
00:26 - you're going to get a job working on any
00:28 - large projects then you're going to need
00:29 - to know how to properly write tests and
00:31 - the reason for that is that it's going
00:33 - to save you a lot of time and headache
00:34 - down the road so when you write good
00:36 - tests for your code it gives you more
00:38 - confidence that your updates and
00:40 - refactoring don't have any unintended
00:41 - consequences or break your code in any
00:43 - way so for example if you update a
00:45 - function in your project those changes
00:47 - may have actually broken several
00:49 - sections of your code even if that
00:51 - function itself is still working and
00:53 - good unit tests will make sure that
00:55 - everything is still working as it should
00:56 - and if it's not then it will show you
00:58 - exactly what's broken so in this video
01:00 - we're going to be going over everything
01:02 - that you need to know to get started
01:03 - with the built-in unit testing module so
01:06 - with that said let's go ahead and get
01:07 - started
01:07 - so right now I have a basic script
01:09 - pulled up here that has some simple
01:11 - functions and I want to start off using
01:12 - these really simple functions so that we
01:14 - can just focus on what the tests look
01:16 - like now what a lot of us start doing to
01:19 - test our code is just put in print
01:21 - statements and occasionally run the code
01:23 - so for example down here at the bottom
01:25 - if I wanted to test that my add function
01:28 - was working I could just say print add
01:30 - and add together ten and five and if I
01:33 - run that then we can see that the output
01:35 - that we got looks right but testing your
01:38 - code this way isn't easy to automate and
01:40 - it's also hard to maintain so also if
01:43 - we're testing a lot of different
01:44 - functions then there's no way for us to
01:46 - see at a glance what failed and what
01:48 - succeeded so that's where unit testing
01:51 - comes in so we're going to go ahead and
01:53 - just move remove this print statement
01:55 - and actually start adding some unit
01:57 - tests so to do this first we need to
01:59 - create a test module so I'm going to
02:01 - create a new file here in this current
02:03 - directory and I'm going to call this
02:05 - test underscore calc dot py now that's
02:10 - the naming convention when writing tests
02:11 - is to start with tests
02:13 - underscore and then what you're testing
02:15 - so in this case it was test underscore
02:17 - calc and that's actually going to be
02:20 - required within our test so now we have
02:23 - this test underscore calc module pulled
02:25 - up and we're currently working with an
02:27 - MP file
02:28 - so first let's import the unit test
02:30 - module now this module is in the
02:32 - standard library so there's no need to
02:34 - install anything you can just say import
02:36 - unit test and now we're also going to
02:39 - want to import the module that we want
02:40 - to test so I'm going to import that calc
02:43 - module and we can import calc from here
02:45 - since it's in the same directory now if
02:47 - you're testing code from a different
02:49 - directory and can't get your imports to
02:50 - work then you can watch my video on
02:52 - importing modules and it should help you
02:54 - figure out how to properly get that set
02:56 - up so now we need to create some test
02:59 - cases for the functions that we want to
03:00 - test and in order to create those test
03:02 - cases we first need to create a test
03:05 - class that inherits from unit test dot
03:07 - test case so to do this we're first
03:10 - going to create a class and we will call
03:13 - this test calc now you can call that
03:16 - class whatever you like but try to keep
03:18 - it descriptive as to what you're testing
03:20 - and we're going to want to inherit from
03:23 - unit test dot test case so inheriting
03:28 - from unit test test case is going to
03:30 - give us access to a lot of different
03:32 - testing capabilities within that class
03:34 - so let's write our first test so to do
03:38 - this we'll write a method and the method
03:41 - needs to start with test underscore now
03:45 - that naming convention is actually
03:46 - required so that when we run this it
03:48 - actually knows which methods represent
03:50 - tests so if the method doesn't start
03:52 - with the word test then they won't be
03:54 - run and we'll see what that looks like
03:56 - in just a minute so ours will be test
03:58 - underscore and then what we're testing
04:01 - so first we'll just test the add
04:03 - function of our calcul so we'll call
04:06 - this test underscore add and just like
04:09 - any method in a class this takes self as
04:11 - the first argument and now within our
04:14 - method we can write our test so since we
04:17 - inherited from unit test test case we
04:19 - have access to all these assert methods
04:21 - and I have them all pulled up in the
04:23 - documentation here over in Chrome so we
04:26 - can see that we can assert
04:27 - whether two values are equal with assert
04:30 - equals not equal with assert not equal
04:33 - true assert false and the documentation
04:36 - shows you exactly what all of these
04:39 - check for so for example assert is not
04:42 - none checks whether a variable is not
04:45 - none so the documentation has a good
04:47 - overview of all these asserts and then
04:49 - over here what it actually checks for
04:52 - and I'll also leave a link to this in
04:54 - the description section below so now
04:56 - let's switch back to writing our test so
04:59 - we're going to use assert equals to test
05:01 - our add function so I can run our add
05:03 - function from here by saying something
05:06 - like result is equal to calc add and
05:11 - we'll just add those same values 10 and
05:13 - 5 and we would expect this to equal 15
05:16 - so to test this we can say self dot
05:18 - assert equals and now we want to assert
05:22 - that that result is equal to 15 okay so
05:26 - now how do we run this test so we could
05:28 - do it from the command line so I have my
05:30 - command line here pulled up and I am
05:33 - navigated to the directory where our
05:35 - module is currently located now you
05:37 - might think that we could just run the
05:40 - test by saying you know Python test
05:43 - underscore Cal PI but if I run that you
05:46 - can see it doesn't actually return
05:47 - anything so instead we need to run unit
05:50 - tests as our main module and pass in
05:53 - test underscore calc and we can do that
05:55 - by saying Python - m and then
05:59 - unit test and now the test underscore
06:03 - calc I
06:05 - module and we can see that when we run
06:07 - that it puts a dot here and it says one
06:11 - ran one test and at the bottom it says
06:14 - ok so that means that everything passed
06:16 - now it would be nice if we could just
06:18 - run our tests using this first method
06:21 - here by saying Python test underscore
06:24 - calc and just running the module instead
06:26 - of using this longer command here and
06:28 - setting it up to run that way but also
06:30 - allow us to run our test from directly
06:33 - within our editor so to do this we can
06:36 - just come down here to the bottom and we
06:38 - can say if name double underscore name
06:41 - is equal to in quotes here double
06:45 - underscore main and then within this
06:48 - conditional we can just say unit test
06:50 - dot main and run that now if you don't
06:54 - know what this double underscore name
06:56 - equals double underscore main is doing
06:59 - this actually isn't related to unit
07:01 - testing at all I do have a separate
07:04 - video specifically what that is about
07:06 - but basically it's just saying that if
07:08 - we run this module directly then run the
07:10 - code within the conditional and that
07:12 - code within our conditional is this unit
07:15 - test dot main and that unit test dot
07:17 - main will run all of our tests so now if
07:20 - we go back here this is now saved if we
07:22 - go back here to our terminal and I will
07:25 - clear this out so now let's rerun that
07:27 - using that first method of just Python
07:30 - and our test module and if we run that
07:32 - you can see that now we can run it
07:34 - directly and it runs our unit test and
07:36 - says that it passed and since we can run
07:38 - it this way within the terminal that
07:40 - should mean that it can also run within
07:43 - our editor so if I run this then you can
07:46 - see that within our editor we can now
07:48 - run these tests also okay so that's good
07:50 - so we're running our first test so it's
07:52 - saying that we're only running one test
07:54 - now do you remember earlier when I said
07:56 - that your tests have to start with the
07:58 - word test well let me show you what it
08:01 - does if it doesn't so instead of test
08:03 - underscore add here as our test let's
08:06 - call this add underscore test and save
08:08 - this and run it so when we run this it
08:11 - might not be obvious right off the bat
08:13 - that anything is wrong because we didn't
08:15 - get any errors or any warnings but if we
08:17 - look at how many tests ran it says zero
08:20 - so this test would just skipped so you
08:22 - have to be careful that all of your
08:23 - tests are named properly and start with
08:26 - the word test so let's go ahead and
08:27 - change that back and rerun it okay so
08:30 - now what happens if our test fails so
08:33 - let's change this value here with the
08:35 - assert equals the result is equal to 15
08:38 - let's change this to a 14 so that our
08:41 - test of adding 10 and 5 fails so let's
08:44 - save that and run it so now if I pull
08:47 - this up a little bit here to where we
08:50 - can see we can see that in stead of a
08:53 - dot
08:53 - an F for fail and it also shows us that
08:56 - the test failed with an assertion err
08:59 - that 15 is not equal to 14 okay so now
09:02 - let me pull this down just a little
09:03 - further here and now let's change this
09:06 - test back and also add in a few more
09:09 - tests so first of all instead of setting
09:12 - this result variable and testing that
09:14 - I'm just going to instead drop our
09:16 - function directly into the assert
09:18 - statement so I'm going to copy this and
09:21 - replace that result variable actually
09:23 - with our add function and then I can
09:26 - just get rid of that result variable
09:28 - there so you usually want to also check
09:31 - some edge cases so let's copy and paste
09:33 - this line here a couple of times and
09:36 - test a couple of edge cases so one edge
09:39 - case might be one negative number and
09:41 - one positive number so let's make sure
09:43 - that negative one plus one is equal to
09:47 - zero and two negative numbers would also
09:50 - be another edge case so let's make sure
09:52 - that negative one plus negative one is
09:55 - equal to negative two so now if we save
09:59 - this and run it then it's saying that it
10:01 - passed but it also says that it ran one
10:03 - test now you may have been expecting
10:05 - this to say that it ran three tests but
10:08 - really these three assert methods here
10:10 - are just within this single test called
10:13 - test underscore add but even though it
10:16 - still says that there's only one test we
10:18 - still made this test better by adding in
10:21 - these additional checks so it's not our
10:23 - goal to write as many tests as possible
10:25 - but just make sure that we write good
10:27 - tests so that's something that a lot of
10:29 - people get tripped up one they just
10:31 - shoot for you know full coverage without
10:33 - making sure their tests are actually
10:36 - good enough to catch mistakes so try to
10:38 - be mindful of that when writing tests
10:39 - and in order to add more tests we just
10:42 - add in more test methods so let's test
10:45 - the rest of our calc functions so I will
10:47 - just copy and paste this test add
10:50 - function here three more times and I'm
10:54 - going to get rid of our output here so
10:56 - we can see a little bit better and now
10:58 - I'll change these to test all of our
11:00 - calc functions so I'll test our
11:02 - subtraction function by changing all of
11:05 - these ones here too
11:07 - correct and now let's change our assert
11:09 - equals so 10 minus 5 will be 5 negative
11:13 - 1 minus 1 will be negative 2 and
11:16 - negative 1 minus negative 1 should be 0
11:21 - and now moving down the line here let's
11:22 - change this next test to be multiplied
11:26 - so now for our assert equals we want to
11:29 - test that 10 multiplied by 5 is 50
11:32 - negative 1 multiplied by 1 is negative 1
11:36 - negative 1 multiplied by negative 1 is 1
11:39 - and then let's change this last method
11:41 - here to test our divided function so we
11:44 - want to test divide so now in our
11:46 - certain statements here we want to make
11:48 - sure that 10 divided by 5 is equal to 2
11:51 - negative 1 divided by 1 is negative 1
11:55 - and negative 1 divided by negative 1
11:57 - will just be 1 so now if I run this code
12:01 - with all 4 of these tests then you can
12:03 - see that we got 4 dots and it says that
12:05 - we ran 4 tests and all of those tests
12:08 - pass with all of those assert equal
12:10 - statements so you can imagine how useful
12:12 - this is so if you have a module with
12:14 - some complicated functions then once you
12:16 - put in the work to write good tests like
12:18 - this then you can just come back and
12:20 - rerun these tests to make sure that
12:22 - everything still works so if you change
12:24 - something in your program that you think
12:26 - will work but it actually broke some
12:28 - stuff then your test should catch that
12:30 - so for example let's say that I came in
12:32 - here to our calc function and we just
12:36 - made a typo in this multiply function
12:38 - and instead of 1 asterisk there we put 2
12:40 - now this is actually going to return X
12:43 - to the power of Y so if we come back
12:45 - here to our tests and rerun this then we
12:48 - can see that if we look here at our
12:50 - output that we have 2 dots and then an F
12:53 - and then a dot so that means that 3 of
12:56 - our tests pass and 1 test failed and the
12:59 - one that failed it says that we have an
13:01 - assertion error that the 10 times 5
13:04 - should actually be equal to 50 and it's
13:07 - not instead we got this value here so
13:09 - that gives us an idea of exactly where
13:11 - the problem is and where we can make
13:13 - that change to get these tests to pass
13:15 - again so let's go ahead and go back here
13:17 - and change this back now sometimes you
13:19 - might make a change that
13:20 - doesn't actually break your test but
13:23 - well actually unexpectedly break your
13:25 - code so for example let's say that we
13:28 - came in here and changed our divide
13:30 - function to be for division instead of
13:33 - regular division and we can do this by
13:35 - changing this to two division signs now
13:37 - if you don't know what floor division is
13:39 - basically it just doesn't give you the
13:41 - remainder now our current test won't
13:43 - catch this because right now all of our
13:46 - and let me save this here so right now
13:49 - all of our divisions currently come out
13:51 - two whole numbers anyway so it doesn't
13:53 - matter for using for division or regular
13:55 - division so if we run our tests and we
13:58 - can see that currently all of these
13:59 - tests are passing so let's say that at
14:02 - some point that for division broke our
14:04 - program and after some debugging we
14:06 - traced it back to that and found the
14:09 - problem now in that case it's always a
14:11 - good practice to go update your tests
14:13 - with a test that would have caught the
14:15 - problem that you just found that way we
14:18 - can know that we don't revisit the same
14:20 - bugs over and over so for example a test
14:23 - that would have caught this I'm going to
14:25 - copy in a sequel statement here now a
14:29 - test that would have caught this is if
14:31 - we would say you know 5 divided by 2 we
14:35 - want that to actually equal 2.5 but with
14:39 - floor division that's actually just
14:40 - going to equal 2 so now if we run this
14:43 - then we can see that we got our error
14:45 - because we're using that floor division
14:47 - and we can see that it is an assertion
14:49 - error that 2 is not equal to 2.5 so that
14:54 - should point us in the right direction
14:55 - and then we can go and see why that
14:58 - would be the case and then we can find
14:59 - out that we're using floor division
15:01 - there instead of regular division and
15:02 - fix that go back to our test and run it
15:05 - and now they're all passing ok so now
15:07 - there's one more thing within our calc
15:10 - file here that we can see we can see
15:13 - here that we are checking if the number
15:16 - that we're dividing by is zero and if so
15:19 - then we're raising a value error with
15:22 - the message that we can't divide by zero
15:24 - so we'll likely want to test that our
15:27 - expectations are working on that as well
15:29 - so but this is done a little differently
15:33 - than the other assertion
15:34 - so let's go back to our test and show
15:37 - how we can test that dividing by zero
15:39 - raises this correct error so there's
15:42 - actually two ways that we can do this so
15:45 - first we could say self dot assert
15:48 - raises and within assert raises first we
15:52 - want to pass in the exception that we
15:55 - expect and that is a value error and now
15:59 - the function that we want to test and
16:01 - that is calc divide now we're not
16:03 - putting parentheses or any arguments
16:06 - there we're putting the arguments as
16:08 - arguments to this assert raises method
16:10 - so let's look at this one more time so
16:13 - our first argument is the exception that
16:15 - we expect the second second argument is
16:18 - the function that we want to run but we
16:20 - aren't passing arguments to the function
16:22 - so leave off the parentheses and then we
16:25 - pass in each argument that we want to
16:27 - pass into the divide function separately
16:29 - so now the reason that we have to do it
16:32 - this way instead of just running the
16:34 - function normally is because our
16:35 - function would actually throw that value
16:37 - error and our test will think that
16:39 - something failed but we'll look at a way
16:42 - that we can do this right after this
16:44 - test so right now if we run this then we
16:47 - can see that this is currently passing
16:49 - and that's because the 10/0 did throw
16:52 - this value error so if I was to change
16:55 - this zero to a two then it's not going
16:58 - to throw that value error so if I run
17:00 - that then it failed and we can see that
17:03 - the assertion error is that value error
17:05 - not raised by divide so which makes
17:09 - sense if we divided by two so if we
17:11 - divide by zero that test passes now I've
17:14 - never preferred this method of testing
17:16 - exceptions because I just like to call
17:18 - the function that I want to test
17:20 - normally instead of passing in all of
17:22 - the arguments separately like we're
17:24 - doing here and we can do this if we test
17:27 - the exceptions using a context manager
17:30 - now that will allow us to handle and
17:34 - check the exception properly and also
17:37 - call our function normally so to do this
17:40 - I'm actually going to get rid of
17:41 - everything here and to do this we say
17:44 - with self dot assert raises value
17:48 - err and that's using the context manager
17:50 - and within this context manager we can
17:53 - just call our function normally like we
17:55 - normally would so calc divided and we'll
17:58 - divide 10 by zero and save that and run
18:01 - it then you can see that by using this
18:03 - context manager that all of those tests
18:05 - still pass so you can choose either
18:07 - method that you prefer but I've always
18:10 - preferred to use the context manager
18:11 - when testing exceptions okay so now
18:14 - let's look at writing slightly more
18:16 - difficult tests so I have a simple
18:20 - employee class here and this is the
18:22 - employee class from the object learning
18:24 - series and if you don't know exactly
18:26 - what this class is doing then it's not
18:28 - really important we're just going to see
18:30 - how this affects some testing strategies
18:33 - so basically what this code is doing is
18:35 - that allows us to create employee
18:37 - instances where it will set the
18:40 - employees first-name and lastname and
18:43 - pay and then we have some methods that
18:45 - return the employees email address which
18:49 - is their first name and last name at
18:51 - email com then we have a method that
18:53 - returns the employees full name which is
18:56 - just their first name and last name
18:58 - combined and we also have a regular
19:00 - method here where we can apply arrays
19:02 - and it will set their pay to the current
19:05 - pay times the Rays amount which by
19:08 - default is 5% up here now the way that
19:11 - this code is set up if an employee's
19:13 - first name or last name changes then
19:16 - that should automatically be reflected
19:17 - in the email and first name okay so
19:20 - let's say that we wanted to write some
19:21 - tests for this so first what we would do
19:23 - is we would create a new file and I'm
19:26 - going to call this test underscore
19:28 - employee dot PI and to save time from
19:32 - you watching the type all of these tests
19:34 - I'm instead going to grab them out of my
19:36 - snippets file here and we'll explain
19:38 - exactly what we're testing so I'm going
19:41 - to copy all of these down to this point
19:44 - and paste these in here okay so if we
19:47 - scroll up to the top here then first
19:49 - we're importing unit tests and also
19:52 - importing our employee class from the
19:54 - employee module and then we're creating
19:57 - our test case that inherits from unit
20:00 - test test case
20:01 - and then we have three different tests
20:04 - here so our first test is called test
20:07 - underscore email and this creates two
20:10 - employees here and when these employees
20:12 - are created we should immediately be
20:14 - able to access the email property so we
20:16 - test both of their emails to check if
20:19 - we're getting the expected values and
20:21 - then we are changing their first names
20:24 - and then checking the emails again here
20:27 - because their email should change with
20:29 - when their name changes so this test
20:32 - email is just testing to make sure that
20:34 - all that functionality is working
20:36 - properly and then when we test the full
20:38 - name it's basically the same thing we're
20:40 - creating two employees and then we're
20:42 - checking their full names to make sure
20:44 - they were created correctly then we're
20:46 - changing their first names and then we
20:49 - are rechecking to make sure that the
20:51 - full names were changed as well and
20:52 - lastly we have a test for testing the
20:55 - apply raise function here and again we
20:58 - are creating two employees and then we
21:00 - are applying a raise and by default
21:03 - that's 5% so we just test to make sure
21:06 - that the pay was raised by 5% so this is
21:09 - basically just a slightly more
21:10 - complicated test than our simple
21:12 - calculator test but there isn't anything
21:15 - here that we haven't seen yet so we just
21:17 - have three different tests and have some
21:19 - assert equals in here to make sure that
21:22 - things have the values that we expect so
21:25 - if we run this and we can see that all
21:27 - of those tests pass now one thing that
21:30 - you might notice is that at the
21:32 - beginning of every one of these tests we
21:35 - are creating two employees now anytime
21:38 - you see the same code over and over that
21:40 - should be something that pops out to you
21:42 - that there might be a better way of
21:43 - doing this because usually programmers
21:46 - try to make their code dry which stands
21:48 - for don't repeat yourself
21:49 - now the reason for that is because if
21:52 - anything ever changes with these to
21:53 - setup employees here then we'll need to
21:56 - make changes to every single test where
21:58 - we created at these employees now this
22:01 - might not be a big deal when we just
22:02 - have three tests like this but if you
22:04 - have hundreds then it could be a pain to
22:07 - maintain so it would be nice if we could
22:09 - create these from scratch in one place
22:12 - and we you
22:13 - them for every test and there is a way
22:15 - to do that so that's what the setup and
22:18 - teardown methods are for so at the top
22:21 - of our test class here let's create two
22:24 - new methods and one of these is going to
22:26 - be called a setup and then self as the
22:30 - first argument and for now we'll just
22:32 - put in a pass statement there and the
22:34 - second method here will be tear down
22:37 - with self as the first argument and
22:40 - another pass statement now these are
22:41 - camel cased with the upper case U and
22:44 - the upper case D so be sure that you
22:47 - type those correctly Python usually
22:49 - doesn't do that but I think this is
22:51 - carried over from some older code so the
22:53 - set up method will run its code before
22:55 - every single test and the teardown
22:58 - method will run its code after every
23:00 - single test so for example we wanted to
23:03 - create these two employees before every
23:06 - single test so we can come down here and
23:09 - grab what we're creating these employees
23:11 - and I'm just going to copy that and
23:13 - paste it here within the setup now in
23:16 - order to access these from within our
23:18 - other tests we're actually going to have
23:19 - to set these as instance attributes by
23:23 - putting self dot employee 1 and self dot
23:27 - employee two now if you don't understand
23:30 - how these instance attributes work then
23:32 - I do have a video in my object-oriented
23:36 - series where I go over exactly how those
23:38 - work but now that we have these within
23:40 - our setup method now we can delete the
23:42 - creation of these employees from the
23:44 - beginning of every test so I'm going to
23:47 - go down and remove these from the
23:50 - beginning of all three of these tests
23:54 - and now since those are instance
23:56 - attributes everywhere that we reference
23:58 - employee 1 and employee 2 we need to add
24:01 - self to the beginning so I'm going to do
24:03 - this with the multi cursor functionality
24:06 - here within sublime text but in your IDE
24:08 - or editor you could just use a simple
24:10 - find and replace so I'm going to grab
24:13 - all of these employee ones here and just
24:18 - add a self dot before that and then I'll
24:22 - grab these employee twos here and
24:26 - had a self dot before that so now one
24:29 - more time let's go ahead and just look
24:31 - at this one more time here so within our
24:33 - setup we're creating these two employees
24:35 - and it's going to create these before
24:37 - every single test so now here within our
24:40 - test we're saying okay
24:42 - self dot assert equals and make sure
24:44 - that this employee that we created up
24:46 - here in the set up is equal to this
24:49 - email and this employee to Z mail is
24:51 - equal to this email and we can reuse
24:53 - those same employees for every single
24:55 - one of these tests and they get created
24:57 - anew for every single one of these tests
25:00 - so let's go ahead and rerun this and
25:02 - make sure that this is still working and
25:03 - it does look like all three of these
25:05 - tests are still passing now we're
25:07 - currently not using our teardown method
25:10 - for anything but I still wanted to show
25:12 - you that it exists just in case you have
25:15 - a use case for it so let's say for
25:17 - example that you had some functions that
25:19 - you wanted to test that added files to a
25:21 - directory or to a database then in your
25:24 - setup method you could create the test
25:26 - directory or the test database to hold
25:28 - those files and in the teardown method
25:30 - you could delete all of those so that
25:32 - you have a clean slate for the next test
25:35 - now just to be more clear where all of
25:37 - this code is being run
25:38 - let me grab some code here from my
25:41 - snippets that has print statements
25:43 - included throughout all of our tests so
25:46 - I'm going to grab from here down and
25:50 - replace this employee test here now this
25:54 - code is exactly what we just had but now
25:57 - we have print statements throughout our
26:00 - code so we have a print statement in the
26:02 - setup and in the teardown and also
26:05 - within every single test case so now if
26:08 - I go ahead and run this and scroll up
26:11 - here to the top then we can see that we
26:13 - have the setup and then the tests and
26:16 - then the teardown and it does this for
26:19 - every single test set up the test and
26:22 - teardown set up test teardown now
26:24 - another thing to notice here is that the
26:26 - tests don't necessarily run in order so
26:28 - you should never assume that the tests
26:30 - run straight down through the script now
26:33 - that's why we need to keep all of our
26:34 - tests isolated from one another
26:36 - now sometimes it's also useful to have
26:38 - some code run at the
26:40 - the beginning of the test file and then
26:42 - have some cleanup code that runs after
26:44 - all the tests have been run
26:47 - so unlike the setup and teardown that
26:49 - runs before and after every single test
26:52 - it would be nice if we had something
26:54 - that ran once before anything and then
26:56 - once after everything now we can do this
26:59 - with two class methods called setup
27:02 - class and teardown class now I have
27:04 - these in my snippets also so let me grab
27:07 - these so we can see what these look like
27:09 - and I'll paste these here at the top of
27:14 - our test and let me fix the indentation
27:17 - there okay so we can see that these are
27:20 - class methods and if you don't know what
27:22 - that means
27:22 - basically it means that we're working
27:24 - with the class rather than the instance
27:27 - of the class like we were with self now
27:30 - I have an object or a video on this as
27:32 - well where I go into this concept more
27:34 - in-depth and I'll leave a link to that
27:36 - in the description section below but
27:37 - once we have these class methods in
27:39 - place with these naming conventions of
27:41 - setup class and teardown class with that
27:44 - camelcase if we run this code and if we
27:47 - scroll up here to the top then we can
27:49 - see that it runs setup class first and
27:52 - then the setups test and tear downs for
27:55 - each test and then at the very end here
27:58 - it runs that teardown class now the
28:01 - print buffering is a little strange with
28:03 - that so it ran after this line here but
28:06 - it ran teardown class at the end of all
28:08 - those tests now this setup class and
28:11 - teardown class can be useful if you just
28:13 - want to do something once and it's too
28:15 - costly to do before each test so for
28:18 - example maybe you want to populate a
28:20 - database to run tests against now as
28:23 - long as you're just reading from the
28:25 - database then it might be appropriate to
28:27 - just set this up once in the setup class
28:30 - method and then you can tear it down in
28:32 - the teardown class method okay now I
28:34 - know that this video is getting a bit
28:36 - long but there's one more thing that I
28:38 - wanted to show you about unit testing
28:40 - that I think is important for most
28:42 - people to know so sometimes our code
28:44 - relies on certain things that we have no
28:46 - control over so for example let's say
28:48 - that you have a function that goes to a
28:50 - website and pulls down some information
28:52 - now if that web
28:54 - site is down then your function is going
28:56 - to fail which will also make your test
28:58 - fail but this isn't what we want because
29:01 - we only want our test to fail if
29:03 - something is wrong with our code so if a
29:06 - website is down then there's nothing
29:08 - that we can actually do about that so
29:10 - we're going to get around this with
29:11 - something called mocking now there's a
29:13 - lot that we could look at in terms of
29:15 - mocking and it could probably be a video
29:17 - all on its own but let's take a look at
29:19 - an example of some basic usage so one
29:22 - more time I'm going to go over here to
29:24 - my snippets and grab a little bit of
29:27 - code here and this is going to be a new
29:30 - method in our employee class so I'm
29:33 - going to paste this at the bottom of our
29:36 - employee class and then fix these
29:39 - indentations so this is a sample method
29:41 - that we're going to pretend that goes to
29:43 - a company's website this line here using
29:47 - request gets and pulls down and
29:50 - employees scheduled for a given month
29:53 - and real quick I also have to import the
29:57 - request library here at the top so
30:00 - import requests and back down here in
30:03 - our method so we do the request get for
30:06 - this website for this employee and for
30:10 - this month
30:11 - to get their schedule and if the
30:12 - response is okay then we want to return
30:15 - the text of that response and if the
30:17 - response is not okay then we want to
30:20 - return the text bad response so the
30:22 - information from that website is
30:24 - something that we would want to mock
30:26 - because we don't want the success of our
30:28 - tests to depend on that website being up
30:31 - so we only care that the get method was
30:34 - called with the correct URL and that our
30:37 - code behaves correctly whether the
30:39 - response is okay and whether the
30:41 - response is not okay so to do this let's
30:44 - import something from mock called
30:48 - hatch so up here at the top of our test
30:51 - employee module I will say from unit
30:55 - test dot mock import patch now there are
30:59 - a couple of different ways that we can
31:00 - use patch so we can use patch either as
31:03 - a decorator or as a context manager and
31:06 - it will allow us to mock
31:07 - object during a test and then that
31:10 - object is automatically restored after
31:12 - the test is run so let's create a new
31:15 - test down here at the bottom for that
31:18 - monthly schedule method and we'll just
31:21 - call this test underscore monthly oops
31:25 - and I wanted to call that monthly
31:27 - schedule not monthly method and then
31:30 - we'll pass in self and so in this
31:32 - example we'll use patch as a context
31:35 - manager so we'll just say so what we
31:45 - said here was with patch and then within
31:48 - patch we pass what we want to mock and
31:51 - we want to mock request get of the
31:55 - employee module and then we're setting
31:58 - that equal to mocked get now you may
32:00 - wonder why we didn't just import request
32:03 - into our test and just mock that instead
32:06 - of the employee request but we want to
32:09 - mock these objects where they're
32:11 - actually used so it's actually used in
32:13 - this employee module so that is the
32:16 - request get that we want to mock okay so
32:19 - now when requests that get is run in the
32:22 - employee module it's actually going to
32:24 - use our MOT get variable here instead of
32:28 - the regular get method and we can just
32:31 - assign the return value instead of
32:33 - actually going out to the website so we
32:36 - can test a successful call by saying
32:39 - mocked get dot return value and if we
32:45 - look back at our employee module we want
32:47 - that return value to have an okay of
32:50 - true so I can say return value dot okay
32:54 - is equal to true and let's also set the
33:00 - text of that return value so we can set
33:04 - the text equal to you know something
33:06 - like success so if we look here in
33:09 - employee module if it returns okay as
33:12 - true then we should get our response
33:15 - text back so now within our context
33:18 - manager here let's just run our monthly
33:21 - schedule
33:21 - method just like we're testing it so we
33:24 - can say schedule is equal to self dot
33:27 - employee one dot monthly schedule and
33:34 - we'll just pass in a value of may to get
33:39 - the may schedule now one more awesome
33:41 - thing about these mock objects is that
33:44 - they actually record when they were
33:46 - called and with what values so we want
33:48 - to make sure that the get method was
33:51 - called with the correct URL so to do
33:53 - this we can say mocked get dot assert
33:58 - called
33:59 - with and this is just a method of that
34:02 - mocked object and now we can test that
34:05 - it got called with the correct URL so
34:07 - since this is employee one here the last
34:12 - name is Schaefer right here so this
34:16 - should have been called with the URL
34:18 - HTTP company.com slash Schaefer and the
34:23 - month that we passed in was May and if
34:26 - you're wondering where I get that here
34:28 - in our employee class this is where it
34:31 - creates the URL here so it's saying HTTP
34:34 - company comm and then the employees last
34:37 - name and then the month that we passed
34:39 - in so that's the URL that it should have
34:41 - called that get method with now after we
34:43 - know that the method was called with the
34:45 - correct URL let's make sure that it
34:47 - returns the correct text which we set to
34:50 - success so let's say self dot assert
34:55 - equal and we want to assert that our
34:58 - schedule which is the response is equal
35:01 - to success okay so now if we run this
35:05 - code then we still have our print
35:07 - statements in here but we can see down
35:08 - here at the bottom that it ran for tests
35:11 - and that they all passed okay now last
35:14 - thing is that we want to test a failed
35:17 - response so to do this we can just do
35:19 - the exact same thing so I'll just copy
35:22 - all of this here and paste it in down
35:26 - below but instead of this okay value
35:29 - being true I'm going to set this to
35:31 - false so that'll test a bad response
35:35 - from the website and if that okay value
35:37 - isn't true then our monthly schedule
35:39 - function should just return the string
35:42 - bad response so we actually don't need
35:44 - this text value here at all so we can
35:47 - just remove that and just to switch the
35:49 - second test up a bit let's change our
35:51 - employee here to employee two and we'll
35:55 - use the month of June
35:57 - just to make these tests a little better
35:59 - so now the get method should be called
36:01 - with the URL of Smith which is our
36:04 - employee - if I scroll up here to the
36:06 - top you can see our employee - is Smith
36:09 - and then that month that we used is June
36:12 - so I'll save that and lastly instead of
36:14 - our result equaling success it should
36:16 - instead return the text bad response
36:19 - with an exclamation point so now if we
36:23 - run this then we can see that all of our
36:25 - tests are still passing so I know that
36:27 - this mocking can be a little confusing
36:29 - when you first see it and like I said it
36:31 - could probably be a video all on its own
36:33 - but you don't use it a whole lot unless
36:36 - you're you know accessing things like
36:38 - URLs and things that are basically out
36:41 - of your control so you don't use it a
36:43 - lot but whenever you do need it it is
36:45 - definitely nice to know okay so I think
36:48 - that's going to about do it for this
36:50 - video but before we finish up here let
36:53 - me mention a few things about best
36:54 - practices so first of all like we saw in
36:57 - this video test should be isolated so if
37:00 - you're still unclear what that means
37:02 - basically this just means that your test
37:04 - should rely on other tests or effect
37:07 - other tests so you should be able to run
37:09 - any tests by itself independent of the
37:13 - other tests and one more thing that I
37:14 - wanted to mention is that you'll notice
37:16 - that in this video I was adding tests to
37:19 - existing code now you may have heard
37:21 - something called test-driven development
37:23 - and basically what test-driven
37:25 - development means is that you write the
37:28 - test before you write the code and I
37:30 - know that that might sound a little
37:31 - strange but sometimes I've found it
37:34 - useful
37:34 - I don't strictly follow test-driven
37:36 - development to where it's something that
37:38 - I always do but basically the concept is
37:41 - that you should think about what you
37:43 - want your code to do and then write a
37:45 - test implementing that behavior then
37:48 - watch the test
37:49 - fail since it doesn't actually have any
37:51 - code to run against and then to write
37:53 - the code in a way that gets the test to
37:55 - pass so if you ever hear someone talking
37:58 - about test-driven development then
38:00 - that's what they're talking about okay
38:01 - so I think that is going to do it for
38:03 - this video I hope that everyone now has
38:05 - a good idea for how they can get started
38:07 - with unit testing now any testing is
38:09 - better than no testing so don't feel
38:11 - like you have to be an expert with mocks
38:13 - and things like that before you start
38:15 - writing any tests even if you just write
38:17 - some basic assertions then it's better
38:19 - than not having anything now there is
38:22 - another test framework out there called
38:24 - pi test that a lot of people like to use
38:26 - more than this built-in unit test
38:28 - library and I'll be doing a video on
38:30 - that in the near future so that you can
38:32 - compare the two and see which one you
38:34 - like better now if anyone has any
38:35 - questions about what we covered in this
38:37 - video then feel free to ask in the
38:38 - comment section below and I'll do my
38:40 - best to answer those and if you enjoyed
38:41 - these tutorials and would like to
38:42 - support them then there are several ways
38:44 - you can do that the easiest way is to
38:46 - simply like the video and give it a
38:47 - thumbs up and also it's a huge help to
38:49 - share these videos with anyone who you
38:50 - think would find them useful and if you
38:52 - have the means you can contribute
38:53 - through patreon and there's a link to
38:54 - that page in the description section
38:56 - below be sure to subscribe for future
38:58 - videos and thank you all for watching
39:10 - you

Cleaned transcript:

hey there how's it going everybody in this video we're going to learn about unit testing in Python so we'll go over how to write tests how to setup and teardown your test and also some best practices so if you're not currently testing your code then it's definitely something that you're going to want to learn and start adding to your projects so a lot of you have probably heard of testing but you might not know exactly what it is testing your code is the most exciting thing to do but there's a reason that most companies and teams require their code to be thoroughly tested and if you're going to get a job working on any large projects then you're going to need to know how to properly write tests and the reason for that is that it's going to save you a lot of time and headache down the road so when you write good tests for your code it gives you more confidence that your updates and refactoring don't have any unintended consequences or break your code in any way so for example if you update a function in your project those changes may have actually broken several sections of your code even if that function itself is still working and good unit tests will make sure that everything is still working as it should and if it's not then it will show you exactly what's broken so in this video we're going to be going over everything that you need to know to get started with the builtin unit testing module so with that said let's go ahead and get started so right now I have a basic script pulled up here that has some simple functions and I want to start off using these really simple functions so that we can just focus on what the tests look like now what a lot of us start doing to test our code is just put in print statements and occasionally run the code so for example down here at the bottom if I wanted to test that my add function was working I could just say print add and add together ten and five and if I run that then we can see that the output that we got looks right but testing your code this way isn't easy to automate and it's also hard to maintain so also if we're testing a lot of different functions then there's no way for us to see at a glance what failed and what succeeded so that's where unit testing comes in so we're going to go ahead and just move remove this print statement and actually start adding some unit tests so to do this first we need to create a test module so I'm going to create a new file here in this current directory and I'm going to call this test underscore calc dot py now that's the naming convention when writing tests is to start with tests underscore and then what you're testing so in this case it was test underscore calc and that's actually going to be required within our test so now we have this test underscore calc module pulled up and we're currently working with an MP file so first let's import the unit test module now this module is in the standard library so there's no need to install anything you can just say import unit test and now we're also going to want to import the module that we want to test so I'm going to import that calc module and we can import calc from here since it's in the same directory now if you're testing code from a different directory and can't get your imports to work then you can watch my video on importing modules and it should help you figure out how to properly get that set up so now we need to create some test cases for the functions that we want to test and in order to create those test cases we first need to create a test class that inherits from unit test dot test case so to do this we're first going to create a class and we will call this test calc now you can call that class whatever you like but try to keep it descriptive as to what you're testing and we're going to want to inherit from unit test dot test case so inheriting from unit test test case is going to give us access to a lot of different testing capabilities within that class so let's write our first test so to do this we'll write a method and the method needs to start with test underscore now that naming convention is actually required so that when we run this it actually knows which methods represent tests so if the method doesn't start with the word test then they won't be run and we'll see what that looks like in just a minute so ours will be test underscore and then what we're testing so first we'll just test the add function of our calcul so we'll call this test underscore add and just like any method in a class this takes self as the first argument and now within our method we can write our test so since we inherited from unit test test case we have access to all these assert methods and I have them all pulled up in the documentation here over in Chrome so we can see that we can assert whether two values are equal with assert equals not equal with assert not equal true assert false and the documentation shows you exactly what all of these check for so for example assert is not none checks whether a variable is not none so the documentation has a good overview of all these asserts and then over here what it actually checks for and I'll also leave a link to this in the description section below so now let's switch back to writing our test so we're going to use assert equals to test our add function so I can run our add function from here by saying something like result is equal to calc add and we'll just add those same values 10 and 5 and we would expect this to equal 15 so to test this we can say self dot assert equals and now we want to assert that that result is equal to 15 okay so now how do we run this test so we could do it from the command line so I have my command line here pulled up and I am navigated to the directory where our module is currently located now you might think that we could just run the test by saying you know Python test underscore Cal PI but if I run that you can see it doesn't actually return anything so instead we need to run unit tests as our main module and pass in test underscore calc and we can do that by saying Python m and then unit test and now the test underscore calc I module and we can see that when we run that it puts a dot here and it says one ran one test and at the bottom it says ok so that means that everything passed now it would be nice if we could just run our tests using this first method here by saying Python test underscore calc and just running the module instead of using this longer command here and setting it up to run that way but also allow us to run our test from directly within our editor so to do this we can just come down here to the bottom and we can say if name double underscore name is equal to in quotes here double underscore main and then within this conditional we can just say unit test dot main and run that now if you don't know what this double underscore name equals double underscore main is doing this actually isn't related to unit testing at all I do have a separate video specifically what that is about but basically it's just saying that if we run this module directly then run the code within the conditional and that code within our conditional is this unit test dot main and that unit test dot main will run all of our tests so now if we go back here this is now saved if we go back here to our terminal and I will clear this out so now let's rerun that using that first method of just Python and our test module and if we run that you can see that now we can run it directly and it runs our unit test and says that it passed and since we can run it this way within the terminal that should mean that it can also run within our editor so if I run this then you can see that within our editor we can now run these tests also okay so that's good so we're running our first test so it's saying that we're only running one test now do you remember earlier when I said that your tests have to start with the word test well let me show you what it does if it doesn't so instead of test underscore add here as our test let's call this add underscore test and save this and run it so when we run this it might not be obvious right off the bat that anything is wrong because we didn't get any errors or any warnings but if we look at how many tests ran it says zero so this test would just skipped so you have to be careful that all of your tests are named properly and start with the word test so let's go ahead and change that back and rerun it okay so now what happens if our test fails so let's change this value here with the assert equals the result is equal to 15 let's change this to a 14 so that our test of adding 10 and 5 fails so let's save that and run it so now if I pull this up a little bit here to where we can see we can see that in stead of a dot an F for fail and it also shows us that the test failed with an assertion err that 15 is not equal to 14 okay so now let me pull this down just a little further here and now let's change this test back and also add in a few more tests so first of all instead of setting this result variable and testing that I'm just going to instead drop our function directly into the assert statement so I'm going to copy this and replace that result variable actually with our add function and then I can just get rid of that result variable there so you usually want to also check some edge cases so let's copy and paste this line here a couple of times and test a couple of edge cases so one edge case might be one negative number and one positive number so let's make sure that negative one plus one is equal to zero and two negative numbers would also be another edge case so let's make sure that negative one plus negative one is equal to negative two so now if we save this and run it then it's saying that it passed but it also says that it ran one test now you may have been expecting this to say that it ran three tests but really these three assert methods here are just within this single test called test underscore add but even though it still says that there's only one test we still made this test better by adding in these additional checks so it's not our goal to write as many tests as possible but just make sure that we write good tests so that's something that a lot of people get tripped up one they just shoot for you know full coverage without making sure their tests are actually good enough to catch mistakes so try to be mindful of that when writing tests and in order to add more tests we just add in more test methods so let's test the rest of our calc functions so I will just copy and paste this test add function here three more times and I'm going to get rid of our output here so we can see a little bit better and now I'll change these to test all of our calc functions so I'll test our subtraction function by changing all of these ones here too correct and now let's change our assert equals so 10 minus 5 will be 5 negative 1 minus 1 will be negative 2 and negative 1 minus negative 1 should be 0 and now moving down the line here let's change this next test to be multiplied so now for our assert equals we want to test that 10 multiplied by 5 is 50 negative 1 multiplied by 1 is negative 1 negative 1 multiplied by negative 1 is 1 and then let's change this last method here to test our divided function so we want to test divide so now in our certain statements here we want to make sure that 10 divided by 5 is equal to 2 negative 1 divided by 1 is negative 1 and negative 1 divided by negative 1 will just be 1 so now if I run this code with all 4 of these tests then you can see that we got 4 dots and it says that we ran 4 tests and all of those tests pass with all of those assert equal statements so you can imagine how useful this is so if you have a module with some complicated functions then once you put in the work to write good tests like this then you can just come back and rerun these tests to make sure that everything still works so if you change something in your program that you think will work but it actually broke some stuff then your test should catch that so for example let's say that I came in here to our calc function and we just made a typo in this multiply function and instead of 1 asterisk there we put 2 now this is actually going to return X to the power of Y so if we come back here to our tests and rerun this then we can see that if we look here at our output that we have 2 dots and then an F and then a dot so that means that 3 of our tests pass and 1 test failed and the one that failed it says that we have an assertion error that the 10 times 5 should actually be equal to 50 and it's not instead we got this value here so that gives us an idea of exactly where the problem is and where we can make that change to get these tests to pass again so let's go ahead and go back here and change this back now sometimes you might make a change that doesn't actually break your test but well actually unexpectedly break your code so for example let's say that we came in here and changed our divide function to be for division instead of regular division and we can do this by changing this to two division signs now if you don't know what floor division is basically it just doesn't give you the remainder now our current test won't catch this because right now all of our and let me save this here so right now all of our divisions currently come out two whole numbers anyway so it doesn't matter for using for division or regular division so if we run our tests and we can see that currently all of these tests are passing so let's say that at some point that for division broke our program and after some debugging we traced it back to that and found the problem now in that case it's always a good practice to go update your tests with a test that would have caught the problem that you just found that way we can know that we don't revisit the same bugs over and over so for example a test that would have caught this I'm going to copy in a sequel statement here now a test that would have caught this is if we would say you know 5 divided by 2 we want that to actually equal 2.5 but with floor division that's actually just going to equal 2 so now if we run this then we can see that we got our error because we're using that floor division and we can see that it is an assertion error that 2 is not equal to 2.5 so that should point us in the right direction and then we can go and see why that would be the case and then we can find out that we're using floor division there instead of regular division and fix that go back to our test and run it and now they're all passing ok so now there's one more thing within our calc file here that we can see we can see here that we are checking if the number that we're dividing by is zero and if so then we're raising a value error with the message that we can't divide by zero so we'll likely want to test that our expectations are working on that as well so but this is done a little differently than the other assertion so let's go back to our test and show how we can test that dividing by zero raises this correct error so there's actually two ways that we can do this so first we could say self dot assert raises and within assert raises first we want to pass in the exception that we expect and that is a value error and now the function that we want to test and that is calc divide now we're not putting parentheses or any arguments there we're putting the arguments as arguments to this assert raises method so let's look at this one more time so our first argument is the exception that we expect the second second argument is the function that we want to run but we aren't passing arguments to the function so leave off the parentheses and then we pass in each argument that we want to pass into the divide function separately so now the reason that we have to do it this way instead of just running the function normally is because our function would actually throw that value error and our test will think that something failed but we'll look at a way that we can do this right after this test so right now if we run this then we can see that this is currently passing and that's because the 10/0 did throw this value error so if I was to change this zero to a two then it's not going to throw that value error so if I run that then it failed and we can see that the assertion error is that value error not raised by divide so which makes sense if we divided by two so if we divide by zero that test passes now I've never preferred this method of testing exceptions because I just like to call the function that I want to test normally instead of passing in all of the arguments separately like we're doing here and we can do this if we test the exceptions using a context manager now that will allow us to handle and check the exception properly and also call our function normally so to do this I'm actually going to get rid of everything here and to do this we say with self dot assert raises value err and that's using the context manager and within this context manager we can just call our function normally like we normally would so calc divided and we'll divide 10 by zero and save that and run it then you can see that by using this context manager that all of those tests still pass so you can choose either method that you prefer but I've always preferred to use the context manager when testing exceptions okay so now let's look at writing slightly more difficult tests so I have a simple employee class here and this is the employee class from the object learning series and if you don't know exactly what this class is doing then it's not really important we're just going to see how this affects some testing strategies so basically what this code is doing is that allows us to create employee instances where it will set the employees firstname and lastname and pay and then we have some methods that return the employees email address which is their first name and last name at email com then we have a method that returns the employees full name which is just their first name and last name combined and we also have a regular method here where we can apply arrays and it will set their pay to the current pay times the Rays amount which by default is 5% up here now the way that this code is set up if an employee's first name or last name changes then that should automatically be reflected in the email and first name okay so let's say that we wanted to write some tests for this so first what we would do is we would create a new file and I'm going to call this test underscore employee dot PI and to save time from you watching the type all of these tests I'm instead going to grab them out of my snippets file here and we'll explain exactly what we're testing so I'm going to copy all of these down to this point and paste these in here okay so if we scroll up to the top here then first we're importing unit tests and also importing our employee class from the employee module and then we're creating our test case that inherits from unit test test case and then we have three different tests here so our first test is called test underscore email and this creates two employees here and when these employees are created we should immediately be able to access the email property so we test both of their emails to check if we're getting the expected values and then we are changing their first names and then checking the emails again here because their email should change with when their name changes so this test email is just testing to make sure that all that functionality is working properly and then when we test the full name it's basically the same thing we're creating two employees and then we're checking their full names to make sure they were created correctly then we're changing their first names and then we are rechecking to make sure that the full names were changed as well and lastly we have a test for testing the apply raise function here and again we are creating two employees and then we are applying a raise and by default that's 5% so we just test to make sure that the pay was raised by 5% so this is basically just a slightly more complicated test than our simple calculator test but there isn't anything here that we haven't seen yet so we just have three different tests and have some assert equals in here to make sure that things have the values that we expect so if we run this and we can see that all of those tests pass now one thing that you might notice is that at the beginning of every one of these tests we are creating two employees now anytime you see the same code over and over that should be something that pops out to you that there might be a better way of doing this because usually programmers try to make their code dry which stands for don't repeat yourself now the reason for that is because if anything ever changes with these to setup employees here then we'll need to make changes to every single test where we created at these employees now this might not be a big deal when we just have three tests like this but if you have hundreds then it could be a pain to maintain so it would be nice if we could create these from scratch in one place and we you them for every test and there is a way to do that so that's what the setup and teardown methods are for so at the top of our test class here let's create two new methods and one of these is going to be called a setup and then self as the first argument and for now we'll just put in a pass statement there and the second method here will be tear down with self as the first argument and another pass statement now these are camel cased with the upper case U and the upper case D so be sure that you type those correctly Python usually doesn't do that but I think this is carried over from some older code so the set up method will run its code before every single test and the teardown method will run its code after every single test so for example we wanted to create these two employees before every single test so we can come down here and grab what we're creating these employees and I'm just going to copy that and paste it here within the setup now in order to access these from within our other tests we're actually going to have to set these as instance attributes by putting self dot employee 1 and self dot employee two now if you don't understand how these instance attributes work then I do have a video in my objectoriented series where I go over exactly how those work but now that we have these within our setup method now we can delete the creation of these employees from the beginning of every test so I'm going to go down and remove these from the beginning of all three of these tests and now since those are instance attributes everywhere that we reference employee 1 and employee 2 we need to add self to the beginning so I'm going to do this with the multi cursor functionality here within sublime text but in your IDE or editor you could just use a simple find and replace so I'm going to grab all of these employee ones here and just add a self dot before that and then I'll grab these employee twos here and had a self dot before that so now one more time let's go ahead and just look at this one more time here so within our setup we're creating these two employees and it's going to create these before every single test so now here within our test we're saying okay self dot assert equals and make sure that this employee that we created up here in the set up is equal to this email and this employee to Z mail is equal to this email and we can reuse those same employees for every single one of these tests and they get created anew for every single one of these tests so let's go ahead and rerun this and make sure that this is still working and it does look like all three of these tests are still passing now we're currently not using our teardown method for anything but I still wanted to show you that it exists just in case you have a use case for it so let's say for example that you had some functions that you wanted to test that added files to a directory or to a database then in your setup method you could create the test directory or the test database to hold those files and in the teardown method you could delete all of those so that you have a clean slate for the next test now just to be more clear where all of this code is being run let me grab some code here from my snippets that has print statements included throughout all of our tests so I'm going to grab from here down and replace this employee test here now this code is exactly what we just had but now we have print statements throughout our code so we have a print statement in the setup and in the teardown and also within every single test case so now if I go ahead and run this and scroll up here to the top then we can see that we have the setup and then the tests and then the teardown and it does this for every single test set up the test and teardown set up test teardown now another thing to notice here is that the tests don't necessarily run in order so you should never assume that the tests run straight down through the script now that's why we need to keep all of our tests isolated from one another now sometimes it's also useful to have some code run at the the beginning of the test file and then have some cleanup code that runs after all the tests have been run so unlike the setup and teardown that runs before and after every single test it would be nice if we had something that ran once before anything and then once after everything now we can do this with two class methods called setup class and teardown class now I have these in my snippets also so let me grab these so we can see what these look like and I'll paste these here at the top of our test and let me fix the indentation there okay so we can see that these are class methods and if you don't know what that means basically it means that we're working with the class rather than the instance of the class like we were with self now I have an object or a video on this as well where I go into this concept more indepth and I'll leave a link to that in the description section below but once we have these class methods in place with these naming conventions of setup class and teardown class with that camelcase if we run this code and if we scroll up here to the top then we can see that it runs setup class first and then the setups test and tear downs for each test and then at the very end here it runs that teardown class now the print buffering is a little strange with that so it ran after this line here but it ran teardown class at the end of all those tests now this setup class and teardown class can be useful if you just want to do something once and it's too costly to do before each test so for example maybe you want to populate a database to run tests against now as long as you're just reading from the database then it might be appropriate to just set this up once in the setup class method and then you can tear it down in the teardown class method okay now I know that this video is getting a bit long but there's one more thing that I wanted to show you about unit testing that I think is important for most people to know so sometimes our code relies on certain things that we have no control over so for example let's say that you have a function that goes to a website and pulls down some information now if that web site is down then your function is going to fail which will also make your test fail but this isn't what we want because we only want our test to fail if something is wrong with our code so if a website is down then there's nothing that we can actually do about that so we're going to get around this with something called mocking now there's a lot that we could look at in terms of mocking and it could probably be a video all on its own but let's take a look at an example of some basic usage so one more time I'm going to go over here to my snippets and grab a little bit of code here and this is going to be a new method in our employee class so I'm going to paste this at the bottom of our employee class and then fix these indentations so this is a sample method that we're going to pretend that goes to a company's website this line here using request gets and pulls down and employees scheduled for a given month and real quick I also have to import the request library here at the top so import requests and back down here in our method so we do the request get for this website for this employee and for this month to get their schedule and if the response is okay then we want to return the text of that response and if the response is not okay then we want to return the text bad response so the information from that website is something that we would want to mock because we don't want the success of our tests to depend on that website being up so we only care that the get method was called with the correct URL and that our code behaves correctly whether the response is okay and whether the response is not okay so to do this let's import something from mock called hatch so up here at the top of our test employee module I will say from unit test dot mock import patch now there are a couple of different ways that we can use patch so we can use patch either as a decorator or as a context manager and it will allow us to mock object during a test and then that object is automatically restored after the test is run so let's create a new test down here at the bottom for that monthly schedule method and we'll just call this test underscore monthly oops and I wanted to call that monthly schedule not monthly method and then we'll pass in self and so in this example we'll use patch as a context manager so we'll just say so what we said here was with patch and then within patch we pass what we want to mock and we want to mock request get of the employee module and then we're setting that equal to mocked get now you may wonder why we didn't just import request into our test and just mock that instead of the employee request but we want to mock these objects where they're actually used so it's actually used in this employee module so that is the request get that we want to mock okay so now when requests that get is run in the employee module it's actually going to use our MOT get variable here instead of the regular get method and we can just assign the return value instead of actually going out to the website so we can test a successful call by saying mocked get dot return value and if we look back at our employee module we want that return value to have an okay of true so I can say return value dot okay is equal to true and let's also set the text of that return value so we can set the text equal to you know something like success so if we look here in employee module if it returns okay as true then we should get our response text back so now within our context manager here let's just run our monthly schedule method just like we're testing it so we can say schedule is equal to self dot employee one dot monthly schedule and we'll just pass in a value of may to get the may schedule now one more awesome thing about these mock objects is that they actually record when they were called and with what values so we want to make sure that the get method was called with the correct URL so to do this we can say mocked get dot assert called with and this is just a method of that mocked object and now we can test that it got called with the correct URL so since this is employee one here the last name is Schaefer right here so this should have been called with the URL HTTP company.com slash Schaefer and the month that we passed in was May and if you're wondering where I get that here in our employee class this is where it creates the URL here so it's saying HTTP company comm and then the employees last name and then the month that we passed in so that's the URL that it should have called that get method with now after we know that the method was called with the correct URL let's make sure that it returns the correct text which we set to success so let's say self dot assert equal and we want to assert that our schedule which is the response is equal to success okay so now if we run this code then we still have our print statements in here but we can see down here at the bottom that it ran for tests and that they all passed okay now last thing is that we want to test a failed response so to do this we can just do the exact same thing so I'll just copy all of this here and paste it in down below but instead of this okay value being true I'm going to set this to false so that'll test a bad response from the website and if that okay value isn't true then our monthly schedule function should just return the string bad response so we actually don't need this text value here at all so we can just remove that and just to switch the second test up a bit let's change our employee here to employee two and we'll use the month of June just to make these tests a little better so now the get method should be called with the URL of Smith which is our employee if I scroll up here to the top you can see our employee is Smith and then that month that we used is June so I'll save that and lastly instead of our result equaling success it should instead return the text bad response with an exclamation point so now if we run this then we can see that all of our tests are still passing so I know that this mocking can be a little confusing when you first see it and like I said it could probably be a video all on its own but you don't use it a whole lot unless you're you know accessing things like URLs and things that are basically out of your control so you don't use it a lot but whenever you do need it it is definitely nice to know okay so I think that's going to about do it for this video but before we finish up here let me mention a few things about best practices so first of all like we saw in this video test should be isolated so if you're still unclear what that means basically this just means that your test should rely on other tests or effect other tests so you should be able to run any tests by itself independent of the other tests and one more thing that I wanted to mention is that you'll notice that in this video I was adding tests to existing code now you may have heard something called testdriven development and basically what testdriven development means is that you write the test before you write the code and I know that that might sound a little strange but sometimes I've found it useful I don't strictly follow testdriven development to where it's something that I always do but basically the concept is that you should think about what you want your code to do and then write a test implementing that behavior then watch the test fail since it doesn't actually have any code to run against and then to write the code in a way that gets the test to pass so if you ever hear someone talking about testdriven development then that's what they're talking about okay so I think that is going to do it for this video I hope that everyone now has a good idea for how they can get started with unit testing now any testing is better than no testing so don't feel like you have to be an expert with mocks and things like that before you start writing any tests even if you just write some basic assertions then it's better than not having anything now there is another test framework out there called pi test that a lot of people like to use more than this builtin unit test library and I'll be doing a video on that in the near future so that you can compare the two and see which one you like better now if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoyed these tutorials and would like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
