With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're going to be taking a
00:02 - look at the inter tools module so
00:04 - itertools is a collection of tools that
00:06 - allows us to work with iterators in a
00:08 - fast and memory efficient way now if you
00:11 - don't know what an iterator is it's
00:12 - basically sequential data that we can
00:14 - iterate or loop over now I would
00:16 - recommend being familiar with the
00:18 - concept of iterators and generators
00:19 - before watching this video I do have a
00:22 - video that I released a little over a
00:24 - week ago that I'll leave in the
00:25 - description section below if you want to
00:27 - watch that video first it's probably not
00:29 - absolutely necessary but understanding
00:31 - how an iterator is exhausted or how some
00:34 - only hold one object in memory at a time
00:36 - is going to help with understanding how
00:38 - itertools is working as well so the
00:40 - inter tools module contains a number of
00:42 - commonly used iterators as well as
00:44 - functions for combining several
00:46 - iterators now The Sitter tools module is
00:48 - available in the Python standard library
00:49 - so there's nothing that you need to
00:51 - install in order to use this now if
00:53 - you're looking for a specific itertools
00:55 - function then I'm going to try to put a
00:57 - timestamp in the description section
00:59 - below
00:59 - to each of the functions that we go over
01:01 - in this video so you can look there for
01:03 - a time step to whichever function that
01:05 - you're looking for so first off let's go
01:08 - ahead and import this so that we can see
01:10 - what we can do with this so first I'll
01:12 - just say import it err tools ok so right
01:16 - off the bat let me show you one of the
01:17 - most simple itertools functions so the
01:19 - first function that we're going to look
01:21 - at is called count and just like it
01:23 - sounds it simply returns an iterator
01:25 - that counts so we can say that use that
01:28 - just by saying counter is equal to
01:31 - itertools dot count and by default if we
01:35 - don't pass in any arguments then count
01:37 - will just start at 0 and count out by
01:39 - one each iteration and this is just
01:42 - going to go on forever so right now if
01:44 - we were to loop over this it would just
01:46 - start counting up from zero by one and
01:47 - never stop so if you're not careful then
01:50 - you can get stuck in an infinite loop
01:51 - now I'm going to show you what this
01:52 - looks like but I wouldn't recommend you
01:54 - do this on your machine because
01:56 - sometimes it's hard to stop from
01:57 - executing and can freeze up your
01:59 - computer or program but I'm going to try
02:01 - to run this and just stop it quickly so
02:03 - I'm just going to say for num in counter
02:06 - oops in counter and we will just print
02:10 - out num now again this is going to be an
02:12 - infinite loop
02:13 - but I'm just
02:13 - run this and stop it quickly okay so I
02:17 - ran that and then quickly stopped it by
02:19 - hitting ctrl C but even in that short
02:21 - time it already counted up by a lot we
02:23 - already got up over two hundred thousand
02:25 - here now if you are familiar with
02:27 - iterators then we can actually get the
02:29 - next value without using a for loop we
02:32 - can simply just use the next function
02:34 - and pass in our iterator so instead of
02:37 - looping through it like this instead
02:38 - let's do something like I will remove
02:41 - this for loop and just say print next
02:44 - and then next counter so let's save that
02:48 - and run it and when we run that we can
02:50 - see that we get a zero now if I copy and
02:52 - paste this a couple of times and run
02:54 - this again so I'll copy and paste this a
02:56 - few times here and run it then we can
02:58 - see that each time we run next we get 0
03:01 - 1 2 3 and it just keeps on going and
03:04 - this is one big key take away from these
03:06 - iterators some of them can go on forever
03:08 - but even if they do we can still just
03:10 - get one item at a time ok so why is this
03:14 - useful well there's a lot of different
03:15 - scenarios that this might be useful but
03:17 - let's just look at one example so it's
03:19 - very common to have a list of values and
03:22 - want to have some kind of index assigned
03:24 - to them so to show an example let me
03:26 - create a quick list here so I'm going to
03:28 - comment out these print statements and
03:31 - I'm just going to make a quick list of
03:33 - data here and say that I want 100 200
03:37 - 300 and 400 so here we just have a list
03:40 - of some random numbers so let's say that
03:42 - we wanted this data to be paired up with
03:44 - an index value for some reason well for
03:46 - example let's say that our data took
03:48 - place over a daily basis and we wanted
03:51 - to graph this so we want to pair it up
03:53 - by saying ok 100 is associated with day
03:56 - 0 200 is associated with day 1 300 is
03:59 - day 2 and so on now if we don't know how
04:02 - much data there's going to be then we
04:04 - can simply use the count function to
04:07 - provide values for any amount of data so
04:09 - for example we could simply say
04:11 - something like this so I will say daily
04:15 - underscore data is equal to and I'm
04:18 - going to use the zip function here and
04:20 - then I will pass in itertools dot count
04:23 - and as the first argument and then our
04:26 - data list as the
04:27 - the second argument now if you don't
04:29 - know what the built-in zip function does
04:30 - basically it combines two intervals and
04:33 - pairs the values together so it will get
04:35 - the first value of the count function
04:37 - which by default is zero and it will
04:40 - pair it with the first value of data
04:42 - which in this example is 100 and then it
04:44 - will move on and pair one with two
04:47 - hundred and two with three hundred and
04:48 - so on now the zip function will return
04:51 - an iterator itself that needs to be
04:53 - looped over in order to get all the
04:55 - values now if we want we can simply
04:57 - convert the results to a list and get
04:59 - them all at once so I could just convert
05:02 - this entire thing to a list by wrapping
05:05 - all of that in a list function so now
05:08 - that we've done that let me print out
05:09 - our daily data variable here so I will
05:12 - print that out then we can see that it
05:14 - paired those values up in our result and
05:17 - since we use itertools count it just
05:19 - kept grabbing the next value until our
05:21 - data list had gone through all of its
05:23 - values so that count function will work
05:25 - with any size of data okay so we can
05:28 - also pass some arguments into our count
05:30 - function in order to start at a
05:31 - different place and we can also step by
05:34 - a different amount as well so let me
05:37 - uncomment out these print statements
05:40 - here and for now I'm just going to
05:41 - comment out our data example here and
05:45 - let me actually grab these print
05:48 - statements and put these up here okay so
05:51 - now let's look at passing some arguments
05:52 - into our count function so if I wanted
05:55 - to start from something other than zero
05:57 - then I could simply pass in a value of
05:59 - start equals five for example if I save
06:02 - that and run it we can see that now our
06:04 - counter starts at five and we get five
06:05 - six seven eight now it's still counting
06:08 - up by one and we can also pass a step
06:10 - argument to change how the counter is
06:12 - incremented so if I started at five then
06:15 - I could also pass in an argument of step
06:17 - equals five if I save that and run it
06:20 - then we can see it now starts at five
06:22 - and now it's counting up by five each
06:24 - time so 5 10 15 20 now the counter is
06:27 - pretty versatile it can also count
06:29 - backwards and can also count by decimal
06:31 - numbers as well so if I was to instead
06:34 - say that our step is negative two point
06:37 - five for example and then run that then
06:40 - we can see that it starts at
06:41 - five and subtracts 2.5 from each step
06:44 - and then even goes into the negatives
06:46 - okay so that's a look at the count
06:48 - function now since we've already seen an
06:50 - example using the built-in zip function
06:53 - down here let me show you a knitter
06:54 - tools function that is just like this
06:56 - except it doesn't end until the longest
06:59 - iterable is exhausted and again the
07:01 - built in zip function ends on the
07:03 - shortest iterable
07:04 - so this itertools function is called zip
07:07 - longus so a pretty obvious name for what
07:09 - it does now remember this pairs
07:12 - iterables together so if it doesn't end
07:14 - until the longest interval is exhausted
07:16 - then it means it will need to pair some
07:20 - other values with some placeholders so
07:21 - by default that's going to be a none
07:24 - value so let me comment out these lines
07:26 - up here and uncomment out this example
07:29 - where we used this zip function here now
07:32 - this worked before because zip ends
07:35 - after our shortest interval is exhausted
07:37 - and we're not going to be able to use
07:39 - the itertools count function with the
07:41 - zip longest the way that we have it
07:43 - right here because we're converting it
07:46 - into a list and since count goes on
07:48 - forever then that would just run out of
07:50 - memory trying to convert that to a list
07:52 - now you could still use count and just
07:55 - not cast it to a list but then you just
07:57 - need to get the next values one at a
07:59 - time but let's leave this list here and
08:02 - simply replace count with a range of
08:04 - values instead so instead I'm going to a
08:07 - switch count out here and instead just
08:10 - say something like range of 10 values so
08:13 - if I run this right now while we're
08:14 - still just using this regular zip
08:16 - built-in then we can see that it runs
08:19 - just like it did before
08:20 - it just pairs those values up until our
08:22 - shortest interval is exhausted and the
08:25 - shortest interval here is data so as
08:27 - soon as all of our data is paired
08:29 - together then it just cuts off those
08:31 - values and it doesn't pair the rest of
08:33 - our range here but if instead we use zip
08:36 - longest from itertools
08:37 - so I'll say it err Tools dot zip
08:40 - underscore longest if I save that and
08:43 - run it then we can see that it pairs
08:45 - those intervals together but when our
08:47 - data variable runs out it continues and
08:50 - just pairs the rest of our range with
08:52 - none values so that can be useful
08:54 - depending on
08:55 - the type of problem that you're trying
08:56 - to solve so we can see here that it
08:59 - paired up the values and then this is
09:01 - where our data ran out but then it
09:03 - continued with the range and just put
09:05 - none values here for four or five six
09:07 - seven eight and nine okay so that was a
09:09 - quick detour looking at the zip longest
09:11 - function and now let's get back to
09:12 - looking at a couple more iterative tools
09:14 - functions that can go on indefinitely
09:16 - so let's look at the cycle function so
09:19 - cycle also returns an iterator that goes
09:22 - on forever basically it takes an
09:24 - iterable as an argument and will cycle
09:27 - through those values over and over so
09:29 - let me get rid of this example that we
09:31 - have here and uncomment out this so that
09:35 - we can see an example of this cycle
09:37 - function okay so instead of count I'm
09:39 - going to say itertools dot cycle and
09:42 - this takes in an iterator and basically
09:45 - like I said it's just going to cycle
09:46 - over these over and over so I will just
09:49 - pass in a list of one two three and four
09:52 - our print statements here I only have
09:54 - four here right now
09:55 - let me make this six total here so that
09:57 - we can see exactly what this is doing so
09:59 - I will save this and run it and let me
10:02 - zoom up a little bit okay so we can see
10:03 - that our output is just one two three
10:07 - one two three so it loops through our
10:10 - list that we just passed into cycle but
10:13 - once it hits the end of the list
10:15 - it just cycles back through so that's a
10:17 - pretty simple concept but there's a lot
10:19 - that you could do with it so for example
10:21 - if you wanted to simulate a switch of
10:24 - something getting turned on or off or
10:25 - something like that then you could
10:27 - simply create a cycle with two values so
10:30 - that could either be a 1 and a negative
10:32 - 1 or a 1 and a 0 or you could even pass
10:35 - in a list of strings of on and off so
10:38 - for example if I came up here instead of
10:41 - a list I'll actually use a tuple just to
10:43 - show a different data structure here and
10:46 - I'll say on and off as our two values in
10:49 - that tuple so if I save that and run it
10:51 - then if I screw up to the top here we
10:53 - can see that it just cycles between the
10:55 - values of on off on off on off each time
10:59 - the next value is fetched so that's a
11:01 - look at the cycle function it's super
11:03 - simple but there's a lot of different
11:05 - ways that we could use it okay so now
11:07 - let's look at the last
11:08 - infinite iterator and itertools and
11:10 - that's going to be the repeat function
11:12 - and this one is also super simple it
11:15 - just takes some input and repeats it
11:17 - indefinitely so for example if I was to
11:20 - come up here and say itertools dot
11:22 - repeat and then just pass in a value of
11:25 - two for example if I save that and run
11:28 - it then we can see that it simply
11:30 - repeats the same value over and over
11:32 - each time we fetch the next value and we
11:35 - can set a limit on this too so if I was
11:37 - to instead come up here and say repeat
11:39 - and then just say times equal to three
11:43 - and save that and run it then if I
11:45 - scroll up here a little bit then we can
11:46 - see that it repeats the value for the
11:49 - first three times and then it throws a
11:51 - stop iteration exception now if we had
11:53 - run that through a for loop then it
11:55 - would have just looped through that
11:56 - three times and we wouldn't have seen
11:57 - that exception since the for loop
12:00 - handles those stop iteration exceptions
12:02 - for us now on the surface this might not
12:04 - seem very useful but it's usually used
12:06 - for passing in a stream of constant
12:08 - values two functions like map or zip
12:10 - that also operate on intervals so for
12:13 - example if you wanted to get the square
12:16 - of the values one through ten then you
12:18 - could do something like this for example
12:21 - so I'm just going to comment out these
12:23 - print statements here so let me type out
12:26 - an example of this and I actually got
12:27 - this from the Python documentation so
12:29 - I'm going to say squares is equal to map
12:32 - and with map will use the pal function
12:36 - which takes the power of values and we
12:38 - will pass in arguments of a range of ten
12:42 - and also we'll do a knitter tools dot
12:45 - repeat and we'll just pass in a value of
12:48 - two there as well now if you don't know
12:50 - what map does basically it takes a
12:52 - function in this case we're using pal
12:54 - which raises a number to a certain power
12:56 - and then it takes iterables and uses the
12:59 - values from those to pass as arguments
13:02 - to that function and it will loop
13:03 - through and pass values from those
13:05 - intervals into a function until the
13:08 - shortest list of arguments has run
13:10 - through all of its values so this will
13:12 - start off by passing in the next value
13:14 - from our range and that would start at
13:16 - zero and it will also pass in the first
13:19 - value of our repeat iterable which is
13:22 - always going to
13:22 - - so the first value it will calculate
13:25 - is going to be zero to the second power
13:27 - and then the next time through it'll do
13:29 - one to the second power and then two to
13:31 - the second power and so on so if I print
13:34 - this out this is actually going to be
13:36 - needed to be converted to a list as well
13:40 - otherwise it's just going to be an
13:42 - iterator waiting to be iterated on but
13:44 - I'll cast it to a list so I'll just put
13:46 - out print out a list of those squares
13:48 - and run that now we can see that we got
13:50 - a list of the squares of all the values
13:52 - from zero to nine so that's a little
13:55 - more practical of an example of where
13:57 - you would use that repeat function like
14:00 - I said it's usually used for passing in
14:02 - a stream of constant values to a
14:04 - function like map or zip now since we're
14:06 - already using the map function this
14:08 - would be a good time to look at another
14:10 - itertools function that modifies the map
14:12 - function a little bit and this is called
14:14 - star map basically star map is very
14:17 - similar to map but instead of taking
14:20 - arguments from iterables like we're
14:21 - doing here it instead takes arguments
14:24 - that are already paired together as
14:25 - tuples so for example let's use star map
14:29 - to get these first few powers so instead
14:32 - of passing in range and this repeat here
14:35 - I'm just going to pass in a list and
14:37 - these are going to be a list of tuples
14:39 - that have the arguments already paired
14:42 - together and I'm just going to do the
14:43 - first few here so I'm going to go 0 to
14:46 - the second power and then let me go
14:48 - ahead and copy this to make this a
14:51 - little quicker so I'll do 0 to the
14:53 - second power then 1 to the second power
14:55 - and then 2 to the second power and
14:57 - instead of map we instead want to use
15:00 - itertools dot star map so if I save that
15:04 - and run it then you can see that it ran
15:08 - our arguments here as tuples into our
15:10 - power function and we got 0 1 & 4 for
15:15 - the results of those arguments so pretty
15:17 - similar to map but instead it takes its
15:19 - arguments as a list of tuples instead so
15:21 - depending on the problem that you're
15:22 - trying to solve that might be more
15:24 - useful for you ok so so far we've gone
15:26 - over itertools functions that produce
15:28 - iterators that can go on forever
15:30 - but now let's look at some useful
15:31 - functions that will eventually terminate
15:34 - so first let's go over two of the moe
15:36 - popular in Turtles functions and those
15:38 - are combinations and permutations so
15:41 - these allow us to take an iterable and
15:43 - return all of the combinations or
15:45 - permutations from that interval and if
15:47 - you don't know the difference between
15:48 - combinations and permutations basically
15:51 - combinations are all the different ways
15:53 - that you can group a certain number of
15:55 - items or the order does not matter and
15:58 - permutations are all the different ways
16:00 - that you can group a certain number of
16:02 - items where the order does matter so
16:05 - let's look at some examples and this
16:06 - will be more clear so I'm going to use a
16:08 - couple of lists hear from our snippets
16:11 - file and I'll post this snippets file in
16:13 - the code to this snippets file in the
16:15 - description section below if you want to
16:16 - use this as well but I'm just going to
16:18 - grab three code snippets here and I'm
16:21 - going to paste these up here at the top
16:23 - and to clean up what we have so far let
16:25 - me go ahead and just remove what we
16:28 - already have here and save that okay so
16:31 - for this example I'm going to use our
16:33 - letters list here that consists of the
16:35 - values of a b c d so let's say that i
16:38 - want to get all of the possible
16:40 - combinations of two values from those
16:42 - letters so to do that I can simply say
16:45 - I'll say result is equal to itertools
16:48 - dot combinations and I want to get the
16:51 - combinations of the letters and I want
16:54 - to get all the different combinations of
16:55 - two values and now let me make this
16:59 - output a little smaller here and now let
17:02 - me do a for loop where I say for item in
17:04 - result print the item so let me save
17:08 - that and run it and make this a little
17:11 - larger again okay so we can see that
17:13 - when we loop through those it gives us
17:15 - all the different combinations of two
17:17 - values that we can make from our
17:19 - original list of ABCD now remember with
17:22 - combinations the order does not matter
17:24 - so we can see that we have a combination
17:27 - here of a B but we don't see a
17:30 - combination of B a and that's because
17:33 - they are seen as the same combination
17:35 - and sometimes this is exactly what we
17:37 - want so for example if we're simulating
17:39 - a poker hand or something like that
17:41 - then it wouldn't matter what order your
17:44 - hand is in so an ace King would be the
17:46 - same thing as a king ace so you would
17:49 - need to produce bow
17:50 - of those combinations now if order does
17:52 - matter then you'll want to use
17:54 - permutations instead that will give you
17:57 - all of the different ways that you can a
17:58 - group certain number of items where the
18:01 - order does matter so let's go ahead and
18:03 - look at that so I'm going to just
18:05 - replace combinations here with our
18:07 - permutations function and rerun this so
18:10 - instead of combinations I will say
18:12 - permutations save that and run it and
18:14 - now if I scroll up here we can see that
18:16 - we got more values there and that's
18:19 - because we're going to get all the
18:20 - different ways that we can arrange two
18:21 - values from our original iterable where
18:24 - the order does matter so we can see that
18:27 - we have a value for a B here at the top
18:30 - but if we scroll down a little bit then
18:32 - we also have a permutation for BA as
18:34 - well now you can think of this as trying
18:36 - to simulate all of the different
18:37 - possible results of a race or something
18:40 - like that so if a came first and then B
18:43 - then that would be different than B
18:45 - coming first and then a so permutations
18:48 - is what you would want to use in a
18:49 - situation like that now one thing that
18:51 - you'll notice is that combinations and
18:53 - permutations don't repeat values so what
18:56 - I mean by that so for example with our
18:58 - permutations here we have all the
19:00 - different ways that we can arrange two
19:02 - items from our original list but it
19:04 - doesn't repeat any of those values so
19:06 - for example it doesn't give us a a as
19:09 - one of the permutations and that's
19:11 - because there's only one a in our
19:13 - original list but what if we wanted to
19:15 - allow repeats so for example let's use
19:18 - our numbers list so you can see how
19:20 - having numbers list here of 0 1 2 and 3
19:22 - so let's pretend that we wanted to see
19:25 - all the different ways that we could
19:26 - create a four-digit code using these
19:29 - values and that would include repeats so
19:31 - we could have a code that's 0 0 0 or 0 1
19:35 - 0 1 or anything like that
19:37 - well for that we couldn't use
19:39 - combinations or permutations because
19:42 - that will only give us the ways that we
19:44 - can range the values in that list if we
19:46 - wanted the values to be able to repeat
19:48 - then we could use the product function
19:50 - which will give you the Cartesian
19:53 - product of iterables that you pass in
19:55 - now if we only pass in one iterable then
19:57 - we can tell it how many times we want it
19:59 - to be able to repeat those values so
20:01 - with that said
20:03 - let's look at an example here so I'm
20:05 - gonna say itertools dot product and
20:07 - we're going to use our numbers here and
20:10 - let's say that we want to set repeat
20:13 - equal to four so what this is going to
20:16 - do is it's going to give us all the
20:17 - different ways that we could arrange
20:18 - these numbers where repeats are allowed
20:21 - so if I save this and run it and scroll
20:24 - up here to the top then we can see that
20:26 - this gives us what we were looking for
20:27 - in terms of going through all the
20:29 - different ways that we could arrange
20:30 - these numbers in groups of four now this
20:33 - is also a way that you could build some
20:34 - kind of password cracker so for example
20:37 - you could create a loop where you go
20:39 - through all the different ways to
20:40 - arrange alphanumeric characters in you
20:43 - know a pattern of six or something like
20:45 - that now I should also mention that
20:47 - there's a way to get combinations with
20:49 - repeated values as well and we do that
20:51 - with a function called combinations with
20:53 - replacements so if I just go up here and
20:56 - replace product with combinations whoops
21:00 - be sure to spell this right combinations
21:02 - underscore with underscore replacement
21:05 - and instead of repeat here we can just
21:07 - pass that and as a positional argument
21:10 - instead so if I save that and run it and
21:13 - go up here to the top then we can see
21:14 - that now we get all the different
21:16 - combinations of those four numbers but
21:18 - it allows repeated values as well so
21:21 - that's a look at some of the ways to get
21:23 - different groups of arrangements from an
21:25 - iterable and always find it fascinating
21:26 - to use combinations and permutations and
21:29 - products and they're definitely useful
21:30 - depending on what you're trying to solve
21:33 - okay so now let's look at some other
21:35 - useful itertools functions that allow us
21:37 - to solve certain types of problems so
21:40 - now let's look at the chain function so
21:43 - chain allows us to chain together
21:45 - intervals so that it will go through all
21:47 - the items in the first interval and
21:49 - after that has been exhausted then it'll
21:51 - go through all the items in the second
21:52 - interval and so on so I have three
21:54 - different lists here that I pulled from
21:56 - my snippets are there and let's pretend
21:58 - that we want to loop over all of these
22:00 - values and all of these lists so how
22:03 - would we do this so one way would be
22:05 - that we could create a new list that
22:07 - combines all three of these lists and
22:09 - then loops over those so we could say
22:12 - something like let me overwrite this
22:14 - part here so I could just say
22:17 - combined is equal to you know letters
22:20 - plus numbers plus names now the problem
22:24 - with an approach like this is that it
22:26 - creates a new list with all of those
22:28 - values in memory so the sample list that
22:31 - we have here are really short so it
22:33 - wouldn't be a big deal using it in this
22:35 - situation but what if these lists
22:37 - contain millions of items it would be
22:39 - majorly inefficient for us to make
22:41 - copies of all of those and put them into
22:43 - another variable or what if those
22:46 - weren't even list a that they were
22:48 - generators or something like that
22:49 - instead then how would we loop over all
22:52 - of those at once well to do this we can
22:54 - use chain so instead of doing it the way
22:57 - we have here let's instead say combined
23:00 - is equal to itertools dot chain and I
23:04 - will just pass in all of those to our
23:06 - chain so letters numbers and names so
23:10 - now if we loop over these I'll say for
23:13 - item in combined then we will print out
23:18 - the item if I save that and run it then
23:21 - if I scroll up here then we can see that
23:23 - first loop through our letters and after
23:25 - those were exhausted it looped there our
23:26 - numbers and then our names at the end so
23:29 - we can see that it looped over all of
23:30 - the items in all three of those
23:32 - iterables so that can be extremely
23:34 - efficient depending on the data that
23:36 - you're iterating over okay so now let's
23:38 - look at a function that will allow us to
23:40 - get a slice of an iterator so you can
23:43 - think of this like list slicing where
23:45 - you can specify that you only want the
23:47 - first five item items of a list or
23:49 - something like that but this function
23:50 - will allow us to perform slicing on an
23:53 - iterator and this function is called I
23:55 - slice so to use this there are three
23:57 - different arguments that we can pass in
23:59 - we can pass in a stopping point to go
24:01 - from the beginning of an iterator until
24:03 - it hits a stopping point so for example
24:06 - let's say that I wanted to slice a range
24:08 - from 0 to 9 and stop on the fifth index
24:12 - so to do that I could just come up here
24:14 - and say itertools dot I slice and we
24:18 - will slice a range of 10 values and I
24:22 - will pass in a stopping value of 5 now
24:26 - instead of combined here I'm just going
24:28 - to change that to result so that that
24:29 - variable makes more
24:30 - I also have to change it in the for loop
24:32 - here as well so if I save that and run
24:35 - it then we can see that it gives us the
24:37 - first five items of that iterable now if
24:39 - you're thinking to yourself you know why
24:41 - is this useful because I can already do
24:43 - that with list slicing well don't worry
24:45 - we'll look at some useful examples here
24:47 - in just a minute okay so we can also
24:49 - pass in a starting point argument into I
24:52 - slice as well now if there's only one
24:54 - argument like we have here then it will
24:56 - assume that it's the stopping point but
24:58 - if we put in two arguments then it will
25:00 - assume that it is the starting point and
25:02 - stopping point so if we wanted to skip
25:05 - the first value then I could come in
25:07 - here and just say one as our first
25:10 - argument and then five and it'll think
25:12 - that one is the starting point and five
25:14 - is the stopping point so if I save that
25:16 - and run it then we can see that now it
25:18 - started at index 1 and stopped at index
25:21 - 5 and lastly we can also do steps so if
25:24 - we want to do the same slice that we
25:26 - have now but only get every other value
25:28 - then we can simply say that we want to
25:30 - step by 2 so up here I can also pass in
25:34 - another argument there as a 2 and
25:37 - that'll be the step so if I save that
25:39 - and run it then we can see that we get
25:41 - the values from the 1st to 5th index but
25:44 - it steps by 2 okay so why is this useful
25:48 - so this is useful because like with our
25:51 - other examples so far we may have an
25:53 - iterator that is just too large to put
25:55 - into memory so we don't want to cast it
25:58 - to a list just to get a certain slice of
26:00 - that iterator so for example let's
26:03 - imagine that we have some log files on
26:04 - your machine that are thousands and
26:06 - thousands of lines but you only want to
26:08 - grab the top few lines that are the
26:11 - header of the log file so to do this
26:13 - efficiently we can use I slice now I
26:16 - have a sample file here where I'm going
26:18 - to do this so I have a sample file
26:20 - called test log and this is it here and
26:23 - we can see that we have some fake data
26:24 - in here but the top three lines have the
26:27 - date the author and the description so I
26:31 - just want to grab those and ignore
26:32 - everything else so let's do this using I
26:35 - slice so I'm going to come back to the
26:38 - demo here I'll make this a little
26:40 - smaller here and for now I'm just going
26:42 - to comment out our previous example
26:44 - and scroll down here a little bit and
26:46 - now let's use this I slice on this log
26:51 - file so I'm gonna say with open to open
26:54 - this file and that file was called test
26:57 - dot log now this is in the same
26:59 - directory as my python file so I don't
27:01 - have to pass in a full path if it's in
27:03 - the same directory then it'll work just
27:05 - like this and I want to read that file
27:08 - and now that we have that file open
27:11 - files are actually iterators themselves
27:14 - and whenever you call next on them it
27:16 - gets the next line in the file so we can
27:19 - use them just like any other iterator so
27:21 - in order to just grab the header I'm
27:23 - going to say that the header is equal to
27:25 - itertools
27:26 - dot I slice I've spelled that wrong I
27:29 - slice we will pass in the file as the
27:32 - first argument and let's just pass in a
27:35 - 3 and remember with one argument that's
27:38 - just going to be the stopping point so
27:40 - it's gonna start at the beginning which
27:41 - is the first line and just go up to 3 so
27:44 - that should grab me the first three
27:46 - lines of the file so now I'm going to
27:48 - loop over those so I'm gonna say 4 line
27:50 - in header go ahead and print each of
27:54 - those lines so I will save that and run
27:58 - it and we can see that it prints those
28:00 - first few lines from the log file now
28:02 - those are broken up on two different
28:03 - lines but that's just because the line
28:05 - itself has a newline character in it and
28:08 - the print function also adds a line
28:10 - between print statements now if we
28:12 - wanted to get rid of that then we could
28:14 - just simply come up here to our print
28:15 - statement and say end is equal to an
28:19 - empty string and it won't add an empty
28:21 - line between those print statements so
28:24 - if I save that and run it then we can
28:26 - see that now it just gets those first
28:28 - few lines so that's useful because if we
28:30 - were looping over tons of large files
28:32 - and getting just these few lines then
28:35 - doing it this way will allow us to get
28:36 - those values without loading the entire
28:38 - contents of that file into memory ok so
28:42 - now that we've seen that now let's look
28:44 - at a few functions and Inter tools that
28:46 - allow us to select certain elements from
28:49 - an iterable first let's look at the
28:51 - compressed function so compress is a
28:54 - function that I could see being used in
28:56 - data science style problems
28:58 - where you have some data and some
28:59 - selectors that you can use to filter
29:01 - down that data so let's say that we have
29:04 - a list of true/false values that
29:06 - correspond to my letters list here so
29:09 - first let me just get rid of this file
29:11 - example here and scroll back up and now
29:14 - like I was saying let's say that we have
29:18 - a list of true/false values and they're
29:20 - gonna correspond to my letters list here
29:22 - and I'm going to call these selectors so
29:24 - I'll say selectors is equal to and this
29:27 - will just be a list and I'll just pass
29:29 - in a list of true true false true so we
29:34 - can just pretend that this is another
29:36 - column of data of true/false values and
29:38 - we could pretend that this is anything
29:40 - like if someone is over the age of 21 or
29:42 - if they're married or whatever so we can
29:45 - use the compress function and pass in
29:48 - our iterable with these selectors and it
29:50 - will return a new iterable that only
29:52 - contains the items in our iterable that
29:55 - had a corresponding true value so this
29:58 - will make more sense when we see this
30:00 - example so let me uncomment out our code
30:03 - here and instead of I slice I'm going to
30:06 - instead look at the compressed function
30:09 - so I'll say compress and let's pass in
30:12 - our letters here and also pass in those
30:16 - selectors now like I said this compress
30:18 - function should return and iterable that
30:22 - has all of our corresponding letters
30:24 - that had true values and our selectors
30:27 - so if I save that and run it then we can
30:29 - see that it gives us the values of a B
30:31 - and D so C wasn't included because it's
30:35 - corresponding selector was false now you
30:38 - might notice that this is kind of
30:39 - similar to the built-in filter function
30:41 - the difference is that filter uses a
30:44 - function to determine whether something
30:46 - is true or false but with compress those
30:48 - values are just passed in as an iterable
30:51 - so depending on your problem that you're
30:53 - trying to solve you would use whichever
30:55 - of those are most appropriate so let me
30:57 - show you how filter works really quick
30:59 - just so we can compare the two
31:00 - so with filter we need to create a
31:03 - function so I'm going to create a
31:05 - function here at the top and I'm just
31:07 - going to say I'm going to call this LT
31:10 - to for values
31:11 - less than two and we'll take in a value
31:14 - of in there and so I'll just say if n is
31:17 - less than 2 then we want to return true
31:20 - otherwise we'll just return false and
31:23 - now if we run an interval through that
31:25 - built-in filter function using this
31:27 - function that we just created
31:29 - then it will give us all of the values
31:31 - that are less than 2 so for our result
31:34 - here I'll just say filter and I will use
31:37 - that function that we just created which
31:40 - was LT 2 and I'll pass in our numbers
31:43 - list here so let me save that and run it
31:45 - and we can see that when we run that we
31:47 - get the numbers that are less than 2 now
31:50 - there are some functions and itertools
31:51 - that compliment these built-in functions
31:53 - so there is one integer tools called
31:56 - filter false and it's just like this
31:58 - built-in filter function except instead
32:01 - it gives you the values that return
32:02 - false instead of true so instead of
32:05 - using this built-in filter function here
32:08 - if I instead said itertools dot filter
32:13 - false if i save that and run it then we
32:16 - can see that now we get the values that
32:18 - are greater than or equal to 2 because
32:20 - those are what returned false from our
32:23 - function now there are two more
32:25 - itertools functions that are similar to
32:28 - filter but these stop filtering once a
32:31 - function returns true now I don't think
32:33 - I've ever found the need to actually use
32:35 - these but I'm sure they could be useful
32:37 - in certain situations so first let's
32:39 - look at drop while so the drop while
32:42 - function will drop values from an
32:44 - iterable until one of the values returns
32:47 - true so for and then from that point on
32:49 - it simply returns the rest of the
32:51 - iterable so to show you the difference
32:52 - from filter let me put in some other
32:55 - values at the end of our numbers list
32:56 - here that would have been filtered out
32:59 - so I will say 0 1 2 3 then 2 1 0 so if I
33:06 - save this with those new values and run
33:08 - this then we can see that the values
33:10 - greater than or equal to 2 still get
33:13 - filtered out but instead let's use drop
33:16 - while instead of filter false so I will
33:19 - say drop while and use the same
33:21 - arguments and if I save that and run
33:24 - that now
33:24 - and scroll up here a little bit then we
33:27 - can see that our first couple of values
33:29 - were less than two so it dropped those
33:32 - but once it hit a value that was greater
33:34 - than or equal to two then it stopped
33:37 - applying that filter and just returned
33:38 - the rest of the iterable so it doesn't
33:41 - filter out all of those values just the
33:43 - drops the first few ones that met that
33:45 - criteria so our result down here was
33:48 - equal to two three two one zero so
33:51 - everything after those first couple of
33:53 - values now again I don't think I've ever
33:54 - personally used this but I'm sure there
33:56 - are situations where it could be useful
33:58 - and for the opposite of that we also
34:00 - have the take while function so take
34:03 - while well instead grab all the values
34:05 - that return true and as soon as it hits
34:08 - a value that doesn't return true then it
34:10 - will just return the values that it has
34:12 - at that point so see what this looks
34:15 - like
34:15 - instead of drop while I will simply
34:17 - replace this with take while so let's
34:19 - save that and run it and we can see that
34:21 - what it did there was take the values
34:23 - that return to true from our function
34:26 - until it hit a value that returned false
34:29 - and after it got a value that returned
34:31 - false then it just returned the values
34:33 - that it had up until that point so 0 was
34:36 - less than 2 so it added that one was
34:38 - less than 2 so that added that then it
34:40 - hit 2 which is equal to or greater than
34:43 - 2 and so it just stopped at that point
34:45 - and return 0 and 1 ok so we're just
34:48 - about finished up I know that this video
34:49 - is getting a little long but we only
34:51 - have a couple more functions to go over
34:53 - so another function that we're going to
34:55 - look at is called accumulate so just
34:58 - like it sounds
34:59 - this takes an iterable and returns
35:00 - accumulated sums of each item that it
35:03 - sees and it keeps using addition by
35:06 - default but you can use other functions
35:08 - as well you know such as multiply or
35:11 - something like that
35:12 - so let's pass our numbers list and the
35:14 - through this accumulate function and see
35:17 - what this does so let me scroll up here
35:19 - a little bit I'm gonna get rid of our
35:20 - selectors and our function here we're
35:23 - not gonna need those anymore and now I
35:27 - just want to use this accumulate
35:31 - function and I want to pass in our
35:33 - numbers in to this function okay so if I
35:37 - run this
35:38 - then we can see that each time through
35:41 - the loop it just keeps a running total
35:44 - of the values that it has seen so far so
35:47 - it starts at 0 and then 0 plus 1 is 1
35:50 - and then 1 plus 2 is equal to 3 and then
35:55 - 3 plus 3 is equal to 6 and it just keeps
35:59 - doing that all the way through our list
36:01 - so whenever we scroll down here it kept
36:04 - a total sum of 9 at the end and we can
36:07 - pass in different functions as well so
36:09 - if we wanted to multiply these values
36:11 - instead of adding them then we can
36:13 - simply say so we'll have to actually
36:16 - import something here I'm gonna import
36:19 - it here at the top actually so I'll say
36:21 - import operator because we need to grab
36:24 - this multiply function so down here I
36:28 - can now say for the function that we
36:30 - want to use operator dot mu L for
36:33 - multiply function and now if we run that
36:36 - using this data now this isn't very
36:39 - exciting because all of our values are
36:41 - going to be 0 since our first value here
36:43 - was 0 everything multiplied by 0 is
36:45 - going to be 0 so instead let me just get
36:48 - rid of that first 0 there and rerun this
36:51 - scroll up then now we can see that it's
36:53 - keeping a running product so 1 times 2
36:56 - is 2 2 times 3 is 6 6 times 2 is 12 and
37:00 - so on okay so that is the accumulate
37:03 - function okay so now let's take a look
37:06 - at our last major function in itertools
37:08 - and that is going to be called group by
37:10 - now I saved this one for last since it's
37:12 - a little harder to explain but hopefully
37:15 - after you see the examples it'll be a
37:17 - bit easier so this will go through an
37:19 - iterable and group values based on a
37:21 - certain key and then it will return a
37:24 - stream of tuples now the tuples consist
37:27 - of the key that the items were grouped
37:29 - on and the segment value of the tuple is
37:32 - an iterator that contain all of the
37:34 - items that were grouped by that key so I
37:36 - know that that sounds confusing but
37:38 - let's take a look at an example and
37:40 - hopefully this will sink in so to show
37:42 - this I'm gonna grab some code from my
37:44 - snippets here so up here and my snippets
37:46 - I'm gonna grab this big list of
37:48 - dictionaries here and I'm going to
37:52 - this right here into our code and
37:55 - actually just to make this more clean
37:57 - I'm just going to replace everything
37:59 - except our itertools import so let me
38:02 - repay stat in there and like I said I'll
38:04 - have a link to these code snippets and
38:06 - the description section below
38:07 - if you'd like to follow along with this
38:09 - so what we have here is a list of
38:12 - dictionaries and each dictionary in this
38:14 - list contains some information so we
38:17 - have a person's name and a city and a
38:21 - state
38:22 - so let's say that we wanted to group all
38:24 - of our people by the state that they're
38:26 - from so how would we do that
38:28 - well that's what our group by function
38:31 - can help us with but first we're going
38:33 - to need a function that tells group by
38:35 - exactly what we want to group on and
38:38 - that's going to be our key so we need to
38:40 - write a function that tells us what to
38:42 - return from a single item in our
38:44 - iterable so I'm gonna go up here to the
38:47 - top and I'm going to create a function
38:49 - here just called get state and this is
38:52 - going to take in a person because that's
38:54 - what a single item from our interval is
38:55 - going to be is it's going to be a
38:57 - dictionary that represents a person and
38:59 - now we just want to return what we want
39:02 - our key to be so I'm just going to say
39:04 - return person and we're going to access
39:07 - that state value so that is going to
39:11 - tell group by that for every item in our
39:13 - interval we want to group by the state
39:15 - so now let's actually run this so down
39:18 - here at the bottom and you can see that
39:20 - this list we have several people here in
39:22 - our list now down here at the bottom I'm
39:25 - gonna say person underscore group and
39:28 - I'm gonna set this equal to and we will
39:30 - say itertools itertools dot group by and
39:35 - we want to group this list and this list
39:38 - is called
39:39 - people so I'll scroll back down here so
39:41 - this is called people and we want the
39:43 - key to be equal to that get state
39:46 - function that we created and now let's
39:49 - loop over this so each item in this
39:51 - person group is going to be a tuple of
39:54 - two things so the first thing is going
39:56 - to be our key and the key that we used
39:59 - was the state and the second is going to
40:02 - be an iterable of all the items in that
40:05 - so it should be an iterable of each
40:07 - person in that state so let's print both
40:10 - of these out just so we can see what
40:11 - this looks like so I'm gonna say four
40:13 - key and group in our person group and
40:17 - for now let's just print out both the
40:21 - key and the group so if I save this and
40:24 - run it then we can see let me make this
40:26 - a little larger here we can see that we
40:28 - have four different groups one for each
40:31 - state that was present in our list of
40:34 - people and our group variable here is an
40:37 - iterable that should contain all of the
40:39 - people from that state so let's also
40:42 - loop over that group and print those out
40:44 - as well so within our for loop here I'm
40:48 - just going to print the key on the first
40:50 - line and now I'm gonna loop over that
40:52 - group so I'm gonna say for person in
40:55 - group and we just want to print out that
41:00 - person and I'm also going to put a print
41:03 - statement here at the end and that's
41:05 - just going to be to spread out our
41:06 - output a little bit so now let me save
41:09 - this and run it and scroll up here to
41:12 - the top and again let me make this just
41:15 - a little larger okay so in our output
41:18 - here we can see that we are first
41:20 - printing out our key and that's what we
41:22 - print it out right here which is the
41:24 - state and then we're looping over the
41:26 - group which are the people that are in
41:28 - that state so we can see that from New
41:31 - York we have John Doe and Jane Doe and
41:33 - then it moves on to Colorado and prints
41:35 - out the people from there then it goes
41:37 - to West Virginia and prints those out
41:38 - and finally North Carolina so our group
41:41 - by function did a lot of work in the
41:42 - background there for us just to get
41:45 - those results in a nice efficient way
41:47 - now there are all kinds of interesting
41:49 - problems that we can solve using this
41:51 - group by function so for example what if
41:53 - instead of printing out all the people
41:55 - from that state we just wanted to print
41:56 - the number of people in our list from
41:58 - there so instead I'm just going to
42:00 - comment out our for loop there instead
42:02 - I'm just going to print out our key and
42:04 - then just the length of our group so if
42:07 - I save that and run it oh and that's
42:09 - actually an iterator I forgot so we have
42:11 - to cast that to a list before we can get
42:13 - the length so if I cast that to a list
42:17 - and then rerun this then we can see that
42:19 - in our
42:19 - list we had two of those people from New
42:21 - York two from Colorado two from West
42:22 - Virginia and three from North Carolina
42:24 - so you can probably think of all
42:25 - different types of problems that you
42:27 - could use to solve with this group by
42:28 - function so for example how many
42:30 - students in your class got AIDS versus
42:33 - bees versus C's and so on sorts of
42:35 - problems like that now one thing that I
42:37 - should mention is that group by expects
42:40 - the initial iterable to be sorted so
42:42 - that it can group properly so if we look
42:45 - at the initial list of our values then
42:47 - the people are already sorted by state
42:49 - so we have the people from New York
42:51 - first people from Colorado second and so
42:54 - on now if we were to put someone from
42:56 - New York onto the end of that list then
42:58 - it wouldn't include them in the first
43:00 - group of people from that state so group
43:02 - by is a little different than the SQL
43:04 - version of the group by function in the
43:06 - sense that it needs the values to be
43:08 - sorted beforehand and we won't cover
43:10 - sorting in this video but if you want to
43:13 - see how we'd sort a list of dictionaries
43:15 - like this then I do have a separate
43:17 - video on sorting where I covered all of
43:19 - that and I'll be sure to put that in the
43:21 - description section below as well
43:22 - okay so we're basically finished up but
43:24 - I wanted to show you one last thing that
43:26 - we'll just take about two seconds so
43:28 - let's say that we wanted to replicate an
43:30 - iterator now this can sometimes be
43:32 - harder to do than we think
43:34 - well the inner tools module gives us a
43:36 - nice simple function for replicating
43:38 - iterators easily and we can do this
43:41 - using the T function so let's say that I
43:44 - wanted to replicate this person group
43:47 - and to do two different intervals so to
43:49 - do that I could simply come down here
43:52 - and say copy one copy to is equal to
43:56 - itertools dot t and that is te e and
44:00 - then just pass in that person group and
44:03 - if you were to run that then now your
44:05 - copy 1 and copy 2 will be their own
44:08 - individual intervals and if we wanted
44:10 - more copies then we could just pass in
44:12 - an argument to this T function and
44:14 - return however many that we'd like and
44:17 - one thing to note is that you should no
44:20 - longer use the original iterator after
44:22 - you copy it so in this example it means
44:25 - that we should only use these copies of
44:27 - copy one and copy two and not use this
44:30 - original person group iterator
44:32 - after that we've made the copy or it
44:34 - could have unintended consequences of
44:36 - exhausting the items in the replicates
44:38 - so that's something to keep in mind
44:40 - there now on a side note I actually have
44:43 - no idea what T stands for or why they
44:47 - named it that rather than something a
44:48 - little more intuitive so if anyone knows
44:50 - what that means then feel free to let me
44:52 - know in the comments I think it comes
44:54 - from a Linux command with the same name
44:56 - but I'm not too familiar with that Linux
44:58 - command either but anyways with that
45:00 - said I think that is going to do it for
45:02 - this video hopefully now you have some
45:04 - ideas for how you can begin to use the
45:06 - itertools module and your daily coding
45:08 - and possibly write some more efficient
45:10 - code but if you do have any questions
45:12 - about what we covered in this video then
45:14 - feel free to let ask in the comment
45:15 - section below and I'll be sure to answer
45:17 - those and if you enjoy these tutorials
45:19 - and would like to support them then
45:20 - there are several ways you can do that
45:21 - these its ways to simply LIKE the video
45:23 - and give it a thumbs up and also it's a
45:25 - huge help to share these videos with
45:26 - anyone who you think would find them
45:28 - useful and if you have the means you can
45:29 - contribute through patreon and there's a
45:31 - link to that page in the description
45:32 - section below
45:33 - be sure to subscribe for future videos
45:34 - and thank you all for watching
45:47 - you

Cleaned transcript:

hey there how's it going everybody in this video we're going to be taking a look at the inter tools module so itertools is a collection of tools that allows us to work with iterators in a fast and memory efficient way now if you don't know what an iterator is it's basically sequential data that we can iterate or loop over now I would recommend being familiar with the concept of iterators and generators before watching this video I do have a video that I released a little over a week ago that I'll leave in the description section below if you want to watch that video first it's probably not absolutely necessary but understanding how an iterator is exhausted or how some only hold one object in memory at a time is going to help with understanding how itertools is working as well so the inter tools module contains a number of commonly used iterators as well as functions for combining several iterators now The Sitter tools module is available in the Python standard library so there's nothing that you need to install in order to use this now if you're looking for a specific itertools function then I'm going to try to put a timestamp in the description section below to each of the functions that we go over in this video so you can look there for a time step to whichever function that you're looking for so first off let's go ahead and import this so that we can see what we can do with this so first I'll just say import it err tools ok so right off the bat let me show you one of the most simple itertools functions so the first function that we're going to look at is called count and just like it sounds it simply returns an iterator that counts so we can say that use that just by saying counter is equal to itertools dot count and by default if we don't pass in any arguments then count will just start at 0 and count out by one each iteration and this is just going to go on forever so right now if we were to loop over this it would just start counting up from zero by one and never stop so if you're not careful then you can get stuck in an infinite loop now I'm going to show you what this looks like but I wouldn't recommend you do this on your machine because sometimes it's hard to stop from executing and can freeze up your computer or program but I'm going to try to run this and just stop it quickly so I'm just going to say for num in counter oops in counter and we will just print out num now again this is going to be an infinite loop but I'm just run this and stop it quickly okay so I ran that and then quickly stopped it by hitting ctrl C but even in that short time it already counted up by a lot we already got up over two hundred thousand here now if you are familiar with iterators then we can actually get the next value without using a for loop we can simply just use the next function and pass in our iterator so instead of looping through it like this instead let's do something like I will remove this for loop and just say print next and then next counter so let's save that and run it and when we run that we can see that we get a zero now if I copy and paste this a couple of times and run this again so I'll copy and paste this a few times here and run it then we can see that each time we run next we get 0 1 2 3 and it just keeps on going and this is one big key take away from these iterators some of them can go on forever but even if they do we can still just get one item at a time ok so why is this useful well there's a lot of different scenarios that this might be useful but let's just look at one example so it's very common to have a list of values and want to have some kind of index assigned to them so to show an example let me create a quick list here so I'm going to comment out these print statements and I'm just going to make a quick list of data here and say that I want 100 200 300 and 400 so here we just have a list of some random numbers so let's say that we wanted this data to be paired up with an index value for some reason well for example let's say that our data took place over a daily basis and we wanted to graph this so we want to pair it up by saying ok 100 is associated with day 0 200 is associated with day 1 300 is day 2 and so on now if we don't know how much data there's going to be then we can simply use the count function to provide values for any amount of data so for example we could simply say something like this so I will say daily underscore data is equal to and I'm going to use the zip function here and then I will pass in itertools dot count and as the first argument and then our data list as the the second argument now if you don't know what the builtin zip function does basically it combines two intervals and pairs the values together so it will get the first value of the count function which by default is zero and it will pair it with the first value of data which in this example is 100 and then it will move on and pair one with two hundred and two with three hundred and so on now the zip function will return an iterator itself that needs to be looped over in order to get all the values now if we want we can simply convert the results to a list and get them all at once so I could just convert this entire thing to a list by wrapping all of that in a list function so now that we've done that let me print out our daily data variable here so I will print that out then we can see that it paired those values up in our result and since we use itertools count it just kept grabbing the next value until our data list had gone through all of its values so that count function will work with any size of data okay so we can also pass some arguments into our count function in order to start at a different place and we can also step by a different amount as well so let me uncomment out these print statements here and for now I'm just going to comment out our data example here and let me actually grab these print statements and put these up here okay so now let's look at passing some arguments into our count function so if I wanted to start from something other than zero then I could simply pass in a value of start equals five for example if I save that and run it we can see that now our counter starts at five and we get five six seven eight now it's still counting up by one and we can also pass a step argument to change how the counter is incremented so if I started at five then I could also pass in an argument of step equals five if I save that and run it then we can see it now starts at five and now it's counting up by five each time so 5 10 15 20 now the counter is pretty versatile it can also count backwards and can also count by decimal numbers as well so if I was to instead say that our step is negative two point five for example and then run that then we can see that it starts at five and subtracts 2.5 from each step and then even goes into the negatives okay so that's a look at the count function now since we've already seen an example using the builtin zip function down here let me show you a knitter tools function that is just like this except it doesn't end until the longest iterable is exhausted and again the built in zip function ends on the shortest iterable so this itertools function is called zip longus so a pretty obvious name for what it does now remember this pairs iterables together so if it doesn't end until the longest interval is exhausted then it means it will need to pair some other values with some placeholders so by default that's going to be a none value so let me comment out these lines up here and uncomment out this example where we used this zip function here now this worked before because zip ends after our shortest interval is exhausted and we're not going to be able to use the itertools count function with the zip longest the way that we have it right here because we're converting it into a list and since count goes on forever then that would just run out of memory trying to convert that to a list now you could still use count and just not cast it to a list but then you just need to get the next values one at a time but let's leave this list here and simply replace count with a range of values instead so instead I'm going to a switch count out here and instead just say something like range of 10 values so if I run this right now while we're still just using this regular zip builtin then we can see that it runs just like it did before it just pairs those values up until our shortest interval is exhausted and the shortest interval here is data so as soon as all of our data is paired together then it just cuts off those values and it doesn't pair the rest of our range here but if instead we use zip longest from itertools so I'll say it err Tools dot zip underscore longest if I save that and run it then we can see that it pairs those intervals together but when our data variable runs out it continues and just pairs the rest of our range with none values so that can be useful depending on the type of problem that you're trying to solve so we can see here that it paired up the values and then this is where our data ran out but then it continued with the range and just put none values here for four or five six seven eight and nine okay so that was a quick detour looking at the zip longest function and now let's get back to looking at a couple more iterative tools functions that can go on indefinitely so let's look at the cycle function so cycle also returns an iterator that goes on forever basically it takes an iterable as an argument and will cycle through those values over and over so let me get rid of this example that we have here and uncomment out this so that we can see an example of this cycle function okay so instead of count I'm going to say itertools dot cycle and this takes in an iterator and basically like I said it's just going to cycle over these over and over so I will just pass in a list of one two three and four our print statements here I only have four here right now let me make this six total here so that we can see exactly what this is doing so I will save this and run it and let me zoom up a little bit okay so we can see that our output is just one two three one two three so it loops through our list that we just passed into cycle but once it hits the end of the list it just cycles back through so that's a pretty simple concept but there's a lot that you could do with it so for example if you wanted to simulate a switch of something getting turned on or off or something like that then you could simply create a cycle with two values so that could either be a 1 and a negative 1 or a 1 and a 0 or you could even pass in a list of strings of on and off so for example if I came up here instead of a list I'll actually use a tuple just to show a different data structure here and I'll say on and off as our two values in that tuple so if I save that and run it then if I screw up to the top here we can see that it just cycles between the values of on off on off on off each time the next value is fetched so that's a look at the cycle function it's super simple but there's a lot of different ways that we could use it okay so now let's look at the last infinite iterator and itertools and that's going to be the repeat function and this one is also super simple it just takes some input and repeats it indefinitely so for example if I was to come up here and say itertools dot repeat and then just pass in a value of two for example if I save that and run it then we can see that it simply repeats the same value over and over each time we fetch the next value and we can set a limit on this too so if I was to instead come up here and say repeat and then just say times equal to three and save that and run it then if I scroll up here a little bit then we can see that it repeats the value for the first three times and then it throws a stop iteration exception now if we had run that through a for loop then it would have just looped through that three times and we wouldn't have seen that exception since the for loop handles those stop iteration exceptions for us now on the surface this might not seem very useful but it's usually used for passing in a stream of constant values two functions like map or zip that also operate on intervals so for example if you wanted to get the square of the values one through ten then you could do something like this for example so I'm just going to comment out these print statements here so let me type out an example of this and I actually got this from the Python documentation so I'm going to say squares is equal to map and with map will use the pal function which takes the power of values and we will pass in arguments of a range of ten and also we'll do a knitter tools dot repeat and we'll just pass in a value of two there as well now if you don't know what map does basically it takes a function in this case we're using pal which raises a number to a certain power and then it takes iterables and uses the values from those to pass as arguments to that function and it will loop through and pass values from those intervals into a function until the shortest list of arguments has run through all of its values so this will start off by passing in the next value from our range and that would start at zero and it will also pass in the first value of our repeat iterable which is always going to so the first value it will calculate is going to be zero to the second power and then the next time through it'll do one to the second power and then two to the second power and so on so if I print this out this is actually going to be needed to be converted to a list as well otherwise it's just going to be an iterator waiting to be iterated on but I'll cast it to a list so I'll just put out print out a list of those squares and run that now we can see that we got a list of the squares of all the values from zero to nine so that's a little more practical of an example of where you would use that repeat function like I said it's usually used for passing in a stream of constant values to a function like map or zip now since we're already using the map function this would be a good time to look at another itertools function that modifies the map function a little bit and this is called star map basically star map is very similar to map but instead of taking arguments from iterables like we're doing here it instead takes arguments that are already paired together as tuples so for example let's use star map to get these first few powers so instead of passing in range and this repeat here I'm just going to pass in a list and these are going to be a list of tuples that have the arguments already paired together and I'm just going to do the first few here so I'm going to go 0 to the second power and then let me go ahead and copy this to make this a little quicker so I'll do 0 to the second power then 1 to the second power and then 2 to the second power and instead of map we instead want to use itertools dot star map so if I save that and run it then you can see that it ran our arguments here as tuples into our power function and we got 0 1 & 4 for the results of those arguments so pretty similar to map but instead it takes its arguments as a list of tuples instead so depending on the problem that you're trying to solve that might be more useful for you ok so so far we've gone over itertools functions that produce iterators that can go on forever but now let's look at some useful functions that will eventually terminate so first let's go over two of the moe popular in Turtles functions and those are combinations and permutations so these allow us to take an iterable and return all of the combinations or permutations from that interval and if you don't know the difference between combinations and permutations basically combinations are all the different ways that you can group a certain number of items or the order does not matter and permutations are all the different ways that you can group a certain number of items where the order does matter so let's look at some examples and this will be more clear so I'm going to use a couple of lists hear from our snippets file and I'll post this snippets file in the code to this snippets file in the description section below if you want to use this as well but I'm just going to grab three code snippets here and I'm going to paste these up here at the top and to clean up what we have so far let me go ahead and just remove what we already have here and save that okay so for this example I'm going to use our letters list here that consists of the values of a b c d so let's say that i want to get all of the possible combinations of two values from those letters so to do that I can simply say I'll say result is equal to itertools dot combinations and I want to get the combinations of the letters and I want to get all the different combinations of two values and now let me make this output a little smaller here and now let me do a for loop where I say for item in result print the item so let me save that and run it and make this a little larger again okay so we can see that when we loop through those it gives us all the different combinations of two values that we can make from our original list of ABCD now remember with combinations the order does not matter so we can see that we have a combination here of a B but we don't see a combination of B a and that's because they are seen as the same combination and sometimes this is exactly what we want so for example if we're simulating a poker hand or something like that then it wouldn't matter what order your hand is in so an ace King would be the same thing as a king ace so you would need to produce bow of those combinations now if order does matter then you'll want to use permutations instead that will give you all of the different ways that you can a group certain number of items where the order does matter so let's go ahead and look at that so I'm going to just replace combinations here with our permutations function and rerun this so instead of combinations I will say permutations save that and run it and now if I scroll up here we can see that we got more values there and that's because we're going to get all the different ways that we can arrange two values from our original iterable where the order does matter so we can see that we have a value for a B here at the top but if we scroll down a little bit then we also have a permutation for BA as well now you can think of this as trying to simulate all of the different possible results of a race or something like that so if a came first and then B then that would be different than B coming first and then a so permutations is what you would want to use in a situation like that now one thing that you'll notice is that combinations and permutations don't repeat values so what I mean by that so for example with our permutations here we have all the different ways that we can arrange two items from our original list but it doesn't repeat any of those values so for example it doesn't give us a a as one of the permutations and that's because there's only one a in our original list but what if we wanted to allow repeats so for example let's use our numbers list so you can see how having numbers list here of 0 1 2 and 3 so let's pretend that we wanted to see all the different ways that we could create a fourdigit code using these values and that would include repeats so we could have a code that's 0 0 0 or 0 1 0 1 or anything like that well for that we couldn't use combinations or permutations because that will only give us the ways that we can range the values in that list if we wanted the values to be able to repeat then we could use the product function which will give you the Cartesian product of iterables that you pass in now if we only pass in one iterable then we can tell it how many times we want it to be able to repeat those values so with that said let's look at an example here so I'm gonna say itertools dot product and we're going to use our numbers here and let's say that we want to set repeat equal to four so what this is going to do is it's going to give us all the different ways that we could arrange these numbers where repeats are allowed so if I save this and run it and scroll up here to the top then we can see that this gives us what we were looking for in terms of going through all the different ways that we could arrange these numbers in groups of four now this is also a way that you could build some kind of password cracker so for example you could create a loop where you go through all the different ways to arrange alphanumeric characters in you know a pattern of six or something like that now I should also mention that there's a way to get combinations with repeated values as well and we do that with a function called combinations with replacements so if I just go up here and replace product with combinations whoops be sure to spell this right combinations underscore with underscore replacement and instead of repeat here we can just pass that and as a positional argument instead so if I save that and run it and go up here to the top then we can see that now we get all the different combinations of those four numbers but it allows repeated values as well so that's a look at some of the ways to get different groups of arrangements from an iterable and always find it fascinating to use combinations and permutations and products and they're definitely useful depending on what you're trying to solve okay so now let's look at some other useful itertools functions that allow us to solve certain types of problems so now let's look at the chain function so chain allows us to chain together intervals so that it will go through all the items in the first interval and after that has been exhausted then it'll go through all the items in the second interval and so on so I have three different lists here that I pulled from my snippets are there and let's pretend that we want to loop over all of these values and all of these lists so how would we do this so one way would be that we could create a new list that combines all three of these lists and then loops over those so we could say something like let me overwrite this part here so I could just say combined is equal to you know letters plus numbers plus names now the problem with an approach like this is that it creates a new list with all of those values in memory so the sample list that we have here are really short so it wouldn't be a big deal using it in this situation but what if these lists contain millions of items it would be majorly inefficient for us to make copies of all of those and put them into another variable or what if those weren't even list a that they were generators or something like that instead then how would we loop over all of those at once well to do this we can use chain so instead of doing it the way we have here let's instead say combined is equal to itertools dot chain and I will just pass in all of those to our chain so letters numbers and names so now if we loop over these I'll say for item in combined then we will print out the item if I save that and run it then if I scroll up here then we can see that first loop through our letters and after those were exhausted it looped there our numbers and then our names at the end so we can see that it looped over all of the items in all three of those iterables so that can be extremely efficient depending on the data that you're iterating over okay so now let's look at a function that will allow us to get a slice of an iterator so you can think of this like list slicing where you can specify that you only want the first five item items of a list or something like that but this function will allow us to perform slicing on an iterator and this function is called I slice so to use this there are three different arguments that we can pass in we can pass in a stopping point to go from the beginning of an iterator until it hits a stopping point so for example let's say that I wanted to slice a range from 0 to 9 and stop on the fifth index so to do that I could just come up here and say itertools dot I slice and we will slice a range of 10 values and I will pass in a stopping value of 5 now instead of combined here I'm just going to change that to result so that that variable makes more I also have to change it in the for loop here as well so if I save that and run it then we can see that it gives us the first five items of that iterable now if you're thinking to yourself you know why is this useful because I can already do that with list slicing well don't worry we'll look at some useful examples here in just a minute okay so we can also pass in a starting point argument into I slice as well now if there's only one argument like we have here then it will assume that it's the stopping point but if we put in two arguments then it will assume that it is the starting point and stopping point so if we wanted to skip the first value then I could come in here and just say one as our first argument and then five and it'll think that one is the starting point and five is the stopping point so if I save that and run it then we can see that now it started at index 1 and stopped at index 5 and lastly we can also do steps so if we want to do the same slice that we have now but only get every other value then we can simply say that we want to step by 2 so up here I can also pass in another argument there as a 2 and that'll be the step so if I save that and run it then we can see that we get the values from the 1st to 5th index but it steps by 2 okay so why is this useful so this is useful because like with our other examples so far we may have an iterator that is just too large to put into memory so we don't want to cast it to a list just to get a certain slice of that iterator so for example let's imagine that we have some log files on your machine that are thousands and thousands of lines but you only want to grab the top few lines that are the header of the log file so to do this efficiently we can use I slice now I have a sample file here where I'm going to do this so I have a sample file called test log and this is it here and we can see that we have some fake data in here but the top three lines have the date the author and the description so I just want to grab those and ignore everything else so let's do this using I slice so I'm going to come back to the demo here I'll make this a little smaller here and for now I'm just going to comment out our previous example and scroll down here a little bit and now let's use this I slice on this log file so I'm gonna say with open to open this file and that file was called test dot log now this is in the same directory as my python file so I don't have to pass in a full path if it's in the same directory then it'll work just like this and I want to read that file and now that we have that file open files are actually iterators themselves and whenever you call next on them it gets the next line in the file so we can use them just like any other iterator so in order to just grab the header I'm going to say that the header is equal to itertools dot I slice I've spelled that wrong I slice we will pass in the file as the first argument and let's just pass in a 3 and remember with one argument that's just going to be the stopping point so it's gonna start at the beginning which is the first line and just go up to 3 so that should grab me the first three lines of the file so now I'm going to loop over those so I'm gonna say 4 line in header go ahead and print each of those lines so I will save that and run it and we can see that it prints those first few lines from the log file now those are broken up on two different lines but that's just because the line itself has a newline character in it and the print function also adds a line between print statements now if we wanted to get rid of that then we could just simply come up here to our print statement and say end is equal to an empty string and it won't add an empty line between those print statements so if I save that and run it then we can see that now it just gets those first few lines so that's useful because if we were looping over tons of large files and getting just these few lines then doing it this way will allow us to get those values without loading the entire contents of that file into memory ok so now that we've seen that now let's look at a few functions and Inter tools that allow us to select certain elements from an iterable first let's look at the compressed function so compress is a function that I could see being used in data science style problems where you have some data and some selectors that you can use to filter down that data so let's say that we have a list of true/false values that correspond to my letters list here so first let me just get rid of this file example here and scroll back up and now like I was saying let's say that we have a list of true/false values and they're gonna correspond to my letters list here and I'm going to call these selectors so I'll say selectors is equal to and this will just be a list and I'll just pass in a list of true true false true so we can just pretend that this is another column of data of true/false values and we could pretend that this is anything like if someone is over the age of 21 or if they're married or whatever so we can use the compress function and pass in our iterable with these selectors and it will return a new iterable that only contains the items in our iterable that had a corresponding true value so this will make more sense when we see this example so let me uncomment out our code here and instead of I slice I'm going to instead look at the compressed function so I'll say compress and let's pass in our letters here and also pass in those selectors now like I said this compress function should return and iterable that has all of our corresponding letters that had true values and our selectors so if I save that and run it then we can see that it gives us the values of a B and D so C wasn't included because it's corresponding selector was false now you might notice that this is kind of similar to the builtin filter function the difference is that filter uses a function to determine whether something is true or false but with compress those values are just passed in as an iterable so depending on your problem that you're trying to solve you would use whichever of those are most appropriate so let me show you how filter works really quick just so we can compare the two so with filter we need to create a function so I'm going to create a function here at the top and I'm just going to say I'm going to call this LT to for values less than two and we'll take in a value of in there and so I'll just say if n is less than 2 then we want to return true otherwise we'll just return false and now if we run an interval through that builtin filter function using this function that we just created then it will give us all of the values that are less than 2 so for our result here I'll just say filter and I will use that function that we just created which was LT 2 and I'll pass in our numbers list here so let me save that and run it and we can see that when we run that we get the numbers that are less than 2 now there are some functions and itertools that compliment these builtin functions so there is one integer tools called filter false and it's just like this builtin filter function except instead it gives you the values that return false instead of true so instead of using this builtin filter function here if I instead said itertools dot filter false if i save that and run it then we can see that now we get the values that are greater than or equal to 2 because those are what returned false from our function now there are two more itertools functions that are similar to filter but these stop filtering once a function returns true now I don't think I've ever found the need to actually use these but I'm sure they could be useful in certain situations so first let's look at drop while so the drop while function will drop values from an iterable until one of the values returns true so for and then from that point on it simply returns the rest of the iterable so to show you the difference from filter let me put in some other values at the end of our numbers list here that would have been filtered out so I will say 0 1 2 3 then 2 1 0 so if I save this with those new values and run this then we can see that the values greater than or equal to 2 still get filtered out but instead let's use drop while instead of filter false so I will say drop while and use the same arguments and if I save that and run that now and scroll up here a little bit then we can see that our first couple of values were less than two so it dropped those but once it hit a value that was greater than or equal to two then it stopped applying that filter and just returned the rest of the iterable so it doesn't filter out all of those values just the drops the first few ones that met that criteria so our result down here was equal to two three two one zero so everything after those first couple of values now again I don't think I've ever personally used this but I'm sure there are situations where it could be useful and for the opposite of that we also have the take while function so take while well instead grab all the values that return true and as soon as it hits a value that doesn't return true then it will just return the values that it has at that point so see what this looks like instead of drop while I will simply replace this with take while so let's save that and run it and we can see that what it did there was take the values that return to true from our function until it hit a value that returned false and after it got a value that returned false then it just returned the values that it had up until that point so 0 was less than 2 so it added that one was less than 2 so that added that then it hit 2 which is equal to or greater than 2 and so it just stopped at that point and return 0 and 1 ok so we're just about finished up I know that this video is getting a little long but we only have a couple more functions to go over so another function that we're going to look at is called accumulate so just like it sounds this takes an iterable and returns accumulated sums of each item that it sees and it keeps using addition by default but you can use other functions as well you know such as multiply or something like that so let's pass our numbers list and the through this accumulate function and see what this does so let me scroll up here a little bit I'm gonna get rid of our selectors and our function here we're not gonna need those anymore and now I just want to use this accumulate function and I want to pass in our numbers in to this function okay so if I run this then we can see that each time through the loop it just keeps a running total of the values that it has seen so far so it starts at 0 and then 0 plus 1 is 1 and then 1 plus 2 is equal to 3 and then 3 plus 3 is equal to 6 and it just keeps doing that all the way through our list so whenever we scroll down here it kept a total sum of 9 at the end and we can pass in different functions as well so if we wanted to multiply these values instead of adding them then we can simply say so we'll have to actually import something here I'm gonna import it here at the top actually so I'll say import operator because we need to grab this multiply function so down here I can now say for the function that we want to use operator dot mu L for multiply function and now if we run that using this data now this isn't very exciting because all of our values are going to be 0 since our first value here was 0 everything multiplied by 0 is going to be 0 so instead let me just get rid of that first 0 there and rerun this scroll up then now we can see that it's keeping a running product so 1 times 2 is 2 2 times 3 is 6 6 times 2 is 12 and so on okay so that is the accumulate function okay so now let's take a look at our last major function in itertools and that is going to be called group by now I saved this one for last since it's a little harder to explain but hopefully after you see the examples it'll be a bit easier so this will go through an iterable and group values based on a certain key and then it will return a stream of tuples now the tuples consist of the key that the items were grouped on and the segment value of the tuple is an iterator that contain all of the items that were grouped by that key so I know that that sounds confusing but let's take a look at an example and hopefully this will sink in so to show this I'm gonna grab some code from my snippets here so up here and my snippets I'm gonna grab this big list of dictionaries here and I'm going to this right here into our code and actually just to make this more clean I'm just going to replace everything except our itertools import so let me repay stat in there and like I said I'll have a link to these code snippets and the description section below if you'd like to follow along with this so what we have here is a list of dictionaries and each dictionary in this list contains some information so we have a person's name and a city and a state so let's say that we wanted to group all of our people by the state that they're from so how would we do that well that's what our group by function can help us with but first we're going to need a function that tells group by exactly what we want to group on and that's going to be our key so we need to write a function that tells us what to return from a single item in our iterable so I'm gonna go up here to the top and I'm going to create a function here just called get state and this is going to take in a person because that's what a single item from our interval is going to be is it's going to be a dictionary that represents a person and now we just want to return what we want our key to be so I'm just going to say return person and we're going to access that state value so that is going to tell group by that for every item in our interval we want to group by the state so now let's actually run this so down here at the bottom and you can see that this list we have several people here in our list now down here at the bottom I'm gonna say person underscore group and I'm gonna set this equal to and we will say itertools itertools dot group by and we want to group this list and this list is called people so I'll scroll back down here so this is called people and we want the key to be equal to that get state function that we created and now let's loop over this so each item in this person group is going to be a tuple of two things so the first thing is going to be our key and the key that we used was the state and the second is going to be an iterable of all the items in that so it should be an iterable of each person in that state so let's print both of these out just so we can see what this looks like so I'm gonna say four key and group in our person group and for now let's just print out both the key and the group so if I save this and run it then we can see let me make this a little larger here we can see that we have four different groups one for each state that was present in our list of people and our group variable here is an iterable that should contain all of the people from that state so let's also loop over that group and print those out as well so within our for loop here I'm just going to print the key on the first line and now I'm gonna loop over that group so I'm gonna say for person in group and we just want to print out that person and I'm also going to put a print statement here at the end and that's just going to be to spread out our output a little bit so now let me save this and run it and scroll up here to the top and again let me make this just a little larger okay so in our output here we can see that we are first printing out our key and that's what we print it out right here which is the state and then we're looping over the group which are the people that are in that state so we can see that from New York we have John Doe and Jane Doe and then it moves on to Colorado and prints out the people from there then it goes to West Virginia and prints those out and finally North Carolina so our group by function did a lot of work in the background there for us just to get those results in a nice efficient way now there are all kinds of interesting problems that we can solve using this group by function so for example what if instead of printing out all the people from that state we just wanted to print the number of people in our list from there so instead I'm just going to comment out our for loop there instead I'm just going to print out our key and then just the length of our group so if I save that and run it oh and that's actually an iterator I forgot so we have to cast that to a list before we can get the length so if I cast that to a list and then rerun this then we can see that in our list we had two of those people from New York two from Colorado two from West Virginia and three from North Carolina so you can probably think of all different types of problems that you could use to solve with this group by function so for example how many students in your class got AIDS versus bees versus C's and so on sorts of problems like that now one thing that I should mention is that group by expects the initial iterable to be sorted so that it can group properly so if we look at the initial list of our values then the people are already sorted by state so we have the people from New York first people from Colorado second and so on now if we were to put someone from New York onto the end of that list then it wouldn't include them in the first group of people from that state so group by is a little different than the SQL version of the group by function in the sense that it needs the values to be sorted beforehand and we won't cover sorting in this video but if you want to see how we'd sort a list of dictionaries like this then I do have a separate video on sorting where I covered all of that and I'll be sure to put that in the description section below as well okay so we're basically finished up but I wanted to show you one last thing that we'll just take about two seconds so let's say that we wanted to replicate an iterator now this can sometimes be harder to do than we think well the inner tools module gives us a nice simple function for replicating iterators easily and we can do this using the T function so let's say that I wanted to replicate this person group and to do two different intervals so to do that I could simply come down here and say copy one copy to is equal to itertools dot t and that is te e and then just pass in that person group and if you were to run that then now your copy 1 and copy 2 will be their own individual intervals and if we wanted more copies then we could just pass in an argument to this T function and return however many that we'd like and one thing to note is that you should no longer use the original iterator after you copy it so in this example it means that we should only use these copies of copy one and copy two and not use this original person group iterator after that we've made the copy or it could have unintended consequences of exhausting the items in the replicates so that's something to keep in mind there now on a side note I actually have no idea what T stands for or why they named it that rather than something a little more intuitive so if anyone knows what that means then feel free to let me know in the comments I think it comes from a Linux command with the same name but I'm not too familiar with that Linux command either but anyways with that said I think that is going to do it for this video hopefully now you have some ideas for how you can begin to use the itertools module and your daily coding and possibly write some more efficient code but if you do have any questions about what we covered in this video then feel free to let ask in the comment section below and I'll be sure to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that these its ways to simply LIKE the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
