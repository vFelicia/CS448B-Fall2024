With timestamps:

00:00 - hey there how's it going everybody in
00:01 - this video we're gonna learn how to
00:02 - deploy our django application using
00:04 - Heroku so that anyone with internet
00:06 - access can use it within a browser so so
00:09 - far we've created this application with
00:11 - some good functionality but the site
00:12 - still only lives on our local machine so
00:15 - right now I have this running in my
00:16 - browser on my local machine but no one
00:18 - else can access this so the point of
00:20 - building these sites and applications is
00:22 - to deploy them so that they're
00:25 - accessible over the Internet so in this
00:27 - video we're going to use Heroku to
00:29 - deploy our application now if you don't
00:31 - know what Heroku is it's a platform that
00:33 - allows us to easily deploy and host
00:36 - applications without going through the
00:38 - headache of setting up everything on our
00:39 - own manually so if you watch my video on
00:42 - how to deploy to a Linux server then you
00:44 - would have noticed that that took a lot
00:46 - of time and also requires you to be
00:47 - familiar with a little bit of system
00:50 - administration and things like that in
00:51 - order to get your application up and
00:54 - running
00:54 - Heroku abstracts a lot of that away and
00:58 - allows us to get our application
01:00 - deployed more easily without needing to
01:02 - set up our own web servers and firewalls
01:04 - and stuff like that and they also have a
01:07 - free tier that you can use so that you
01:09 - can actually get your application
01:10 - deployed without paying any money and
01:12 - then if you need to add any features
01:14 - that aren't being included for free then
01:16 - you can simply scale up however you need
01:18 - now one thing that I should mention
01:19 - about Heroku is that they don't have a
01:22 - normal file system like we're used to it
01:25 - will hold our static files and things
01:27 - like that but if we store a bunch of
01:29 - images or user uploads then those are
01:31 - actually going to be deleted so if
01:33 - you're saving images or files from your
01:35 - users then you'll need to use a service
01:38 - through something like Amazon Web
01:40 - Services in s3 buckets so if you're
01:43 - following along with this series then we
01:45 - already saw how to get that set up in
01:47 - our last video okay so with that said
01:49 - let's go ahead and get started so first
01:51 - you're going to need to create a Heroku
01:54 - account this is pretty straightforward
01:55 - you're just going to want to go to their
01:57 - website and create an account just like
02:00 - you would on any other site so I've
02:02 - already gone and signed up for an
02:04 - account through them but if you hasn't
02:06 - haven't then you can just go to sign up
02:08 - and fill in all your information and
02:09 - just register like you would with any
02:11 - other site now once you've created an
02:13 - count we also have a few prerequisites
02:16 - that we need to set up so first we're
02:18 - going to need to use get version control
02:21 - now using git and version control is
02:23 - considered a best practice by just about
02:25 - any programmer out there so I think it's
02:27 - great that this is how Heroku does its
02:29 - deployments because it basically steers
02:31 - you towards best practices so installing
02:34 - git is also very straightforward so I'll
02:36 - open up the git download page here now
02:39 - most of you likely already have git
02:40 - installed so I'm not going to go into
02:42 - that here but if for some reason you
02:44 - don't have git installed then I'll leave
02:46 - a link in the description section below
02:48 - to this download page that I have pulled
02:50 - up here so that you can download git for
02:52 - whichever operating system you are using
02:54 - now another thing that you're going to
02:56 - want to do once you have a Heroku
02:57 - account is you're going to want to
02:59 - install the Heroku command-line
03:01 - interface which is the Heroku CLI for
03:04 - short
03:05 - the Heroku CLI is going to allow us to
03:07 - deploy our application from our command
03:09 - line using some Heroku specific commands
03:12 - so this page that I have opened here
03:14 - will give you instructions for how to
03:15 - download this for a Mac Windows or Linux
03:18 - and again I'll have a link to this page
03:20 - in the description section below as well
03:22 - so that you can download the CLI for
03:24 - whichever operating system you're using
03:26 - I'm on a Mac so that's the option that I
03:29 - chose but I've already downloaded and
03:31 - installed this and once you have that
03:33 - CLI installed let's open up our command
03:36 - line and see if that worked so I'm going
03:38 - to open up my command line here and
03:41 - you're just went going to test this by
03:43 - simply typing in Heroku so I'll type in
03:46 - Heroku and run that and if our
03:48 - installation of the Heroku CLI worked
03:50 - then it should list out a list of
03:52 - commands that we can use to interact
03:54 - with our account now the first thing
03:56 - that we'll need to do is log in through
03:59 - the command line so that we're validated
04:01 - to run these commands on our account so
04:04 - to do this I'm just going to scroll down
04:05 - actually I'll just clear my page here
04:08 - by the way by typing in Heroku you can
04:10 - see all of the commands that we can use
04:12 - here but I will clear the page now to
04:15 - login I'm going to say
04:17 - Heroku login and I'll run that and you
04:20 - can see it says press any key to open up
04:22 - the browser to log in or press Q to exit
04:24 - so I'm going to press any key and it's
04:26 - going to open up a
04:27 - browser and asked me to login to Heroku
04:30 - so from here you can log-in to your
04:33 - Heroku account so I'm going to go ahead
04:35 - and do that okay so now it says we're
04:40 - logged in and that we can close this
04:41 - page and return to our CLI and that it
04:44 - should now be logged in so now I should
04:46 - be authenticated so once you're
04:48 - authenticated then we can continue with
04:50 - our deployment so there are a few things
04:52 - that we want to do within our project
04:53 - before we deploy so I'm going to pull
04:56 - back up
04:57 - my terminal here and I've already
05:00 - navigated to my project directory and
05:03 - you're going to want to do the same mine
05:05 - is located on my desktop and it's called
05:07 - Jango Project but you can navigate to
05:09 - wherever yours is located and once
05:12 - you're navigated to your project then
05:13 - we're going to want to create a
05:14 - requirements txt file now if you haven't
05:17 - created a requirements that txt file
05:19 - basically it is a file that holds all of
05:22 - the dependencies that we're using in our
05:24 - application now I'm using a virtual
05:26 - environment so all of my packages are
05:28 - specific to this project but if you
05:30 - aren't using a virtual environment then
05:32 - I'll link to the requirements that txt
05:35 - file that my app produces and I'll link
05:37 - to those in the description section
05:39 - below
05:39 - now you likely don't want to just use
05:41 - your systems Python dependencies because
05:43 - it could contain a lot of packages that
05:45 - aren't specific to your project and all
05:48 - of these are going to get installed on
05:49 - Heroku so it's best to keep it exclusive
05:52 - to what's actually needed for our
05:53 - application so first before we create
05:56 - our requirements txt file of our
05:58 - dependencies
05:59 - let's pip and install one more package
06:01 - that we're going to use when our
06:02 - application is deployed and that is G
06:05 - unicorn so I'm going to install that by
06:08 - saying pip install G unicorn so we will
06:12 - install that and once we have that
06:14 - installed now we want to create our
06:16 - requirements that txt file now the
06:18 - requirements file is also how Heroku
06:20 - knows that it's a Python application if
06:23 - you're using a setup PI file or a pip
06:26 - file then you can use those instead and
06:28 - it'll also recognize it as a Python
06:30 - application okay so now to make this
06:33 - requirements that txt file we can simply
06:36 - say let me clear this and first do
06:39 - something called a pip
06:41 - freeze if I run pip freeze then we can
06:44 - see that this lists out all of the PIP
06:47 - installations that we have currently
06:49 - made and these are what we want to add
06:51 - to a requirements txt file so if you're
06:54 - on Windows then you can just create a
06:56 - requirements txt file in your project
06:58 - and copy all of those copy all of the
07:01 - output output from pip freeze and just
07:04 - paste that into a requirements txt file
07:07 - if you are on Mac or Linux or using bash
07:11 - then we can simply say pip freeze and we
07:15 - can just pipe that into a requirements
07:18 - dot txt file and that'll create that
07:21 - file for us with the output of that pip
07:23 - freeze command okay so now we should
07:25 - have that requirements dot txt file in
07:27 - our project folder that has the output
07:29 - from that pip freeze command okay so
07:32 - another thing that we need to do here is
07:34 - to use git within our application so
07:38 - some of you may have already been using
07:40 - it for this but if not then I'll run
07:43 - through these steps real quick so it's
07:45 - extremely easy to do we just have to
07:48 - simply run the command to get an it to
07:51 - initialize and empty git repository so
07:54 - we ran that and we can see it says
07:56 - initialize empty git repository in our
07:59 - project folder so now we're using git
08:01 - version control within our application
08:02 - it's actually that easy in this video
08:05 - we're going to be using very simple git
08:08 - commands so you don't need to be
08:09 - extremely comfortable with using it in
08:12 - the command line but if you'd like to
08:13 - see an in-depth explanation and
08:15 - walkthrough of how to use git then I do
08:17 - have a detailed video on that as well
08:19 - and I'll leave a link to that in the
08:20 - description section below if anyone is
08:22 - interested okay so now we're ready to
08:24 - tell git what files we want to actually
08:27 - track there are usually going to be
08:29 - certain files that we don't want get to
08:31 - track so for example anything that is
08:33 - specific to my machine or something like
08:35 - that
08:36 - we're going to want to ignore that now
08:38 - one resource that I use a lot for this
08:41 - is from github itself and it's a
08:43 - template of commonly ignored files for
08:46 - Python programs and actually have that
08:48 - open here in my browser let me close
08:51 - down this page and open this up so this
08:53 - is the Python get
08:55 - nor file here and we can see that it
08:58 - ignores files like pyc files and logs
09:02 - and stuff like that that kind of stuff
09:05 - you likely don't want to track with git
09:08 - it also has a django section if I scroll
09:11 - down here a bit we can see it has a
09:13 - django section here now we can see it
09:16 - ignores our DB sequel Lite file as well
09:19 - and that is our sequel Lite database and
09:22 - that's fine because we're actually not
09:24 - going to be using sequel Lite for our
09:26 - production database in development we've
09:28 - been using sequel Lite but for
09:30 - production we're going to set up a new
09:32 - Postgres database
09:33 - Postgres is the database of choice for a
09:35 - lot of different websites because of its
09:37 - you know features and performance so
09:40 - that's what we're going to be using and
09:41 - it's also what Heroku recommends and
09:43 - it's walkthroughs so I'm actually going
09:45 - to copy this template get ignore file
09:47 - from github and use that as a starting
09:49 - point for my get ignore file now one tip
09:52 - is that if you're ever copying something
09:54 - from github then you can just click on
09:56 - this raw link here towards the top right
09:59 - of the page and it will take you to just
10:02 - the text of the file so that it's easier
10:04 - to copy and paste so this is all of the
10:07 - text of that git ignore file so I'm
10:09 - going to just highlight all of that and
10:11 - copy and now I'm going to go back to my
10:14 - project and in my project I'm going to
10:17 - create a git ignore file so I'm going to
10:19 - go to a new file and this is actually
10:21 - going to be a dot file so it is dot get
10:24 - ignore so don't forget the dot before
10:27 - get ignore so I'm going to create that
10:30 - and open that up and I'm going to paste
10:32 - in what we got from github and then
10:34 - scroll up here to the top so we can see
10:37 - that it is ignoring a lot of these
10:39 - different files we have some unit test
10:42 - files in here and things like that so
10:44 - that's good now at the top of mine I'm
10:46 - also going to add something that gets
10:48 - added on Macs sometimes if you're on
10:50 - Windows then you don't have to do this
10:52 - but at the top I'm also going to add a
10:55 - section for Mac and I'm gonna add a file
10:59 - here that is dot d s underscore store
11:02 - and that's just an annoying file that
11:04 - gets created on Mac sometimes that we
11:07 - don't want to commit with our project as
11:09 - well
11:09 - so I'm going to add that to the get it
11:11 - ignore file okay so now that we have our
11:13 - get ignore file let's go back to the
11:16 - command line and commit all of our
11:18 - changes so far so I'm going to open up
11:20 - our terminal here and to do this we can
11:24 - simply say git add with a dash capital a
11:29 - and that's going to add all of the
11:30 - changes that we have so far so I'll run
11:33 - that and now if I do a git status then
11:37 - we can see that we have all of these new
11:40 - files now the reason our entire project
11:42 - is saying that it's new files is because
11:45 - we just initialized our git repository
11:47 - so all of these files are new to get
11:49 - none of them have been committed yet
11:51 - so now let's commit them to get so I can
11:54 - say git commit and then we can do a dash
11:57 - M here to set a message for this commit
12:00 - and I'm just gonna say initial commit
12:03 - and run that okay so now we've committed
12:06 - these files to get locally so now that
12:09 - we've committed these locally let's
12:11 - create an Heroku app where we can push
12:14 - this code so to do this we can simply
12:16 - use the Heroku command so let me clear
12:19 - the screen here so I can say whoops
12:22 - Heroku oh sorry about that
12:24 - Heroku create and now the name of our
12:28 - app so I've just called mine my awesome
12:31 - app and run that well and it looks like
12:33 - my awesome app is already taken as a
12:36 - name for a Heroku app so instead this
12:39 - might take some trial and error but
12:40 - let's see here I'll call this my Django
12:43 - app and try to create that that's
12:45 - already taken as well okay how about
12:47 - this we'll do my awesome Django app I
12:51 - doubt that is taken okay so that one
12:53 - worked okay so when that app is created
12:55 - it's actually going to create a domain
12:58 - for us as well and I can see that domain
13:00 - and the output of that create command
13:03 - you could so you can either copy and
13:05 - paste that into your browser or you can
13:07 - simply run Heroku open to open that in
13:10 - your browser so this is the URL here you
13:13 - can copy and paste that into a browser
13:14 - or let me clear my screen here or I can
13:18 - just say Heroku open and it will
13:21 - automatically open that URL in
13:23 - my browser so we can see here that our
13:25 - site is currently working but it's just
13:27 - using the default Heroku site for now
13:29 - now if that Heroku open command didn't
13:32 - work for you and it says that you're
13:34 - missing a require flag to specify what
13:36 - app you want to open then it's likely
13:38 - because you're not in your projects
13:40 - directory within your command line or
13:42 - possibly you did some of these steps out
13:45 - of order so for example if you create an
13:47 - app in a directory that isn't tracked by
13:49 - git then it might give you some issues
13:52 - and require you to set that stuff up in
13:53 - a different way but if you did
13:55 - everything in the order that we covered
13:57 - in this video then this should be
13:58 - working for you so we can see here that
14:00 - it gave us a domain of my awesome Jango
14:03 - app dot Heroku app comm and we currently
14:06 - have Heroku default site so we haven't
14:09 - actually deployed anything yet so now
14:11 - let's go ahead and do that so let's push
14:14 - our code to Heroku so if we go back to
14:17 - our command line then we can push that
14:20 - by saying git push Heroku master so if
14:26 - we run that then this is going to start
14:28 - pushing our code up to Heroku so we can
14:31 - see that it's going to do a lot of
14:32 - different things here so it's saying
14:34 - that a Python app is detected that it's
14:36 - installing Python installing pip and all
14:39 - of these different things so let me
14:41 - let's run through this installation here
14:44 - ok so if you just have a simple Python
14:47 - application then that might have worked
14:49 - for you and pushed that up to Heroku now
14:51 - ours didn't work because our application
14:53 - is a bit more complex and it ran into an
14:56 - issue while it was deploying now the
14:58 - good part is that if it runs into an
14:59 - error like this then your app just
15:02 - doesn't get deployed so it won't break
15:04 - your website if it runs into errors at
15:06 - this deployment section here so if we
15:09 - scroll up here a little bit then we
15:10 - should see a detailed traceback of
15:12 - exactly what went wrong now my text is a
15:16 - bit larger here so that you all can see
15:18 - so this is going to be a bit bunched
15:20 - together but I'll see if I can find the
15:23 - part where it ran into an error so we
15:27 - can see that the error happened when it
15:28 - ran this command Python managed PI
15:33 - collect
15:34 - static now if that's not obvious from
15:36 - this section here
15:37 - if I scroll down a little bit here then
15:40 - we can see that it gives a note here
15:42 - error while running Python managed dot
15:45 - pi collects static so what that command
15:47 - does is it collects our static files so
15:50 - that they can be served up in production
15:52 - so if you've been following along with
15:53 - this series then you might remember that
15:55 - at one point I mentioned that those
15:57 - static files would be handled
15:58 - differently in production so that's what
16:01 - this is so that's a command that Heroku
16:03 - runs for us so that it can automate that
16:06 - process but if I scroll down a bit to
16:09 - see what went wrong with that command or
16:11 - scroll up a little bit then we can see
16:13 - that it says here you're using the
16:15 - static files app without having set the
16:19 - static route setting to a file system
16:21 - path so that's telling us that we don't
16:23 - have this static route variable set to
16:26 - where our static files will be located
16:28 - on the file system so let's go ahead and
16:31 - set that in our settings so I'm going to
16:34 - open up our project here I'm going to
16:37 - close the get ignore file and now let me
16:39 - open the settings dot py file and once
16:42 - when you have that open I'm going to
16:43 - scroll down to the very bottom here and
16:46 - let me turn off the word wrap so that we
16:48 - can see this a bit better now I'm going
16:51 - to scroll up to where we have our static
16:53 - URL okay so now let's set our static
16:56 - route now the location that Heroku will
16:58 - put the static files for us when they
17:00 - run that command is going to be in a
17:03 - directory called static files so we will
17:06 - say and let me actually copy this media
17:10 - root because this is going to be very
17:11 - similar but instead of media root this
17:14 - is going to be static root and the
17:17 - location that Heroku is going to put
17:19 - these files is going to be called static
17:22 - files so I will put that there and save
17:25 - that okay so earlier our deployment
17:27 - failed because we didn't have the static
17:29 - root set so now we can try to commit our
17:31 - updates and deploy this again now I'm
17:34 - gonna tell you right now that it's still
17:36 - not going to work but the reason I'm
17:38 - showing you one step at a time like this
17:40 - is so that we can see the justification
17:42 - for each step instead of just ploughing
17:45 - through all of the changes that we need
17:46 - to make seeing it one step at a time
17:49 - like this might help you debug an applic
17:51 - in the future if you have an application
17:53 - that is different from what we've
17:55 - created here
17:56 - so let's commit these updates and try to
17:58 - redeploy so I'm going to open back up
18:00 - the command line here and let me clear
18:03 - my screen and now let's commit these
18:06 - updates and redeploy so first if we want
18:09 - to see what we changed I can say get
18:11 - status and we can see that we modified
18:13 - our settings dot py file and to add that
18:16 - to the files that we want to commit we
18:18 - can simply say git add - a - add all of
18:21 - the modified files and now we can commit
18:25 - that so I'll say git commit dash M for a
18:28 - message and I'll just say updated static
18:32 - root and I will commit that okay so now
18:35 - we have committed that locally and now
18:37 - let's actually push that up to Heroku
18:39 - and try to deploy that so I'm gonna say
18:42 - git push Heroku master so if I run that
18:46 - then it's going to run through and try
18:49 - to deploy this again okay so it looks
18:52 - like our deployment was successful and
18:54 - we don't have any errors when we tried
18:56 - to push our code so that's good but now
18:59 - let's try to open our application in the
19:01 - browser and again if I clear my screen
19:04 - we can do that with Heroku open so I'll
19:07 - run Heroku open to open our application
19:11 - in the browser and now let me make this
19:13 - a little larger here so that you all can
19:15 - read it so now it's telling us that
19:17 - we're getting an application error so
19:20 - this is different than getting an error
19:22 - during deployment so it gives us a hint
19:24 - here it says that if we're the owner of
19:26 - this application then we can run this
19:28 - command Heroku logs - - tale that
19:32 - command will allow us to see the latest
19:34 - logs of our application so I'm going to
19:37 - copy that command and let's go back to
19:40 - our terminal and run that so I'll pull
19:42 - up the terminal and I will paste that in
19:44 - Heroku logs - - tale now if you look
19:48 - through these logs then we can actually
19:50 - find a lot of interesting things and you
19:53 - can actually use the logging module from
19:55 - the Python standard library to log out
19:57 - different things wherever you want so if
20:00 - you want these logs to be even more
20:01 - detailed and then you can use that but
20:05 - what we want to look at here is the air
20:07 - that we're getting so we can see that
20:08 - the air that we're getting is right here
20:10 - at the bottom and it's running on two
20:13 - different lines here but we can see that
20:15 - the description of this air says that
20:17 - there are no web processes running so
20:20 - what's going on here is that we haven't
20:22 - told her Oh COO how we want to run our
20:24 - application so in order to do this we're
20:27 - going to need to create something called
20:29 - a proc file so I'm going to create this
20:31 - and explain along the way so in the root
20:35 - of our project directory I'm going to
20:38 - create that proc file so within our
20:41 - project directory I'm going to say new
20:43 - file and this is going to be called proc
20:45 - file so that's an uppercase P and then
20:48 - lowercase for the rest and that's PR OC
20:52 - f IL e so this proc file is going to be
20:56 - a simple text file now even though it's
20:59 - a text file be sure you don't create the
21:01 - file with a dot txt extension it should
21:05 - not have an extension so I'm going to
21:08 - create that file and then open that up
21:10 - now within this file we're going to
21:13 - create that web process that our logs
21:15 - said wasn't running so to do this we can
21:18 - simply say and I'm going to type this
21:20 - all out and then explain it later so
21:23 - I'll say web G unicorn make sure I
21:26 - spelled that right G unicorn and then
21:29 - Django underscore project dot WSGI okay
21:34 - so now let's look this over a piece by
21:36 - piece so web is the process type the
21:40 - name web is important here it declares
21:43 - that this process type will receive web
21:45 - traffic traffic when deployed now G
21:48 - unicorn is the command needed to run our
21:51 - web process if you don't know what that
21:53 - is it's basically a way for our Python
21:56 - code to talk to the web server and it's
21:59 - going to do that through our WSGI file
22:01 - so WSGI stands for web service gateway
22:05 - interface so G unicorn is the command
22:08 - and then we're specifying the location
22:11 - to the WSGI file in our application
22:14 - after that so Django project is my
22:18 - package
22:19 - and you'll want to have that be whatever
22:20 - your project directory is called so this
22:23 - right here should be the name the same
22:26 - name as the directory that holds your
22:28 - Settings dot py file so if you called
22:31 - that you know my awesome app or
22:33 - something like that then you want to put
22:35 - that here I called mine Django project
22:37 - and after we specify that package then
22:40 - we want to specify our WSGI file now we
22:43 - didn't make any changes to that WSGI
22:45 - file in this series but that file has a
22:48 - variable called application and g
22:51 - unicorn we'll use that to run our
22:53 - application for us okay so that's going
22:56 - to do it for our proc file now these
22:58 - files can contain additional process
23:00 - types so for example you know you might
23:03 - declare one for a background worker
23:05 - process that processes items off a queue
23:08 - or something like that but in this video
23:10 - we're only going to do the web process
23:13 - so I've saved that file and now let's
23:15 - commit those changes and see what we get
23:18 - in the browser and again I can tell you
23:20 - that this still isn't going to work but
23:22 - we'll go step by step
23:24 - so I'm going to re open our terminal
23:27 - here and I'll press ctrl C to quit those
23:30 - logs and now we can commit our changes
23:32 - so again if we want to see what changes
23:34 - we've made we can do a git status and we
23:37 - can see that we have a new file here
23:38 - proc file so I'll add that and say git
23:41 - add - a to add all of our changes and
23:44 - now do a commit so get commit with a
23:48 - message of added proc file and now I'll
23:52 - clear the screen now let's push this up
23:54 - to Heroku so I'll say git push Heroku
23:58 - whoops Heroku master and run that okay
24:04 - so now we've pushed those changes up to
24:05 - Heroku now you might have noticed that
24:08 - your push to Heroku was faster there
24:10 - than it was before and that's because
24:12 - Roku will see that we've already
24:13 - installed all of the dependencies from
24:16 - the requirements file before and that
24:19 - there aren't any new ones so it'll just
24:20 - skip that step so that's a nice feature
24:22 - of Heroku ok so now let's open up our
24:25 - application and the browser again and
24:27 - again we can do that with just Heroku
24:30 - open so I will run that
24:32 - and open this up okay so now we can see
24:34 - that we're getting a different looking
24:36 - error here now you might recognize that
24:38 - this is actually the Django debug error
24:40 - screen so we have made some progress
24:42 - this is actually now using Django now
24:45 - one thing that should worry us here is
24:47 - that it's showing us so much information
24:50 - on this debug screen and that's why we
24:52 - should definitely turn off debug mode
24:54 - when working in production people could
24:57 - use this information to find
24:59 - vulnerabilities in our application and
25:01 - we definitely don't want that but while
25:03 - we have the debug output here we may as
25:06 - well see what it says so at the very top
25:08 - here it says invalid HTTP host header
25:12 - with this domain name here and then it
25:16 - says you may need to add this to our
25:18 - allowed host so since this is now
25:21 - deployed Django has some built-in
25:23 - security features where we need to
25:24 - explicitly specify the host that we're
25:27 - going to allow for our application and
25:29 - we're going to make this change in our
25:31 - settings dot py file so I'm just going
25:34 - to copy that host that it says that we
25:37 - need to add so that is right here mine
25:40 - is my awesome Django app dot Heroku app
25:44 - comm I'll copy that and now I'm going to
25:47 - add that to our settings dot py file so
25:49 - I'm going to open up our application go
25:51 - back to our settings dot py file and
25:53 - scroll up here to the top and if we
25:55 - scroll down a little bit we can see that
25:57 - we have this allowed host section here
26:00 - so I'm going to paste that in as a
26:03 - string so my awesome Django app dot
26:06 - Heroku app comm now we can also see here
26:09 - in our settings that we have debug equal
26:11 - to true now like I said before we're
26:14 - going to want to set debug equal to
26:16 - false in production but we shouldn't
26:18 - just set it equal to false because when
26:21 - we're on our local machine we actually
26:23 - want debug equal to true for testing so
26:26 - anytime you need a value that's specific
26:29 - to whichever machine you're on that is a
26:31 - good candidate for an environment
26:33 - variable so if you've been following
26:35 - along with this entire series then you
26:37 - should already have some experience
26:39 - setting environment variables since
26:41 - that's where we put our username and
26:43 - password for our email service and
26:45 - also our credentials for AWS s3 but if
26:49 - you don't know how to set environment
26:50 - variables then I actually have a
26:52 - separate video on how to do that for
26:54 - your operating system so I'll leave a
26:56 - link to that video in the description
26:57 - section below if you need to give that a
26:59 - watch so I'm actually going to set a
27:01 - debug environment variable here so that
27:05 - that can be different for our local
27:06 - machine and Heroku now while we're
27:08 - setting environment variables we should
27:10 - also move our secret key to an
27:12 - environment variable while we're at it
27:13 - so the secret key shouldn't be something
27:16 - that we put in our code potentially for
27:18 - other people to see so I'm going to
27:20 - create an environment variable for the
27:22 - secret key as well and I'm actually
27:24 - going to create a new secret key for our
27:26 - application since we've been using the
27:28 - current one for development so the new
27:30 - one that we create will be for
27:32 - production now there are a bunch of ways
27:34 - that we can generate a new secret key
27:36 - but the way that I like to do this is
27:38 - from the Python interpreter so I'm just
27:41 - going to open up my command line here
27:44 - and I'm going to run Python so I'm going
27:47 - to use Python here to generate a random
27:49 - key and you actually have to be running
27:51 - Python 3 in order to use this module so
27:54 - I'm gonna do this using a module called
27:56 - secrets and that is included in the
27:58 - Python 3 standard library so I'm gonna
28:01 - say import secrets and run that and that
28:04 - imported and now I'm gonna use a method
28:07 - called token hex to generate this and
28:09 - the more bytes that you pass in to that
28:11 - method the longer the random value will
28:14 - be so I'll say secrets dot token
28:17 - underscore hex and I'll just pass in a
28:20 - 24 for the bytes there and we can see
28:22 - that it generates this really long
28:24 - random string and that's about as long
28:27 - as our current secret key so I'm going
28:29 - to copy that
28:31 - and I'm gonna add that to my environment
28:33 - variables now since I'm on a Mac I can
28:35 - put these in my dot bash underscore
28:38 - profile file but like I said if you're
28:40 - on a different operating system and
28:42 - don't know how to create environment
28:44 - variables for your operating system then
28:46 - you can watch that other video that I
28:48 - mentioned just a bit ago that's linked
28:50 - in the description section below so I'm
28:52 - going to open my bash profile here so
28:55 - I'm going to exit out of the Python
28:58 - interpreter
28:59 - and open up my bash profile file in my
29:03 - home directory now I used a sublime
29:06 - command to open this up but if you don't
29:09 - have that sublime command set up on your
29:11 - system then you can just open that in
29:13 - whatever editor of your choice
29:16 - once we have that open let me turn off
29:17 - wordwrap here so that we can read this a
29:19 - little better once we have that open I'm
29:21 - going to set this secret key under this
29:25 - section here where we have our Django
29:27 - blog variables and you can see that we
29:29 - already have some environment variables
29:31 - here that we set for AWS in the last
29:34 - video okay so to set this secret key I'm
29:36 - just going to say export secret
29:38 - underscore key set that equal to that
29:41 - string that we just generated and now
29:44 - I'm also going to create an environment
29:45 - variable for our debug value so I'm
29:48 - going to say export debug underscore
29:50 - value and I'm going to set that equal to
29:52 - true since we're on our local machine
29:56 - and we want that debug value equal to
29:58 - true so that we can test our site now on
30:01 - Heroku we're going to set that
30:02 - environment variable equal to false
30:04 - since that'll be our production version
30:06 - now also notice here that our
30:08 - environment variable is a string of true
30:11 - and not just a simple boolean like we
30:14 - would see in Python and we'll see why
30:16 - that's important in just a second but
30:19 - we'll ignore it for now okay so now I
30:22 - have my environment variable set for my
30:24 - local machine so now let's set our
30:26 - environment variables for Heroku so let
30:29 - me save that before we exit out of it
30:31 - and I'm going to pull up my terminal to
30:33 - set these Heroku environment variables
30:35 - so I'm still within my project here
30:37 - within the command line now to add these
30:39 - environment variables to Heroku we can
30:41 - simply say Heroku config colon set and
30:46 - now we can set our environment variables
30:49 - so first I'm going to set a secret key
30:52 - and actually just to make sure I don't
30:54 - mess up any of the spelling here whoops
30:57 - let me go back to our bash profile and
31:01 - I'm just going to grab these from here
31:05 - and whoops copy those back into our
31:09 - terminal so Heroku config set and
31:12 - we'll set that secret key equal to that
31:14 - value and now also say Heroku config :
31:21 - set go back to our environment variables
31:26 - here and set this debug value equal to
31:29 - true and if you've been following along
31:35 - with this series then you also need to
31:36 - set a few more environment variables so
31:39 - these will be the username and password
31:40 - for the email service that you set up in
31:43 - the reset password video and also the
31:45 - AWS credentials that we set up in the
31:48 - AWS s3 video so first I'll do the AWS
31:52 - credentials since we already have those
31:54 - pulled up here so I'm gonna copy this
31:57 - access key ID so again let me just rerun
32:04 - that Heroku config set and I will set
32:07 - that to the AWS access key ID that we
32:11 - used and again let me now do Heroku
32:16 - config set and set this equal to our AWS
32:21 - secret access key okay and lastly let me
32:28 - do Roku config set set this equal to our
32:32 - AWS Storage bucket name and paste that
32:38 - in got that set and now I'm going to do
32:41 - my email user and password for the email
32:44 - service so I'm going to say Heroku
32:48 - config set and first that was email
32:53 - underscore user and my email user is
32:56 - equal to Corey M Schaefer at gmail.com
33:00 - and for the password that was email
33:05 - underscore Paz now I'm not actually
33:09 - going to put my email password here for
33:11 - obvious reasons I don't want to
33:12 - broadcast that to everyone in a video
33:15 - but I'm going to pause the video and put
33:18 - in my password here in an environment
33:20 - variable to get the emails to work and
33:22 - then I will pick up the video after
33:24 - I have put that in okay so I pause the
33:28 - video and put in that email password as
33:30 - an environment variable and now picked
33:32 - it back up so now that we have all of
33:34 - those environment variables set now
33:36 - let's update our settings dot py file to
33:39 - use those environment variables that we
33:40 - just set so I'm going to go back to
33:43 - sublime and open up our settings dot py
33:47 - file so for our secret key here I'm just
33:49 - going to comment out the old secret key
33:52 - and now I'll set a new one here so I'll
33:55 - say secret key is equal to and to grab
33:57 - an environment variable we can say Oh s
34:00 - dot environed on git and we can get that
34:06 - environment variable and we just called
34:08 - that secret key as the environment
34:09 - variable as well so we can just grab
34:11 - that now for our debug value I'm going
34:14 - to leave this set to true just for a bit
34:16 - longer until we get this deployed and
34:18 - once it's working then I'll set it equal
34:21 - to false
34:21 - once everything is working properly okay
34:24 - so we've made some changes to our
34:26 - settings so now let's commit our changes
34:28 - and put those up to Heroku and see what
34:31 - we get so I'm gonna go back to the
34:33 - command line here and instead of running
34:35 - get status I'm just going to go ahead
34:37 - and add these you can run get status if
34:39 - you want to see what you've changed but
34:41 - I'll just add all of our changes and now
34:43 - I'll say git commit dash M for the
34:46 - message and we can say updated settings
34:50 - and now let's push that to Heroku so git
34:53 - push Heroku master and I'll run that
34:58 - okay so once we have that deployed let's
35:01 - take a look at our site so I'm going to
35:04 - say Heroku open to open that up in the
35:07 - browser okay so we're still getting an
35:09 - error this time the error says no such
35:13 - table blog post okay so remember we
35:16 - didn't push our SQL Lite database that
35:19 - we've been using in deployment because
35:21 - we're going to use Postgres in
35:23 - production so this is a little expected
35:25 - since we haven't created any tables in a
35:27 - Postgres database yet so first of all
35:30 - we're going to need Postgres installed
35:32 - on our machine to get this working so
35:34 - let me pull up Roku's documentation on
35:37 - this I
35:38 - I have this pulled up over here okay and
35:41 - again I'll have a link to all of these
35:43 - resources in the description section
35:44 - below
35:45 - so that you don't have to look around
35:47 - for this stuff so we can see that they
35:49 - give instructions for how to install
35:50 - Postgres for different operating systems
35:54 - so we have it to setup for mac and for
35:58 - windows and for linux now i already went
36:00 - through the installation for mac so you
36:03 - don't have to watch me do that but it's
36:05 - pretty straightforward just follow what
36:07 - they have listed step by step so once
36:10 - you have Postgres installed on your
36:12 - machine we're going to want to create a
36:14 - Postgres database on Heroku now it's
36:16 - possible that Heroku already created a
36:18 - database for us it does this for certain
36:20 - applications that have certain libraries
36:22 - so we can check that if I go back to the
36:25 - command line if I say Heroku add-ons and
36:30 - run that then we can see that we have a
36:33 - database for our app already but if you
36:37 - do need to create a database then
36:39 - instead if it didn't create one for you
36:43 - then you could say Heroku add-ons : and
36:46 - create and then Heroku - PostgreSQL let
36:52 - me spell it correctly and then : and
36:54 - then you can put in the plan of database
36:56 - that you want the free version is Hobby
36:59 - - dev so if you don't have a database
37:01 - already then you can run that now I'm
37:04 - not gonna run that since it already has
37:06 - a database for me here now like I said
37:08 - that hobby dev part is the plan and that
37:11 - is the free tier but if you ever need
37:13 - any more performance then you can always
37:15 - bump that up and we can see more about
37:18 - that if we were to run Heroku PG we can
37:23 - see there it shows us a bit more about
37:24 - that database so we can see that it has
37:27 - for the rows zero out of ten thousand so
37:31 - the free tier does have a ten thousand
37:34 - row limit okay so now that we have a
37:37 - Postgres database now we actually need
37:39 - to create tables for it so we also need
37:42 - to create a super user where we can
37:44 - login to our Django admin site so first
37:48 - things first we need to add the
37:50 - credentials to our
37:51 - settings dot py file so that our django
37:54 - application can talk to the database now
37:57 - instead of doing this manually we're
37:59 - going to use a helper function that that
38:01 - Heroku provides for us to do this and we
38:04 - can get that by running a pip install so
38:08 - here within our command line I'm going
38:12 - to do an installation of pip install
38:14 - janggu Django
38:16 - - Heroku so I'll run that so that Django
38:20 - Heroku package is going to automatically
38:23 - configure our database URL and we'll
38:25 - also take care of connecting our static
38:28 - assets to G unicorn using a package
38:31 - called white noise so it's going to set
38:33 - up some stuff for logging and things
38:35 - like that - I think this will even take
38:38 - care of a couple of things we already
38:40 - set up like our secret key and allowed
38:42 - host but I like setting those myself
38:45 - since I'm already in there anyways okay
38:48 - so the way that we get this to work is
38:50 - to open up our settings dot py file so
38:52 - let me open that up here and at the top
38:55 - of our file we want to import that
38:58 - module so I'm going to import Django
39:02 - underscore Heroku now I know that we
39:04 - installed that as Django - Roku but when
39:08 - we import its Django underscore Heroku
39:10 - now at the very bottom of our settings
39:13 - file so let me scroll all the way to the
39:15 - bottom at the very bottom we're gonna
39:17 - say Django Heroku dot Settings and we
39:22 - are going to pass in locals and these
39:26 - need parentheses here at the end so like
39:29 - I said just by adding that in that's
39:30 - going to automatically set a lot of
39:32 - those configurations for us okay so now
39:35 - let's deploy this now one thing that you
39:38 - don't want to forget to do is update
39:40 - your requirements txt file so we've pip
39:43 - installed some packages so we want to
39:46 - make sure Heroku gets those changes so
39:48 - I'm gonna grab those pip frees
39:50 - dependencies again and update my
39:54 - requirements dot txt file so to do this
39:57 - on Mac I can simply say pip freeze and
40:00 - pipe those in to requirements dot txt
40:05 - again if you're on a Windows then you
40:07 - can just paste that pip freeze output
40:09 - into your requirements that txt file
40:12 - instead ok so again if you want to see
40:14 - the changes you can run a get status now
40:17 - mine says that I've modified my settings
40:19 - dot py and that I haven't modified my
40:21 - requirements dot txt file and I think
40:23 - that's just because I already had that
40:25 - one Django Heroku module installed
40:28 - already so that was already in that file
40:30 - ok so now to add those I'll say git add
40:34 - dash a and now I can commit those
40:38 - changes locally so get commit dash M
40:41 - with a message here and the message I
40:44 - will just say added janggu - Heroku and
40:48 - now I can to push those changes to
40:51 - Heroku so I'll say git push Heroku
40:54 - master and let that run through the
40:57 - deployment again ok so that deployment
41:00 - is complete now I promised to y'all that
41:03 - we are about to have our application
41:05 - working but if we check it now then it
41:07 - should still give us some errors so
41:10 - let's see what those are so I'll say
41:11 - Heroku open and open up our page in the
41:15 - browser again and again it says relation
41:18 - and blog posts does not exist
41:20 - ok so we're still getting an error that
41:22 - our tables don't exist but we should be
41:25 - able to talk to the database now with
41:27 - Django so now we just need to run the
41:29 - commands that create the tables and
41:31 - while we're at it we'll also create a
41:33 - super user that has admin access now if
41:36 - you remember from the database video
41:38 - earlier in this series we can create our
41:40 - tables by running the manage py migrate
41:44 - command we shouldn't need to run make
41:46 - migrations because the migrations we
41:49 - already had should have been pushed up
41:51 - with our application so we only need to
41:53 - run migrate so how do we run that
41:57 - command on Heroku well there are two
41:59 - ways that we can do this we can if we
42:02 - want to run a command on Heroku then we
42:04 - can use Heroku run so for example let me
42:08 - go back to my terminal here and let me
42:11 - go ahead and clear the screen so if we
42:14 - want to run a command on Heroku we can
42:16 - say Heroku
42:17 - run and now I can specify any command
42:21 - that I want to run on the shell of our
42:23 - Heroku and that command will be run from
42:26 - the root of our application so I could
42:29 - simply say Heroku run Python managed py
42:34 - migrate so if I run that then it's going
42:38 - to run Python managed py migrate on our
42:43 - Heroku machine so that should have run
42:46 - our migrations for our application and
42:49 - created our tables and if we scroll up
42:51 - here we can see that it looks like
42:52 - that's what it did we have a bunch of
42:55 - green marks here that said everything
42:56 - went ok
42:58 - ok so now our tables should be created
43:00 - now while we're at it let's also create
43:03 - a super user that can login to the admin
43:05 - panel remember we're starting over with
43:08 - a new production database here so our
43:11 - old one that we used in development it
43:13 - no longer exists we have to also create
43:15 - this on Heroku now another way that we
43:17 - can run in commands on Heroku is to
43:20 - actually run a bash shell from Heroku
43:23 - itself so let me clear my screen here
43:25 - now the way to do this is we can simply
43:27 - say Heroku run bash and if I run Heroku
43:31 - run at bash then it should give me a
43:33 - bash shell to our Heroku machine okay so
43:37 - now we're connected to our Heroku
43:39 - machine and now we can run some commands
43:41 - since we'll actually be on the hokum of
43:43 - machine we won't need to prepend the
43:46 - command with Heroku run anymore
43:48 - now these roca machines are called dinos
43:51 - and they are a Linux system so you need
43:54 - to run Linux commands so for example if
43:57 - I run LS then it lists the files and
44:01 - directories of the current directory
44:02 - which is the root of our application so
44:06 - we can run commands from here as well so
44:08 - to create a super user we can simply say
44:11 - python managed dot py and create super
44:16 - user so if i run that then it's going to
44:19 - ask for a username and password and all
44:22 - of that good stuff so I will make my
44:24 - username core EMS and then the email
44:28 - address
44:29 - put in my email address and now I
44:32 - password
44:33 - I'll just put as testing 321 okay so our
44:38 - super user was created successfully and
44:40 - now to exit our Heroku manned machine we
44:43 - can simply type exit and now once it
44:48 - exits out of there we are now back on
44:50 - our local machine now that we're back on
44:52 - our local machine now let's try running
44:54 - our website again now that we should
44:57 - have created those tables and that super
44:59 - user so I'm gonna say Heroku open to
45:03 - open our website in the browser and now
45:05 - it actually looks like we're getting
45:07 - somewhere let me resize this here to be
45:10 - a little smaller so we can see our
45:12 - application is running here at my
45:14 - awesome django app roku app comm so this
45:18 - should be accessible to anyone on the
45:20 - internet at this point now there
45:22 - currently aren't any posts because we
45:25 - created a new Postgres database for
45:27 - production so let's test out some of the
45:29 - functionality of the site and see if
45:31 - everything is working so let's try to
45:34 - log in with that super user that we just
45:36 - created so the username there was cory
45:39 - ms the password was testing three two
45:42 - one so if i log in but it looks like we
45:46 - logged in because we can access our
45:47 - profile and stuff like that first let's
45:50 - go to the admin panel and see if our
45:54 - admin site is working and it is so
45:56 - that's good let me try logging out as
45:59 - this user and going back to our site up
46:02 - that's trying to log back into the admin
46:04 - site let's try to create a new user so
46:07 - i'll go to register for the new username
46:10 - I'll just say deployed user for the
46:14 - email I'll say D you at test comm
46:17 - password as testing three to one testing
46:21 - three to one signup okay
46:24 - looks like that user was created let's
46:27 - try to log in as that user okay and that
46:30 - seemed to work so now let's create some
46:32 - new posts here so my first post with the
46:37 - content of my first post and that seems
46:40 - to be working well
46:43 - we are getting our images from Amazon s3
46:46 - like we set up in the last video so that
46:49 - is working well
46:51 - also let me create another post here and
46:55 - try to do some updates so I'll create a
46:59 - post here click on that go to update and
47:02 - say my updated second post that seems to
47:07 - work well let me try to delete that post
47:10 - okay and that's working well
47:12 - also that second post was deleted so
47:14 - we're just kind of going through here
47:15 - and making sure that all this
47:17 - functionality is working correctly now
47:20 - this is also why it's a good idea to
47:21 - have tests set up for your website so
47:24 - that you can just automate all of these
47:26 - tests because doing this manually every
47:28 - time you make some updates takes a long
47:31 - time as you can see but I'm gonna try to
47:34 - update a profile picture here so it
47:36 - looks like our profile picture updated
47:39 - successfully so that's good and lastly
47:41 - let's try to log out and see if it sends
47:46 - us an email if we click on forgot
47:48 - password if this looks like it sends us
47:51 - a reset password email okay and we can
47:54 - see an email has been sent with
47:56 - instructions to reset your password so
47:58 - that looks like it is working also and I
48:00 - actually just saw that email pop up on
48:02 - my phone so it does look like that email
48:05 - went through okay so all of that seems
48:07 - to be working great so now we've got our
48:09 - application deployed to Heroku now when
48:12 - you're working with django django has a
48:15 - deployment checklist on their website
48:17 - that you can look through to make sure
48:19 - that you did everything that you need to
48:20 - do when deploying applications so let me
48:23 - actually search for this so I will go to
48:26 - django deployment checklist and it
48:30 - should be the first result here okay so
48:33 - this deployment checklist it'll kind of
48:36 - tell you the things that you need to do
48:37 - so for example you know hiding your
48:40 - secret key setting debug equal to false
48:43 - so you're going to want to look through
48:45 - this deployment checklist and make sure
48:47 - that you did everything that you need to
48:48 - do when deploying applications and this
48:52 - actually reminds me so it's a good thing
48:54 - that we use this checklist actually
48:56 - reminds me that we didn't set debug
48:57 - equal to false yet we just had it set to
49:01 - true while we were debugging our
49:03 - application but now we need to set that
49:05 - equal to our environment variable so to
49:08 - change that let's go back to our
49:10 - settings dot py file here I'm going to
49:13 - scroll up to our debug now for our debug
49:17 - value here we have to do something a bit
49:20 - different so this has to be equal to a
49:23 - boolean of true or false but we can only
49:27 - get back strings from environment
49:29 - variables so instead I'm going to do a
49:31 - little trick to turn this into a boolean
49:34 - so if we use a conditional to test
49:37 - whether that environment variable is
49:39 - equal to the string of true then it will
49:41 - return a boolean of true or false so let
49:45 - me just do this and then I will explain
49:48 - what it's doing so within some
49:49 - parentheses here I'm gonna say OS dot
49:52 - environment and I'm going to get the
49:56 - environment variable and we called that
49:59 - debug value I'm pretty sure if I go back
50:02 - to my bash profile can check yeah that
50:04 - is debug value and that is set equal to
50:06 - the string of true so we'll say if that
50:10 - environment variable of debug value is
50:12 - equal to the string of true and if that
50:17 - debug value is equal to the string of
50:19 - true then this entire conditional is
50:21 - going to return true and that's what
50:24 - debug will be set to so basically debug
50:27 - is going to be equal to false if the
50:29 - debug value environment variable is
50:31 - anything but true so that'll work well
50:34 - so now if we wanted to push that last
50:36 - change then we could simply open up our
50:39 - terminal and do a git add dash a of all
50:43 - of our changes and do a git commit with
50:46 - a message here and I'll set that as a
50:49 - message of set debug value and now you
50:55 - can push that to Heroku by saying git
50:57 - push Heroku master and run through that
51:02 - ok so now we have our site deployed to
51:05 - Heroku now if you just want to have your
51:07 - site accessible and don't care about
51:09 - having that Heroku domain name then you
51:12 - could simply leave it like this and
51:13 - share that with anyone who you want to
51:16 - see your application now if you want a
51:19 - custom domain name then there is a bit
51:21 - more that we need to do but I believe
51:23 - I'll save that for a future video if
51:25 - anyone is interested in seeing how
51:27 - that's done so if that's something that
51:28 - you want to see then just let me know
51:30 - now there's also a lot more that we
51:31 - could learn about the Heroku platform
51:33 - itself and what all capabilities that
51:36 - are available to us so for example they
51:38 - have a great versioning system where
51:40 - it's easy to rollback if you ever make a
51:41 - mistake so for example let me just show
51:44 - a quick example here if I was to do
51:46 - Heroku and run the releases command then
51:50 - this will show us all of the deployments
51:54 - that we made in this video and all of
51:56 - these have a version associated with the
51:59 - deployment so we can see here that there
52:01 - is a V 16 at the top the 15 V 14 so if
52:05 - you pushed out a bad deployment and
52:07 - simply wanted to roll back to a stable
52:09 - version then all you would have to do in
52:12 - that case is so let me copy like V 15
52:15 - here I could simply say something like
52:17 - Heroku rollback and then paste in V 15
52:22 - so if I were to run that command which
52:24 - I'm not gonna do because I don't want to
52:27 - actually roll that back but that would
52:29 - take you back to that specific
52:31 - deployment automatically without any
52:33 - actual work on your end so I think that
52:35 - those are great features so if you're
52:37 - interested in learning more about Heroku
52:39 - then I would highly recommend going
52:41 - through their documentation to see what
52:42 - all you can do with their service ok so
52:44 - I think that is going to do it for this
52:47 - video hopefully now you have a good
52:49 - understanding for how you can push your
52:51 - Python application to Heroku but if
52:54 - anyone has any questions about what we
52:55 - covered in this video then feel free to
52:57 - ask in the comment section below and
52:58 - I'll do my best to answer those and if
53:00 - you enjoy these tutorials and would like
53:01 - to support them then there are several
53:03 - ways you can do that the easiest ways to
53:04 - simply like the video and give it a
53:06 - thumbs up and also it's a huge help to
53:07 - share these videos with anyone who you
53:09 - think would find them useful and if you
53:10 - have the means you can contribute
53:11 - through patreon and there's a link to
53:13 - that page in the description section
53:14 - below be sure to subscribe for future
53:16 - videos and thank you all for watching
53:28 - you

Cleaned transcript:

hey there how's it going everybody in this video we're gonna learn how to deploy our django application using Heroku so that anyone with internet access can use it within a browser so so far we've created this application with some good functionality but the site still only lives on our local machine so right now I have this running in my browser on my local machine but no one else can access this so the point of building these sites and applications is to deploy them so that they're accessible over the Internet so in this video we're going to use Heroku to deploy our application now if you don't know what Heroku is it's a platform that allows us to easily deploy and host applications without going through the headache of setting up everything on our own manually so if you watch my video on how to deploy to a Linux server then you would have noticed that that took a lot of time and also requires you to be familiar with a little bit of system administration and things like that in order to get your application up and running Heroku abstracts a lot of that away and allows us to get our application deployed more easily without needing to set up our own web servers and firewalls and stuff like that and they also have a free tier that you can use so that you can actually get your application deployed without paying any money and then if you need to add any features that aren't being included for free then you can simply scale up however you need now one thing that I should mention about Heroku is that they don't have a normal file system like we're used to it will hold our static files and things like that but if we store a bunch of images or user uploads then those are actually going to be deleted so if you're saving images or files from your users then you'll need to use a service through something like Amazon Web Services in s3 buckets so if you're following along with this series then we already saw how to get that set up in our last video okay so with that said let's go ahead and get started so first you're going to need to create a Heroku account this is pretty straightforward you're just going to want to go to their website and create an account just like you would on any other site so I've already gone and signed up for an account through them but if you hasn't haven't then you can just go to sign up and fill in all your information and just register like you would with any other site now once you've created an count we also have a few prerequisites that we need to set up so first we're going to need to use get version control now using git and version control is considered a best practice by just about any programmer out there so I think it's great that this is how Heroku does its deployments because it basically steers you towards best practices so installing git is also very straightforward so I'll open up the git download page here now most of you likely already have git installed so I'm not going to go into that here but if for some reason you don't have git installed then I'll leave a link in the description section below to this download page that I have pulled up here so that you can download git for whichever operating system you are using now another thing that you're going to want to do once you have a Heroku account is you're going to want to install the Heroku commandline interface which is the Heroku CLI for short the Heroku CLI is going to allow us to deploy our application from our command line using some Heroku specific commands so this page that I have opened here will give you instructions for how to download this for a Mac Windows or Linux and again I'll have a link to this page in the description section below as well so that you can download the CLI for whichever operating system you're using I'm on a Mac so that's the option that I chose but I've already downloaded and installed this and once you have that CLI installed let's open up our command line and see if that worked so I'm going to open up my command line here and you're just went going to test this by simply typing in Heroku so I'll type in Heroku and run that and if our installation of the Heroku CLI worked then it should list out a list of commands that we can use to interact with our account now the first thing that we'll need to do is log in through the command line so that we're validated to run these commands on our account so to do this I'm just going to scroll down actually I'll just clear my page here by the way by typing in Heroku you can see all of the commands that we can use here but I will clear the page now to login I'm going to say Heroku login and I'll run that and you can see it says press any key to open up the browser to log in or press Q to exit so I'm going to press any key and it's going to open up a browser and asked me to login to Heroku so from here you can login to your Heroku account so I'm going to go ahead and do that okay so now it says we're logged in and that we can close this page and return to our CLI and that it should now be logged in so now I should be authenticated so once you're authenticated then we can continue with our deployment so there are a few things that we want to do within our project before we deploy so I'm going to pull back up my terminal here and I've already navigated to my project directory and you're going to want to do the same mine is located on my desktop and it's called Jango Project but you can navigate to wherever yours is located and once you're navigated to your project then we're going to want to create a requirements txt file now if you haven't created a requirements that txt file basically it is a file that holds all of the dependencies that we're using in our application now I'm using a virtual environment so all of my packages are specific to this project but if you aren't using a virtual environment then I'll link to the requirements that txt file that my app produces and I'll link to those in the description section below now you likely don't want to just use your systems Python dependencies because it could contain a lot of packages that aren't specific to your project and all of these are going to get installed on Heroku so it's best to keep it exclusive to what's actually needed for our application so first before we create our requirements txt file of our dependencies let's pip and install one more package that we're going to use when our application is deployed and that is G unicorn so I'm going to install that by saying pip install G unicorn so we will install that and once we have that installed now we want to create our requirements that txt file now the requirements file is also how Heroku knows that it's a Python application if you're using a setup PI file or a pip file then you can use those instead and it'll also recognize it as a Python application okay so now to make this requirements that txt file we can simply say let me clear this and first do something called a pip freeze if I run pip freeze then we can see that this lists out all of the PIP installations that we have currently made and these are what we want to add to a requirements txt file so if you're on Windows then you can just create a requirements txt file in your project and copy all of those copy all of the output output from pip freeze and just paste that into a requirements txt file if you are on Mac or Linux or using bash then we can simply say pip freeze and we can just pipe that into a requirements dot txt file and that'll create that file for us with the output of that pip freeze command okay so now we should have that requirements dot txt file in our project folder that has the output from that pip freeze command okay so another thing that we need to do here is to use git within our application so some of you may have already been using it for this but if not then I'll run through these steps real quick so it's extremely easy to do we just have to simply run the command to get an it to initialize and empty git repository so we ran that and we can see it says initialize empty git repository in our project folder so now we're using git version control within our application it's actually that easy in this video we're going to be using very simple git commands so you don't need to be extremely comfortable with using it in the command line but if you'd like to see an indepth explanation and walkthrough of how to use git then I do have a detailed video on that as well and I'll leave a link to that in the description section below if anyone is interested okay so now we're ready to tell git what files we want to actually track there are usually going to be certain files that we don't want get to track so for example anything that is specific to my machine or something like that we're going to want to ignore that now one resource that I use a lot for this is from github itself and it's a template of commonly ignored files for Python programs and actually have that open here in my browser let me close down this page and open this up so this is the Python get nor file here and we can see that it ignores files like pyc files and logs and stuff like that that kind of stuff you likely don't want to track with git it also has a django section if I scroll down here a bit we can see it has a django section here now we can see it ignores our DB sequel Lite file as well and that is our sequel Lite database and that's fine because we're actually not going to be using sequel Lite for our production database in development we've been using sequel Lite but for production we're going to set up a new Postgres database Postgres is the database of choice for a lot of different websites because of its you know features and performance so that's what we're going to be using and it's also what Heroku recommends and it's walkthroughs so I'm actually going to copy this template get ignore file from github and use that as a starting point for my get ignore file now one tip is that if you're ever copying something from github then you can just click on this raw link here towards the top right of the page and it will take you to just the text of the file so that it's easier to copy and paste so this is all of the text of that git ignore file so I'm going to just highlight all of that and copy and now I'm going to go back to my project and in my project I'm going to create a git ignore file so I'm going to go to a new file and this is actually going to be a dot file so it is dot get ignore so don't forget the dot before get ignore so I'm going to create that and open that up and I'm going to paste in what we got from github and then scroll up here to the top so we can see that it is ignoring a lot of these different files we have some unit test files in here and things like that so that's good now at the top of mine I'm also going to add something that gets added on Macs sometimes if you're on Windows then you don't have to do this but at the top I'm also going to add a section for Mac and I'm gonna add a file here that is dot d s underscore store and that's just an annoying file that gets created on Mac sometimes that we don't want to commit with our project as well so I'm going to add that to the get it ignore file okay so now that we have our get ignore file let's go back to the command line and commit all of our changes so far so I'm going to open up our terminal here and to do this we can simply say git add with a dash capital a and that's going to add all of the changes that we have so far so I'll run that and now if I do a git status then we can see that we have all of these new files now the reason our entire project is saying that it's new files is because we just initialized our git repository so all of these files are new to get none of them have been committed yet so now let's commit them to get so I can say git commit and then we can do a dash M here to set a message for this commit and I'm just gonna say initial commit and run that okay so now we've committed these files to get locally so now that we've committed these locally let's create an Heroku app where we can push this code so to do this we can simply use the Heroku command so let me clear the screen here so I can say whoops Heroku oh sorry about that Heroku create and now the name of our app so I've just called mine my awesome app and run that well and it looks like my awesome app is already taken as a name for a Heroku app so instead this might take some trial and error but let's see here I'll call this my Django app and try to create that that's already taken as well okay how about this we'll do my awesome Django app I doubt that is taken okay so that one worked okay so when that app is created it's actually going to create a domain for us as well and I can see that domain and the output of that create command you could so you can either copy and paste that into your browser or you can simply run Heroku open to open that in your browser so this is the URL here you can copy and paste that into a browser or let me clear my screen here or I can just say Heroku open and it will automatically open that URL in my browser so we can see here that our site is currently working but it's just using the default Heroku site for now now if that Heroku open command didn't work for you and it says that you're missing a require flag to specify what app you want to open then it's likely because you're not in your projects directory within your command line or possibly you did some of these steps out of order so for example if you create an app in a directory that isn't tracked by git then it might give you some issues and require you to set that stuff up in a different way but if you did everything in the order that we covered in this video then this should be working for you so we can see here that it gave us a domain of my awesome Jango app dot Heroku app comm and we currently have Heroku default site so we haven't actually deployed anything yet so now let's go ahead and do that so let's push our code to Heroku so if we go back to our command line then we can push that by saying git push Heroku master so if we run that then this is going to start pushing our code up to Heroku so we can see that it's going to do a lot of different things here so it's saying that a Python app is detected that it's installing Python installing pip and all of these different things so let me let's run through this installation here ok so if you just have a simple Python application then that might have worked for you and pushed that up to Heroku now ours didn't work because our application is a bit more complex and it ran into an issue while it was deploying now the good part is that if it runs into an error like this then your app just doesn't get deployed so it won't break your website if it runs into errors at this deployment section here so if we scroll up here a little bit then we should see a detailed traceback of exactly what went wrong now my text is a bit larger here so that you all can see so this is going to be a bit bunched together but I'll see if I can find the part where it ran into an error so we can see that the error happened when it ran this command Python managed PI collect static now if that's not obvious from this section here if I scroll down a little bit here then we can see that it gives a note here error while running Python managed dot pi collects static so what that command does is it collects our static files so that they can be served up in production so if you've been following along with this series then you might remember that at one point I mentioned that those static files would be handled differently in production so that's what this is so that's a command that Heroku runs for us so that it can automate that process but if I scroll down a bit to see what went wrong with that command or scroll up a little bit then we can see that it says here you're using the static files app without having set the static route setting to a file system path so that's telling us that we don't have this static route variable set to where our static files will be located on the file system so let's go ahead and set that in our settings so I'm going to open up our project here I'm going to close the get ignore file and now let me open the settings dot py file and once when you have that open I'm going to scroll down to the very bottom here and let me turn off the word wrap so that we can see this a bit better now I'm going to scroll up to where we have our static URL okay so now let's set our static route now the location that Heroku will put the static files for us when they run that command is going to be in a directory called static files so we will say and let me actually copy this media root because this is going to be very similar but instead of media root this is going to be static root and the location that Heroku is going to put these files is going to be called static files so I will put that there and save that okay so earlier our deployment failed because we didn't have the static root set so now we can try to commit our updates and deploy this again now I'm gonna tell you right now that it's still not going to work but the reason I'm showing you one step at a time like this is so that we can see the justification for each step instead of just ploughing through all of the changes that we need to make seeing it one step at a time like this might help you debug an applic in the future if you have an application that is different from what we've created here so let's commit these updates and try to redeploy so I'm going to open back up the command line here and let me clear my screen and now let's commit these updates and redeploy so first if we want to see what we changed I can say get status and we can see that we modified our settings dot py file and to add that to the files that we want to commit we can simply say git add a add all of the modified files and now we can commit that so I'll say git commit dash M for a message and I'll just say updated static root and I will commit that okay so now we have committed that locally and now let's actually push that up to Heroku and try to deploy that so I'm gonna say git push Heroku master so if I run that then it's going to run through and try to deploy this again okay so it looks like our deployment was successful and we don't have any errors when we tried to push our code so that's good but now let's try to open our application in the browser and again if I clear my screen we can do that with Heroku open so I'll run Heroku open to open our application in the browser and now let me make this a little larger here so that you all can read it so now it's telling us that we're getting an application error so this is different than getting an error during deployment so it gives us a hint here it says that if we're the owner of this application then we can run this command Heroku logs tale that command will allow us to see the latest logs of our application so I'm going to copy that command and let's go back to our terminal and run that so I'll pull up the terminal and I will paste that in Heroku logs tale now if you look through these logs then we can actually find a lot of interesting things and you can actually use the logging module from the Python standard library to log out different things wherever you want so if you want these logs to be even more detailed and then you can use that but what we want to look at here is the air that we're getting so we can see that the air that we're getting is right here at the bottom and it's running on two different lines here but we can see that the description of this air says that there are no web processes running so what's going on here is that we haven't told her Oh COO how we want to run our application so in order to do this we're going to need to create something called a proc file so I'm going to create this and explain along the way so in the root of our project directory I'm going to create that proc file so within our project directory I'm going to say new file and this is going to be called proc file so that's an uppercase P and then lowercase for the rest and that's PR OC f IL e so this proc file is going to be a simple text file now even though it's a text file be sure you don't create the file with a dot txt extension it should not have an extension so I'm going to create that file and then open that up now within this file we're going to create that web process that our logs said wasn't running so to do this we can simply say and I'm going to type this all out and then explain it later so I'll say web G unicorn make sure I spelled that right G unicorn and then Django underscore project dot WSGI okay so now let's look this over a piece by piece so web is the process type the name web is important here it declares that this process type will receive web traffic traffic when deployed now G unicorn is the command needed to run our web process if you don't know what that is it's basically a way for our Python code to talk to the web server and it's going to do that through our WSGI file so WSGI stands for web service gateway interface so G unicorn is the command and then we're specifying the location to the WSGI file in our application after that so Django project is my package and you'll want to have that be whatever your project directory is called so this right here should be the name the same name as the directory that holds your Settings dot py file so if you called that you know my awesome app or something like that then you want to put that here I called mine Django project and after we specify that package then we want to specify our WSGI file now we didn't make any changes to that WSGI file in this series but that file has a variable called application and g unicorn we'll use that to run our application for us okay so that's going to do it for our proc file now these files can contain additional process types so for example you know you might declare one for a background worker process that processes items off a queue or something like that but in this video we're only going to do the web process so I've saved that file and now let's commit those changes and see what we get in the browser and again I can tell you that this still isn't going to work but we'll go step by step so I'm going to re open our terminal here and I'll press ctrl C to quit those logs and now we can commit our changes so again if we want to see what changes we've made we can do a git status and we can see that we have a new file here proc file so I'll add that and say git add a to add all of our changes and now do a commit so get commit with a message of added proc file and now I'll clear the screen now let's push this up to Heroku so I'll say git push Heroku whoops Heroku master and run that okay so now we've pushed those changes up to Heroku now you might have noticed that your push to Heroku was faster there than it was before and that's because Roku will see that we've already installed all of the dependencies from the requirements file before and that there aren't any new ones so it'll just skip that step so that's a nice feature of Heroku ok so now let's open up our application and the browser again and again we can do that with just Heroku open so I will run that and open this up okay so now we can see that we're getting a different looking error here now you might recognize that this is actually the Django debug error screen so we have made some progress this is actually now using Django now one thing that should worry us here is that it's showing us so much information on this debug screen and that's why we should definitely turn off debug mode when working in production people could use this information to find vulnerabilities in our application and we definitely don't want that but while we have the debug output here we may as well see what it says so at the very top here it says invalid HTTP host header with this domain name here and then it says you may need to add this to our allowed host so since this is now deployed Django has some builtin security features where we need to explicitly specify the host that we're going to allow for our application and we're going to make this change in our settings dot py file so I'm just going to copy that host that it says that we need to add so that is right here mine is my awesome Django app dot Heroku app comm I'll copy that and now I'm going to add that to our settings dot py file so I'm going to open up our application go back to our settings dot py file and scroll up here to the top and if we scroll down a little bit we can see that we have this allowed host section here so I'm going to paste that in as a string so my awesome Django app dot Heroku app comm now we can also see here in our settings that we have debug equal to true now like I said before we're going to want to set debug equal to false in production but we shouldn't just set it equal to false because when we're on our local machine we actually want debug equal to true for testing so anytime you need a value that's specific to whichever machine you're on that is a good candidate for an environment variable so if you've been following along with this entire series then you should already have some experience setting environment variables since that's where we put our username and password for our email service and also our credentials for AWS s3 but if you don't know how to set environment variables then I actually have a separate video on how to do that for your operating system so I'll leave a link to that video in the description section below if you need to give that a watch so I'm actually going to set a debug environment variable here so that that can be different for our local machine and Heroku now while we're setting environment variables we should also move our secret key to an environment variable while we're at it so the secret key shouldn't be something that we put in our code potentially for other people to see so I'm going to create an environment variable for the secret key as well and I'm actually going to create a new secret key for our application since we've been using the current one for development so the new one that we create will be for production now there are a bunch of ways that we can generate a new secret key but the way that I like to do this is from the Python interpreter so I'm just going to open up my command line here and I'm going to run Python so I'm going to use Python here to generate a random key and you actually have to be running Python 3 in order to use this module so I'm gonna do this using a module called secrets and that is included in the Python 3 standard library so I'm gonna say import secrets and run that and that imported and now I'm gonna use a method called token hex to generate this and the more bytes that you pass in to that method the longer the random value will be so I'll say secrets dot token underscore hex and I'll just pass in a 24 for the bytes there and we can see that it generates this really long random string and that's about as long as our current secret key so I'm going to copy that and I'm gonna add that to my environment variables now since I'm on a Mac I can put these in my dot bash underscore profile file but like I said if you're on a different operating system and don't know how to create environment variables for your operating system then you can watch that other video that I mentioned just a bit ago that's linked in the description section below so I'm going to open my bash profile here so I'm going to exit out of the Python interpreter and open up my bash profile file in my home directory now I used a sublime command to open this up but if you don't have that sublime command set up on your system then you can just open that in whatever editor of your choice once we have that open let me turn off wordwrap here so that we can read this a little better once we have that open I'm going to set this secret key under this section here where we have our Django blog variables and you can see that we already have some environment variables here that we set for AWS in the last video okay so to set this secret key I'm just going to say export secret underscore key set that equal to that string that we just generated and now I'm also going to create an environment variable for our debug value so I'm going to say export debug underscore value and I'm going to set that equal to true since we're on our local machine and we want that debug value equal to true so that we can test our site now on Heroku we're going to set that environment variable equal to false since that'll be our production version now also notice here that our environment variable is a string of true and not just a simple boolean like we would see in Python and we'll see why that's important in just a second but we'll ignore it for now okay so now I have my environment variable set for my local machine so now let's set our environment variables for Heroku so let me save that before we exit out of it and I'm going to pull up my terminal to set these Heroku environment variables so I'm still within my project here within the command line now to add these environment variables to Heroku we can simply say Heroku config colon set and now we can set our environment variables so first I'm going to set a secret key and actually just to make sure I don't mess up any of the spelling here whoops let me go back to our bash profile and I'm just going to grab these from here and whoops copy those back into our terminal so Heroku config set and we'll set that secret key equal to that value and now also say Heroku config set go back to our environment variables here and set this debug value equal to true and if you've been following along with this series then you also need to set a few more environment variables so these will be the username and password for the email service that you set up in the reset password video and also the AWS credentials that we set up in the AWS s3 video so first I'll do the AWS credentials since we already have those pulled up here so I'm gonna copy this access key ID so again let me just rerun that Heroku config set and I will set that to the AWS access key ID that we used and again let me now do Heroku config set and set this equal to our AWS secret access key okay and lastly let me do Roku config set set this equal to our AWS Storage bucket name and paste that in got that set and now I'm going to do my email user and password for the email service so I'm going to say Heroku config set and first that was email underscore user and my email user is equal to Corey M Schaefer at gmail.com and for the password that was email underscore Paz now I'm not actually going to put my email password here for obvious reasons I don't want to broadcast that to everyone in a video but I'm going to pause the video and put in my password here in an environment variable to get the emails to work and then I will pick up the video after I have put that in okay so I pause the video and put in that email password as an environment variable and now picked it back up so now that we have all of those environment variables set now let's update our settings dot py file to use those environment variables that we just set so I'm going to go back to sublime and open up our settings dot py file so for our secret key here I'm just going to comment out the old secret key and now I'll set a new one here so I'll say secret key is equal to and to grab an environment variable we can say Oh s dot environed on git and we can get that environment variable and we just called that secret key as the environment variable as well so we can just grab that now for our debug value I'm going to leave this set to true just for a bit longer until we get this deployed and once it's working then I'll set it equal to false once everything is working properly okay so we've made some changes to our settings so now let's commit our changes and put those up to Heroku and see what we get so I'm gonna go back to the command line here and instead of running get status I'm just going to go ahead and add these you can run get status if you want to see what you've changed but I'll just add all of our changes and now I'll say git commit dash M for the message and we can say updated settings and now let's push that to Heroku so git push Heroku master and I'll run that okay so once we have that deployed let's take a look at our site so I'm going to say Heroku open to open that up in the browser okay so we're still getting an error this time the error says no such table blog post okay so remember we didn't push our SQL Lite database that we've been using in deployment because we're going to use Postgres in production so this is a little expected since we haven't created any tables in a Postgres database yet so first of all we're going to need Postgres installed on our machine to get this working so let me pull up Roku's documentation on this I I have this pulled up over here okay and again I'll have a link to all of these resources in the description section below so that you don't have to look around for this stuff so we can see that they give instructions for how to install Postgres for different operating systems so we have it to setup for mac and for windows and for linux now i already went through the installation for mac so you don't have to watch me do that but it's pretty straightforward just follow what they have listed step by step so once you have Postgres installed on your machine we're going to want to create a Postgres database on Heroku now it's possible that Heroku already created a database for us it does this for certain applications that have certain libraries so we can check that if I go back to the command line if I say Heroku addons and run that then we can see that we have a database for our app already but if you do need to create a database then instead if it didn't create one for you then you could say Heroku addons and create and then Heroku PostgreSQL let me spell it correctly and then and then you can put in the plan of database that you want the free version is Hobby dev so if you don't have a database already then you can run that now I'm not gonna run that since it already has a database for me here now like I said that hobby dev part is the plan and that is the free tier but if you ever need any more performance then you can always bump that up and we can see more about that if we were to run Heroku PG we can see there it shows us a bit more about that database so we can see that it has for the rows zero out of ten thousand so the free tier does have a ten thousand row limit okay so now that we have a Postgres database now we actually need to create tables for it so we also need to create a super user where we can login to our Django admin site so first things first we need to add the credentials to our settings dot py file so that our django application can talk to the database now instead of doing this manually we're going to use a helper function that that Heroku provides for us to do this and we can get that by running a pip install so here within our command line I'm going to do an installation of pip install janggu Django Heroku so I'll run that so that Django Heroku package is going to automatically configure our database URL and we'll also take care of connecting our static assets to G unicorn using a package called white noise so it's going to set up some stuff for logging and things like that I think this will even take care of a couple of things we already set up like our secret key and allowed host but I like setting those myself since I'm already in there anyways okay so the way that we get this to work is to open up our settings dot py file so let me open that up here and at the top of our file we want to import that module so I'm going to import Django underscore Heroku now I know that we installed that as Django Roku but when we import its Django underscore Heroku now at the very bottom of our settings file so let me scroll all the way to the bottom at the very bottom we're gonna say Django Heroku dot Settings and we are going to pass in locals and these need parentheses here at the end so like I said just by adding that in that's going to automatically set a lot of those configurations for us okay so now let's deploy this now one thing that you don't want to forget to do is update your requirements txt file so we've pip installed some packages so we want to make sure Heroku gets those changes so I'm gonna grab those pip frees dependencies again and update my requirements dot txt file so to do this on Mac I can simply say pip freeze and pipe those in to requirements dot txt again if you're on a Windows then you can just paste that pip freeze output into your requirements that txt file instead ok so again if you want to see the changes you can run a get status now mine says that I've modified my settings dot py and that I haven't modified my requirements dot txt file and I think that's just because I already had that one Django Heroku module installed already so that was already in that file ok so now to add those I'll say git add dash a and now I can commit those changes locally so get commit dash M with a message here and the message I will just say added janggu Heroku and now I can to push those changes to Heroku so I'll say git push Heroku master and let that run through the deployment again ok so that deployment is complete now I promised to y'all that we are about to have our application working but if we check it now then it should still give us some errors so let's see what those are so I'll say Heroku open and open up our page in the browser again and again it says relation and blog posts does not exist ok so we're still getting an error that our tables don't exist but we should be able to talk to the database now with Django so now we just need to run the commands that create the tables and while we're at it we'll also create a super user that has admin access now if you remember from the database video earlier in this series we can create our tables by running the manage py migrate command we shouldn't need to run make migrations because the migrations we already had should have been pushed up with our application so we only need to run migrate so how do we run that command on Heroku well there are two ways that we can do this we can if we want to run a command on Heroku then we can use Heroku run so for example let me go back to my terminal here and let me go ahead and clear the screen so if we want to run a command on Heroku we can say Heroku run and now I can specify any command that I want to run on the shell of our Heroku and that command will be run from the root of our application so I could simply say Heroku run Python managed py migrate so if I run that then it's going to run Python managed py migrate on our Heroku machine so that should have run our migrations for our application and created our tables and if we scroll up here we can see that it looks like that's what it did we have a bunch of green marks here that said everything went ok ok so now our tables should be created now while we're at it let's also create a super user that can login to the admin panel remember we're starting over with a new production database here so our old one that we used in development it no longer exists we have to also create this on Heroku now another way that we can run in commands on Heroku is to actually run a bash shell from Heroku itself so let me clear my screen here now the way to do this is we can simply say Heroku run bash and if I run Heroku run at bash then it should give me a bash shell to our Heroku machine okay so now we're connected to our Heroku machine and now we can run some commands since we'll actually be on the hokum of machine we won't need to prepend the command with Heroku run anymore now these roca machines are called dinos and they are a Linux system so you need to run Linux commands so for example if I run LS then it lists the files and directories of the current directory which is the root of our application so we can run commands from here as well so to create a super user we can simply say python managed dot py and create super user so if i run that then it's going to ask for a username and password and all of that good stuff so I will make my username core EMS and then the email address put in my email address and now I password I'll just put as testing 321 okay so our super user was created successfully and now to exit our Heroku manned machine we can simply type exit and now once it exits out of there we are now back on our local machine now that we're back on our local machine now let's try running our website again now that we should have created those tables and that super user so I'm gonna say Heroku open to open our website in the browser and now it actually looks like we're getting somewhere let me resize this here to be a little smaller so we can see our application is running here at my awesome django app roku app comm so this should be accessible to anyone on the internet at this point now there currently aren't any posts because we created a new Postgres database for production so let's test out some of the functionality of the site and see if everything is working so let's try to log in with that super user that we just created so the username there was cory ms the password was testing three two one so if i log in but it looks like we logged in because we can access our profile and stuff like that first let's go to the admin panel and see if our admin site is working and it is so that's good let me try logging out as this user and going back to our site up that's trying to log back into the admin site let's try to create a new user so i'll go to register for the new username I'll just say deployed user for the email I'll say D you at test comm password as testing three to one testing three to one signup okay looks like that user was created let's try to log in as that user okay and that seemed to work so now let's create some new posts here so my first post with the content of my first post and that seems to be working well we are getting our images from Amazon s3 like we set up in the last video so that is working well also let me create another post here and try to do some updates so I'll create a post here click on that go to update and say my updated second post that seems to work well let me try to delete that post okay and that's working well also that second post was deleted so we're just kind of going through here and making sure that all this functionality is working correctly now this is also why it's a good idea to have tests set up for your website so that you can just automate all of these tests because doing this manually every time you make some updates takes a long time as you can see but I'm gonna try to update a profile picture here so it looks like our profile picture updated successfully so that's good and lastly let's try to log out and see if it sends us an email if we click on forgot password if this looks like it sends us a reset password email okay and we can see an email has been sent with instructions to reset your password so that looks like it is working also and I actually just saw that email pop up on my phone so it does look like that email went through okay so all of that seems to be working great so now we've got our application deployed to Heroku now when you're working with django django has a deployment checklist on their website that you can look through to make sure that you did everything that you need to do when deploying applications so let me actually search for this so I will go to django deployment checklist and it should be the first result here okay so this deployment checklist it'll kind of tell you the things that you need to do so for example you know hiding your secret key setting debug equal to false so you're going to want to look through this deployment checklist and make sure that you did everything that you need to do when deploying applications and this actually reminds me so it's a good thing that we use this checklist actually reminds me that we didn't set debug equal to false yet we just had it set to true while we were debugging our application but now we need to set that equal to our environment variable so to change that let's go back to our settings dot py file here I'm going to scroll up to our debug now for our debug value here we have to do something a bit different so this has to be equal to a boolean of true or false but we can only get back strings from environment variables so instead I'm going to do a little trick to turn this into a boolean so if we use a conditional to test whether that environment variable is equal to the string of true then it will return a boolean of true or false so let me just do this and then I will explain what it's doing so within some parentheses here I'm gonna say OS dot environment and I'm going to get the environment variable and we called that debug value I'm pretty sure if I go back to my bash profile can check yeah that is debug value and that is set equal to the string of true so we'll say if that environment variable of debug value is equal to the string of true and if that debug value is equal to the string of true then this entire conditional is going to return true and that's what debug will be set to so basically debug is going to be equal to false if the debug value environment variable is anything but true so that'll work well so now if we wanted to push that last change then we could simply open up our terminal and do a git add dash a of all of our changes and do a git commit with a message here and I'll set that as a message of set debug value and now you can push that to Heroku by saying git push Heroku master and run through that ok so now we have our site deployed to Heroku now if you just want to have your site accessible and don't care about having that Heroku domain name then you could simply leave it like this and share that with anyone who you want to see your application now if you want a custom domain name then there is a bit more that we need to do but I believe I'll save that for a future video if anyone is interested in seeing how that's done so if that's something that you want to see then just let me know now there's also a lot more that we could learn about the Heroku platform itself and what all capabilities that are available to us so for example they have a great versioning system where it's easy to rollback if you ever make a mistake so for example let me just show a quick example here if I was to do Heroku and run the releases command then this will show us all of the deployments that we made in this video and all of these have a version associated with the deployment so we can see here that there is a V 16 at the top the 15 V 14 so if you pushed out a bad deployment and simply wanted to roll back to a stable version then all you would have to do in that case is so let me copy like V 15 here I could simply say something like Heroku rollback and then paste in V 15 so if I were to run that command which I'm not gonna do because I don't want to actually roll that back but that would take you back to that specific deployment automatically without any actual work on your end so I think that those are great features so if you're interested in learning more about Heroku then I would highly recommend going through their documentation to see what all you can do with their service ok so I think that is going to do it for this video hopefully now you have a good understanding for how you can push your Python application to Heroku but if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest ways to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you
