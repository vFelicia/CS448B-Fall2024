00:00 - hi everyone welcome to my channel my
00:02 - name is Salina I am a software engineer
00:05 - and I make programming and it related
00:08 - videos here on YouTube so if that is
00:10 - something that is of interest to you
00:11 - consider subscribing to my channel and
00:14 - this video is going to be allinone C++
00:17 - full course for beginners and the goal
00:20 - of this video is to take you from that
00:22 - place where you are struggling with
00:24 - programming where you don't understand
00:26 - how to read code or write code to a
00:29 - place where where you feel really
00:31 - comfortable writing code and reading
00:33 - code and you really understand what the
00:35 - code is doing because that is the most
00:37 - important part so this course consists
00:40 - of lectures where I will teach you a
00:42 - specific concept and then uh there will
00:45 - be a task and by solving that task you
00:48 - will get a good understanding of that
00:50 - specific concept and then the complexity
00:53 - of those tasks will gradually increase
00:56 - so that at the end of this video If you
00:58 - finish it you will have have a very good
01:01 - understanding of the most important
01:03 - programming Concepts not only in C++ but
01:06 - you will be able to take that knowledge
01:08 - with you to other programming languages
01:10 - as well and then uh at the end after you
01:13 - finish this course in the description I
01:15 - will leave directions for you on what
01:18 - should be your next step because I have
01:20 - created a road map with steps and
01:22 - directions so that if you follow those
01:25 - you will be able to build your
01:27 - programming knowledge to a very very
01:29 - high level
01:30 - but before we start I want to ask you
01:33 - one question and I feel extremely proud
01:36 - and happy that you decided to invest
01:38 - your time to learn programming and I can
01:40 - personally give you many reasons why
01:42 - that is a great decision but what I'm
01:44 - more interested in is what are your
01:46 - reasons why would you like to learn
01:49 - programming and be good at it is it
01:51 - because you are very creative person or
01:54 - you want to get a job and earn a lot of
01:56 - money or you want to gain those problem
01:58 - solving skills or because you think that
02:00 - programming is cool um so any other
02:03 - reason that you might have as well
02:05 - please write that in the comments down
02:06 - below and then uh make a public
02:09 - commitment before you start because that
02:11 - is something that will motivate you so
02:14 - um write I will learn programming
02:16 - because and then put your reason and
02:18 - hold yourself accountable so I am very
02:21 - much looking forward to reading your
02:24 - answer in the comments down below so
02:26 - without further Ado I will just roll the
02:28 - intro and let's start with the
02:31 - [Music]
02:41 - video hi guys very warm welcome to
02:44 - everyone watching this video and this
02:45 - video is going to be introduction to C++
02:48 - programming language and the first video
02:50 - of this course I was planning on
02:52 - dividing this video into two separate
02:54 - parts so that in the first part I'm
02:56 - going to explain some basic concepts
02:58 - some general concepts that are related
03:00 - to C++ and that you need to understand
03:03 - in my opinion first before starting to
03:05 - write code and then in the second part
03:07 - we are going to build our first C++
03:10 - program so I'm going to include in the
03:12 - description of this video a time stamp
03:14 - so that you can navigate yourself to the
03:16 - coding part if you want but if you're an
03:18 - absolute beginner I would recommend you
03:20 - to watch the entire
03:22 - video Let's explain a couple of Concepts
03:25 - before we actually start to write codes
03:27 - so that you are familiar with them you
03:29 - may wonder what kind of applications you
03:31 - can build with C++ well C++ is general
03:35 - purpose language that means that it can
03:37 - be used to build all type of
03:39 - applications so uh it is very close to
03:42 - the hardware and that means that it can
03:44 - manipulate resources easily so you can
03:47 - build operating systems if you want with
03:50 - it you can build compilers browsers uh
03:52 - demanding games so all general purpose
03:56 - software can be built with C++ uh it is
03:59 - not specific for only one domain but it
04:01 - can be used to solve and build different
04:04 - types of
04:05 - applications uh after that I would like
04:07 - to mention that C++ is compiled language
04:11 - that means that the code that you write
04:13 - first has to be compiled or uh converted
04:17 - translated into another language that is
04:20 - understandable to your machine to your
04:21 - computer so that phase is called
04:24 - compiling code or building code there
04:27 - are certain errors that can occur in
04:29 - this phase of course and those are
04:31 - compile time errors uh this type of
04:34 - Errors is usually the most common among
04:37 - beginners among people who are just
04:39 - starting to learn C++ and we are going
04:41 - to demonstrate some of those compile
04:43 - time errors when we start uh coding
04:46 - after that C++ is case sensitive
04:49 - language that means that uh C++
04:53 - distinguishes between lowercase and
04:55 - uppercase letters so if you have for
04:57 - example a variable all up uppercase
05:00 - and then a variable all lowercase so the
05:03 - same meaning the same word those two are
05:05 - going to be treated and and understood
05:08 - differently as different variables uh by
05:11 - C++ so it is case sensitive
05:14 - language why C++ was created another
05:18 - question because before it there were
05:20 - other programming languages uh well yes
05:23 - they were uh and it was created in
05:26 - 1980s uh and it was created with two
05:29 - programming languages in mind one of
05:31 - those two was simula uh and the other
05:33 - one was C so simula at the time was
05:36 - great language for human way of
05:39 - understanding and representing things so
05:41 - it was very understandable and easy to
05:44 - use to humans but at the same time it
05:46 - was very very slow so uh they decided to
05:50 - combine it with another programming
05:51 - language a fast one and at that time the
05:55 - best choice for that was C programming
05:57 - language so they combined did the two
06:00 - and they got C++ uh C++ is very very uh
06:05 - understandable language very easy to use
06:07 - by humans so you can build and maintain
06:10 - uh huge projects with C++ uh but at the
06:14 - same time because of this C part uh it
06:17 - is uh very close to the hardware so uh
06:20 - demanding tasks can be executed fast uh
06:24 - and also well since since it was created
06:26 - uh from C programming language you can
06:29 - say that any valid uh C program is
06:31 - actually valid C++ program so if you've
06:34 - ever built a c program you have actually
06:36 - built a C++ program
06:39 - already as I have already said the code
06:42 - that you write is not directly
06:45 - understandable to your machine so first
06:47 - it has to be converted into another
06:49 - language that is understandable to your
06:50 - computer but the one the language that
06:52 - is understandable to you is called
06:54 - source code I am going to put here an
06:56 - example of source code uh and I'm also
06:59 - one wondering at this moment what do you
07:02 - think that this code does so before we
07:04 - started any programming any coding at
07:06 - all what do you think that the result of
07:09 - this program is going to be so just to
07:11 - check how understandable C++ really is
07:14 - even for someone who has not have a lot
07:17 - of experience in coding so write in the
07:20 - comments of the video what you think
07:22 - that this code is going to do and I'm
07:25 - going to check those so at the same time
07:27 - you're going to be doing uh something
07:29 - called writing pseudo code which means
07:32 - describing what a program does but just
07:34 - in plain English so no
07:37 - C++ so this is uh the source code after
07:42 - that that source code is transferred or
07:46 - uh translated into another form another
07:48 - language which is understandable to your
07:50 - computer and that is object code that
07:53 - object code is usually in the form of
07:56 - binary numbers so ones and zeros and
07:59 - that is the only language that your
08:01 - computer actually understand and this is
08:04 - an example of your uh machine
08:07 - language I'm also not going to ask
08:10 - anyone to describe what this here does
08:12 - because this is highly unreadable and
08:15 - cannot be understood by humans but uh as
08:17 - I said it is the only language that your
08:20 - machine
08:22 - understands so algorithm what is
08:25 - algorithm algorithm is nothing more than
08:27 - a recipe so steps instructions that you
08:31 - write to your
08:32 - computer list of ingredients and and
08:35 - steps that your computer needs to do in
08:37 - order to perform a certain task that's
08:40 - algorithm now that we have understood
08:43 - these Concepts let's switch to more
08:45 - practical part so the tool that we are
08:47 - going to use is called Visual Studio
08:50 - 2019 and there is a lot of tutorials on
08:53 - YouTube on how you can download and
08:55 - install the visual studio and you can
08:58 - also use Community version for free so
09:01 - uh when we open Visual
09:05 - Studio you can see that here in this
09:08 - left part we have our recent projects uh
09:11 - so the project that that I have recently
09:13 - created and this may be empty if you
09:16 - haven't used your visual
09:18 - studio so on the other side there is a
09:21 - menu with multiple options you have uh
09:24 - the option to check out your code from
09:26 - GitHub here you can open existing
09:28 - project from your computer uh and
09:31 - continue working on that but the option
09:34 - that we are going to use is called
09:36 - create new project so we are going to
09:39 - click
09:40 - that so this new window now here appears
09:45 - and we are going to Define what kind of
09:47 - project we want as beginners we are
09:49 - going to build a very simple app so we
09:52 - are going to build a C++ console
09:55 - application so you can type in a C++
09:59 - and make sure to select C++ console
10:03 - application so not c not Visual Basic
10:07 - but C++ and when you clicked it you can
10:12 - now uh click uh when you selected it you
10:14 - can now click next
10:16 - so this new window uh
10:21 - now we get a new window uh where we have
10:24 - to Define our project name location
10:27 - where our project is going to be saved
10:29 - and and our solution name as default our
10:32 - solution is named the same as our
10:34 - project what solution is is just
10:36 - actually a group of project so if you
10:37 - had a huge application and you wanted to
10:40 - divide it in smaller parts so that it is
10:42 - easier to maintain you could divide it
10:45 - in multiple projects but all of those
10:47 - projects would be part of the same
10:49 - solution so as we are since we are
10:52 - building a simple app we have only one
10:55 - project and we will name it my first app
10:58 - so my
11:01 - my first app and location for our
11:05 - project we can either enter manually or
11:07 - we can do it by clicking this button
11:11 - here and I want my f files to be saved
11:15 - on desktop so I'm going to select uh
11:19 - desktop and now we are done with uh with
11:22 - creating our project so uh with
11:25 - configuring our project so we can click
11:27 - uh create
11:31 - so the tool that we are going to use uh
11:34 - Visual Studio is an IDE or integrated
11:37 - development environment that means that
11:40 - it has a lot more options than just
11:42 - those that we as beginners are going to
11:44 - need and use so for now I'm going to
11:47 - explain only the most basic ones the
11:50 - ones that we are going to need as
11:52 - beginners but as we progress along the
11:55 - way I'm going to explain the new
11:57 - features that we'll use so
11:59 - so the first thing that you can see here
12:03 - is our solution
12:05 - Explorer so uh if you cannot see your
12:07 - solution Explorer you can click here to
12:10 - this View and select solution Explorer
12:15 - and that should bring your solution
12:17 - Explorer back to view so as we said our
12:21 - solution Explorer is named my first app
12:24 - and it has one project inside it so this
12:28 - this this project is this one here and
12:32 - as you can see when we created our
12:33 - project it was created with some default
12:36 - folders and files for now we are going
12:39 - to use only one file so you can delete
12:42 - these folders header files and resource
12:44 - files if you want just click right click
12:48 - and click
12:51 - delete so now this source files folder
12:55 - is where we are going to put our source
12:58 - code files if you remember from before I
13:00 - have said that uh source code is the
13:03 - code that we write and that is
13:05 - understandable to us so this is our
13:08 - source code file so this with CPP
13:12 - extension so when we created our project
13:15 - this file was created by default and if
13:19 - you double click it it opens uh here so
13:25 - this part here is nothing more than a
13:26 - than a text editor really as any text
13:29 - editor it just has these uh different
13:32 - colors depending on the
13:34 - purpose or the role of the code so that
13:38 - you can manage the code easier if it
13:39 - were all the same color it would be
13:41 - harder to uh to read so for example this
13:44 - green part here is a comment comment is
13:48 - just a note for
13:50 - yourself
13:52 - so compiler will not try to translate
13:55 - commented
13:56 - lines so if if you type for example here
14:02 - this slash slash
14:06 - or that means actually begin
14:09 - comment and then you can explain for
14:11 - example what this preceding code does so
14:14 - you can write this will output to the
14:21 - console hello
14:24 - world so this will output to the console
14:27 - hello world so that when you for example
14:30 - come tomorrow to this code and you have
14:32 - forgotten what this code here does this
14:34 - will remind you this comment here and
14:38 - these are some default comments which I
14:40 - will delete now we are not going to uh
14:43 - need this so just select everything and
14:46 - click delete as you would in any regular
14:48 - text editor this part here
14:52 - also now let's explain what we got here
14:56 - so this include iio stream is actually a
15:01 - header file so it is also called a
15:04 - library and this um I stream is input
15:08 - output Stream So it allows our uh us to
15:11 - input and output data to and from our
15:14 - program for example thanks to this we
15:17 - can use commands such as this here so
15:19 - see
15:20 - out or console output so without having
15:25 - this we would actually have to program
15:28 - ourselves how
15:29 - we will input and output data in uh our
15:33 - in our
15:34 - console so we will not delete this line
15:36 - here now check this code here it says
15:40 - main well that means that this is our
15:42 - main function so a main procedure that
15:45 - our program is going to execute so
15:50 - whenever whatever you put actually in uh
15:53 - these braces here your program will
15:56 - execute and the execution of your
15:57 - program begins here and it ends here so
16:02 - since this here is the the scope of your
16:05 - main function so you can collapse it by
16:07 - clicking
16:08 - here and you see that everything is
16:11 - collapsed now so for now it's enough for
16:13 - you to know that this is our main method
16:16 - our main procedure and later in this
16:18 - course we are going to uh learn and
16:21 - understand what methods are used for
16:23 - what is their purpose and we are also
16:26 - going to create a lot of Our Own
16:29 - methods so now we have this uh C out or
16:34 - console output which is the command to
16:37 - Output to the console and then we have
16:41 - also combined with this um STD and these
16:46 - redirection signs so STD is the Nam
16:50 - space for this C out so that's how your
16:54 - computer knows what this SE out really
16:56 - is I will show you later how you can get
16:58 - rid of this if you really
17:00 - want and we also have this hello world
17:04 - in uh quotation
17:06 - marks okay let's see what we have
17:08 - learned so far we said that this is our
17:11 - solution it inside it has one project
17:14 - and within that project we have this
17:16 - file with uh with extension. CPP which
17:21 - is our source code so if we double click
17:25 - this file it brings us here so to this
17:29 - text
17:30 - editor and this is our program this is
17:32 - the code of our program now how we can
17:35 - run this code well see this green play
17:39 - button here well that's our start button
17:42 - it's really uh it's really intuitive so
17:46 - if I click
17:47 - it we will get our hello world text here
17:51 - which I have outputed to the console uh
17:55 - and you can also see that we we have
17:57 - besides our hello world we have gotten
17:59 - some junk text here so what I'm going to
18:02 - do is show you how you can get rid of
18:06 - this in a moment so let's close our
18:09 - program for a moment and what you need
18:13 - to do in order to get rid of this junk
18:16 - text is type this command here so system
18:25 - pause greater than zero in quotation
18:28 - mark
18:29 - and the end of command you notice that
18:33 - at each of uh at the end of each command
18:36 - uh you have to put this semic column and
18:40 - if you didn't it would result in an
18:42 - compiler error and I will demonstrate
18:44 - that let's run our program now and you
18:48 - will see that our junk text has
18:51 - disappeared so as I said after each
18:54 - command you have to put this semic
18:57 - column and if you if you didn't do that
18:59 - it would create a syntatic error and
19:02 - that then your your compiler would not
19:04 - be able to understand and your program
19:07 - would not run actually your program
19:09 - would not start so if I delete this
19:12 - semicolon
19:14 - here you see that something has changed
19:16 - in this in this window here so you see
19:20 - this R error error red sign um well if I
19:24 - hover over it you see you see it here
19:28 - also here here uh it
19:30 - says expected a semicolon which is very
19:34 - clearly says that you are missing a
19:37 - semicolon and if you see this red
19:40 - underline here it says also expected a
19:43 - semic colum so uh before this you are
19:46 - missing a semic column here so if I add
19:51 - it
19:52 - here if I add it here our error will
19:55 - disappear so if you try to run your
19:57 - program before fixing this
19:59 - error it would prompt you with with a
20:04 - window like this
20:06 - so it
20:08 - says you have one failed project and
20:12 - zero succeeded projects so this is the
20:14 - code building that I have mentioned
20:17 - before so this one project which is
20:21 - actually the only project that we have
20:22 - has failed building so your compiler
20:25 - does not actually understand what you
20:26 - have written since you are missing a
20:28 - semi uh column so another thing how you
20:31 - could know that you have syntax error uh
20:34 - except from this uh this prompt window
20:36 - that we got is this uh syntax error so
20:40 - missing semic column before this closed
20:43 - brace and if you click it here it will
20:46 - take you right where you need to go to
20:47 - fix your error so it's it's very
20:51 - useful
20:53 - and if I press my play button again it
20:57 - now says hello
21:00 - world so I will stop program now uh you
21:06 - can do it either by clicking this red
21:07 - sign here which says stop debugging or
21:11 - you can click this X on the console
21:13 - window so if some other error has
21:16 - happened to you which didn't happen to
21:18 - me here you can write that in the
21:20 - comments down below and I will gladly
21:21 - help you also someone else can help you
21:25 - from uh from the other people learning
21:27 - from this video and I would highly
21:29 - encourage that since in my opinion the
21:32 - best way to learn something is to try to
21:35 - reproduce what you've learned and to
21:36 - explain it to someone
21:39 - else so write in the comments if you got
21:42 - some other error now let's see how we
21:45 - can upgrade our program so let's write
21:47 - something
21:50 - else let's add for
21:53 - example STD two column
21:57 - signs console out so uh under quotation
22:00 - marks I will put something that I want
22:04 - to write out so let's say for example my
22:07 - name is
22:10 - Salina you can put your name of course
22:13 - and at the end of each command you put
22:16 - semicolon and let's add one more
22:20 - so let's say today is
22:26 - Friday and also add
22:29 - end of command here
22:31 - so it should write when we run our
22:33 - program it should write these sentences
22:35 - in uh this order here so you can run
22:37 - your
22:39 - program and if you can notice it has
22:43 - this new line in the first sentence so
22:45 - this is because of this this back slash
22:49 - n so that puts whatever text is coming
22:52 - after in a new line so you can put uh
22:56 - that text in a new line by either
22:58 - entering a back sln or with adding
23:04 - this STD end
23:07 - line so STD end
23:10 - line and I have previously stopped my
23:13 - program if I run it again you see that
23:18 - that we have gotten a new line here you
23:21 - see also that this um STD here is
23:25 - becoming a bit tedious to write again
23:27 - and again and I've told you that I'm
23:29 - going to show you how you can get rid of
23:31 - this uh so what you can do is you can uh
23:34 - put this STD on a global level so you
23:37 - can
23:38 - say using using namespace STD using
23:43 - namespace STD and what will that do is
23:46 - reference this STD namespace on a global
23:50 - level so you don't have to uh reference
23:53 - it every time that you are using it and
23:56 - now we can delete all of these so
23:59 - wherever you have written
24:01 - STD that's going to be referenced here
24:03 - now and you don't need it need to write
24:05 - it
24:06 - separately and if we run our program uh
24:09 - here we are going to get uh our
24:14 - result so we have also uh this new line
24:18 - added by either sln
24:21 - or this end line
24:24 - here okay so in this video we have
24:28 - learned how we can output data in a
24:31 - console and in the next video we are
24:33 - going to see how we can input data into
24:36 - our uh console so we can ask user to
24:38 - input data and we are also going to talk
24:41 - about variables and data types another
24:45 - thing that I want to show you before I
24:46 - finish this video is you may be
24:50 - wondering okay do I have to start Visual
24:53 - Studio every time that I want to run my
24:55 - program is there any other way for me to
24:59 - to execute my program uh and uh the
25:02 - answer is no you don't have to start
25:04 - Visual Studio every time there is
25:07 - another way to start your program for
25:09 - for w from
25:10 - Windows so let's save all changes that
25:14 - we have made here so far so you can
25:17 - press control+ s or um if you have made
25:20 - any changes you see this star here so it
25:24 - is indicating indicating that you have
25:26 - unsaved changes so you can right click
25:29 - on that and click
25:32 - save and you see that that start
25:34 - disappears now
25:36 - so let's find a folder where we have
25:39 - created our project for me that was
25:42 - desktop uh if you follow this tutorial
25:44 - from the beginning you created it also
25:46 - and if you follow me you created it also
25:48 - on desktop uh so you can open your
25:53 - folder you can uh go to debug and inside
25:57 - that you uh see this file here it says
26:01 - application so this is your program so
26:05 - uh if you right click on
26:08 - that and you check its properties you
26:11 - will see that it says exe that means
26:14 - that it is executable file so that is
26:17 - your program that is your um application
26:20 - and if you double click on that well you
26:24 - see that it runs same as in visual
26:26 - studio so
26:28 - you can start your program from Windows
26:30 - actually if you want to show it to your
26:32 - friends or someone else you don't have
26:33 - to you don't have to open Visual Studio
26:36 - each time that you want to uh to run
26:38 - your program but one more thing to keep
26:41 - in mind is that if I go to visual studio
26:45 - now and I add one more line let's
26:49 - say let's say we write out have a nice
26:55 - day so and and if I save it so contrl
27:01 - s and if I try to open my program from
27:03 - Windows
27:05 - now what you'll see now is that this new
27:09 - line that I have just added is missing
27:12 - but why is that so you know well um if
27:16 - you remember when we were talking about
27:18 - building code we said that that's the
27:21 - phase of uh converting source code that
27:23 - you have written into a code that your
27:26 - machine understands and when you start
27:28 - your code from Visual Studio it does
27:31 - that process automatically for you so it
27:33 - builds your code and then it executes
27:36 - your your program but when you are
27:38 - starting your uh program from uh Windows
27:41 - it is missing that phase of building
27:44 - code so your uh recent changes your last
27:48 - changes were not
27:50 - translated so your uh computer has only
27:54 - the only translated version that it has
27:56 - is the previous one so without about
27:58 - your uh recently added changes what you
28:00 - need to do is you either have to run uh
28:03 - your code from Visual Studio first or
28:06 - it's enough for you just to build that
28:08 - code inside visual studio and what
28:11 - happens when you do that so just click
28:16 - here
28:18 - and you can click
28:21 - build and what happens is your Visual
28:25 - Studio translates this code that you
28:27 - have written
28:28 - and it saves
28:30 - it here and now when you run it and when
28:34 - your windows runs it it has uh the the
28:36 - latest version it has the latest
28:39 - changes so this is the small trick that
28:42 - I wanted to uh show
28:47 - you so uh this will be all for this
28:50 - video and uh if you came across to some
28:53 - errors that didn't happen here to me or
28:56 - you have any questions you can write
28:58 - those in the comments and I will I will
29:01 - answer those and if you watched so far
29:04 - you can like this video you can
29:05 - subscribe and share it with someone else
29:07 - who would also like to learn programming
29:09 - and I will see you in the next
29:12 - video hi guys I hope you are all well
29:15 - and welcome to the second video of C++
29:17 - for beginners in this video we are going
29:19 - to talk about variables data types and
29:23 - also I'm going to explain how you can
29:25 - enter data in your program and how that
29:27 - data is encoded into numbers using
29:30 - something called asky table so here I
29:34 - have opened visual studio and if you are
29:36 - not familiar with Visual Studio or there
29:39 - is some code that you see here but you
29:41 - don't understand it I would recommend
29:43 - you to watch my first video of this
29:45 - course the link is going to be in the
29:47 - description of this video and then come
29:49 - back to this video so let's talk about
29:53 - variables now what is variable well I
29:57 - like to explain it a real life example
29:59 - for
30:00 - example you see this glass here well
30:03 - what I can say about this glass is that
30:06 - it is a container for a certain type of
30:08 - liquid so it can hold water milk tea
30:13 - juice whatever you want really and the
30:15 - same way a variable is a container but
30:18 - for a certain data type so you can put
30:21 - whole number inside it you can put
30:23 - character or a decimal point number or a
30:26 - Boolean value meaning true or false
30:28 - value so they are the same in this
30:31 - aspect another thing that I can say
30:35 - about this glass is that it defines a
30:38 - maximum amount of liquid that it can
30:40 - hold so it has a max limit and if you
30:44 - put too much it will overflow the same
30:47 - way with variables variables also Define
30:50 - a maximum amount of data that they can
30:52 - hold for example if you have a whole
30:55 - number variable well there is a Max
30:58 - number limit for that variable that it
31:00 - can hold and also if you put too much it
31:03 - is going to overflow it is literally
31:05 - called data type overflow
31:10 - so it is a container the same as
31:12 - variable and also it defines a maximum
31:15 - amount of data that it can hold but how
31:17 - much data you really put inside that
31:20 - variable so the same way with with the
31:23 - water inside this glass if you decide to
31:25 - put 1/3 or 1/2 or 2/3 of this glass the
31:29 - same way is with variables you can put
31:32 - however much you want as long as you
31:34 - don't put too much because then it's
31:36 - going to
31:38 - overflow one thing that is different
31:40 - though between variables and this glass
31:43 - is that you can put one day inside this
31:46 - glass you can put water the next day you
31:48 - can put juice the next day you can put
31:50 - milk then tea or even you can mix two
31:53 - liquids but with variables you cannot do
31:55 - that at least not with Once in C Plus+
31:59 - there are certain languages that you can
32:01 - do that with and there is also
32:03 - advantages and disadvantages when it
32:05 - comes to that but in C++ you cannot put
32:09 - two different data types inside one
32:12 - variables and you can also not change a
32:15 - data type of variables once you create
32:18 - it so let me show you what I'm talking
32:20 - about on a practical example let's say
32:24 - that you want to create a variable that
32:26 - is going to hold your annual salary well
32:29 - that variable is definitely going to be
32:31 - a decimal point number or also floating
32:35 - Point number that's how it's called in
32:37 - C++ and the type that is used for that
32:41 - is called float so I'm going to say
32:46 - float and then I'm going to give a name
32:50 - to that variable since we said that is
32:53 - going to hold a annual salary we are
32:56 - going to call it annual
33:00 - salary
33:02 - okay and then we are going to assign it
33:05 - a value and that value is going to be
33:08 - let's say
33:11 - 50,000
33:13 - 99 so now what I have done here is I
33:16 - have created a variable called annual
33:18 - salary I have said that that variable is
33:21 - going to be of type floating Point
33:23 - number and then I have put inside that
33:26 - variable
33:30 - 5099 so now let's see how we can base on
33:35 - this variable based on our annual salary
33:38 - calculate how much our user is earning
33:41 - every month so what we are going to do
33:44 - is we are going to create another
33:46 - variable we are going to call it monthly
33:49 - salary and we are going to assign that
33:51 - variable a result of dividing this
33:54 - annual salary with 12 months so we are
33:58 - creating a variable of type float also
34:01 - since the result of division usually can
34:05 - be also floating Point number or decimal
34:09 - number and because of that we are using
34:11 - also float type for our monthly salary
34:18 - variable so I'm creating monthly salary
34:21 - variable and I'm going to say that that
34:24 - variable is going to hold result of this
34:28 - expression annual salary divided by 12
34:33 - months and now we have result of this
34:36 - division inside this variable and what
34:38 - we are left to do is to write that
34:41 - result out to our user so I'm going to
34:43 - say see out since that's the command
34:45 - that we use to Output data to console
34:48 - and I'm going to say your
34:52 - monthly salary
34:56 - is and I'm going to say monthly salary
35:02 - so one thing to notice here is that when
35:06 - you are writing out strings or when
35:10 - you're writing out data like this you
35:14 - use quotation marks but when you want to
35:17 - write out the value that you are holding
35:19 - inside a variable well then you just put
35:21 - the name of your variable you don't use
35:24 - any quotation marks then and now we can
35:27 - run our
35:28 - program and let's see what's the result
35:30 - that we got you see here your monthly
35:33 - salary is
35:35 - 4,166
35:37 - 75 so if you want to check that out you
35:39 - can uh you can calculate it in your
35:45 - calculator one thing that uh that
35:48 - bothers me in this program is that we
35:50 - have hardcoded this value here so we
35:52 - have hardcoded coded this 50,000 99 not
35:57 - every everyone's salary is 50,9 and what
36:00 - if we wanted our user to enter what his
36:03 - salary is during the execution of our of
36:06 - our program so when he runs our program
36:08 - our program should ask him what is your
36:10 - annual salary and then he enters that
36:12 - salary and then we calculate his monthly
36:16 - salary based on the number that he has
36:18 - entered so I would like to upgrade this
36:20 - program now to work like I just
36:23 - explained and how we are going to do
36:25 - that well first I'm going to delete
36:28 - these 50,000
36:30 - 99
36:32 - okay and then we are left with this
36:35 - situation here so it says float annual
36:39 - salary that means that I have just
36:42 - created a variable called annual salary
36:45 - and I have said I'm going to put a
36:47 - floating Point number inside that
36:49 - variable but I have not assigned any
36:52 - value to it yet so here we have a
36:55 - container for our annual salary and that
36:58 - container doesn't hold any value and if
37:01 - we try to run our program now what do
37:04 - you think that we are going to get write
37:06 - that in the comments before I run this
37:07 - program and now I'm going to uh so pause
37:11 - the video and think about it and then
37:13 - write write your answer in the comments
37:16 - and now I'm going to run the the
37:18 - program and you can see that we have
37:22 - some build errors as this here uh this
37:26 - window here says
37:28 - so let's see if we open this part here
37:34 - it says we have one error and that error
37:36 - is uninitialized local variable annual
37:39 - salary used what that means is that this
37:43 - exess expression here if you see this
37:45 - green
37:47 - underline It also says using
37:49 - uninitialized memory annual salary well
37:53 - that means that this expression here our
37:56 - computer doesn't know how to do this
37:58 - expression since we haven't assigned any
38:00 - value to our annual salary variable so
38:03 - it doesn't know how to divide that that
38:06 - with 12 since there is no value inside
38:08 - that container inside that variable so
38:11 - this causes a compiler error and whoever
38:14 - has written that compiler error is going
38:16 - to occure he was right so how we have to
38:21 - what we have to do to correct this is we
38:23 - have to ask our user to enter his
38:28 - uh annual salary so what we are going to
38:30 - do now is let's see First Command that
38:35 - we use to Output data from our program
38:38 - into our console is C out so console
38:41 - output and the command that we use to
38:43 - input data is console input or C in so
38:48 - I'm going to say C
38:49 - in and then we use these other
38:52 - redirection signs and then we say what
38:55 - is the variable that we want to store
38:57 - what our user has entered and I'm going
38:59 - to say annual salary so what I have said
39:02 - here is our user is going to console
39:05 - input the data and then whatever he has
39:08 - inputed you have to redirect that inside
39:12 - our annual salary variable so now if I
39:17 - run my program
39:19 - now you see that our program runs now so
39:23 - there is no compile time error and also
39:27 - our cursor is blinking well it is
39:30 - blinking because it expects here our
39:33 - user to enter annual salary but this is
39:36 - not really clear to someone who has not
39:38 - made this program so what we have to do
39:41 - if I enter some value now well it is
39:44 - going to calculate it correctly but this
39:46 - is not really user friendly so what we
39:48 - have to do is we have to write a message
39:52 - to our user before he enters anything so
39:55 - that he knows what he should enter so
39:57 - before this C in command I'm going to
40:00 - say C
40:02 - out and I'm going to say
40:06 - please enter your
40:10 - annual
40:12 - salary
40:13 - okay and
40:15 - now if I run my
40:18 - program you are going to see please
40:21 - enter your annual salary and the cursor
40:24 - is blinking waiting for you to enter the
40:26 - value and if I I say for example
40:30 - 40,000 you see that your monthly salary
40:33 - is
40:35 - 33333 so the program has calculated your
40:39 - monthly salary and the number is based
40:43 - on whatever our user decides to
40:46 - input so we have upgraded our program
40:49 - and there is also one more thing that I
40:51 - would like to show you when we are doing
40:54 - this example and that is
40:57 - let's say that we want to calculate how
40:59 - much money our user is going to earn in
41:03 - 10 years so let's say see
41:07 - out in 10
41:10 - years you will
41:14 - earn and now we have to put a value of
41:19 - how much money he is going to earn and
41:22 - if you look at this situation here we
41:25 - first created our monthly salary
41:28 - variable and we then assigned it a value
41:31 - of annual salary divided by 12 but there
41:34 - is another way that we can write out
41:36 - results of Expressions without creating
41:39 - any variables if that is what we need
41:43 - and that is just here so in this line in
41:46 - 10 years you will earn you add these
41:48 - redirection signs and then you say
41:50 - expression that you want your computer
41:52 - to calculate and what we want to
41:54 - calculate is how how much our user is
41:56 - going to earn in 10 years so that is
41:59 - annual
42:01 - salary times
42:05 - 10 and if you do it this way so if you
42:09 - don't decide to create a variable then
42:12 - you will not be able to use result of
42:15 - this expression later in your program so
42:17 - you don't have a container that holds
42:20 - this 10 year salary but you have a
42:23 - container that holds annual salary and
42:25 - monthly salary so each time that you
42:27 - want to to write out or do something
42:30 - with your 10year salary you will have to
42:34 - write this expression while if you want
42:36 - to do something with your monthly salary
42:38 - you have a container that is holding
42:40 - that value directly for you and you can
42:42 - access it so if we run our program
42:45 - now you
42:47 - see it expects us to enter our annual
42:52 - salary let's say
42:54 - 50,000 and you see here your monthly
42:57 - salary is
43:00 - 4,166 67 and then in 10 years you will
43:04 - earn what is this half a million
43:07 - so okay one thing that we are missing
43:10 - here then and that you can add is end
43:14 - line or back slash end so you can add it
43:17 - here and your program is going to format
43:21 - your text nicely so this line should go
43:25 - here like this if I if I add here one
43:30 - more end
43:32 - line and if I run my program
43:37 - again you see enter 50,000 and now we
43:42 - have our text formatted nicely because
43:46 - of this end line that I have just
43:48 - added let's now create another variable
43:52 - and this time we are going to create a
43:53 - variable of type character so
43:58 - Char that is the type that is used for
44:01 - character variables in C++ it's called
44:03 - Char and let's name our
44:06 - variable character and when you want to
44:09 - assign a value to a character variable
44:11 - in C++ what you use is these single
44:15 - quotes like
44:18 - this if you see this example here when
44:21 - we are writing out text so string of
44:24 - text we use these double quotation marks
44:26 - but when we want to assign a character
44:29 - value of a character variable we use
44:32 - these single quotations like here and
44:36 - there are also some more rules when it
44:38 - comes to naming your variables and the
44:40 - most important one in my opinion and the
44:43 - most important one to make it easier to
44:45 - you is to name your variables according
44:48 - to their purpose so give meaningful
44:50 - names to your variables that is really
44:52 - really important for example you see
44:55 - this uh monthly salary variable here we
44:57 - could have as well named this variable
45:00 - blah blah blah and copy it here also
45:04 - because we are having compiler error
45:05 - right now because our compiler does not
45:08 - know what this variable really is you
45:10 - see it says identifier is undefined
45:14 - because you have not created this
45:16 - variable here because it supposes that
45:19 - it is a variable but it has not been
45:22 - created before so it does not recognize
45:25 - what this variable is so we have to copy
45:28 - the new name here also and now our
45:31 - compile time error
45:33 - disappears and this here this name does
45:37 - not represent anything to your computer
45:39 - so your computer is now going to run
45:41 - your program and your program is going
45:43 - to work just the same as it did before
45:46 - but this is really making it hard for
45:48 - you to understand what your code is
45:50 - doing and especially if you come to this
45:53 - for example in 10 days or someone else
45:55 - tries to understand your PR program this
45:58 - is really hard to read and he will just
46:02 - try to uncover really what your program
46:04 - is doing without understanding it
46:07 - because you have used these blah blah
46:09 - blah names for your variables the same
46:11 - situation would be if you for example
46:13 - have three boxes inside your kitchen and
46:16 - you you use one for storing sugar and
46:19 - flour and salt and instead of naming
46:22 - those sugar flour salt respectively you
46:25 - decide to name them Red Box green box
46:28 - and blue box and then in someone else
46:32 - comes to your house someone else comes
46:33 - to your program he does not really know
46:36 - where to find sugar because red does not
46:39 - mean that that box is storing sugar so
46:42 - you should name that box sugar box
46:44 - because imagine have three is easily
46:46 - easy to remember but imagine having 10
46:48 - boxes or 10 variables or a hundred of
46:50 - them or even a thousand which is very
46:54 - common inside large programs so what you
46:58 - should do and I am going to do is return
47:01 - that previous name so monthly salary and
47:05 - here also so you should give meaningful
47:08 - names to your variables that is very
47:10 - important and that is the first rule the
47:13 - second rule is that well the second and
47:17 - third and the fourth are the rules that
47:19 - you will have to obey in most cases
47:21 - because if you don't then you are just
47:24 - going to get a compile time error
47:27 - in 99% of the cases let's say and I'm
47:31 - not going to say what that 1% is because
47:33 - I want you to obey these rules
47:36 - so when it comes naming your variables
47:39 - another thing is that your variable
47:41 - names
47:43 - cannot contain any special characters
47:46 - except
47:48 - underscore so like this this here is
47:52 - valid name to your variable but if you
47:55 - try for example to name your your
47:57 - variable like this so you say plus
47:59 - character you see that here in this
48:03 - error window it says expected an
48:06 - identifier so you cannot use this to
48:08 - name your variable or this you cannot
48:11 - say character with this minus inside it
48:15 - so character
48:17 - minus um so these signs these special
48:21 - signs are used for something else they
48:24 - are operators inside C++ and and you are
48:27 - not supposed to use those inside your
48:29 - variable names if you really want to use
48:32 - some special signs what you should and
48:36 - can use is underscore like this so this
48:40 - is the only sign that is allowed and
48:41 - that I recommend for you to use for
48:43 - naming your variables that's the second
48:47 - rule the third rule is that your
48:50 - variable names cannot begin with numbers
48:53 - like this so you cannot say
48:57 - eight character for example It also says
49:00 - expected an identifier but what you can
49:02 - do is you can say for example character
49:06 - 8 that is a valid name so a number can
49:10 - be on any other position except on the
49:13 - first
49:14 - position so this is a valid name for a
49:17 - variable so you can put also number here
49:20 - so you can say for example C12 eror 8
49:25 - but again what does that really mean me
49:27 - that is not a meaningful name for a
49:28 - variable so again we come to the first
49:31 - rule so you should name your variables
49:33 - according to their purpose so I'm going
49:36 - to return this to character name
49:39 - again and then we have our third rule I
49:44 - guess which is you cannot use space
49:48 - inside your variable names so for
49:50 - example this this is not valid and your
49:54 - compiler says it here so it gives you an
49:57 - error it does not know what this really
50:00 - is so you cannot use Space Blank spaces
50:04 - inside your variable names because you
50:07 - are going to get compile time error and
50:09 - if I try to do that and I try to run my
50:12 - program I get the window so it says you
50:15 - cannot run this program you have
50:16 - syntatic errors what you should do is
50:18 - you
50:19 - should correct those errors and then you
50:23 - can really run your program like this
50:28 - this
50:30 - okay so let's repeat these rules one
50:32 - more time the first rule is that you
50:35 - should give meaningful names to your
50:37 - variables so name them according to
50:39 - their purpose the second rule is that
50:42 - your variables cannot contain any
50:44 - special characters except underscore the
50:48 - third rule is that your variables cannot
50:50 - start with numbers you can put number on
50:53 - any other position but not on the first
50:56 - one and third rule is that and the
50:58 - fourth rule actually is that your
51:00 - variables cannot contain blank spaces so
51:04 - empty spaces no no in a variable name
51:07 - what you should do is you should name
51:10 - your variables according to their
51:11 - purpose so meaningfully and you should
51:14 - also use something called camel casing
51:16 - what is camel casing you see how I have
51:19 - named this annual salary here you see
51:22 - that the first letter of my variable
51:25 - name is small letter and then the next
51:27 - word starts with capital letter and that
51:30 - is called camel casing so for example
51:33 - you would name your variable like this
51:36 - first
51:38 - second
51:39 - third so like this you see that this
51:43 - first second third these are words
51:45 - inside your variable name and this F is
51:49 - lowercase letter that's the start letter
51:51 - of your variable and then each next word
51:54 - begins with capital letter and all the
51:57 - rest is lowercase letters that is called
51:59 - camel casing and that is something that
52:01 - is usually used with
52:03 - C++ let's talk about data types now I am
52:07 - going to delete this code so if you need
52:09 - this code for a bit longer you can pause
52:11 - the video
52:13 - here
52:15 - so what kind of data can we store in our
52:18 - variables Well for now we are going to
52:21 - cover only the most basic ones the ones
52:23 - that we are going to use frequently and
52:25 - you should know that there are a a lot
52:26 - more data types besides from these that
52:29 - we are going to mention here a more
52:30 - complex ones that we are going to cover
52:33 - later in these videos in this tutorial
52:36 - so the first one that I would like to
52:37 - mention is a whole number data type so
52:42 - integer a data type that can hold
52:44 - negative whole numbers zero and positive
52:48 - whole numbers so the type that is used
52:50 - for that and C++ is called
52:54 - int and good example example for INT
52:57 - variable is let's say year of
53:02 - birth so that is an example of a whole
53:07 - number variable and let's say that that
53:09 - variable is going to hold
53:13 - 1995 okay so that would be an integer
53:16 - variable after that we have already seen
53:19 - this so it is a character variable so
53:23 - let's say Char and an example of a Char
53:27 - variable could be gender for
53:29 - example let's call it gender and you can
53:33 - store f for female or M for male for
53:37 - example so the Char variable can store
53:40 - one
53:42 - character then the next one is Boolean
53:46 - value meaning true or false value this
53:49 - is the simplest one and the type that is
53:52 - used to store bullion is called bull
53:56 - and a good example for a bull value
53:59 - could be for example if you want to hold
54:01 - in your program a variable that tells
54:04 - you whether your user is older or
54:07 - younger than 18 years 18 years old so
54:11 - let's call our variable is older than
54:15 - 18 and we can assign to that variable
54:18 - either value of true or
54:20 - false so I'm going to put true true
54:24 - here another very able another data type
54:28 - is decimal point number also called
54:32 - floating Point number which we have
54:34 - mentioned before and let's create a
54:36 - variable of type
54:40 - float and let's say that that variable
54:42 - is going to to hold our average grade so
54:46 - average
54:49 - grade and uh this average grade can also
54:54 - be a whole number but since it has
54:56 - potential to be
54:58 - also floating Point number or a decimal
55:01 - point number we are going to to use a
55:03 - float data type for this average
55:07 - grade and another data type that I would
55:11 - like to mention for also storing decimal
55:14 - numbers is called double and the
55:16 - difference between double and Float is
55:18 - that double is double size of float so
55:21 - if you remember when we talked
55:22 - previously about uh Tak memory space
55:26 - that that varibles take so float is
55:28 - taking four bytes and double is taking
55:31 - double of that so eight bytes so you can
55:33 - put much more data inside your double
55:36 - data type than inside float and let's
55:39 - say for example that if you had a credit
55:41 - card and you had a lot of money a lot a
55:45 - lot a lot of money and you want to store
55:48 - that value inside a variable you would
55:50 - use a double data type so let's say
55:53 - double balance if equals to this large
55:58 - number here which I'm not going to even
56:01 - try to read
56:04 - okay so these are the most common data
56:09 - types that we are going to use in this
56:11 - tutorial I have said earlier that each
56:14 - data type takes a certain space in
56:16 - memory but let's see exactly how much
56:19 - each of these take for that we are going
56:22 - to use something called size of operator
56:25 - and let's see how we use it so C out
56:29 - size of int is and then we write this
56:34 - size off so size of and in parenthesis
56:37 - we pass to it data type that we want to
56:40 - check how much memory it is using so
56:43 - int and if I run my program now you see
56:47 - that it says that int takes four bytes
56:50 - of memory and if you've ever actually
56:53 - studied binary algebra you would know
56:55 - that four bytes of memory is actually 32
56:58 - bits since each bite has eight bits and
57:02 - as we said our int can store both
57:04 - positive and negative numbers and zero
57:06 - also remember that so the first of these
57:10 - 30 two bits is used to determine whether
57:12 - the number has plus sign or minus sign
57:15 - so whether it's a positive or A negative
57:16 - number and then remaining 31 bits are
57:19 - used for this value itself so let's
57:23 - check what is min value for our int
57:26 - let's write that out let's write C out
57:30 - int Min value is and we have reserved
57:34 - word for minimal amount for INT in C++
57:39 - and that is intore
57:41 - min and if I run my program now you see
57:46 - that it says this minus 2 billion
57:49 - extremely hard to read this number but
57:51 - you see that this is the minimal amount
57:55 - of int so this number is actually 2 to ^
57:58 - of 31 let's just quickly write these so
58:01 - -1 -2 -3 and then
58:06 - minus this number here so this number as
58:11 - I said is 2 to the power of 31 why not
58:14 - 32 because this one bite is used to
58:17 - represent this minus prefix now we
58:21 - should check a positive number range so
58:24 - we also can write write int max value is
58:29 - and then there is another keyword in C++
58:32 - for INT Max which is intore Max and are
58:36 - you expecting to see this same interval
58:40 - but just with plus sign so write in the
58:44 - comments what are you expecting to
58:47 - see and if I run my program you see that
58:51 - that did not happen and if some of you
58:53 - know why it did not happen I would also
58:55 - like to to hear what you think why we
58:59 - have this number here and then this
59:01 - number here for our negative and for our
59:03 - positive range so different ending
59:06 - number and I'm going to explain why
59:10 - because this positive range here we have
59:12 - to include zero also so in order to
59:15 - include one number here just let's just
59:18 - copy this and paste it so our positive
59:21 - range is going to from one up to let's
59:23 - say that it is this number but since it
59:26 - is including zero also in order to
59:28 - include one number here so zero you have
59:31 - to take one number here so this here is
59:34 - not eight anymore but is seven so that
59:38 - is why we got let's say different number
59:41 - for our positive and negative range
59:43 - because this here includes zero also one
59:47 - thing that I have to mention though is
59:49 - that if you want to use only positive
59:51 - integer numbers there is a data type for
59:53 - that as well and data type that is used
59:57 - for that is called unsigned int and its
60:00 - size is the same as of int so four bytes
60:03 - or 32 bits but since it is unsigned that
60:07 - means that it does not use one bit for
60:10 - sign because the sign is by default plus
60:14 - but it uses all 32 bits to represent
60:17 - value and those values go from zero to
60:21 - let's see exactly how big of a number 4
60:23 - billion and something so see out
60:27 - size of unsigned int
60:32 - is and let's see size of unsigned int
60:37 - this is the data
60:39 - type and let's also write out what is
60:43 - the max value of unsigned int so let's
60:47 - say C out u in max value
60:53 - is and there is there is also reserved
60:56 - War for that and that is U inore
61:02 - Max so if I run my program now you see
61:06 - that we got 4 billion and something
61:09 - number so double the size of this and
61:11 - this is actually 2 to ^ of 32 but minus
61:15 - one because we are also including zero
61:19 - in this range so let's check these
61:22 - remaining data types I'm going to write
61:25 - those out quickly and I will be back so
61:28 - I have written here the rest of these
61:30 - data types and as you can see since our
61:32 - bull is only true or false value one
61:35 - bite is enough for bull our Char is
61:38 - using also one bite float is using four
61:40 - bytes double is using eight and I'm also
61:44 - going to include a table with some more
61:47 - data types which we haven't mentioned
61:48 - here so if you need to check those out
61:52 - please pause the video
61:57 - one thing that I promis to show you is
61:59 - data type overflow let's see what that
62:02 - is so let's create a variable of type
62:05 - int and call it int Max and let's say
62:08 - that I want to store inside that
62:10 - variable maximum amount of int So intore
62:15 - Max and I'm going to write that variable
62:18 - out now just see how big of value that
62:21 - really is so see out int Max and if I
62:26 - run my program now you see that I have
62:29 - gotten here this 2 billion very large
62:32 - number actually so that is the max
62:34 - amount of int now my question for you is
62:38 - what is going to happen in this
62:39 - situation so see out int Max +
62:45 - one what is going to be the result of
62:48 - our program now if I run it so some of
62:51 - you may know this already some of you
62:53 - may not but I am very interested in
62:56 - reading your answers so make sure to
62:58 - write your answers before watching my
63:00 - explanation on this write those in the
63:02 - comments down below and if I run my
63:05 - program now well our number has not
63:09 - increased by one but it has went to the
63:13 - minimal amount of int and why has that
63:16 - happened well that is the data type
63:19 - overflow that I was talking about and
63:20 - how this works actually is it works the
63:23 - same as your clock works so it goes 9 10
63:27 - 11 12 and then from 12 since that is the
63:31 - max value on your clock it does not go
63:34 - to 13 but it goes back to Min so 1 12
63:39 - and then 1 and that is applicable here
63:44 - it went from the max value to Min value
63:47 - just by adding one and that is called
63:50 - data type
63:53 - overflow I already can see that this
63:55 - video is pretty pretty long and I'm
63:56 - currently having problems uploading very
63:58 - long videos to YouTube so I'm going to
64:01 - leave for the next video explanation of
64:03 - asky table and we are also going to do
64:06 - some more examples and practice C++ some
64:09 - more so make sure to subscribe to my
64:11 - channel and also click the Bell icon so
64:14 - that you are first to be notified when I
64:16 - upload my next video and also like it
64:18 - and share it with anyone who do you
64:20 - think could benefit from this video and
64:22 - I will see you in the next
64:24 - one hi guys welcome to my channel as I
64:28 - promised in my previous video in this
64:30 - video I'm going to explain the concept
64:31 - of asky table and then I'm going to give
64:34 - you an idea an example of a program that
64:37 - is very beginner friendly very simple
64:40 - but also very fun and that you can build
64:42 - only with knowledge from my two previous
64:44 - courses and this one so if you haven't
64:47 - watched those make sure to watch them
64:49 - link is going to be somewhere here and
64:51 - also in the description and also make
64:54 - sure to like this video and to subscribe
64:56 - to my channel for more educational
64:58 - content and let's begin now so what is
65:01 - aski well aski stands for American
65:04 - Standard code for information
65:06 - interchange and it was first created in
65:08 - order to standardize the way of
65:10 - representing characters in your computer
65:13 - so in asky table those characters are
65:16 - represented as numbers numeric codes and
65:19 - what this means is following let me give
65:21 - you an example when I first learned to
65:24 - read and write so when I was a little I
65:27 - decided to together with my friend
65:29 - create uh our special symbol language
65:32 - where we would exchange each character
65:34 - with a special symbol that only two of
65:37 - us could understand and then we would
65:39 - exchange letters us using that symbol
65:42 - language and no one else could
65:44 - understand those letters and also guys
65:47 - write in the comments down below if you
65:49 - did that I know you did so don't make me
65:51 - feel like a weird one well that is
65:53 - exactly what your computer does it
65:55 - exchanges each character with a number
65:58 - so that it can understand it and it can
66:01 - communicate with other computers so this
66:03 - means that your computer or ask key
66:07 - table assigns to each character a unique
66:10 - number and let's prove that now so how
66:12 - we can do that is in my visual studio
66:16 - I'm going to
66:17 - say see
66:19 - out and then in these parentheses I'm
66:22 - going to say
66:24 - int and then these single quotes and I'm
66:27 - going to say letter a and let's add end
66:30 - line so this is one way of doing that
66:33 - and then there is another way of doing
66:36 - just the same thing and that is let's
66:38 - say see out and then int and then inside
66:42 - these parentheses we are going to say
66:45 - our single quotes and our letter a and
66:47 - also add end line so this here is called
66:53 - casting operator and it is the operator
66:55 - that forces one data type to convert
66:58 - into another and since we said that each
67:01 - character has its numeric pair inside
67:04 - ask key table well we can ask our
67:06 - computer to give us that pair so here
67:08 - I'm seeing please tell me what is my
67:11 - numeric pair of my letter A so what
67:13 - number is my letter a and if I run my
67:17 - program
67:18 - now you see that I got 97 so our
67:23 - lowercase letter a is 9 97 in ask key
67:26 - table let's check now a capital letter A
67:29 - so I'm going to say C out in off and
67:34 - let's put our capital letter a and one
67:36 - more end
67:39 - line so if I run my program now you see
67:43 - that I'm going to get a different number
67:45 - so
67:46 - 65 and this is so that your computer can
67:49 - distinguish between lowercase and
67:51 - uppercase letters so ask key uses seven
67:56 - seven bits to represent each character
67:58 - and that means that it can represent 2
68:00 - to the power of seven that's how much
68:02 - characters it can represent so
68:05 - 128 characters and that is enough for
68:09 - all English characters so all English
68:11 - lowercase and up uppercase letters and
68:14 - numbers and also some special symbols
68:17 - but there is also a lot more languages
68:19 - and also languages that have a lot more
68:22 - characters so there is a lot more
68:24 - standards for representing those
68:26 - characters inside your computer so this
68:29 - that we have just mentioned is called um
68:32 - ask key and there is also extended ask
68:35 - key that is another standard that can
68:38 - represent more characters then there is
68:40 - also utf8 utf16 and a lot more different
68:45 - standards so what we should remember for
68:47 - now that is related to ask key is that
68:50 - as key represents each character with a
68:53 - number so it holds its numeric nuic
68:55 - match it's num numeric pair in its table
68:59 - and then that we can also get get that
69:02 - numeric match using our casting operator
69:05 - so this here is a casting operator so
69:09 - now you may ask if we can get a numeric
69:13 - value of our letter so if if we can get
69:16 - our int number of our our letter can we
69:18 - do vice versa so can we get a character
69:22 - from our numeric value and the answer is
69:24 - yes we can convert a number into a
69:27 - letter also and I'm going to demonstrate
69:30 - how we can do that in a moment so you
69:34 - can say see out Char and let's say Char
69:38 - of 65 and add end line and if I run my
69:44 - program you see that I'm going to get a
69:47 - letter A so capital letter a and now
69:51 - with this when you learn this you can
69:53 - get an idea on how you can build
69:55 - something more useful than than just
69:57 - basic hello world application so you can
70:00 - for example build a program that ciphers
70:02 - words and sentences in a s key and then
70:06 - also a program that deciphers those
70:08 - messages back into English readable
70:11 - characters so now we are going together
70:14 - to build a program that ciphers words
70:17 - into ask key codes and then I'm going to
70:19 - leave to you to build the program that
70:21 - deciphers those words back into English
70:23 - readable characters
70:26 - so let's say that we want to Cipher a
70:28 - five letter word so what I'm going to do
70:32 - is what I need to do is to create five
70:35 - Char variables so I'm going to create
70:38 - five Char variables then I'm going to
70:40 - let my user input his letters inside
70:44 - those five chart variables and then I'm
70:45 - going to write out encoded words so I'm
70:49 - going to convert all of these letters in
70:52 - ask key codes and then I'm going to
70:53 - write that out to my user so I'm going
70:55 - to on a in a certain way Cipher his his
70:59 - word so I'm going to say here Char
71:04 - C1 Char
71:07 - C2 and then Char
71:11 - C3 and I won stop here for a moment I
71:14 - want to explain one thing when we first
71:16 - were talking about creating variables we
71:18 - said that this is the way of creating
71:20 - variables so you say the type of of your
71:22 - variable so Char in this case and then
71:25 - you say what name you are going to give
71:27 - to your V variable so in this case this
71:29 - is our C1 C2 C3 so this way of creating
71:34 - variables here it is correct but it is a
71:36 - bit tedious for this current situation
71:39 - there is another way of creating more
71:41 - than one variable and I'm going to
71:43 - demonstrate that now so what you can say
71:46 - also what you can do is Char C1 C2 C3
71:53 - C4 and C5 and all separated with this
71:57 - comma sign so you can create more than
72:00 - one variable in one line like this but
72:04 - only if all of those variables are of
72:06 - the same type and in this situation they
72:08 - are so all of these variables are of
72:11 - type CH so I've now created five
72:15 - variables of type chart and another
72:17 - thing that I want to mention is that in
72:19 - upcoming videos we are going to learn
72:21 - how we can let our user decide how many
72:24 - characters how many uh how how many
72:27 - values he wants to enter during the
72:28 - execution of our program so now we have
72:32 - hardcoded these five values but we are
72:34 - going to learn more in the following
72:35 - courses and also another thing is that
72:38 - also in C++ there are a lot of solutions
72:41 - that you can use already made so that
72:44 - you can enter whole words or sentences
72:47 - so you don't have to enter your word
72:49 - letter by letter so you don't have to
72:51 - create variable for each letter that you
72:53 - want to enter but what I'm trying to
72:55 - explain here and what we want to
72:57 - understand here is how it really works
72:59 - in the background so how it works inside
73:02 - you have to understand that and I
73:04 - believe that that will give you a great
73:05 - advantage over those programmers that
73:07 - just know how to use something rather
73:10 - than how to make that something by
73:12 - themselves and then use it so I have
73:15 - here created five variables and each one
73:18 - hold a character that we will enter and
73:21 - let's enter them now so what I'm going
73:24 - to say is C out enter five
73:31 - letters and then I'm going to say C in
73:34 - and I'm going going to put all my
73:36 - variables here so C1 C2 C3
73:42 - C4 and
73:45 - C5 so if you can see here I have entered
73:50 - all of my five variables in a single
73:52 - line so you can do this you can buy B
73:55 - these operators like like this so that
73:58 - you can enter more than one variable in
74:00 - a single line the same way that you can
74:02 - bind your see out operator so that you
74:05 - can write out more than just one
74:08 - string
74:10 - so now what we are left to do is we have
74:15 - to write out our ask key message so what
74:18 - I'm going to say is see
74:21 - out ask
74:23 - key message
74:26 - and then I'm going to put int C1 let me
74:30 - write that out really
74:32 - quickly so I have written this message
74:34 - here and what I have said is console
74:37 - output asky message and then I have
74:40 - combined these C out operators so that I
74:43 - can write more than one variable in a
74:46 - single line so in a single command
74:48 - actually so I have said give me my int
74:51 - code of my C1 so give me my ask key code
74:54 - of my C1 variable and then put a blank
74:57 - space and then give me my asky code of
75:00 - my C2 and also C3 4 and five and I have
75:05 - also used these blank spaces because I
75:08 - don't want to write just a single number
75:11 - in a single line because I want to know
75:13 - where my first character ends and where
75:16 - my second character begins that's why
75:18 - I'm going to separate those codes with a
75:20 - empty space and also there's another
75:23 - thing that I want to mention and it is
75:25 - that when you want to convert your
75:28 - variable so the value that you are
75:30 - holding in your variable and when you
75:32 - use your casting operator on that you
75:34 - don't put your variable in a single
75:36 - quotation mark so you just put the name
75:38 - of your variable like this example
75:40 - here so if I run my program
75:44 - now you see that I get my message so
75:47 - enter five letters and I'm going to
75:49 - enter
75:51 - hello and you see now that I have this
75:53 - output asking message is 104 101 so 108
75:59 - and 108 so that is our letter L you see
76:03 - that it has the same code and now I have
76:06 - gotten this asky message which is which
76:09 - is our ciphered
76:12 - word and also there is one thing that
76:15 - you that I want you to keep in mind and
76:17 - that is that this program here will not
76:19 - take into consideration your enter or
76:22 - your space key as a letter so if you if
76:25 - you put your enter or your space key
76:27 - however much times you want it will not
76:29 - treat it as a character there are some
76:32 - other functions that you can use in your
76:34 - C++ if you want to capture your enter
76:37 - for example or your space key such as
76:39 - cin.get if you really want you can
76:41 - Google that out but at this point we are
76:44 - keeping this very beginner friendly so
76:47 - this will not capture your enter and
76:49 - your space so let's just prove that I'm
76:52 - I'm running my program once more and I'm
76:54 - going put enters and spaces and you see
76:58 - nothing is happening and then if I enter
77:00 - hello once more you see that I'm going
77:03 - to get the same numbers so the same
77:06 - message as
77:08 - before so we have built here a program
77:12 - that ciphers our words into s key and we
77:15 - have built this program after just
77:17 - studying a little bit of coding so
77:19 - imagine what you can do if you learned
77:21 - more so stay tuned make sure to
77:23 - subscribe to my channel
77:25 - and also like this video if you want to
77:27 - support me in filming these videos and
77:29 - also I'm going to leave to you to write
77:33 - a program that is going to decipher
77:35 - these messages from ask keyb into
77:37 - readable English words so you also can
77:41 - put your uh suggestions of a code in a
77:43 - comments down below and also what you
77:45 - can do you can upgrade this program here
77:47 - that we have written so that you can put
77:49 - in more words more sentences if you want
77:52 - and then you can put those coded encoded
77:56 - messages in the comments and everyone
77:58 - who wants to read those messages is
78:00 - going to have to build a program that is
78:02 - going to decipher those messages into
78:04 - readable English so subscribe to my
78:07 - channel like this video and I'll see you
78:10 - in the next
78:11 - one hi guys welcome to my channel in
78:15 - today's video I wanted to show you
78:17 - something that you are going to be using
78:19 - very often if you start on a programming
78:21 - path and that is if else statement so
78:24 - what is IFL statement well if statement
78:28 - is something that is used when you want
78:29 - to execute part of your code so block of
78:32 - your code conditionally which means not
78:35 - always but only in a certain situation
78:38 - and then if you add else block to that
78:41 - that else block is going to be executed
78:43 - otherwise so in the situation where your
78:45 - if block is not executed your else is
78:48 - going to be executed so let me explain
78:52 - that to you in a simple example here I
78:55 - have opened my visual studio and let's
78:57 - quickly paste an exercise that we are
79:00 - going to do in this tutorial and that
79:04 - that is this task here so let's say that
79:07 - our user has to enter a number a whole
79:09 - number integer number and then after
79:12 - that our program has to check whether
79:15 - that number is even or odd and has to
79:17 - write out that to our user so how we are
79:20 - going to solve this problem here well
79:23 - I'm going to explain explain this to you
79:25 - using diagrams because I believe that
79:28 - that is the best way for you to
79:30 - understand this if you haven't used this
79:32 - IFL statement before and then what we
79:34 - are going to do after we understand
79:36 - those diagrams well we are literally
79:38 - going to just translate that diagram
79:41 - into our C++ code so let me open my tool
79:45 - here I have opened a tool that I'm going
79:48 - to be using for drawing diagrams it's
79:50 - called blank diagram you can use
79:52 - whatever tool you want you can use even
79:54 - a paint or pen and paper if you want
79:57 - that will work as well so here I'm going
80:00 - to draw the
80:02 - flowchart of our program so how our
80:04 - program is going to be executed and let
80:07 - me add
80:09 - first here this shape and we are going
80:12 - to say that this is going to be the
80:14 - start of our program so I'm going to
80:16 - write out start and this indicates our
80:20 - main function let's say the first line
80:22 - of our main function so here our program
80:24 - starts and then as we said in our task
80:28 - in our exercise our user has to enter an
80:31 - integer number and the shape that we are
80:34 - going to be using for that is this shape
80:36 - here so let me put this shape here and
80:41 - I'm going to write a text inside and I'm
80:44 - going to say in number so this shape
80:48 - here indicates that our user is going to
80:51 - enter some data in our program and why
80:53 - I'm using this shape because it looks
80:55 - like this it looks like a funnel so you
80:57 - can clearly visualize that something has
80:59 - to enter inside that shape so something
81:02 - has to be inputed in your program so I'm
81:05 - going to use this shape for that and
81:08 - then I'm going to say that our user has
81:10 - to enter an integer number which I'm
81:13 - going to call number so that variable
81:15 - I'm going to call number and let's
81:18 - quickly add this Arrow so that we know
81:21 - that this is the flow of our program so
81:23 - after it has started our user enters a
81:25 - number and then after that what we have
81:28 - to do is our program has to decide
81:31 - whether that number that user has
81:33 - entered is even number or odd number so
81:36 - how we are going to do that well the
81:39 - shape that I'm going to be using for
81:40 - that decision let me find it Well it is
81:44 - this shape here so this diamond shape
81:46 - and as you can see it says decision on
81:49 - it so that's the shape that we are going
81:51 - to be using and inside this this shape
81:55 - here I'm going to write a condition so
81:58 - as you can see our program flows this
82:00 - way and after it comes here as you can
82:04 - see it has one entry point and then it
82:06 - it can have multiple multiple flows that
82:10 - it can go to depending on this condition
82:12 - that we are going to put inside here but
82:15 - how we are going to decide whether that
82:17 - number that our user has entered is even
82:19 - or odd let me very quickly open my
82:22 - visual studio once more it is
82:25 - here and let me show you something I
82:28 - want to introduce you to a operator that
82:30 - is called modulo and that is used to
82:33 - show what is the remainder of dividing
82:35 - two whole numbers so I'm going to write
82:38 - out C
82:39 - out and then what I'm going to write out
82:43 - is let's say 2 modulo
82:46 - 2 so this operator here gives you the
82:51 - remainder of dividing these two numbers
82:54 - and in this situation we are expecting
82:57 - to see a zero because 2 ided by 2 is 1
83:00 - and then what remains after that
83:01 - operation is zero and that what remains
83:04 - should be should be shown when we use
83:07 - this operator here so if I run my
83:09 - program you can see that we have gotten
83:11 - the expected result so we have gotten
83:14 - zero here but let me show you what
83:17 - happens if I enter for example
83:21 - five well what we are going to get is
83:23 - one because 5 ided by two is going to be
83:26 - two and then that one that remains we
83:29 - can get using this operator and you see
83:32 - that it gives us the expected result so
83:34 - 5 modul 2 is equal to
83:37 - 1 so this operator here is what we are
83:42 - going to be using to determine whether
83:44 - our user has entered even number or odd
83:46 - number because when we get the result of
83:50 - modulating two numbers when our result
83:52 - is one that means that our user has has
83:54 - entered odd number and if we get zero as
83:57 - a result of this operation that means
84:00 - that our user has entered even number so
84:03 - I'm going to switch again to my diagram
84:06 - and then inside this decision here we
84:10 - are going to be writing we are going to
84:13 - write this condition here so I'm going
84:15 - to say number modulo 2 is equal to Zer
84:22 - so what this means it means that after
84:24 - our program has started and our user has
84:28 - entered the number that he wants an
84:30 - integer number we are coming to a
84:32 - decision point where we have to decide
84:34 - whether this number that he has entered
84:37 - after you modulate it with zero whether
84:39 - it's a uh zero remainder or some other
84:42 - remainder so in this situation when this
84:45 - is zero we are going to execute a
84:47 - certain part of code and then let me add
84:50 - very quickly oh I'm impressed it already
84:53 - has this yes
84:54 - inside it and then we also have this no
84:57 - on this other line so in this situation
85:01 - where this results as operation that is
85:03 - true we are going to execute this part
85:06 - code of here so I'm going to add another
85:10 - shape which I cannot see but let me use
85:13 - this shape once more and I'm only going
85:16 - to rotate this shape like this and I'm
85:20 - going to delete this text and what we
85:22 - are going to be using this shape here
85:23 - for
85:25 - is to indicate that we are going to
85:27 - output something from our program so it
85:29 - looks like this which is clearly a
85:32 - visual of something is going to be
85:33 - outputed from it so it is just reverse
85:37 - of this shape here this funnel
85:39 - shape and then inside this shape let me
85:44 - write a text which is going to
85:47 - be um let's say that in the case that
85:51 - this here results as a yes as a true
85:54 - operation so our number when it's
85:56 - modulated by two it gives a zero
85:58 - remainder we are going to say that that
86:01 - number is even number so we are going to
86:04 - write that out to our user and then in
86:08 - the situation where this here results as
86:12 - a no so as operation that is
86:14 - false let me write out that here and I'm
86:19 - going to say to our user so I'm going to
86:22 - write out to my user that he has entered
86:25 - odd number and let's just join this here
86:29 - like
86:31 - this okay
86:33 - so our user enters a number then we
86:36 - decide if that number modulated by two
86:38 - gives us zero and if yes we are going to
86:42 - write out to our user that that is a
86:44 - even number if no we are going to write
86:47 - out to our user that that number is odd
86:50 - number and this is here really our
86:53 - program what I'm going to add is let's
86:56 - say that after this our program is going
86:58 - to stop so I'm going to to say here that
87:02 - this is the end of my program like this
87:06 - and let's add one more
87:09 - stop of this flow here so in both of
87:13 - these situations after we have and after
87:15 - we have outputed to our user the result
87:17 - of this program our program is going to
87:19 - stop and this here really like these two
87:23 - stop points look a bit ugly to me so
87:25 - what I'm going to do instead of this I'm
87:28 - going to delete this you could have as
87:31 - well left it like this like like it was
87:33 - before but what I'm going to add I'm
87:36 - going to add one more of these diamond
87:38 - shapes only this time it's going to be
87:40 - smaller and I'm going to say that in
87:44 - this situation it is going to be used
87:46 - only to say that this decision here this
87:50 - decision flow is going to be joined in
87:52 - this point here so like this I'm going
87:55 - to
87:56 - say whatever has happened whether this
87:59 - block of code or this block of code it
88:02 - has come to an end here and then after
88:05 - that from here I'm going to say now my
88:08 - program is going to
88:11 - stop like this and this and let me
88:15 - remove this yes and this is going to be
88:19 - the flowchart of our program so our
88:21 - program starts then our user enters
88:24 - integer number then we decide whether
88:26 - that number modulated by two is going to
88:29 - give us zero if yes we execute this else
88:33 - we execute this so if this is no and
88:36 - then we come to this which joins our two
88:40 - pads and then we can say that our
88:42 - program has ended and now let's
88:45 - translate this to our code here I have
88:48 - opened both my visual studio and also I
88:51 - have exported this diagram so that we
88:53 - can translate it literally we can look
88:55 - at this diagram and then translate that
88:57 - into code so now I'm going to delete all
89:00 - of this that we have written inside our
89:02 - visual studio and I'm going to look at
89:05 - this picture and just translate it into
89:07 - C++ commands so the first this first
89:11 - shape here says that user is going to
89:13 - enter integer number inside our program
89:16 - and we are going to call that variable a
89:18 - number so I'm going to say int number
89:24 - and then this here this funnel shape
89:27 - really translates into C in command so
89:31 - user enter something inside our program
89:34 - and that is C in command and I'm going
89:35 - to say that user is going to enter a
89:39 - number before this I would like to add
89:42 - one more information to our user so that
89:44 - he knows what he should enter you could
89:46 - have as well put that to our diagram but
89:49 - I didn't want it to make that diagram
89:51 - crowded so I didn't but what we are
89:53 - going to add here is see out and then
89:57 - say please
90:00 - enter
90:01 - whole
90:04 - number like this so we write out a
90:07 - message to our user and after that our
90:09 - user as you can see here enters integer
90:12 - number we had also to declare this int
90:16 - number variable because you can enter
90:17 - the value only for variables that you
90:19 - have previously declared and then after
90:22 - that our program comes to this decision
90:25 - point and how we can represent this
90:27 - decision inside our code is using if
90:31 - statement so we are going to write here
90:35 - if and then I'm going to put this
90:38 - condition here inside these parentheses
90:41 - so I'm going to say if number modulo 2
90:47 - equals
90:49 - zero this here is operator of equals so
90:54 - whether this side is equal to this side
90:57 - since only one of these so like this
91:00 - this operator here is used to assign
91:02 - value to a variable so that was already
91:05 - taken so this
91:07 - here two of these signs are used to
91:10 - check equality of these two sides so
91:13 - whether this is equal to this and then
91:16 - what I'm going to say as you can see
91:18 - from my diagram here we check this
91:20 - condition here and if this condition is
91:22 - true if this condition is yes we are
91:25 - going to execute a certain block of code
91:27 - and that is this code here and how you
91:29 - indicate a block of code in your C++ is
91:32 - using these braces here like this so
91:35 - this is your block of code that is going
91:37 - to to be executed in this yes situation
91:40 - and then in case that this no here
91:43 - happens so in case that this results as
91:46 - false you are going to execute another
91:49 - block of code and we represent that
91:51 - block of code using else statement so we
91:55 - are going to say if this here is true
91:58 - execute one block of code else if this
92:02 - here is false execute another block of
92:05 - code so here what our if makes us do
92:10 - well it says that we only have to write
92:12 - out to our user that he has entered even
92:15 - number because this shape here as you
92:17 - can see it looks like this and it
92:19 - represents that something should be
92:21 - outputed from your program so we are
92:23 - going to use for that our C out command
92:26 - so see
92:29 - out you have
92:32 - [Music]
92:33 - entered even
92:37 - number so like
92:39 - this and let's add end line so in case
92:43 - that this here results as true we are
92:46 - going to Output to our user that he has
92:48 - entered even number else if this here
92:51 - results as false we are going to Output
92:54 - to our user let me copy this like this
92:58 - and we are going to change that only to
93:00 - odd so in case that this here results as
93:03 - false we are going to Output you have
93:05 - entered odd number so either this here
93:09 - is going to be executed or this here
93:11 - depending on this condition and you can
93:14 - see that from diag diagram clearly so
93:16 - when your program comes to this decision
93:18 - point it checks this condition and if
93:21 - the answer is true or yes it is going to
93:24 - execute this else if the answer is no it
93:28 - is going to execute this and then after
93:30 - that it really just joins these two
93:33 - flows and then that is the that is the
93:37 - stop point of your program so we can
93:39 - write here see
93:42 - out thanks by okay let's say that that
93:47 - is the last line of our program you
93:50 - don't I haven't put this on on my
93:52 - diagram I
93:54 - okay so I'm going to run my program
93:58 - now and as you can see it says please
94:03 - enter a whole number so this line here
94:05 - and if I enter for
94:08 - example8 it is going to come to this
94:10 - line here and it is going to modulate
94:14 - our eight with two and if the result is
94:19 - zero which it is it is going to execute
94:21 - this line here and write out you have
94:24 - entered even
94:25 - number oh thanks we are missing an S
94:29 - here and then it writes out thanks by
94:32 - and let me add an S here okay and if I
94:36 - run my program again as you can see it
94:39 - ask me asks me again to enter a number
94:42 - and this time I'm going to enter five
94:44 - which we know that is an odd number it
94:47 - says you have entered an odd number
94:49 - because it has come to this decision
94:51 - Point here it has tried to modulate 5
94:54 - with two and the result of that was not
94:57 - zero so it has not executed this but it
95:00 - has executed this else statement and it
95:03 - has written you have entered odd number
95:06 - as you can see here and then this thanks
95:09 - by
95:10 - okay so I hope that you have understood
95:14 - this and if you like me to use these
95:16 - diagrams to explain some more code that
95:20 - we are going to be using you can write
95:22 - that in the comments down below and I'm
95:24 - going to try to use more of these
95:26 - diagrams because I know that some people
95:28 - understand it better when there is a
95:30 - visual representation of your code I was
95:32 - one of those people when I first started
95:34 - learning programming so if you find it
95:36 - easier to understand when I use these
95:38 - diagrams I'm going to be using that so
95:41 - thanks for watching this video make sure
95:43 - to like it if you find it any helpful
95:45 - and also to subscribe to my channel and
95:47 - I'm going to see you in my next video
95:50 - bye hi guys welcome to my channel in
95:54 - this video I wanted to talk about if
95:55 - else statements but a bit more complex
95:58 - if El statements so that you can get an
96:00 - idea on how they are used in real life
96:03 - so if you're not familiar with them at
96:05 - all like you have never heard of IFL
96:07 - statement then you should probably First
96:09 - Watch My First video of this subject and
96:12 - I'm going to link it somewhere here and
96:14 - then you can come back to this video but
96:16 - if you're already familiar with the very
96:19 - basics of IFL statements then this video
96:21 - is right for you so that you can upgrade
96:23 - your knowledge so keep watching so the
96:26 - problem that we are going to solve in
96:28 - this video is the one that students
96:30 - usually get on their exams a lot and
96:33 - with the knowledge that you get from
96:34 - this video you are going to be able to
96:36 - recognize and solve other problems of
96:39 - this type and also if you don't want to
96:41 - work with C++ this logic that I'm going
96:43 - to teach you today is going to be
96:45 - applicable in other programming
96:46 - languages as well so here's the text of
96:49 - my problem and it says that our user
96:52 - should enter the lengths of a triangle
96:55 - so a b and c and after that our program
96:58 - should write out whether that triangle
97:00 - is equilateral isoceles or scaling
97:03 - triangle and as you already may know
97:06 - equilateral triangle is the one that has
97:09 - all three sides of the same length
97:11 - isoceles triangle has two sides of the
97:14 - same length and then scalene triangle is
97:16 - the one that has all three sides of
97:19 - different length so the way that we are
97:22 - going to solve this problem is we are
97:24 - going to really visualize the solution
97:26 - for this problem so that you can really
97:28 - understand it and that is going to be
97:30 - using diagrams the tool that I'm going
97:33 - to be using for drawing diagrams is
97:35 - called blank diagram you can use
97:37 - whatever tool you prefer even pen and
97:39 - paper if you want and the first shape
97:41 - that I'm going to put to this diagram is
97:43 - going to be this circle shape here let's
97:46 - say that it is going to indicate the
97:49 - start position of our program so here is
97:52 - where our program starts and after our
97:55 - program has started what we want is we
97:57 - want our user to enter side lengths of
98:00 - our triangle and the shape that we are
98:02 - going to be using for DOT is this funnel
98:05 - shape
98:07 - here so that you can clearly visualize
98:10 - because of this funnel shape that
98:12 - something should enter inside it
98:14 - something should be inputed in your
98:16 - program
98:18 - and what should be inputed is side
98:21 - length so a b and c and the type that
98:25 - I'm going to be using for these three
98:27 - variables is
98:29 - float why float well because the lengths
98:33 - of sides of a triangle can be decimal
98:35 - point number or floating Point number so
98:39 - float and then let's put this Arrow here
98:42 - so that you can oh so that you can uh
98:46 - visualize the flow of our program it
98:48 - goes like this and then after our user
98:50 - has inputed the side lengths what we
98:53 - should do is we should determine whether
98:55 - he has entered a equilateral triangle
98:58 - isoceles triangle or squalene triangle
99:01 - and what I'm going to do next is I'm
99:03 - going to use this diamond shape here
99:07 - which indicates decision in your program
99:10 - and what I'm going to put inside this
99:12 - shape here is condition the first thing
99:15 - that we want to check is whether whether
99:17 - our user has entered equilateral
99:19 - triangle so whether these three sides
99:22 - are all of the same length whether these
99:24 - three variables hold the same
99:28 - value and let me make this a bit bigger
99:32 - and inside here I'm going to say please
99:35 - check if my a is equal to my B and also
99:41 - if my B is equal to my C like this so
99:47 - let me join these
99:49 - two and I want to explain two things
99:52 - when it comes to this first one is this
99:54 - operator here this end operator these
99:58 - two ents this is logical end operator
100:02 - and it is used as I'm going to just
100:05 - explain so this expression here is going
100:08 - to result as true expression only in a
100:11 - situation where this here is true and
100:15 - also at the same time this here is true
100:20 - so in that case this whole expression
100:23 - expression is going to result as a true
100:25 - operation that is the logic behind this
100:28 - end operator and the second thing that I
100:31 - want to explain is following so I have
100:33 - said here please check if my a side
100:36 - length is equal to my B length and also
100:39 - if my b side length is equal to my C
100:41 - side length what you have Al what you
100:44 - can also put here is you can also say a
100:47 - because we have determined here that
100:49 - these two are of the same length so it
100:52 - really doesn't matter if you put here A
100:54 - or B whichever you
100:57 - prefer so in this situation where this
101:01 - results as a true operation we are going
101:04 - this way and what I'm going to do when
101:07 - this results as a true operation as a
101:09 - yes
101:10 - operation I am going to use this shape
101:13 - here let me just rotate it I really
101:17 - don't see a shape that that is this one
101:20 - so that's why I'm using this reverse
101:22 - funnel shape and I'm rotating it so that
101:24 - you can clearly visualize something
101:26 - something that is being outputed from
101:28 - your
101:29 - program let me delete this text here and
101:33 - make it a bit
101:35 - wider and I'm going to put text inside
101:39 - it and what I want to write out in this
101:42 - situation here where this results as a
101:44 - true operation where this condition is
101:46 - fulfilled is that our user has entered
101:49 - equilateral triangle because all three
101:51 - sides are of the same length so let me
101:53 - write that
102:00 - out so in case that this condition
102:04 - condition here is true we are going to
102:08 - to write out our user that he has
102:10 - entered equilateral
102:13 - triangle and then let's check the
102:16 - situation where this here results as a
102:18 - no operation so in that case we have to
102:23 - to determine whether our user has
102:25 - entered scaling triangle or a isoceles
102:29 - triangle and for that I'm going to be
102:31 - using another of these diamond shapes so
102:34 - another decision that we have to make
102:36 - and let's put it
102:39 - here and oh no and the next thing that
102:43 - we want to check is following so I want
102:48 - check when I once I have determined that
102:50 - my user has not entered all three
102:53 - sides of the same length I want to
102:55 - determine whether he has entered all
102:57 - three sides of a different length so I'm
102:59 - going to put inside this shape here
103:02 - another condition and I'm going to say
103:05 - following so please check if my a is
103:09 - oops if my a is not equal to my B and
103:14 - also at the same time if my a is not
103:17 - equal to my C and also at the same time
103:21 - if my b is not equal to my C like
103:27 - this so this is the next condition that
103:30 - we want to check and this operator here
103:33 - is called not equal to operator and it
103:37 - is really reversed from this equal
103:39 - operator it has reversed logic so in
103:42 - this condition here what we want to
103:43 - check is whether my a side length is not
103:46 - equal to my bside length and also at the
103:49 - same time whether my aside length is not
103:52 - equal to my C side length and also
103:55 - whether my B is not equal to my C and if
103:58 - this here results as a true operation
104:01 - that means that all of these three side
104:04 - lengths are not equal they all have the
104:07 - different lengths so in that situation
104:10 - we are going to go this way and we are
104:13 - going to write out let me copy this
104:18 - shape and here I'm going to say please
104:22 - write out my user that he has entered a
104:25 - triangle that has all three different
104:28 - side lengths and that is going to be our
104:33 - scaling triangle like
104:38 - this okay so in the situation where this
104:41 - here results as a true operation it
104:43 - means that all of these three are of a
104:45 - different length and we write out to our
104:48 - user that he has entered scaling
104:49 - triangle and then the situation where
104:52 - this here results as a no because we
104:55 - have previously determined that these
104:58 - tree are definitely not of the same
105:00 - length and then we have in this
105:02 - condition here determined that these Tre
105:05 - are also not of a different length what
105:08 - is left is that the two of these two of
105:12 - these three sides are going to be of the
105:15 - same length and that is going to be the
105:17 - situation where we write out to our user
105:20 - well I can copy this
105:24 - and we write to our user that he has
105:27 - entered isoceles triangle so let me
105:31 - write that
105:34 - out okay so these three are three
105:38 - potential end points of our program so
105:41 - three potential solutions to our problem
105:44 - and after we write out to our user this
105:47 - or this or this I'm going to really put
105:51 - this one diamond shape just to indicate
105:54 - that our decision has now come to an end
105:58 - we have solved this problem and we are
106:00 - going to join these pads in this shape
106:03 - here so I'm going to put this and this
106:10 - like this so now after we have decided
106:14 - whether whether it's an equilateral
106:16 - triangle or scaling or isoceles I can
106:19 - now say say you can resume the execution
106:21 - of my program normally so whatever I put
106:24 - after this shape here is going to be
106:26 - executed in either this case or this
106:29 - case or this case and what is going to
106:31 - be happening after the shape here is
106:34 - just stop so our program is going to
106:36 - stop but you can put a lot of code here
106:38 - if you need to so I'm going to say
106:42 - stop
106:44 - and let me delete this really I don't
106:46 - need it okay let's explain one more time
106:50 - this diagram so after our program start
106:52 - Parts our user should enter a b and c
106:56 - which represent side lengths of a
106:57 - triangle and I have used this float
107:00 - shape since since those side lines can
107:02 - be uh decimal point numbers and after
107:05 - our user has entered that we come to
107:07 - this decision Point here and what we
107:09 - want to decide here is first thing we
107:11 - want to check whether all of these three
107:14 - variables are of the same value so
107:16 - whether he has entered three same
107:18 - lengths for a triangle sides and in case
107:22 - that this here results as a true
107:24 - operation we are going this way and we
107:27 - write out to our user that he has
107:29 - entered equilateral triangle and after
107:31 - that we go this way and our program
107:35 - stops in the situation where this here
107:38 - results as a no operation we want to
107:41 - check something else so we are going
107:43 - this way and we come to another decision
107:45 - point and here we want to decide whether
107:48 - our user has entered a triangle that has
107:52 - all three three different side lengths
107:54 - so after we have checked that they are
107:57 - not equal we want to check whether all
108:00 - of three variables are of a different
108:03 - value and in case that this condition
108:05 - here results as a yes operation that
108:08 - means that he has entered scaling
108:10 - triangle but in case that this here
108:13 - results as a no operation we can now
108:16 - clearly say that he has entered isoceles
108:19 - triangle because we have checked here
108:22 - that these three sides are not the same
108:25 - and we have checked here that these
108:27 - three sides are not different so all of
108:30 - them are not difference and that means
108:32 - that two of them have to be equal and in
108:35 - that situation we go this way and we
108:36 - write out to our user that he has
108:38 - entered isoceles triangle and now we can
108:42 - go this way and you can see that in this
108:44 - situation as well our program
108:47 - stops here I have opened my flowchart
108:50 - and my visual studio so that we can just
108:52 - translate this diagram into our C++ code
108:56 - so the first thing here is our user
108:58 - enters our a b and c side length so
109:01 - let's
109:02 - declare three variables of type float
109:05 - and let's call them a b and c and now
109:09 - I'm just going to write out a message to
109:11 - my user so that he knows what he should
109:13 - enter so let's say C out and please
109:16 - enter a and then B and then C like
109:21 - this and then let's let's use our C in
109:23 - command so that he enters his values
109:27 - okay let's say first thing that our user
109:30 - uh enters is going to be stored inside
109:32 - my a variable after that what he enters
109:36 - please store that inside my B variable
109:38 - and then the third value that he enters
109:40 - is going to be stored inside my C
109:42 - variable so now that we have entered our
109:45 - side lengths of a triangle we come here
109:48 - so to a decision point and we said that
109:50 - we represent this with if else statement
109:54 - so I'm going to write here if and then
109:58 - inside these parentheses I'm going to
110:01 - say this condition here so please check
110:06 - like this please check if my a is equal
110:08 - to my B and then also check is my b
110:12 - equal to my C like this and if this this
110:17 - here this expression here results as
110:20 - true expression I'm going to execute one
110:22 - block of code and that block of codee is
110:25 - going to be this one here but if this
110:28 - expression here results as a false
110:32 - expression okay I am going to execute
110:35 - another block of code and that block of
110:36 - code we represent with our else
110:39 - statement like this
110:43 - okay and then let's write this yes
110:47 - situation so let's write here see
110:51 - out equilateral Al triangle
110:57 - so like this oops you should put that
111:02 - not in a quotation marks okay so in this
111:05 - situation where these three side lengths
111:08 - are equal we write out to our user that
111:10 - he has entered equilateral triangle but
111:13 - in the situation where this here results
111:15 - as false we have this else block to
111:17 - execute and let's find out what is
111:20 - inside our else block so it is this code
111:24 - here and that is another if else
111:26 - statement so this if else statement
111:29 - statement is really nested inside this
111:32 - one here so it is nested inside this
111:35 - else block so here in these brackets
111:38 - here we are going to put another if El
111:42 - statement so let me write out if and
111:45 - then inside these parenthesis we put our
111:48 - condition from this decision here so
111:50 - from this diamond shape here and I'm
111:52 - going to write out please check if my a
111:55 - is not equal to my B and then is my a
112:00 - not equal to my C also and then is my b
112:05 - not equal to my C so in this condition
112:10 - here we check whether all of these three
112:13 - variables have different values here and
112:18 - if they do if this condition results as
112:20 - a true expression
112:23 - I'm going to write out let me just copy
112:25 - this and then we are going to adjust it
112:28 - I'm going to write out that my user has
112:31 - entered a scaling triangle as you can
112:33 - see here so when this goes in a yes way
112:37 - we write out that
112:40 - message so if this results as a true we
112:43 - write out that our user has entered
112:45 - scaling triangle but if this here
112:48 - results is a false then we are going to
112:51 - write out that our user has entered
112:54 - isosceles
112:56 - triangle and let me copy
112:59 - this like
113:03 - this okay
113:06 - so we have nested this if else statement
113:10 - inside this else block so this if else
113:13 - statement is going to execute only in a
113:16 - situation where this here results as a
113:18 - false F false expression so this code
113:23 - here if you find it a bit unreadable I
113:24 - want to show you one trick so one rule
113:26 - that you can really follow and that is
113:29 - if you have only one command under this
113:32 - if or else statement you don't need to
113:35 - use these brackets so you don't need to
113:37 - say that you are going to execute a
113:39 - block of code since you are not you are
113:40 - going to execute only one command so you
113:43 - can really delete th this here like this
113:47 - and then also here since we have only
113:49 - one command both here and here we we can
113:52 - delete these brackets here like
113:57 - this okay so now this code is a bit
114:01 - easier to
114:02 - read
114:04 - okay now as you can see from this
114:07 - diagram here it is literally translation
114:11 - of this here and vice versa so this code
114:13 - here is a translation of this diagram
114:16 - here and what it means is when our user
114:20 - enters three values for our sides of a
114:22 - triangle first we are going to check
114:25 - whether all of these three sides are
114:27 - equal if they are I'm going our program
114:30 - is actually going to say that our user
114:33 - has entered equilateral triangle but if
114:35 - this here results as false then we are
114:38 - going to our else block and then inside
114:40 - that else block we are going to Nest
114:43 - another if else so we are going to check
114:45 - another condition we are going to uh
114:47 - execute this if else here and this if
114:50 - else here is going to check for
114:52 - following so it is going to say please
114:55 - check if all of these three variables
114:58 - are different values so if all three
115:01 - sides of a triangle have different
115:03 - lengths and if they do we can say that
115:05 - that is a scaling triangle but if they
115:08 - don't then since we have already checked
115:11 - that they are all that all of them are
115:13 - not equal and also we have checked here
115:16 - that all of them are not different we
115:19 - can say now that definitely two of these
115:22 - variables are equal and that means that
115:25 - our user has entered isoceles triangle
115:29 - and that is the program that we had here
115:34 - okay so I hope you like this video and
115:36 - if you did this is a strong call to
115:38 - subscribe to my channel and to share it
115:40 - with anyone else who would like to learn
115:42 - programming and I'm going to see you in
115:44 - my next video bye hi everyone welcome to
115:48 - another video of C++ for beginners in
115:50 - this video I wanted to talk about a
115:52 - operators in C++ and we are going to
115:54 - cover the ones that are used most of the
115:56 - time but I'm also going to make a
115:58 - separate video for certain operators
116:00 - that have specific use in C++ so in this
116:03 - video we will talk about the ones that
116:04 - are used most of the time and that you
116:06 - really need to know and understand and
116:08 - also make sure to watch the entire video
116:10 - because I do have some important tips to
116:12 - give you when it comes to this that you
116:14 - really need to understand and that you
116:16 - will find Handy for your future progress
116:19 - in learning of
116:20 - programming the first thing that I
116:22 - wanted to explain is what are operators
116:25 - you can understand operators as special
116:27 - type of functions that are used to
116:30 - perform certain calculations on
116:32 - arguments or operant and then based on
116:35 - those arguments and on that calculation
116:37 - they give you a new value so the first
116:40 - type of operators that I want to talk
116:42 - about are arithmetic operators and you
116:46 - are probably familiar with most of these
116:49 - so there is operator of adding and and
116:52 - subtracting multiplying dividing and
116:56 - also one more operator that you may not
116:58 - be familiar with which is the modulo
117:01 - operator so all of these are arithmetic
117:05 - operators and let me give you an example
117:07 - of how these are used so I'm going to
117:09 - say C out and then let's write out the
117:13 - result of 5 + 2 and let's add one end
117:18 - line okay so this here is the operator
117:21 - of adding and then these two are operant
117:26 - or arguments and this here is going to
117:28 - perform certain calculation and then
117:30 - write that out to my
117:32 - console so if I run my program we get
117:35 - the expected result which is seven so
117:37 - these really behave as you would expect
117:39 - them to behave in
117:41 - maths but there are certain rules that
117:44 - are specific to programming and that I
117:46 - want to mention so this operator here
117:50 - operator of dividing let me give you a
117:53 - simple example if I say C out and then
117:58 - five divided by two and I add end line
118:03 - what do you expect to see in this line
118:05 - here write that in the comments down
118:07 - below now I'm going to run my program
118:10 - and you see that the result that I've
118:13 - gotten from this line here is two but
118:16 - why has that happened we know that five
118:18 - divided by two is
118:19 - 2.5 well there is a certain rule in
118:23 - programming that says that the result of
118:26 - dividing two whole numbers like this so
118:29 - five is whole number and then two is
118:31 - also whole number is also going to be
118:33 - represented as whole number so even
118:36 - though the result of dividing D2 is 2.5
118:39 - that 0.5 cannot really be put inside uh
118:43 - integer variable so it cannot be put
118:45 - inside integer container so just two can
118:49 - can be put here and that point two is
118:51 - really lost if you want to show the real
118:54 - result of dividing these two what you
118:56 - have to do is you have to make one of
118:59 - these two or both of them off a
119:02 - different type and that type is going to
119:03 - be decimal point number so float or
119:06 - double so if you put here
119:09 - 2.0 or you put here
119:12 - 5.0 then in this case you are going to
119:16 - get the result represented as decimal
119:19 - point number so you can use it like this
119:22 - or you can make just one of these of a
119:24 - floating Point type so you can say also
119:27 - like this and then if I run my program
119:30 - now you see that now I have got the
119:33 - expected result so
119:35 - 2.5 that is one rule that you really
119:37 - need to know when it comes to this
119:39 - division
119:41 - operator and another tip that I want to
119:43 - show you is this operator of
119:46 - modulo so how do we use this modulo
119:50 - operator this example here here that
119:52 - I've just shown you shown you let me
119:54 - return this to this situation where I've
119:56 - been dividing um two whole numbers and
120:00 - we've just seen that 5 ided by two is
120:04 - going to result as two and that one that
120:07 - remains we can get that one really with
120:10 - this operator here so if you say C out
120:14 - and then five modulo
120:18 - 2 add end line this operator here is
120:22 - going to give you the remainder of
120:24 - dividing two whole numbers which are
120:26 - these two so the result of this
120:29 - operation is going to be that one so let
120:33 - me run my program and you see that we
120:36 - have gotten that expected result so 5
120:39 - divided by two when it comes to whole
120:41 - numbers if you're dividing whole numbers
120:43 - the result is also going to be whole
120:45 - number and in this situation it's going
120:46 - to be two and then that remainder after
120:49 - dividing two whole numbers you can get
120:51 - with this modulo operator and the
120:53 - remainder after after dividing five with
120:56 - two is one and you get it with this
121:00 - operator here so these five are really
121:05 - arithmetic operators and these are these
121:08 - are also called binary arithmetic
121:10 - operators why binary well because they
121:12 - are all used with two up runs they
121:15 - perform their calculation on two operant
121:19 - there is also another type of arithmetic
121:21 - operators in C++ that are used or that
121:25 - perform calculations on only one operant
121:28 - and those are unary
121:31 - operators the examples of unary
121:33 - operators in C++ are this operator here
121:37 - which is operator of increment and then
121:40 - this operator here which is the operator
121:42 - of decrement so how these are used let
121:46 - me give you example so let's create a
121:48 - variable of type inth and let's call it
121:51 - counter
121:54 - and I'm going to assign to that variable
121:56 - a value of seven for example so how this
122:00 - operator of increment works is it really
122:03 - increases the value of your variable by
122:05 - one so if I say
122:09 - counter counter
122:11 - Plus+ what this operator is going to do
122:14 - it's really going to add plus one to my
122:16 - counter variable so 7 + one it should in
122:21 - this line here increase value of my
122:22 - counter variable to eight and let's
122:25 - prove that oops see
122:28 - out
122:30 - counter and then let's add one end
122:35 - line okay if I run my program you see
122:38 - that we've got expected result so eight
122:42 - we've declared a variable of type in
122:44 - called counter we've given it a value of
122:46 - seven and then in the next line we
122:48 - applied this increment operator to it
122:51 - which had increased its value + one so
122:54 - eight and then after we write out that
122:56 - value of that variable we got our result
122:59 - so that is how this increment operator
123:01 - is used this decrement operator so
123:06 - counter minus minus this decrement
123:09 - operator here Works uh reverse so it
123:13 - really subtracts one from this variable
123:15 - here and if I copy this line here and
123:20 - then paste it after this line here our
123:23 - counter should be decreased by one so
123:25 - the value of our counter should really
123:27 - again be seven and if I run my program
123:32 - oops like this you see that we've gotten
123:35 - our seven so we've gotten the expected
123:37 - result however there are specific rules
123:40 - when it comes to these increment and
123:42 - decrement operators and let me explain
123:44 - what I mean on another example so I'm
123:47 - going to create another variable of Type
123:50 - L int call it counter two and let's
123:54 - assign it also a value of seven and what
123:56 - I want to do with this variable here is
123:59 - I want to write out its value but I want
124:02 - to write out and increment its value in
124:05 - a single line so I want to do this so
124:07 - see out counter to
124:12 - Plus+ and I'm missing this red Direction
124:14 - sign here okay so what are you expecting
124:18 - to see in this line here we've seen that
124:21 - this line here has resulted with eight
124:24 - and this line here should also result in
124:26 - eight let's
124:28 - see okay run my
124:31 - program and it didn't in this line here
124:34 - we have written out seven but why has
124:36 - that happened well this operator here is
124:41 - increment operator but it is really post
124:44 - increment operator and what that means
124:47 - is that whatever operation needs to be
124:49 - performed on this variable is going to
124:52 - happen first and then this increment
124:55 - operation is going to happen so that is
124:58 - called po increment another type of
125:02 - increment is pre-increment and it is
125:04 - used like
125:07 - this okay and this pre-increment means
125:12 - that whatever operation needs to happen
125:15 - on this variable here first I'm going to
125:18 - increment it and then I'm going to
125:20 - perform that operation
125:22 - so if I run my program
125:24 - now you see that we now get our eight
125:27 - same as here and that is because we have
125:30 - used this pre-increment which first has
125:33 - increased our variable and then our
125:35 - variable is written out okay and the
125:39 - same is applied for decrement operator
125:42 - so for example if I say C
125:45 - out counter to minus
125:48 - minus and then oh my God
125:53 - again okay and then if I run my
125:57 - program you see that we have gotten the
126:00 - same value for this line and this line
126:02 - so eight and why that has happened is
126:05 - because we have used this post decrement
126:08 - here so first our variable has been
126:10 - written out and after that the value of
126:13 - that variable has been
126:15 - decreased so just to prove that I'm
126:18 - going to say one more time C out and
126:21 - then counter two without any increment
126:25 - or decrement just to prove that uh the
126:27 - value of this variable has been
126:29 - decremented after it has been written
126:32 - out so if I run my program again you see
126:35 - that this line here has resulted in
126:38 - eight and then this line here has
126:39 - resulted in
126:41 - seven
126:44 - okay so you see that our console now is
126:47 - full of some random numbers and it's
126:50 - really making it hard to read so what I
126:52 - want to do is I want to clear out my
126:54 - console but without deleting this code
126:58 - here so how I'm going to do that um I'm
127:02 - going to use a command that is called
127:07 - system and then inside these parentheses
127:09 - I'm going to say
127:11 - CLS which really is going to clear my
127:14 - screen so if I run my program you see
127:17 - that all of our code is still here but
127:20 - console has been cleared so that's
127:23 - because of this command here that's a
127:25 - quick tip if you need to clear your
127:27 - console another type of operators that I
127:30 - want to talk about are relational
127:32 - operators and these are really used to
127:34 - compare the value of two operant so two
127:38 - arguments and relational operators in
127:41 - C++ are following so we have less than
127:44 - and then we have greater than and then
127:47 - less than or equal
127:49 - to and then greater than or equal to
127:54 - then we have just is equal to operator
127:57 - and then we have not equal to so these
128:01 - six are relational operators in
128:04 - C++ and how these are used let me show
128:07 - you in an example so let's say that I'm
128:09 - going to create a variable of type in
128:12 - call it a and let's assign it the value
128:15 - of five and also create another variable
128:19 - that is called B and assign it value of
128:22 - five so now if I say C out and then
128:27 - inside this parentheses I'm going to say
128:30 - please write out if my if my V variable
128:33 - a is greater than my variable B so if if
128:37 - my five is greater than this another
128:41 - five okay and I'm using these
128:44 - parentheses because I want my C out
128:46 - command to know that this here is one
128:49 - expression that first should be
128:51 - calculated and then whatever this
128:53 - expression here results in I'm going to
128:55 - write that out in my cout command so if
128:59 - I run my program now you see that we
129:02 - have gotten zero and if you know about
129:05 - how computers work you know that they
129:08 - work on zeros and ones meaning that zero
129:11 - represents false and then one represents
129:13 - true so in this situation we have gotten
129:16 - the result of false so when I ask my
129:19 - computer is my a greater than my be so
129:22 - is five greater than five it says false
129:26 - no it is not okay and the same is going
129:29 - to happen if I put here this other
129:31 - operator of less than like this but if I
129:36 - for example put less than or equal to so
129:40 - this operator here and I run my program
129:43 - again you see that now we have gotten
129:46 - the result of one so that is true that
129:49 - is what our computers computer considers
129:51 - as true so our five is less than or
129:55 - equal to five which is correct and even
129:59 - better would be if we say just is equal
130:02 - to and in this situation also we are
130:04 - going to get true as a result like this
130:09 - because five is equal to five and then
130:13 - how we use this operator here is like
130:16 - this so you can say is my a not equal to
130:20 - my b and your computer really hears is
130:24 - my five not equal to my five and the
130:28 - response to that is going to be no it is
130:31 - false because these two are equal it's
130:34 - the same number even though it's held by
130:35 - two different
130:37 - variables okay I hope you understood
130:40 - these relational operators and there's
130:43 - also one tip that I want to give you
130:44 - here and that is you see this comma sign
130:46 - here this is also operator in C++ and it
130:50 - is not really ational operator but it is
130:53 - binary operator and how this operator is
130:55 - really used because we have seen it
130:57 - before without knowing that it was an
130:59 - operator it is used as follows so in
131:03 - this line here we have said please
131:04 - create a variable of type int call it a
131:08 - and assign it value of five and then
131:11 - also so that is the purpose of my comma
131:14 - so also create another variable of type
131:16 - int call it B and assign it value of
131:21 - five so my comma in this situation is
131:24 - operator and separator as well so it is
131:28 - pretty intuitive so before we continue
131:31 - let's add one more of these clear screen
131:33 - commands
131:35 - here and the next type of operators that
131:37 - I want to talk about are logical
131:39 - operators and there are three of those
131:42 - so we have logical and and then logical
131:45 - or and then also not operator so these
131:50 - three are logical iCal operators and
131:52 - they are usually used to combine two or
131:55 - more conditions into one single
131:57 - condition and I'm going to show you that
131:59 - on an example and let's use for that
132:01 - example these variables here let's just
132:04 - change the value of our B to eight for
132:07 - example so what I want to do is I want
132:10 - to write
132:11 - out following so is my a is my a equal
132:16 - to five and then also is my b equal to
132:20 - five
132:21 - I want to write out the result of this
132:23 - expression here and you see that we have
132:25 - used our end operator to combine these
132:28 - two expressions so if I run my program
132:32 - you see that the result of this is false
132:35 - so that is the nature of our end
132:37 - operator it really works like this it
132:40 - says please check is my a equal to five
132:43 - yes it is and then also check is my b
132:47 - equal to 5 no it is not it is 8 so then
132:51 - this operator says okay whatever then
132:53 - this whole expression is going to be
132:54 - false because this operator here needs
132:58 - both of its oper so this here and then
133:01 - this here also both of these need to be
133:04 - true in order for this whole expression
133:06 - to result as true expression that's the
133:09 - nature of this end operator however
133:12 - there is one more forgiving operator in
133:15 - C++ and that is this operator here so
133:18 - this or operator and if if I place that
133:22 - here instead of our end operator and I
133:24 - run my program
133:26 - again you see that this time we got
133:28 - different result now we have true and
133:32 - that is the nature of our or operator so
133:35 - it says please check if this is true or
133:40 - this here is true whichever of these
133:41 - results as true then I'm going to be
133:44 - true expression only in the situation
133:47 - where this here is false and also this
133:49 - here is false I'm going to result as
133:52 - false in any other situation this here
133:55 - is going to be true so that is the
133:57 - nature of or operator and then we have
134:01 - also this not operator which really
134:03 - negates whatever comes after it so if I
134:07 - put it here for example you see that
134:09 - you've seen that previously this
134:11 - expression here has resulted as true
134:14 - expression now that I negate it we are
134:18 - going to get false so that is our not
134:22 - operator
134:24 - here
134:25 - okay and there is also one more thing
134:28 - that I want to explain when it comes to
134:31 - the procedence of these operators which
134:34 - means priority of these operators so
134:37 - which operator types have the biggest
134:40 - priority uh the biggest priority have
134:43 - arithmetic operators after that come
134:46 - these relational operators and then the
134:50 - smallest priority already have these
134:52 - logical operators so let me show you
134:54 - that on an example let's just comment
134:57 - this very quickly and let's add another
135:00 - line but the previous one that we had so
135:05 - this here like this that is the
135:08 - operation that has resulted as false so
135:11 - is my a equal to five and then is my B
135:13 - also equal to five and this has resulted
135:16 - as false but if we for example say it
135:19 - like this what do you think that this
135:22 - expression here is going to write
135:25 - out so if I run it you see that we have
135:28 - gotten one why is that so well as I've
135:31 - said the biggest priority have
135:33 - arithmetic operators so this expression
135:36 - here is going to be executed first so 5
135:39 - + 3 after that priority have these
135:42 - relational operators so this operator
135:44 - here and this operator here so after
135:48 - that comes logical operation so so this
135:51 - expression here is going to be really is
135:53 - my a equal to 5 yes it is and then also
135:57 - is my b equal to eight and the answer to
136:02 - that is also yes so now both of these
136:05 - operant are true and our end operator is
136:09 - satisfied now and it's going to result
136:12 - as true operation this whole expression
136:15 - so you need to remember that the biggest
136:17 - priority have arithmetic operators so
136:20 - these
136:21 - here so these here binary and unary
136:26 - arithmetic operators after that we have
136:29 - our relational operators and then the
136:32 - least priority have these logical
136:35 - operators here let's add one more of
136:38 - these clear screen commands before we
136:40 - talk about the last type of operators
136:43 - that I want to cover in this video and
136:44 - those are operators of assignment and
136:47 - there are six of those and there are a
136:50 - follow so operator that just assigns
136:53 - value and then operator that adds and
136:56 - assigns and then operator that subtracts
136:59 - and assigns multiplies and assigns
137:02 - divides and assigns and modulates and
137:06 - assigns so these six are operators of
137:10 - assignment and let me show you how they
137:12 - work so first I'm going to create a
137:14 - variable of type end and let's call it X
137:17 - and let's assign it a value of for
137:21 - example
137:22 - five okay so this here is example of
137:27 - this assignment operator here and that
137:30 - is how it works it assigns whatever is
137:32 - on the right to your variable on the
137:35 - left so that is the direction of
137:37 - Association it really says whatever is
137:39 - on my right side Please assign that to
137:41 - my left side and let me show you know
137:45 - how these here work because they're a
137:47 - bit more complex so if I say for example
137:51 - x + = 7 like this what this expression
137:57 - here is going to do well let me write
138:00 - out one more expression and that is X =
138:04 - x + 7 so this expression here and this
138:09 - expression here are just the same this
138:12 - is just shorter way to write this here
138:16 - and what this here does well this is
138:19 - expression that is not valid in
138:21 - mathematics but in programming it is and
138:23 - it does following so it
138:26 - says please whatever is on my right side
138:29 - assign that to my left side and why it
138:32 - does that well because this arithmetic
138:34 - operator here has priority over this
138:37 - assignment operator so if you remember
138:39 - when we were talking about priority
138:41 - these assignment operators have the
138:43 - lowest priority of all so whatever is on
138:46 - my right side that is x + 7 is going to
138:49 - be assigned to my X variable so 5 + 7 is
138:54 - going to be equal to 12 and then that is
138:57 - going to be assigned to your X variable
138:59 - in this line here and this expression
139:01 - here is really short way to write this
139:05 - here okay so I'm going to comment this
139:08 - out and if I write the value of my X
139:14 - now we are expecting to see 12 and it is
139:18 - the result that we have gotten so
139:21 - this x +al 7 is just going to do this so
139:26 - this expression here so it's going to
139:28 - add to my X this number here and the
139:32 - same applies to these operators here so
139:35 - this one that subtracts and then assigns
139:38 - or multiplies and assigns divides and
139:41 - modulates so if you say for example x
139:45 - minus equal to 7 then that is really
139:48 - going to result as X is equal to x minus
139:53 - 7 and then that right side is going to
139:56 - be assigned to your left variable
139:58 - because arithmetic operators have
140:00 - priority over these operators of
140:03 - assignment and if I run my program again
140:06 - it really sees 5 - 7 and that is minus 2
140:12 - so I hope that you have understood these
140:14 - examples that I've just given you and
140:16 - I'm also going to include some more
140:18 - examples at the end of this video but
140:20 - tricky want so that you can be sure that
140:22 - you have really understood these
140:24 - operators in C++ because they are used
140:27 - very often and you have to understand
140:29 - them in order to continue with your
140:31 - progress on a programming path so make
140:33 - sure to do those examples on your own
140:35 - and if you come across any problems or
140:38 - you have any questions that are related
140:39 - to this video write those in the
140:41 - comments down below and I'm going to
140:42 - answer them I'm going to help you and if
140:45 - you likeed this video make sure to
140:47 - subscribe to my channel and also click
140:49 - the Bell icon so that you are are first
140:50 - to be notified when I publish my next
140:52 - video and I'm going to see you in my
140:55 - next video
141:01 - bye hi guys welcome to my channel in
141:04 - this video I wanted to answer a question
141:07 - that I recently got and that is a
141:09 - question that is often asked on job
141:10 - interviews and also students get it on
141:13 - their exams and that is a question on
141:15 - how you can swap the value of two
141:18 - variables I'm going to give you two ways
141:20 - to solve this problem but let me just
141:23 - explain what I mean by this so I'm going
141:25 - to copy the text of this problem here
141:30 - like
141:31 - this and let me say that I have one
141:35 - variable which is going to be called a
141:38 - and that variable is going to hold value
141:40 - of 20 let's say and then I have another
141:44 - variable which is going to be called B
141:46 - and that variable holds value of 10 and
141:49 - now I need to switch the value so to
141:51 - swap the value of these two variables I
141:54 - want my a to hold whatever my B is
141:56 - holding and then I want my B to hold
141:59 - whatever my a is holding so how we are
142:03 - going to do that for the first
142:05 - explanation I will need something so let
142:07 - me get it so here I have two glasses and
142:11 - inside this left glass I have my green
142:14 - juice and then inside this glass I have
142:17 - just plain water and the question that
142:20 - we have in our our Visual Studio is
142:22 - equivalent to a question how we can swap
142:25 - the content of these two glasses and to
142:28 - solve that problem I'm going to use
142:31 - another glass so a temporary glass and
142:35 - that is this one here and I'm sorry guys
142:37 - I know this is not a glass it's a Shaker
142:39 - but it will do for this explanation so
142:42 - what I'm going to do is I'm going to
142:44 - take this this glass this variable and
142:47 - I'm going to put its content inside this
142:50 - third glass this temporary
142:53 - glass okay and then when I have saved
142:58 - the value of this glass inside this
143:00 - temporary glass what I can do is I can
143:04 - put my green juice so the content of
143:06 - this glass inside
143:09 - here
143:11 - okay this is a bit more complex in real
143:15 - life than in programming so once you do
143:19 - that
143:20 - you have saved the value of this glass
143:23 - here so the content of this glass here
143:25 - inside this glass and now what we are
143:28 - left to do is just to put whatever our
143:31 - temp variable our Temp Glass was holding
143:34 - inside this glass here and now we have
143:37 - successfully accomplished to solve this
143:40 - problem so we have switched the content
143:42 - of these two glasses and let's just
143:44 - translate this into our
143:47 - code now that I have explained the
143:49 - algorithm to solve this problem we are
143:52 - just going to translate that algorithm
143:54 - into C++ code so the first thing that
143:57 - I'm going to do is I'm going to create a
144:00 - variable a temporary variable which I'm
144:02 - going to call Temp and inside that temp
144:06 - variable I'm going to put whatever my a
144:08 - is holding so I'm going to say that my
144:11 - temp holds now whatever is inside my a
144:14 - variable and since we have our a
144:17 - variable free now to hold something else
144:19 - I'm going to put my B value inside my a
144:24 - so now my a is going to hold whatever my
144:26 - B is holding and now that we have saved
144:29 - the value of our B inside our a variable
144:33 - we can put inside our B whatever our
144:36 - temp variable is holding so that is the
144:41 - value that previously was inside our a
144:43 - variable and this here is really the
144:46 - algorithm to solve this problem using a
144:49 - third VAR variable and let's just
144:51 - quickly add a c out so that we can see
144:55 - what we have done so our a is equal to a
145:00 - and then our B is equal
145:05 - to RB and let's add end line like this
145:11 - and I'm going to add just a comma sign
145:14 - here okay and if I run the program you
145:18 - see now that here we have a is equal to
145:23 - 20 and B is equal to 10 and now we have
145:25 - successfully swapped the value of these
145:27 - two variables so now my a is holding 10
145:31 - and then my B is holding 20 which
145:34 - previously was inside my a variable and
145:38 - this is a solution for our problem using
145:40 - a third variable but this question is
145:43 - often asked in another way and that is
145:46 - how you can swap the value of two
145:48 - variables without using a third variable
145:51 - and now I'm going to explain that so let
145:54 - me very quickly delete
145:56 - this until here okay and in order to
146:01 - solve this problem without using third
146:03 - variable you will have to think in a
146:06 - more mathematical way and the solution
146:09 - for this is going to be the following so
146:11 - the first thing that I'm going to do is
146:13 - I'm going to say okay let's say that my
146:16 - a variable is going to hold whatever my
146:19 - a is holding holding and I'm going to
146:22 - add whatever my B is holding also and
146:25 - this expression here would be really
146:27 - incorrect in any mathematics but in
146:30 - programming this is this is a valid
146:32 - expression and it means this here
146:35 - whatever this expression results in I'm
146:37 - going to assign that to my a variable
146:41 - and this here is whatever my a is
146:43 - holding plus whatever my B is holding
146:46 - assign that to a so that is going to be
146:49 - a so 20 + B 10 that is equal to 30 so
146:54 - now in this line here my a is going to
146:57 - hold the value of 30 and then in the
147:02 - next line let's say now my B is going to
147:06 - hold whatever my a is holding and then
147:10 - subtract whatever my B is holding from
147:13 - that so in this line here I'm going to
147:16 - say store inside my B the result of this
147:19 - expression here and this expression will
147:23 - result in following a so
147:26 - 30 minus b - 10 that is going to be 30 -
147:30 - 10 20 so in this line here my B is going
147:34 - to hold the value of 20 and then what we
147:38 - are left to do is just to put the
147:42 - correct value inside our a and that is
147:44 - going to be a = to a minus B this means
147:51 - whatever my a is holding at this very
147:53 - moment and that is
147:55 - 30 minus whatever my B is holding at
147:59 - this very moment and that is 20 and guys
148:02 - 30 minus 20 is going to result in 10 and
148:05 - our a is going to get the value of 10 in
148:08 - this line here so now if I write out C
148:13 - out a is equal to a and let's add and
148:19 - line and then C out B is equal to
148:26 - B and if I run my
148:29 - program you see that I'm going to get
148:32 - the expected result so my a now is
148:35 - holding whatever my B was holding so 10
148:38 - and then my B is holding this value that
148:42 - previously was inside our a variable
148:45 - here so we have solved this problem in
148:48 - two ways so with or with without a third
148:51 - variable so if you found this video
148:53 - helpful make sure to like it and to
148:55 - subscribe to my channel and also any
148:57 - questions that you have leave those in
148:59 - the comments down below and share this
149:01 - video with anyone who'd like to learn
149:03 - programming and I'm going to see you in
149:04 - my next video and also guys one question
149:07 - for you if you have any recipes any
149:11 - algorithms on how you can make green
149:13 - juice taste and smell good please make
149:16 - sure to write those in the comments down
149:17 - below bye hi guys welcome to my channel
149:21 - welcome to another video of C++ for
149:23 - beginners I just got an idea of a simple
149:26 - and fun program that I can show you how
149:28 - you can build and since I'm a bit of a
149:31 - fitness Enthusiast myself if you haven't
149:34 - noticed uh I wanted to show you how you
149:37 - can build your own body mass index
149:39 - calculator so stay tuned make sure to
149:41 - subscribe and let's build our own BMI
149:44 - calculator okay so here is the text of
149:47 - my task and what we are going to build
149:49 - is BM calculator so first I want to
149:51 - explain what is BMI calculator it is
149:54 - body mass index calculator that is going
149:57 - to tell you whether you are underweight
149:59 - or normal weight or you are overweight
150:02 - depending on your weight and your height
150:05 - and here I'm going to use weight in
150:07 - kilograms and then height in meters so
150:10 - if someone else wants to adjust this
150:11 - program so that it can work with pounds
150:13 - feets and inches you can write out that
150:16 - code in the comments down below and the
150:18 - first one that gets it right I'm going
150:20 - to pin that comment so that everyone
150:21 - else can use it and see it okay so we
150:24 - are going to use this formula here which
150:27 - is used to calculating your BMI in
150:30 - metric system so another thing that I
150:32 - want to mention is this these three
150:34 - categories here there are also some more
150:37 - categories that you can really calculate
150:39 - whether you are extremely underweight or
150:41 - you are extremely overweight but these
150:44 - three should be enough for us to do now
150:46 - and these three I'm going to cover in
150:48 - this code another claer that I want to
150:50 - make is that this BMI calculator
150:52 - probably should not be used by people
150:54 - that have huge amounts of muscle so
150:57 - professional bodybuilders because even
150:59 - though they have muscle that muscle is
151:01 - still weight so even though they are not
151:03 - overweight they will fall in a category
151:05 - of overweight because their BMI is going
151:07 - to be higher but for most of us that
151:10 - don't have a lot a lot a lot of muscle
151:12 - or are leaving normal lives training
151:14 - couple of times a week maybe this is
151:16 - going to be completely okay so let's
151:19 - build our prog program now so here is
151:22 - our tool that we are going to use to
151:23 - draw this diagram so Lucid chart and
151:28 - let's really develop the algorithm for
151:31 - solving this problem and then we are
151:33 - going to translate that diagram that
151:35 - algorithm in C++ code so as you may
151:38 - already know first thing that I'm going
151:40 - to put here is this shape here that is
151:42 - going to indicate the start position of
151:44 - my program this circle shape here and
151:48 - after that we really need two things
151:50 - from our user so two things that he
151:52 - should enter and those are his height
151:54 - and his weight so let's use this funnel
151:57 - shape here that is going to indicate
152:00 - something entering in your program so
152:02 - visual representation that's why I'm
152:04 - using that funnel
152:06 - shape and inside here I'm going to put
152:10 - two things that my user needs to enter
152:12 - and those two things are these two tanks
152:16 - here so his weight and he should enter
152:19 - his weight in kilogram and also his
152:22 - height and let's say that he should
152:24 - enter his height in meters so I'm going
152:28 - to use metric system for this problem
152:31 - okay and let's indicate the flow of our
152:34 - program it should flow like this and
152:38 - after our user has entered his weight
152:39 - and his height there is a simple
152:42 - calculation that our program needs to
152:44 - perform and that calculation is going to
152:46 - be a process for our program so the
152:49 - shape that I'm going to to use for that
152:51 - is this shape here so this shape that
152:53 - says process on it and what our program
152:56 - should process what our program should
152:58 - calculate is it should calculate BMI so
153:02 - I'm going to put here BMI is equal to
153:05 - and then I'm going to put this formula
153:08 - here that is used to calculate
153:11 - BMI okay so it's weight represented at
153:15 - kilog divided by height to the^ of two
153:18 - so I'm going to multiply my height with
153:21 - height okay and this is really the
153:25 - calculation of our BMI and now after our
153:28 - program has calculated this BMI what we
153:31 - are left to do is we should depending on
153:34 - this BMI really write out to our user
153:37 - whether he's underweight or overweight
153:39 - or of a normal weight so we should make
153:42 - a decision depending on this BMI and for
153:46 - that decision we are using this decision
153:48 - shape so this diamond
153:50 - shape and inside this diamond shape I'm
153:53 - going to
153:54 - put I'm going to put a condition and
153:57 - that condition is going to be let's
154:00 - first check whether my BMI is lower than
154:06 - 18.5 like this and in this situation
154:09 - where our user's BMI is lower than 18.5
154:12 - so when this condition here results as
154:15 - yes I am going to write out something to
154:17 - my user and let's me find a shape okay
154:22 - let's rotate this shape and delete is
154:26 - text okay and what I want to write out
154:30 - to my user oh I can make this
154:33 - smaller what I want to write out to my
154:35 - user in the situation where his BMI is
154:38 - lower than
154:39 - 18.5 is I want to write out that he is
154:43 - really underweight so let's put text
154:45 - inside here and let's write out that he
154:49 - is underweight so that is going to
154:51 - happen in this situation oh my God that
154:54 - is going to happen in this situation
154:56 - here let me
154:59 - just okay now it's okay so in this
155:02 - situation where his BMI is lower than
155:04 - 18.5 we are going to write out that he
155:07 - is underweight but in the situation
155:09 - where his BMI is not lower than 18.5 we
155:13 - have to check something else and let's
155:17 - check so let's add another another of
155:20 - these diamond shapes where is it
155:23 - here okay and let's now check whether
155:27 - his BMI is higher than
155:31 - 25 so I'm going to write out BMI greater
155:35 - than
155:36 - 25 okay and that is going to happen in
155:39 - the case that this here results as no
155:43 - and in the situation where user's BMI is
155:46 - higher than 25 that really means that
155:48 - our user is overweight so we are going
155:51 - to write out
155:53 - of okay so we are really going to write
155:56 - out a message to our user so let's copy
155:59 - this shape
156:01 - here which we are using to write out a
156:04 - message to our user so this reversed
156:06 - finnal shape that represents something
156:09 - leaving your program something being
156:10 - outputed from your program so in the
156:13 - case where this calculation here results
156:16 - as true we are going to write out to our
156:19 - user that he is
156:22 - overweight like
156:24 - this okay and let's really adjust
156:29 - this now it's now it looks a bit more
156:33 - presentable okay so first we have
156:36 - checked whether his BMI is lower than
156:38 - 18.5 is if yes we have written out
156:41 - underweight if no we have to check
156:43 - whether his BMI is greater than 25 and
156:46 - if it if it is it means that he's
156:48 - overweight but in the situation where
156:50 - this here results as a no that means
156:54 - that our user BMI is not lower than 18.5
156:58 - nor it is greater than 25 so that means
157:01 - that his BMI is really somewhere in
157:03 - between so between 18.5 and 25 and that
157:07 - is a normal BMI so that is our last
157:11 - possible situation where we are going to
157:13 - write out to our
157:14 - user that he has a normal weight so
157:18 - let's write out
157:20 - normal normal weight
157:23 - okay so after we have covered these
157:26 - three cases cases let's just join our
157:31 - flows into one so I'm looking for this
157:34 - shape here and I'm going to make it
157:37 - smaller delete this text from it and I'm
157:41 - really just going to join these flows
157:44 - inside this shape here let's let's just
157:46 - try to move this here I'm going to
157:51 - delete it and let's say that I'm going
157:54 - to oh no
158:12 - [Music]
158:21 - okay guys I had huge problems trying to
158:23 - adjust some arrows so I had to rewrite
158:26 - this whole diagram and I believe that I
158:28 - made it a bit prettier so here we were
158:33 - explaining that in the case that our
158:35 - user has BMI lower than 18.5 we are
158:38 - going to write out this message to him
158:40 - in the case that his BMI is not lower
158:42 - than 18.5 we are going to check whether
158:45 - it is greater than 25 and if yes we are
158:48 - going to write out that he's overweight
158:51 - if no we are going to write out that
158:53 - he's of normal weight and in each of
158:55 - these three cases we are coming here to
158:58 - this diamond shape here which is just
159:00 - just going to join these three potential
159:04 - situations and after this diamond shape
159:07 - here we are going to write out to our
159:09 - user what his BMI really is because I
159:11 - really want my user to know if he's for
159:14 - example in this situation here or in
159:16 - this situation here I want him to know
159:18 - whether he's BMI is let's say
159:21 - 18.4 so he's not that extremely
159:23 - underweight but he's just a little bit
159:26 - underweight or in this situation here I
159:28 - want him to know whether his BMI is 25.5
159:31 - so he's just a little bit overweight or
159:34 - his BMI is really 35 let's say that's
159:37 - why I I want to write out my BMI to my
159:40 - user his BMI to my user okay so and then
159:44 - we just released upop our program so now
159:47 - I'm going to copy this diagram and put
159:50 - it next to my visual studio so that we
159:52 - can really translate this this diagram
159:54 - here into our
159:56 - code so here I have put this diagram and
159:59 - then also my visual studio and let's now
160:02 - translate this diagram let's translate
160:04 - this algorithm and to code because this
160:07 - here really is an algorithm explanation
160:09 - on how to solve a certain problem so the
160:12 - first thing that needs to happen is our
160:15 - user should enter his weight and his
160:17 - height and for that to happen I first
160:19 - need to declare variables for weight and
160:21 - height and for that I'm going to use
160:24 - type float because his weight and height
160:27 - can be decimal point number so I'm going
160:29 - to say float and then I'm going to say
160:33 - weight and height okay like this and
160:37 - after that let's put a message out to
160:39 - our user so that he knows that he should
160:42 - enter his weight and height so I'm going
160:44 - to say C
160:46 - out weight and let's put that here
160:49 - should enter his weight in kilogram and
160:52 - then
160:53 - also height but he should enter his
160:56 - height in meters like this so that he
160:59 - knows which which system he should
161:02 - use okay after we have written out this
161:04 - message here what I need to do is I need
161:07 - to use my C in command so that I can
161:10 - allow my user to enter weight and height
161:12 - and I'm going to
161:13 - say first thing that my user enters
161:16 - that's going to be stored inside my
161:18 - weight variable
161:19 - and then after that the second value
161:21 - that my user enters is going to be my
161:24 - height so store that in a height
161:26 - variable like this okay and after we
161:30 - have entered weight and height next
161:33 - thing that needs to happen is we need to
161:34 - do this formula here and really
161:37 - calculate our BMI and in order to store
161:40 - this result the result of this
161:42 - expression in our BMI we need a variable
161:44 - for that and that variable is obviously
161:46 - going to be called BMI so let's add here
161:48 - in this line here let's add BMI so I'm
161:53 - going to declare another variable and
161:55 - that variable I'm going to use now and
161:58 - I'm going to say that my
162:00 - BMI is going to be used as follows so
162:04 - I'm going to use this formula here which
162:06 - is our
162:08 - weight divided by our height to the
162:12 - power of two for now I'm going to use
162:16 - use it like this okay and and in this
162:19 - line here we have really calculated our
162:21 - BMI so this code here and now after we
162:25 - have calculated our BMI what we should
162:27 - do is we should really check what is the
162:30 - value of that BMI and for that we are
162:33 - using this shape here which really
162:35 - translates into if if else case so first
162:39 - I'm going to say
162:40 - if and then the first thing that I want
162:42 - to check is if my user's BMI is lower
162:47 - than 18
162:49 - 5 like this and in this situation where
162:53 - his BMI is lower than 18.5 I'm going to
162:56 - execute one line of code so that's why I
162:59 - don't need to put these brackets so I'm
163:03 - going to delete them because I just want
163:04 - to execute one line of code and that
163:06 - line of code is going to be indented
163:08 - here so that it is easier to read and
163:10 - that line of code is really to be going
163:12 - to be a message that I want to write out
163:15 - to my user and that message is going to
163:17 - be that my user is underweight
163:22 - unfortunately okay and let's add one end
163:26 - line like this okay this is in the
163:30 - situation where his BMI is lower than
163:32 - 18.5 in a situation where his BMI is not
163:35 - lower than 18.5 we are going to execute
163:38 - something else so that something else we
163:41 - represent with else statement and I'm
163:43 - going to put that lse statement and what
163:45 - is happening in that else case it is
163:48 - happening another
163:49 - if else so here we have a situation
163:52 - where we need to check something else so
163:55 - here I'm going to put else if so if this
163:59 - here results as no please then check
164:02 - something else and for that we use this
164:04 - else if statement so I'm going to say
164:07 - else if please check if my BMI is
164:11 - greater than 25 then so in this
164:16 - situation we also want to execute one
164:18 - line of code and that line of code is
164:21 - going to be to write out to my user that
164:23 - his BMI is greater than 25 which means
164:26 - that he is overweight so let me copy
164:28 - this message here and we are just going
164:31 - to adjust it so I'm just going to say
164:36 - you are overweight like this okay so if
164:40 - his BMI is less than 18.5 I'm going to
164:43 - write out that he's underweight else if
164:46 - his BMI is not lower than 18.5 I'm going
164:50 - to check whether his BMI is greater than
164:53 - 25 if yes I'm going to write out that
164:56 - he's overweight if no we are also going
164:59 - to execute something else and that that
165:02 - is this situation here so in this case
165:05 - he has a normal weight so let me again
165:08 - copy this message here and let's really
165:12 - put
165:13 - here a normal weight like this okay so
165:18 - in this situation where his BMI is not
165:21 - great not lower than 18.5 nor it's
165:24 - greater than 25 we are going to write
165:26 - out our user that he has a normal weight
165:29 - and with this here with this code here
165:32 - we have really covered this part of
165:34 - diagram here
165:36 - okay and then after this code here
165:40 - executes we really want to write out our
165:43 - BMI to to to the user
165:47 - so we have to this shape here which
165:50 - really translates into our our C out
165:53 - command and we want to write out your
165:57 - BMI
165:58 - is and then let's write out BMI like
166:03 - this okay and this line of code as you
166:06 - may already see from our diagram is
166:08 - going to execute in either this case or
166:11 - this case or this case because after we
166:14 - have finished with this decision part we
166:18 - have executed only this part of codee or
166:21 - this part of code or this part of code
166:23 - here so whichever of these three has
166:25 - been executed after this code here we
166:29 - are going to execute this line here in
166:32 - either this situation or this situation
166:35 - or this situation and that is going to
166:37 - be writing out to my user what his BMI
166:39 - really is and that is the last thing
166:42 - that we need to put so the last part of
166:45 - our code and now if I run my program
166:50 - okay it asks me to enter my weight and
166:54 - my height and my weight is I believe
167:00 - 6 66
167:02 - kilg I think and then my height is
167:09 - 1.75
167:11 - so let's press enter oh no I'm
167:16 - overweight how my BMI is 6
167:20 - 6 okay guys for a moment I thought that
167:23 - I am overweight but I am not definitely
167:27 - this 66 BMI overweight so that means
167:30 - that we have a bug so where are you
167:33 - sneaky little buggy
167:36 - bug well if you can see where our bug is
167:39 - then write that in the comments down
167:40 - below and I already see where
167:42 - potentially our bug could be so this
167:45 - formula here it should really go like
167:48 - this so we should divide our weight with
167:51 - our height to the^ of two which means
167:54 - that we should put parentheses here like
167:57 - this because and that is this
168:00 - calculation here so in this situation
168:03 - our weight is going to be divided with
168:05 - our height and after that that number is
168:07 - going to be multiplied with our height
168:09 - so we are going to get larger BMI than
168:12 - we should really so we should put this
168:15 - code here in parentheses
168:18 - so that was the first bug that really
168:21 - happened in these tutorials okay I'm
168:23 - going to leave this part I'm not going
168:26 - to edited
168:28 - out okay and now if I enter my
168:33 - weight um let's see
168:36 - 66 and then my height
168:41 - 1.75 okay so I am 21.5 that is my BMI
168:46 - and I am off a normal weight
168:49 - so we have really built our BMI
168:52 - calculator and this is the formula that
168:53 - you should use for metric system and if
168:56 - someone else wants to rewrite this
168:58 - program for pounds and inches and um
169:02 - feet you can write that in the comments
169:04 - down below and as I said I'm going to
169:05 - pin that comment up so that everyone can
169:08 - see it if you of course get it right I
169:11 - hope you like this video if you did make
169:13 - sure to write it in the comments down
169:14 - below and I'm going to put more videos
169:16 - like this and also subscribe to my
169:18 - channel and click the Bell icon so that
169:19 - you are first to be notified when I
169:21 - publish a new video share this video
169:23 - with anyone who would like to learn
169:25 - programming or also with Fitness people
169:27 - that would just like to use this program
169:29 - and if you don't know how you can run
169:31 - this program without using using visual
169:33 - studio I'm going to link my first video
169:36 - here and at the end of that video I'm
169:38 - explaining how you can run the program
169:40 - from Windows and that should give you an
169:42 - idea on how you can really share your
169:44 - applications with other people so make
169:47 - sure to subscribe like leave a comment
169:50 - share whatever you want and I'm going to
169:52 - see you in my next video bye hi everyone
169:56 - welcome to my channel welcome to another
169:57 - video of C++ for beginners in this video
170:00 - I wanted to explain the concept of
170:02 - turnery operator also known as
170:04 - conditional operator and also some
170:07 - people call it shorter version of IFL
170:09 - statement it is an important concept
170:12 - that you are definitely going to come
170:14 - across in your programming career and
170:16 - you should understand it and I'm going
170:18 - to explain this concept through building
170:20 - fun and simple program that is going to
170:22 - be a guessing game so let's explain the
170:25 - rules of this game we need to have two
170:27 - users and our first user which I'm going
170:30 - to call host user has to enter a number
170:34 - after that we have to delete that number
170:36 - from our console so that our second user
170:39 - cannot see it and then after that our
170:42 - second user which I'm going to call
170:44 - guest user has to enter his guest so
170:47 - that he can guess what number our first
170:50 - user has entered so this way we can
170:53 - really make a fun program and learn an
170:56 - important concept at the same time and
170:58 - at the end of this video I'm going to
171:00 - give you an idea or multiple ideas how
171:02 - you can really upgrade this program on
171:04 - your own so make sure to watch the
171:07 - entire video now that we have explained
171:10 - the rules of this game let's start
171:11 - building our program and the first thing
171:14 - that we need to do is create two
171:16 - variables since we said that our user is
171:18 - going to be guessing numbers those two
171:20 - variables are going to be definitely a
171:23 - number type and let's say that that type
171:25 - is going to be integer so integer
171:28 - numbers and we need two variables the
171:30 - first one is going to hold our first
171:33 - user number so our host user number and
171:37 - then our second variable is going to
171:38 - hold the number that our guest user
171:40 - enters so let's call those to host user
171:45 - number like this and then the second one
171:48 - let's
171:50 - call guest user
171:54 - number like
171:56 - this okay and now after we have created
172:00 - these two variables the next thing that
172:02 - we need to do is let's write out a
172:04 - message to our host user so that he
172:06 - knows that he should enter a number so
172:08 - let's say see out and let's just
172:11 - say
172:13 - host like this so that our host user
172:16 - really knows that he should enter a
172:18 - number
172:19 - and I'm going to accept that number in
172:22 - my console using the C in command and
172:25 - I'm going to store that number inside
172:27 - our host user number variable so with
172:31 - this line here we have entered our host
172:33 - user number and what we have said at the
172:36 - beginning of this video is that after
172:37 - our host user enters the number we
172:40 - really need to delete that number from
172:42 - our console so that our second user is
172:44 - not able to see it and the command that
172:46 - I'm going to use for that is going to be
172:49 - this command here so I'm going to say
172:51 - system and then I'm going to say
172:55 - CLS which is which is really going to
172:58 - clear our console so clear our screen
173:01 - and now if I run my program let's see
173:03 - how far we have made made this
173:06 - program here we have this line This
173:09 - seventh line which says host user and it
173:12 - expects our host user to enter a number
173:15 - so I'm going to say for example seven
173:17 - and then after I press enter this number
173:20 - here really is deleted so our console
173:23 - has been cleared and now after this we
173:26 - need to ask our guest user to guess the
173:29 - number that our host user has entered so
173:32 - I'm going to stop the program and next
173:36 - we need to write out a message to Our
173:38 - Guest user so I'm going to say guest
173:43 - like
173:44 - this and after that we need to accept
173:48 - what our guest user enters inside our
173:50 - guest user variable so I'm going to copy
173:52 - this line here like this and instead of
173:56 - accepting that value inside host user
173:58 - number I'm just going to change this to
174:01 - guest user number and after this part
174:05 - here we really have both accepted our
174:08 - host user number and our guest user
174:10 - number and now we need to compare these
174:13 - two and see whether our guest user has
174:16 - guessed correctly our host users number
174:19 - so how we can do that if you are
174:22 - familiar with f l statements and I'm
174:25 - going to link that video here and if you
174:28 - are familiar with them that is really
174:30 - one way to solve this problem so you can
174:33 - solve this problem with IFL statement
174:35 - and I'm going to do that and then we are
174:37 - going to really convert that IFL
174:39 - statement inside into a tary operator so
174:44 - how we can solve this with IFL
174:46 - statements well it is quite simple
174:48 - solution so we have to say if and then
174:51 - inside these parentheses I'm going to
174:53 - really compare these two numbers so host
174:54 - user number and guest user number so I'm
174:57 - going to say host user number is equal
175:01 - to guest user number like this and then
175:07 - if this here results as true so if these
175:10 - two if these two numbers are the same we
175:13 - can write out a message to our user and
175:15 - that message is going to be let's say
175:20 - correct like
175:22 - this so our user has guessed correctly
175:26 - but in a situation where this here
175:28 - results as false we can use our else
175:32 - statement and in this else situation
175:34 - let's write out a different message to
175:36 - our user so let's say see out and then
175:40 - inside this these quotation marks let's
175:42 - say failed like this so that in the case
175:47 - where these two are the same number we
175:50 - can write out to our user that he has
175:51 - guessed correctly and then in a
175:53 - situation where these two are not the
175:55 - same we can write out to our user that
175:57 - he has failed in guessing so if I run my
176:00 - program
176:01 - now you see that it expects our host
176:04 - user to enter a number and I'm going in
176:07 - this situation to take the role of both
176:09 - host and guest user so I'm going to
176:12 - enter seven for example and then you see
176:16 - that that seven number has been deleted
176:17 - from our console because of this command
176:19 - here and now our program expects Our
176:22 - Guest user to enter his number and I
176:26 - even forgot what number I entered so
176:28 - let's say that our host user has entered
176:32 - for example
176:33 - 11 and you see that our program says you
176:36 - have failed so you haven't guessed
176:39 - correctly and one more time let's enter
176:42 - for our host user number five for
176:45 - example and then let's say that our
176:47 - guest user also says number five and our
176:51 - program says you have guessed
176:54 - correctly so this is one potential
176:57 - solution for this problem but I wanted
176:58 - to show you how you can solve this
177:00 - problem using Turner operator and now
177:03 - I'm going to comment this code here like
177:07 - this so this is a comment for multiple
177:10 - lines of code and let's really translate
177:15 - this part of code here into a turn
177:19 - operator like
177:21 - this okay so how does theary operator
177:25 - work well it is the only operator that
177:28 - takes three op runs or works on three
177:31 - operands and the first opun is going to
177:34 - be a condition so I'm going to copy this
177:37 - condition here which is is our host user
177:40 - number equal to Our Guest user number so
177:43 - that is going to be the first uun and
177:45 - after that first uun we need to put this
177:49 - question mark and then after this
177:51 - question mark we have the following
177:53 - Behavior if this expression here so if
177:57 - this condition here is true we are going
177:59 - to execute one line of code or actually
178:04 - one part of code and that is going to be
178:06 - this line
178:08 - here but in the situation where this
178:10 - here results as false we are going to
178:13 - execute whatever we put after this
178:16 - column sign so that is going to be our C
178:20 - out failed like
178:24 - this and this is really the Syntax for
178:27 - our Turner operator and as you can see
178:30 - it really is a shorter form of if else
178:34 - statement so this line of code really
178:37 - means please check this condition here
178:40 - and if this condition here results as
178:43 - true execute this part of code here but
178:48 - if this code here results as false
178:51 - please execute whatever I put after my
178:53 - column sign so that is going to be our
178:56 - see out failed and now if I run the
179:01 - program it asks again for our host user
179:04 - to enter the number let's enter number
179:06 - nine for example and then our guest user
179:09 - has to guess the number so let's enter
179:12 - for example number three and you can see
179:15 - that our program says to Our Guest user
179:17 - that has failed in
179:19 - guessing so there are a couple of ways
179:22 - in which you can really upgrade this
179:23 - program and I'm going to give you a few
179:25 - ideas and the first one is for example
179:28 - you don't have to use int type here so
179:31 - you can use different data type data
179:33 - type you can guess characters or you can
179:35 - guess even strings if you know how to
179:38 - and if some of you want to play with
179:39 - that and try that on their own and you
179:41 - get it right make sure to paste that
179:43 - code in the comments down below and I'm
179:45 - going to check it and if you get it
179:46 - right I'm going to pin that comment up
179:48 - so that everyone else can see it so that
179:51 - would be one way of upgrading this
179:52 - program another way to upgrade this
179:54 - program is to make it easier to your
179:56 - guest user and how do I mean easier well
180:00 - you can really limit your host user to
180:02 - enter a number that is going to be in a
180:04 - certain interval for example you can say
180:07 - to your host user that he can enter only
180:10 - a number that is going to be between
180:12 - let's say 1 and 15 or 50 it depends on
180:16 - how difficult you want to make it to
180:17 - your guest user and that would be one
180:20 - way also of upgrading this program and
180:22 - another and the best way of upgrading
180:24 - this program is going to be when we
180:26 - learn loops and when we do that I'm
180:28 - going to link the video here and how you
180:31 - can upgrade this program using Loops
180:33 - well you can give your guest user
180:35 - multiple attempts so you can say for
180:37 - example let my guest user guess three
180:41 - times or five times before I say game
180:43 - over you have failed okay so I hope that
180:48 - you have liked this video and if you did
180:49 - make sure to subscribe to my channel
180:51 - share it with your friends and with
180:53 - other people that would like to learn
180:54 - programming and I'm going to see you in
180:56 - my next video
180:59 - bye hi guys welcome to my channel
181:02 - welcome to another C++ for beginners
181:04 - tutorial and I'm really excited for
181:06 - making this video because this video is
181:08 - going to be a milestone and in this
181:11 - video I'm going to show you how you can
181:12 - build your own calculator application so
181:15 - if you have watched my previous videos
181:17 - and you are also so watching this one
181:18 - and you build this application together
181:20 - with me you should really feel proud of
181:22 - yourself because you have made a great
181:24 - progress so let's build that application
181:27 - now here I have opened my visual studio
181:30 - and let's very quickly explain what we
181:32 - want to do before we start write code so
181:35 - I want my user to enter two numbers and
181:38 - also operation sign and then depending
181:41 - on those two numbers and that operation
181:43 - we want to calculate the result and then
181:45 - write that result to our user so so the
181:48 - first thing that we need to do is we
181:49 - need to declare variables that are going
181:51 - to hold those numbers and that operation
181:54 - sign and since we want our user to be
181:57 - able to enter decimal point numbers so
181:59 - not only integers but decimal point
182:02 - numbers as well we are going to declare
182:04 - variables that can hold decimal point
182:06 - numbers and those can be float and uh
182:09 - double so let's declare float variable
182:12 - for example and let's call it num one
182:16 - which is going to hold our first first
182:18 - number and also another one which is
182:20 - going to be called number two and hold
182:22 - our second number and after we have
182:25 - declared these two let's also declare a
182:28 - variable that is going to hold our
182:30 - operation sign and since that is a
182:32 - character we need to use a character
182:34 - type for that variable so let's say Char
182:38 - and let's call that variable
182:42 - operation like this okay and now after
182:46 - we have created these three variables we
182:49 - can really allow our user to enter his
182:52 - numbers and his operation and we want to
182:55 - do that in the following order so we
182:57 - want to say C in and then first our user
183:01 - has to enter the first number and then
183:05 - after that we want our user to enter the
183:07 - operation sign so let's
183:09 - say operate operation like this and
183:14 - after that our user has to enter the
183:17 - second number and this window here guys
183:21 - this is called Intellis sense and it
183:23 - really makes your code writing easier so
183:26 - you can navigate this list here using
183:29 - your arrows and then you can also use
183:32 - tab key so that it finishes your
183:35 - variable name for you if you want
183:38 - that okay so now we have entered our
183:43 - first number our operation and then our
183:45 - second number as well like this
183:48 - and another thing that I want to write
183:50 - out to my user because this is going to
183:51 - be the best calculator ever let's write
183:54 - that uh title for user so let's write
183:57 - here before he enters anything a quick
184:00 - title so let's say see out and then
184:04 - let's say that it's going to be called
184:06 - code Beauty calculator you can call
184:08 - yours whatever you want
184:14 - so like this and let's
184:19 - add these here so that it looks
184:22 - prettier okay and now if I run my
184:27 - program well you see that it really
184:29 - looks like this and now we are able to
184:34 - enter one number after that we want our
184:37 - user to enter operation like this and
184:40 - then we want to enter the second number
184:43 - like this and then after we press enter
184:45 - our program should really calculate the
184:47 - result of this operation in this current
184:50 - situation it is not really doing
184:52 - anything else because we haven't written
184:54 - code for that okay so now let's solve
184:59 - this problem that we have here so at
185:01 - this point you should really have an
185:03 - idea yourself on how to solve this
185:05 - problem using IF El statements and also
185:07 - nested IFL statements so if you are not
185:10 - familiar with those I'm going to link
185:12 - one of my previous videos here so make
185:14 - sure to watch that video as well but in
185:17 - this this video I want to show you the
185:18 - more appropriate way for solving this
185:21 - particular problem and that is going to
185:22 - be using switch case statement so what
185:25 - is switch case statement well switch
185:28 - case statement is as well as if else
185:31 - statement used when you want to execute
185:33 - a block of code depending on a certain
185:36 - condition so depending on a value of a
185:38 - certain variable but switch case
185:40 - statement is particularly used in a
185:43 - situation where that variable can
185:45 - potentially hold a lot of different
185:47 - values and if you look at our operation
185:51 - variable here you should really notice
185:54 - that this variable can hold six
185:57 - different values and what are those six
186:00 - well our user can decide to enter
186:03 - operation for adding subtracting
186:06 - multiplying dividing modulating and then
186:10 - what if our user does not really want to
186:13 - use our application but he wants to hack
186:15 - it so if he decides that he doesn't want
186:18 - to enter one of these five but he really
186:21 - enters some nonv valid arithmetic
186:23 - operation we should also cover that case
186:27 - so we should really as programmers
186:29 - predict all these six situations and
186:31 - cover all these six
186:35 - cases I'm going to add one end line here
186:38 - so that my text is formatted nicely and
186:42 - then let's really show how this switch
186:44 - case statement is used so the first
186:47 - thing that I want want to write is
186:49 - switch like this and then if you press
186:53 - tab you see that you are getting some
186:56 - default Syntax for this switch case for
186:59 - now I'm going to delete that and I want
187:01 - to show you how you can really write
187:02 - that
187:03 - yourself and inside these parentheses
187:07 - here I want to write out the name of my
187:09 - variable that I want to switch through
187:12 - or switch on and that is going to be my
187:14 - operation variable because depending on
187:16 - the value of this operation variable we
187:18 - are going to perform a different
187:20 - calculation on these two number
187:23 - variables so I'm going to say here
187:26 - operation and then in these curly
187:29 - brackets here we really want to cover
187:31 - all our cases so the first
187:35 - case let's say that our first case is
187:39 - going to be a situation where our user
187:41 - enters minus operator so I'm going to
187:44 - use these single quotes and then inside
187:47 - the single quotes I'm putting the value
187:50 - that our variable can potentially hold
187:52 - and that is this minus operator here and
187:55 - after that I'm going to add this column
187:58 - sign here like this and then after this
188:01 - column sign I really want to put out
188:03 - whatever code I need to execute in the
188:06 - case that our operation corresponds to
188:09 - to this sign here and what I want to
188:13 - execute in this case is I want to say
188:16 - see out
188:18 - and let's WR write out our first number
188:21 - and then let's write out our
188:24 - operation and then let's write out our
188:27 - second number so that our user really
188:29 - gets a night nicely for method text and
188:32 - after that I'm going to add this is
188:35 - equal to sign and here we are going to
188:39 - put really our result and that result is
188:42 - going to be our first number minus
188:45 - because our user has entered this minus
188:47 - minus so our first number minus our
188:50 - second number so let's write out number
188:53 - one
188:55 - minus
188:57 - number number two like
189:00 - this and after we have covered this
189:03 - first case we need to add one more
189:05 - keyword and that is going to be break
189:09 - and this break keyword is really used so
189:12 - that our switch case statement knows
189:15 - where our first case ends so I'm I'm
189:18 - saying here whenever my operation is
189:21 - equal to this sign here you are going to
189:23 - execute this code and you should really
189:27 - stop executing this CA that case when
189:30 - you come to this break statement okay so
189:34 - this is going to be our first case our
189:36 - second case is going to be situation
189:38 - where our user let's say enters this
189:42 - plus sign and in that situation we
189:45 - really want to write out to our
189:48 - user this text here so the same text we
189:52 - want to really write out our first
189:55 - number Plus in this case our second
189:59 - number and then is equal to and then we
190:01 - are going to add really this calculation
190:04 - here so number one
190:06 - plus number two like this and in this
190:11 - situation as well we want to add this
190:14 - break statement at the
190:16 - end like like this okay so these are two
190:21 - potential cases and now I'm going to
190:24 - really write out the rest of them so I
190:27 - have written out these remaining cases
190:31 - and in each of these cases we really
190:32 - want to write out our user his first
190:35 - number after that his operation second
190:38 - number and then this equal sign and then
190:41 - in each of these cases we are performing
190:43 - adequate calculation so we are
190:45 - performing that operation that are user
190:47 - has entered and writing that result out
190:50 - to our user and after each of these
190:53 - cases we really need to put this break
190:55 - statement and you really have to put
190:57 - this break statement because if you
190:58 - don't you are going to get your program
191:00 - to behave as you don't want it to and as
191:04 - you can see in this situation here so in
191:06 - this situation where we are trying to
191:08 - modulate two numbers we are getting an
191:11 - error and if we hover over this number
191:14 - here you can see that our error says
191:18 - expression must have integral or
191:20 - unscoped enum type what does that mean
191:23 - well if you haven't watched my video on
191:26 - operators I suggest you to do so I'm
191:29 - going to link it here and here I'm
191:31 - quickly going to explain what is
191:33 - happening so this operation here this
191:35 - modulo operation is Operation that is
191:37 - really going to give you a remainder
191:40 - after dividing two whole numbers and
191:42 - since this number here and this number
191:45 - here are of type float we really cannot
191:48 - perform this calculation on these two
191:51 - variables so what we have to do is we
191:54 - first have to check whether this number
191:57 - is really a integer number whether it's
191:59 - a whole number and this number as well
192:02 - and since our float can hold decimal
192:05 - point numbers and integers as well we
192:08 - really in certain situations only can
192:11 - perform this modulating operation and
192:14 - let me explain what I mean by this that
192:15 - our float can hold can hold decimal
192:18 - point numbers and integers as well well
192:20 - this variable here this number variable
192:23 - can really have a value of 5.5 for
192:26 - example but it can hold as well value of
192:29 - 5.0 which is really integer value so
192:32 - it's 5
192:34 - only so now what we have to do is
192:37 - following I'm going to delete this line
192:39 - here and we first have to check whether
192:42 - both of these numbers are integers and
192:45 - in that situation only we can perform
192:47 - this calculation but in a situation
192:50 - where one of these two or both of them
192:52 - are not integers we are going to write
192:54 - out to our user that that operation is
192:56 - not valid so I'm deleting this code
193:00 - here and then let's create two variables
193:04 - so let's create a variable of type Bull
193:08 - and let's call it is num one integer so
193:13 - this variable is going to hold a value
193:15 - that is going to tell us is our our
193:17 - number one integer value and let's also
193:20 - create another variable that is going to
193:22 - be called is num two
193:27 - int and as well this variable is going
193:30 - to tell us whether our number two is
193:33 - integer and let's develop now an
193:36 - algorithm so that we can know whether
193:38 - our number one or number two is integer
193:42 - number and I'm going to ask you to write
193:45 - your Solutions in the comments down
193:46 - below so pause the video think about it
193:48 - and then write your solution and without
193:50 - using any already made functions as
193:53 - programmers as Engineers you should
193:55 - really be able to figure out the
193:57 - solution on your own so applying the
194:00 - knowledge that you have gotten from my
194:01 - previous videos or this one but I'm
194:03 - going to say from my previous videos so
194:06 - pause the video and write your
194:10 - solution so this question is not really
194:12 - a question of programming it's more of a
194:14 - question of thinking in a logical way
194:17 - and if you remember when we were talking
194:19 - about casting operators we said that a
194:21 - casting operator is used to convert one
194:24 - data type into the other and I'm going
194:26 - to link that video here if you haven't
194:28 - watched it make sure to do so and here
194:31 - we are going to try to convert our
194:34 - floating Point number so our number one
194:38 - and our number two into integer data
194:41 - type so into integer number and how we
194:44 - are going to do that well we are really
194:46 - going to say
194:48 - int so this here is going to cast
194:50 - whatever we put after it into int type
194:54 - and we are going to say please try to
194:56 - convert my number one into
195:01 - integer and how does this work well for
195:04 - example if you have a number one that
195:06 - holds value of 5.7 when you try to
195:10 - convert that value into integer what it
195:12 - does really it says that 5.7 so that7
195:17 - part really bye-bye I'm going to take
195:19 - only this five part so only this whole
195:22 - part of a
195:24 - number so in that situation we are
195:27 - really going to get only five from this
195:30 - 5.7 floating Point number so what I'm
195:34 - going to say now is I'm going to say
195:36 - whatever this expression here this
195:38 - casting operation results with I'm going
195:41 - to really try to compare that with the
195:44 - initial value of my number one variable
195:47 - so I'm going to say num one is my
195:50 - converted number one so converted to
195:53 - integer equal to number one like this
195:57 - and how does this calculation here work
195:59 - well as I said for example if you have a
196:02 - number one that holds a value of
196:05 - 5.0 so
196:07 - 5.0 this part here is really going to
196:10 - take this 0 Z part of a number and
196:14 - delete it it's going to keep only this
196:16 - five so only this whole part of a number
196:20 - and after that we have this is equal to
196:23 - operator and then we are trying to
196:25 - really uh trying to really check whether
196:28 - that is equal to
196:30 - 5.0 and the result of this is going to
196:34 - be true so we with this here we have
196:38 - checked really whether our number is
196:41 - going to be equal to our floating Point
196:44 - number so this result here we are going
196:47 - to assign this value to our is number
196:51 - one integer variable so here I'm going
196:54 - to say Please assign the result of this
196:58 - operation to our is number one integer
197:03 - variable like this and let's put this
197:06 - expression here so this whole expression
197:08 - inside these parentheses so that we
197:11 - really can see that this is an
197:12 - expression and the result of this
197:14 - expression should be assigned to this is
197:16 - number one one in variable and now we
197:19 - are going to do the same for our is
197:21 - number number two so I'm going to say is
197:25 - number two integer and we are going to
197:27 - say that that is equal to I'm trying to
197:30 - convert my number two to in and then
197:34 - compare that to my float number
197:38 - two and after this we really can now do
197:44 - our algorithm to perform this modulo
197:48 - where it is this modulo operation on our
197:50 - two numbers in the case where both of
197:53 - them are integers so here I'm going to
197:56 - say
197:58 - if is my number one int and then also is
198:03 - my
198:04 - number two int like this in this
198:09 - situation here I'm going to perform this
198:11 - modular operation and as you can see
198:14 - here I have used only these two bull
198:17 - values here in this expression so I
198:19 - didn't say please check is my number one
198:23 - int equal to True like this nor I have
198:28 - said please check is my number two equal
198:31 - to True like this because uh this here
198:35 - this part here and this part here are
198:38 - really redundant and what this
198:41 - expression here translates in it
198:43 - translates in is true equal to true and
198:47 - that is really redundant so I'm going to
198:49 - remove this part here and this part here
198:52 - and it should work fine like this for
198:55 - Boolean values so Boolean variables and
198:59 - in this situation here where both of
199:02 - these are integers we really can perform
199:04 - this modular operation so in this
199:06 - situation here I'm going to take this
199:10 - code and I'm going to copy it like this
199:15 - and I'm going to say please write out my
199:17 - number one then my operation then my
199:19 - number two is equal to sign and then
199:22 - here I'm going to put adequate
199:24 - calculation so I'm going to say take my
199:27 - number one convert it to to
199:31 - int and then modulate that with my
199:35 - number two that is as well converted to
199:39 - int like
199:42 - this okay so in this situation where
199:44 - both both of these are integers we are
199:47 - going to really write out the result of
199:50 - modulating operation to our user let's
199:53 - add empty space here and here as well
199:56 - but in the situation where one of these
199:59 - two is not integer or both of them are
200:02 - not integers I'm going to say else and
200:06 - in that situation I really going to
200:07 - write out my user that this operation is
200:10 - not valid so let's say just not valid
200:15 - like this
200:17 - so in any of these two situations
200:19 - whether we write out this line of code
200:22 - here or this line of code here after
200:24 - that we are going to come here and here
200:27 - we have to put our break statement like
200:30 - this so after each case comes break and
200:35 - now we can really test this part of code
200:38 - here that we have written so if I run my
200:40 - program the first thing that that I want
200:43 - to test is let's say 5.5 Plus
200:48 - 2.2 and we get the expected result so
200:51 - 7.7 let's run our program again and this
200:55 - time I want to check whether my modulo
200:58 - operation is working as it should
201:00 - because this code here is really
201:02 - specific so let's say five modulo 2 like
201:07 - this and as well we have gotten correct
201:10 - result and let's run our program one
201:12 - more
201:13 - time and here I really want to trick my
201:16 - program and try to make it to modulate
201:18 - two
201:19 - numbers that are not whole numbers so
201:22 - 5.2 modulated by two and as well our
201:26 - program works as it should so it says
201:29 - not valid operation
201:32 - okay so if you have noticed uh in this
201:36 - current situation I really have to run
201:38 - my program each time that I want to
201:40 - perform a calculation and that is
201:42 - because we haven't learned anything
201:44 - about iteration or loops so far and
201:47 - those videos are coming so make sure to
201:49 - subscribe to my channel and also click
201:51 - the Bell icon so that you are notified
201:53 - when I publish those videos and in that
201:55 - situation where we learn iteration and
201:57 - Loops we are really going to be able to
202:00 - run our programs indefinitely which
202:02 - means to run our calculator application
202:05 - until we really decide to stop it
202:09 - okay so after we have covered these five
202:13 - cases here there is only one situation
202:16 - left to cover and that is situation
202:18 - where our user enters any other sign
202:22 - that is not one of these five here and
202:25 - that situation we are really going to
202:28 - write like this so we are going to say
202:31 - default so in the case where our user
202:34 - enters operation that is not going to
202:37 - correspond to any of these five signs we
202:40 - are going to execute our default
202:42 - situation and here we really want to
202:44 - write out a meth message to the user
202:47 - that is trying to hack our program so
202:50 - you can write whatever message you want
202:52 - to the user that is trying to hack the
202:53 - program that you have worked so hard to
202:56 - build and I'm going to put
203:03 - here okay you really can write out
203:07 - whatever you want to that type of user
203:10 - like
203:11 - this so in the case where our user has
203:15 - not entered
203:17 - this nor this nor this nor this nor this
203:20 - which means our user has entered some
203:23 - other sign we really want write out not
203:25 - valid operation and let's test now our
203:28 - default case so I'm going to run the
203:31 - program and I'm going to take the role
203:33 - of a malicious user that is going to try
203:35 - to hack your application and I'm going
203:38 - to say please try to perform this
203:41 - calculation here so 5
203:45 - z9 no not really you have been smart
203:48 - enough to predict his malicious behavior
203:51 - and you have said if you haven't put
203:53 - here a valid arithmetic operation then
203:56 - no I cannot help you this is not a valid
203:59 - operation and there is really one thing
204:02 - that you have been wondering about for
204:03 - the most part of this video and that is
204:05 - this break statement here so why I have
204:08 - said that after each case you have to
204:10 - put break and now you want me to explain
204:13 - that do you do you really wouldn't that
204:16 - be a spoiler for a situation where you
204:18 - decide on your own to delete this break
204:21 - statement here and then run your program
204:23 - even though I have said not to and you
204:26 - enter some calculation and you remember
204:29 - that I have said that you are going to
204:30 - get unexpected Behavior but was she
204:33 - lying was she not and then you decide to
204:37 - execute this calculation and boom here
204:40 - is your unexpected
204:42 - Behavior so what has happened here well
204:45 - your program has really recognized that
204:47 - this operation here that you have
204:49 - entered is this minus operation and
204:51 - after that is it has written out this
204:54 - number one so 7 and then operation minus
204:58 - and then this number two five is equal
205:01 - to and then it has calculated number one
205:04 - minus number two which is 7 - 5 and that
205:06 - is equal to 2 and after that it has
205:10 - really continued executing other cases
205:13 - which means it has come to this line
205:15 - here and then then it has written one
205:17 - more time your number one minus number
205:19 - two so 7 - 5 is equal 2 and then it has
205:23 - performed this number one plus number
205:26 - two calculation and 7 + 5 is going to be
205:29 - equal to 12 and then it has come to this
205:32 - first break command and it has has
205:35 - stopped the execution of your switch
205:38 - case so why has this happened it has
205:41 - happened because you haven't put this
205:43 - break command here and in that case
205:46 - program is really going to be executing
205:48 - your cases until it comes to the first
205:51 - break command and if you have noticed
205:55 - here in this default situation I haven't
205:57 - really put any breaks you can as well
206:00 - put your break statement here you can
206:03 - say break here but even if you don't if
206:07 - even if you didn't put your break here
206:10 - and your program really tries to execute
206:12 - something after this line here there is
206:14 - really nothing to execute so you are not
206:16 - going to get a problem in this situation
206:19 - here I hope that you like this video and
206:21 - that you have built your own calculator
206:23 - application and if you did make sure to
206:25 - subscribe to my channel and click the
206:27 - Bell icon as well share this video with
206:29 - anyone who would like to learn
206:30 - programming and I'm going to see you in
206:32 - my next video
206:34 - bye hi everyone welcome to my channel
206:37 - welcome to another video of C++ for
206:39 - beginners and in this video I wanted to
206:42 - deepen your knowledge of switch case so
206:44 - if you're not familiar with switch case
206:46 - Cas at all if you haven't watched my
206:47 - previous video you definitely have to do
206:49 - that the link is going to be here and in
206:52 - this video I wanted to give you some
206:54 - more examples that you can practice on
206:56 - and introduce some things that I haven't
206:58 - mentioned in my previous video as well
207:01 - so in this video we are going to build a
207:02 - program that is going to require from
207:04 - our user to enter a year and a month as
207:08 - well and then our program has to write
207:09 - out how many days there is in that month
207:13 - so how we are going to do that let's see
207:15 - but first you have to subscribe to my
207:17 - channel and like this video and also
207:19 - share it with your friends as I
207:22 - explained there are two things that we
207:23 - need from our user to enter and those
207:26 - are going to be month and year so let's
207:28 - create two variables let's say year and
207:32 - month like
207:34 - this and now I'm going to write out the
207:37 - message to my user so that he knows that
207:39 - he should enter those two values so year
207:43 - and after that please enter month like
207:46 - this and let's store now the values that
207:49 - our user enters so the first one is
207:52 - going to be stored inside our year
207:54 - variable and then the second one is
207:55 - going to be stored inside our month
207:58 - variable and now we have really covered
208:01 - everything that we need from our user
208:03 - now our program has to check these two
208:05 - variables and then decide how many days
208:08 - there is in that month of that year and
208:12 - we are going to do that using switch
208:14 - case statement but but there is one
208:17 - thing that I want to mention before
208:18 - before we start write our switch case
208:21 - and that is you have to take in
208:23 - consideration that there are years that
208:25 - are leap years and that have one day
208:28 - more than the year that is not a leap
208:30 - year and there is a rule for that so I'm
208:34 - going to copy the rule that that is
208:36 - going to help us to determine whether a
208:39 - year is a leap year or not and that is
208:42 - this rule here so any year that one
208:46 - modulated by four gives the result of
208:48 - zero and at the same time that year
208:51 - modulated by 100 is not equal to zero
208:56 - or a year so that same year when
208:59 - modulated by 400 is going to give the
209:02 - result of zero and this here is going to
209:05 - be a definition for our leap year which
209:08 - means a year that has 366 days or a
209:12 - February inside this year has 29 days
209:17 - that's why we need this rule here so now
209:20 - let's write out our switch case
209:22 - statement and if you haven't watched my
209:24 - video on switch case statement I am
209:26 - going to link it here one more time
209:28 - because you really need to understand
209:30 - the switch case and then you can come
209:33 - back to this video and deepen your
209:34 - knowledge on switch case so switch this
209:39 - is going to be the syntax of our switch
209:41 - case but I'm going to delete this
209:44 - default syntax we want to write it
209:47 - ourselves so inside these parentheses
209:49 - here I'm going to put the variable that
209:52 - we are going to switch through and that
209:54 - is going to be our month variable like
209:57 - this so whichever value our user has
210:02 - entered for our month we are going to
210:04 - cover all the potential values that our
210:05 - month can hold in our cases so the first
210:10 - case that I want to cover is going to be
210:12 - the most specific one and that is going
210:14 - to be our February which means second
210:17 - month so I'm going to say in the case
210:20 - that this month variable is equal to 2
210:24 - which means that our user is requesting
210:25 - from us to determine how many days our
210:28 - February month has we really in this
210:31 - case need to check whether that year is
210:34 - a leap year or not and then if that year
210:37 - is a leap year that means that our
210:39 - February has 29 days and if not which
210:43 - means if this condition here is not true
210:46 - that means that our second month has 28
210:49 - days so I'm going to copy this
210:52 - expression here this condition and also
210:56 - if you are not familiar with Turner
210:58 - operator you have to watch that video
211:00 - because in this video we are going to
211:02 - use that tary operator you can do it as
211:05 - well with if else statement but I want
211:07 - you to practice also this because you
211:10 - will uh you are going to actually come
211:13 - across it in your programming career
211:16 - so here I'm putting this condition for a
211:19 - leap here and I'm going to say this
211:22 - question mark and then I'm going to say
211:27 - if this here is true you have to write
211:30 - out this line of code so you have to
211:32 - write out C out and if this condition
211:36 - here is true that means that our year is
211:38 - a leap year which means that our
211:40 - February our second month has 29 days so
211:44 - let's say 29
211:46 - days month like
211:49 - this
211:51 - okay
211:53 - and so that is in the situation where
211:55 - this here is true and in the situation
211:57 - where this expression here results as
212:00 - false I'm going to put here a column
212:03 - sign and then I'm going to write out a
212:06 - different message and that is going to
212:08 - be that this second month in the case
212:13 - where a year is not a leap here has
212:15 - actually
212:16 - 28 days
212:19 - so after we have written this expression
212:24 - here so this Turner operator we have
212:27 - really write out how many written out
212:29 - how many days there is in our February
212:31 - month and after each case I have to put
212:34 - break so in this case as well I'm going
212:37 - to put put our break command after it
212:41 - and with this example with this case
212:44 - here we have really covered our second
212:46 - month which was the most specific one
212:49 - now we are left to cover the remaining
212:51 - months which means ones that have 31
212:55 - days and also ones that have 30 days and
212:58 - here I'm going to show you something
213:00 - that I haven't shown you before let me
213:02 - scroll this code like this
213:05 - maybe okay and then there are some
213:08 - months that contain 30 days and some
213:11 - that contain 30 31 days and the ones
213:14 - that contain 30 days are following so
213:18 - I'm going to write out case like this
213:21 - and then the the first month that
213:23 - contains 30 days is going to be April so
213:26 - fourth month and then also our sixth
213:30 - month contains 30 days and then also
213:35 - let's see 4 6 9th and
213:40 - then November as well like
213:43 - this and here we have written out really
213:47 - all the months that contain 30 days okay
213:52 - and now I'm going to at the end so at
213:56 - this case here write out a message let
213:59 - me copy
214:00 - this and I'm going to paste it and I'm
214:03 - going to say 30 days month like this
214:08 - okay and I'm going to put break command
214:11 - here as well so let me explain this part
214:14 - of code here because we haven't seen
214:16 - this part of code here
214:18 - before this break statement what it does
214:21 - is when your program so when your
214:23 - program execution actually comes to this
214:26 - case here it says okay my month is equal
214:28 - to two so I'm going to execute this part
214:31 - of code here and then it comes to this
214:33 - break command and this break command
214:35 - really breaks the execution of your
214:37 - switch which means that when your
214:40 - program comes to the first break command
214:43 - it is going to stop the execution of
214:45 - your switch there which means that it is
214:47 - not going to check any more cases and
214:51 - because of that you can really
214:53 - hear so you can put more than one month
214:56 - you can put all months that have 30 days
214:59 - like this and then you can write out the
215:03 - same message and put one break command
215:06 - at the end and how that is going to
215:08 - really behave inside your program in the
215:11 - case where user enters for example month
215:14 - six your program is going to check
215:17 - whether that month is is equal to two
215:19 - and it's not going to be then it's going
215:21 - to check whether your month is equal to
215:23 - four not as well and then it's going to
215:26 - come here and say okay this is sixth
215:28 - month this that our user has entered so
215:31 - please execute whatever code you find
215:34 - until you come to the first break and
215:36 - that is going to be this here which is
215:38 - empty so nothing and then this here
215:41 - which is as well empty so nothing and
215:44 - then it comes to this code here and that
215:49 - line so this code here contains this see
215:52 - out message 30 days month so it is going
215:56 - to write out this and then it really
215:59 - comes to this first break command and it
216:02 - breaks your switch which means that it
216:05 - is not going to check any other cases
216:07 - that come after this break okay so in
216:11 - any case whether your user enters month
216:13 - four or 6 or 9 or 11 your program is
216:17 - going to execute this line here and then
216:19 - break your switch so with this part of
216:22 - code here we have really covered all
216:25 - months that have 30 days and now we are
216:28 - left to cover the ones that have 31 days
216:32 - and those are months uh let's see that
216:36 - is our January and then our third month
216:42 - and our fifth
216:45 - and our 7eventh
216:48 - month like this let me scroll it a
216:51 - little bit
216:53 - more okay and then we have as well
216:59 - case 8 and case 10 and as well our
217:06 - December has 31
217:09 - days so there are seven months that have
217:13 - 31 days uh five five months that have 30
217:16 - days and one month that has 28 or 29
217:19 - days and in this line here we are going
217:22 - to write out a
217:24 - message that is going to say 31 days
217:28 - month and as well here we have to put
217:31 - our Brak command like this okay so I am
217:35 - going to run my program now and show you
217:38 - how this program
217:40 - behaves so our program is asking us to
217:44 - enter a year and month let's say a year
217:47 - is going to be 2020 which is current
217:50 - year and then a month is going to be
217:53 - let's see it's April so 4th and it says
217:57 - that it is a 30-day month which is April
218:01 - April has 30 days and let's run our
218:06 - program one more time and let's say 2020
218:09 - again and let's say that we want check
218:11 - our second month and it says that
218:14 - February of 2020 has 29 days which is
218:18 - correct as well and there is really one
218:20 - more situation that I want to cover and
218:22 - that is going to be a situation where
218:24 - our user enters a number that is not a
218:27 - valid month number and that situation
218:30 - I'm going to cover with my default
218:31 - statement so I'm going to write out
218:34 - default and in this default case as well
218:37 - I want to write out a message to my user
218:40 - like this and inside here I'm going to
218:43 - say not valid Val which means that our
218:47 - user has not entered a valid month
218:49 - number so let's run our program and if I
218:52 - enter year
218:54 - 2020 and for a month let's say minus 5
218:58 - for example you see that our program has
219:01 - written out not
219:04 - valid okay so I hope that you have liked
219:08 - this video and if you did make sure to
219:10 - subscribe to my channel and share it
219:12 - with anyone who would like to learn
219:13 - programming as well and today is May the
219:17 - 2nd that's when I'm filming this video I
219:19 - don't know when I'm going to publish it
219:20 - probably in a couple of days and
219:23 - currently we are a little bit over 900
219:25 - people so let's see how fast this
219:28 - channel can grow thanks for watching and
219:31 - I'm going to see you in my next video
219:33 - bye hi everyone welcome to my channel
219:37 - welcome to another video of C++ for
219:39 - beginners and in this video I wanted to
219:41 - talk about loops more specifically about
219:44 - while loops Loop so what are Loops what
219:47 - are they used for how they are used well
219:50 - Loops are used when you want to execute
219:53 - a block of your code multiple times
219:55 - while a certain condition is true which
219:58 - means you give a certain condition to
220:00 - your Loop and you say you are going to
220:02 - execute this block of code while this
220:05 - condition here is true so however many
220:08 - times it is necessary and one thing that
220:12 - I want to mention before we start uh on
220:14 - our example is the following so
220:17 - selection sequencing and
220:20 - iteration those three are three main
220:23 - building blocks of programming languages
220:27 - and when you really learn and understand
220:29 - those three you should be able to solve
220:31 - any logical programming problem and in
220:34 - this video we are going to talk about
220:36 - iteration we have already talked about
220:39 - sequencing and selection in my previous
220:41 - videos so what is sequencing well that
220:45 - means that your code is executed
220:48 - sequentially which means one line after
220:50 - the other and then selection that would
220:53 - be really when you want to select one
220:56 - part of the code rather than the another
220:59 - one which means you are going to tell to
221:01 - your program under a certain certain
221:03 - situation it really has to select which
221:05 - block of code it is going to execute the
221:08 - same would be when you for example come
221:09 - to a crossroad and then you have
221:11 - multiple ways in front of you but you
221:13 - really have to select which one you are
221:15 - going to take because you cannot take
221:18 - all of them and then iteration is going
221:21 - to be really iterating or executing
221:24 - multiple times a certain block of code
221:27 - certain part of code while a certain
221:29 - condition is true so while a certain
221:32 - condition is fulfilled you are going to
221:33 - execute the same block of code so let's
221:36 - see our example now so I'm going to
221:39 - paste the text of my program
221:42 - here and this is our task so it says
221:46 - that we have to write out all the
221:48 - numbers between 100 and 500 that are
221:51 - divisible by three and by five and how
221:55 - we are going to do that first I want to
221:57 - explain you the algorithm so how we are
222:00 - going to solve this problem and then we
222:02 - are going to translate that algorithm
222:04 - into our code so this interval here so
222:07 - this 100 to 500 interval we are really
222:11 - going to iterate through all of the
222:14 - numbers of of this interval and we are
222:17 - going to do that using while loop and
222:20 - then for each of those numbers so for
222:22 - each value of our counter we are going
222:25 - to check whether that counter value can
222:28 - be divided by three and by five and if
222:32 - yes we will write out that value if no
222:35 - we are just going to continue to the
222:37 - next iteration so as I already said we
222:41 - are going to use while loop to solve
222:44 - this problem and and we are going to
222:46 - start our V loop with the counter value
222:49 - of 100 and in each iteration we are
222:52 - going to really increase the value of
222:55 - our counter so 101 102 and three and we
222:59 - are going to stop the execution of our V
223:02 - Loop when this counter value comes from
223:06 - 100 to 500 And1 which means 500 value of
223:11 - counter is going to be our last
223:12 - iteration through our Loop so so the
223:16 - first thing that I'm going to do is I'm
223:19 - going to really declare a variable that
223:21 - is going to hold our current counter
223:23 - value so I'm going to call it
223:26 - int counter like this and initially I'm
223:30 - going to set the value of my counter to
223:34 - 100 okay so this is our initial value of
223:38 - our counter and then let's see what is
223:41 - the syntax of of our while loop so so we
223:45 - write out while like this and then in
223:49 - these parentheses we are going to put
223:51 - our condition so how long our Loop is
223:53 - going to execute and then in these
223:58 - braces here so in this curly brackets we
224:01 - are going to put which block of code our
224:03 - while loop is going to execute while
224:06 - this condition here is fulfilled and
224:08 - let's now fill these parentheses here so
224:12 - as I've said our counter has to go from
224:14 - 100 to 500 which means since it starts
224:18 - on 100 here we have to say to our while
224:21 - loop that the execution of this block of
224:24 - code here really has to stop when our
224:26 - counter comes to 500 or 5001 500 is
224:30 - still valid value so that we are going
224:34 - to say like this so we are going to say
224:37 - counter like
224:39 - this and then we are going to say there
224:41 - are two ways to write this condition the
224:43 - first one is to say while our counter is
224:47 - less or equal to
224:49 - 500 or you could as well said while our
224:53 - counter is less than
224:56 - 51 so that is a valid situation while
225:00 - you're executing your Loop so while your
225:03 - counter is less than 501 or while your
225:06 - counter is less or equal to 500 I prefer
225:11 - it this way but whichever way you put it
225:14 - is going to work so now that we have put
225:17 - this condition here we really can write
225:20 - out this code that comes in this while
225:23 - loop block so what we are going to
225:25 - execute while this condition here is
225:27 - true and that is going to be following
225:30 - inside this block of code here we really
225:33 - have to check whether our current value
225:35 - of our counter is divisible by three and
225:39 - by five and if it is we have to write
225:42 - out that number to our user if no we
225:46 - just need to continue to our next
225:48 - iteration of our Loop and how we can
225:51 - check whether this counter value can be
225:54 - divided by three and by five well we use
225:57 - modulo operation for that if you haven't
225:59 - watched my video on operators I'm going
226:01 - to link it here make sure to watch
226:04 - it and here we really put the following
226:07 - so we can say if and also if you're not
226:10 - familiar with if statement going to link
226:14 - it here
226:16 - so if our counter value so our current
226:19 - value of our
226:22 - counter after you modulate it with three
226:26 - if the result of that is zero that means
226:30 - that our number so our counter is
226:32 - divisible by
226:34 - three and we also have to check whether
226:37 - our
226:38 - counter is divisible by
226:42 - five as well we use this modul operation
226:46 - here and we say whether our counter
226:49 - modulated by five is going to equal to
226:51 - zero and if this condition here is
226:53 - fulfilled we really have checked this
226:56 - part of our task and if this part here
227:00 - is true we have to write out that number
227:04 - so in this situation here I'm going to
227:05 - say C out like this and I'm going to put
227:10 - inside
227:11 - here let's see we are going to write out
227:14 - the value of our counter like this and
227:17 - we are going to write out
227:20 - is divisible like this and let's put
227:24 - one end line after this line of code
227:28 - here because we are definitely going to
227:30 - have multiple lines so we want our lines
227:32 - to be formatted nicely okay so this part
227:37 - of code here has really covered this
227:40 - divisible by three and five and write
227:42 - out that number if it is divisible by
227:44 - three and by five five and there is
227:46 - really one very important thing that you
227:48 - have to keep in mind each time that you
227:50 - write loops and that is the following so
227:53 - you have to give your
227:55 - Loop away so that it can stop executing
227:59 - this block of code here so under a
228:01 - certain condition it really needs to
228:04 - leave this block of code here because if
228:07 - you don't do that you are going to end
228:09 - up with an infinite Loop you are really
228:11 - going to lock your program in an
228:13 - infinite Loop situation
228:15 - and this code here this Loop here that
228:17 - we have written this is really an
228:19 - infinite Loop so let me prove that I'm
228:23 - going to run my program and as you can
228:26 - see the console is empty so I enter any
228:30 - value enter whatever it is not really
228:33 - reacting and why has that happened well
228:37 - your counter value starts with 100 and
228:40 - then it comes to your while loop and
228:42 - your while loop checks this condition
228:44 - here so it checks whether your 100 is
228:48 - less or equal to 500 and the answer to
228:50 - that is yes which means that your
228:52 - program execution can enter this block
228:54 - of code here so it can start executing
228:56 - your Loop and then it comes here and it
228:59 - says please check whether my counter
229:01 - which is 100 is divisible by three and
229:04 - the answer is no so this part of code
229:08 - here is not even going to be
229:10 - checked because of the nature of this
229:12 - end operator it really needs both of
229:15 - these operant to be true in order for
229:18 - this expression here to be true because
229:20 - this here is not true it's false 100 is
229:23 - not divisible by three it is not even
229:26 - going to check this condition here and
229:28 - this line of code here is not ever going
229:31 - to be written so after that it comes
229:34 - here to this closed curly brace and then
229:38 - because of the nature of while loop when
229:40 - it comes here it really goes back here
229:43 - and then it checks again your value of
229:46 - your counter whether that is less or
229:48 - equal to 500 but nothing has changed
229:51 - your counter value is still 100 and then
229:54 - it is going to enter again here and then
229:56 - really repeat that process over and over
230:00 - again and your program because of that
230:02 - is going to be locked inside an infinite
230:05 - Loop so let me prove that really because
230:08 - here we have an empty console and you
230:10 - cannot see what is happening in the
230:11 - background so I'm going to stop my
230:13 - program and I'm going to write out here
230:16 - let's write out C out like
230:21 - this and let's write out infinite Loop
230:25 - and if I run my program now as you can
230:28 - see your program has really entered in
230:31 - an infinite Loop and it is writing out
230:33 - this infinite Loop text for infinite
230:37 - number of times so as you can see it
230:40 - says infinite Loop okay and this
230:45 - execution here is not really going to
230:47 - stop until your program's memory is full
230:50 - and then it's going to crash so whatever
230:53 - code in the case that you had some code
230:56 - here it is not ever going to be
231:00 - executed so I'm going to stop this here
231:02 - and I'm going to delete this part of
231:04 - code here because we don't really need
231:06 - it what we need is we need to put here a
231:10 - certain code that is going to help our
231:12 - Loop to really stop the execution at a
231:16 - certain point and the code that we need
231:18 - to put here is going to be really
231:20 - following it's going to be
231:23 - counter plus plus like this what this
231:27 - code of here this code here is going to
231:29 - do in each iteration it is going to
231:32 - check whether this condition here is
231:34 - true if yes it is going to write out
231:36 - this part of code here and then in each
231:39 - iteration it is going to really increase
231:42 - the value of your counter by 1 which
231:45 - means in your first iteration is going
231:46 - to be 100 after that it's going to be
231:49 - 101 102 103 and it is going to really go
231:55 - until it comes to 500 that is going to
231:58 - be the last iteration of your program
232:00 - and then when it comes to 5501 this
232:03 - condition here is not going to be true
232:05 - anymore and then your Loop is going to
232:09 - check really whether 51 is less or equal
232:12 - to 500 and the the answer to that is not
232:15 - going to be no so your program is going
232:18 - to really stop the execution of this
232:21 - Loop and come here and then really stop
232:25 - your program so if I run the program now
232:28 - I'm going to prove that okay so this has
232:32 - been executed very fast and as you can
232:35 - see this is the result of your program
232:38 - it has really written out all the
232:40 - numbers that are divisible by three and
232:43 - by five and you can check check all of
232:45 - these numbers using your calculator if
232:47 - you want
232:50 - so with this expression here with this
232:53 - counter Plus+ we have really both
232:56 - iterated through all the numbers between
232:58 - 100 and 500 because we check our counter
233:02 - value here and then also we have we have
233:06 - really given a way to our Loop to stop
233:08 - the execution of this block of code here
233:12 - when this counter value comes to
233:15 - 51 and this is the result of our
233:20 - program okay so I hope that you have
233:23 - liked this video any questions that you
233:25 - have write those in the comments down
233:26 - below and I'm going to answer those make
233:29 - sure to subscribe to my channel and
233:31 - share it with all your friends anyone
233:33 - who would like to learn programming and
233:36 - I'm going to see you in my next video
233:38 - bye hi everyone welcome to my channel
233:41 - welcome to another video of C++ for
233:43 - beginners today I want to talk about
233:46 - while loop and I have already made one
233:49 - video on this topic and if you haven't
233:51 - watched that I'm going to link it here
233:53 - so make sure to do so and why I'm making
233:55 - this video because I really believe that
233:57 - watching One video and doing only one
234:00 - example is not going to be enough for
234:02 - you to really Master a certain concept
234:04 - it wasn't for me it is not going to be
234:07 - for you as well and that is completely
234:09 - okay so we are going to show you how
234:11 - this while loop is used on one more
234:13 - example and the program that I want to
234:16 - build today is going to be a program
234:18 - that has to count how many digits the
234:21 - number contains so our user is going to
234:23 - enter a number and then we are going to
234:25 - write a program that is going to count
234:27 - how many digits there are in that number
234:31 - so let me copy the text of that
234:35 - program like this and it says count
234:40 - digits of a number so let's do do the
234:44 - first thing that we know that we have to
234:46 - do and that we know how to do as well so
234:49 - that is going to be write out a message
234:51 - to our user so that he enters that
234:53 - number and then also allow him to enter
234:56 - that number so I'm going to say see out
234:59 - and then I'm going to say number like
235:02 - this and then I'm going to allow my user
235:05 - to enter that number before I can enter
235:08 - it I have to really declare a variable
235:10 - that is going to hold that number so
235:12 - here I'm going to say int number like
235:15 - this and then here after we have written
235:18 - out this me message to our user we are
235:20 - going to say C
235:23 - in number like
235:25 - this so after our user has entered his
235:29 - number we really have stored it in our
235:32 - number variable and now we are going to
235:34 - write out the program that is going to
235:36 - count the number of digits of this
235:38 - number here so let's first see one
235:43 - specific situation that can happen and
235:45 - that is going to be when our user enters
235:48 - number zero so this number holds a value
235:51 - of zero and in that situation I'm just
235:54 - going to write out a condition so I'm
235:55 - going to say if my
235:58 - number like this is equal to zero in
236:02 - that situation situation please just
236:04 - write out a message to my user like this
236:08 - you have entered zero okay
236:14 - like this
236:16 - and I don't need semicolon here this
236:19 - looks better so this here is a situation
236:23 - where our user has entered number zero
236:26 - and in that case we just want to write
236:28 - out that he has entered zero and now we
236:30 - are left with the main problem of this
236:33 - task and that is to count the digits of
236:35 - the number that our user has entered and
236:38 - that part I'm going to put in my else
236:40 - block like this and if you're are not
236:44 - fam familiar with if else statements
236:46 - make sure to watch that video it's going
236:47 - to be linked
236:49 - here so here in this else block I want
236:52 - to write the program that is going to
236:54 - count the digits of a number which is
236:56 - not zero definitely because if we come
236:58 - here then our number is definitely not
237:01 - zero so how we are going to do that well
237:05 - let me show you the algorithm on an
237:07 - example let's say that our user is going
237:09 - to enter a number
237:12 - 1325 for example that is the number that
237:14 - our user enters so how we are going to
237:16 - count the digits of this number well
237:19 - first we are going to have a variable
237:22 - that is going to be called counter like
237:24 - this and initially we are going to set
237:27 - the value of that counter to zero so
237:30 - that is initial count of our digits of
237:34 - number and then we are going to to use
237:36 - while loop to iterate through all the
237:39 - digits of this number and in each
237:42 - iteration we are going to do following
237:44 - so we are going to come here and then we
237:47 - are going to say okay take this last
237:50 - digit of my number and really remove it
237:53 - I don't need it and as well increase the
237:56 - number that my counter is holding so
237:59 - increase the number of digits because we
238:02 - have removed one digit and then in the
238:04 - next iteration we are coming here and we
238:07 - are as well saying okay so take that
238:09 - last digit and increase my
238:12 - counter like this and then in the next
238:15 - iteration take the last digit increase
238:19 - counter and in the next as well take
238:22 - last digit increase counter and then
238:26 - when we come next time we really have
238:29 - nothing more to count so there are no
238:31 - more digits left our number at this
238:34 - situation here is going to be equal to
238:36 - zero and then we are going to know that
238:39 - there is nothing else to count and then
238:42 - we are really going to leave our Wild
238:44 - Loop and we are going to write out the
238:45 - value that our counter variable is
238:47 - holding which is at this situation for
238:50 - so let me show you how we how we can do
238:52 - that in our code so I'm going to delete
238:55 - this part here we don't need it anymore
238:58 - and then here I'm going to write out the
239:00 - following so as we explained already
239:03 - first thing that we need to do is we
239:04 - need to create a variable that is going
239:07 - to be called
239:08 - counter like this or digits counter
239:11 - however you prefer and and that variable
239:15 - I'm going to assign a value of zero
239:18 - initially and after we have created this
239:20 - variable here now we need our while loop
239:25 - so
239:26 - while like this and then inside these
239:29 - parentheses here we really write out a
239:32 - condition that our while loop is going
239:34 - to check each time that it wants to run
239:37 - each time that it wants to iterate and
239:39 - that condition here is really going to
239:41 - be please check whether my number number
239:44 - is greater than zero okay so in any case
239:49 - where our number is greater than zero
239:51 - our while loop is going to execute this
239:54 - block of code that I put inside these
239:57 - parentheses and what we are going to put
240:00 - inside these parentheses well as we
240:02 - already explained previously first thing
240:05 - that we need to do is we need to say
240:08 - number is equal to number divided by 10
240:14 - and what this line of code is going to
240:17 - do well let me show you that on an
240:20 - example let's say that our number so our
240:23 - number holds the value of 1 2 3 like
240:26 - this and this line here really says the
240:30 - following it says Please do this
240:32 - expression here so calculate it and
240:35 - whatever this expression here results in
240:37 - assign that to my number variable and 1
240:41 - 2 3 so
240:42 - 1233 divide by 10 because this here is
240:46 - whole number so it's integer and this
240:48 - here is whole number as well the result
240:50 - is going to be whole number and that is
240:53 - going to be 12 or 12.3 but but because
240:57 - result has to be the whole number that3
241:00 - part is just deleted bye-bye so then
241:03 - this 12 in this situation is going to be
241:06 - assigned to our number
241:08 - variable okay so that means that this
241:12 - number divided by 10 is really going to
241:14 - take away that last digit which we have
241:17 - previously explained so I'm going to
241:20 - delete this part
241:22 - here okay and this line of code there is
241:26 - really one more way to write this so
241:28 - write the same thing so I'm going to
241:30 - comment this here and I'm going to write
241:33 - out number divided equal so number R
241:38 - like this 10 okay
241:41 - so this line of code here and this line
241:44 - of code here are exactly the same this
241:47 - is just shorter way to write this here
241:50 - and this looks prettier to me but you
241:52 - can leave whichever of these two you
241:55 - prefer okay so after we have taken the
241:57 - last digit from our number what we are
242:00 - left to do is to increase our counter
242:02 - variable by one so we can do that using
242:05 - our increment operator here so this part
242:09 - of code has really in each iteration
242:12 - taken away one digit and then increased
242:15 - counter variable so what we should do
242:19 - now after our while loop finishes we
242:23 - should really write out how many number
242:25 - how many digits our number contained so
242:28 - we are going to write out
242:31 - count number
242:35 - contains like this and then let's write
242:38 - out the value that our counter
242:40 - variable is holding like this
242:45 - what is this oh it says count instead of
242:47 - C out
242:50 - okay and then let's write out
242:55 - just digits like
242:58 - this okay so our number contains
243:02 - whatever our counter variable is holding
243:06 - digits so now I can really run my
243:08 - program and let's do
243:11 - that so it asks us to enter a number
243:15 - let's enter number 1 2 3 for example and
243:19 - it says that our number contains three
243:22 - digits which is correct so let's very
243:26 - quickly explain one more time how this
243:29 - has happened so I'm going to stop my
243:32 - program and I'm going to say here that
243:36 - our user has entered number let's say 1
243:39 - 2 3 so our program in this situation
243:43 - comes here to our while loop and it says
243:45 - please check whether the number that our
243:47 - user has entered is greater than zero
243:50 - and that number is 1 2 3 so 123 which is
243:53 - greater than zero so then our program
243:56 - can really start executing this wild
243:58 - Loop so it enters here and then it comes
244:01 - to the first line of this while loop and
244:03 - it says Please do this expression here
244:05 - and this expression here really just
244:08 - takes the last digit of our number away
244:11 - and that is going to be three so we are
244:13 - going going to take that away and then
244:16 - the next thing that needs to happen is
244:18 - increase the value of our counter since
244:20 - previously the value of our counter was
244:22 - Zero now the value is going to be
244:25 - increased by one so that is going to be
244:27 - one and after that our program comes
244:30 - here and because of the nature of the
244:31 - while loop it goes back here it checks
244:34 - again whether our number is greater than
244:36 - zero our number is 12 now so the one
244:39 - digit has been taken away so that is
244:41 - still greater than zero so then our
244:43 - number really comes here and then does
244:46 - does this line of code again so it says
244:48 - again please take away one digit from my
244:50 - number so then it takes away this two
244:55 - part and then it comes here it says now
244:58 - increase my counter because you have
245:00 - taken away one digit and that is going
245:01 - to be two now after that our program
245:04 - comes here and then goes back here
245:07 - checks whether our number so whether our
245:09 - one is greater than zero it says yes and
245:12 - then it comes here and it says says
245:14 - please divide my number by 10 so take
245:16 - away that one digit so that one digit is
245:19 - taken away and we are left with zero and
245:22 - then our counter is increased by one and
245:26 - then we are really going to come here
245:28 - again and then our program goes back and
245:31 - says please check whether my number so
245:33 - whether zero is greater than zero and
245:36 - then our program says no it is not so
245:39 - our while loop is not executed anymore
245:41 - and then it comes here instead dad and
245:44 - it writes out that our number contains
245:47 - three
245:49 - digits and there is one more situation
245:51 - that I want to show you and that is
245:53 - going to be what is going to happen in a
245:56 - situation where our user decides to
245:58 - enter a negative number so let's run our
246:01 - program and let's see how our program is
246:03 - going to behave in that situation so now
246:06 - I'm going to enter a number of Min - 335
246:09 - for example and you see that our program
246:12 - writes out that our number contains zero
246:15 - digits why has that happened because our
246:18 - program has come here so it has
246:21 - increased our counter it has actually
246:23 - assigned our counter a value of zero and
246:26 - then it has come here and it is it has
246:28 - really tried to check whether our number
246:30 - is greater than zero but because our
246:33 - number is minus 335 that is not greater
246:36 - than zero so our program then really is
246:38 - not going to execute this block here but
246:42 - it's just going to go here directly so
246:45 - then it's going to write out that our
246:46 - number contains and the value that it
246:49 - has assigned to our counter here which
246:51 - is zero so our number contains zero
246:53 - digits and that's the message that you
246:55 - see here so that is the explanation of
246:58 - this behavior and we need to solve that
247:00 - now how we are going to solve that well
247:03 - it's pretty simple so here when we come
247:06 - to this else Block in this situation in
247:09 - this 14th line of code we are really
247:12 - sure that our number is not equal to
247:14 - zero because we have checked that here
247:17 - but here we really don't know whether
247:18 - our number is less than zero or greater
247:21 - than than zero so here we really have to
247:25 - check whether our number is less than
247:27 - zero and if it is we really need to get
247:30 - the absolute value of our number which
247:32 - means if it is negative we have to
247:34 - convert it to the positive number so
247:37 - here I'm going to write out the
247:39 - following condition so I'm going to say
247:42 - please check if my my number is less
247:46 - than zero like this and then if this
247:49 - here results as true I'm going to write
247:51 - out here a way for my program to convert
247:55 - this number in case that it is negative
247:57 - into a positive number and how we can do
248:00 - that well we can really multiply that
248:03 - number by minus one so we can say number
248:07 - is equal to -1 * number like this
248:14 - okay so now if I run my
248:18 - program and if I enter value of Min -
248:23 - 236 for example our program now writes
248:26 - out that our number contains three three
248:28 - digits which is correct so how has this
248:31 - happened our program has come here it
248:34 - has really checked that our number is
248:36 - less than zero and then it has come here
248:39 - and it has said please do this
248:41 - expression here and then assign that to
248:43 - my number so -1 * 2 - 236 those minuses
248:49 - are going to really convert into plus
248:51 - sign and then 1 * 236 is going to be
248:56 - 236 and after that we are going to do
248:59 - the same logic here so we are going to
249:02 - write out that our program that our
249:04 - number contains three digits which is
249:06 - correct
249:08 - answer okay so that is the one situation
249:12 - that I wanted to explain and there is
249:14 - also another situation that I want to
249:16 - explain to you and that is what is going
249:18 - to happen in the following situation
249:21 - here so let's see let me enter a number
249:24 - that is very very very large I I cannot
249:28 - even read this number here so how our
249:32 - programs going to behave in that in this
249:34 - situation here write that in the
249:35 - comments down below please before I
249:37 - execute this here and now if I press
249:41 - enter what is going to happen happen
249:44 - well our program has glitched a little
249:47 - bit and after that it has written out
249:48 - that our number contains 10 digits but
249:52 - this is definitely more than 10 why has
249:55 - this happened if you are not familiar
249:58 - with data types and overflow and concept
250:02 - Concepts that I have already talked
250:04 - about in one of my videos I am going to
250:07 - link that video here so make sure to
250:09 - watch that video and now I'm very
250:10 - quickly going to explain what has
250:12 - happened here but make sure to watch
250:14 - that video so when we have entered this
250:17 - number here let me stop this
250:19 - program and let me put let's see let me
250:24 - put a breakpoint here and now I'm going
250:27 - to run my program and what this
250:29 - breakpoint is going to do it's really
250:31 - going to stop the execution of my
250:33 - program at this line here and we haven't
250:37 - talked about breakpoints or debugging
250:39 - programs previously but if you want me
250:41 - to include that in one of my next videos
250:44 - make sure to write that in the comments
250:45 - down below because I really believe that
250:47 - it is important for you to see how your
250:49 - program is executed line by line so to
250:52 - be able to follow it and in that way you
250:54 - can really discover any bugs and any
250:57 - situations that are tricky and that are
250:59 - happening inside your program so you can
251:02 - see and control that better so I have
251:05 - put here a break point and let's now
251:08 - enter a number that is going to be a
251:10 - very large number
251:13 - okay so if I press enter now you see
251:17 - that my program has really stopped the
251:19 - execution here on this line here so
251:21 - after I have entered my number and then
251:25 - even though I have entered a number that
251:27 - is pretty large let's hover over this
251:31 - number variable you can see that it is
251:33 - holding a value of 2 billion And1 147
251:36 - million and something so this value here
251:40 - is definitely not equal to this value
251:43 - here but because our program has really
251:46 - gotten the value that is much larger
251:48 - than the maximum value that our int
251:51 - variable can hold it has really assigned
251:54 - the maximum amount that our int can hold
251:57 - to our number variable so that is what
251:59 - has happened in this program and if I
252:03 - click continue now you can see that our
252:05 - program writes out that our number
252:07 - contains 10 digits because it really was
252:10 - holding a 10 digigit number so that is
252:13 - the maximum amount that our int type can
252:16 - hold okay so that is the last situation
252:20 - that I wanted to explain to you and I
252:23 - hope that you like this video and if you
252:25 - have learned something new make sure to
252:28 - subscribe to my channel share it with
252:30 - all your friends anyone who would like
252:31 - to learn programming thanks for watching
252:34 - and I'm going to see you in my next
252:36 - video
252:38 - bye hi everyone welcome to my channel
252:41 - welcome to another video of C++ for
252:43 - beginners and first things first make
252:45 - sure to subscribe to my channel and hit
252:47 - that Bell icon as well and share this
252:50 - video with everyone it really helps me
252:51 - to reach a lot more people and in this
252:54 - video I want to show you how you can
252:56 - reverse a number so your user is going
252:58 - to enter a number and what we want to do
253:01 - is we want to write out that number in
253:03 - Reverse so reverse the order of the
253:05 - digits of that number and here I have
253:09 - opened my visual studio so let's copy
253:12 - the text of this
253:14 - task like
253:16 - this and the first thing that we need to
253:19 - do is we need to really create a
253:20 - variable so let's say int number like
253:24 - this so that our user can enter his
253:26 - value in this variable here so let's
253:29 - write out a message to our user so let's
253:31 - say see
253:33 - out number like this so that our user
253:36 - knows that he should enter a number and
253:39 - then let's accept that value in our
253:42 - number
253:43 - variable
253:45 - oh number like
253:48 - this now after our user has entered a
253:51 - number let's really think about how we
253:53 - are going to solve this
253:55 - problem okay I get it so the first thing
253:59 - that I notice here is that we are
254:01 - missing a variable and that variable is
254:03 - going to be the one that is going to
254:05 - hold our reversed number so let's
254:07 - declare it here I'm going to add it here
254:11 - and I'm going to call it let's say
254:14 - reversed
254:16 - number like this and I'm initially going
254:20 - to assign it a value of
254:22 - zero okay and now the algorithm that we
254:26 - are going to use in order to solve this
254:29 - task in order to reverse our number so
254:32 - the algorithm that we are going to use
254:34 - is going to be the following so this
254:36 - reverse number here it is holding a
254:39 - value of zero initially and this number
254:41 - here is the one that our user enters so
254:44 - let's say for example that our user
254:46 - enters a value of
254:49 - 123 like this so 1 23 so how we are
254:52 - going to reverse this number here the
254:56 - algorithm is going to be following so we
254:59 - are going to iterate through this number
255:01 - here so all the digits of this number
255:05 - here we are going to go through those
255:08 - and in each iteration we are going to do
255:10 - the following so the first thing is we
255:13 - are going to say please take this
255:14 - reverse number and multiply it by 10 so
255:18 - 0 * 10 is going to say to stay zero
255:22 - after that what we are going to do is we
255:23 - are going to take this last digit of our
255:26 - number that our user has entered and we
255:29 - are going to add that number to our
255:32 - reverse number so 0 + 3 and that is
255:35 - going to be equal to three and after
255:38 - that we are going to really remove that
255:41 - last digit of our number so I'm going to
255:43 - delete that digit and then in our next
255:47 - iteration what we are going to do is the
255:49 - same thing so we are taking this reverse
255:51 - number we are going to multiply it by 10
255:54 - so I'm going to say 3 * 10 that is going
255:57 - to be equal to
255:59 - 30 and after that we are going to take
256:02 - this last digit of our number and we are
256:06 - going to add that digit to this number
256:08 - here so to this reversed number so 30 +
256:12 - 2 that is going to be equal to
256:14 - 32 and then we can really remove this
256:18 - last digit here so I'm going to deleted
256:21 - after that we are going to the to the
256:23 - third iteration and we are doing the
256:25 - same thing so we are taking this revers
256:27 - number multiplying it by 10 so 32 * 10
256:31 - is going to be equal to
256:33 - 320 and then we are taking the last
256:36 - digit of our number this is this one
256:38 - here and we have to add that digit to
256:42 - our reversed number so 320 + 1 is going
256:46 - to be equal to
256:48 - 321 and after that as we did before we
256:51 - can really delete remove this digit here
256:56 - and then in my next iteration we are
256:58 - going to come here again and our Loop is
257:00 - really going to see that there is
257:02 - nothing else left to iterate through so
257:04 - there are no more digits and then it is
257:07 - really going to leave that Loop and at
257:10 - that moment we are really going to have
257:11 - our reverse number so 3 2 1 that is
257:14 - reverse number from the one that our
257:16 - user has initially entered so let's now
257:19 - translate this algorithm into our code
257:22 - so the loop that we are going to use in
257:24 - order to solve this problem here is
257:26 - going to be while loop so I'm going to
257:29 - write while and then in these
257:32 - parentheses here I'm going to really
257:34 - give it an expression that is going to
257:36 - check each time that it wants to run an
257:38 - iteration and what we are going to
257:41 - iterate through are the digits of this
257:43 - number here so the number that our user
257:45 - has entered so I'm going to say please
257:48 - iterate through this part here so
257:52 - execute this block of code here which is
257:55 - currently empty while our
257:58 - number so number where is it is
258:02 - different than zero like this okay and
258:07 - inside here we are going to write out
258:10 - the algorithm that I just explained and
258:12 - the first step of that algorithm was
258:14 - really multiplying our reverse number by
258:17 - 10 so I'm going to say reverse
258:21 - number is equal to reverse number time
258:26 - 10 like this okay and the shorter way to
258:29 - write this expression here is going to
258:32 - be like this so you can really take this
258:35 - part here delete it and say it like this
258:38 - it is going to do absolutely the same
258:40 - thing so it is going to really multiply
258:43 - our reversed number by 10 and then
258:46 - whatever that results in it is going to
258:48 - assign that back to our reversed
258:51 - number so that was the first step the
258:55 - Second Step In order to reverse our
258:56 - number is going to be really to take the
258:59 - last digit of this number that our user
259:01 - has entered so how can we do that we can
259:04 - do that by modulating this number here
259:07 - by 10 so I'm going to declare a variable
259:10 - let's call it um last digit like this
259:16 - and as we already said we can get that
259:18 - last digit if we modulate this number
259:22 - here where is it so this number that our
259:26 - user has entered by 10
259:30 - okay that is going to give us the last
259:32 - digit of this number here and then what
259:35 - we really want to do is we really want
259:37 - to add that last digit to our reversed
259:40 - number that was one part of this
259:43 - algorithm so the next step so I'm going
259:45 - to say reversed
259:48 - number plus equal to last digit like
259:54 - this or you can write it a longer way
259:57 - but this way I pref I prefer to write it
259:59 - um this way but you can as well say
260:01 - reverse number is equal to reverse
260:04 - number plus last digit and after we have
260:08 - added that last digit to our reverse
260:10 - number there is one more step left to do
260:13 - and that is to really take that last
260:16 - digit from our number and how we can do
260:19 - that well we can really do that by
260:22 - dividing our number by 10 so you can say
260:26 - number is equal to number divided by 10
260:29 - or number divided equal to 10 whichever
260:34 - way you prefer okay so this is really
260:38 - the algorithm that we explained and this
260:41 - step here you can can really write out
260:44 - the shorter way if you want so you can
260:46 - say for
260:48 - example reverse number plus equal to
260:52 - number modulated by 10 like this so you
260:57 - can make your code a bit more readable
261:00 - if you prefer it this way or you can
261:02 - leave this part here and then really add
261:04 - your last digit to your reversed number
261:07 - so now that we have done this algorithm
261:11 - here let's write out our reverse number
261:13 - and see what we have done so I'm going
261:15 - to write
261:16 - out C
261:18 - out and I'm going to say
261:22 - reversed like this okay and I'm going to
261:26 - write out our reversed
261:29 - number okay let me delete these empty
261:33 - spaces and if I run my program
261:37 - now it asks us to enter a number so
261:41 - let's enter number 1 2 3 and now if I
261:46 - press enter you can see that our program
261:48 - has really reversed this number here so
261:51 - let's quickly one more time explain how
261:53 - this has happened so our while loop has
261:55 - really iterated through this number here
261:58 - so that in each iteration it is going to
262:01 - do the following so it is going to take
262:03 - our reverse number and initially that
262:06 - reverse number is equal to zero so it is
262:08 - going to multiply that by 10 so it stays
262:11 - zero and after that is going to take
262:14 - that reverse number and add it the last
262:17 - digit of our number that our user has
262:19 - entered so that is going to be in a
262:20 - first iteration number three so our
262:23 - reverse number in that case becomes
262:25 - three so 0 + 3 is equal to three and
262:29 - after that we are going to really take
262:31 - that last digit from our number that our
262:33 - user has entered so it has taken this
262:35 - three part away and then in the second
262:39 - iteration is coming here it is going to
262:41 - check again whether or not number is not
262:43 - equal to zero and our number is going to
262:46 - be 12 in that situation so that is not
262:49 - equal to zero so it enters here again it
262:52 - executes this block of code here so it
262:56 - says again please multiply my reverse
262:59 - number by 10 and assign that again to my
263:02 - reverse number so our reverse number was
263:04 - three and if you multiply by 10 if you
263:07 - multiply 3 by 10 you are going to get 30
263:10 - after that it is taking the last digit
263:13 - of the number that our user has entered
263:15 - which is two now because three we have
263:17 - taken away in our previous iteration so
263:20 - it is going to add that two to my
263:22 - reversed number so number reverse number
263:25 - is going to become 32 now and then it is
263:28 - really going to take that last digit
263:32 - from our number away it is going to
263:34 - divide it by 10 so now we are left with
263:36 - number one and our reverse number is
263:38 - equal to 32 and then it goes back to to
263:42 - our third iteration it checks again
263:45 - whether our number so whether our
263:46 - remaining number is equal to zero and
263:50 - this one here is the value of our number
263:52 - so that is not equal to zero so this
263:55 - condition here is fulfilled it can enter
263:57 - the while loop so it does this algorithm
264:00 - here again so it says please multiply my
264:03 - reverse number by 10 our reverse number
264:05 - at this point is 32 so when you multiply
264:09 - that by 10 you get 320
264:12 - and then after that it takes the last
264:15 - digit of our number which is going to be
264:17 - this one so this one here which is the
264:21 - last one remaining so it is going to
264:23 - take this one and add it to my reverse
264:26 - number as you can see here and then it
264:29 - is really going to take that last digit
264:31 - away so it is going to take all of these
264:34 - three digits away so it has taken them
264:36 - in a previous situations and now it has
264:38 - taken this one away as well so our
264:40 - number is equal to zero now now and then
264:43 - it goes back to our fourth iteration it
264:46 - checks whether our number is not equal
264:48 - to zero but in this situation our number
264:51 - is equal to zero so it really leaves
264:55 - this Loop here so it is not going to
264:57 - enter in this Loop anymore and then it
264:59 - goes here and it really writes out the
265:02 - value of our reversed number which is
265:04 - this line of code here so that is how we
265:07 - have reversed our number so I hope that
265:10 - you like this video and that you
265:12 - understand this explanation if you have
265:14 - any questions write those in the
265:15 - comments down below and also share this
265:17 - video with all your friends with anyone
265:19 - who would like to learn programming and
265:21 - thanks for watching I'm going to see you
265:23 - in my next video bye hi everyone welcome
265:26 - to my channel welcome to another video
265:28 - of C++ for beginners if you are already
265:31 - a subscriber welcome back and if you're
265:34 - a new viewer make sure to subscribe hit
265:36 - that Bell icon as well and welcome to my
265:39 - channel so in this video I want to talk
265:41 - about the while loop and in my previous
265:45 - videos we have already talked about
265:47 - while loop and iteration in general so
265:49 - if you are not familiar with those make
265:51 - sure to watch that video I'm going to
265:53 - link it here but in this video I want to
265:56 - explain to you how and when is used do
265:59 - while loop and I'm going to give you an
266:02 - example of a program that is usually
266:04 - used and for example applications such
266:07 - as when you try to unlock your phone and
266:09 - then you are given three attempts to
266:12 - guess your pen and if you guess it
266:14 - correctly then you can proceed loading
266:17 - your phone's applications further or for
266:20 - example if you want to unlock your
266:22 - credit card so you put your credit card
266:24 - in ATM and then it gives you three
266:25 - attempts to unlock your credit card if
266:28 - you guess your pen correctly you can
266:29 - proceed further but if you fail so if
266:33 - you don't guess your pen correctly in
266:34 - those three attempts your account gets
266:37 - blocked so that is the application that
266:39 - we are going to make today and for that
266:41 - we are going to use do while loop so
266:44 - there are three things that we need
266:47 - actually three variables so I'm going to
266:49 - declare those three here the first one
266:52 - is going to be our let's say the the pin
266:55 - of our user so let's call it users
266:59 - pin like this which is going to be
267:01 - really the correct pin the one that you
267:04 - want to guess so I'm going to put here
267:07 - let's say 1 2 3 4 that is going to be
267:10 - our user pin after that that we need
267:12 - another variable which is going to be
267:14 - really the pin that our user enters so
267:17 - let's call that variable just pin okay
267:21 - like
267:22 - this and then the third variable that we
267:25 - need is going to be really counter of
267:27 - our errors so the counter of the
267:30 - attempts and errors that our user has
267:32 - made so I'm going to call that variable
267:35 - error
267:37 - counter like this and let's set that
267:41 - value initially to zero
267:44 - okay and the next thing that we need to
267:47 - do is we really need to give our user
267:50 - three attempts in order to guess this
267:53 - pin here and if he guesses it correctly
267:56 - in those three attempts we are going to
267:58 - write out that the application can be
268:00 - loaded further so we are going to write
268:02 - out application is loading or something
268:04 - like that but in the case that our user
268:07 - does not guess this pin here so this pin
268:10 - here correctly we we are going to really
268:12 - write out that the application or a
268:15 - credit card whatever has been blocked
268:18 - and how we are going to do that so we
268:21 - are going to use do while loop so I'm
268:23 - going to write out
268:25 - do like this and then here I'm going to
268:28 - put while because that is the syntax of
268:31 - our do while
268:33 - loop okay and here you need semic colum
268:38 - because if you don't put it you are
268:40 - going to get a syntax error now here we
268:43 - put the block of code that we want to
268:45 - execute in each iteration and here we
268:48 - put the condition that we want to check
268:50 - each time that this code here is
268:52 - executed we come here and then we check
268:54 - that condition and if this condition
268:56 - here that we put is correct we are going
268:59 - to go again here and do one more
269:02 - iteration and then again check and then
269:04 - do more one more iteration and we are
269:07 - going to repeat that until this
269:09 - condition that we put here is no long
269:11 - longer true when it when this condition
269:14 - here when it becomes false we are going
269:15 - to leave our do while loop okay so what
269:19 - do we want to enter so what do we want
269:22 - actually to do in this block of code
269:24 - here we really want to write out a
269:26 - message to our user so that he knows
269:28 - that he should enter a pin a pin and
269:30 - then we want to really accept that pin
269:32 - that our user enters in this variable
269:34 - variable here so let's do that first I'm
269:37 - going to write out C out like this and
269:41 - then then let's just write out pin like
269:45 - this and let's accept the value that our
269:49 - user has entered in our pin variable
269:52 - like this okay and then after we have
269:55 - done this what we need to do is we
269:57 - really need to check whether this pin
269:59 - here so this pin that our user has
270:01 - entered corresponds to this pin here so
270:04 - whether this value is equal to this
270:07 - value here and if they are not that
270:09 - means that our user has failed so in
270:12 - that case we are going to increase our
270:14 - errors counter so I'm going to put here
270:19 - if
270:21 - pin is not equal to users pin like this
270:26 - what we want to do is we want really
270:29 - increase our errors counter variable
270:32 - like
270:34 - this
270:35 - okay and this code here so we want to
270:39 - give the the attempt to user so that he
270:43 - can enter a pin and then we want to
270:45 - check whether that pin is correct three
270:47 - times or until this pin here and this
270:50 - pin here are the same so until they are
270:53 - equal or until until our user has used
270:56 - all of these three attempts that we have
270:59 - given to him okay so here I'm going to
271:03 - really put that condition so here inside
271:06 - these parentheses I'm going to write out
271:09 - please do this block of code here here
271:13 - while our e let's say while our
271:19 - errors
271:20 - counter is less than three like this and
271:26 - then also at the same time while our pin
271:30 - is not equal to users pin like this
271:36 - which means that this block of code here
271:38 - is going to be executed while our user
271:41 - has not used all of these three attempts
271:43 - that we have given to him and while this
271:46 - pin here so this pin here and this pin
271:49 - here are not equal in a situation where
271:52 - this here results as false we are going
271:55 - to come here and after that when we come
271:59 - here we really want to check whether we
272:01 - have left this do while loop here
272:04 - because our errors counter has reached
272:06 - three or because these two were the same
272:10 - in a situation where our errors counter
272:12 - has reached three that means that our
272:14 - user has used three attempts and that he
272:18 - has not guessed his pin
272:21 - correctly so I'm going to put here if
272:25 - our errors counter is less than three
272:30 - like this and this condition here really
272:33 - means that this do while loop has been
272:36 - left in a situation where our user has
272:39 - not used all of these three attempt that
272:42 - we have given to him that means that
272:45 - this while condition has really failed
272:48 - on this part here so that means that our
272:51 - user has entered 1 2 3 4 as pin and in
272:55 - that situation 1 2 3 4 is not equal to 1
272:58 - 2 3 4 that results as false so this
273:01 - whole expression here this whole
273:03 - condition results in false as false and
273:05 - then we leave our do while loop and in
273:08 - that situation if our user has not used
273:11 - all of these three attempts that really
273:13 - means that he has guessed his pin
273:15 - correctly so here in this if situation
273:18 - we can write out to our user see out you
273:22 - have guessed or you can proceed with
273:24 - loading of of this application so I'm
273:26 - going to write out just
273:29 - loading like
273:32 - this but in a situation where our while
273:35 - loop has been left because this errors
273:38 - counter is greater than three actually
273:40 - it is going to be equal to three that
273:42 - means that our user has failed in
273:44 - guessing his pin three times and that
273:47 - means probably that he's not trying to
273:49 - unlock his phone or his credit card so
273:52 - in that situation we are really going to
273:54 - block that account so we can say
273:58 - else see out
274:02 - blocked like
274:04 - this okay and I'm going to put one more
274:08 - here like
274:09 - this so this is going going to be a
274:12 - program that we really use to allow our
274:15 - user to enter three attempts of his pin
274:18 - and in a situation where he guesses that
274:21 - pin correctly in those three attempts we
274:23 - are going to write out to our user that
274:25 - he has successfully unlocked his phone
274:28 - for example and we can proceed with
274:30 - loading of applications but in a
274:33 - situation where he really uses all of
274:35 - those three attempts and fails to guess
274:37 - his pin we can write out that the
274:40 - application is blocked
274:45 - oh blocked now now it's now it's okay so
274:50 - let me run this
274:53 - program and let's try to use three
274:58 - attempts so I'm going to say that my
275:00 - first attempt is going to be for example
275:02 - 1 one one one like
275:06 - this so it says you have not guessed
275:10 - correctly please enter pin again this is
275:13 - what it means after that I'm going to
275:15 - try for example
275:18 - 2222 it tries to prompt me to enter my
275:21 - pin again because I have failed
275:23 - previously and let's say that my third
275:26 - third attempt is going to be
275:28 - 3333 like this and then it has said it
275:31 - has written out a message that my
275:33 - account has been blocked because I have
275:36 - missed three times okay so that is one
275:40 - scenario and and the other scenario is
275:42 - going to be really where we guess the
275:44 - one where we guess our pin correctly so
275:46 - let's say that our first attempt is
275:48 - going to be um 111 one again and after
275:52 - that we really remember what is the
275:55 - correct pin and we enter 1 2 3 4 like
275:59 - this and then if I press enter it says
276:02 - really you are loading you can you can
276:04 - load your application now or the further
276:06 - loading of your application is going to
276:08 - begin now because we have T the correct
276:12 - pin so let me very quickly explain one
276:15 - more time how has this happened so this
276:19 - code here when we come to this do while
276:22 - loop the first thing that is executed is
276:24 - this line here so it says please enter
276:26 - your PIN and then after your user enters
276:29 - the pin your program really checks
276:32 - whether that pin is equal to user's pin
276:35 - so the previous pin the one that he
276:36 - needs to guess and if those two are not
276:40 - equal that means that your user has not
276:42 - guessed correctly and then you want to
276:43 - increase your errors counter so the
276:47 - number of attempts that your user has
276:49 - used and failed actually in using so we
276:53 - increase in our first iteration that
276:55 - errors counter to one so from 0o to one
276:59 - and then we come here and then our Loop
277:02 - really checks whether that errors
277:03 - counter is less than three so one is
277:06 - less than three that is true and also it
277:08 - checks whether that pin here is is not
277:12 - equal to the pin that we need to guess
277:14 - and in this situation it is not equal so
277:18 - it also this this whole expression
277:20 - results as true and it now can go here
277:24 - again so it prompts you again to enter
277:26 - the pin so you can enter the pin now and
277:29 - in this situation we enter 2222 for
277:32 - example and then it guesses it it checks
277:34 - again so it checks whether pin that you
277:37 - have entered so 2222 is not equal to 1 2
277:41 - 3 4 for those two are not equal so it
277:43 - increases the errors counter once more
277:47 - and it becomes two now then you go here
277:50 - and then it says okay please check
277:52 - whether my user has used all of these
277:53 - three attempts it it it says that your
277:56 - errors counter is still less than three
277:59 - so you have used only two attempts so
278:02 - far and then this condition here results
278:05 - as true because you have entered 2222
278:07 - and that is not equal to your PIN so 1 2
278:10 - 3 4 and then it goes back here tries to
278:13 - prompt you one more time to enter your
278:15 - PIN and then if you fail this time it
278:18 - increases your errors counter to
278:21 - three like this and then it goes here
278:24 - and it checks whether your errors
278:26 - counter is less than three your error
278:28 - errors counter in this situation is uh
278:30 - has become three so this condition here
278:34 - results as false and your while the
278:36 - while loop actually is now broken so you
278:40 - are not going to continue the execution
278:41 - of your do while loop but you come here
278:44 - and then it checks whether errors
278:46 - counter is less than three because this
278:48 - here fails because this here results as
278:50 - false you are presented with this
278:53 - message here so blocked your phone your
278:55 - account has been blocked okay and in a
278:59 - situation where your user guesses
279:01 - correctly that errors counter is going
279:03 - to be less than three and you are going
279:05 - to be presented with a message of
279:07 - loading and there is one important thing
279:10 - that I want to mention and is really the
279:12 - difference between while loop and do
279:14 - while loop in do while loop you first do
279:18 - so you first execute this block of code
279:21 - here and then you check the condition
279:24 - and then if that condition results as
279:26 - true you go back and you again do this
279:29 - block of code here and then you check
279:32 - and then you do but in a situation of
279:35 - while loop you first check the condition
279:37 - and then if that condition results as
279:39 - true then you can really proceed with
279:41 - executing your block of code that comes
279:44 - after your while but in this situation
279:46 - here so in the situation of do while
279:48 - loop you first do this block of code
279:51 - here so uh irrelevant whether this
279:54 - condition here is true or not you are
279:56 - going to do this block of code here at
279:58 - least once I hope that you like this
280:01 - video if you did make sure to subscribe
280:03 - to my channel and click that Bell icon
280:05 - as well and also if you want me to post
280:08 - more videos like this make sure to like
280:10 - this video because then I will know that
280:13 - you liked it and well that's all I'm
280:17 - going to see you in my next video
280:19 - bye hi everyone welcome to my channel
280:22 - welcome to another video of C++ for
280:24 - beginners in this video I want to talk
280:26 - about four Loops but before we start
280:29 - make sure to subscribe to my channel and
280:31 - hit that Bell icon as well okay so what
280:35 - I'm going to explain today I want to
280:37 - explain to you how for Loop works and
280:39 - I'm going to explain that on a simple
280:42 - example which is calculating the
280:44 - factorial of a number so let me copy the
280:47 - text of our task here like this and I'm
280:52 - going to comment it out so what is the
280:55 - factorial of a number factorial of a
280:58 - number is usually defined as a product
281:01 - of all numbers between one and that
281:04 - number that you want to calculate the
281:06 - factorial of that means for example if
281:10 - your user enter here is number six let's
281:12 - say and you want to calculate the
281:14 - factorial of number six you are going to
281:16 - do that in a following way so 1 * by 2
281:21 - multipli by 3 4 5 and oh sorry six okay
281:29 - and then this here is going to result in
281:33 - 720 so this 720 is really going to be
281:38 - the result of your factorial of six and
281:42 - this example here is what we want to
281:44 - really translate in our program so we
281:46 - want our user to enter a number and then
281:49 - we want to calculate the factorial of
281:51 - that number and write that result out to
281:54 - our user and we are going to use for
281:58 - Loop for that so let me
282:00 - quickly declare a variable which is
282:03 - going to be called number okay like this
282:08 - and let's prompt our user that he should
282:10 - enter
282:11 - a
282:12 - number and then let's really store that
282:17 - number that our user enters in our
282:20 - number variable okay
282:24 - so after we have acquired a number that
282:27 - we want to calculate our factorial of
282:31 - let's explain how we are going to really
282:34 - do that so I'm going to do that using
282:37 - for Loop and what is the difference
282:40 - between four Loop and while loop and do
282:42 - while loop because we have previously
282:44 - talked about while loop and do while
282:46 - loop as well you can find those videos
282:48 - on my channel if you're interested and
282:49 - I'm going to link those videos in the
282:51 - description of this video if you want to
282:53 - watch them so the difference is that
282:56 - usually when you use for Loop beforehand
282:59 - you should know how many iterations that
283:02 - Loop is going to make so for how long
283:05 - your Loop is going to run so let me show
283:08 - you the syntax of our for Loop you say
283:11 - four and then you use these parentheses
283:14 - here in which we are going to put
283:16 - certain expressions in a moment and
283:18 - after that you put these curly brackets
283:22 - in which we are going to write out the
283:23 - code that is going to be executed in
283:25 - each iteration of our four Loop so
283:29 - inside this parentheses here we need to
283:31 - put three things what are those three
283:33 - things the first one is going to be to
283:36 - set the initial value of our counter
283:39 - variable that is the first one after
283:41 - that the second is going to be to really
283:44 - put the condition that your for Loop is
283:47 - going to check each time that it wants
283:49 - to run this block of code here so before
283:51 - each iteration it is going to check that
283:54 - condition so that is going to be the
283:56 - second thing and after that the third
283:58 - thing is going to be really a way for
284:01 - your counter value to come to that
284:04 - condition condition which means that you
284:05 - have to either increase or decrease your
284:08 - counter variable in order to reach that
284:11 - condition at certain point and then when
284:14 - that condition results as false your for
284:16 - Loop is not going to be executed anymore
284:19 - okay so those are three things that we
284:22 - need to put in these parentheses here
284:24 - and let's now look at this example here
284:26 - because from here we are going to really
284:29 - uh deduct which conditions which
284:31 - Expressions we are going to put here so
284:34 - if you notice this algorithm here
284:36 - because this is really algorithm nothing
284:39 - else um you see that this is really a
284:44 - counter this behaves as counter so it
284:46 - goes 1 2 3 four and it really starts at
284:51 - one and then it goes up to that value
284:54 - that your user has entered so we can use
284:58 - that for our expression here the first
285:02 - expression is initial value of our
285:04 - counter we need to declare that variable
285:06 - and we are going to call that variable I
285:09 - you can call it count
285:11 - or whatever you want really uh your
285:14 - compiler is not going to give you an
285:17 - error because of that but a common
285:19 - practice is to use a single letter
285:22 - variable name for this counter that you
285:24 - use in your for Loop so I'm going to use
285:27 - name I for that and the initial value of
285:30 - my I counter is going to be one because
285:34 - as you can see here it really starts on
285:37 - one and then after that we need to put
285:41 - the condition that your for Loop is
285:43 - going to check each time that it wants
285:44 - to run a new iteration and that
285:47 - condition as you can see here is really
285:50 - this this expression here this algorithm
285:53 - runs until it comes to this six until it
285:56 - comes to the value that your user has
285:58 - entered so we are going to put that here
286:01 - we are going to say please run this
286:04 - block of code here until my I is less or
286:08 - equal to number like this so whichever
286:12 - number our user enters and then the
286:15 - third thing is going to re be really to
286:17 - give our Loop a way to reach this
286:21 - condition here at some point which means
286:23 - to make this condition here false and
286:26 - then leave our four Loop and again we
286:30 - look here and you can see that your
286:33 - counter is really increasing in each
286:35 - iteration by
286:37 - one okay so here we are going to put I
286:41 - ++ which is in each iteration going to
286:45 - increase the value of our I counter by
286:48 - one okay so after we have put these
286:53 - expressions in these parentheses of our
286:55 - for Loop we need to really put a block
286:58 - of code that is going to be executed in
287:00 - each iteration of our four Loop and I'm
287:04 - going to declare before this for Loop
287:06 - here I'm going to declare another
287:08 - variable which I'm going to call
287:10 - tutorial and I'm going to give it a type
287:13 - of
287:15 - int okay like
287:18 - this and I'm going to assign the initial
287:22 - value to my factorial factorial variable
287:24 - and that is going to be
287:28 - one and then how I'm going to use this
287:31 - factorial variable in each iteration of
287:34 - my four loop I want to say that my
287:37 - factorial is going to be equal to
287:40 - whatever my factorial was previously
287:42 - holding multiply that by my current I
287:47 - value which means by the current value
287:49 - of my counter and how this is going to
287:53 - behave so let's say that our user enters
287:56 - for example number three and then your
287:59 - execution comes here and it says please
288:02 - declare a a variable which is going to
288:04 - be called factorial and it is going to
288:06 - have a value of one so we have assigned
288:08 - that value here and then it comes to
288:11 - your four Loop the first thing that your
288:13 - four Loop is going to do is it is going
288:15 - to declare this I variable here and
288:19 - assign it a value of one so we we are
288:22 - going to write that here so we are going
288:24 - to say I is equal to
288:27 - 1 and then it really goes here and
288:30 - checks this condition here before it
288:33 - determines whether it's going to run
288:35 - this block of code here or not so if
288:38 - this here results is true it is going to
288:40 - run this block of codee here and if not
288:43 - it is going to leave your for Loop so is
288:46 - your I less or equal to the number that
288:49 - your user has entered so your I is going
288:51 - to be one and then that is less or equal
288:55 - to three so your for Loop is going to
288:57 - execute this block of code here which
289:00 - means that it is going to come here and
289:02 - say factorial multiplied by one which is
289:05 - going to be 1 multiplied by 1 and that
289:09 - is going to result as one and it is
289:11 - going to assign the result of this here
289:13 - to your factorial variable which is
289:16 - going to stay one after that your for
289:19 - Loop comes here and at this close
289:22 - bracket here it really goes here and it
289:25 - increases the value of your I and this
289:29 - increment operator is going to increase
289:31 - it by one so your I now becomes two and
289:34 - then after that it goes back here and
289:37 - checks this condition here so it says
289:40 - please check check whether my two is
289:43 - less or equal to the number that your
289:45 - user has entered so two is less or equal
289:49 - to three so it is going to run this
289:52 - block of code here again and then it is
289:55 - going to do following so it is going to
289:56 - say please multiply my factorial value
289:59 - so the previous value that my factorial
290:01 - was holding which is one by the current
290:04 - value of my I which is 1 * 2 that is
290:09 - going to result as 2
290:11 - and that is going to be assigned to your
290:12 - factorial variable so we assign two here
290:16 - okay and then it goes back to these Clos
290:19 - brackets and then it goes here increases
290:23 - the value of your I again so your I now
290:27 - is three and then it really checks this
290:31 - condition here so whether three is less
290:33 - or equal to three the result of that is
290:35 - going to be yes so it is going to do
290:38 - this expression here again so so the
290:41 - current value of your factorial which is
290:42 - going to be two multiplied by the
290:45 - current value of your counter variable
290:47 - which is going to be three so 2 ultied
290:50 - by 3 that is going to be six and that is
290:53 - going to be assigned to your factorial
290:55 - variable after that it goes here and
290:58 - then it really increases again the value
291:01 - of your I variable so of the counter
291:04 - that you are using in your for Loop and
291:06 - that value becomes four now after that
291:09 - it is going to try to check this
291:12 - expression here so this condition here
291:14 - and four is not less or equal to three
291:20 - so your for Loop is not going to execute
291:22 - anymore and then your really your your
291:25 - execution comes here and at this line of
291:29 - code here it has the value of six in
291:31 - your factorial variable which means that
291:33 - we are left only with the need to write
291:38 - out this to our user so we need need to
291:42 - say um let's say it like this
291:46 - number okay and then let's say factorial
291:50 - of that number is going to be equal two
291:53 - and then let's write out the result so
291:57 - the result we are holding in our
291:59 - factorial variable like this so This
292:03 - should really write out the result of
292:07 - this here so the the factorial of this
292:09 - number that our user has has entered and
292:11 - if I run my
292:13 - program you can see that it asks us to
292:17 - enter a number I'm going to say let's
292:20 - say for example three and then if I
292:22 - press enter it is going to give us the
292:24 - result of six which is the correct
292:26 - result the one that we previously got
292:29 - let's run it one more time just check
292:32 - this number here so I'm going to say
292:35 - please give me a factorial of six and it
292:39 - calculates that the factorial of 6 is
292:42 - 720 as we did before so this is going to
292:46 - be really one way of writing this for
292:49 - Loop for this current example so for
292:52 - calculating factorial I want to show you
292:55 - another way how you can do exactly the
292:57 - same thing so I'm going to really
293:00 - comment this part of code here so I'm
293:03 - going to say um comment this block of
293:06 - code here and then there is another way
293:09 - to write these parenthesis here so as
293:13 - you can see this example here is what we
293:15 - have used in order to write these
293:19 - Expressions inside these parentheses but
293:20 - there is really one more way to
293:23 - calculate your factorial and that is
293:24 - going to be to start at this maximum
293:29 - value which means 6 factorial is equal
293:33 - to 6 multiplied by 5 by 4 3 2 1 and and
293:40 - that is going to be equal to
293:42 - 720 so now you start your counter at
293:46 - this maximum value so this number that
293:48 - your user has entered and then you
293:51 - really decrease the value of your
293:53 - counter and you go until your counter
293:56 - value comes to one and that is the
293:59 - condition when you stop so your one
294:01 - value of a counter is going to be the
294:03 - last iteration through your for Loop so
294:05 - now we are going to write out um so
294:08 - actually we are going to really write
294:10 - our for Loop using this algorithm here
294:13 - so we are going to say
294:16 - four and then also put this these
294:20 - parentheses which we are going to use
294:22 - for the block of code that we want to
294:24 - run through in each iteration and in
294:26 - these parentheses here I'm going to set
294:29 - the initial value of my counter that is
294:33 - going to be I is equal to and as you can
294:36 - see here our I starts at six so I'm
294:39 - going to put here six which means a
294:42 - number that our user has entered in this
294:44 - current situation it is six but since we
294:46 - want to calculate the factorial of
294:48 - whichever number our user decides to
294:50 - enter I'm going to use that variable
294:53 - here okay and then the condition that
294:57 - your for Loop is going to check each
294:58 - time that it wants to make a new
295:00 - iteration and that is going to be please
295:03 - run this block of code here until my I
295:07 - is greater than or equal to 2 1 okay and
295:13 - then the last thing that we need to put
295:16 - here is going to be really a way for our
295:18 - for Loop to stop at a certain point and
295:22 - if you look at this example here you see
295:24 - that your counter is decreasing by one
295:27 - in each iteration so we are going to put
295:30 - that here we are going to say I minus
295:33 - minus which means use this decrement
295:34 - operator on our I variable and then we
295:37 - are going to really use the same
295:39 - expression here
295:40 - here
295:42 - okay and this is going to give us the
295:46 - exact exactly the same result as this
295:48 - code here did so if I run my program you
295:52 - can see that it asks number again so if
295:54 - I enter number six for example it is
295:57 - going to give us
295:58 - 720 as this code here did as well so
296:02 - let's repeat one more time there are
296:04 - three things that you need to put in
296:06 - these parentheses here in order to set
296:08 - up your four Loop
296:10 - and the first one of those three is
296:12 - going to be to set the initial value of
296:14 - your I variable which means the initial
296:17 - value of your counter after that you
296:19 - need to put the condition which is going
296:21 - to be checked each time that your for
296:23 - loop wants to run an iteration and if
296:25 - this condition here results as true your
296:28 - for Loop is going to run this block of
296:30 - code here but if this condition here
296:33 - results as false your for Loop is not
296:36 - going to run this block of code here but
296:37 - you are really going to leave your for
296:39 - Loop and come to the next line after it
296:43 - and then the third thing that you need
296:44 - to put in these parentheses here is
296:47 - going to be really to either increase or
296:49 - decrease value of your counter variable
296:52 - so that it can reach this condition here
296:55 - at certain point and make it false so we
296:58 - have decreased it in this example here
297:00 - and we have increased it in this example
297:03 - here so those are three things that you
297:05 - need to put inside these parentheses
297:07 - here and you really need to separate
297:09 - those three using this semic colum sign
297:13 - okay and there is one more thing that I
297:15 - need to mention and that is going to be
297:17 - really you can upgrade this program here
297:20 - so that it checks whether this number
297:22 - here is greater than zero because you
297:25 - cannot calculate factorial of negative
297:28 - number so our program is not going to be
297:30 - behave as expected if you enter negative
297:32 - number and also the factorial of zero is
297:36 - going to be equal to 1 so you can put
297:39 - that code here and determine whether
297:41 - your user has entered positive or
297:44 - negative number and in case that your
297:46 - user has entered negative number make
297:47 - sure to write out appropriate message to
297:50 - your user so I think that is all if you
297:53 - like this video and if you learned
297:54 - something new make sure to subscribe to
297:56 - my channel and hit that Bell icon as
297:59 - well share it on your social media
298:00 - because it really helps me to reach a
298:02 - lot more people so that all of us can
298:05 - learn and upgrade our knowledge in
298:07 - programming and I'm going to see you in
298:09 - my next video bye hi everyone welcome to
298:13 - my channel welcome to another video of
298:14 - C++ for beginners in this video I want
298:17 - to talk about nesting Loops in my
298:20 - previous videos we have talked about
298:23 - while loop do while loop and for Loop
298:25 - and now I want to show you the example
298:27 - on how you can really combine and Nest
298:30 - those Loops so if you haven't watched my
298:33 - previous videos or you are not familiar
298:35 - with loops at all I recommend you to
298:37 - watch those I'm going to link those in
298:38 - the description of this video
298:40 - and also before we start make sure to
298:42 - subscribe to my channel and click that
298:45 - Bell icon as well so what are we going
298:48 - to do in this video I want to really
298:51 - show you how you can nest for Loop and
298:54 - do while loop and the example that I'm
298:56 - going to use to explain that is going to
298:59 - be following so I want my user which is
299:02 - going to be a student let's say to enter
299:05 - three grades or more if you want we are
299:08 - going to use three for desk exam
299:11 - and I want to those grades I want those
299:13 - grades to be between 1 and five and then
299:17 - I want to write out the average grade so
299:20 - the average grade between those three
299:21 - that he has entered so let's start
299:25 - building our program the first thing
299:27 - that I need to explain is since we are
299:29 - going to enter three grades that means
299:31 - that we are going to repeat that
299:33 - entering process three times and for
299:36 - that I'm going to use for Loop so I'm
299:38 - going to write
299:40 - four and then in these parentheses here
299:43 - I'm going to put my initial set setup of
299:46 - four Loop which is going to be the first
299:49 - thing is going to be initial value of
299:51 - our counter so I'm going to declare a
299:54 - counter which is going to be called I
299:56 - and initially I'm going to give it a
299:58 - value of zero that is the first thing
300:01 - the second thing that I need to put in
300:02 - these parentheses here is going to be
300:04 - the condition that our Loop checks each
300:06 - time that it wants to run a block of
300:09 - code which is going to be this block of
300:11 - code that we put inside these
300:13 - parentheses so that condition we put
300:16 - here and that condition is going to be
300:19 - while our I is less than three so we
300:22 - want to make three iterations in the
300:25 - first iteration our I has the value of
300:27 - zero in the second iteration it's going
300:29 - to have the value of one and then in our
300:31 - third iteration it's going to have the
300:33 - value of two so we have made three
300:36 - iterations after that it gets the value
300:38 - of three but this condition here is not
300:41 - going to be true anymore so then our for
300:43 - Loop is not going to be executed anymore
300:47 - so that is the second thing and then the
300:49 - third thing which we need is going to be
300:51 - really increasing that value of our
300:54 - counter in each iteration so after age
300:56 - iteration and I'm going to put here this
301:00 - increment on our I variable okay
301:04 - so in this block of code here we are
301:07 - going to repeat three times something so
301:10 - what is that something that is going to
301:12 - be really the process of our user
301:15 - entering the value for his grade and
301:19 - since we said that that grade needs to
301:21 - be between 1 and five I am going to use
301:26 - do while loop for that how well I'm
301:30 - going to write out do okay and then here
301:34 - I'm going to put while which is going to
301:36 - be the condition so here we prompt our
301:39 - you user to enter the grade and then we
301:42 - we say here you are going to have to
301:45 - enter that grade while that grade is
301:49 - less than 1 or greater than five so
301:53 - since we don't have any variable that we
301:55 - are going to use to enter that grade I
301:57 - will have to declare it here so I'm
301:59 - going to say here int grade like this
302:05 - okay and then let's prompt our user in
302:08 - this block here to enter his grade so
302:12 - I'm going to write out C
302:15 - out and let's say
302:19 - enter
302:21 - grade and I am going to use the current
302:24 - value of my counter so that I can really
302:26 - say um which grade my user is entering
302:30 - so enter first grade second grade and
302:33 - third grade so I'm going to say I + 1
302:37 - like this y + one well because our
302:41 - counter starts at zero and it wouldn't
302:44 - make much sense to say to our user
302:46 - please enter grade zero so that is why
302:50 - I'm increasing this value of my I when I
302:53 - want to write out a message to my user
302:57 - okay like this so here I'm going to
303:01 - write out please enter a grade and after
303:05 - that I need to accept that grade that my
303:07 - user enters in my grade variable so I'm
303:10 - going to say C
303:11 - in grade like
303:14 - this and we are going to repeat this
303:17 - process here for a single grade while
303:23 - our user enters a grade that is less
303:27 - than one
303:29 - or grade is greater than 5 okay so our
303:35 - program is really going to prompt our
303:37 - user please enter grade one and then he
303:39 - enter six for example and then our
303:42 - program checks this condition here and
303:43 - says okay you have missed this part here
303:47 - so go back and then please enter grade
303:51 - one so first grade again okay so if I
303:54 - run my program now let's just prove that
303:57 - very quickly so our program our program
304:00 - says now enter first grade so enter
304:03 - grade one and then let's say that I
304:05 - enter nine for example it prompts me
304:08 - again to enter first grade because I
304:11 - have not obeyed this rule here this part
304:15 - here so I'm going to say this time for
304:17 - example five and then it says okay you
304:21 - have successfully entered first grade
304:24 - let's now enter second grade so for that
304:27 - second grade let's enter for example
304:30 - zero and then it prompts me again you
304:33 - have not entered correct value for grade
304:36 - two please enter it again and let's say
304:38 - that this time I'm going to enter one
304:41 - and then it asks for third grade and
304:44 - let's say that this time third grade is
304:46 - going to be three so our program now has
304:50 - successfully accepted this third grade
304:52 - and now our program is going to really
304:54 - uh finish its execution because we
304:56 - haven't written anything else after this
304:59 - part here so there is something else
305:02 - that we need to write and since we want
305:05 - to calculate the average grade of our
305:07 - user what we are going to need is going
305:10 - to be really to sum all of these grades
305:13 - that our user enters so I am going to
305:16 - declare a variable which is going to
305:18 - really hold that sum of our users grades
305:21 - so I'm am going to put it
305:24 - here I'm going to call it sum and
305:28 - initially I'm going to assign it a value
305:30 - of zero and later I'm going to explain
305:33 - why so I have declared a variable that
305:37 - is going to be of type int and I have
305:39 - called it sum and assign it a value of
305:42 - zero so this sum here is going to each
305:46 - time that our user enters a grade and we
305:48 - really um we really check that that
305:51 - grade is valid grade after that we want
305:54 - our sum to hold whatever it was
305:58 - previously holding plus the value of our
306:01 - grade like
306:04 - this okay so why I have assigned a value
306:08 - of zero to my sum because zero is a
306:11 - neutral value when it comes to adding
306:14 - numbers you add zero to whichever number
306:16 - and then you get that same number and in
306:19 - a situation where we didn't assign any
306:21 - value to our sum we would get really um
306:24 - an error so if I try to run my program
306:27 - now you see that it prompts me with an
306:30 - error and it says uninitialized local
306:32 - variable sum used because it does not
306:35 - have any value assigned to this variable
306:38 - here it is going to say really that it
306:41 - does not know how to add the value so
306:44 - the value of our grade to our sum so
306:47 - that is why we need to assign some value
306:50 - to our sum variable okay so and that
306:53 - value is going to be zero because zero
306:55 - is neutral when it comes to adding
306:58 - numbers okay so now I can really run my
307:03 - program and as you can see um that error
307:06 - has disappeared so I'm going to stop my
307:09 - program
307:10 - and let's very quickly write out this
307:13 - sum that we have calculated here so I'm
307:17 - going to say see
307:19 - out and I'm going to write out
307:22 - sum like this sum is equal to and then
307:26 - let's write out the value of our sum and
307:29 - let's add end line like this so I am
307:33 - going to run my program once
307:35 - more it prompts me to enter first grade
307:38 - I'm going to say that my first first
307:39 - grade is going to be for example five
307:42 - and then my second grade is going to be
307:44 - for example six uhuh that's an error so
307:48 - please enter your second grade again so
307:50 - I'm going to enter this time two let's
307:54 - say and then for my third third grade
307:56 - let's enter one for example and it says
307:59 - that the sum of my grade grades is equal
308:02 - to 8 which is correct so 1 + 2 + 5 that
308:07 - is going to equal to 8 so what we are
308:10 - left to do now we should only really
308:13 - divide our sum by the count of our
308:17 - grades which is three because we have
308:19 - hardcoded this value here to three so
308:22 - our user can enter only three grades you
308:25 - can really use a variable for this or
308:27 - you can part code it to any other value
308:30 - that you want and need so here after
308:34 - this line of code here what I need to do
308:36 - is following so I'm going to say C out
308:40 - out and then let's say average is equal
308:45 - to let's say average grade is equal to
308:50 - and let's write out the result so that
308:53 - is going to be sum divided by three
308:59 - okay is it though so I'm going to run my
309:03 - program and let's enter for example
309:06 - value two and then again value two and
309:09 - then let's enter for example value four
309:13 - and then it says that average grade is
309:15 - equal to two which is not correct but
309:18 - why has this
309:20 - happened so as you can see here we have
309:23 - used two integer variables so our sum is
309:27 - integer value and then three is integer
309:29 - value as well so when you divide two
309:32 - integer values the result is also going
309:34 - to be integer value so in order to get a
309:37 - floating point a decimal point Point
309:39 - number you really need to convert one of
309:41 - these two into a float type so you can
309:44 - say either here you can say float so
309:48 - please convert my sum variable into
309:51 - float and then divide or you can put
309:54 - here this 0 Z or you can leave both of
309:58 - these whichever you prefer so I'm going
310:00 - to leave both of these like this so if I
310:04 - run my program once more it prompts me
310:07 - again to enter first first grade so I'm
310:10 - going to say that my first grade is
310:12 - equal to five and then my second grade
310:14 - is also five and then let's say that the
310:18 - third grade of our user is going to be
310:20 - nine so our program prompts us again to
310:23 - enter the third grade because it needs
310:25 - to be in this interval here so I'm going
310:28 - to say now that uh the value of my third
310:31 - grade is going to be three which is
310:32 - correct value and after that as you can
310:35 - see it writes out that the sum of these
310:38 - three grades
310:39 - is 13 and then average grade is
310:43 - 4.33
310:45 - 333 so that was an example on how you
310:48 - can really combine and Nest Loops in
310:51 - order to solve complex problems and
310:54 - thanks for watching make sure to
310:56 - subscribe to my channel click the Bell
310:58 - icon also share it with anyone who would
311:01 - like to learn programming and I'm going
311:04 - to see you in my next video
311:06 - bye hi everyone welcome to to my channel
311:10 - welcome to another video of C++ for
311:12 - beginners in this video I want to talk
311:14 - about nesting four Loops so I want show
311:17 - you how you can solve more complex
311:19 - problems using nested for Loop but
311:22 - before we start please subscribe to my
311:24 - channel and click the Bell icon as well
311:27 - and also like this video so this example
311:31 - that we are going to do today is going
311:33 - to be really multiplication stable so
311:36 - I'm going to show you the example that I
311:39 - want to program so that would be this
311:43 - here and if you look at this
311:45 - multiplication table that we want to
311:47 - make you can really start to notice a
311:50 - pattern and what pattern I mean you see
311:54 - here this this first end in this first
311:57 - part of my multiplication table so in
311:59 - this first table as you can see this
312:02 - first end is one and it stays one in
312:06 - this table here after that you can look
312:09 - at this second table you see that this
312:11 - end is now two and then in my third
312:13 - table it has increased to three
312:17 - 4 five and it really increases so it
312:21 - increments by one and it goes up to 10
312:25 - okay so that is the first operand so
312:27 - this first part of my multiplication
312:30 - after that we can look at this second
312:32 - operand and you can really notice that
312:34 - it
312:35 - increases in each iteration by one so it
312:38 - goes one two three four five up to 10
312:43 - and then it does the same thing in this
312:45 - second table so it goes from 1 to 10
312:49 - again and then the same in my third
312:51 - table fourth fifth and it really behaves
312:54 - the same in this 10th table as well so
312:58 - that is the pattern that I want you to
313:00 - notice so this first oper end can be
313:04 - really represented using one for Loop so
313:07 - let's say that that is going to be outer
313:09 - for Loop and it is going to increase
313:13 - each time that my second upper end
313:17 - Counts from 1 to 10 and that second
313:19 - opont we can really represent using
313:22 - another for Loop which is going to be
313:23 - really inner for Loop so the program the
313:27 - algorithm for for solving this problem
313:29 - is going to go like this you have outer
313:31 - for Loop which is going to count from 1
313:34 - 2 3 4 up to 10 so it is going to count
313:37 - from 1 to 10
313:39 - and then you are going to have inner for
313:41 - Loop which is also going to count from 1
313:44 - to 10 but for each value of my counter
313:48 - of my outer loop okay so that means that
313:52 - my outer loop counter changes only after
313:55 - my inner loop has counted from 1 to 10
313:59 - so let's copy the text of our task here
314:02 - I'm going to say multiplication table
314:04 - and let's comment that text out so as we
314:07 - said in order to solve this problem we
314:09 - are going to use nested for Loops so I'm
314:14 - going to add empty space here and then
314:16 - the first thing that I need is going to
314:18 - be my outer loop so I'm going to really
314:21 - set up my outer loop I'm going to say
314:24 - four and then we need to declare a
314:26 - counter which I'm going to call I so I'm
314:29 - going to say int I is equal to and then
314:33 - since our outer let me show you this
314:35 - image one more time since it goes from
314:38 - one to 10 I'm really going to set its
314:41 - initial value to one so I'm going to say
314:44 - I is equal to 1 and then I'm going to
314:47 - write the condition so how long this for
314:50 - Loop is going to run and that is going
314:53 - to be while this I is less than or equal
314:57 - to 10 like this and then each iteration
315:01 - it is going to increase by one so that
315:03 - is going to be
315:06 - i++ okay and then I'm going to put this
315:08 - block of code here that is going to be
315:10 - executed in each iteration of this for
315:13 - Loop so what we need to do in each
315:17 - iteration of our for Loop let's look at
315:19 - our image one more time and as you can
315:22 - see it really says that in each
315:25 - iteration of this outer for Loop you
315:27 - need to count from 1 to 10 so in this
315:30 - iteration here some other counter really
315:33 - counts from 1 to 10 and then new
315:36 - iteration so our I is now two and then
315:39 - counter counts again from 1 to 10 and
315:42 - then three but also we have this inner
315:44 - counter that counts from 1 to 10 okay so
315:49 - let's really write that code so that
315:52 - inner counter that counts from 1 to 10
315:54 - for each value of our I we are going to
315:56 - represent with another for Loop and that
315:59 - is going to be really that nested or
316:02 - that inner for Loop so I'm going to
316:04 - write
316:04 - four and that inner counter I'm going to
316:08 - call J so I'm going to write int J and
316:13 - since our J also Counts from 1 to 10 I'm
316:16 - going to set its initial value to one
316:19 - and I'm also going to say
316:22 - please iterate through this for a loop
316:25 - while our J is less than or equal to 10
316:29 - as well and then in each iteration
316:32 - please increase the value of J by one so
316:35 - do this increment operation and then in
316:38 - each iteration of our J Loop we are
316:41 - going to execute this block of code here
316:44 - so what we are going to do in this block
316:46 - of code here well let me look at that
316:50 - image once more and as you can see in
316:53 - each iteration of our J so this is one
316:55 - iteration of our J this is second third
316:59 - fourth fifth and then 10th iteration of
317:02 - our J after that we change our I counter
317:06 - value so we increment that and then our
317:08 - J starts again starts one more to count
317:11 - from 1 to 10 so in each of these
317:15 - iterations as you can see really we have
317:18 - to multiply our I value counter with our
317:21 - J value counter and write the result of
317:24 - that so I am going to write that here I
317:28 - am going to write C out like this and
317:32 - then let's write out the value of our I
317:34 - counter like this and then let's write
317:38 - out this this
317:39 - multiplication operation and then let's
317:42 - write out J like this this is just for
317:46 - maing our text so I'm going to put this
317:50 - equal
317:51 - sign and then I really want to multiply
317:55 - those two counters like this and let's
317:58 - also add one end line here so that our
318:02 - text is formatted nicely because we are
318:04 - going to have multiple multiple lines so
318:08 - with this we we have really covered this
318:10 - multiplication part and there is only
318:13 - one more thing left to do and that is to
318:15 - add one more end line because I really
318:17 - want to make separation between these so
318:20 - I want to make separation between these
318:22 - tables this is going to be one logical
318:25 - part after that this is going to be
318:26 - another then third fourth and I want to
318:29 - put uh empty space space between those
318:32 - two so that I can group them group them
318:35 - so I'm going to add here C out and line
318:39 - like this and that should be it pretty
318:42 - much so if I run my program
318:46 - now as you can see it has
318:49 - generated this multiplication table from
318:53 - 1 to
318:55 - 10
318:57 - okay and it has done that in a matter of
319:00 - less than a second so as you can see
319:04 - here we have this outer counter oh I
319:07 - cannot Mark that only so we have this
319:10 - outer counter which is going to be our I
319:14 - that counts from one to 10 but for each
319:19 - value of our outer counter for so for
319:22 - each value of our I we have to really
319:24 - count from 1 to 10 with our inner
319:27 - counter which is going to be our J as
319:30 - you can see
319:32 - here okay so these are the results of
319:36 - our multiplication operation and I hope
319:40 - that you have seen now how you can
319:42 - really use programming to your advantage
319:44 - how you can use it to solve not really
319:46 - complex but tedious tasks you would
319:50 - really need 20 or 30 minutes in order to
319:52 - write this yourself and you can now
319:54 - generate it with just couple of lines of
319:56 - code and less than a second of your
319:58 - computer's power to to Really execute
320:01 - this code here that you have written and
320:04 - the most amazing part is that you don't
320:06 - really have to put 10 here here so we
320:09 - have put 10 here because I want to make
320:12 - this example manageable for this video
320:15 - but you don't have to hardcode these
320:17 - values here you can really use whatever
320:19 - values you want you can say for example
320:22 - let's say
320:24 - 2,000 okay so I want to generate
320:26 - multiplications stable up to 2,000 how
320:29 - long would that take in real life so
320:31 - without programming okay now you see
320:39 - a few moments
320:41 - later okay so it is still running and it
320:44 - is going to generate around 4 million
320:47 - records which is a lot and it is going
320:49 - to do that in a matter of minutes so how
320:52 - long would it take for you to even just
320:54 - count from 1 to 4 million it would take
320:56 - you probably days if not months and also
321:01 - there were a lot of errors that you
321:02 - would probably make in that process so I
321:06 - hope that now you can really recognize
321:08 - the power of programming now if you
321:10 - needed to do this task you would really
321:12 - program your computer to do it and now
321:14 - you can just go take a break and your
321:16 - computer is going to finish that task
321:18 - for you so I hope that you can recognize
321:21 - now how you can use programming in order
321:24 - to solve different types of tasks that
321:26 - you can come across in your school in
321:29 - your job or life in general and if you
321:32 - like this video make sure to subscribe
321:34 - to my channel also click the Bell icon
321:37 - and share it with anyone who would like
321:39 - to learn programming and I'm going to
321:41 - see you in my next video
321:43 - bye hi everyone welcome to my channel
321:46 - welcome to another video of C++ for
321:48 - beginners in this video I want to show
321:50 - you how you can draw shapes using C++ so
321:54 - before we start make sure to subscribe
321:56 - to my channel and also hit that Bell
321:58 - icon as well so that you are notified
322:00 - when I publish my next video and let me
322:04 - show you now what we are going to do in
322:06 - this video so here where is it here I
322:10 - have image of the task that we are going
322:13 - to do today and that is going to be
322:15 - really to draw this rectangle shape with
322:19 - the desired height and width and the
322:22 - symbol that our user enters okay so that
322:26 - is the task that we are going to do in
322:28 - this video and let's very quickly
322:31 - analyze this problem and see how we are
322:33 - going to solve it so the first thing
322:36 - that we need is for our user to enter
322:38 - height width and then symbol and after
322:42 - that we will really need to figure out a
322:45 - way so figure out the algorithm on how
322:47 - we are going to draw this rectangle
322:50 - shape here so if you look at this
322:53 - rectangle shape you can really notice
322:55 - that it has the height that is going to
322:58 - be three of these symbols that our user
323:01 - has entered and then it has the width
323:03 - that is going to take four of these
323:06 - symbols that our user has entered for
323:08 - width okay so we are going to use nested
323:12 - for Loop in order to solve this problem
323:15 - here and if you're not familiar with
323:17 - nested four loop I am going to link that
323:19 - video here because I have already made
323:21 - one video with nested four Loops so make
323:24 - sure to watch that video and in this
323:27 - video I am going to really use that
323:30 - nested for Loop in order to control
323:32 - height and width of our rectangle shape
323:36 - so we are going to have outer for Loop
323:39 - which is going to really control this
323:42 - height and then for each iteration of
323:45 - our outer for Loop we are really going
323:47 - to control this width with another loop
323:52 - and we are going to count from one up to
323:56 - four because four is the width that our
323:58 - user has entered and draw that shape in
324:00 - each iteration of our inner for Loop
324:04 - okay so that is what we are going to do
324:07 - so let's now translate that into code
324:10 - I'm going to say here first thing that
324:12 - we need is going to be from our user to
324:14 - enter width and height so I'm going to
324:17 - declare two variables the first one is
324:19 - going to be
324:21 - height like this and then
324:25 - with Okay so let's write out a message
324:29 - to our user so that he knows that he
324:31 - should
324:32 - enter
324:35 - height okay now let's accept that height
324:40 - value in our height variable and after
324:43 - that let's really copy this and do the
324:45 - same thing for our
324:48 - width like this and accept that value in
324:52 - our width variable so that is the first
324:55 - step the second step is going to be to
324:58 - declare another variable which is going
324:59 - to hold the symbol that our user wants
325:02 - to use for drawing that shape so I'm
325:04 - going to declare a variable of type Char
325:07 - and I'm going to call it
325:09 - symbol like this and let's write out a
325:13 - message to the user so that he knows
325:15 - that he should enter that
325:17 - symbol like this and let's say C
325:22 - in
325:25 - symbol so after we have acquired all the
325:28 - necessary inputs from our user which are
325:31 - height width and symbol that we are
325:34 - going to use to draw our shape now we
325:37 - are left to write the algorithm that is
325:40 - going to draw that rectangle shape so as
325:43 - I already said for that we are going to
325:45 - use nested for Loop so I am going to set
325:49 - up my outer loop the first Loop and I'm
325:52 - going to say four and then I'm going to
325:55 - declare the counter which is going to
325:56 - count the iterations of my outer loop
325:59 - since that outer loop is going to
326:02 - control the height of our rectangle I'm
326:04 - going to say int H so I'm going to give
326:08 - the
326:08 - H name to our outer counter and I'm
326:11 - going to set its initial value to zero
326:14 - like this and then we are going to put
326:17 - the condition how long our outer loop is
326:19 - going to run so while our H is less than
326:24 - height that our user has entered like
326:28 - this and then after each iteration of my
326:31 - outer loop we have to increment the
326:33 - value of our H counter so that would be
326:37 - the setup of our Outer Loop and let's
326:40 - Now set up our inner loop so I'm going
326:43 - to write
326:44 - four and for this inner loop I'm going
326:47 - to declare another counter which I'm
326:49 - going to call W like this because this
326:53 - inner loop is going to control the width
326:55 - of rectangle shape so I'm going to set
326:58 - its initial value to zero as well and
327:01 - then I'm going to say that it is going
327:02 - to run while this W is less than with
327:08 - that our user has entered like this and
327:11 - also after each iteration we really need
327:13 - to increment the value of this
327:18 - W okay so what we are going to do in
327:22 - this Loop so in this inner loop if you
327:25 - look at this image here where is it okay
327:28 - here you can really notice that in each
327:32 - iteration of our inner loop it just
327:34 - draws this symbol that our user has
327:37 - entered so I am going to very quickly
327:40 - just see out so write that symbol out
327:43 - I'm going to say see out and then write
327:46 - out that symbol like this and there is
327:49 - really one more thing that we need to
327:51 - put and that is going to be after this
327:53 - four Loop so this outer for Loop
327:56 - finishes single iteration we really need
327:59 - to put something else at the end so here
328:02 - at the end of our outer for Loop and
328:05 - let's look at our image so as you can
328:07 - see here after each iteration of our
328:11 - outer four Loop because it is
328:12 - controlling height and it is really
328:15 - iterating through this inner four Loop
328:18 - in each iteration of our outer four loop
328:21 - at the end of that iteration of outer
328:24 - for Loop we really need to put empty
328:26 - space so here I need to put empty space
328:30 - and that corresponds to this line here
328:34 - so here I'm going to write out C out end
328:38 - line like this and now if I run my
328:43 - program we should really expect to see
328:46 - the shape that rectangle shape of
328:49 - Dimensions that our user defines so
328:51 - let's say for height four and then for
328:54 - width let's say for example six and the
328:57 - symbol that we want to use to draw that
328:59 - shape let's say that that is going to be
329:01 - this plus symbol okay so as you can see
329:06 - our rectangle has the height of four and
329:10 - then it has the width of 2 4 6 so it has
329:14 - the width of six of these symbols that
329:16 - our user has entered okay so there is
329:19 - one more thing that I notice here and
329:21 - that is going to be really to format
329:23 - this shape uh to be a bit more pretty so
329:28 - for that we are going to use the library
329:32 - which is called IO manip so I am going
329:35 - to include that Library here I have to
329:38 - say
329:40 - include
329:42 - IO manip like this and this Library here
329:47 - really contains a function that is that
329:49 - is called set W which means set width
329:53 - which is really going to set the width
329:55 - of the field that comes after it so I'm
329:58 - going to put here that function I'm
330:01 - going to say I'm going to put these
330:04 - redirection signs here and then in this
330:07 - space here I'm going to write out set V
330:11 - so set W actually and then here I want
330:14 - to put what is the width of the field
330:17 - that comes after this function so what
330:20 - is going to be the width of our symbol
330:22 - field and let's use three for DOT for
330:25 - example so if I run my program again but
330:28 - let me stop it first and if I run it
330:32 - again oh no I haven't stopped my program
330:36 - so I'm going to close it
330:38 - okay and now if I run my program you can
330:41 - see that it asks height and width again
330:44 - so previously we have entered four and
330:47 - six and then for the symbol let's enter
330:50 - plus again and now as you can see our
330:53 - shape looks much nicer because of this
330:57 - set width function because it has really
330:59 - assigned to each symbol to each
331:01 - character that our user has entered the
331:04 - width of three Fields okay so let's run
331:09 - our program one more time and let's say
331:12 - that that height is going to be five and
331:14 - width is going to be seven and let's
331:17 - enter another shape so let's say for
331:19 - example minus and as you can see it has
331:22 - written out the shape so the rectangle
331:25 - shape of these Dimensions that our user
331:27 - has entered and it has used this symbol
331:30 - that our user also has
331:33 - entered so I hope that you enjoyed this
331:36 - video if you did make sure to sub
331:37 - subscribe to my channel and click the
331:39 - Bell icon as well also if you want me to
331:42 - make more videos like this so if you
331:44 - want me to use programming to draw more
331:46 - shapes make sure to write that in the
331:48 - comments down below so that I can know
331:49 - that you really enjoyed this video and
331:52 - like it as well and thanks for watching
331:55 - I'm going to see you in my next video
331:58 - bye hi everyone welcome to my channel
332:01 - welcome to another video of C++ for
332:03 - beginners and this video is going to be
332:06 - sort of a continuation to my previous
332:08 - video in which I showed you how you can
332:10 - draw rectangle shape using
332:12 - C++ and in this video I want to show you
332:15 - how you can draw triangle and reversed
332:18 - triangle shapes using C++ as well so if
332:21 - you're not familiar with how you can
332:23 - draw rectangle I would suggest you to
332:25 - watch that video first I'm going to link
332:27 - it here because in my opinion it is a
332:31 - bit more difficult to draw triangle than
332:34 - it is to draw a rectangle shapes so what
332:37 - one more thing I have also created
332:39 - Instagram and Twitter accounts so if you
332:42 - are interested in how developer life
332:45 - looks like and also if you're interested
332:47 - in behind the scenes of these videos
332:48 - that I post on YouTube make sure to
332:50 - follow me on my other social media so at
332:53 - true code Beauty Instagram and Twitter
332:56 - accounts I'm going to put the link to
332:58 - those in the description of this video
333:00 - so without further Ado let's start
333:02 - drawing our triangle shape so here I
333:05 - have the shape that we are going to draw
333:07 - in this video and that is going to be
333:10 - this equilateral triangle shape that I
333:12 - have here and there is a couple of
333:15 - things that I want to explain before we
333:17 - start to write code the first thing is
333:19 - going to be that this height our user
333:22 - really has to enter this height so we
333:24 - are going to let our user decide how
333:27 - many of these symbols are going to be on
333:29 - this side and this side and this side as
333:32 - well and the second thing is going to be
333:34 - that our user defines this symbol so
333:37 - which whichever symbol our user wants to
333:39 - use in order to draw this shape we are
333:41 - going to use that symbol that he enters
333:44 - those are two things that we need from
333:46 - our user and then it is up to us to
333:49 - really think and figure out the
333:52 - algorithm that we are going to use in
333:54 - order to draw this triangle shape here
333:57 - so let me explain to you how we are
333:59 - going to do that so we are going to have
334:02 - two four loops and those are going to be
334:05 - nested for Loops so if you're not
334:07 - familiar with for Loop nesting I'm going
334:09 - to link my video on that here so make
334:12 - sure to watch it so our outer four Loop
334:16 - is the one that is going to control this
334:18 - height of a triangle so in this
334:21 - particular case it is going to have five
334:23 - iterations 1 2 3 4 five and then our
334:28 - inner for Loop is the one that is going
334:30 - to control the width of this
334:33 - triangle and if you really look at this
334:36 - triangle you can notice that our outer
334:38 - for Loop really goes from one up to the
334:41 - number that our user has entered so it
334:44 - has five etration in this particular
334:47 - case because our user has entered five
334:49 - for the length of this triangle so for
334:52 - the length of its sides so that is the
334:56 - behavior of our outer for Loop it goes
334:58 - from one up to five in this particular
335:01 - case and then the behavior of our inner
335:03 - for Loop is going to be the following so
335:05 - in the first iteration of our outer for
335:07 - Loop loop our inner for Loop has only
335:09 - one iteration after that in the second
335:12 - iteration of outer for Loop inner for
335:15 - Loop has two iterations then in the
335:18 - third iteration of outer for Loop inner
335:20 - for Loop has three in a fourth iteration
335:23 - of outer for Loop inner for Loop has
335:26 - four and so on so that means that our
335:29 - inner for Loop goes from one up to the
335:32 - current value of the counter of outer
335:35 - for Loop so let's translate that into
335:39 - our C++
335:41 - code let me return this picture here
335:45 - okay so before we start to write that
335:48 - algorithm I am going to create a
335:51 - variable which is going to hold the
335:53 - length that our user enters so I'm going
335:55 - to call that variable
335:58 - length Okay and then let's write out a
336:00 - message to the user so that he knows
336:02 - that he should enter
336:05 - length like this
336:08 - and let's store the value in our length
336:12 - variable so that is the first thing that
336:14 - we need from our user and then the
336:16 - second thing is going to be a symbol so
336:19 - that is going to be of type
336:22 - Char like this so I'm going to write out
336:26 - oh see out
336:31 - symbol like this so that our user knows
336:34 - that you should enter symbol as well and
336:36 - let's store that symbol and our symbol
336:40 - variable so after we have acquired these
336:43 - two things from our user let's translate
336:46 - the algorithm that I just explained into
336:48 - C++ code so as I said we are going to
336:52 - have two for Loops outer for Loop which
336:55 - is going to have counter that I'm going
336:58 - to call let's say I and that outer for
337:02 - Loop its counter goes from one up to the
337:06 - value that our user us has entered and
337:09 - it increases by one in each iteration
337:12 - okay so I'm going to say I is equal to 1
337:15 - and then I is I is less than or equal to
337:20 - length so length that our user has
337:22 - entered and then please increment that I
337:26 - in each iteration so that is going to be
337:29 - outer for Loop and then inner for Loop
337:33 - is going to go from one up to the
337:36 - current value of outer for Loops counter
337:40 - so in the first iteration is going to
337:42 - execute only once so it is going to have
337:44 - only one iteration in the second
337:47 - iteration of outer for Loop it is going
337:49 - to execute twice in the third it is
337:51 - going to execute three times four times
337:54 - five times so how we are going to write
337:58 - that we are going to say four int and
338:01 - then our inner for Loops counter I'm
338:03 - going to call
338:05 - J and J goes from one up to the value of
338:11 - our I so up to the value of outer four
338:15 - Loops counter and it increases by one as
338:20 - well in each iteration and in each
338:22 - iteration it has to write out this
338:25 - symbol that our user has entered so
338:27 - let's say see
338:28 - out symbol like this okay and then there
338:33 - is one more thing that I want to explain
338:34 - and that is going to be after each
338:36 - iteration of outer for Loop really the
338:39 - next iteration starts in a new line so
338:42 - we are going to write that here here I'm
338:47 - sorry so at the end of our for loop our
338:51 - outer for Loop we are going to say see
338:54 - out end
338:56 - line okay and now if I run this
339:02 - program it asks for length I'm going to
339:05 - say that length is let's say five and
339:08 - then symbol is going to be star symbol
339:11 - and as you can see it has really written
339:14 - out a triangle that has the length five
339:17 - of these symbols that our user has
339:19 - entered and there is one more thing that
339:21 - I want to do in order to format this
339:24 - shape here to be a bit prettier and that
339:27 - is going to be really to add a function
339:32 - here which is going to assign to each of
339:35 - these symbols that are user enter so
339:38 - that our for Loop writes out uh width of
339:41 - two fields and that is going to be done
339:45 - using a function that is called set W
339:48 - meaning set width and this function here
339:52 - is going to give the space of two fields
339:56 - to the symbol that comes after it and in
339:59 - order to use this function here we have
340:00 - to include its library and that is going
340:03 - to be iio manip Library so I'm going to
340:06 - say include
340:08 - like this IO manip oh okay and now this
340:15 - underline has went away so if I run my
340:19 - program once
340:21 - more and I enter let's say for length
340:24 - six and then for symbol I enter this
340:28 - this symbol here as you can see our
340:31 - triangle shape looks better now so it
340:35 - has the height or actually the length of
340:38 - six of these symbols that our user has
340:40 - entered and it has also used this symbol
340:43 - here in order to draw this triangle
340:46 - shape and there is one more thing that I
340:48 - want to show you so at the beginning of
340:50 - this video I promis that I'm going to
340:52 - teach you how you can draw triangle
340:54 - shape and then reversed triangle shape
340:57 - as well so there is one very beautiful
341:01 - thing about programming and that is
341:02 - going to be code reusability and about
341:05 - real code reusability you are going to
341:07 - learn when we learn about classes and
341:10 - functions and when I make my videos on
341:13 - functions I'm going to link that video
341:15 - here so make sure to watch it because
341:17 - functions really are one of the most
341:19 - important things that you have to
341:21 - understand not only for C++ programming
341:24 - but for programming in general so make
341:27 - sure to watch that video and let's say
341:29 - that for now we are only going to really
341:32 - adjust this code here so we are going to
341:34 - modify it a little bit in order to draw
341:37 - this shape here
341:39 - so if you look at these two shapes you
341:42 - can really notice similarities and what
341:45 - are those so this inner for Loop behaves
341:49 - about the same in both of these
341:50 - triangles but there is one key
341:52 - difference and that is going to be that
341:54 - in this triangle shape our outer for
341:57 - Loop Counts from 1 to five and then in
342:01 - this reverse triangle our outer for Loop
342:04 - really counts from five to one so if we
342:08 - modify that we are going to have this
342:11 - reversed triangle so let me move these
342:16 - and then I'm going to really copy this
342:19 - here so I'm going to use contrl C and
342:22 - then control V and then let's really add
342:25 - a couple of end lines between these
342:29 - two okay like
342:32 - this and
342:35 - then let's modify this triangle shape
342:39 - that we have just explained and drawn
342:43 - and as you could see on this image here
342:47 - our outer for Loop Counts from five to
342:50 - one which means from the size that our
342:52 - user has entered from one so that means
342:55 - that if we change our outer for Loop we
342:59 - should get that reverse triangle shape
343:01 - so it goes from
343:04 - length like this and it really goes
343:08 - while our I is greater than or equal to
343:11 - 1 and then our I decreases in each
343:15 - iteration so it decrements and now if I
343:19 - run my
343:21 - program it asks me for length let's say
343:24 - that length is going to be five and then
343:27 - symbol is going to be let's say this
343:29 - plus
343:30 - symbol and when I pressed enter we have
343:34 - gotten both of these triangle shapes so
343:36 - this
343:37 - one that we have drawn first and then
343:39 - this reverse triangle shape as well I
343:43 - hope that now you have really seeing the
343:45 - real beauty of programming you learn
343:47 - some Basics and then you can use those
343:50 - basics in the most creative ways that
343:52 - you can think of so I hope that you like
343:55 - this video if you did make sure to
343:57 - subscribe to my channel click the Bell
343:58 - icon as well so that you are notified
344:00 - when I publish my next video and a lot
344:02 - more great videos are coming thanks for
344:05 - watching I'm going to see you in my next
344:07 - video
344:09 - bye hi everyone welcome to my channel
344:12 - welcome to the first video of C++
344:14 - functions if you're a beginner at C++
344:17 - make sure to check out my playlist on
344:19 - C++ for beginners and there you can find
344:22 - some of the most important Concepts that
344:24 - you will need to understand and know in
344:26 - order to work with
344:28 - C++ and in this video we are going to
344:30 - talk about C++ functions so functions
344:34 - are one of the most important Concepts
344:36 - that you will need to understand and use
344:38 - in order to be a good programmer and
344:41 - that is not only case in C++ but in most
344:44 - programming languages as well the first
344:47 - thing that I want to explain is what is
344:49 - function function is a block of code
344:52 - that is grouped together and usually
344:54 - that block of code solves a specific
344:57 - problem meaning it performs a specific
344:59 - task and that block of code is executed
345:02 - only when you call that function meaning
345:05 - only when you invoke the function
345:07 - the body of that function is going to be
345:09 - executed and each C++ program contains
345:13 - at least one function and that is going
345:16 - to be main function so this here and the
345:20 - execution of your program starts on the
345:23 - first line of your main function and
345:26 - then it ends when it comes to this last
345:28 - line so this Clos bracket of your main
345:30 - function and also it can end when it
345:33 - comes to return statement but we are
345:35 - going to talk about return statements
345:37 - later in this course so main function is
345:41 - the main one so the first one that is
345:43 - executed and whatever code you put in
345:46 - your main function that code is going to
345:48 - be executed as part of your program so
345:51 - if I say here for example see
345:54 - out and I say hello from main function
345:59 - like this and let's add a new line like
346:04 - this and now if I run my program
346:08 - you can see that our program has written
346:09 - out hello from Main and that is the
346:13 - first function that our program starts
346:16 - executing besides from main function you
346:18 - can also create your own functions and
346:21 - let's explain how you can do that so
346:25 - there are a couple of things that you
346:26 - need to know in order to create your own
346:28 - function and that is going to be
346:31 - following so the first thing that you
346:33 - need to really write when you create
346:35 - your own function is going to be return
346:37 - type of your function and that is going
346:40 - to be void for now which means that this
346:43 - function is not going to return anything
346:46 - and we are going to talk about return
346:48 - types more in detail later in this
346:50 - course so for now we are going to use
346:53 - void return type meaning that this
346:54 - function that we declare in this line is
346:57 - not going to to return anything and then
347:00 - you write out the name for your function
347:02 - and let's call it
347:05 - function like this and then in these
347:08 - parentheses you can put arguments or
347:12 - parameters that your functions that your
347:14 - function really uh receives and for now
347:17 - these parth parentheses are going to be
347:18 - empty meaning that this function does
347:21 - not receive any arguments and then in
347:24 - these curly brackets we are going to put
347:27 - the body of our function so this here is
347:30 - going to be the function that we created
347:33 - ourselves and you have to specify
347:36 - specify the return type of your function
347:39 - after that you write out the name of
347:41 - your function then in these parentheses
347:44 - you can put any arguments that your
347:46 - function receives in this particular
347:48 - case these are empty and we are not
347:50 - going to send any parameters to our
347:52 - function and then here is going to be
347:55 - the body of your function and what we
347:58 - are going to put in this body let's say
348:01 - see
348:03 - out hello from
348:06 - function like
348:09 - this and let's also add end line at the
348:13 - end of this function so now we have
348:17 - really created our own function which is
348:20 - called function and if I run my program
348:23 - now what do you think that is going to
348:24 - happen write that in the comments down
348:26 - below so I am going to run this program
348:30 - and as you can see nothing has changed
348:33 - really our program has written out hello
348:35 - from Main as it did before so before we
348:37 - created this function that is because as
348:40 - I explained your function is not going
348:42 - to execute until you call that function
348:45 - so until you invoke it it is not going
348:47 - to execute so in order for our function
348:51 - to be executed we need to invoke that
348:53 - function and how that is done so here in
348:57 - this line after hello from Main we are
348:59 - going to put
349:01 - function and then these
349:04 - parentheses so this here is the
349:06 - invocation of our function and now our
349:10 - function is going to be executed so now
349:12 - if I press this play button you can see
349:16 - that now our console has changed so now
349:19 - we have hello from Main and then also
349:22 - hello from function so that is because
349:26 - we have invoked this function here and
349:29 - you can invoke this function wherever
349:31 - you need it so you can I have invoked it
349:34 - after this line here but you can invoke
349:36 - it as well before this line here if you
349:40 - need to and if you want to so now if I
349:43 - run my program you can see that it first
349:45 - says hello from function and then it
349:48 - says hello from Main because this
349:50 - function has been invoked first and then
349:53 - we have written out this line of code
349:56 - here and that you can see in this
349:59 - console window and let me show you one
350:03 - thing so I'm going to return this after
350:07 - this line of code the invocation of our
350:09 - function I'm going to return here and
350:12 - now I'm going to take this code here so
350:15 - this uh definition of our function and
350:18 - I'm going to paste it after our main
350:21 - function and let's see what is going to
350:23 - happen now so let me delete these these
350:27 - blank lines and now if I run my program
350:31 - you can see that our program has failed
350:33 - to build so we have compile time errors
350:36 - and in this window here in this error
350:39 - list you can see that it says function
350:42 - identifier not found which means that
350:45 - this function here is really uh our
350:48 - compiler does not understand what this
350:50 - function is because C++ code is executed
350:54 - from top to bottom and when it comes to
350:57 - this line here so when it comes to the
350:59 - invocation of your function it is really
351:01 - not familiar with this function it it
351:03 - does not know what this function is so
351:06 - you have to either put this code before
351:10 - your main function as we did before or
351:13 - you have to do um other thing which is
351:15 - really the recommended way to create
351:17 - your functions and that would be to
351:20 - create definition and Declaration of
351:23 - your function so what are definition and
351:26 - Declaration of function Declaration of
351:30 - function is going to be
351:32 - really this here so I'm going to copy
351:35 - this
351:37 - and put it before our main function and
351:40 - this declaration of function is going to
351:43 - tell to your compiler what is going to
351:45 - be the return type of your function what
351:48 - is the name of your function and then if
351:51 - there are any parameters that your
351:53 - function really receives you are going
351:55 - to put those in these parentheses here
351:57 - so that is going to be Declaration of
352:00 - your function and that part decoration
352:03 - of your function goes before your main
352:05 - function and after that you are going to
352:08 - write the definition of your function
352:10 - and the definition of your function is
352:13 - going to go after your main function and
352:16 - in that way you are going to make your
352:18 - code more readable meaning that when
352:21 - someone else comes to your code and if
352:23 - your code had 200 or three or 400 lines
352:26 - of code then it would be really hard to
352:30 - to read that code and for someone it
352:33 - would be really hard to manage and uh go
352:35 - through your code so he is going to find
352:38 - it much easier if he has all the
352:40 - Declarations of your functions before
352:42 - your main function and then if he needs
352:44 - to read a specific definition of a
352:46 - function he can rightclick the name of
352:49 - that function and click go to definition
352:52 - and then he's going to be taken to the
352:55 - definition of your function so the
352:57 - specific one that he needs to read so
353:00 - that you don't bombard um that user with
353:04 - all the functions all the definitions of
353:06 - a fun functions that you have in your
353:08 - program and in this particular situation
353:10 - it is only one function but uh your
353:13 - program is going to consist usually of
353:15 - more than one function and that is
353:17 - really unreadable when you find a lot of
353:19 - definitions of a functions before your
353:21 - main so you can right click on your
353:24 - function and say go to definition or you
353:27 - can press F12 so you can click on your
353:29 - function and then press F12 and you are
353:32 - going to be taken to the definition of
353:34 - your function Okay so so this here is
353:37 - the recommended way to create functions
353:40 - and now if I press play button you can
353:44 - see that our program has executed
353:48 - actually has written out the same as it
353:50 - did before so we have uh really removed
353:53 - that error that we had when we um moved
353:56 - this definition of a function after our
353:59 - main because we have added this
354:01 - declaration of a function before our
354:03 - main function and there is really the
354:06 - most most important thing that I want to
354:07 - mention in this video and that is going
354:09 - to be what is the reason why functions
354:12 - exist okay so we have seen that they
354:15 - make your code a bit more readable so
354:17 - they group the parts of your code
354:19 - together so that you can manage your
354:21 - code easier and the most important
354:25 - characteristic of functions is that they
354:27 - make your code reusable meaning that you
354:30 - can write a specific code once so you
354:32 - can solve a specific problem once put
354:35 - the solution the algorithm the code for
354:38 - that problem in a function and then you
354:40 - can really invoke that function however
354:43 - many times you need it so here I can
354:47 - really copy this and then paste it let's
354:50 - say three times if I needed it and then
354:53 - if I run my
354:55 - program you can see that this function
354:58 - has been executed three times here and
355:02 - that is really the most important thing
355:04 - about functions which means
355:07 - functions make your code reusable you
355:09 - don't have to write the same code over
355:12 - and over again and you should really try
355:15 - to group your code in functions so that
355:17 - each function does a specific task
355:20 - nothing more than that and in that way
355:22 - you are going to make your code easier
355:25 - for yourself and for other people as
355:27 - well that are going to read your code so
355:30 - I hope that you understood what
355:32 - functions are and how they are used and
355:35 - we are going to talk about function
355:36 - functions in more detail in my later
355:38 - videos so make sure to subscribe to my
355:40 - channel and click the Bell icon because
355:43 - only then you are going to be notified
355:45 - when I publish my next video and also
355:48 - follow me on my other social media
355:50 - platforms so Instagram and Twitter
355:53 - accounts through code Beauty thanks for
355:55 - watching and I'm going to see you in my
355:57 - next video
356:00 - bye hi everyone welcome to my channel
356:03 - welcome to another video of C++
356:05 - functions in this video I wanted to talk
356:07 - about function parameters or arguments
356:11 - and the first thing that I want to
356:12 - explain is what are parameters so what
356:14 - are
356:15 - arguments sometimes a function needs to
356:18 - receive a certain value a certain
356:20 - variable and then perform a certain task
356:23 - on that value so on that variable or it
356:26 - really needs the value of that variable
356:28 - in order to perform a certain task so
356:30 - let's explain how we are going to create
356:33 - a function that receives a parameter in
356:35 - C+ plus so here I'm going to add a
356:39 - function of return type void and I'm
356:44 - going to say that that function is going
356:46 - to be called let's say um introduce
356:49 - me introduce me like this and then in
356:53 - these parentheses here we can put
356:56 - parameters that our function is going to
356:58 - receive and after that in these curly
357:03 - brackets we are going to put the body of
357:05 - our function
357:07 - so as I said in these parentheses here
357:09 - we are going to put parameters and they
357:12 - are specified in a following way so
357:14 - first you are going to write out the
357:16 - type of your parameter and that is going
357:18 - to be string like this and then we are
357:22 - going to specify the name of our
357:25 - parameter and that is going to be let's
357:27 - say name so we want to pass in this
357:31 - function that is going to introduce our
357:32 - user we want to really pass the name of
357:36 - our user and then what our function is
357:38 - going to do we are going to put in these
357:41 - curly brackets here and that is going to
357:44 - be really to introduce our user so our
357:46 - function is going to write out C
357:48 - out um let's say my name is and then
357:54 - let's write out this name that we have
357:57 - received in this function so I'm going
357:59 - to say name and I'm going to add end
358:03 - line like this okay okay so this is the
358:08 - way to pass a parameter so to pass a
358:11 - value to your function and as I said in
358:14 - my previous video you can really
358:16 - separate this um declaration and
358:18 - definition of a function so you can put
358:20 - really um Declaration of your function
358:23 - here so before your main function and
358:25 - then you can put definition of your
358:26 - function after your main function and if
358:29 - you don't know how to do that make sure
358:31 - to watch my first video of this playlist
358:34 - okay so now
358:36 - I want to invoke this function here and
358:38 - how we do that well we specify the name
358:41 - of my function so I'm going to say
358:44 - introduce me and then since this this
358:47 - function receives um argument so since
358:50 - this function function receives a
358:51 - parameter here we really have to pass
358:56 - that parameter to our function and that
358:59 - I'm going to put here so here I'm going
359:01 - to pass an argument to my function so
359:05 - I'm going to say
359:07 - Salena like this and this here really is
359:12 - called argument so it is a value that we
359:14 - passed to our function and then here it
359:17 - is called parameter okay so now if I run
359:22 - my
359:24 - program you can see that my function has
359:27 - successfully introduced me so it says my
359:30 - name is Salina like this okay so here we
359:34 - have really here we have really um
359:37 - defined our function so the parameters
359:40 - that our function receives name return
359:42 - type and then uh the block of code that
359:45 - our function is going to execute and
359:47 - then here we have invoked our function
359:49 - and passed an argument which is this
359:53 - string of text here to our function
359:55 - which is going to be received in this
359:57 - name variable and then our function is
359:59 - going to really treat it as a variable
360:02 - which means that it is going to write
360:04 - that value here okay okay and now if I
360:08 - try to invoke this function once more so
360:10 - I'm going to copy this this line and
360:13 - then paste it here and let's say that
360:15 - I'm going to pass it a different value
360:17 - so I'm going to say for example
360:19 - Anna
360:21 - okay you can see that uh now our
360:24 - function has successfully introduced two
360:26 - users so it has said my name is my name
360:29 - is Salina and then my name is Anna and
360:33 - there is also another thing that I want
360:35 - to explain and that is going to be how
360:37 - you can pass multiple arguments to your
360:40 - function and that is going to be in a
360:41 - following way so here in these
360:44 - parentheses where I have specified my
360:46 - first parameter you can put comma sign
360:50 - and then you specify your second third
360:52 - fourth fifth and um your other
360:55 - parameters so you specify the type which
360:58 - is also going to be string in this
361:01 - particular case and let's say that my
361:03 - second parameter is going to be called
361:05 - City
361:06 - like this and let's add another one so
361:09 - let's say int H like this so now in this
361:15 - function I'm going to write out also
361:17 - where is my user from and also how old
361:20 - my user is so I'm going to write out C
361:24 - out um I am from and then let's write
361:29 - out this city that we have passed in
361:33 - this function and add also end line and
361:38 - let's write out also I am I
361:43 - am um age so I am however many years we
361:48 - have passed in this function and then
361:52 - let's say years
361:54 - old old like
361:57 - this okay so now we have really
362:01 - introduced our user in more detail and
362:04 - we have passed to this function name
362:06 - City and age information for our user
362:10 - but as you can see here our function so
362:14 - our compiler really says that this
362:15 - function is not valid it has too few
362:17 - arguments in a function call meaning
362:20 - that this invocation this call of a
362:22 - function does not really contain all the
362:24 - necessary parameters or all the
362:26 - necessary arguments that we need to pass
362:29 - to our function which means that it
362:31 - really lacks the city and age parameters
362:35 - so here here I'm going to put comma as
362:38 - well and then I'm going to specify my
362:41 - city this here is bolded so it is bold
362:45 - and that means that we have to really
362:48 - pass a city value to our function so I'm
362:51 - going to write out
362:53 - mostar like this and then I am also
362:57 - going to specify age so I'm going to say
363:01 - 25 and let's do the same for our ni user
363:05 - so I'm going say that our Anna is from
363:07 - New York and let's say that she has 27
363:10 - years old for
363:12 - example so now when I run my program you
363:17 - can see that we have successfully
363:20 - introduced two users so my name is
363:23 - Salina I am from mustar I am 25 years
363:26 - old and then also my name is Anna I from
363:29 - New York and I'm 27 years old okay so
363:33 - and we have really written this code
363:36 - only once and then we can reuse it
363:39 - however many times we need to so in this
363:41 - particular case we have reused it two
363:44 - times okay and another thing that I want
363:47 - to explain is going to be a default
363:50 - parameter so what is default parameter
363:54 - sometimes you really don't want to pass
363:56 - a value to your function meaning that in
363:59 - a specific situation you don't have that
364:01 - value or you don't want to pass it and
364:03 - in that case you want to Define define
364:05 - find um theault value for your parameter
364:08 - so in the case where you use where your
364:10 - user does not pass that argument to your
364:14 - function for example you can say that
364:17 - your age parameter here has the default
364:20 - value of zero okay and that means that
364:25 - you don't really have to pass this age
364:28 - parameter anymore so here I'm going to
364:31 - delete this age for my Anna user and
364:35 - let's let's run our program now in order
364:37 - to see how this function is going to
364:39 - behave for this first user and then also
364:42 - to see how it is going to behave for
364:44 - this second user user which did not
364:46 - specify this age parameter so this age
364:50 - argument and when I run it you can see
364:55 - that my first user has been introduced
364:57 - as it was previously so I am 25 years
365:01 - old and then the second user which did
365:03 - not specify age argument it really said
365:08 - I am zero years old meaning that our
365:11 - function has really taken this default
365:13 - value and it has written out I am and
365:16 - then this default value and then years
365:19 - old oh we are missing s here okay so I'm
365:23 - going to add s
365:26 - and I want to do a following thing so in
365:29 - the case where our user does not pass
365:32 - this value for our AG parameter I'm
365:35 - going to really check whether we have
365:38 - that value or we have this default value
365:41 - and then in the case where we have only
365:43 - this default value I don't want to write
365:45 - this line of code here so I am going to
365:48 - say here
365:50 - if age is not equal to zero meaning that
365:55 - our user has specified some other value
365:58 - which is not zero then and only then we
366:02 - are going to write this line of code but
366:04 - in the case where we have only this
366:06 - default value we do not really want to
366:08 - write out that our user has zero years
366:10 - old cuz that does not make sense okay so
366:16 - as you can see now my first user has
366:19 - been introduced as I am 25 years old and
366:22 - then my name is Anna I from New York
366:25 - since Anna did not specify how old she
366:28 - is we haven't written out her age here
366:32 - because of this check that we have added
366:35 - okay
366:36 - so that was about default parameter and
366:39 - there is one thing also that I want to
366:41 - um that I want to say about this default
366:43 - parameter and that is going to be really
366:46 - if I delete this is equal to zero and
366:48 - then I try to assign theault value to
366:50 - this city parameter so I say let's say
366:54 - that city is equal
366:56 - to default like this you can see that
367:00 - the compiler is really underlying this
367:02 - function and it says okay it says
367:05 - theault argument not at end of parameter
367:08 - list meaning that you can specify
367:10 - theault argument only at the end of this
367:14 - list so if you want to specify default
367:17 - value for this parameter you will have
367:19 - to specify default value for this one as
367:22 - well so if I add theault value here so I
367:27 - have added zero then we can really add a
367:31 - default value for this second parameter
367:33 - and then we can add default value for
367:35 - this this one as well and now we are
367:38 - really uh left with so our compiler is
367:41 - not underlying this uh introduce me
367:43 - function name anymore okay and this does
367:47 - not make sense so I'm going to delete it
367:49 - but I wanted to explain that you cannot
367:52 - specify default value for your middle
367:54 - parameter if you did not specify a
367:56 - default value at the end of your
367:58 - parameters list and there is one more
368:01 - thing that I want to show you and that
368:02 - is going to be that you don't have to
368:04 - hardcore these values as we did here so
368:08 - I'm going to comment these out and then
368:11 - I'm going to let my user Define his own
368:14 - values for these three variables so I am
368:17 - going to declare uh two variables of
368:20 - type string which are going to be name
368:23 - and City and then also I'm going to
368:25 - declare a variable of type int which is
368:27 - going to be called age and then I'm
368:30 - going to say see out so please enter a
368:34 - name
368:36 - like
368:37 - this it's not capital letter okay and
368:40 - then see
368:42 - in name and then see
368:44 - out City so after my user has entered
368:49 - name I want him to enter City so C in
368:54 - city like this and then also I want to
368:58 - enter
369:00 - age and C in age like this so now after
369:06 - my user has has specified these three
369:10 - variables so name City and age I can
369:14 - pass these three in my introduce me
369:17 - function so I can say introduce me and
369:20 - then pass name and City and age like
369:26 - this and if I run my program
369:30 - now as you can see my program really
369:32 - asks me to enter a name so let's say
369:34 - that name is going to be Tom for example
369:38 - and then let's say that city is going to
369:40 - be
369:41 - London and age let's say
369:45 - 32 okay and now as you can see my
369:48 - function has successfully introduced Tom
369:50 - so it says my name is Tom I am from
369:52 - London and I am 32 years old okay and
369:57 - you don't really have to use these names
370:00 - for the variables in your main function
370:02 - so the names of these variables here do
370:05 - not have to be the same as these names
370:08 - here here so you can call these for
370:11 - example name one city 1 age 1 but you
370:15 - are going to have to use these names in
370:17 - your main function so you will have to
370:19 - say name one city 1 age one and here as
370:23 - well but these names do not have to be
370:27 - the same as these names here your
370:29 - program is going to work correctly you
370:31 - have to however have the same type here
370:35 - and here so this here has to be string
370:39 - if it has been declared as string here
370:42 - and this one as well and then age also
370:45 - has to be of type int if it has been
370:47 - declared as int here and once more if I
370:51 - run my program you can see that it asks
370:54 - for name so Tom New York and then age is
370:59 - going to be 22 and as you can see my
371:02 - name is Tom I'm from New York I am 22
371:04 - years old so your program works just
371:07 - fine so I hope that you have understood
371:10 - how parameters behave in a function and
371:12 - how you can pass multiple parameters to
371:15 - your function and also how you can
371:17 - specify a default parameter in your
371:19 - function and if you enjoyed this video
371:21 - If you learned something new make sure
371:23 - to subscribe to my channel click the
371:25 - Bell icon so that you are notified when
371:26 - I publish my next video also like it and
371:29 - share it with your friends and follow me
371:32 - on my other social media so Instagram
371:34 - and Twitter account true code Beauty
371:37 - thanks for watching and I'm going to see
371:38 - you in my next video
371:41 - bye hi everyone welcome to my channel
371:44 - welcome to another video of C++
371:46 - functions in this video I wanted to talk
371:48 - about return statements and return types
371:51 - of a function so what is return type of
371:53 - a function well return type of a
371:55 - function can be any data type that can
371:57 - be used in order to declare variable so
372:00 - it can be int float bull charart double
372:04 - um it can be any user created data type
372:07 - and it can be void as well which means
372:09 - that that function is not going to
372:10 - return anything and as we explained in
372:13 - one of my previous videos function is a
372:16 - block of code it is a code that is
372:18 - grouped together and that code is going
372:20 - to perform a specific task and here I
372:24 - want to make a difference between
372:25 - functions that return value and
372:27 - functions that don't return value and
372:30 - functions that don't return value can be
372:32 - for example um an example of a function
372:35 - that does not return value can be a
372:37 - function that writes out a menu to your
372:39 - user so you call that function that
372:41 - function writes out a menu to your user
372:44 - and the job of that function is done
372:46 - there so you are not expecting any value
372:48 - to be returned from that function but an
372:51 - example of a function that returns a
372:54 - value can be a function that performs a
372:56 - specific calculation let's say on
372:58 - arguments that you pass to that function
373:01 - and after that calculation is performed
373:04 - you are EXP expecting a certain value so
373:07 - result of that calculation to be
373:09 - returned from that function and an
373:12 - important thing is that function can
373:14 - return only one value so only one return
373:18 - statement inside your fun function is
373:20 - going to be executed and I'm going to
373:22 - show that on the example that we are
373:24 - going to do in this video and now I'm
373:28 - going to show you really how functions
373:30 - make your code easier to read easier to
373:33 - understand and how they make your code
373:35 - reusable so we are going to show that on
373:38 - an example which we are going to first
373:40 - make without using a function so we are
373:43 - going to make a program that is going to
373:45 - determine whether a number is prime
373:47 - number or not and we are going to do
373:49 - that first without chosing functions and
373:51 - then I'm going to refactor that program
373:53 - so that it uses functions and then I'm
373:55 - going to show you how that program
373:57 - becomes instantly more readable more
374:00 - understandable and also how that makes
374:02 - your code reusable
374:05 - so as I said we are going to create a
374:07 - program that is going to determine
374:08 - whether our number is prime number or
374:11 - not and the definition of a prime number
374:14 - is a number that is divisible only by
374:16 - itself and by one so if that number is
374:20 - divisible by any other number so not one
374:23 - and not itself but any other number that
374:26 - means that that number is not prime
374:28 - number so the first thing that I'm going
374:30 - to do here is I'm going to declare a
374:32 - variable of type in call it number
374:35 - and then I'm going to let my user enter
374:38 - that number so I'm going to write out
374:40 - the message to my user and then use the
374:43 - C in command in order to get that number
374:46 - and store it in my number variable and
374:48 - then let's explain the algorithm that we
374:51 - are going to use in order to determine
374:52 - whether that number is prime number or
374:54 - not the definition of a prime number is
374:57 - a number that is divisible only by one
375:00 - and by itself which means that if you
375:03 - can find any other number number besides
375:06 - one and that number itself that you can
375:09 - use to
375:10 - divide it by this number that are user
375:13 - has entered and get the remainder of
375:15 - zero that means that this number is not
375:18 - prime number so how we are going to
375:20 - solve this problem well we are going to
375:23 - iterate through all the numbers between
375:26 - two and this number minus one and then
375:30 - we are going to check whether this
375:32 - number is divisible by that count
375:35 - value so I'm going to write out for INT
375:39 - I is equal to 2 and then I is less than
375:44 - number and in each iteration I want to
375:47 - increase the value of my I counter so
375:51 - why haven't I used one here and why
375:54 - haven't I said here that this I is less
375:57 - than or equal to the number because
376:00 - every number can be divided by one so we
376:02 - do not need really to check that and
376:05 - also every number can be divided by
376:07 - itself and we do not need to check that
376:10 - as well so here we are going to iterate
376:13 - through this interval so between two and
376:16 - while I is less than that number that
376:19 - our user has entered and here we are
376:22 - going to check whether this number that
376:25 - our user has entered can be divided by
376:27 - any value of ouri so in any iteration
376:31 - which we are going to go through and in
376:33 - the situation where it can be divided we
376:35 - are going to use a flag which I'm going
376:38 - to declare here and that flag is going
376:41 - to be of type bu and let's call it is
376:46 - prime
376:48 - flag like this okay and this flag is
376:52 - initially going to be assigned a value
376:55 - of true so we are going to initially say
376:58 - that all the numbers are prime numbers
377:00 - and then we want to prove that wrong for
377:02 - the numbers that are not so we are going
377:05 - to use this flag in a following way here
377:08 - I'm going to check in each iteration if
377:11 - our
377:12 - number that our user has entered can be
377:15 - divided by that current counter so by
377:19 - the current value of I so I'm going to
377:22 - use this modular operation and I'm going
377:24 - to say if this number modulated by I is
377:28 - going to give us the result of zero so
377:30 - when you divide this number by I do you
377:34 - get the remaining of zero and if this
377:38 - operation here results as true we are
377:41 - going to say that our is prime flag is
377:44 - going to be false so we are going to
377:46 - assign the false value to our is prime
377:47 - flag because we have clearly found one
377:50 - number which is not one and that number
377:52 - itself that can be used in order to make
377:55 - this condition true so here I'm going to
377:58 - write out is prime flag and then I'm
378:01 - going to assign it a value of false and
378:04 - and then another thing is going to be
378:06 - really if we find one number so even one
378:09 - number is enough to find that that
378:12 - really fulfills this condition here in
378:14 - order to say that our number is not
378:16 - prime number and in that situation we do
378:18 - not really need to check any more
378:19 - numbers because we have determined that
378:21 - our number is not prime number so here I
378:24 - can use break statement so I can say if
378:27 - you find only one number please do not
378:30 - iterate through this for Loop anymore
378:32 - because we do not need to find any more
378:34 - numbers
378:35 - so in this situation here we have
378:38 - iterated through all the numbers between
378:39 - two and that number that our user has
378:42 - entered we have checked whether that
378:44 - number can be divided by any value of
378:47 - our I counter and if it can be divided
378:50 - meaning that it gives the remainder of
378:53 - zero after that division we are going to
378:56 - set our Prime flag to false and we are
378:59 - going to break from our four Loop and
379:03 - after we have have successfully
379:06 - fulfilled this so after we have
379:08 - successfully iterated through this for
379:10 - Loop or we have fulfilled this condition
379:14 - in one iteration we are going to leave
379:17 - our for Loop and we are going to come to
379:20 - this line of code here and here I want
379:22 - to check what has happened with my is
379:24 - prime flag meaning I want to check
379:26 - whether this is prime flag has has
379:28 - stayed true which means that our for
379:31 - Loop has executed all of its iteration
379:35 - and it has not find any number that can
379:38 - be really used to fulfill this condition
379:41 - here and in that particular situation
379:43 - that flag is going to stay true and that
379:46 - is going to mean that our number is
379:50 - prime number so here I'm going to write
379:52 - out if is prime flag meaning if this
379:57 - value here if this variable here holds
379:59 - the value of true we are going to write
380:02 - out C out like this and we are going to
380:06 - write out prime number like this okay
380:12 - and let's also add end line here but in
380:16 - a situation where this here does not
380:17 - hold a value of true that means that in
380:21 - uh one iteration so it can be the first
380:23 - one it can be the last one it can be any
380:26 - in between we have really found at least
380:29 - one number that can be used to fulfill
380:31 - this condition and that has set our is
380:34 - prime flag to fals and in that situation
380:36 - we are going to use our else statement
380:39 - and we are going to copy this and we are
380:42 - going to really modify it to say not
380:45 - prime number like this okay so now if I
380:49 - run this
380:51 - program you can see that it asks us to
380:54 - enter a number I'm going to enter a
380:56 - number um let's say five for example and
381:00 - it says that five is prime number which
381:02 - is correct five is a prime number and
381:05 - let's run it one more time and let's say
381:08 - that we want to check six this time and
381:11 - as you can see our program has written
381:12 - out that six is not prime number and six
381:16 - really is not prime number because it is
381:18 - divisible by two and by three besides
381:21 - from one and itself
381:24 - okay so now you have seen how we can
381:27 - really solve this problem and let's try
381:31 - to refactor this program here in order
381:34 - to use functions so how we are going to
381:37 - do that well the first thing that we
381:40 - need to do is we need to create function
381:42 - and I'm going to do that here and since
381:46 - this part of code here this is the part
381:48 - of code that we are going to move to our
381:50 - function and since this part of part of
381:53 - code here determines really whether our
381:55 - number is prime number or not and then
381:57 - sets this flag to true or false let's
382:01 - say that we are going to create a
382:02 - function which is going to check as as
382:04 - well whether the number is prime number
382:07 - or not and then it is going to return a
382:09 - value true or false meaning the number
382:13 - is prime number or the number is not
382:15 - prime number and that we are going to
382:18 - write here so here I'm going to put the
382:20 - return type of my function and that is
382:22 - going to be
382:23 - bull so that is the return type of my
382:25 - function and then the name for my
382:27 - function is going to be is prime number
382:33 - like this and then let's say that we
382:35 - want to pass an argument to that
382:37 - function and that argument is going to
382:40 - be of type
382:41 - int and that argument is going to be
382:43 - really the number that we want to oh the
382:46 - number that we want to check so we are
382:49 - going to pass the number to our function
382:51 - that function is going to in this body
382:55 - here check whether that number is prime
382:58 - number or not and then it is going to
383:00 - return bull value meaning true or false
383:03 - so if the number is prime number it is
383:05 - going to return true and if the number
383:07 - is not prime number it is going to
383:08 - return the value of false and how we are
383:12 - going to do that very simple so you see
383:15 - this code here I'm going to comment this
383:18 - code here and I'm going to really um oh
383:22 - I should have copied it before so I'm
383:24 - going to copy this code here and I'm
383:27 - going to move it to my function okay and
383:32 - we have previously explained this code
383:34 - here so we do not need to explain it
383:36 - again but what I'm going to say here is
383:39 - after this algorithm is done so after we
383:42 - have really uh stored the value of true
383:45 - or false so we have stored the value of
383:48 - false in our is prime flag or we have
383:51 - really kept this True Value inside our S
383:54 - Prime flag what we need to do is we
383:56 - really just need to say return is Prime
384:00 - oh is
384:02 - prime flag
384:05 - like this so after we have checked
384:08 - whether our number is prime or not we
384:10 - can really just return that value from
384:13 - our function okay so we can now after we
384:17 - have moved this code to our function we
384:19 - can delete it from here like this okay
384:23 - and then as you can see we have been
384:25 - left with this is prime flag which is
384:27 - not declared now so identifier is prime
384:30 - flag is undefined meaning that now we
384:33 - have to really declare it and we have to
384:35 - assign it a value so I'm going to say
384:38 - here bow is
384:42 - prime flag like this and then the value
384:46 - that I'm going to assign to my is prime
384:48 - flag variable is going to be whatever
384:50 - value our function returns so here I'm
384:54 - going to say please call my function is
384:57 - prime number oh this prime number like
385:02 - this okay and then pass to that function
385:06 - this argument here so our function
385:09 - expects a value and that is going to be
385:12 - this number that we want to check
385:13 - whether it's prime or not and then after
385:16 - this function here is done it is going
385:18 - to return a value of either true or
385:21 - false and that value is going to be
385:23 - stored inside our S Prime flag variable
385:27 - okay so now if I run my
385:29 - program you can see that it asks us
385:32 - again to enter a number so so I'm going
385:34 - to say let's check number nine for
385:36 - example and it says that number nine is
385:39 - not prime number which is not because it
385:42 - is divisible by three and let's check
385:46 - number um 13 for example and 13 is prime
385:51 - number okay so after we have really used
385:55 - this function in order to perform this
385:58 - particular task I want to show you one
386:00 - more thing and that is going to be how
386:02 - we can refactor this fun function here
386:04 - in order to make it even more simple and
386:09 - if you look at this function here you
386:12 - can say you can see that this is prime
386:15 - flag is set to True here and then in
386:18 - this situation where we find number that
386:20 - can be used to fulfill this condition
386:24 - here we set that is prime flag to false
386:27 - and then we use this break statement in
386:28 - order to break our for Loop so we are
386:30 - not going to iterate anymore through our
386:32 - for Loop when we come to this break
386:34 - statement and then we really go here and
386:37 - then we return that is prime flag but we
386:40 - can do that in a more simple Manner and
386:43 - that is going to be really here so here
386:46 - in a situation where we find number that
386:48 - is really fulfilling this condition here
386:52 - we can say at this very line of code we
386:55 - can say return false like this because
386:59 - this and this code of this code here we
387:02 - can delete and what I can use this
387:05 - return statement because this return
387:06 - statement is going to really break our
387:08 - for Loop and it is going to return the
387:11 - value from our is prime number function
387:14 - meaning it is going to do two things so
387:17 - we do not really need to set the flag
387:20 - and then return the value of that flag
387:22 - at the end but we can really say if you
387:25 - find any number that can fulfill this
387:27 - condition return false immediately so
387:30 - break for Loop and also return the value
387:32 - from our function meaning and the
387:34 - execution of that function because we
387:36 - have found our result and then here as
387:40 - well we do not really need to declare
387:42 - this is prime flag to true and then
387:45 - return it because it is clearly true so
387:47 - we can say here return true and then
387:51 - remove this flag from here like this and
387:55 - then as well I can remove these curly
387:57 - brackets and make my code even more
388:01 - readable so now I want to explain what
388:03 - we have done
388:04 - so here we are passing a number to our s
388:07 - prime number function then we are
388:09 - iterating through all the numbers
388:11 - between two and that number we have
388:14 - skipped one and that number itself
388:16 - because all the numbers are divisible by
388:17 - one and by that by that number itself
388:21 - and then we are checking whether any of
388:24 - these I values between two and number
388:26 - fulfill this condition here that would
388:28 - mean that that number is divisible by
388:31 - that current value of I and that would
388:34 - mean that our number is not prime number
388:36 - so at that very moment we can say please
388:39 - return false because this number is
388:40 - clearly not prime number but in a
388:43 - situation where this for Loop has really
388:45 - iterated through all of its iterations
388:47 - and it has not found any number that
388:49 - fulfills this condition here that means
388:51 - that this return false statement has not
388:53 - been executed and then that in that
388:56 - particular situation this return
388:58 - statement here is going to be executed
389:00 - and this return statement here says
389:02 - return true
389:04 - okay so this part of code here has not
389:08 - changed nor it is going to change and if
389:11 - I run it again you can see it asks me to
389:15 - enter a number I am going to enter
389:17 - number seven then it is going to check
389:20 - whether that number is prime number so
389:22 - it is going to call our function and
389:24 - assign the result of that to our is
389:26 - prime flag variable and I press enter
389:30 - here you can see that we get result
389:32 - prime number because 7 is prime number
389:36 - okay and that is really making your code
389:39 - much more readable and reusable as well
389:42 - so this main function here is much more
389:46 - clean than it was before and now I want
389:49 - to show you the most beautiful thing and
389:51 - that is going to be how we can make this
389:53 - is prime number function reusable so
389:57 - let's
389:58 - say that I am going to delete all of
390:01 - this code here so I'm going to delete it
390:04 - and now I have I know that I have
390:07 - written out this is prime number
390:09 - function and I know that that I can
390:11 - really invoke this function and use it
390:14 - whenever I need to determine whether
390:16 - some number is prime number or not so
390:19 - let's say that now we want to check all
390:22 - the prime numbers between 1 and a th000
390:25 - for example so how we are going to do
390:27 - that well we are going to iterate
390:30 - through all the numbers between one so I
390:34 - is equal to 1 and then I is less than or
390:37 - equal to 1,000 and increase our I in
390:41 - each iteration by one like this and then
390:44 - in each iteration I really am going to
390:47 - just send this I to my function and I'm
390:50 - going to really get the result from this
390:52 - function so this function is going to
390:54 - tell me whether that I is prime number
390:56 - or not so here I'm going to declare a
390:59 - variable of type ball and I'm going to
391:01 - call it is prime and I'm going to assign
391:05 - to that variable a value of is prime
391:10 - number when I pass it the value of I so
391:14 - whatever this function here returns
391:17 - whatever this function here results in
391:18 - I'm going to assign that result to my is
391:21 - prime variable okay and now what I want
391:25 - to write out is all the numbers that I
391:28 - that are prime numbers between one and
391:31 - this thousand value so I'm going to say
391:34 - if is prime like this I'm going to write
391:39 - out C out and then I want to write out
391:42 - the current value of my I counter
391:44 - because that is number that we are
391:46 - talking about so I is prime number
391:52 - number like this okay and I'm going to
391:55 - add a new line at the end so this code
392:00 - here is really going to check all the
392:02 - prime numbers between one and a th and
392:05 - it is going to write out all the prime
392:07 - numbers in that interval and for solving
392:11 - this particular problem so whether the
392:13 - number is prime number or not we have
392:14 - used this is prime number function which
392:18 - we have written once and we have really
392:20 - tested it once we know that it works as
392:23 - it should and now we can really close it
392:25 - we do not need to really think about how
392:28 - we are going to perform this task never
392:31 - again so we have written it we have oh
392:35 - we have tested it and now we have this
392:37 - algorithm stored in our is prime number
392:40 - function and we know that this function
392:43 - Works in a following way so we pass it a
392:45 - value and then this function return
392:47 - returns us true or false variable
392:50 - meaning that the number is prime number
392:52 - or not so once more if I run my program
392:56 - you can see that we have gotten the
392:58 - expected result so we have gotten all
393:00 - the prime numbers between one and a
393:04 - th000 okay and there are a lot of
393:08 - numbers okay so you can check these
393:11 - numbers on your calculator if you
393:14 - want and let's say now that we really
393:16 - want to check all the numbers between
393:18 - not just one and a th000 but let's say 1
393:21 - and 10,000 or
393:24 - 100,000 okay we can call just this is
393:28 - prime number function pass it the value
393:30 - of our I and then check the value that
393:32 - this function has returned and this
393:35 - function has really told us whether the
393:37 - number is prime number or not and if the
393:39 - number is prime number we just want to
393:41 - write that number out to our user so if
393:44 - I run this function again you can see
393:47 - that it is writing out all the prime
393:49 - numbers between 1 and
393:52 - 100,000 and there there is a lot of
393:55 - numbers again so you can even count how
393:59 - many prime numbers there are in this
394:01 - interval so between 1 and 100 ,000 and
394:04 - let's say that I'm going to leave that
394:06 - part to you so if you want to really uh
394:09 - upgrade this program so that it counts
394:11 - how many prime numbers there are in this
394:14 - interval you can write that code in the
394:16 - comments down below and I'm going to
394:18 - check it and as well you can leave it
394:20 - for other people to see and use if they
394:23 - need it so I hope that you have
394:25 - understood this return type of a
394:27 - function and in this particular
394:29 - situation it was Bull type but you can
394:32 - have as a return type from your function
394:34 - you can have any other data type so you
394:36 - can have float chart int uh string
394:40 - whichever data type you can really uh
394:42 - use in order to create a variable you
394:44 - can use that data type in order to be um
394:47 - return type of your function so in this
394:50 - particular situation I wanted to show
394:52 - you an example of a bit of a more
394:54 - complex function let's say that is going
394:57 - to determine whether your number is
394:59 - prime number or not and it is going to
395:02 - really receive that number that you want
395:04 - to check as an argument as parameter and
395:08 - then it is going to return only true or
395:11 - false meaning that number is prime
395:13 - number or that number is not prime
395:15 - number and once you have written this
395:18 - code and once you have tested it you do
395:21 - not really need to bother with this
395:23 - function anymore you do not need to
395:25 - remember this code nor read it nor even
395:28 - understand it in order to use this
395:30 - function only in a situation where you
395:33 - have a b bug and that bug is in this
395:36 - particular function only in that
395:38 - situation you are going to need to
395:40 - really reread this function and fix that
395:43 - bug in any other situation you can
395:45 - really just use this is prime number
395:48 - function uh and as well we could have
395:50 - made other functions with other return
395:52 - types we could have created for example
395:55 - a function that is going to um to sum
395:58 - two numbers so you are going to pass to
396:00 - a function two numbers let's say number
396:03 - a and number B which your user enters
396:06 - and then that function is going to sum
396:08 - those two numbers and it is going to
396:10 - return the result to your main function
396:12 - from where you are going to invoke that
396:14 - function and as well I can leave that to
396:17 - you so you can really practice writing
396:20 - functions on that example for example
396:22 - and you can put the code for that um
396:25 - exercise in the comments down below as
396:27 - well and I'm going to check it and in
396:30 - this particular example as I said I
396:32 - wanted to show you a bit more complex
396:34 - example so that you can really
396:36 - understand why we need functions and why
396:39 - they make our code understandable and
396:42 - reusable and if someone else comes to
396:45 - your code now and he sees that he has um
396:48 - is prime number function he does not
396:50 - really need to open this function and
396:53 - read how this function works it is
396:55 - pretty clear from this this declaration
396:59 - itself that this function receives a
397:02 - number and determines whether that
397:04 - number is prime number or not and
397:06 - returns that true or false back to the
397:10 - invoker back to the function that called
397:12 - that invoked this is primed is prime
397:15 - number okay so I hope that you like this
397:19 - video I hope that you enjoyed watching
397:21 - this video if you did make sure to like
397:23 - it and also subscribe to my channel and
397:26 - follow me on my other social media so
397:28 - Instagram Twitter account at true code
397:31 - Beauty the link is going to be in the
397:32 - description and I'm going to see you in
397:35 - my next video
397:37 - bye hi everyone welcome to my channel
397:40 - welcome to another C++ functions video
397:43 - and in this video I want to talk about
397:45 - concept that is related to functions
397:48 - which is function overloading so I want
397:50 - to First explain what function
397:52 - overloading is it means that you can
397:54 - create multiple functions with the same
397:57 - name but those functions are going to
397:59 - have different parameters so here I have
398:02 - opened my visual studio stud and let's
398:05 - create a function which is going to be
398:07 - called for example sum and I'm going to
398:10 - put the return type of that function to
398:12 - be int so integer if you're not familiar
398:15 - with function return types I'm going to
398:16 - link that video here so make sure to
398:18 - watch it so first thing we write the
398:21 - return type of our function and then we
398:24 - write the name of our function and as I
398:26 - said our function is going to be called
398:28 - sum and then I want to pass parameters
398:30 - to this function so I really want to
398:32 - declare which parameters this function
398:35 - is going to receive and those are going
398:36 - to be two
398:37 - parameters the first one is going to be
398:39 - integer and I'm going to call it a and
398:42 - then the second one is also going to be
398:44 - integer and I'm going to call it B like
398:47 - this so this is going to be our first
398:50 - function and let's also say that we want
398:52 - to create another function which is also
398:55 - going to be called sum but this time it
398:58 - is going to be of return type double
399:01 - like this and then I'm going going to
399:03 - call it sum as I already said and this
399:06 - function is going to receive two
399:08 - parameters as well but those are going
399:10 - to be of type double so I'm going to say
399:13 - double A and then Double B like
399:17 - this okay and as you can see these
399:20 - functions are underlined because it says
399:22 - function definition for sum not found
399:24 - meaning we have declared our functions
399:26 - here but these functions are missing the
399:29 - the definition so definition is missing
399:32 - for this function and and then this
399:33 - function as well and let's also create
399:36 - one more function so I'm going to say
399:37 - for example float and then I'm also
399:40 - going to call it sum and let's say that
399:43 - this time I'm going to give it um three
399:46 - parameters so I'm going to say
399:48 - float um let's say float a and then
399:51 - float B and then float C like this okay
399:57 - and then what I want to do is I want to
399:59 - create definitions for these functions
400:02 - which I'm going to do here here so the
400:04 - first one that I want to Define is going
400:05 - to be this one here so I'm going to copy
400:09 - its declaration and then I'm going to
400:10 - add these curly brackets and here I'm
400:13 - going to put a definition for this
400:15 - function so let's say that I'm going to
400:17 - create a variable of type int and I'm
400:20 - going to call that variable
400:22 - result like this and I'm going to assign
400:26 - it the result of a + b like this and
400:30 - then what I want to do is return this
400:32 - result from my function fun so here I'm
400:34 - going to say return result like this so
400:39 - this would be one way of returning the
400:42 - result from your function and then
400:43 - another way to do the same thing is
400:45 - going to be to say really return here so
400:48 - instead of creating a variable that is
400:50 - going to hold this result you can really
400:53 - return this result itself from your
400:55 - function so you can say
400:57 - here return A+ B and now we can delete
401:02 - this line and as you can see this
401:04 - function became shorter and more
401:06 - readable so now I want to Define this
401:09 - function here so I'm going to say
401:12 - double okay I should have copied
401:15 - this and then double b as well like this
401:21 - so here I want to put the definition for
401:23 - this function here and this function oh
401:27 - I'm missing the name for my function it
401:30 - is called sum so this is return type
401:32 - this is the name of our function and
401:34 - then these are parameters of our
401:36 - function and here I want to say return a
401:40 - + b as well but this time our a and our
401:44 - B are going to be of type double so in
401:47 - this situation there were integers and
401:49 - then in this situation there are decimal
401:52 - numbers okay and let's also create a
401:56 - definition for this function here so
401:59 - this float function and this time I'm
402:01 - going to copy it
402:05 - okay and I'm going to add these curly
402:07 - brackets and here I want to write return
402:12 - and then A + B + C like this okay so now
402:18 - how we are going to test this we can
402:20 - call these functions we can invoke these
402:22 - functions here in our main function and
402:25 - the first one that I want to invoke is
402:27 - going to be our in function so I'm going
402:28 - to say C out and then this line of code
402:32 - is going to write out whatever our
402:35 - function returns so I'm going to say
402:36 - please write out whatever my sum
402:39 - function returns and then I want to pass
402:42 - to my sum function two numbers and those
402:45 - two numbers are going to be two integers
402:48 - and as you can see here we have really
402:50 - helped from our Intel ense which says
402:53 - you have three possible functions that
402:55 - you can call so you have overloaded
402:57 - three functions and you can navigate
403:00 - through these using your arrows so the
403:03 - first one is going to be our function
403:05 - that has float return type and that
403:07 - function return that function receives
403:09 - three parameters of type float and then
403:12 - the second one is going to be the one
403:13 - that has return type double and that
403:16 - function receives two double parameters
403:19 - and then the third one is going to be
403:21 - the one that returns integer and that
403:23 - function receives two integer values so
403:26 - here I want to call our integer function
403:29 - and I want to pass to that function four
403:32 - and three for example and let's also add
403:35 - end line like
403:37 - this and now if I run my
403:41 - program we can expect to see the result
403:44 - of this line of code here and as you can
403:46 - see the result is seven meaning that our
403:49 - function has been invoked and then this
403:51 - line of code has received the result of
403:54 - summing these two numbers and that has
403:56 - been written out in our console and the
403:59 - result of summing four and three is
404:01 - seven Okay so now I'm going to stop this
404:04 - console and I want to test these other
404:07 - two functions so I'm going to say see
404:09 - out and let's test our some function
404:12 - that receives two double parameters so
404:15 - it is going to be this one here so I'm
404:18 - going to say 4.4 and then 3.3 for
404:21 - example and I'm going to add end line at
404:24 - the end as well okay and now if I run
404:29 - this program you can see that our second
404:32 - line is is 7.7 meaning 4.4 + 3.3 is
404:37 - going to be 7.7 which is correct so we
404:41 - have successfully tested this function
404:44 - here so this double function that
404:46 - returns double and receives also two
404:49 - double parameters and then let's also
404:51 - test this third function so here I want
404:54 - to say C out sum and then here I want to
404:59 - pass three parameters the first one is
405:01 - going to be let's say four .4 and then
405:04 - the second one is going to be 3.3 and
405:07 - then oh three decimal points 3.3 and
405:11 - then the third one is going to be 2.2
405:15 - for
405:15 - example okay now this invocation should
405:19 - invoke this float function so when I run
405:24 - my program as you can see here this
405:27 - third line contains the result of
405:29 - summing these three numbers and you can
405:31 - check this out using a calculator but
405:33 - this is the correct result so as I
405:37 - already explained this represents
405:40 - function overloading and we have created
405:43 - three functions the first one is the one
405:46 - that receives in types and returns in
405:49 - type as well then the second one
405:51 - receives double so two double uh
405:54 - variables two double parameters and
405:57 - returns double as well and then the
405:59 - third one really contains three
406:01 - arguments so three parameter parameters
406:03 - but it has the same name as these
406:06 - previous two and then it returns float
406:09 - type as well and then now when we call
406:12 - when we invoke those functions we can
406:14 - really pass different data types and
406:16 - depending on those data types we are
406:18 - going to call adequate function so in
406:20 - this first line we are going to invoke
406:22 - this and then in this second line we are
406:25 - going to invoke this and then in our
406:27 - third line we are going to invoke this
406:31 - okay so I hope that you understood what
406:33 - function overloading is and also I hope
406:36 - that you have understood that you don't
406:38 - have to create functions with different
406:40 - names when they are doing uh almost the
406:43 - same thing so these three functions
406:46 - these three are doing the same thing
406:48 - they are summing the numbers that we
406:50 - pass to them only in this particular
406:52 - situation the first one is summing
406:54 - integers the second one is summing
406:56 - decimal point numbers and then this
406:58 - third one really sums three numbers and
407:01 - we have overloaded this sum function and
407:05 - we didn't have to create functions that
407:07 - are for example sum int and then
407:11 - some double oh double and then some
407:16 - float like this so we didn't have to
407:19 - name these like some int some double and
407:23 - some float but we can use the same name
407:25 - as long as we have different parameters
407:29 - different number of parameters different
407:31 - return type or something similar in that
407:34 - particular situation our compiler is
407:36 - going to decide on its own which
407:38 - function it should call I hope that you
407:40 - have understood what function
407:42 - overloading is and how you can use that
407:45 - thanks for watching and I'm going to see
407:47 - you in my next video
407:50 - bye hi everyone welcome to my channel my
407:54 - name is Salina and I make it and
407:56 - programming related videos so if that is
407:59 - something that is of interest to you
408:01 - consider subscribing to my channel and
408:03 - give this video a thumbs up as well now
408:06 - in this video I want to show you how you
408:08 - can build an ATM application and the
408:11 - first thing that I want to do in order
408:13 - to build this application is going to be
408:15 - to plan the functionalities that this
408:18 - application is going to have so I'm
408:20 - going to put a comment here and then
408:22 - here we are going to write all the
408:24 - functionalities that our ATM is going to
408:27 - have so the first one is going to be to
408:30 - check the balance so I'm going to write
408:32 - that
408:35 - so check balance and then another
408:38 - functionality is going to be to deposit
408:41 - money so let's say
408:44 - deposit like this okay and then what
408:48 - else well we should be able to withdraw
408:51 - money as well so let's write
408:55 - that okay and I definitely want to show
408:58 - the menu to my user so I'm going to
409:00 - write that as well so I'm going to say
409:02 - say
409:03 - show
409:05 - menu like this okay now after we have
409:09 - written these functionalities that we
409:11 - want to implement the first one that I
409:14 - want to implement is going to be this
409:15 - show menu function so I'm going to put
409:18 - the code for this show menu
409:20 - functionality in a function and let's
409:24 - create that function here so I'm going
409:25 - to say void it is going to be of void
409:28 - return type let's call it show menu
409:32 - like this oh like this okay and then
409:38 - what I want to do here is I want to
409:40 - write out the menu to my user so I'm
409:42 - going to say see out and then let's add
409:45 - these star symbols four 5 6 7 8 9 10
409:50 - that is going to be
409:51 - enough like this and then I'm going to
409:54 - copy this on the other
409:57 - side so that it looks
409:59 - proportional okay and then the first
410:02 - option that I want to write out my user
410:05 - is going to be uh let's add first and
410:09 - then check
410:12 - balance so that is going to be the first
410:15 - option that our user can choose and then
410:19 - let's add couple more of these so the
410:22 - second option is going to be deposit so
410:25 - I'm going to write
410:27 - that like this and then the third option
410:31 - is going to be to with draw so I'm going
410:33 - to copy this here and then paste it
410:38 - here okay and then let's add these star
410:41 - symbols at the end of our menu like
410:45 - this okay now after we have created this
410:50 - show menu function what I want to do is
410:52 - I want to invoke this function so here
410:55 - I'm going to say um show menu like
411:00 - this okay and if I run my
411:06 - program as you can see we have this menu
411:10 - shown to our user now what should happen
411:13 - next is we should allow our user to
411:16 - choose one of these three options so the
411:19 - next thing that I will do is I will
411:22 - create a variable so let's create it
411:25 - here let's say int and that variable is
411:28 - going to store the option that our user
411:30 - chooses so I'm going to call it option
411:35 - like this and then here after I have
411:38 - written out this menu so this menu here
411:41 - to my user I'm going to say see out and
411:44 - then please choose an option or whatever
411:47 - message you want to show so
411:51 - option like
411:54 - this and then I want to accept the value
411:58 - that my user enters in this option
412:00 - variable so I'm going to say C in
412:03 - option like this okay now if I run this
412:09 - program again as you can see it asks for
412:11 - option and if I select any of these
412:14 - three options if I press three for
412:17 - example you can see that my program
412:19 - closes because we haven't written any
412:22 - code after this line here so what I want
412:25 - to do now is I want to handle these
412:28 - three options and I'm going to handle
412:31 - these three options using a switch case
412:34 - so I'm going to write
412:36 - switch okay and then here I want to put
412:41 - this option variable so that is going to
412:43 - be the value that I want to check so I'm
412:46 - going to say switch option and then in
412:50 - the case that our user has entered
412:52 - option one what I want to do is I want
412:56 - to write out the balance to my user and
412:59 - in order to do that I'm going to create
413:02 - a balance variable because we do not
413:04 - have a balanced variable yet so I'm
413:06 - going to give it a type
413:08 - double like this and call it
413:12 - balance okay and let's assign it initial
413:15 - value of uh for example 5 100 okay so
413:20 - that is going to be the initial value of
413:22 - our balance um variable so here I'm
413:25 - going to say C out and then let's say
413:30 - balance is
413:33 - okay and then let's write out this
413:36 - balance
413:38 - variable and I'm going to add this
413:41 - dollar symbol at the end and I'm going
413:43 - to add end line as well okay so that is
413:47 - going to happen in the case that our
413:48 - user enters value or option one and I'm
413:53 - going to add break at the end of each
413:56 - case so here as
413:59 - well okay now our second case case is
414:02 - going to be when our user enters option
414:06 - two like this so in that second case we
414:10 - should allow our user to deposit money
414:13 - so here I'm going to say see out and
414:17 - then let's write out um
414:20 - deposit amount so we want to ask our
414:23 - user how how much money he wants to
414:27 - deposit so in order to accept the value
414:30 - that our user enters I'm going to create
414:32 - a variable which I'm going to call
414:34 - deposit amount so let's create that
414:38 - variable it's going to be of type double
414:41 - and it is going to be called deposit
414:45 - amount like this and then I'm going to
414:49 - accept the value that our user enters
414:52 - here in my deposit amount variable like
414:56 - this okay and now what I want to do with
415:00 - this deposit amount is I want to add it
415:03 - to my balance so I'm going to say
415:05 - balance is now going to be equal to
415:09 - whatever my balance was previously
415:11 - holding plus this deposit amount like
415:15 - this and then let's add break at the end
415:18 - as well okay and then our third option
415:23 - our third case is going to be when our
415:25 - user wants to withdraw money so I'm
415:27 - going to copy this case here and then
415:30 - paste it here and here I want to write
415:33 - out a different message to my user so
415:35 - I'm going to say withdraw amount let's
415:38 - copy
415:40 - this okay and then this variable I'm
415:43 - going to call
415:44 - it withdraw
415:46 - amount like this okay and then here I
415:50 - want to enter that withdraw amount and
415:54 - what I'm going to do with my balance in
415:56 - that situation is going to be I want to
415:58 - subtract that withdraw amount from my
416:02 - balance but I want to subtract that
416:05 - withdraw amount only in a situation
416:08 - where this withdraw amount is equal to
416:11 - or less than this balance so I'm going
416:14 - to say here if withdraw where it is
416:18 - withraw amount is less than or equal to
416:23 - balance like this then I want to give
416:27 - that money to my user else meaning if
416:31 - our user has has requested more money
416:33 - than he has I'm going to write out a
416:36 - message so I'm going to say not enough
416:41 - money like
416:44 - this okay and that is going to happen so
416:47 - this code here is going to happen in the
416:50 - case that our user enters option three
416:53 - which is this one here okay so now if I
416:57 - run my
416:59 - program you can see that it asks option
417:03 - and let's see that we want this first
417:05 - option so this check balance and it says
417:08 - that balance is 500 and if I press
417:11 - anything else as you can see my program
417:14 - is going to close and that is because we
417:16 - haven't implemented any Loop that is
417:19 - going to iterate this code here so let's
417:22 - add that Loop now so here I'm going to
417:26 - say do so do while loop is the one that
417:29 - I want to use and then in inside my do
417:32 - while loop I'm going to put all of this
417:35 - code here so let's add a curly bracket
417:38 - close curly bracket at the end like this
417:42 - and then I'm going to say please do this
417:45 - block of code here
417:48 - while and then I want to do this code
417:52 - here while the option that my user has
417:55 - ento
417:57 - option that my user has entered is not
418:00 - equal to four four and when my user
418:04 - enters option four we should stop the
418:06 - execution of our program so in order for
418:09 - our user to know that for means exit we
418:13 - are going to write that here in our show
418:15 - menu function so here I'm going to add
418:18 - this fourth option which is going to
418:21 - exit our program like this okay now if I
418:26 - run this
418:27 - code you can see that it says that it
418:31 - has this menu here and then it asks for
418:35 - option so I'm going to enter option one
418:37 - for example okay and this option one
418:41 - says that balance is
418:44 - $500 now let's enter this second option
418:47 - let's enter this deposit option so I'm
418:49 - going to press two and as you can see it
418:52 - says please enter deposit amount so
418:54 - let's say that I want to deposit $700
418:58 - for example okay now if I check my b
419:02 - balance again so I have entered this
419:04 - option one and then I press enter as you
419:06 - can see it says that my balance is
419:10 - $1,200 and there is one thing that I
419:12 - want to do with this program because I
419:13 - don't like the way that this looks it is
419:16 - not really readable so I'm going to add
419:19 - um clear screen so clear console command
419:23 - and I'm going to add that here so after
419:26 - my user chooses his option I want to
419:29 - clear the console so I'm going to say
419:31 - system
419:34 - and then let's add CLS which is a
419:37 - command that is going to clear my
419:39 - console clear my um window so if I run
419:43 - my program again as you can see again we
419:45 - have this menu and then it asks us for
419:48 - the option so let's say that I want to
419:51 - check my balance it says that my balance
419:54 - is
419:54 - $500 now let's try to withdraw money
419:57 - let's say that I want to withdraw money
419:59 - and I want to withdraw $600
420:02 - for example and then it says not enough
420:05 - money because we had
420:07 - $500 um on our account so now what I
420:11 - want to do is let's say for example that
420:13 - I want to
420:14 - deposit
420:16 - $100 okay and then I want to withdraw
420:21 - $600 okay and if I check my balance now
420:24 - as you can see balance is zero and in
420:27 - order to test this exit functionality
420:30 - let's press for and then if I press
420:33 - enter as you can see my application is
420:35 - going to
420:36 - close now another thing that I want to
420:39 - check is going to be what is going to
420:41 - happen if our user enters option that is
420:44 - not valid meaning an option that is not
420:47 - any of these for that we have covered
420:50 - here so if I run my program again as you
420:53 - can see um it asks us to enter options
420:56 - so I'm going to enter option five for
420:58 - example which is not valid and nothing
421:01 - has happened happened if I enter option
421:03 - n nothing has happened again 99 okay now
421:07 - you get the point what is happening here
421:10 - is our program tries to find this
421:13 - adequate option so option five option n
421:17 - whichever one we have selected and since
421:20 - that option does not exist in these
421:22 - cases here our program continues to this
421:25 - while check and then it checks that the
421:27 - option is not equal to four and because
421:29 - our option is five or 9 or 99 which is
421:33 - not equal to 4 then our DU while
421:36 - iterates again and then it writes this
421:38 - show menu again and then it asks us to
421:41 - enter this option again so these three
421:44 - options are the only valid options that
421:47 - you can select and then four means that
421:49 - you are going to exit your program now
421:53 - here we have created this show menu
421:56 - function that has uh check balance
421:59 - deposit withdraw and then this exit
422:02 - option and what I want to suggest to you
422:05 - is how you can upgrade this program on
422:08 - your own so for example you can create
422:11 - two users two accounts and what you can
422:14 - do with those two users is you can
422:16 - Implement transfer option meaning um
422:19 - transfer money from one account to the
422:21 - other account and I'm going to leave
422:24 - that up to you and if some of you decide
422:26 - to write that code make sure to paste it
422:29 - in the comments down below and I'm going
422:30 - to review that code and and some other
422:32 - people may find it useful as well so I
422:35 - hope that you enjoyed this video if you
422:37 - did give it a thumbs up don't forget to
422:39 - subscribe to my channel and hit that
422:41 - Bell icon as well and I'm going to see
422:44 - you in my next video bye hi everyone
422:48 - welcome to my channel my name is Salina
422:50 - and I make it and programming related
422:53 - videos so if you're interested in those
422:55 - please subscribe to my channel and give
422:57 - this video a thumbs up because that
422:59 - helps me a lot to reach more people and
423:01 - spread programming knowledge and in this
423:03 - video I want to talk about generics and
423:06 - templates in C++ so what are generics
423:10 - the idea of generics was born when
423:12 - programmers decided that they want to be
423:14 - able to use the same code but with
423:17 - different data types so the logic is the
423:20 - same but data types are different or if
423:23 - you want another explanation when we
423:25 - talked about functions we said that we
423:27 - can pass parameters to functions and
423:30 - what we said as well is that types of
423:32 - those parameters had to be known
423:34 - beforehand so you had to hardcode types
423:37 - of those parameters whether it is int or
423:40 - Char or float or any other data type
423:43 - that had to be known beforehand but with
423:46 - this idea of generics what we should be
423:48 - able to do is we should be able to pass
423:51 - that type itself to a function so we
423:54 - should be able to determine which type
423:57 - we want that function to operate on and
424:00 - the best way for you to understand and
424:01 - this will be on an example so that is
424:03 - exactly what I will do so let's say that
424:06 - in my visual studio I want to create a
424:09 - function that will swap the values of
424:11 - two variables and if you don't have an
424:14 - idea how you can swap values of two
424:16 - variables I have a video where I
424:18 - explained that uh in a very visual way
424:22 - so you can use that video I will link it
424:24 - here so here I will just type very
424:27 - quickly the code for that and if you
424:29 - need explanation again you can watch
424:31 - that video so I will say that that
424:33 - function will be of return type void and
424:36 - I will call it Swap and then what I want
424:39 - to pass this function will be two
424:41 - integer variables so I will say int a
424:45 - and then int int B like this okay but
424:50 - because I want to have both of these
424:52 - variables available in my main function
424:55 - which will invoke my swap function I
424:57 - will have to pass these two variables
425:00 - using a reference
425:02 - and again if you're not familiar with
425:04 - passing parameters by a reference I will
425:06 - link another video here where I talk
425:09 - about that and I think that I made more
425:11 - than one video on my channel talking
425:13 - about passing variables by a reference
425:14 - to a function so I will put those in the
425:17 - description as well so the code for this
425:20 - swap function will be the following so I
425:23 - will say int temp I will create a
425:26 - temporary variable and to that temporary
425:28 - variable I will assign the value that my
425:30 - variable a is hold holding and then I
425:33 - will assign to my variable a the value
425:36 - that my B is holding like this and then
425:38 - to my B I will assign whatever my temp
425:42 - variable is holding again if you need to
425:45 - understand this in more detail I will
425:47 - put video in the description of this
425:50 - logic here okay so now this function
425:53 - should give us the ability to swap
425:56 - values of two variables and the way to
425:58 - test this function is the following so I
426:00 - will say please create two variables
426:02 - call them A and B like this and to my a
426:07 - variable I will assign the value of five
426:09 - for example and then B will have the
426:11 - value of s so let's write out values of
426:15 - these two variables let's say a and then
426:19 - just make a separation and then value of
426:22 - B like this okay so now what I want to
426:25 - do is I want to invoke this swap
426:27 - function I will say Swap and then I will
426:31 - pass my a and then B like this and if I
426:35 - copy this line after the invocation of
426:37 - my swap function we will see if the
426:40 - values had indeed been changed so if I
426:43 - run my
426:44 - program as you can see this line of code
426:48 - here has resulted with this output so 57
426:51 - and then after invoking our swap
426:53 - function the values inside these two
426:55 - variables so A and B have successfully
426:58 - been swapped so now it is 75 okay
427:02 - excellent so that means that this
427:03 - function does what it should do now what
427:06 - happens if I want to swap values of two
427:08 - Char variables for example what I would
427:11 - have to do is I would have to copy this
427:14 - function paste it here and then I will
427:17 - adjust it to be able to work with Char
427:20 - variables so I will say Char and then I
427:23 - will change this with Char as well and
427:26 - then here I will put Char as well now
427:28 - this swap function should work with char
427:31 - parameters and this is called function
427:34 - overloading if you're not familiar with
427:36 - function overloading I made that video
427:38 - explaining how it works so I will link
427:41 - it here if you want to watch it and I
427:43 - will put it in the description as well
427:45 - so this function should be able to work
427:47 - with Char parameters now and in order to
427:50 - test this function let's create two
427:52 - variables of type Char so Char C and
427:57 - then d as well and to my C variable I
428:00 - will assign the value of letter C and
428:03 - then to d i will assign the value of
428:05 - letter D excellent so I will copy this
428:08 - line of code here and I will just adjust
428:10 - it so that now we write out the value of
428:13 - our C variable and then here we write
428:15 - out the value of my D variable like this
428:18 - and then after this line of code here I
428:20 - want to invoke this swap function so I
428:22 - will say Swap and then pass it C and
428:27 - D like this and I want to write out my C
428:31 - and D variables after this line of code
428:34 - here so after I have swapped the values
428:36 - just to check that they successfully
428:38 - have been swapped so if I run my code as
428:42 - you can see we have this out output here
428:45 - so c and d and then after swapping the
428:48 - values inside these two variables we
428:50 - have this output here which means that
428:52 - they have been swapped successfully now
428:56 - um I see a problem with this approach
428:58 - here and the problem is following what
429:01 - happens if I want for example to swap
429:04 - values of two float variables and then
429:06 - two doubles and then two booleans and so
429:08 - on well I would have to create this swap
429:11 - function for each data type and that is
429:15 - repeating code and we shouldn't really
429:16 - be repeating code unless we really need
429:18 - to and in this particular situation we
429:20 - don't so there is a simple solution for
429:24 - this problem and that simple solution
429:26 - will be using generics and the idea is
429:30 - to be able to use
429:31 - the same function the same logic but
429:34 - with different data types so again we
429:36 - will be solving this problem using
429:38 - generics and the way that generics are
429:41 - implemented is using templates so how do
429:44 - you make a template in C++ well you use
429:48 - keyword that is template like this and
429:51 - then inside these angled brackets you
429:55 - will put the name of your type so you
429:57 - will say type name and um most common
430:01 - type name that is used is called T but
430:04 - you can use whichever type name you want
430:06 - you can say type as well if you want
430:09 - that should work but I will use T
430:11 - because that is the recommended way so
430:14 - now that I have created a template and I
430:16 - have said I want to create a new type
430:19 - which is called T I will have to use
430:21 - this T in my swap function so now I will
430:26 - change this int with my T so I will say
430:29 - t here and and then T here and I will
430:34 - create T here as well okay now this T is
430:38 - called generic data type and this swap
430:41 - function is now a generic function which
430:43 - means that this swap function can be
430:45 - used on any data type whose variables
430:48 - can be swapped using this logic here so
430:51 - in one invocation it can be swapping
430:53 - integer variables and then in another it
430:55 - can be swapping characters and then in
430:57 - the next one floats and then doubles and
430:59 - booleans and so on on so now that means
431:03 - that we can really remove this swap
431:06 - function because we do not need it
431:07 - because as we said this function here is
431:10 - a generic function and it can be used
431:12 - with different data types so now I will
431:15 - delete this swap function here and if I
431:18 - run this code this code should work as
431:21 - it did before so let's press this button
431:25 - okay and as you can see 57 and then 75
431:29 - this function indeed works for integers
431:31 - and then CD and then DC so it works for
431:35 - characters as well and let's close this
431:38 - okay now what you can do here as well
431:40 - here in the invocation in this 15th line
431:44 - invoking this function for two integer
431:46 - variables what you can do is you can
431:47 - specify the type itself as well so you
431:49 - can say I am invoking this swap function
431:53 - for my integer type so now when this
431:56 - function is invoked it will go here and
432:00 - this T keyword will be changed with this
432:03 - int so it will be int here and then int
432:06 - here and then int here and it will do
432:09 - the swapping this function here will do
432:11 - the swapping for INT data type and then
432:14 - in this 20th line here you can say as
432:18 - well Char if you want you don't have to
432:20 - that process will happen automatically
432:22 - because you have declared C and D as
432:25 - charart type so those C and D of type
432:28 - chart will be passed here and then Char
432:30 - will be here here and Char will be here
432:32 - and then Char will be here as well so
432:35 - what we have acquired with this template
432:38 - function here is to be able to use the
432:40 - same code with different data types we
432:43 - have just demonstrated how that can be
432:45 - invoked for integer data type and then
432:47 - how we can use it for character and you
432:49 - can do on your own float or double or
432:51 - bull and so on okay and then what you
432:55 - can do as well is you can use any other
432:58 - name for your generic type T is
432:59 - something that is used commonly in
433:01 - literature but you can use type as well
433:04 - if you want so you can say oh you can
433:06 - say type and then you would have to say
433:09 - type here and then type here and here as
433:14 - well okay that should work the same way
433:17 - that it did previously and then another
433:19 - thing that you will find in literature
433:21 - is instead of this type name keyword you
433:24 - can use class um it really depends on
433:27 - you whichever one you want to use you
433:29 - can and again if you know what classes
433:32 - are class is a type as well so it is
433:35 - userdefined type so this should work as
433:37 - well the same way that type name keyword
433:40 - did and if you're not familiar with
433:42 - classes and objects and objectoriented
433:44 - programming I have course which I will
433:46 - link here so make sure to watch that so
433:50 - I hope that this video helped you
433:51 - understand what are generics and
433:53 - templates and what is the main idea
433:55 - behind them and we will be talking about
433:57 - this of course in my future videos and
433:59 - in more depth so so make sure to
434:01 - subscribe to my channel and hit that
434:03 - Bell icon as well so that you don't miss
434:05 - a video that I publish and if you like
434:08 - this one please give it a thumbs up that
434:10 - helps me to reach more people and help
434:12 - more people with programming so thank
434:14 - you very much for watching and I am
434:16 - going to see you in my next video bye hi
434:18 - everyone welcome to my channel my name
434:20 - is Salina and I make it and programming
434:23 - related videos so if that is something
434:26 - that is of interest to you consider
434:28 - subscribing to my channel and in this
434:30 - video I want talk about recursion and
434:32 - recursive functions in my previous
434:35 - videos we already talked about functions
434:37 - in general so you should be familiar
434:39 - with that and then in this video I want
434:41 - to show you on an example what is
434:44 - recursion and how it works so what is
434:47 - recursion recursion is a process where a
434:50 - function invokes itself and that
434:53 - function that invokes itself is called
434:55 - recursive function that is pretty simple
434:58 - definition so let's show that on an
435:01 - example and the example that I want to
435:03 - give you today in this video will be the
435:06 - sum all the numbers between M and N
435:09 - which are the numbers that our user
435:11 - defines and the first thing that I want
435:13 - to show is we will solve that problem
435:15 - using Loops which is a solution that you
435:18 - should already be familiar with and if
435:20 - you don't understand Loops you can find
435:22 - videos on Loops in my C++ for beginers
435:25 - playlist so you can watch that and then
435:27 - after we solve that problem using Loops
435:30 - I want to show you how you can solve
435:31 - that same problem using recursion so if
435:34 - you want to skip directly to the
435:36 - recursion part I'm going to leave the
435:38 - link to that part the time stamp in the
435:41 - description of this video so that you
435:42 - can navigate yourself directly to the
435:45 - recursion part if you want now as I
435:47 - already said the problem that we want to
435:49 - solve in this video is going to be to
435:51 - sum all numbers between number M and N
435:54 - so let's write the text of our task here
435:58 - I'm going to say
435:59 - sum number
436:01 - first
436:04 - between M and N okay so this is going to
436:08 - be our task and then here as I already
436:11 - said I will first solve this problem
436:14 - using Loops so considering that we have
436:17 - to sum numbers between number M and N I
436:20 - will create two variables so int M and N
436:24 - which are two variables to hold the
436:26 - numbers that our user enters you can do
436:28 - that part I'm going to hard code those
436:31 - values here so let's say that my number
436:33 - M that my variable M holds value of two
436:36 - and then n holds the value of four for
436:39 - example uh and one thing if you are
436:42 - going to ask your user to enter the
436:44 - numbers for these two variables what you
436:46 - should do is you should make sure that
436:48 - your user enters smaller number in your
436:50 - variable M and then greater number in
436:53 - your variable n and if that is not the
436:57 - case there are a few ways to solve that
436:59 - problem so you can swap the values in
437:01 - those in these two variables if your
437:03 - user enters bigger number here and then
437:05 - smaller one here and if you don't know
437:07 - how to swap the values into variables
437:10 - I'm going to put a link which contains
437:11 - the explanation for that here and then
437:14 - you can as well just ask your user to
437:17 - enter again and again and again until
437:19 - this number is smaller and then this one
437:21 - is greater uh and as I already said I'm
437:24 - just going to hard code these two values
437:26 - here okay so now that we have our number
437:30 - M and our number n what I'm going to do
437:32 - is I will write a loop which is going to
437:35 - solve this problem here and the easiest
437:38 - way to solve this problem here is going
437:40 - to be using four Loops so I will say
437:42 - four and then I will declare a counter
437:45 - in I and that counter should start at
437:48 - the value of our variable M so I is
437:52 - equal to M and then it should count
437:55 - until it comes to the value of n so
437:58 - while our I is less than or equal to n
438:02 - oh sorry so while our I is less than or
438:06 - equal to n and then in each iteration
438:09 - I'm going to increase the value of my
438:11 - counter by one okay so what I should do
438:14 - in this for Loop here is I will just sum
438:18 - all the values that my counter holds in
438:21 - a specific iteration so I will create a
438:24 - variable here which is going to be of
438:26 - type int and I will call it sum and
438:30 - initial Val for our sum will be zero
438:33 - because zero is neutral when it comes to
438:35 - adding so here I will write sum is equal
438:39 - to whatever our sum was previously
438:41 - holding and then to that I will add the
438:44 - value of my I counter like this so this
438:48 - should be pretty much it to solve this
438:50 - problem and at the end of this for Loop
438:53 - we should have the sum of the numbers
438:55 - between two and four in this variable
438:57 - here so let's write that out I will say
439:00 - C out out sum is equal to and then write
439:04 - out the value that are sum variable
439:07 - holds and if you are not familiar with
439:09 - this code here you should watch my video
439:12 - related to for Loop and I'm going to
439:14 - link it here or leave it in the
439:16 - description down below so let's run our
439:18 - program and test this code here okay it
439:22 - says that our sum is equal to 9 so 2 + 3
439:25 - is 5 + 4 is 9 so that is the correct
439:29 - result so this approach here will solve
439:32 - this problem using loops and this is
439:35 - something that you should already be
439:36 - familiar with and now I'm going to show
439:39 - you how you can solve the same problem
439:41 - using recursive functions so let's
439:43 - comment this code out because I don't
439:46 - need it anymore like this and then what
439:50 - I want to do is I want to create a
439:52 - function of return type int and I will
439:56 - call it let's call it
439:59 - recursive sum like
440:02 - this okay so this recursive sum function
440:06 - will receive two parameters and those
440:08 - two will be integer number M and then
440:12 - integer which is called number n so we
440:16 - will pass these two values to our
440:18 - recursive sum function and what should
440:21 - we do inside this recursive sum function
440:23 - well the same way that we do not want
440:25 - this four Loop to be an infinite Loop we
440:28 - do not want our function to be an
440:31 - infinite recursion so here we specified
440:34 - the condition when our for Loop is going
440:36 - to stop to execute so here when our
440:38 - counter I reaches the value of n that is
440:41 - the point when our for Loop stops
440:44 - running and then here in our recursive
440:46 - sum function we will have to define a
440:48 - base case which is going to break this
440:52 - recursion so as I already said it is
440:55 - called base case and for this recursive
440:57 - sum function our base case will be
441:00 - following so I will say if our m is
441:03 - equal to n in that case what I want to
441:07 - do is I want to return from this
441:08 - recursive sum function value of our M or
441:12 - n so I will say return M it doesn't
441:15 - really matter which one you return
441:17 - because here we have checked that they
441:18 - are equal okay so this here is our base
441:23 - case something that is going to break
441:25 - our recursion so that we do not end up
441:27 - with an infinite recursion okay and then
441:31 - what I want to do here is I want to do
441:33 - that recursive part so that part where
441:35 - the function is invoking itself and what
441:38 - we should do here is the following so I
441:41 - will say return and here I want to
441:43 - return the value of M so the current
441:47 - value of our M parameter and then I will
441:49 - add to that the following expression so
441:52 - I will invoke again our recursive sum
441:55 - function but this time I will pass to
441:58 - this recursive sum function the value of
442:01 - our m + 1 and then the value of our n
442:06 - variable okay so what this code here is
442:09 - going to do the same way that here we
442:11 - have increased the value of our I
442:13 - counter in each iteration here I'm
442:17 - increasing the value of our M parameter
442:20 - in each recursion so that at a certain
442:22 - point we are going to reach this
442:24 - condition here so our M and RN will be
442:27 - equal and at that point our recursion is
442:30 - going to stop so how is this code here
442:33 - going to behave well let's write out
442:36 - invocation of this function here and
442:38 - then we are going to go line by line
442:41 - through the execution of this program so
442:43 - that you can understand how this
442:44 - recursion is going to work so let's say
442:47 - see out sum is equal to and then I will
442:52 - invoke this recursive sum so recursive
442:56 - sum and here I want to pass the value of
442:59 - M and N
443:01 - like this so when we come to this 14th
443:04 - line of code here what is going to
443:07 - happen is we will pass values of two and
443:10 - four to this function here so I will
443:12 - write that my M holds the value of two
443:15 - and then n holds the value of four okay
443:19 - and then we come to this line of code
443:21 - here and we check is our m equal to our
443:24 - n so is 2 equal to 4 the answer to that
443:27 - is no so we do not execute this but we
443:30 - go here and what this line of code here
443:33 - says it says please return from this
443:36 - function the following so return current
443:39 - value of my M which is two and then to
443:42 - that I will add whatever this recursive
443:46 - sum function returns to me if I pass it
443:49 - m + one and N so here I will invoke
443:53 - function again and I'm going to use
443:56 - these parentheses to indicate invocation
443:58 - of a function so here we are invoking
444:01 - recursive sum function again and this
444:04 - time we are passing it values of n + one
444:07 - which is three and then n stays the same
444:10 - because our n is our upper limit so that
444:13 - we can know when we are going to break
444:15 - this recursion so here is the invocation
444:18 - of this function again and then we have
444:20 - entered this function using these two
444:23 - parameters so we go here again and we
444:26 - check again is our m equal to r n so is
444:29 - 3 equal to 4 the answer to that is no so
444:32 - we do not execute this line of code but
444:35 - we go here again and what this line of
444:37 - code here says it says please return
444:40 - current value of M which is in this
444:43 - recursion three and then add to that
444:46 - whatever this recursive sum function
444:49 - returns for these parameters here so
444:53 - here I will invoke recursion again and I
444:56 - will indicate that again with these
444:58 - parentheses so we inv invoke our
445:00 - recursive function again with parameters
445:03 - of n + 1 which is four and then n stays
445:07 - the same so we go here again and we
445:10 - check is 4 equal to 4 and the answer to
445:13 - that question now is yes so now we
445:16 - return the value of RM which is four so
445:20 - here I will say that this recursion
445:23 - Returns the value of four and then we go
445:26 - backwards so here we have all the
445:28 - invocations of this recursive of some
445:30 - function so the result the end result of
445:33 - this recursion is going to be the result
445:36 - of this expression here so let's
445:38 - calculate what this recursive sum
445:40 - function is going to return finally at
445:42 - the end so this is one recursion and
445:46 - that recursion Returns the value of four
445:48 - so I'm going to delete these parentheses
445:51 - and then the recursion prior to that
445:54 - returned the value of 3 + 4 which is 7
445:59 - and then if we come out this recursion
446:01 - as well so I will delete these
446:03 - parentheses the result of our recursive
446:06 - sum function will be the result of this
446:08 - expression so 2 + 7 will be equal to 9
446:13 - so this is going to be the result of our
446:15 - recursive sum function so if I run my
446:18 - program now we should get this nine as
446:21 - the result of executing this recursive
446:24 - Su function so let's run our program and
446:28 - as you can see some is equal to 9 and if
446:32 - I increase these M and N values so if I
446:35 - say for example please calculate some
446:37 - between 1 and 4 we should get 10 this
446:40 - time so 10 okay and then here if I add
446:44 - number five for example we should get
446:47 - value of 15 right so we get that the
446:50 - result is 15 and what you can do here
446:53 - now of course you can say please
446:54 - calculate some of the numbers between 1
446:57 - and 551 for example but this is going to
447:00 - be hard to check so if I run my program
447:03 - as you can see we get uh this very very
447:06 - big number okay one very important thing
447:10 - that you must have each time that you
447:12 - work with recursion is the following so
447:16 - every time that you work with recursion
447:18 - you must have this base case here which
447:22 - will stop the recursion from happening
447:24 - again and again and again so this base
447:27 - case here will stop invoking recursive
447:30 - some function at a certain point when a
447:33 - certain condition is reached and unless
447:36 - you have that base case which will stop
447:38 - the recursion you will have that
447:40 - function invoking itself infinitely so
447:43 - infinite number of times and you will
447:46 - get an error so in order to demonstrate
447:49 - that I will remove this base case here
447:52 - so let's comment it out and if I run my
447:56 - program
447:57 - now as you can see we get un stack
448:00 - Overflow error which means that as I
448:03 - already said this recursive sum function
448:06 - is invoking itself again and again and
448:09 - again infinite number of times and this
448:11 - recursion never stops and in order to
448:14 - stop it you need to have a base case
448:18 - which will stop the recursion so I'm
448:20 - going to close the program now and I
448:23 - will return this code here which is our
448:26 - base case and if I run my program again
448:30 - as you can see we get the expected
448:33 - result and the error has disappeared so
448:35 - that is something very important to
448:38 - remember each time that you use
448:39 - recursion you must have a base case to
448:42 - break that recursion from happening
448:44 - infinite number of times so I hope that
448:47 - you understood what is recursion and how
448:50 - it works and in order to practice on
448:52 - your own I will leave a task for you and
448:56 - the task is following so I want you to
448:59 - do the factorial of a number using
449:02 - recursion calculate factorial of a
449:04 - number using recursion and if you are
449:06 - not familiar with what factorial is or
449:09 - how it is calculated I will leave a
449:11 - video link here where I'm calculating
449:14 - factorial of a number using loops and
449:16 - then what I want you to do is to do that
449:19 - same task using recursive functions and
449:22 - you can paste your code in the comments
449:24 - down below so I hope that this video
449:27 - helped you understand what is recursion
449:30 - and how it works and if it did give it a
449:33 - thumbs up and subscribe to my channel
449:35 - and also you can follow me on my other
449:37 - social media if you want the links are
449:39 - in the description thank you very much
449:42 - for watching I'm going to see you in my
449:44 - next video
449:45 - bye hi everyone welcome to my channel my
449:48 - name is Salina and I make it and
449:51 - programming related videos so if that is
449:54 - something that is of interest to you
449:55 - consider subscribing to my channel and
449:57 - give this video a thumbs up as well now
450:00 - in this particular video I want to talk
450:02 - about objectoriented programming so what
450:05 - is objectoriented programming well oop
450:08 - or object-oriented programming allows
450:11 - you to represent real life objects in
450:14 - programming and those real life objects
450:17 - are going to be represented together
450:19 - with their attributes and then their
450:21 - behaviors as well one of the most
450:23 - important concepts of oop are classes
450:27 - and objects so let me explain difference
450:30 - what is a class and then what is an
450:32 - object a class is going to represent a
450:35 - template meaning a blueprint and then an
450:38 - object really represents an example of
450:41 - that class an instance of that class for
450:44 - example a class can be a fruit and then
450:48 - an object of that fruit class can be an
450:51 - apple a banana a peach or another
450:55 - example a class can be a car and then an
450:58 - object of that class can be a Volvo a
451:01 - Ford a BMW and so
451:04 - on and that car class for example has
451:08 - some attributes and then it has some
451:10 - behaviors as well now what are
451:12 - attributes of car class well a car has a
451:15 - name for example that's an example of a
451:17 - one attribute and then it has a price
451:20 - and Max Speed and color and so on and
451:25 - then behaviors of a car can be drive for
451:28 - example and then break a as well and
451:30 - then change color and so on so here we
451:35 - are going to create an example of a
451:38 - class and then we are going to create an
451:40 - object of that class so the class that I
451:43 - want to create is going to be called
451:45 - YouTube channel so in order to create a
451:48 - class you write class and then you give
451:52 - a name to your class so here I'm going
451:54 - to say YouTube
451:57 - channel like this and then you put these
452:00 - curly brackets and at the end you will
452:02 - have to put a semic column and now here
452:05 - you will put the members of this class
452:08 - now one thing that I haven't mentioned
452:10 - is that class is user defined data type
452:14 - we have already talked about data types
452:16 - in this course or in C++ for beginners
452:20 - course so if you haven't watched that
452:22 - make sure to do so I'm going to link it
452:24 - in the description and then here as well
452:28 - so we have talked about basic data types
452:31 - such as integer floating Point number
452:33 - and then Boolean character double string
452:37 - you know but a class is going to be a
452:40 - user defined data type which is going to
452:42 - allow you to represent a real life
452:44 - object in programming and in this
452:47 - particular situation I want to represent
452:49 - a YouTube channel so let's think of
452:51 - attributes of a YouTube channel what is
452:53 - something that describes a YouTube
452:55 - channel let's say for example that each
452:57 - YouTube channel has a name so so that is
453:00 - going to be a string variable let's say
453:03 - string name like this so these
453:06 - attributes are going to be represented
453:09 - with variables so one of the attributes
453:12 - is going to be name and then let's say
453:15 - another is going to be string owner
453:18 - owner
453:20 - name like this and then let's think of
453:24 - another attribute let's say that each
453:26 - YouTube channel has a subscribers count
453:30 - so in
453:33 - subscribers count like this and then
453:38 - let's as well create a list of published
453:41 - videos so I'm going to say list and
453:44 - let's call it published video
453:47 - titles so that is going to be type
453:49 - string and it is going to be called
453:56 - published like this now here it says
453:59 - that that this list cannot be used
454:01 - because we haven't included um it here
454:04 - so here I'm going to say include list
454:09 - and now this should be accessible okay
454:10 - now we don't have that error anymore and
454:14 - what I want to do here is I want to
454:15 - represent a YouTube channel that has
454:17 - four attributes it has a name then owner
454:21 - name you can use email here or whatever
454:24 - and then it has subscribers count and
454:27 - published video titles now here you can
454:29 - use another class here you can say for
454:31 - example list of videos you can create
454:35 - another class that is called video and
454:37 - then in that video class you can put all
454:40 - the attributes that describe a video so
454:42 - that can be for example a title and then
454:44 - a description number of likes number of
454:47 - comments number of views um the duration
454:51 - of that video the video itself you know
454:53 - but for the Simplicity of this
454:54 - particular exam example I'm going to use
454:57 - just the title of those videos so now
455:01 - after I have created this YouTube
455:03 - channel class what I can do is I can
455:05 - create an object of that class so let's
455:09 - say here that I'm going to create an
455:12 - object so how you do that you say the
455:14 - type so you put the name of your class
455:17 - which is YouTube channel and then you
455:20 - give a name to that variable let's call
455:22 - it YouTube channel like this okay now
455:27 - what I want to do is I want to assign
455:30 - values to these properties of my YouTube
455:33 - channel and how do I do that well you
455:35 - say YouTube channel and then you put dot
455:39 - and here is nothing available but it
455:42 - should be these properties should be
455:44 - available when you say YouTube channel
455:46 - dot now why these are not available it
455:49 - is because all the members of your class
455:52 - are by default private and that means
455:56 - that these members because they are
455:58 - private they are going to be accessible
456:00 - only within this class here and in order
456:03 - to make them public in order to make
456:05 - them accessible outside of this class
456:08 - you put Public Access modifier so you
456:10 - say here public okay like this now this
456:16 - public is an access modifier and it is
456:19 - going to make all of these members of
456:22 - your class accessible outside of your
456:25 - class which means that now if I press
456:28 - dot here as you you can see name owner
456:31 - name published video titles and then
456:33 - subscribers count is available for me
456:36 - now so I'm going to say that the name of
456:39 - my YouTube channel is going to be for
456:41 - example code Beauty like this and then
456:46 - owner name let's copy this a couple more
456:49 - times so owner name is going to be my
456:53 - name so
456:55 - Salina like this and then subscribers
456:58 - count
457:00 - well let's say this is an integer
457:03 - variable so we don't need the quotation
457:05 - marks let's say
457:09 - 1,800 uh people and then these published
457:13 - video titles so let's add value to my
457:16 - published video titles list so here I
457:18 - want to say that I have published for
457:23 - example um
457:24 - C++ for
457:27 - beginners oh
457:30 - let's say video one okay and then let's
457:35 - say HTML and
457:38 - CSS video
457:41 - one okay and let's add as well this
457:44 - video so let's say C++ o o video one
457:51 - okay now after I have assigned value to
457:54 - these properties what I can do is I can
457:56 - write out these properties so I can say
457:59 - here for example see out and then let's
458:03 - say
458:05 - name and let's write out the name of my
458:08 - YouTube channel like this and I'm going
458:11 - to add an end line and I'm going to copy
458:14 - this couple more times like this so here
458:17 - I want to write out owner name so let's
458:20 - put YouTube channel. owner name and then
458:24 - here I want to write out a subscribers
458:26 - count so YouTube channel do subscribers
458:29 - count and then published video titles
458:32 - now this property here published video
458:35 - titles is not a simple property meaning
458:38 - this property here is a list and in
458:40 - order to write out a list we are going
458:42 - to use a loop so I'm going to delete
458:45 - this and then here I want to create a
458:48 - loop and let's say that we will be using
458:50 - for each Loop so I'm going to say four
458:53 - like this and then here I'm going to
458:56 - write out the type of the value that I'm
458:59 - going to use in my list so I'm going to
459:01 - say
459:02 - string because this published video
459:05 - title is of type string and then here I
459:09 - want to give it a name so I'm going to
459:11 - say video
459:13 - title like this and then I'm going to
459:17 - specify the list that I want to iterate
459:19 - and that list is going to be this one
459:21 - here so it is going to be a list of
459:25 - published videos in my YouTube channel
459:28 - object okay
459:30 - and now in these curly brackets I am
459:32 - going to specify the block of code that
459:35 - is going to be executed in each
459:37 - iteration so what I want to do with this
459:40 - video title is I want to write it out so
459:42 - I'm going to say see out and then let's
459:45 - write out video title and I'm going to
459:49 - add an end line at the end as well and
459:51 - one more thing that I want to write out
459:53 - before this list is going to be just see
459:56 - out videos
459:59 - like this okay and let's add end line at
460:03 - the end so that it is formatted nicely
460:07 - so now if I run this program as you can
460:10 - see it has written out information about
460:13 - this object that we have created here it
460:15 - says that the name of YouTube channel is
460:17 - code Beauty and then owner name is
460:20 - salinaa subscribers count is equal to
460:23 - 1800 and then the this channel has
460:26 - published three videos so C++ for
460:28 - beginners and then HTML and CSS video
460:31 - one and then C++ objectoriented
460:34 - programming video one okay so uh I have
460:39 - created a class that is called YouTube
460:41 - channel I have uh created four
460:44 - attributes so four properties and made
460:47 - them public which means that these four
460:50 - properties are going to be accessible
460:52 - outside of this class and we have
460:55 - accessed those properties here so we
460:58 - have said uh that we want to assign
461:00 - value to our name property and then
461:02 - owner name sub subscribers count and
461:05 - then we have as well um assigned value
461:08 - to this published video titles list okay
461:12 - and then here we have written out
461:14 - information that is stored inside these
461:16 - properties so that was an example of how
461:19 - you can create a class and then how you
461:21 - can create an object of that class as
461:24 - well and in my next video we are going
461:27 - to be talking about Constructors and
461:30 - class methods because there is a more
461:32 - simple way to do this that we have done
461:35 - here so make sure to check that video
461:37 - out as well so I hope that you enjoyed
461:40 - this video if you did give it a thumbs
461:42 - up and also please subscribe to my
461:44 - channel and click that Bell icon and I'm
461:47 - going to see you in my next video
461:50 - bye hi everyone welcome to my channel my
461:53 - name is Salina and I make it and
461:56 - programming related videos on this
461:58 - channel so if that is something that is
462:00 - of interest to you consider subscribing
462:03 - and give this video a thumbs up as well
462:06 - and in this particular video I want to
462:07 - talk about Constructors and class
462:10 - methods so here I have some code that we
462:13 - have written in a previous tutorial of
462:15 - this course so if you haven't watched
462:17 - that make sure to check it out I'm going
462:20 - to link it here and in the description
462:22 - as well and let's explain very quickly
462:25 - this code that we have here so I have
462:27 - created a class called YouTube channel
462:30 - and that class has four public
462:33 - properties so four attribut attributes
462:35 - those are name owner name subscribers
462:38 - count and then a list of published video
462:42 - titles and then here I have created an
462:45 - object of that class I have assigned the
462:48 - value to the to these properties here
462:52 - okay and then here I have written out
462:54 - information about this object that we
462:57 - created and as I said said in this video
463:00 - I want to talk about Constructors and
463:02 - class methods and how am I going to
463:04 - explain these well let me first
463:06 - introduce a problem to this approach
463:09 - here so that you can really understand
463:11 - the need for these two so what happens
463:15 - if I want to create another object of
463:18 - this YouTube channel class how am I
463:20 - going to do that well in this current
463:22 - situation what I would do is I would
463:25 - copy this so I'm going to copy it and
463:29 - then I'm going to paste it here like
463:32 - this and let's give it a name let's say
463:35 - that this channel is going to be YouTube
463:37 - channel to and let's call it let's say
463:40 - YouTube channel 2. name let's say that
463:43 - it is going to be called Amy
463:47 - SS for example and um owner is going to
463:52 - be a girl called Amy and then she is
463:54 - going to have let's say 2,000
463:57 - subscribers okay and and then the videos
464:00 - that she has published are going to be
464:02 - songs obviously because she has a
464:05 - channel named Amy sings so let's say
464:08 - that she has published for example um
464:12 - let's say
464:14 - Johnny B cover like this so that's one
464:19 - song that's one video and then let's say
464:21 - that another video that she has
464:24 - published is going to be for example um
464:27 - Laura Li
464:30 - so that's a song from scorpions and she
464:32 - has made a cover of that song like this
464:35 - now these two are two of my favorite
464:37 - songs and you can put whatever you want
464:40 - here in this list and I'm also wondering
464:43 - and you can write that in a comments
464:45 - down below what are your favorite songs
464:47 - so please write that in the comments
464:49 - just don't put links because I think
464:51 - that YouTube has this policy of treating
464:53 - um links as U advertising or spam or
464:56 - something so just write out the name
464:59 - name of your song and then uh the name
465:01 - of a singer I guess and I'm really
465:03 - looking forward to reading your comments
465:06 - so now that I have created this second
465:09 - YouTube channel what I want to do is I
465:11 - want to write out information about this
465:14 - channel but I noticed that I'm missing
465:16 - here uh this YouTube channel to so here
465:18 - I'm going to say YouTube channel 2.
465:20 - ownername and then YouTube channel 2.
465:23 - subscribers count and then YouTube
465:25 - channel to. published video titles as
465:28 - well okay now if I wanted to write out
465:31 - information about this second Channel
465:33 - what I would do is I would copy this so
465:36 - I'm going to copy it and then paste it
465:39 - here and here I will say that the name
465:42 - is Youtube channel 2. name and then
465:44 - owner name is YouTube channel 2.
465:47 - ownername and then here as well and then
465:50 - YouTube channel 2. published video
465:53 - titles okay now if I run this
465:57 - program we should get information about
465:59 - these two channels so the first channel
466:02 - is this one that we already had it's
466:05 - code Beauty owner is me and then this is
466:08 - subscribers counter and then these are
466:10 - three videos that I published so far I
466:12 - mean I published more than three videos
466:15 - uh but this is just an example and then
466:18 - here is our second channel it's called
466:21 - Amy sings and then owner is Amy she has
466:24 - 2,000 subscribers and then she has
466:26 - published two covers
466:29 - now this here has a problem if we wanted
466:33 - to create a third a fourth a fifth
466:35 - object we would have to copy this code
466:39 - and then each time that we want to write
466:40 - out information about those channels we
466:42 - would have to copy this code and this
466:45 - really collides with a principle called
466:48 - don't repeat yourself meaning do not
466:50 - repeat your code if you don't really
466:52 - have to repeat it and in this particular
466:54 - situation we do not have to repeat it so
466:57 - how we are going to solve this problem
466:59 - well the first thing that I want to talk
467:01 - about are going to be Constructors and
467:03 - what a Constructor is it is a special
467:06 - method that is going to be invoked each
467:08 - time that you create an object of a
467:10 - specific class meaning that method is
467:13 - going to be called on the construction
467:15 - of that object so there are two rules
467:19 - when it comes to Constructors and the
467:22 - first rule is that Constructor has the
467:25 - same name as your class and then the
467:28 - second rule is that Constructor does not
467:31 - have a return type so let's create a
467:34 - Constructor for this YouTube channel
467:36 - class here I'm going to say YouTube
467:40 - channel like this and then I'm going to
467:42 - put these parentheses and I'm going to
467:45 - put these curly brackets as well now
467:48 - what I want to do in this Constructor is
467:50 - I want to receive two parameters I want
467:53 - to receive two arguments and those are
467:55 - going to be string name and then string
467:59 - string um let's let's say owner
468:03 - name okay now these are two parameters
468:08 - that I want to pass to my Constructor
468:10 - and what I'm going to do with these in
468:12 - my Constructor is I'm going to assign
468:14 - these to these properties here so I'm
468:16 - going to say that name is going to be
468:19 - equal to whatever my user has passed to
468:22 - this Constructor so name is equal to
468:24 - this name here and then owner name
468:30 - in my class is going to be equal to this
468:33 - owner name that I have received in my
468:35 - Constructor now since since this
468:37 - Constructor here is invoked each time
468:40 - that I create object each time that it
468:42 - is constructed that means that at the
468:45 - beginning when a channel is created it
468:48 - has zero subscribers so I'm going to put
468:50 - here zero like this we do not even have
468:53 - to pass this value in our Constructor
468:55 - because when you create your YouTube
468:57 - channel you do not have subscribers okay
469:00 - now what am I going to do here is I do
469:03 - not need to write this code like this
469:05 - anymore so I'm going to delete I'm going
469:08 - to actually comment this code here and
469:11 - as you can see this is underlined it
469:13 - says that no default Constructor exists
469:15 - for class YouTube channel now what we
469:18 - have to do is we have to use this
469:20 - Constructor here that I have just
469:22 - created and how you do that well you put
469:27 - parentheses here and then inside these
469:29 - parentheses we are going to pass these
469:32 - two parameters so the first parameter is
469:35 - going to be the name so that is the name
469:38 - of our Channel and that is this name
469:40 - here so code Beauty like this and then a
469:44 - second parameter as you can see here is
469:47 - owner name and that was this value here
469:51 - so I'm going to pass that here like this
469:54 - and now after I have created this
469:57 - YouTube channel we do not need this code
470:00 - um anymore so I'm going to delete it
470:03 - okay and what we can do is we can do the
470:07 - same with this second channel so with
470:09 - this YouTube channel too so I'm going to
470:11 - really comment this code for a moment
470:14 - and then here I want to invoke a
470:16 - Constructor for this YouTube channel
470:19 - class and pass it as first value the
470:23 - name because we are receiving name as
470:24 - our first value in our Constructor like
470:27 - this and then then the second value that
470:29 - we need to pass is going to be owner
470:32 - name so I'm going to copy that as well
470:35 - and now we have successfully created
470:38 - this second YouTube channel okay so now
470:42 - I can delete this code here as
470:45 - well okay and now if I run my
470:49 - program as you can see it has written
470:51 - out information about my two channels
470:53 - the first one is code Beauty owner is me
470:56 - and then I have zero subscribers because
470:59 - I have just created my channel and we
471:00 - have assigned that here and then our
471:03 - second channel is Amy sings uh owner is
471:07 - Amy and she has zero subscribers as well
471:09 - and as you can see both of these videos
471:11 - published videos lists are empty because
471:14 - we haven't uh really added any videos
471:18 - okay so how do you do that I'm going to
471:21 - delete this from here and then move it
471:24 - here like this so now we have both of
471:26 - our objects being created at the
471:28 - beginning here so what I want to do now
471:31 - is I want to add a couple of videos to
471:34 - this channel here so how do you do that
471:36 - well you say YouTube
471:39 - channel like this and then I'm going to
471:41 - put dot and here in this published video
471:44 - titles list I'm going to invoke a method
471:48 - push back which is going to add at the
471:51 - end of this list another element and
471:55 - that element is going to be of type
471:56 - string because this publish video titles
471:59 - is a list of strings so here I'm going
472:02 - to add a string and I'm going to call
472:05 - that video
472:08 - C++ for
472:11 - beginners like this so that is one video
472:14 - and then let's add a couple more videos
472:16 - let's say uh HTML and CSS for
472:21 - beginners and then let's say um o op for
472:25 - beginners Well no let's say C+ plus o o
472:30 - like this okay so we have added three
472:34 - videos for this first channel and then
472:36 - this second channel does not have videos
472:39 - yet so if I run my program again you can
472:42 - see that this first channel has three
472:45 - videos and then this check this second
472:48 - channel does not have any videos yet
472:50 - because we have deleted those that we
472:52 - previously had okay now that was the
472:56 - example on how you can create a constru
472:58 - structor and how you can use a
472:59 - Constructor so this here is the
473:02 - Constructor of this YouTube channel
473:04 - class and we have passed two parameters
473:07 - two arguments to this Constructor and
473:09 - then here in our Constructor we have
473:12 - really assigned initial values to these
473:16 - properties here that we have in our
473:18 - YouTube channel and then this here is
473:21 - the way that you use your Constructor so
473:24 - you put these parentheses and then you
473:26 - pass the values that your Constructor
473:28 - has to receive and here we have created
473:31 - two objects and we have done that
473:34 - without repeating code now what is going
473:37 - to happen with this here so this here
473:41 - and then this here is repeating code as
473:43 - well and in order to solve this
473:45 - particular Pro problem we are going to
473:48 - use class methods so class method is
473:51 - going to describe a behavior of a class
473:55 - and since here we are writing out uh the
473:58 - these attributes of our class since we
474:00 - are writing out information about our
474:02 - YouTube channels what I want to do is I
474:05 - want to create a method that is going to
474:07 - be called get info for example so that
474:11 - method is going to be of type
474:12 - void let's call it get info like
474:17 - this and what I want to do in this
474:20 - particular method is I want to copy this
474:22 - code here so I'm going to cut it and
474:25 - then paste it here and in this
474:28 - particular method in this get info I
474:31 - want to say please write out name and
474:33 - then the name property we don't need
474:37 - this YouTube channel object anymore
474:39 - because we are in the class itself okay
474:42 - and then here as well I'm going to
474:44 - delete this here and then here and now
474:49 - this code should work so whenever you
474:52 - invoke this get info method on your
474:54 - object it should write out all of these
474:57 - properties of of that object so now I
475:00 - can remove this code here as well so
475:04 - this um information about our second
475:07 - Channel and how am I going to get how am
475:10 - I going to invoke this method well I say
475:13 - the name of my object so for example
475:15 - YouTube channel Dot and then as you can
475:18 - see I have this get info method
475:21 - available here because it is public so I
475:24 - say get info and I invoke it like I
475:27 - would invoke any other function and
475:29 - let's do the same for our second YouTube
475:31 - channel let's say YouTube
475:33 - channel to get info like this and now if
475:39 - I run my
475:41 - program as you can see it has written
475:43 - out information about my two channels so
475:46 - code Beauty Sal owner and then
475:49 - subscribers count my videos and then
475:52 - info about my second Channel as well so
475:55 - I hope that you understood the concept
475:57 - behind behind a Constructor of a class
476:01 - and then behind a class method here we
476:04 - have demonstrated how you can create an
476:06 - object using a Constructor and then here
476:09 - as well so you don't really have to
476:11 - repeat your code each time that you
476:13 - create an object and then here we have
476:16 - invoked a method of these objects which
476:19 - we have implemented here so you do not
476:22 - have to repeat that code as well each
476:25 - time that you need to get information
476:26 - about your object you just invoke this
476:29 - get info method and now our main
476:32 - function looks much cleaner and all the
476:35 - implementations of the construction of
476:37 - our objects and then this get info
476:40 - method are in this YouTube channel class
476:43 - so I hope that you enjoyed this video if
476:45 - you did give it a thumbs up and also
476:48 - subscribe to my channel don't forget to
476:50 - hit that Bell icon and I'm going to see
476:53 - you in my next video
476:56 - bye hi everyone my name is Salina and I
476:59 - make it and programming related videos
477:02 - so if that is something that is of
477:04 - interest to you consider subscribing to
477:06 - my channel and give this video a thumbs
477:08 - up as well and in this particular video
477:11 - I want to talk about
477:13 - encapsulation here I have code that we
477:15 - have written in the previous videos of
477:17 - this course so if you haven't watched
477:19 - those make sure to check them out I'm
477:22 - going to link them in the description of
477:24 - this video and I'm going to go over this
477:27 - code very quickly so that you can
477:29 - understand what we have written here so
477:31 - here I have created this YouTube channel
477:33 - class which has four public attributes
477:37 - and those are name owner name
477:39 - subscribers count and then list of
477:41 - published video titles and then here we
477:44 - have a YouTube channel Constructor and
477:47 - then this get info method as well that
477:50 - just writes out information about our
477:53 - YouTube channel and here's the code of
477:55 - our Constructor okay and then in our
477:59 - main function we have created an object
478:02 - of this YouTube channel class and we
478:05 - have assigned it these two values for
478:08 - our name and our owner name and then we
478:11 - have as well added three videos to this
478:14 - published videos list and here we have
478:17 - written out information about our
478:19 - channel so if I run this code now as you
478:22 - can see this is how it behaves it writes
478:25 - out information about our YouTube
478:26 - channel now now what I want to talk
478:29 - about in this video is encapsulation and
478:32 - what does this principle of
478:34 - encapsulation says well encapsulation
478:37 - says that these properties here should
478:40 - not be public these should be private
478:43 - and then the way to change the value the
478:46 - data that you store inside these
478:48 - properties should be really using
478:50 - methods that you Expose and then you
478:52 - give access to those methods to your
478:55 - user and then using those methods
478:57 - obeying the rules of those methods your
479:00 - user can change the value of these
479:02 - properties okay so let me introduce a
479:05 - problem here so that you can really
479:08 - understand why we need en encapsulation
479:11 - so what happens if I say for example
479:14 - that YouTube channel so this that we
479:16 - have created has let's say a million
479:22 - subscribers okay this is a million now
479:25 - we have assigned a million subscribers
479:27 - to this YouTube Channel and this should
479:29 - not be allowed if I run this program you
479:33 - can see that this YouTube channel has a
479:36 - million subscribers now but this is not
479:38 - the natural way to gain subscribers for
479:41 - your YouTube channel what you should do
479:43 - instead is you should give your user the
479:46 - ability to invoke subscribe and
479:48 - unsubscribe methods and then using those
479:50 - methods you are going to increase or
479:52 - decrease this subscribers counter so
479:56 - let's do that let's first hide these
479:59 - properties from our user so from whoever
480:01 - is going to use this class here so how
480:04 - do you hide these well you make them
480:07 - private so here instead of using public
480:10 - access modifier I'm going to use private
480:13 - access modifier so I'm going to say
480:15 - private oh
480:17 - private like this and then these should
480:21 - stay public so I'm going to put public
480:26 - here like this
480:29 - okay and then as you can see we have a
480:33 - problem here it says that this
480:34 - subscribers count is inaccessible and
480:37 - then this publ this published video
480:40 - titles as well is inaccessible meaning
480:43 - that we cannot access these private
480:45 - members of our class these private
480:48 - members can be accessed only within this
480:51 - class itself so how we are going to give
480:53 - our user the ability to change this
480:56 - subscribers counter well as I said we
480:58 - are going to create methods so let's
481:00 - create two methods the first one is
481:02 - going to be
481:04 - void void
481:07 - subscribe like this and then what this
481:11 - method should do it should increase this
481:14 - subscribers counter so here I'm going to
481:16 - say subscribers
481:18 - counter like this plus plus using this
481:22 - increment operator we are going to
481:24 - increase the value that we store in this
481:26 - variable by one and then we are going to
481:29 - have as well unsubscribed method so I'm
481:31 - going to copy
481:32 - this paste it here and let's say
481:37 - unsubscribe and then here I'm going to
481:40 - say that this subscribers count is going
481:43 - to be decremented so now if I I will
481:47 - have to comment this code here and then
481:50 - I'm going to delete this code here and
481:53 - now if I want to increase or decrease
481:56 - subscribers for my Channel what I will
481:58 - have to do is I will have to invoke one
482:01 - of these two methods so let's say for
482:02 - example YouTube channel do subscribe
482:06 - like this
482:08 - okay and let's invoke this method um
482:12 - three times for example and now if I run
482:15 - this
482:17 - program as you can see my channel so
482:21 - code Beauty channel has three
482:23 - subscribers and then let's say for
482:25 - example that I haven't published videos
482:27 - in a while so people decide to
482:29 - unsubscribe so I'm going to invoke this
482:32 - unsubscribe
482:33 - method like this and if I invoke this
482:37 - get info after that I should have two
482:40 - subscribers well oh as you can see I
482:43 - have two subscribers now because three
482:45 - people have subscribed and then one
482:47 - person has unsubscribed from my channel
482:50 - okay so we have this code here as well
482:55 - that was underlined meaning that it has
482:58 - um compile time error and it says member
483:02 - published video titles is inaccessible
483:05 - meaning that now we cannot access this
483:08 - published video titles list anymore
483:10 - because it is private now so I'm going
483:14 - to expose a method that is going to
483:17 - publish videos for me so here I want to
483:19 - create a method of type void which is
483:23 - going to be called publish
483:25 - video publish
483:29 - video like this and then here I want to
483:34 - add a video to my published video titles
483:38 - like this so I'm going to say published
483:40 - video titles push back and then what I
483:44 - want to do is I want to pass a value
483:46 - here which value well we are going to
483:48 - receive that value as a parameter in our
483:50 - function so here I'm going to add an
483:53 - argument a parameter and that is going
483:55 - to be of type string and let's call it
483:59 - title like this and now we are going to
484:02 - use this title here so we are going to
484:05 - push this title in our push in our
484:08 - published videos
484:10 - titles okay like this now if I want to
484:14 - invoke this method I'm going to invoke
484:17 - it like this so I'm going to say YouTube
484:20 - channel dot publish video like this and
484:24 - then I'm going to do the same thing here
484:27 - and then
484:28 - here and here as well okay so now we
484:33 - have created these methods that we
484:36 - invoke and then using these methods we
484:39 - change these properties and these
484:41 - properties should be private meaning
484:43 - these should be
484:45 - encapsulated
484:47 - okay and now as you can see we have a
484:50 - channel called code Beauty and then
484:52 - owner is myself and subscribers is two
484:57 - and then these are videos that I have
484:59 - published so far now if you look at this
485:02 - unsubscribe method you will notice that
485:05 - it has a bug what is that bug well let's
485:09 - delete these three lines of code let's
485:11 - delete these subscribe method
485:13 - invocations and if I run my program now
485:16 - what is going to happen as you can see
485:19 - it says that my subscribers count is
485:22 - equal to minus one and that does not
485:24 - really make sense so you cannot have
485:26 - minus one subscriber and we are going to
485:29 - fix that problem if we put here inside
485:33 - this unsubscribed method a check so we
485:35 - want to check if our
485:38 - subscribers count is greater than zero
485:41 - and only in that situation if that
485:43 - subscribers count is greater than Z zero
485:46 - only then we can decrease this
485:49 - subscribers count value so if I run my
485:52 - program
485:54 - now as you can see we have invoked this
485:57 - unsub subscribe method but we still have
485:59 - zero subscribers and now we have fixed
486:02 - that bug that we had because if no one
486:05 - has subscribe to our Channel then no one
486:07 - can unsubscribe from it okay so that was
486:10 - a bug that I wanted to fix and then what
486:13 - you can do here because here we have
486:15 - exposed these three methods that really
486:18 - manipulate the values that are stored
486:20 - inside these properties and then these
486:23 - two properties there is no way to change
486:25 - them outside of this class so what you
486:27 - can do for dam for example is you can
486:30 - create a getter and a Setter meaning a
486:33 - method that that is called for example
486:36 - get name and that method is going to
486:38 - return you the value that is stored
486:40 - inside this name variable and then a set
486:44 - method meaning set name method that is
486:46 - going to receive um parameter which is
486:49 - going to be called name for example and
486:52 - inside that set name method you are just
486:55 - going to change the value that is stored
486:57 - inside this name property and then you
487:00 - can do the same for this owner name uh
487:02 - as well so you can create a get and a
487:05 - set method so let's go over this
487:07 - encapsulation rule one more time so
487:10 - encapsulation rule says that all of
487:13 - these properties should be private
487:15 - meaning they shouldn't be accessible
487:18 - outside of this class and you do that by
487:22 - making them private so you put this
487:25 - private access modifier here
487:28 - and then how do you change the values
487:30 - that you store inside your properties
487:32 - well you expose a public methods that
487:36 - are going to change the data that you
487:38 - are storing inside your properties and
487:42 - here we have created these three public
487:45 - methods that are going to change the
487:47 - data stored inside our subscribers count
487:50 - uh property and then inside our
487:52 - published video list property here so
487:55 - you can for these two properties again
487:57 - you can create getter and Setter method
488:00 - and if some of you do that please put
488:02 - that code in the comment section and I'm
488:04 - going to review it so if you enjoyed
488:07 - this video give it a thumbs up and don't
488:10 - forget to subscribe to my channel and
488:11 - hit that Bell icon as well and I'm going
488:14 - to see you in my next video bye hi
488:18 - everyone my name is Salina and I make it
488:21 - and programming related videos on my
488:23 - channel so if that is something that is
488:26 - of interest to you consider subscribing
488:28 - and give this video a thumbs up as well
488:31 - and in this particular video I want to
488:33 - talk about inheritance so here I have my
488:36 - visual studio and here I have some code
488:39 - that we have written in the previous
488:41 - tutorials of this course so if you
488:44 - haven't watched those make sure to watch
488:46 - them and now I'm going to go very
488:49 - quickly over the code that we have here
488:52 - so I have created a class that is called
488:54 - YouTube channel and that class has four
488:59 - private properties name owner name
489:02 - subscribers count and then published
489:04 - video titles and then we have a couple
489:06 - of public methods as well we have a
489:10 - Constructor which just assigns
489:12 - initializes these variables here and
489:16 - then we have get info method that just
489:19 - writes out information values that are
489:21 - stored inside these properties here and
489:25 - then as well we have subscribed and
489:27 - unsubscribe methods our subscribe method
489:30 - increases our subscribers counter and
489:33 - then our unsubscribe method decreases
489:36 - that subscribers counter but first we
489:38 - have to check if that subscribers count
489:40 - is greater than zero so those would be
489:43 - subscribe and unsubscribe methods and
489:45 - then we have this publish video method
489:48 - as well that just adds a new item adds a
489:52 - new title to this published videos
489:55 - list okay now what is going to happen if
489:59 - I want to create another type of YouTube
490:02 - channel a specific type of YouTube
490:04 - channel which is going to be for example
490:07 - um cooking YouTube channel so I should
490:10 - copy these properties right well that
490:14 - can be one approach but the quicker and
490:17 - better approach is going to be to
490:19 - inherit this YouTube channel class so
490:22 - let's do that let's create another type
490:25 - of channel so let's create another class
490:28 - let's say class and then let's call it
490:33 - cooking
490:36 - YouTube
490:38 - channel like this okay now I have
490:42 - created a class that is called cooking
490:45 - YouTube channel and in order to inherit
490:48 - this YouTube channel class what I'm
490:51 - going to do is I'm going to put this
490:53 - column sign and then I'm going to say
490:55 - public you YouTube channel like this and
491:00 - in this way my cooking YouTube channel
491:02 - is going to inherit my YouTube channel
491:06 - and that means that my cooking YouTube
491:09 - channel is going to have everything that
491:12 - my YouTube channel has now this public
491:15 - access modifier means that whatever is
491:18 - public in this class here it is going to
491:21 - be public here as well so in this
491:24 - derived class and one very important
491:26 - thing is is to know that this class is
491:29 - called Base Class so the one that you
491:32 - inherit from that is base class and then
491:36 - the derived class is going to be this
491:38 - one here so the one that inherits from
491:41 - the base class is called derived class
491:44 - and in this particular situation our
491:46 - cooking YouTube channel is derived class
491:49 - now what is going to happen if I want to
491:52 - create for example an object of this
491:55 - cooking YouTube channel so I'm going to
491:57 - say cooking YouTube channel and let's
491:59 - call it YouTube channel like this okay
492:04 - now as you can see it says that default
492:07 - Constructor of cooking YouTube channel
492:09 - cannot be referenced now that is because
492:12 - we do not have a Constructor for this
492:14 - class here so let's create one let's
492:17 - create a Constructor so I'm going to
492:20 - copy this name and then add these
492:24 - parentheses okay and now if I hover over
492:29 - this it says that the Constructor is
492:31 - inaccessible so we still have an error
492:34 - but we have a different error which
492:36 - means that we are making progress so
492:39 - because this Constructor is inaccessible
492:41 - I will have to make it public to make it
492:44 - accessible outside of this class here so
492:47 - I'm going to say
492:49 - public okay and now my uh Constructor is
492:53 - going to be accessible but there is
492:56 - another thing that we have to do and
492:58 - that is going to be inside this
493:00 - Constructor we have to receive
493:02 - properties that we are going to
493:04 - initialize in our Constructor and those
493:06 - are going to be these two properties
493:09 - name and owner name so here I'm going to
493:11 - say that my Constructor receives two
493:13 - properties so
493:16 - string
493:18 - name and then string owner
493:22 - name so the owner of that channel and
493:26 - what I'm going to do when I receive
493:28 - these two properties I'm not going to
493:30 - initialize them here in my Constructor
493:32 - because I'm inheriting from a class that
493:35 - already knows how to construct how to
493:39 - initialize these two particular
493:41 - properties so I'm going to call the
493:43 - Constructor of that class so I'm going
493:45 - to call the Constructor of this YouTube
493:48 - channel class so here I'm going to put
493:50 - this column sign and then I'm going to
493:54 - invoke its Constructor so I'm going to
493:56 - say YouTube channel
493:57 - and then I will pass these two
493:59 - parameters here so I'm going to say name
494:02 - and then owner name like this and now
494:09 - our Base Class our YouTube channel class
494:11 - is going to construct to initialize
494:14 - actually the value of these two
494:16 - properties and as you can see here we
494:18 - have an error that asks us to pass these
494:23 - two values to our Constructor so we are
494:26 - going to pass two parameters the first
494:29 - one is going to be the name of our
494:30 - channel so let's say that that is going
494:32 - to be for example Amy's
494:35 - kitchen like this and then owner is
494:39 - going to be um girl named Amy let's put
494:45 - that here as well okay now after I have
494:47 - created an object of this cooking
494:50 - YouTube channel what I should be able to
494:52 - do is I should be able to access all of
494:56 - these public
494:57 - methods that my base class has so all of
495:01 - these methods from my YouTube channel
495:04 - class should be available for my uh
495:06 - cooking YouTube channel so here I'm
495:08 - going to say YouTube
495:11 - channel Dot and then as you can see
495:14 - these are available so get info publish
495:16 - video subscribe unsubscribe let's write
495:19 - out info about my channel like
495:22 - this and if I run it
495:25 - now well you you can see that we have
495:29 - Amy's Amy's kitchen Channel owner is Amy
495:32 - it has zero subscribers and it has no
495:34 - videos as well so let's publish a couple
495:37 - of videos for Amy Amy's kitchen channel
495:41 - so here I'm going to say okay before I
495:44 - this get info function I'm going to say
495:46 - YouTube channel Dot and then let's say
495:49 - publish video of for example
495:53 - apple
495:55 - pie like this this and then let's
495:58 - publish another video let's say for
496:00 - example chocolate
496:04 - cake like this and uh now if I run this
496:10 - program as you can see we have oh we
496:14 - have two videos and let's as well say
496:18 - that people like these videos so they
496:21 - decide to subscribe to Amy's kitchen
496:23 - channel so I'm going to say YouTube
496:25 - channel do subscribe so uh for example
496:30 - two people decide to subscribe to her
496:32 - Channel and if I run my program again
496:36 - you can see that now we have two
496:39 - subscribers as well so we have been able
496:43 - to invoke all of these methods that are
496:46 - implemented in our Base Class so here
496:50 - from the object of our derived class so
496:54 - from the object of this derived class
496:56 - class here now this derived class this
496:59 - cooking YouTube channel can have its own
497:02 - members meaning things that are specific
497:05 - for this class only so let's say for
497:07 - example that we want to create a method
497:10 - that is going to be called uh for
497:12 - example practice so I'm going to say
497:14 - void
497:17 - practice like this and then what this
497:20 - method should do it should just make our
497:23 - user that has this cooking YouTube
497:25 - channel it should say that this user is
497:29 - practicing cooking and then learning new
497:31 - recipes and things like that so I'm
497:34 - going to say see out like this and that
497:37 - let me copy this part of the code
497:39 - because I don't want to make a typo like
497:42 - this so it says that uh our YouTube
497:47 - Channel's user is practicing cooking
497:49 - learning new recipes and then
497:51 - experimenting with spices cuz I guess
497:53 - that's something that you should do if
497:55 - you have a cooking YouTube channel
497:56 - Channel and let me add endline here as
498:00 - well like this so now if I decide to
498:04 - invoke this method this method is going
498:06 - to be available only for objects of this
498:10 - cooking YouTube channel so I'm going to
498:12 - say YouTube channel like this and then
498:15 - let's say
498:17 - practice like this now um let me very
498:21 - quickly change the name of this YouTube
498:23 - channel object because I want to create
498:25 - another object that is going to be of uh
498:28 - this YouTube channnel type and I want to
498:29 - call that YouTube channel so here I'm
498:31 - going to say um
498:33 - cooking YouTube channel and I'm going to
498:37 - paste that name here and then here and
498:40 - here here as well okay now we have named
498:45 - this object cooking YouTube channel and
498:48 - if I run this program you can see that
498:51 - at the end it says practicing cooking
498:53 - learning new recipes experimenting with
498:56 - spices is now as I already said this
498:59 - practice method should be available only
499:01 - for the objects of this cooking YouTube
499:04 - channel class so that means if I decide
499:07 - to create an object of this class here
499:10 - this Base Class that class is not going
499:13 - to have this practice method and let's
499:15 - prove that very quickly so here I'm
499:17 - going to create an object of YouTube
499:18 - channel Class Type and let's call that
499:22 - object YouTube
499:24 - channel that's why I changed the name
499:26 - name of this object like this and let's
499:30 - say that that is going to be my channel
499:33 - for example um code Beauty like this and
499:39 - then let's say that owner is my name
499:43 - Salina so now if I try to
499:46 - access this practice method on my
499:49 - YouTube channel so I press dot you can
499:52 - see that that method is not available
499:55 - for this Base Class it is available only
499:58 - for this cooking YouTube channel class
500:02 - because this practice is very specific
500:05 - method meaning um this code Beauty
500:08 - Channel which is oriented to programming
500:10 - and it does not really benefit from
500:13 - learning uh recipes and experimenting
500:15 - with spices practicing cooking and
500:17 - things like that so this channel should
500:20 - probably have some other way of
500:23 - practicing uh because it is different
500:26 - type of channel so I'm going to delete
500:29 - this code
500:31 - here okay and let's repeat this one more
500:35 - time so we have created a derived class
500:38 - which is called cooking YouTube channel
500:41 - and we have inherited everything that
500:43 - our YouTube channel class has by saying
500:47 - public and then the name of our Base
500:50 - Class and this public access modifier is
500:53 - going to allow us to have whatever is
500:55 - public here to have that public here as
500:59 - well and then we have created a
501:01 - Constructor for our cooking YouTube
501:03 - channel and in that Constructor we
501:05 - receive two parameters name and owner
501:08 - name and since our Base Class
501:11 - Constructor knows how to initialize
501:13 - those two we have here invoked this Base
501:17 - Class
501:18 - Constructor and then here we have
501:20 - created as well a method that is called
501:23 - practice and that method just says that
501:26 - our user is practicing cooking and he is
501:29 - learning new recipes and experimenting
501:31 - with spices now there's one more thing
501:34 - that I want to show you and that is
501:35 - going to be to Let's create another
501:39 - object of this cooking YouTube channel
501:42 - and that is going to be uh let's say
501:44 - cooking YouTube channel to and let's
501:47 - call it um John's
501:51 - kitchen like this and owner is going to
501:54 - be for example John now what is going to
501:58 - happen if I say for example that this
502:01 - second YouTube channel so this cooking
502:03 - YouTube channel to John's YouTube
502:05 - channel is practicing I'm going to um
502:09 - comment these two because I don't need
502:11 - them and if I run my program now you can
502:15 - see that it says two times practicing
502:18 - cooking learning new recipes
502:19 - experimenting with spices and then the
502:21 - same line here so you cannot really
502:24 - differentiate between which which one is
502:27 - Amy's Channel and which one is John's
502:29 - channel so in order to make that a bit
502:33 - more understandable I'm going to add a
502:35 - property here so here I want to add the
502:38 - name of the owner of this channel so
502:40 - here I'm going to say let me copy this
502:43 - property like this so owner name and
502:47 - then let's say that that owner is
502:51 - practicing cooking learning new recipes
502:53 - experimenting with spices and so on but
502:56 - as you can see this this property here
502:58 - is not accessible it says that member
503:02 - owner name is inaccessible and why is
503:05 - that the case why is it inaccessible
503:07 - because it is private and if you
503:10 - remember private members can be accessed
503:13 - only within that class and then public
503:16 - members can be accessed from outside of
503:19 - that class but what happens if you want
503:22 - to have for example a certain property
503:25 - to be accessible in in the derived class
503:27 - now there is an access modifier for that
503:31 - as well so that is going to be protected
503:34 - access modifier so I'm going to say here
503:38 - protected like this and then I'm going
503:41 - to move this owner name to my protected
503:45 - area like this so now this owner name
503:49 - property should be accessible in derived
503:52 - classes as well and as you can see the
503:54 - error has disappeared
503:56 - so now if I run my
503:59 - program you can see that it says that
504:02 - Amy is practicing cooking learning new
504:05 - recipes and experimenting with spices
504:08 - and then this second line here says that
504:11 - John is practicing cooking and learning
504:15 - new recipes and experimenting with
504:16 - spices so now we have made a difference
504:19 - we have specify the name of our owner of
504:23 - the channel and we can understand what
504:25 - the code is doing um a bit more I hope
504:30 - that you understood what is inheritance
504:32 - and how it works in C++ and if you did
504:35 - please like this video don't forget to
504:37 - subscribe to my channel and click that
504:38 - Bell icon as well and I'm going to see
504:41 - you in my next video
504:43 - bye hi everyone welcome to my channel my
504:47 - name is Salina and I make it and
504:50 - programming related videos so if that is
504:52 - something that is of interest to you
504:54 - consider subscribing to my channel and
504:56 - give this video a thumbs up as well and
504:59 - in this particular video I want to talk
505:01 - about polymorphism now the first thing
505:04 - that I want to do is I want to explain
505:06 - what is polymorphism polymorphism
505:09 - describes the ability of an object for
505:12 - example to have multiple forms now that
505:15 - means that you can have two or more
505:19 - objects that inherit from the same Base
505:22 - Class those objects can have the method
505:25 - that has the same name but different
505:27 - implementation meaning different
505:30 - behavior and I'm going to demonstrate
505:32 - that on an example now here I have some
505:35 - code that we have written in my previous
505:38 - courses so if you haven't watched those
505:40 - make sure to do so the links to those
505:43 - videos are going to be in the
505:44 - description and I'm very quickly going
505:47 - to go over this code so here I have
505:50 - created a class that is called YouTube
505:53 - channel that class has three private
505:56 - prop properties name subscribers count
505:58 - and then published video titles and then
506:02 - it has one protected property which is
506:05 - owner name now um this private
506:08 - properties these are available only in
506:11 - this class and then these protected
506:13 - properties these are available in
506:15 - derived classes as well and then here we
506:18 - have public methods as well and this
506:22 - here is our Constructor so it just
506:25 - initializes values of um these
506:28 - properties I'm going to collapse death
506:32 - and then here we have get info method
506:35 - with which just writes out information
506:37 - about our YouTube channel and then these
506:41 - subscribe and unsubscribe methods these
506:45 - just increase or decrease the the number
506:48 - of our
506:50 - subscribers let's collapse that and then
506:52 - publish video method it just um adds
506:57 - another video to this published video
506:59 - titles list so that would be our YouTube
507:03 - channel base class and then here we have
507:06 - cooking YouTube channel which is a
507:08 - specific type of YouTube channel that
507:11 - inherits from this Base Class here and
507:15 - that cooking YouTube channel has its own
507:17 - Constructor which is this one here and
507:19 - here we have just invoked the
507:22 - Constructor of our base class and then
507:25 - here we have implemented a method which
507:27 - is called practice and it says that when
507:31 - you practice and you have a cooking
507:33 - YouTube channel you will have to be
507:35 - practicing uh cooking and then learning
507:37 - new recipes and experimenting with
507:39 - spices now what I want to do is I want
507:42 - to create another derived class so I'm
507:46 - going to copy
507:48 - this
507:50 - okay and then this derived class should
507:53 - be called for example what let's paste
507:56 - the name here so singer YouTube channel
508:00 - and I'm going to paste the name uh here
508:02 - as well on my Constructor so this is
508:06 - going to be a YouTube channel about
508:08 - singing now as you can see this singer's
508:11 - YouTube channel has this practice method
508:14 - as well but this implementation is not
508:17 - right for my singer YouTube channel
508:19 - because if you're a singer you are not
508:21 - going to benefit really from practicing
508:24 - cooking and then from learning re PES
508:26 - and experimenting with spices but what
508:29 - you should do instead is you should
508:31 - practice something else so I'm going to
508:34 - copy that so that I don't make a
508:38 - typo like this so someone who is trying
508:43 - to make a singer's YouTube channel is
508:46 - going to take singing classes and then
508:48 - learning new songs and then he should as
508:51 - well be learning how to dance because I
508:53 - believe that singers should know how to
508:55 - dance as well okay so now we have
508:59 - implemented this singer YouTube channel
509:02 - and as you can see as I already
509:04 - demonstrated it has this same method
509:07 - which is practice but this method has
509:10 - different implementation than this one
509:14 - and as you can see here this is the
509:15 - implementation of our practice method on
509:18 - our Cooking Channel and then this here
509:20 - is the implementation on our singer
509:23 - YouTube channel so what I want to do now
509:25 - is is I want to create this singer's
509:27 - YouTube channel here we already have
509:30 - cooking YouTube channel so it is a video
509:32 - it is a code from one of my previous
509:35 - videos and then what I want to do is I
509:37 - want to create um singer YouTube channel
509:40 - so let's call it um
509:44 - Singers YouTube channel and let's say
509:47 - that it is going to be called for
509:50 - example John sings like this and then
509:53 - owner is going to be a guy named
509:56 - John like this okay now after I have
510:01 - created this cooking YouTube channel and
510:04 - then this singer YouTube channel you can
510:06 - probably call it singing YouTube channel
510:08 - or something like that uh this is the
510:11 - best name that I could come up with okay
510:14 - so now what I want to do is I want to
510:17 - invoke methods on these two classes and
510:20 - the methods that I want to invoke are
510:22 - going to be these two so practice and
510:24 - then this practice method as well so
510:26 - here I'm going to say cooking YouTube
510:28 - channel do practice like this and then
510:33 - let's invoke the same method for my
510:35 - singer YouTube channel like this and now
510:39 - if I run my
510:41 - program as you can see it says that Amy
510:44 - is practicing cooking and then John is
510:47 - taking singing classes and learning new
510:49 - songs and learning how to dance I can
510:52 - imagine that okay
510:56 - now after I have invoked these two
510:58 - methods you can really see oh I have
511:00 - stopped my program I'm sorry so here you
511:03 - can see that this cooking YouTube
511:05 - channel has invoked its own method so
511:09 - this cooking YouTube channel has invoked
511:11 - the method that has been implemented in
511:13 - this cooking YouTube channel class which
511:16 - is this one here and then this
511:19 - invocation so this singer YouTube
511:21 - channel when you invoke practice method
511:23 - on that this method here is going to be
511:26 - invoked so this method that is
511:28 - implemented in singer YouTube channel
511:31 - class now let's add another thing and
511:34 - that is going to be here in this
511:36 - practice method and then in this
511:38 - practice method as well what I want to
511:40 - do is I want to say that each time that
511:44 - our user practices cooking and then
511:47 - practices singing what is going to
511:50 - happen is the quality of that YouTube
511:52 - channel is going to increase so in order
511:55 - to track that quality content rating I'm
511:58 - going to create a property and that is
512:00 - going to be here in this YouTube channel
512:02 - in this Base Class so I'm going to make
512:05 - that property uh protected protected
512:08 - because I want to have it accessible in
512:10 - my cooking YouTube channel and then in
512:13 - my singer YouTube channel as well so I
512:15 - want that property to I want to access
512:18 - that property from my derived classes
512:20 - and because of that I'm going to make it
512:21 - protected so here I'm going to say int
512:25 - and let's call it it content
512:29 - quality like this okay and initially I
512:34 - want to set the value of this content
512:36 - quality variable in this Constructor
512:39 - here I want to set it to zero like this
512:42 - because I want to say that when you
512:44 - create your YouTube channel this
512:46 - Constructor here is going to be invoked
512:48 - and you are going to have zero
512:50 - subscribers and you are going to have a
512:52 - zero knowledge about content quality so
512:56 - your rate content quality rate is going
512:58 - to be zero so let's close that and then
513:02 - what I want to do here in this practice
513:05 - method is I want to say each time that
513:07 - you practice your content quality should
513:10 - increase so let's increase that variable
513:14 - content where is
513:17 - it content quality Plus+ so I'm going to
513:21 - increment that content quality and then
513:24 - I'm going to do the same
513:26 - here like this now let's say for example
513:30 - that my um this singer here John he's
513:34 - going to practice a lot so he has
513:37 - practiced five times more than Amy did
513:41 - so if I run my program now you can see
513:45 - that John is practicing and then again
513:48 - and again and again so he is practicing
513:51 - a lot and Amy is not really so what do I
513:55 - want to do with this content Quality
513:57 - Property well let's say that I want to
514:00 - implement another method and that method
514:03 - is going to be as well implemented here
514:05 - in this Base Class and that method is
514:07 - going to be called uh check analytics
514:10 - because that check analytics method
514:13 - should be available for all YouTube
514:15 - channels so that is not something that
514:17 - is specific for this cooking YouTube
514:19 - channel only or for this singing YouTube
514:22 - channel so singer YouTube channel but
514:25 - that method should be available for all
514:28 - YouTube channels and because of that I'm
514:30 - going to implement it in this Base Class
514:33 - so let's say
514:35 - void check
514:40 - analytics like
514:42 - this okay and now what I want to do in
514:46 - this check analytics method is I want to
514:48 - use this property this content Quality
514:51 - Property in a following way so I want to
514:54 - say if
514:56 - content quality is less than five I want
515:00 - to write out a message to my user so I
515:03 - want to say see out and then let's write
515:05 - out the name of this YouTube channel
515:08 - like this and then let's add um a
515:11 - message which is going to say let me
515:14 - copy
515:15 - that okay this is going to say that this
515:19 - channel has a bad quality content
515:22 - because this content quality has a
515:25 - rating that's that is less than five and
515:29 - let's add in line and then what is going
515:32 - to happen if this content quality is not
515:35 - uh less than five so if it is equal to
515:37 - five or greater than five I'm going to
515:40 - put else block here and what I want to
515:43 - say
515:45 - here okay is that this channel has a
515:50 - good content great content
515:53 - actually okay like this
515:56 - now what am I going to do with this
515:58 - check analytics method well I'm going to
516:00 - try to invoke it here but the way that I
516:04 - want to try to invoke this um this
516:07 - method that we just implemented is going
516:09 - to be in a following way so there is one
516:12 - very interesting thing when it comes to
516:15 - polymorphism and that thing is related
516:18 - to pointers um at this point I haven't
516:21 - made videos about pointers on my channel
516:23 - but if you're watching this video
516:24 - sometime in the future sure then those
516:26 - videos are probably available on my
516:28 - channel so make sure to look for them on
516:31 - my channel and then in the description
516:32 - of this video as well so let's create a
516:36 - pointer and that pointer is going to be
516:38 - a pointer of our Base Class so a pointer
516:42 - of type YouTube channel okay like this
516:46 - and let's call it YouTube one and what I
516:50 - want to do is I want to assign to this
516:52 - pointer here address of this cooking
516:56 - YouTube channel and you can do that you
516:59 - can assign to a pointer of a base class
517:03 - an address of derived class so I'm going
517:07 - to say here please to this pointer
517:10 - assign address of this cooking YouTube
517:14 - channel class like this and then what I
517:17 - want to do is I want to create another
517:19 - pointer let's call it YouTube 2 and then
517:22 - to this YouTube 2 pointer I want assign
517:26 - the address of my singer YouTube channel
517:29 - like this so one more time a pointer of
517:34 - Base Class can point to a variable of
517:38 - derived class now what I can do using
517:42 - these pointers is I can invoke method
517:46 - that I have just created which is this
517:49 - one here so check analytics so let's do
517:52 - that let's say YouTube channel one
517:56 - and then um let's invoke this method
517:58 - let's say check analytics like this and
518:02 - if you just noticed it has changed my
518:04 - DOT to this symbol here because this is
518:07 - used when you want to invoke methods
518:09 - using pointers so I'm going to copy this
518:14 - again for my second YouTube channel like
518:17 - this and now if I run my
518:21 - program as you can see our John has been
518:24 - practicing a lot and then Amy has been
518:28 - practicing only one time so here after I
518:32 - have invoked these two methods this
518:34 - first method says that Amy's kitchen has
518:37 - bad quality content because she hasn't
518:39 - been practicing enough and then after
518:42 - this YouTube channel to check analytics
518:45 - you can see that it writes out this
518:48 - message that John sings channel has
518:50 - great content because he has been
518:53 - practicing a lot as you can see
518:56 - here
518:58 - okay so here we have used polymorphism
519:02 - in order to implement this practice
519:05 - method in our cooking YouTube channel
519:07 - and then in our singer YouTube channel
519:10 - so implementation of our singer YouTube
519:13 - channel practice method is here and then
519:15 - for our cooking YouTube channel our
519:17 - practice method looks like this and we
519:20 - have done that uh thanks to the
519:23 - polymorphism so different implement
519:25 - ations but the same method name and then
519:30 - I have demonstrated here how you can use
519:33 - pointers to point to an object of
519:36 - derived class and you can store that in
519:40 - a pointer of Base class and then we have
519:43 - invoked this check analytics methods
519:46 - using these uh pointers of Base class so
519:51 - I hope that you enjoyed this video if
519:53 - you did give it a thumbs up up and don't
519:56 - forget to subscribe to my channel click
519:58 - the Bell icon as well and I'm going to
520:00 - see you in my next video bye hi everyone
520:05 - welcome to my channel in this video I
520:07 - want to talk about pointers so I will go
520:10 - straight to the point uh pointers are
520:12 - very important Concept in C++ and they
520:15 - have many uses in C++ now pointers are
520:18 - not limited only to C++ they exist in
520:21 - other programming languages as well but
520:23 - in most of those programming languages
520:25 - they are really hidden they work behind
520:27 - the scenes so you cannot see them and
520:30 - you cannot use them yourself but it's
520:32 - C++ you can use them and you can create
520:35 - your own pointers and they can be pretty
520:38 - powerful if you know how to use them but
520:40 - they can get quite confusing as well if
520:43 - you don't understand them well so the
520:45 - first thing that I want to explain is
520:48 - what are Pointers so we already have
520:51 - explained the concept of a variable and
520:53 - you should be familiar with that that so
520:56 - we said that a variable is just a
520:59 - container so a container that stores
521:01 - certain value now a pointer is container
521:04 - as well but instead of storing value
521:07 - pointer stores an address so a memory
521:10 - location and let me show you how
521:13 - pointers work in Visual Studio let's
521:16 - create a variable of type int and I'm
521:19 - going to call it n and assign it a value
521:21 - of five and let's write out this
521:26 - n like this so nothing new here we are
521:30 - already familiar with this and if I run
521:33 - my program as you can see we get this
521:36 - value of five so that was expected now
521:39 - as I already said this N is a variable
521:43 - and that means that it is a container
521:45 - which is storing certain value now
521:48 - because it is a container that means
521:50 - that it has its address inside memory so
521:53 - it has its physical location so how can
521:56 - we get that location how how can we
521:58 - check which address this n has so in
522:01 - order to do that you use this ENT symbol
522:05 - like this so you put it before your
522:07 - variable name and that should give you
522:10 - the address of that variable so if I run
522:13 - my program
522:14 - now as you can see now we have an
522:18 - address um and this is the address of
522:21 - our n variable so this is its physical
522:24 - address where this value of five is
522:26 - stored and because this is pretty hard
522:29 - for humans to remember this is just a
522:32 - random numbers and characters because of
522:35 - that we use meaningful names and we
522:38 - access these values that we store in our
522:40 - memory using these meaningful names
522:43 - which are our variables so I'm going to
522:46 - close this now and what I want to show
522:48 - you here is I want to show you how can
522:50 - you create a pointer that is going to
522:53 - hold this address of our r n variable so
522:56 - in order to create a pointer you give it
522:58 - a type first so you say int and then in
523:02 - order to indicate that you are creating
523:04 - a pointer you use this star symbol and
523:07 - then you give it a name so let's call it
523:09 - PTR pointer and I'm going to assign it
523:14 - the address of our n variable so I'm
523:17 - going to copy this and paste it here
523:20 - okay now our pointer is holding the
523:23 - address of our n variable and in order
523:26 - to prove that I'm going to write out the
523:29 - value of my
523:32 - pointer like
523:36 - this so as expected we have this first
523:39 - line here which is writing out the
523:42 - address of our n variable and then this
523:44 - second line of code is this line here
523:48 - and as you can see we have written out
523:50 - the value of our pointer and that is the
523:53 - same address as this one here here which
523:55 - means that our pointer really is storing
523:58 - the address of our n variable now you
524:01 - may ask how can I access or can I access
524:05 - the value that is stored on that address
524:08 - using pointers and the answer to that
524:10 - question is yes you can and in order to
524:13 - do that in order to access the value
524:15 - that is stored on this address that your
524:17 - pointer is holding you have to
524:19 - dreference your pointer so how do you do
524:22 - that well let me copy this
524:25 - so as you already have seen this line of
524:28 - code here is going to write out the
524:31 - address and in order to write out the
524:33 - value on that address you dreference the
524:35 - pointer and in order to do that you add
524:38 - this star symbol before your Pointer's
524:41 - name so if I run my program now as you
524:45 - can see in this last line of code we
524:48 - have the value of five which is actually
524:50 - the value that is stored on this address
524:53 - here so let me show you one more thing
524:55 - what I want to do is I want to change
524:58 - the value that is stored on this PTR
525:00 - address so on this address that our PTR
525:03 - pointer is storing so how am I going to
525:06 - do that I'm going to say again star
525:08 - symbol and then PTR and this here means
525:12 - please access this memory location so
525:15 - whatever I'm going to assign here is
525:17 - going to be stored on that memory
525:19 - location and what I want to assign is
525:22 - for example value of 10 like this so now
525:26 - if I copy this line of code and then
525:28 - paste it here and if I run my program
525:32 - again we have this value of 10 stored on
525:36 - this address here and one interesting
525:38 - thing as well is that if we try to write
525:41 - out the value that our n holds now like
525:45 - this if I run my program as you can see
525:49 - our n holds the value of 10 as well even
525:52 - though uh we have never said that n has
525:55 - the value of 10 but we have stored the
525:59 - address of our n in our pointer and then
526:02 - we have D referenced our pointer meaning
526:04 - we have changed the value on that
526:07 - address here in this 11th line of code
526:10 - here so that's why our n holds value of
526:12 - 10 now one very important thing to keep
526:16 - in mind is that your pointer has to be
526:18 - of the same type like the variable that
526:20 - it is pointing to so let's close this so
526:24 - as I said this integer pointer is
526:27 - pointing to an integer variable so our n
526:30 - is of int type and the same way would be
526:33 - if we created a float pointer it would
526:36 - have to point to a float variable and
526:38 - then chart pointer can point only to a
526:40 - Char variable double bull um and so on
526:44 - so pointer and the variable that that
526:47 - pointer is pointing to have to be of the
526:49 - same type okay so that means that if I
526:53 - try to change the type of this n
526:55 - variable to float for
526:58 - example like this so if I say float
527:01 - immediately we get an error here and the
527:04 - error says a value of type float pointer
527:08 - cannot be used to initialize an entity
527:10 - of type end pointer meaning you cannot
527:14 - assign address of a float type to
527:18 - pointer of int type okay so that is the
527:22 - error that we have here and I'm I'm
527:24 - going to return this to
527:26 - int okay and as you can see that error
527:30 - has disappeared because now our pointer
527:33 - is pointing to the same type so to the
527:35 - variable of the same type that that
527:37 - pointer has so int pointer pointing to
527:41 - an INT
527:43 - variable one thing that beginners very
527:45 - often try to do is the following so they
527:49 - say okay let's create a pointer so int
527:52 - let's give it a name
527:53 - ptr2 so pointer like this so I have
527:57 - created a pointer right so let's
528:00 - dreference this pointer and assign it a
528:02 - value so I'm going to say please D
528:04 - reference PTR 2 and assign it a value of
528:08 - 7 for example now this code here has a
528:12 - problem problem and if I run it if I say
528:15 - build solution actually as you can see
528:18 - it says uninitialized local variable
528:20 - ptr2 used this means that this ptr2 so
528:25 - this pointer to does not have an address
528:27 - so where should it store this value of
528:30 - seven if it does not have an address and
528:33 - the easiest way right now to solve this
528:35 - problem is going to be to create a
528:37 - variable and to give the address of that
528:41 - variable to our ptr2 pointer so I'm
528:43 - going to say int V this variable has to
528:47 - be of the same type as our pointer as we
528:49 - already said and then I'm going to say
528:52 - here our ptr2 is going to hold hold the
528:55 - address of our V variable like this and
529:00 - now we shouldn't have this problem
529:02 - anymore so if I build my code again as
529:06 - you can see one succeeded so the problem
529:08 - has disappeared and let me write out the
529:12 - value of this V variable so I'm going to
529:14 - say V is equal to and then let's write
529:18 - out the value of this V and if I run my
529:23 - program as you can see it says that V
529:26 - has the value of seven because we have
529:29 - assigned it here by D referencing our
529:31 - pointer that is holding the address of
529:34 - our V so you may say now okay Salina I
529:38 - understand this but this seems a little
529:40 - bit too much why would I create a
529:42 - pointer just to assign a value to a
529:45 - variable and the answer to that question
529:48 - is you don't this is not the type of
529:50 - problem for which pointers were created
529:52 - in C++ so this there are different
529:55 - problems that pointers solve in C++ and
529:58 - this here is just a demonstration of
530:01 - what are Pointers and how can you create
530:03 - your own pointers now examples of some
530:06 - of these other problems that pointers
530:08 - solve is you can use pointers in order
530:11 - to pass values by a reference to a
530:14 - function and then you can use them to
530:16 - return multiple values from a function
530:19 - which is an interesting one uh you can
530:21 - use pointers in combination with arrays
530:23 - as well uh you can use them for dynamic
530:25 - memory allocation and then if you're
530:27 - familiar with oop objectoriented
530:30 - programming you can use a pointer of a
530:33 - base class in order to access a object
530:36 - of derived class and then there is this
530:39 - concept of smart pointers which we are
530:41 - going to cover in the future so I
530:44 - believe as well that I have mentioned
530:46 - some of these things in some of my
530:47 - videos but I plan to make um dedicated
530:51 - series to pointers where we are going to
530:53 - talk only about pointers so stay tuned
530:57 - subscribe to my channel um hit that Bell
531:00 - icon as well so that you are notified
531:02 - when I publish my next video and if you
531:04 - like this one give it a thumbs up thank
531:07 - you for watching and I'm going to see
531:09 - you in my next video where we will be
531:10 - talking about pointers bye hi everyone
531:14 - welcome to my channel in this video I
531:17 - want to talk about void pointers now in
531:19 - the previous video of this playlist I
531:21 - introduced you to pointers in general so
531:24 - I explained what are Pointers and how
531:26 - you can create your own pointers and I
531:28 - said that a pointer is a special
531:31 - variable that can hold an address and I
531:34 - said as well that a pointer can hold
531:36 - only the address of a variable that is
531:39 - of the same type as that pointer which
531:41 - means an integer pointer can hold the
531:44 - address of an integer variable and then
531:46 - a character pointer holds the address of
531:48 - a character variable float pointer of a
531:50 - float variable and so on but there is an
531:54 - exception to that rule and that is a
531:56 - void pointer and a void pointer is a
531:59 - special type of pointer that can hold
532:02 - the address of a variable of any other
532:04 - data type so a void pointer can hold the
532:07 - address of a float variable or an INT
532:09 - variable or a Char bull struct whichever
532:13 - one you pass to that void pointer but a
532:16 - void pointer has a limitation as well
532:19 - and that limitation is that you cannot
532:21 - directly D reference a void point
532:25 - so in order to demonstrate this I'm
532:27 - going to create an example with the
532:28 - knowledge that we already have so using
532:31 - only integer and character and Float
532:33 - pointers that we are already familiar
532:35 - with and then I want to introduce a void
532:38 - pointer in order to solve that problem
532:40 - so that you can see how void pointers
532:42 - are used so let's jump into our Vis
532:45 - Visual Studio here I want to create a
532:48 - variable um and let's make it of int
532:52 - data type so I'm going to say int and
532:55 - let's call it number like this and I'm
532:58 - going to assign it a value of five for
533:01 - example now what I want to do with this
533:04 - number variable is I just want to write
533:06 - it out and because we are working with
533:09 - pointers let's play with pointers some
533:11 - more so I want to write out this
533:13 - variable using a function that receives
533:16 - a pointer let's do that so that function
533:20 - is going to be of return type void and
533:23 - let's call it print
533:25 - number like this and then here this
533:28 - function is going to receive an integer
533:31 - pointer and we are going to call it uh
533:35 - number PTR so number
533:38 - pointer
533:39 - okay now what this function here should
533:42 - do is it it should just print out the
533:45 - value that this number pointer is
533:47 - storing so actually the value that is
533:49 - stored on the address that this number
533:51 - pointer is holding so in order to do
533:54 - that we have to the reference this
533:56 - pointer so I'm going to say star symbol
533:59 - and then put the name of this number
534:02 - pointer and let's add an end line as
534:05 - well now this function is finished and
534:08 - it is writing out the value that is
534:11 - stored on the address that we passed to
534:13 - it and we have to pass it the address of
534:16 - an integer variable so if I invoke this
534:20 - print number function let's say print
534:22 - number as I said since it is receiving a
534:25 - pointer we have to pass it an address
534:28 - and that is going to be the address of
534:30 - this number variable so let's say m
534:33 - perent number so this here is going to
534:36 - give us the address of this number
534:38 - variable okay and now if I run this
534:42 - program as you can see this function
534:45 - here has printed out value of five which
534:48 - is the value of our number okay now what
534:52 - happens if I want to create a k
534:54 - character variable and then print out a
534:56 - character variable as well so let's do
534:58 - that I'm going to say Char let's call it
535:03 - letter and let's assign it a value of
535:06 - letter A okay and now in order to print
535:10 - out this character using this same
535:12 - approach I will have to create another
535:15 - function because this one here receives
535:17 - an integer pointer and in order to print
535:19 - out a character we would have to create
535:22 - a function that receives a character
535:24 - pointer so let's copy this function here
535:27 - and I'm going to call it print
535:31 - letter like this and then this function
535:34 - is going to receive a character
535:36 - pointer okay and that pointer is going
535:39 - to be called Char
535:42 - PTR and then here I just want to write
535:45 - out the referen value of that Char PTR
535:49 - so let's invoke this print letter
535:53 - function let's let's pass it the address
535:55 - of this letter variable that we have
535:58 - created
536:00 - here and now if I run this program as
536:03 - you can see we have five for this first
536:07 - function and then a for this second
536:09 - function which means that these two
536:12 - functions are doing its job but what
536:15 - happens if I want to print out a
536:16 - floating Point number and then a double
536:19 - and then a Boolean value and a stct
536:21 - value in order to do each one of those I
536:23 - would have to to create a function that
536:26 - receives that specific data type pointer
536:29 - but we can solve that same problem using
536:32 - a void pointer because as we already
536:34 - said a void pointer can point to a
536:37 - variable of any data type so let's do
536:40 - that let's create a function that is
536:42 - going to print out any data type so that
536:46 - function is going to be of return type
536:47 - void and let's give it a name print
536:51 - because it is generic it is going to
536:53 - work with all data types I'm going to
536:56 - give it name of print and as we said
536:58 - that function is going to receive void
537:01 - pointer and let's call that pointer
537:03 - PTR okay now because this void pointer
537:08 - can point to a variable of any data type
537:11 - we will have to keep track of which data
537:14 - type we have passed inside this void
537:17 - pointer and in order to do that I'm
537:19 - going to use another parameter here and
537:22 - that parameter is going to be of type R
537:24 - and I'm going to call it
537:26 - type so how this type parameter is going
537:30 - to be used well in a situation where we
537:33 - pass an integer pointer to this print
537:35 - function here this type parameter is
537:38 - going to have a value of I in a
537:41 - situation when we pass a character
537:43 - pointer to this void pointer here in
537:46 - this type parameter we are going to pass
537:48 - a value of c and then if we pass a float
537:51 - pointer here here we are going to store
537:53 - an F and then if we pass a double
537:56 - pointer here this type variable should
537:58 - store a letter D so that we can know how
538:02 - we are going to dreference this PTR
538:05 - pointer so the first thing that we have
538:07 - to do is we have to check what this type
538:10 - variable is holding so in order to do
538:13 - that I'm going to use switch
538:15 - case like this you can use if else as
538:19 - well if you want so here I'm going to
538:21 - switch on this type
538:24 - variable like this and what I want to do
538:27 - here is I want to say in the case that
538:31 - this type variable is holding the value
538:34 - of I that means that this here is an
538:38 - integer pointer so here I'm just going
538:40 - to leave a comment for now so I'm going
538:42 - to say handle int pointer like this and
538:47 - then the other situation is going to be
538:50 - in the case that this type variable is
538:54 - holding the value of C that means that
538:57 - here we have passed a character pointer
539:00 - so I'm going to leave another comment as
539:03 - well so here I I'm going to say handle
539:06 - Char pointer okay now let's explain how
539:10 - we are going to handle this integer
539:13 - pointer and then this character pointer
539:15 - as well well as we already said since a
539:18 - void pointer cannot be dereferenced
539:20 - directly but we first have to cast it
539:23 - into a specific specific data type so
539:25 - into an integer pointer or into a
539:28 - character pointer in this particular
539:29 - situation I'm going to do that so here
539:33 - I'm going to say in the case that our
539:35 - user has passed an integer pointer here
539:38 - I will have to cast this void pointer
539:41 - into an integer pointer first so how do
539:44 - you do that well you say please this
539:47 - pointer here so this PTR cast that into
539:52 - an integer pointer
539:55 - so this expression here is going to cast
539:58 - this void pointer into an integer
540:00 - pointer so in these parentheses here we
540:03 - are going to have an integer pointer and
540:07 - in order to access to the address that
540:10 - an integer pointer is storing and write
540:12 - out the value that is stored on that
540:14 - address we dreference that pointer and
540:17 - for that we use this star symbol so now
540:20 - here we have the value that is stored on
540:24 - this integer pointer and I'm going to
540:27 - write out that value like this and let's
540:30 - add endline as well so this here writes
540:35 - out the value of an integer pointer so
540:38 - let's copy that and then paste it here
540:41 - and here what I want to do in this C
540:43 - situation is I want to cast this void
540:46 - pointer into a character pointer so Char
540:50 - pointer and then after I have character
540:52 - pointer here I ID reference that and
540:56 - then this line is going to write out the
540:58 - value of our character okay so now if I
541:02 - invoke this print function I should get
541:06 - the value of this number and then of
541:07 - this letter as well using only this
541:10 - print function so let's comment these
541:13 - two for
541:14 - now and let's invoke our print function
541:18 - so I'm going to say print and then the
541:20 - first thing that it receives is going to
541:22 - be DX address and in this particular
541:25 - situation considering that this is a
541:27 - void pointer we can pass it the address
541:30 - of any data type so we can pass it the
541:33 - address of a integer variable or of a
541:36 - character variable or of a floating
541:38 - Point variable and in this situation we
541:41 - have integer variable and then character
541:43 - variable so let's use these two so let's
541:47 - pass here the address of our
541:49 - number that oh that is going to be the
541:52 - first parameter and then the second
541:54 - parameter is going to be the type and
541:56 - considering that we have passed the
541:58 - address of an integer let's pass the
542:01 - value of i as our second parameter here
542:06 - okay and then I'm going to copy this
542:08 - function one more time and this time I
542:11 - want to pass it the address of our
542:14 - letter variable and considering that
542:17 - that is a character here as a second
542:20 - parameter I'm going to pass C now I've
542:23 - just not notice that something is
542:24 - missing from our switch case and before
542:27 - I say what it is please write your idea
542:30 - write your answer in the comments down
542:32 - below so what we are missing in these
542:34 - two cases is break at the end so here
542:38 - I'm missing a
542:39 - break like this and then here as
542:44 - well okay so now we have completed our
542:47 - switch case and if I run my program
542:52 - now as you can see for this first line
542:56 - we get the value of five which is our
542:58 - integer so this print function has
543:00 - printed the value of our integer and
543:02 - then in this second line we have printed
543:05 - out the value of a character and we have
543:07 - done that using this print function
543:11 - which receives a void pointer and then
543:15 - it receives a Char uh variable which is
543:18 - called type and we use that Char
543:20 - variable in order to differentiate which
543:23 - data type we are storing inside this
543:26 - void pointer because as I already said a
543:29 - void pointer can point to a variable of
543:31 - any data type but it cannot be de
543:34 - referenced directly so for that we are
543:36 - using this type parameter to check which
543:40 - data type is stored inside this pointer
543:44 - here so now you have an idea on how to
543:47 - use void pointers but I would actually
543:50 - advise you to be very careful when using
543:52 - void pointers why because your compiler
543:56 - in this particular situation does not
543:58 - have a way to tell you hey you are
544:01 - trying to cast a void pointer which is
544:03 - actually an in pointer into a character
544:06 - or vice versa if you're doing that your
544:08 - compiler in this situation here does not
544:12 - have a way to know if you're are making
544:14 - an error or not because inside a void
544:17 - pointer you can store the address of any
544:20 - variable so of a variable of any data
544:22 - type and then you can try to cast that
544:25 - void pointer into a pointer of any other
544:28 - data type which means for example in
544:31 - this particular situation here we are
544:33 - passing an integer so this number here
544:36 - is an integer which means that here for
544:39 - this line of code we are receiving an
544:42 - integer pointer okay and then in this
544:45 - case here we are trying to cast that
544:48 - into an integer pointer and that is okay
544:50 - but if we accidentally make a mistake
544:53 - here and we try to cast that into a
544:55 - character pointer for example like this
544:58 - our compiler Now does not have a way to
545:02 - know that we are making a mistake here
545:04 - and if we run our
545:07 - program look at this we get this
545:10 - undefined symbol here which is what is
545:13 - this you know this is not the expected
545:16 - behavior of our program and we did not
545:19 - get a compile time error which means
545:22 - that this here is is completely valid so
545:25 - your compiler is not going to tell you
545:27 - that this here is an error but it
545:29 - actually is a logical error and those
545:32 - type of Errors so logical errors are
545:35 - much harder to find inside programs and
545:38 - this here is a small program and it is
545:41 - kind of easy to find an error in a
545:43 - program that has 20 lines of code but if
545:46 - you had a logical error in a program
545:48 - that has 20,000 L lines of code for
545:51 - example you would have a very very big
545:54 - problem so again I strongly advise you
545:57 - to be very careful when you are using
546:00 - void pointers because as you see
546:02 - compiler is not uh reporting an error
546:05 - for this situation here but but this
546:07 - actually is an error so I'm going to
546:09 - return this to an integer pointer okay
546:13 - so I hope that you enjoyed this video
546:16 - and uh that you learned something new
546:18 - and if you did give it a thumbs up
546:20 - subscribe to my channel and thank you
546:22 - for watching I'm going see you in my
546:24 - next video bye hi everyone welcome to my
546:28 - channel in this video I want to talk
546:30 - about pointers and arrays and if you
546:33 - watched the first video of this playlist
546:35 - you remember that I said that one of the
546:37 - common uses of pointers is using them
546:40 - with arrays so in this video I want to
546:42 - demonstrate how that works so let's jump
546:45 - straight to our visual studio and let's
546:48 - create an array of type in and I'm going
546:52 - to call that array lucky
546:56 - numbers like this and let's say that I
546:59 - have five lucky numbers for example and
547:02 - those are 2 3 5 7 9 oh that's five
547:07 - numbers already okay so these here are
547:11 - my lucky numbers and now I want to show
547:15 - you one thing so what is going to happen
547:18 - if I say for example see out lucky
547:21 - numbers and let's add and l so what is
547:25 - going to be written out if I write out
547:27 - just the name of my array let's check
547:30 - that if I run this program as you can
547:33 - see we get an address but what is this
547:37 - address this address here so the name of
547:41 - our array is actually the address of the
547:44 - first element of that array and in order
547:47 - to prove that let's write out the
547:49 - address of the first element of this
547:51 - array to check if these two are going to
547:54 - be the same so here I want to write out
547:57 - the address of the first element which
548:00 - is the element with index zero so now if
548:05 - I'm telling the truth these two should
548:07 - be the same so if I run my program as
548:11 - you can see indeed we get the same
548:14 - address which means again the name of
548:18 - the array is the address of the first
548:21 - element of that array
548:24 - now that means that this lucky number's
548:27 - name behaves as a pointer and these
548:31 - square brackets here are behaving as a
548:33 - operator for D referencing so if I say
548:37 - for example see out lucky numbers of two
548:43 - I'm going to get the element that has
548:46 - index two so this here is going to be
548:49 - the first address and then it is going
548:51 - to add two more addresses to that
548:54 - element and we are going to get the
548:56 - value that is stored there so lucky
548:59 - numers name is the address of the first
549:02 - element it is going to add two more
549:04 - addresses to that so one two so this
549:09 - line of code here is going to give us
549:11 - the value of five let's add endline and
549:14 - run our program in order to demonstrate
549:17 - that and as you can see indeed we get
549:20 - the value of five now there is another
549:24 - way to do this same thing here and that
549:27 - is going to be the following way so I
549:28 - can say see out please write out this
549:33 - lucky numbers which as we already
549:35 - demonstrated is the address of this
549:37 - first element so I'm going to put that
549:39 - here and then I can use arithmetic
549:42 - operators on this so I can say please
549:45 - add to this lucky numbers two more
549:48 - address spaces and then the reference
549:52 - this so we use star symbol for that and
549:56 - then I'm going to add end line and these
549:59 - two lines of code so this one here and
550:03 - this one here should behave the same so
550:06 - if I run my program now as you can see
550:08 - we get the same value so these two lines
550:11 - of code are doing the same thing which
550:14 - means that this line of code here is
550:16 - using these square brackets in order to
550:19 - the referentie the element with that
550:22 - index which is index 2 and we know that
550:25 - the indexing starts with zero so 0 1 2
550:28 - and we get the value of five and then
550:31 - this second line of code here uses this
550:34 - star symbol in order to differentiate
550:37 - this expression here and what this
550:39 - expression here says it says lucky
550:42 - numbers which is the address of the
550:44 - first element as we demonstrated here so
550:47 - please use the address of the first
550:50 - element and then add two more address
550:53 - spaces to that so the address of the
550:56 - first element if I add two more to that
550:58 - it's going to be the address of one two
551:01 - so the address of this one here and then
551:04 - if I dierentiate that I get this value
551:08 - which is stored on that address so these
551:11 - two lines of code are writing out the
551:14 - same thing so let me very quickly show
551:17 - you how you can enter the values for
551:19 - this array and then write them out
551:22 - because here we have hard hardcoded
551:24 - value so I'm going to delete
551:27 - this and um I'm going to comment these
551:30 - two lines of code as well no actually
551:32 - I'm going to comment all of these
551:34 - because we don't need them anymore but
551:36 - I'm going to leave them for you so that
551:38 - you can um see how these are used in
551:41 - order to deeri um your array so as I
551:45 - said we want to enter values for our
551:48 - array now so in order to do that I'm
551:50 - going to use for Loop so I will say four
551:54 - and then our for Loop starts uh with I
551:57 - equal to Zer because that is the index
552:00 - of our first element and then
552:02 - considering that our array has five
552:04 - elements and the last one has index of
552:07 - four we are going to run our four Loop
552:10 - while I is less than or equal to four
552:14 - and in each iteration we are going to
552:16 - increment the value of our I okay and in
552:20 - order to enter values for our array
552:23 - let's write out a message so I'm going
552:24 - to say see out number so please enter a
552:28 - number that is going to be the message
552:30 - for our user and then I'm going to input
552:34 - a value from my console into lucky
552:37 - numbers of I so this here means please
552:42 - enter the value into our lucky numbers
552:44 - array to element that has the same index
552:49 - that our I holds in that iteration so in
552:52 - the first iteration index zero in the
552:54 - second iteration index one and then in
552:56 - the third iteration index two and so on
553:00 - so this for Loop here is going to help
553:03 - us to enter the values into our lucky
553:05 - numbers array and in order to show that
553:08 - I'm going to put here a break point and
553:11 - that means that our program is going to
553:13 - stop its execution when it comes to this
553:15 - line here so if I run my program as you
553:20 - can see it asks me to enter number so
553:23 - I'm going to say 2 5 7 9 and 13 so those
553:29 - were five numbers that we had to enter
553:31 - for our lucky numbers array and if I
553:33 - press enter one more time as you can see
553:37 - our program has been stopped in this
553:39 - line of code here and if I hover over my
553:42 - lucky numbers here we have values that
553:45 - we have entered for our array so value
553:47 - of 2 5 7 9 and 13 which are the values
553:52 - that we have entered here so I'm going
553:56 - to stop my program now please stop
554:01 - okay and now what I want to do is I want
554:04 - to use this other approach to write out
554:07 - the numbers that this lucky numbers
554:09 - array is holding so let's use another
554:12 - for Loop I'm going to copy this one okay
554:16 - and then what this second for Loop is
554:18 - going to do it is just going to write
554:21 - out these numbers but but okay let's use
554:24 - this approach for now so I'm going to
554:26 - just change this to see out and then use
554:30 - these other redirection signs and after
554:32 - each number I'm going to add an empty
554:37 - space okay like this and instead of
554:41 - using this approach here so instead of
554:43 - uh using these square brackets in order
554:45 - to
554:46 - deeri uh the element on that position
554:49 - let's use this approach here so I'm
554:52 - going to say
554:53 - please use lucky numbers so which is the
554:57 - address of the first element and then to
555:00 - that I want to add the value of my I so
555:04 - plus I like this and this is going to
555:09 - move okay so this expression here is
555:12 - going to help us to access all of the
555:15 - elements of this lucky numbers array so
555:18 - from the one that has index zero until
555:21 - we come to the one that has index for
555:24 - and because we don't want to write out
555:26 - addresses because this here is going to
555:27 - give us the address but we want to write
555:30 - out the values that are stored on those
555:32 - addresses we will have to dreference
555:34 - this expression here so for that I will
555:37 - use star symbol and I'm going to remove
555:41 - this breakpoint now and I'm going to
555:43 - start my program to see what is going to
555:47 - happen Okay and let's enter 2 3 5 7 9 19
555:54 - and as you can see we get values of 2 3
555:57 - 5 7 and 19 which we have entered okay
556:00 - let's stop this program now and there is
556:03 - one more thing that I want to show you
556:05 - what is going to happen if I change this
556:08 - max value from four to five like this so
556:12 - what is going to happen in this
556:14 - particular situation let's run our
556:17 - program and enter numbers again so 2 5 7
556:21 - 13 15
556:24 - okay as you can see now here we have
556:28 - these five numbers that we have entered
556:29 - so 2 5 7 13 15 those are the ones here
556:33 - and then the last one is something that
556:36 - we do not recognize what is this this is
556:38 - some junk number that we definitely have
556:40 - not entered here so this number here is
556:44 - something that does not belong to our
556:46 - lucky numbers array and here we have
556:50 - accessed someone else's memory base so
556:53 - we have this result because we changed
556:56 - max value from four to 5 here and as we
557:00 - already know our lucky numbers has five
557:03 - elements the last one having the index
557:05 - of four which is this one here and then
557:08 - here we added one more iteration so now
557:11 - we are trying to access the element with
557:14 - index five and that element with index 5
557:17 - does not belong or does not exist in our
557:21 - lucky numbers array so so this element
557:24 - here this is memory location that
557:27 - belongs to someone else and we accessed
557:30 - that trying to deeri the pointer to the
557:34 - element that is Sixth Element so we have
557:38 - five elements in our lucky numbers array
557:41 - and then if we add one more address
557:43 - space to that we get this here which is
557:47 - memory location that belongs to someone
557:49 - else and if we just randomly change and
557:53 - access memory locations that do not
557:55 - belong to us we can cause very very big
557:58 - problems so I advise you to be very
558:01 - careful when iterating through your
558:04 - arrays and to access only memory
558:06 - locations that belong to that array that
558:09 - you are iterating so in the case that
558:12 - your array has five elements that those
558:14 - are going to be from zero to four so
558:16 - indexes from 0 to four in the case that
558:19 - your array has 10 elements for example
558:21 - those are going to be indexes 0 to 9 and
558:24 - so on so again be very very careful to
558:29 - not access memory locations that do not
558:32 - belong to you so I hope that now you
558:34 - have an idea on how pointers and arrays
558:37 - go together and as well we have seen
558:40 - some of the potential problems that can
558:42 - happen if you are not careful enough
558:44 - when working with pointers and arrays so
558:48 - again I advise you to be very careful uh
558:50 - when working with pointers and arrays
558:52 - and and not access memory locations
558:55 - memory addresses that do not belong to
558:57 - you so thank you for watching this video
559:00 - If you enjoyed it if you learned
559:02 - something new give it a thumbs up and
559:04 - subscribe to my channel hit that Bell
559:06 - icon as well you can follow me on my
559:08 - other social media if you want links for
559:10 - those are going to be in the description
559:12 - of this video thank you for watching and
559:15 - I'm going to see you in my next video
559:17 - bye hi everyone welcome to my channel in
559:20 - this video I want to explain how you can
559:23 - use pointers in order to return multiple
559:25 - values from a function so I said in the
559:29 - first video of this playlist that using
559:31 - pointers to return multiple values from
559:33 - a function is a very common use for
559:36 - pointers so in this video I want to
559:38 - demonstrate how that works so here we
559:41 - are going to create an array of numbers
559:44 - and then first I want to create two
559:46 - functions and one of those two is going
559:48 - to return me the smallest number in that
559:51 - array and then the other one is going to
559:53 - return me the largest number in that
559:55 - array and then in the second part of
559:57 - this video I want to show you how you
559:59 - can use pointers in order to get both
560:02 - smallest and largest number using one
560:06 - function only so you can return both of
560:08 - these numbers so Min number and Max
560:11 - number using only one function and that
560:14 - is going to be with the help of pointers
560:16 - so let's start with this example as I
560:20 - already said uh I'm going to create an
560:23 - array of numbers so um those are going
560:26 - to be numbers of type int and let's call
560:29 - this array numbers like this and it is
560:32 - going to be array of five numbers and
560:35 - let's assign him values of for example 5
560:40 - 4 um - 2 29 and 6 for example so those
560:48 - are going to be my numbers okay and now
560:52 - let's create a function that is going to
560:55 - return the smallest number of this array
560:58 - so I'm going to create that function
560:59 - here and let's give it the return type
561:03 - of int and I'm going to call it get min
561:07 - like this and what I will need to pass
561:10 - to this function is going to be array so
561:13 - this array here so I'm going to say int
561:17 - numbers array so this is going to be the
561:21 - first argument and then the second one
561:24 - is going to be the size of this array so
561:26 - I'm going to say in size and we will use
561:30 - this second parameter here so that we
561:32 - know how many iterations we have to make
561:35 - in order to go through all of the
561:37 - elements of this array so let's define
561:40 - this function the first thing that I
561:43 - want to do is I want to create a
561:46 - variable of type int and that variable
561:49 - is going to be called min so this is
561:53 - going to be the variable that is going
561:54 - to hold the minimal value so the
561:57 - smallest number in this array and
562:00 - initially I want to assign to this
562:02 - variable the first element of this array
562:05 - so I'm going to say that the smallest
562:06 - element initially is going to be the
562:08 - first one so I'm going to say numbers of
562:12 - zero and then we are going to iterate
562:14 - through all of the other elements and
562:17 - each time that we find an element that
562:19 - is smaller than the current value of our
562:22 - min we are going to store that value in
562:24 - our Min so let's do that so I'm going to
562:28 - say four and since we have already
562:31 - stored the value of our first element in
562:33 - our Min we do not need to iterate
562:36 - through that so I'm going to say that my
562:38 - int initially has the value of one okay
562:43 - oh int I is equal to one like this and
562:47 - then our for Loop is going to iterate
562:49 - while our I is less than the size of
562:52 - this array so in this particular
562:55 - situation while our I is less than five
562:58 - and in each iteration we want to
563:00 - increment our I like this so as I
563:04 - already said if we find a number on a
563:09 - specific position which is in this
563:11 - current situation uh the position with
563:14 - the index of I if we determine that that
563:17 - number is smaller than our Min
563:20 - number like this we are going to store
563:24 - that number in our Min variable so I'm
563:26 - going to say Min is equal to numbers of
563:31 - I so that at the end of this for Loop in
563:35 - our Min variable is going to be the
563:37 - smallest number of this array so at the
563:41 - end of this for Loop here we can return
563:44 - our Min like this okay so now in order
563:48 - to test this function here I'm going to
563:51 - invoke it let's say get actually I'm
563:53 - going to write it out I'm going to say C
563:55 - out Min is like this and then let's
563:59 - invoke it let's say get min like this
564:03 - and this get min function receives array
564:07 - so let's pass it numbers array and then
564:11 - it receives the size of this array and
564:14 - this array has 1 2 3 4 five elements and
564:17 - you can check that here as well so we
564:19 - are going to pass Five here okay and if
564:24 - I run this
564:26 - program as you can see it says Min is
564:29 - minus 2 which really is the smallest
564:32 - number in our array so that is going to
564:35 - be the first function and then the
564:38 - second function that I want to create is
564:39 - going to be the one that is going to
564:42 - return the largest number in our array
564:44 - so let's copy this function I'm going to
564:47 - copy it and then just modify it a little
564:50 - bit so the name of that other function
564:53 - is going to be get Max like this and
564:57 - then that function as well will receive
564:59 - numbers array and the size but here we
565:03 - are going to have variable which is
565:05 - called Max instead of Min and again we
565:09 - will assign it the value of our first
565:12 - element so then we iterate through all
565:15 - of these elements so starting with the
565:18 - second element because first the value
565:20 - of the first one we already have inside
565:22 - this variable so we do not need to check
565:24 - that but if we find in these remaining
565:28 - elements if we find element that is
565:32 - larger so bigger than our Max let's copy
565:36 - this here we are going to store the
565:39 - value of that element in our Max
565:43 - variable like this and then at the end
565:47 - we will return our Max variable okay so
565:51 - now in order to test this function I
565:54 - will invoke it as we did with this
565:56 - previous one I'm I will just say Max is
566:00 - and then invoke get Max like this and
566:06 - I'm going to add two end lines
566:09 - here so that we have output which is
566:11 - formatted nicely and if I run my program
566:15 - now as you can see it says Min is minus
566:18 - 2 and then Max is 29 which is correct so
566:23 - let's explain one more time the
566:25 - algorithm that we are using here in
566:27 - order to determine the biggest number of
566:29 - our array so here in this first line I
566:33 - say that the biggest number is the one
566:36 - with the index zero so the first one and
566:39 - then here we iterate through all of the
566:42 - remaining elements and that is from the
566:45 - one with index one until the last one
566:49 - and if we find that any of those
566:51 - remaining numbers is greater than our
566:54 - Max number then we say that our Max
566:57 - number is equal to that number so at the
567:01 - end of this for Loop we will have in our
567:03 - Max variable the largest number of this
567:07 - array here okay and we have accomplished
567:11 - to get our Min number and then our Max
567:13 - number using these two functions oh I'm
567:18 - sorry so using this get min and then get
567:22 - Max function as well so now what I want
567:25 - to show you is how you can use one
567:28 - function only to get both Min and Max
567:32 - number so let's do that let's create a
567:35 - function which we will name void get min
567:40 - and Max like this and this function is
567:45 - going to receive like these two previous
567:47 - functions our numbers
567:49 - array and the size of the array and then
567:53 - considering that we want to return two
567:55 - values from our function we will have to
567:58 - pass those two values by a reference
568:01 - which means we will have to pass the
568:03 - addresses of the two values and then
568:06 - this function here is going to change
568:08 - the value that is stored on those two
568:11 - addresses and this function here our
568:14 - main function is going to have the
568:16 - access to those two addresses as well so
568:19 - once this function here assigns the
568:22 - value of Min and Max numbers to those
568:25 - two addresses our main function is going
568:27 - to be able to access those values so as
568:31 - I said let's pass to this function as
568:33 - well int Min like this and then
568:38 - int Max so we are receiving here pointer
568:43 - to A Min number and then pointer to a
568:46 - Max number okay so the job of this
568:50 - function will be very similar to the
568:52 - jobs of the two functions that we just
568:55 - created so I will just copy this and
568:58 - then paste it here and once more we are
569:02 - iterating through all of the numbers of
569:04 - our numbers array and then here we say
569:07 - if you find any number which is greater
569:11 - than our Max number and here we have an
569:13 - error which says operand types are
569:16 - incompatible so int and int pointer
569:19 - which means that here we have to D
569:21 - reference this pointer using the star
569:23 - symbol so if you find any number which
569:27 - is greater than our current Max please
569:31 - store that number inside our Max like
569:35 - this and then I'm going to copy this
569:37 - code one more time for our M number so I
569:40 - will say if you find any number which is
569:44 - smaller than our Min number like this
569:48 - Please assign that number to my Min
569:53 - number like this so this is going to be
569:56 - the work that this function will do and
570:00 - considering that this function is
570:02 - receiving these two so Min and Max as
570:05 - pointers this means that this function
570:08 - is directly going to modify the values
570:10 - that are stored on these addresses and
570:14 - those same addresses are going to be
570:16 - available in our main function which
570:19 - means that once this function changes
570:21 - the value vales that are stored on our
570:23 - Max and our Min address this main
570:26 - function here will be able to access
570:29 - those changed values and using pointers
570:33 - in that way we have achieved to return
570:36 - multiple values from our function so
570:40 - let's invoke this get min and Max in
570:43 - order to test what I just said so I'm
570:46 - going to comment these two lines of code
570:48 - because we do not need them anymore and
570:52 - because here we have to pass Min and Max
570:55 - we will have to create those two
570:57 - variables here as well so I will say int
571:01 - Min and as we did before I'm going to
571:04 - assign to this Min the value of my first
571:08 - element like this okay and then I will
571:12 - create Max variable as well and assign
571:15 - to my Max variable value of my first
571:18 - element as well and now let's invoke
571:22 - this get min and Max function so let's
571:25 - say get min and Max and let's pass it
571:29 - parameters that it needs so the first
571:32 - one is numbers array so I will say
571:35 - numbers and then second parameter is
571:37 - size of that array so five and then it
571:41 - expects to receive two pointers so Min
571:45 - and Max and we will have to pass
571:49 - addresses of our Min and then address of
571:52 - our Max as well like this and this here
571:57 - is called passing a parameter using a
572:01 - reference so that means pass an address
572:04 - of a variable to your function rather
572:07 - than passing variable itself because
572:10 - then if you don't pass an address your
572:12 - function is going to create a copy and
572:15 - whatever changes your function makes
572:17 - with that copy you will not be able to
572:19 - see those changes in your main function
572:22 - so in this way we are passing addresses
572:25 - which means that this function here is
572:28 - operating on the original addresses
572:31 - which this function here is accessing as
572:33 - well so when this function here changes
572:37 - the values that are stored on those
572:38 - addresses this function here will know
572:42 - so that means that now if I try to write
572:45 - out oh I will need to add semic colum
572:48 - here at the end okay so that means now
572:52 - if we try to write out our
572:54 - Min like this Min is and then
573:00 - Min and then if we try to write out our
573:04 - Max as
573:06 - well Max we will get um values of Min -2
573:12 - and 29 at least we expect to get those
573:16 - two values if this function is working
573:18 - correctly so if I run my program
573:22 - as you can see we really have values of
573:25 - min-2 let me just um collapse this so we
573:30 - really have values of Min -2 and 29 as
573:34 - the smallest and largest number in our
573:37 - array and we have achieved that using
573:41 - this pass by a reference so by passing
573:44 - addresses of our variables to our
573:46 - function which our function then changes
573:49 - the values that are stored on those
573:50 - addresses and since this main function
573:53 - as well has the access to those same
573:55 - addresses that means that our main
573:57 - function can see the changes that have
573:59 - been made on those addresses so I hope
574:03 - that now you have an idea how to return
574:05 - multiple values from a function using
574:08 - pointers so if you enjoyed this video If
574:10 - you learned something new give it a
574:12 - thumbs up and also subscribe to my
574:14 - channel and I will be publishing more
574:16 - videos related to pointers in the future
574:18 - so if you don't want to miss out on
574:20 - those press Bell icon as well thank you
574:23 - for watching and I'm going to see you in
574:25 - my next video
574:35 - bye hi everyone welcome to my channel my
574:38 - name is Salina and I make it and
574:41 - programming related videos so if that is
574:43 - something that is of interest to you
574:45 - consider subscribing to my channel and
574:47 - give this video a thumbs up as well and
574:50 - in this video I want to talk about
574:52 - Dynamic arrays so you should already be
574:55 - familiar with the idea of arrays and the
574:57 - concept of fixed arrays from my previous
575:00 - videos but for those of you that really
575:02 - want to understand the need for dynamic
575:04 - arrays I will go through some of the
575:07 - advantages and disadvantages of fixed
575:09 - arrays so that you can really understand
575:12 - where the need for dynamic arrays
575:15 - arised so we said that an array is type
575:19 - of collection which stores elements in
575:21 - continuous memory now that means that it
575:24 - stores elements one after the other so
575:28 - if I do this for example if I say let's
575:30 - create an integer array of five elements
575:35 - and let's call that array my array like
575:38 - this your computer in the background
575:41 - will do the following it will give to
575:43 - this array here five containers of type
575:47 - int and those containers will be one
575:50 - after the other in memory so that means
575:53 - because the array stores data in a
575:56 - continuous memory so one after the other
575:58 - accessing that data will be very very
576:01 - fast so because the name of the array is
576:04 - the address of the first element of that
576:06 - array when you specify the name of the
576:08 - array and then you give it the index of
576:11 - the element that you want to access it
576:14 - is going to be very fast to move from
576:16 - that first element until that position
576:18 - that you specified so until the element
576:20 - that has that index whereas if you use
576:24 - some other collection type like linked
576:26 - list for example which stores data in
576:29 - non-continuous memory which means in a
576:32 - random places in memory and then each
576:34 - element contains a pointer to the
576:36 - previous one and to the next one
576:38 - accessing elements in those type of
576:40 - collections would be much slower so if
576:43 - you wanted to access Fifth Element of
576:45 - linked list you would have to Traverse
576:48 - the first four elements and then get to
576:50 - the fifth one because they are stored in
576:53 - noncontinuous memory meaning they are
576:55 - randomly in your memory so as I already
576:59 - said accessing elements of an array is a
577:01 - very very fast operation but because
577:05 - your array stores data in continuous
577:07 - memory this has certain disadvantages as
577:10 - well so what happens if you want to
577:12 - insert or delete an element in the
577:15 - middle of the array for example so how
577:17 - can you insert or delete an element in
577:20 - the middle of the array without breaking
577:22 - that continuousness if I can say it like
577:25 - that so you get the point that means
577:27 - that the operation of inserting and
577:29 - deleting elements in an array is going
577:32 - to be much slower than inserting
577:34 - elements in a linked list for example
577:36 - and if you want me to do a video which
577:38 - is related to differences between linked
577:40 - lists and arrays for example write it in
577:42 - the comments down below and I will make
577:44 - it in the future when I find time so
577:47 - again if you are not familiar with the
577:49 - basics of arrays I recommend you to
577:51 - watch my first video which is related to
577:53 - arrays and pointers which I will link
577:56 - here and then you come back to this one
577:58 - so those were some advantages and
578:00 - disadvantages of arrays and it will be
578:02 - up to you to decide which collection you
578:05 - want to use however here I want to give
578:07 - you the biggest disadvantage or the
578:10 - biggest obstacle that we encountered so
578:12 - far when working with arrays and that is
578:15 - the following so the size of the array
578:18 - had to be constant which means that the
578:21 - size size of the array had to be known
578:23 - before we even started our program so we
578:26 - always kind of wanted to do this so we
578:28 - wanted to say int size and then we
578:32 - wanted to ask our user to enter the size
578:35 - so please enter the size for the array
578:39 - and then after our user enters the size
578:42 - for the array we wanted to create the
578:45 - array that is of that size that our user
578:49 - specified however we get the error as
578:52 - you can see here it says expression must
578:54 - have a constant value which confirms
578:57 - what I just said which is that the size
579:00 - of the array had to be known at compile
579:03 - time so the size of the array could not
579:05 - be changed once we declar it it and we
579:07 - had to declare it before we even started
579:10 - our program so this problem was without
579:12 - solution so far but surprise surprise if
579:16 - you know how to work with Dynamic arrays
579:18 - and dynamic memory you can very easily
579:21 - create an array and runtime so in C++
579:25 - there are two keywords or two commands
579:28 - which allow you to allocate and
579:30 - deallocate dynamic memory which means to
579:33 - get yourself dynamic memory when you
579:35 - need it and then free that memory once
579:38 - you don't so that it can be reused that
579:41 - is what allocate and deallocate means
579:44 - and those two commands are new and
579:47 - delete so new allocates memory as you
579:50 - may guess and then delete deallocates
579:53 - that memory or freeze it once you don't
579:56 - need it so let's see how we can use this
579:58 - information that I just gave you on our
580:01 - example so instead of doing this here I
580:04 - will comment it because we do not need
580:06 - it instead of doing this what I will do
580:09 - is I will create a pointer like this and
580:13 - let's call that pointer my array and
580:16 - what I want to assign to this pointer
580:18 - will be the following I will say please
580:21 - make this pointer point to new integer
580:25 - array and the size of that array will be
580:29 - this size that our user entered like
580:32 - this okay and as you can see our
580:36 - compiler is fine with this expression
580:39 - here we do not have an error so this new
580:43 - keyword has allocated an array of this
580:47 - size that our user has specified and
580:50 - that array aray the address of the first
580:53 - element of that array is stored in this
580:56 - my array pointer so if I build this
581:01 - code as you can see we do not have
581:04 - compile time errors so what I want to
581:06 - show you now is how we can enter
581:09 - elements for this array and then how we
581:11 - can write them out and this is array
581:14 - again this is array which is created at
581:18 - runtime so our user will specify the
581:20 - size of this array which is something
581:22 - that we were not able to do before we
581:25 - learned how to use Dynamic arrays so uh
581:30 - in order to enter elements for this
581:32 - array here as we already know we will be
581:35 - using four Loops so I will say four
581:38 - please iterate from the element which
581:41 - has index zero until you come to the
581:44 - element that has the index of this size
581:49 - okay and then in each iteration
581:51 - increase our count counter by one and
581:54 - what I want to do is I want to write out
581:57 - a message for my user so I will say
582:00 - array and then let's add index of the
582:04 - current element index that our user is
582:06 - entering so I like
582:10 - this okay and then what I want to do is
582:13 - I just want to
582:16 - enter an element on that position that
582:20 - we are current Curr it rating so I will
582:23 - say my array of I like this so using
582:29 - this code here we should be able to
582:31 - enter elements in this array here and
582:34 - then in order to write these elements
582:36 - out what I will do is I will use another
582:39 - for Loop so I will just copy this one
582:42 - and then paste it here and in this
582:44 - particular situation I just want to
582:46 - write out so I will use C out command
582:50 - and and then these other red Direction
582:53 - signs so I just want to write out all
582:55 - the elements of the array and I will add
582:58 - a few empty spaces after each element so
583:01 - that we have a nicely formatted output
583:05 - so this Loop here should write out the
583:07 - elements of our array and if I start
583:10 - this program now as you can see it asks
583:13 - us to enter the size of the array so
583:15 - let's say five for example and now we
583:19 - are we are entering ele with index zero
583:22 - so let's say 2 5 7 9 and let's say 11
583:28 - okay and as you can see here we have the
583:31 - elements of our array written out and we
583:35 - wouldn't be able to do this if we didn't
583:39 - know how to work with Dynamic arrays so
583:42 - let's stop this program and there is one
583:45 - more thing that I want to mention and
583:47 - that is following these square brackets
583:49 - here are only one way to dreference your
583:52 - array another way to dreference the
583:55 - array or to to access the element on a
583:57 - specific position is the following
584:00 - so so the other way to access the
584:04 - element on a specific position would be
584:06 - using this asteris symbol and then here
584:09 - you say my array plus I now because the
584:14 - name of the array is the address of the
584:16 - first element here you have the address
584:18 - of the first element and then when you
584:20 - add a certain number to that it will
584:23 - move that many spaces in memory and then
584:26 - access the element on that position and
584:29 - when you dreference that you will get
584:31 - the value of that element instead of its
584:34 - address so here is one way to dreference
584:38 - your array and then here is another way
584:41 - to dreference your array and you can use
584:43 - whichever one you prefer and if I run
584:45 - this program again just to demonstrate
584:48 - that it works the same let's say three
584:50 - and then one 5 10 okay we get 15 10 as
584:55 - the elements of our array one very
584:59 - important thing that I mentioned at the
585:00 - beginning is that we have two commands
585:03 - for working with dynamic memory and one
585:06 - of those two commands is new so we said
585:09 - that new is a command which will
585:11 - allocate memory for us when we need it
585:14 - and then another one is going to be
585:17 - delete and delete is a command which
585:20 - will de allocate that memory when we do
585:23 - not need it so that it can be reused Now
585:26 - using dynamic memory comes with a
585:29 - responsibility and that responsibility
585:31 - is the following each time that you
585:34 - allocate memory when you need it you
585:36 - will have to deallocate that memory once
585:38 - you don't so that that memory can be
585:41 - reused so that means that each time that
585:44 - you write new command you will have to
585:47 - write delete command once you don't need
585:49 - that memory anymore so I will
585:52 - demonstrate how can you deallocate the
585:55 - memory that we have allocated for this
585:58 - my array so let's say that here in this
586:01 - line of code we do not need our array
586:04 - anymore so how can I deallocate the
586:07 - memory that I allocated for this array
586:09 - well using delete keyword and I will say
586:13 - please delete the memory that I
586:16 - allocated for my array which is called
586:19 - my AR array like this and you have to
586:23 - specify these square brackets because
586:25 - that is the way that you allocated
586:27 - memory so here you said I want new array
586:31 - and then here you have to say please
586:33 - delete that array and a good practice is
586:37 - to do the following as well so you can
586:39 - say my array is equal to
586:43 - null like this and let me collapse this
586:47 - so this here is going to assign the
586:49 - value of null to your array so your
586:51 - array will not point to anything to any
586:54 - address at this line of code so why do
586:57 - we do this because in the previous line
586:59 - of code we have deallocated this array
587:02 - here and now in this line of code here
587:05 - your array will point to a location in
587:08 - memory which does not belong to you so
587:11 - it does not belong to your program and
587:13 - because of that because we do not want
587:15 - to cause some accidental crashes or
587:17 - problems in our program by having this
587:20 - array pointing to memory locations which
587:22 - are not ours anymore it is a good
587:25 - practice to say that our array is now
587:28 - equal to null which means that it is not
587:30 - pointing to anything so as I already
587:34 - said and I repeat again when you use
587:36 - dynamic memory each time that you write
587:39 - new you will have to write the lead that
587:42 - corresponds to that new so here I have
587:44 - allocated an array and here I am
587:47 - deallocating that array so I hope that
587:51 - this video was helpful and that this
587:53 - video helped you understand what are
587:55 - Dynamic arrays and how they work and now
587:58 - that I have explained this it opened the
588:00 - whole world of new possibilities and new
588:03 - things that you can do with Dynamic
588:05 - arrays and I will leave to you to play
588:08 - and discover those new things until my
588:10 - next video of course so thank you for
588:13 - watching this video give it a thumbs up
588:15 - if you liked it subscribe to my channel
588:18 - click the Bell icon as well and I'm
588:20 - going to see you in my next video bye hi
588:23 - everyone welcome to my channel my name
588:25 - is Alina and I make it and programming
588:28 - related videos so if you're interested
588:31 - in those please subscribe to my channel
588:32 - and give this video a thumbs up and in
588:35 - this video I want to talk about a topic
588:38 - that confuses many students and that is
588:41 - the topic of multi-dimensional dynamic
588:43 - arrays and the topics like this one are
588:47 - the reason why many people step away
588:49 - from learning C+ Plus+ and they believe
588:52 - that learning C++ is hard but what I
588:55 - think is that many of those people never
588:57 - actually had the opportunity to have
588:59 - this explained in a very simple way so
589:03 - that is what I will try to do in this
589:05 - video so with the help of excel I will
589:08 - try to draw what are multi-dimensional
589:10 - Dynamic arrays and how they work and I
589:13 - hope that at the end of this video you
589:15 - will have it pretty clear and you will
589:17 - be able to create and work with your own
589:19 - multi-dimension Dynamic arrays so what a
589:22 - multi-dimensional array is in simple
589:25 - words it is array of arrays and in this
589:28 - video you will learn how to create two
589:31 - dimensional Dynamic arrays and in order
589:33 - to be able to understand this topic you
589:36 - should be familiar with the topic of
589:38 - dynamic arrays which is a video that I
589:41 - already did on my channel and I will
589:43 - link it here so make sure to watch that
589:45 - video before watching this one so I will
589:48 - very quickly remind us all of how
589:50 - Dynamic arrays work and then we will see
589:53 - how we can use that knowledge to
589:56 - understand multi-dimensional Dynamic
589:58 - arrays so let's create a visual
590:00 - representation of a dynamic array in our
590:04 - Excel sheet so let's say that it will be
590:06 - array of four elements like this this is
590:10 - our array and the indexes of these
590:12 - elements start with zero and then 1 2 3
590:17 - so these are the indexes and then the
590:19 - address of this first element will be
590:21 - for example
590:23 - 000000 AA like this and this address
590:28 - here it is the address of the first
590:30 - element but it is the address of the
590:32 - array itself as well and you should be
590:35 - familiar with that so this here is our
590:38 - dynamic memory and then on our stack
590:41 - which will be here let's create our
590:44 - stack so this here will be our static
590:46 - memory here we will have to create a
590:49 - pointer variable which will hold the
590:51 - address to this element here or actually
590:55 - the address to the array itself so I
590:58 - will create a variable let's call it PTR
591:00 - 1 so this is going going to be our
591:03 - pointer one and as we already said that
591:05 - pointer will hold the address of the
591:08 - first element of this array let's copy
591:11 - that
591:12 - address like this and then we will store
591:15 - that address in our PTR 1 now if we
591:19 - wanted to create more array way by the
591:21 - knowledge that we have so far we would
591:23 - have to copy this and then let's paste
591:26 - it here and let's create one more array
591:28 - like this so now we have three Dynamic
591:31 - arrays and the first element of the
591:34 - first array has the address of 0 0000 AA
591:38 - and then this one here let's say that it
591:40 - has the address of BB for example and
591:43 - then this one here has the address of
591:46 - 0000 CC and to be able to access these
591:51 - arrays we would have to create on our
591:53 - stack two more pointers so let's do
591:57 - that okay so our pointer 2 will hold the
592:01 - address of the second array which is
592:05 - 0000 BB and then our pointer Tre would
592:08 - hold the address of our third array
592:11 - which is
592:12 - 0000 CC like this now with this we have
592:18 - created three Dynamic arrays and in
592:21 - order to create those three Dynamic
592:22 - arrays we had to create three pointers
592:26 - so those are these three here and this
592:29 - is something that you should already be
592:31 - familiar with so you should already know
592:33 - from my previous video how to create a
592:36 - dynamic array now one thing that I see
592:39 - here and that is a problem is that if we
592:41 - wanted to create four or five or 100 of
592:45 - these Dynamic arrays we would have to
592:47 - create that number of pointers on our
592:49 - stack which means that this part here is
592:52 - not Dynamic only this part here is
592:56 - dynamic because here our user determines
592:58 - how many elements this Dynamic array
593:01 - will have but for each of these Dynamic
593:04 - arrays we have to manually create a
593:07 - pointer on our stack which will hold the
593:09 - address of that array okay now what
593:13 - happens if I want to move this part here
593:16 - to our dynamic memory as well so let's
593:18 - do that let me cut it from here and then
593:22 - I will paste it here for example so now
593:25 - I have moved this part to dynamic memory
593:29 - as well and as you can see here this
593:32 - kind of looks like an array as well so
593:35 - that means that this first element if we
593:38 - look at this as an array the first
593:40 - element will have index of zero and then
593:43 - second will have index of one and then
593:46 - third will have oh this won't move third
593:49 - will have index of two okay so this is
593:54 - an array that has three elements and the
593:58 - first element for example has the
594:00 - address of 00 0 e e e e like this so now
594:07 - this part here is dynamic and then this
594:10 - part here is dynamic and in order to be
594:12 - able to access this array here what we
594:15 - have to do is on our stack which is this
594:19 - part here we will have to create a
594:21 - pointer which will hold the address of
594:24 - this first element so let's do that let
594:27 - me
594:28 - just okay now as I already said on our
594:32 - stack we will have to create a pointer
594:35 - which will hold the address of this
594:37 - first element so let's call that pointer
594:41 - table for example and this table will
594:44 - hold the address of this element here
594:47 - which is 0 0 e e e
594:51 - e and this table because it holds the
594:55 - address it should be a pointer but one
594:58 - thing to keep in mind is that this
595:01 - variable here is not a simple variable
595:04 - but this here is a pointer as well which
595:06 - means that this table will not be a
595:08 - simple pointer but it will be a pointer
595:10 - to a pointer and you indicate that using
595:14 - two ASX symbols because one is just a
595:18 - pointer and then two mean a pointer to a
595:21 - pointer why because this table holds the
595:24 - address of the element which is this one
595:27 - here and that element is pointer as well
595:31 - okay now if we look at this here as you
595:35 - can see we have one array that
595:38 - represents the number of rows that our
595:41 - table will have okay so one 2 3 and then
595:46 - for each one of the elements of this
595:48 - array here we create a separate Dynamic
595:51 - array like this so this here will be our
595:55 - table that has the number of rows that
595:58 - are user defines and then however many
596:00 - columns are user defines as well and in
596:03 - this particular situation it is a table
596:05 - that has three rows so these are three
596:09 - rows and then four columns so let's now
596:13 - translate this to our C++ code and
596:16 - because we said that now our user
596:18 - defines how many rows this table will
596:20 - have and then how many columns as well
596:23 - that is the first thing that I will do
596:25 - so I will create two variables let's
596:28 - call them int rows and columns and then
596:32 - I will ask my user to enter how many
596:35 - rows and how many columns he wants this
596:39 - table to have so let's do that see
596:43 - in
596:45 - rows o and then columns like this okay
596:50 - now after our user has entered how many
596:53 - rows and columns he wants what I want to
596:55 - do now is this part here so this part
596:59 - here this is our first step and then
597:01 - this here is going to be our second step
597:03 - and this part here will be the third
597:06 - step so this part here will be the
597:09 - following when translated to C++ code so
597:12 - here as I already said I create a
597:15 - pointer to a pointer which I will call
597:18 - table so I will say please create an
597:21 - integer pointer to a pointer because
597:24 - here we will store integer values you
597:26 - can create a character or double or
597:29 - float whichever one you want I want to
597:31 - create integer pointer to a pointer and
597:34 - call that table like this okay so we are
597:38 - done with this first part here and then
597:42 - what this table pointer to a pointer
597:44 - will point to is going to be this array
597:46 - here so I will say please create a new
597:49 - in integer array that has this many
597:53 - elements so the number that our user has
597:57 - entered for this rows variable because
598:00 - this rows variable holds how many
598:02 - elements this array here will have but
598:05 - as you can see here we have an error and
598:07 - that error is happening because this
598:10 - here which is this array here is not
598:13 - just a simple integer array but it is
598:16 - array of pointers so here you will have
598:19 - to indicate that so you will have to say
598:21 - please create an integer array of
598:25 - pointers and as you can see now our
598:27 - error has disappeared and with this line
598:30 - of code here we have created this array
598:33 - here now our third step is going to be
598:37 - that for each element of this array here
598:40 - we would have to create a separate
598:43 - Dynamic array so this first element will
598:47 - hold the address of this Dynamic array
598:49 - and then this second element holds the
598:51 - address of this array and then this
598:53 - third the address of this array here so
598:57 - what I will have to do is I will have to
598:59 - iterate through all the elements of this
599:01 - array and for each one I will have to
599:04 - create a separate Dynamic array so let's
599:07 - do that so I will say for in I is equal
599:11 - to zero and then I is less than the
599:14 - number of rows that our user entered and
599:17 - in each iteration increment I so in this
599:21 - particular situation our number of rows
599:23 - is equal to three but you can have as
599:25 - many as you want so what I want to do in
599:29 - each of these iterations is I want to
599:31 - create for each one of these elements a
599:34 - separate Dynamic array so I will say
599:37 - table of I is equal to new integer array
599:44 - that has this many elements and that is
599:48 - the number that we stored in our columns
599:50 - variable like this and with this code
599:53 - here we have successfully created these
599:56 - Dynamic arrays now how do you access
600:00 - elements on a specific position of this
600:03 - table here for example this one or this
600:06 - one or this one so in order to do that
600:09 - let's say for example table of Row one
600:13 - and then column 2 will have the value of
600:17 - 88 now what this could here what this
600:20 - line here will do is the following so
600:23 - this part here it says please give me
600:26 - the table variable which is this one
600:28 - here and it is a pointer to a pointer
600:31 - which holds this address here so 0 0 e e
600:35 - e e and that address is the address of
600:38 - this element here so the address of this
600:41 - array and here we say please give me the
600:44 - element of that array that has index one
600:47 - which is this element here so it is the
600:51 - element that stores the address of 0000
600:54 - BB which is the address of this array
600:58 - here and this second part says please
601:01 - give me the element of that array that
601:04 - has the index of two which is this
601:07 - element here so here we will store the
601:10 - value of 88 so that is what this line of
601:15 - code here will do it will store number
601:17 - 88 to this position position here so
601:21 - this line of code here will store this
601:23 - number at the element that has row index
601:27 - one and column index two of this table
601:30 - so this here is a row with index zero
601:33 - this here is a row with index one and
601:36 - then two so we are storing at this row
601:38 - and then column index two is this one
601:41 - here so here we store number 88 one
601:44 - thing that we said as well in my
601:46 - previous video is that each time that
601:48 - you allocate dynamic memory you have the
601:50 - responsibility to deallocate that memory
601:53 - when you don't need it which means each
601:55 - time that you use new keyword you will
601:58 - have to use delete keyword when you
602:00 - don't need that memory anymore so now is
602:03 - the question how do we deallocate all of
602:06 - this memory that we have taken so in
602:09 - order to do that what I want to do is I
602:11 - want to show you something if for some
602:14 - reason we lose this address here so the
602:17 - value that is stored in this table
602:19 - pointer to a pointer we will never be
602:22 - able to access all of these elements
602:24 - that we have created in our dynamic
602:26 - memory so that means that we will not be
602:29 - deallocating this first and then if we
602:32 - for some reason lost this the value of
602:35 - our 000000 AA for example that means
602:40 - that we would never be able to access
602:42 - this array here so we would never be
602:44 - able to deallocate this memory so that
602:47 - means that this is not going to be
602:49 - deallocated it first as well now
602:51 - allocation of this memory here went as
602:54 - follows this was the first step so this
602:57 - was the first thing that we allocated
602:59 - and it is this code here and then we
603:03 - allocated this so that corresponds to
603:06 - this part here and then the last thing
603:10 - to allocate was these arrays here and
603:13 - that corresponds to this part of the
603:16 - code and the allocation of this memory
603:19 - will go the other way around which means
603:21 - that first we will deallocate this and
603:25 - then we will deallocate this and then
603:27 - this will be the last thing that we will
603:30 - have to worry about now in order to
603:32 - deallocate this the process will be
603:35 - almost the same as the one when we
603:37 - allocated it so I will copy this for
603:40 - Loop and then paste it here but what I
603:44 - want to do in this particular situation
603:46 - so when the allocating is instead of
603:49 - creating a new Dynamic array for each
603:51 - table of I is I want to delete that
603:55 - array so for each element of this array
603:59 - here I want to delete the corresponding
604:01 - Dynamic array so I want to delete these
604:05 - three arrays and in order to do that I
604:08 - will say please delete the array that my
604:12 - table of I is pointing
604:15 - to now what this code here will do is
604:19 - for this element here it will deallocate
604:23 - this array here so let's delete that and
604:27 - then for this element here it will
604:29 - deallocate this array and then for this
604:33 - one it will deallocate this array here
604:37 - so now we have successfully freed this
604:40 - memory that we have taken here now after
604:44 - we have done this after we have
604:46 - successfully deallocated our first step
604:48 - which was here this part here will be
604:51 - our second thing to deallocate so here I
604:54 - will say please delete the array that my
604:58 - table variable is pointing to so this
605:02 - line of code here will deallocate this
605:05 - part here so I will say please delete
605:09 - that we do not need it anymore okay and
605:12 - then our third step which is the last
605:14 - one will be to null this value here why
605:18 - because we have just free the memory
605:20 - that was here so we have deallocated
605:22 - that now someone else might be using
605:25 - this memory here and we really shouldn't
605:28 - keep the address of someone else's
605:30 - memory so we should make this a null
605:34 - value like this and in order to do this
605:37 - in our code I will just say now my table
605:40 - will hold the value of null like this
605:44 - and this will prevent some potential
605:47 - crashes and problems in your application
605:49 - so I hope that this video helped you
605:52 - understand multi-dimensional Dynamic
605:54 - arrays a bit better and if it did please
605:57 - give it a thumbs up and subscribe to my
605:59 - channel because that helps me to reach
606:01 - more people and hopefully make
606:03 - programming a little bit easier for them
606:05 - as well thank you very much for watching
606:08 - and I'm going to see you in my next
606:09 - video bye hi everyone welcome to my
606:13 - channel my name is Alina I'm a software
606:15 - engineer and I make it and programming
606:18 - related videos here in YouTu YouTube and
606:20 - in this video I will be doing something
606:22 - that I haven't done before and that is
606:25 - reviewing your code and we will see some
606:27 - errors that you guys have sent me so I
606:30 - get a lot of messages a lot of questions
606:32 - on my Instagram on Twitter and then here
606:35 - on YouTube as well in the comments where
606:37 - you ask me for an opinion or for advice
606:40 - on certain errors that happen to you in
606:42 - programming and I try to answer as many
606:45 - of those as possible but it's just not
606:48 - possible to answer to all of you and I'm
606:50 - very very sorry but I thought that it
606:53 - would be a good idea to make a video
606:55 - related to that so that all of you can
606:57 - see it so here I am I'm making that
606:59 - video right now so in this video I will
607:01 - be reviewing some code and we will see
607:03 - some errors that can happen and that do
607:05 - happen very often and I'm going to do
607:07 - that both manually and then I want to
607:09 - show you a very cool tool which is
607:11 - called PVS Studio I'm going to leave
607:14 - details in the description down below so
607:15 - that you can check it out for yourself
607:17 - but what PVS studio is
607:20 - it is static code analyzer so it is
607:23 - basically a tool that reviews your code
607:25 - and helps you detect bugs and errors and
607:28 - security weaknesses in your code so in
607:31 - the case that you need another pair of
607:32 - eyes to look at your code and give you a
607:34 - few tips and recommendations it is a
607:37 - great tool to use and you can get it as
607:39 - a team license for teams up to nine
607:41 - people or you can get an Enterprise
607:44 - license for bigger companies bigger
607:46 - departments or you can even request a
607:48 - free license if you are a student if you
607:50 - are working on some private projects or
607:52 - on some open- Source projects and then
607:55 - one very cool thing is that it is not
607:57 - only used to analyze C++ code but you
608:00 - can use it for C and then C and Java as
608:03 - well uh and I wondering guys which team
608:06 - are you in are you team C++ or are you
608:09 - team C or Java or C um I'm very curious
608:12 - to read your answers so please write me
608:15 - in the comments down below and if you
608:17 - ask me I'm definitely team C++ and then
608:19 - team c those are just two of my favorite
608:23 - languages ever but I am very curious to
608:26 - read what you will answer to this
608:28 - question so um I'm going to leave all
608:30 - the details about PVS studio uh in the
608:33 - description of this video so that you
608:34 - can check it out for yourself and let's
608:37 - jump into the coding part right now
608:39 - because I am very very excited to do
608:42 - this here I have created a new project
608:45 - and I have this program that does
608:47 - basically nothing so what I want want to
608:49 - do is I want to check if everything is
608:52 - okay with this code so far so if we have
608:54 - made any errors so far so I'm going to
608:56 - click on extensions and then PVS studio
608:59 - and here you have multiple options you
609:01 - can check your current file you can
609:03 - check open files or you can check your
609:05 - project selected items solution I'm
609:08 - going to select this first option so I'm
609:10 - going to check this current file and you
609:13 - get this window here and as you can see
609:16 - we have one error and that error is that
609:18 - my license will expire in 5 days okay so
609:21 - that is not error which is related to
609:23 - our code so we are just going to ignore
609:25 - it so we don't have code errors so far
609:28 - and let me show you how you can install
609:30 - this tool very quickly so you click on
609:32 - extensions and then manage
609:35 - extensions okay and then here you can
609:38 - search for PVS
609:41 - Studio like this okay great it is this
609:45 - one here so PVS studio is a tool for
609:47 - detecting bugs and security weaknesses
609:50 - and so on okay so you will click
609:53 - download here and your download should
609:55 - begin I'm not going to do that right now
609:57 - because I already have it but once it is
610:00 - downloaded the installation is pretty
610:02 - simple so it's basically next next next
610:05 - finish installation so that should be
610:07 - simple okay now let's close this window
610:10 - here and as you could see we don't have
610:12 - any errors with this code so far so
610:15 - let's write some code and let's create
610:17 - some errors now so so let's create an
610:20 - array of type int and I will call it
610:23 - saved money and that will be array of
610:27 - five elements and I want to initialize
610:29 - those elements here so the purpose of
610:32 - this array is following let's say that I
610:34 - want to save some money each month and I
610:36 - want to store that data in this array
610:39 - here so I'm going to save money for five
610:41 - months and I will store how much money I
610:43 - have saved each month inside this array
610:46 - here so for example the first month I
610:48 - have saved
610:49 - $100 or Euros or whatever and then
610:53 - second month I have saved 200 and then
610:56 - 300 and 400 and 500 fifth month okay so
611:01 - this is our array now what I want to do
611:04 - with this data here is I want to Summit
611:07 - after 5 months I want to know how much
611:09 - money I have saved in total so I'm going
611:11 - to create a variable of type int and I
611:14 - will call it total like this and I will
611:18 - initially give give it a value of zero
611:21 - and then I will iterate through this
611:23 - array here so I will say for INT I is
611:27 - equal to zero and then I is less than or
611:30 - equal to 5 and then I ++ and what I will
611:35 - do inside this for Loop is I will say
611:38 - that my total will hold whatever my
611:41 - total was previously
611:42 - holding plus current value of how much
611:47 - money I have saved in that month so
611:49 - saved money off I okay now after I have
611:53 - done this I will just write out how much
611:56 - money I have in total so I will say
611:59 - total and
612:01 - then this value that is stored inside
612:04 - this variable here okay now if I run
612:08 - this program let's see what will happen
612:11 - well it says that in total I have minus
612:15 - 8 billion something very very big number
612:18 - so I have tried to save each month and
612:20 - then at the end I have minus8 billion
612:24 - dollar you know so that does not make
612:26 - any sense so here we have a logical
612:28 - error okay so let's see what is this
612:31 - error that is happening so let's click
612:34 - on extensions and PVS Studio check
612:37 - current file to see what kind of error
612:39 - PVS Studio sees and it says array over
612:43 - run is possible the value of I index
612:46 - could reach five and if I double click
612:48 - on that it will take me here and this
612:52 - part of code here is underlined and this
612:54 - is actually our compiler our compiler is
612:56 - underlying this and it says that okay it
612:59 - says index 5 is out of valid index range
613:03 - of 0 to four so this here this situation
613:07 - here says that this I is out of range of
613:11 - valid indexes that this array here can
613:14 - have and if you are familiar with arrays
613:16 - you know that indexing of an array
613:18 - starts zero so the first element has
613:21 - index of zero and then 1 2 3 and four so
613:25 - valid indexes for this array here are
613:28 - from 0o to four and here we have
613:31 - accidentally written that this I is less
613:34 - than or equal to five and that is making
613:37 - a problem so if I delete this part here
613:40 - so if I say that my I is just less than
613:44 - five this error should disappear so if I
613:47 - click on PVS 2 studio and then check
613:50 - current
613:51 - file the error should disappear okay it
613:55 - has disappeared now so if I run my
613:59 - program this program is behaving as
614:02 - expected so this is one thing that very
614:05 - often happens you can accidentally write
614:07 - less than or equal to and then you can
614:10 - get a very very big logical error
614:12 - another thing that can happen is if
614:15 - you're typing very quickly and if you
614:16 - lose concentration for a moment and and
614:19 - here instead of incrementing you
614:21 - decrement this counter so you say I
614:23 - minus minus you should get an error as
614:26 - well so if I try to build this program
614:30 - let's see what our compiler will tell us
614:32 - so here in this error list it says ill
614:35 - defined for Loop counts down from
614:37 - minimum so that's kind of helpful um
614:40 - information and then another let's read
614:43 - this other warning it says reading
614:45 - invalid data from Saved memory the
614:47 - readable size is 20 bytes but minus 4
614:50 - bytes maybe read so this is not really
614:52 - help helpful for someone who's just
614:54 - starting and then this third message it
614:57 - says index minus 2 billion something is
615:00 - out of valid index range 0 to 4 again
615:03 - this is not really helpful for someone
615:05 - who is just starting so uh let's see
615:08 - what our PVS Studio has to say so I'm
615:10 - going to click extensions PVS Studio
615:12 - check current
615:14 - file okay
615:16 - and this first error here here says the
615:20 - condition I less than 5 of for Loop is
615:23 - always true so this is actually a
615:26 - helpful message and if I click on this I
615:29 - will be taken here and it says that this
615:32 - condition here I is less than five is
615:34 - always true but why is it always true
615:37 - because we have started counting at zero
615:40 - and then we try to decrement that value
615:43 - in each iteration and uh doing that we
615:46 - can never reach this condition here this
615:49 - condition here will never become false
615:51 - so that means that here we have created
615:53 - an infinite Loop and here our PVS Studio
615:57 - says consider inspecting this for
615:59 - operators so consider inspecting this
616:01 - for Loop here because it will not be
616:04 - executed at all or it can be executed
616:07 - incorrectly and in this particular
616:08 - situation it is going to be executed
616:11 - incorrectly so it is going to be an
616:13 - infinite Loop which we don't want in
616:16 - this particular situation so I'm going
616:18 - to correct this error here so I'm going
616:20 - to return it to
616:21 - i++ but that is sort of a help that you
616:24 - can get from PVS studio and this here is
616:27 - a pretty simple program because it has
616:29 - just a few lines of code where all the
616:31 - bugs can potentially happen but imagine
616:34 - working on a very very big project and
616:37 - then something like this happens so
616:39 - imagine something like this happening uh
616:41 - on a program that a bank uses so you are
616:44 - trying to save money for a couple of
616:45 - months and then the program says that
616:47 - you are in depth that your balance is
616:49 - minus 2,000 or 20,000 or something like
616:53 - this so this can create very very big
616:56 - issues and in this particular situation
616:58 - if you have a bug like this you will
617:01 - want to have all the help that you can
617:03 - get and sometimes that can be uh just
617:06 - the help that you get from your compiler
617:08 - or if you have a very very big problem
617:10 - you will definitely benefit from tools
617:12 - like PVS Studio which will give you some
617:14 - additional information on that situation
617:17 - that is happening and on that problem
617:18 - that you you are having and then there
617:20 - are other situations where you can have
617:22 - very very big problems but your compiler
617:25 - will not be helpful at all because your
617:27 - compiler will not be able to see those
617:30 - potential bugs that you are creating
617:31 - inside your code so in order to
617:33 - demonstrate that let's delete all of
617:35 - this code here because I will not need
617:38 - it anymore and what I do need is to
617:41 - create a function here so let's create a
617:44 - function of return type void and I'm
617:46 - going to call it my
617:50 - function like this okay and what I want
617:54 - to do inside this function is I want to
617:56 - create an integer pointer PTR so if
618:00 - you're not familiar with the topic of
618:02 - pointers make sure to watch the playlist
618:04 - that I will link here it is the playlist
618:06 - where I explain pointers in C++ because
618:09 - it is one of the most important topics
618:10 - in C++ and it is the example that I will
618:14 - be using here so I have created an
618:17 - integer pointer and I'm going to say now
618:20 - you will point to a new array of
618:24 - integers and that array will have five
618:27 - elements like this now what do I want to
618:30 - do with this array well let's do
618:33 - something very simple let's say
618:35 - PTR of two will hold the value okay it
618:39 - will hold the value of 10 like this and
618:42 - then let's just write out something
618:44 - let's say hi I am equal to and then PTR
618:51 - of two okay so this here is pretty
618:55 - simple example that does basically
618:57 - nothing important nothing useful but I
618:59 - will use it to demonstrate a very very
619:01 - big issue that can happen in this
619:03 - situation so I'm going to invoke this
619:07 - function here so I'm going to say my
619:09 - function like this and I have
619:13 - successfully invoked this function so if
619:16 - I run this program
619:21 - it says hi I am 10 so nothing unexpected
619:25 - happened or did
619:27 - it okay um if I inspect my errors list
619:32 - it says that I don't have any errors so
619:36 - if you ask a compiler it will tell you
619:38 - that everything is perfectly fine so
619:40 - let's now ask PVS Studio here it has
619:43 - already detected two potential issues
619:45 - but you can click PVS studio and then
619:47 - check current file just to be
619:49 - sure okay and it says visibility scope
619:55 - of the PTR pointer was exited without
619:58 - releasing the memory a memory leak is
620:01 - possible so what we have done here in
620:03 - this program is we have created memory
620:06 - leak
620:08 - where here so here we have said please
620:13 - give me in my dynamic memory give me
620:15 - array of five integers and this is going
620:19 - to be done in dynamic memory so once
620:23 - this function is finished once this
620:25 - function ends we are going to lose this
620:27 - PTR so we are going to lose the address
620:30 - of the first element of this array here
620:33 - so here if I try to do something like
620:36 - PTR I cannot access this variable here
620:40 - anymore this variable has its scope and
620:42 - that scope is inside this function here
620:45 - and once this function exits we are
620:48 - going to lose the address of this array
620:50 - here which means that we will not be
620:53 - able to deallocate this memory here now
620:56 - let's delete this okay here as you can
620:59 - see this memory leak is not a big memory
621:02 - leak here we are leaking five integers
621:05 - so we are leaking an array of five
621:07 - integers and that is not very big
621:09 - problem but usually what happens in real
621:12 - life is that you are not creating an
621:14 - array of five integers usually you are
621:16 - creating things that require much more
621:18 - memory than just an integer array of
621:21 - five elements so here as I said we are
621:24 - leaking five integers but imagine a
621:26 - situation where you are creating an
621:28 - array of 5,000 or 50,000 and not
621:32 - integers but objects of type user like
621:36 - this and this user has some pretty heavy
621:39 - data in it for example it has some
621:41 - images and things like that so here you
621:43 - are creating 50,000 users and to make
621:47 - things worse imagine not invoking this
621:49 - function only once but imagine invoking
621:52 - this function in a for Loop for example
621:55 - so invoking it 100 times or 1,000 times
621:59 - or 100,000 times that is going to be a
622:02 - huge memory leak so what this line of
622:05 - code here does is it asks your operating
622:08 - system for dynamic memory so it says
622:11 - please can you give me new memory so can
622:14 - you give me dynamic memory that I need
622:17 - to store this data here and your
622:20 - operating system gives that memory to
622:22 - your program so it allocates that memory
622:24 - for your program and then once this
622:27 - function here finishes you will lose all
622:30 - the variables that you have created
622:32 - inside that function and that is this
622:34 - PTR variable here so that means that the
622:37 - address of this array here which was
622:40 - stored inside this PTR variable is lost
622:44 - now and now you will not be able to
622:46 - deallocate this memory here which means
622:49 - that you will not be able to say okay
622:51 - now I am done with this memory which is
622:54 - a lot of memory and now I'm going to
622:56 - return that back to my operating system
622:59 - because I don't have unlimited amounts
623:01 - of memory and my operating system maybe
623:03 - would like to give that memory to some
623:05 - other program so once this function here
623:08 - ends and you don't deallocate this
623:11 - memory here you are leaking that memory
623:14 - and that is exactly the error that you
623:17 - have here it says a memory leak is
623:19 - possible whereas your compiler here said
623:23 - expected a type specifier which is U
623:25 - error that we have here because it does
623:27 - not know what is this user so I'm going
623:29 - to return this back to int okay now that
623:32 - error has disappeared but your compiler
623:34 - does not know that you are leaking
623:36 - memory here whereas your PVS Studio
623:39 - analyzer here says that a memory leak is
623:42 - happening so how do you fix this error
623:46 - here well for each new you need to have
623:51 - delete again you need to watch my C++
623:54 - pointers playlist in order to understand
623:56 - pointers if you don't understand this
623:58 - already so as I said for each new you
624:01 - need to have delete so I'm going to say
624:03 - delete and let's delete this PTR let's
624:06 - see what is going to happen now so if I
624:08 - click extensions and then PVS Studio
624:10 - check current file it says the memory
624:14 - was allocated using new array type
624:17 - operator but it was released using
624:19 - delete operator and then it gives you a
624:22 - recommendation here it says use delete
624:25 - array pointer it set instead so here we
624:28 - are trying to allocate memory for an
624:30 - array but we are not deleting that
624:32 - entire array so here we are leaking
624:34 - memory again so here I'm going to use
624:37 - these square brackets in order to
624:38 - indicate that I want to delete this
624:41 - entire array that I have allocated in
624:44 - this line of code here so now we
624:46 - shouldn't be leaking memory anymore so
624:49 - let's check that out I'm going to say
624:50 - PVS Studio check current file and let's
624:55 - see we have that error that we
624:58 - previously had which is your license
624:59 - will expire in 5 days but we do not have
625:02 - memory leaks anymore which is great so
625:05 - errors like this memory leaks are very
625:07 - common when you work with pointers in
625:09 - C++ and these memory leaks can create
625:12 - huge problems if you have them in your
625:14 - code and as you could already see in
625:16 - most cases you cannot really on your
625:18 - compiler to tell you that you are
625:21 - leaking memory because in most cases it
625:22 - will not even be able to see that so
625:25 - tools like PVS Studio can be very
625:28 - helpful in those situations you could
625:30 - see all those little tips and
625:32 - recommendations that we had from PVS
625:35 - Studio that helped us to fix issues that
625:38 - we had related to leaking memory so
625:41 - those were some topics that I wanted to
625:42 - address in this video because many
625:44 - people when working with pointers will
625:46 - come across problems that they will not
625:49 - be able to fix or they will not even be
625:51 - aware that they have those problems that
625:53 - they have memory leaks until it gets to
625:56 - the point where it is unmanageable and
625:59 - they have very big problem they have
626:01 - huge problem so um if you have any more
626:04 - questions that you would like me to make
626:06 - video on please leave those in the
626:08 - comments down below and if you like this
626:10 - type of video please give this video a
626:12 - thumbs up so that I can know and I will
626:15 - make more videos like this in the future
626:17 - if you want me to so thank you very much
626:19 - for watching this video and I am going
626:21 - to see you in my next video
626:25 - bye hi everyone
626:29 - [Music]
626:31 - well okay so hi everyone welcome to my
626:35 - channel welcome to another
626:37 - [Music]
626:38 - [Applause]
626:43 - [Music]
626:57 - hi
626:58 - everyone Hi everyone welcome
627:02 - to Welcome to my
627:05 - channel so this here is the
627:08 - initialization step of our
627:11 - initialization
627:14 - initialization in
627:28 - initialization
627:33 - initialization so it is the in in