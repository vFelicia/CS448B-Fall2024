in this video we're going to learn exactly why we need a CI pipeline in a software development process and how to build one that automatically checks your application code quality and automatically suggests fixes for any issues that it discovers in your code and if you're a software developer this knowledge is going to be absolutely valuable and useful in your engineering job so make sure to stay till the end and work through the entire demo and with that let's get right in let's say you are in a team of software developers and you're working on a specific feature and the git workflow that your team is using is trunk based development which is a standard workflow in today's modern develops driven development so you always have the main branch in a releasable state that triggers an automated cicd pipeline whenever code changes are pushed into the main branch so you have a fully streamlined release Pipeline with no bottlenecks meaning no manual intervention at any stage of the pipeline that deploys all the way to at least the dev environment and if you have really good test coverage maybe to the staging or even prod environment without any manual testing or code checks in the process but for this to work work you need to have lots of tests to make sure what you are committing to your main branch can be deployed and released to the end users so various tests should be run to test different aspects of the code changes that are about to be deployed now what are those tests that we want to run in this release pipeline you will have unit tests or integration tests that test your code logic with different inputs and parameters to make sure that it's able to handle different scenarios you may have security tests to scan all your dependencies and libraries for known issues or scan your code for any hardcoded secret data or any security best practices in logic which you actually learn this set of security scans and tests in our depops boot camp where we go into detail how to test various security aspects of your application from code to Docker image Etc and then finally you also have code quality tests so your application code may be working so the functionality is fine it may be even secure but your code quality may be bad or unmaintainable let's say you have lots of code duplications because instead of putting things into function you are just duplicating the logic in multiple places which is a bad practice or maybe you are using old apis old library versions maybe you have introduced risk for nullo exceptions in your jav application maybe you don't have a good test coverage for your code so these are the tests for your code quality and the code quality test is what we're going to see in the demo in this video using kadana which is super easy and really good tool to validate various aspects of your code so important to note here that trunkbased g workflow is usually an ideal workflow to use especially in devops driven projects however in practice a lot of teams actually use a different G workflow which is called a feature Branch workflow the core idea behind the feature Branch workflow is that all feature Branch development should take place in a dedicated Branch instead of the main branch and this way multiple developers or Engineers can work on a specific feature without interfering with the main code base so you create a fature branch and make your changes there and when you're ready to merge you create merge request and all the tests will run on the merge request to act as a gatekeeper and decide whether the changes should be merged into the main meaning whether those code changes are even in a releasable state that's why we want to run those tests on merge requests before the code even ends up in the main branch because imagine your code merged into the main branch and then the tests ran and they failed because your code had issues so those issues were discovered and the pipeline failed but other developer also merged their code changes and they had just one or two issues but now even if they fix their own issues their code changes cannot be released because your broken code is also in the main branch so it will block all other code changes from going to the development until you fix your code issues and that's why we want to run tests on the merge request instead of merging it into Main and then running the tests now imagine feature development takes longer and you have tens of commits now you're done your feature works you have tested it a little bit manually and now you're ready to merge it into the main and you create a merge request which triggers all the tests and so on and those tests detect a ton of issues that you have introduced so your code works but you copy paste did some code snippet from internet with very bad coding practice and even added some security issues to the application now you have to go and spend probably hours or days figuring out how to fix those issues maybe you built the whole logic with this library that is outdated or has known issues so now you have to start over find a new library and write logic with a new library test it again and so on but you could have saved yourself all the time if you tested your code changes right away on the very first commit instead of collecting those commits and then running tests later on the merge request so what if you had those tests running even before the merge request on every single commit in the feature Branch so you introduce a library committed the changes and immediately saw through the code scan that this library has issues then you made another change again commit and Trigger pipeline it will run test to see if if your code changes are fine if not you can fix the issue right away and move on to the next one and especially as a junior engineer this actually lets you learn so much of programming best practices while you're developing because it gives you this feedback loop of what you are doing wrong and that process of committing small code changes frequently and running tests and scans on them to identify issues is called continuous integration or CI and the pipeline that runs those tests in order to discover any issues is called a CI Pipeline and it is a best practice to build CI pipelines for feature branches so you aren't deploying anything in the feature Branch obviously there's no CD continuous deployment you're just testing your code changes for any issues frequently to fix them early enough and you also saw that we kept moving those tests earlier and earlier in the development process which is a a general concept of Shifting left or shifting automated testing left and guess what there is even an option to find code issues even earlier than in the CI pipeline of a feature Branch you already have this on your local computer as a developer when you use intellig ID for example that has builtin code checks that show you while you developing if you have written a dirty code which can be cleaned up and made better or more effici or if you just created a code duplication and those builtin inspections will even give you Auto suggestion to let's say update the library version to the latest or remove the code duplication and so on or if you have any linter extensions with whatever code editor you're using you can also have that locally in your development environment now of course we can assume that some developers May ignore those highlights that ID is showing or they may not even know how to use those Auto suggestions and that's why we want to have those tests in the pipeline to run automatically because we don't want to rely on individual developers doing everything correctly on their local machine so we want to centralize this process and automate it and that's why say pipelines are so important so you notice that we have multiple places where the code issues will be detected starting from local ID to fiture Branch CA pipeline merge request Pipeline and even when the code gets merged into the main branch it will run the same code scans and automated tests again because as I said what if other Engineers merged their code changes before us maybe there is an issue between that new code and ours so we want to check on every step great now that we understand what CIP PIP plan is and why it's so important let's build one to Showcase how we can Implement a fully automated code quality checks for the demo we're going to use GitHub actions as our CI server to execute the code quality checks and for the code analysis itself we will use a tool called kadana as I mentioned which has really good code quality checks and is really easy to get started with so just to give you a quick overview of how it works and how those automated code quality scans will be done as I mentioned Ides like intellig actually all IDs from jet brains have this builtin inspect s that automatically scan the code file by file and identify any code issues and show them in the editor and even suggest fixes automatically and essentially we want to have exactly the same thing but in a centralized place like Ci Pipeline and kadana which was also created by jet brains is using the same mechanism and inspections that are built in the IDS so it runs those inspections and identifies any code issues and as a bonus imagine you could fix those code issues automatically in the pipeline so those Auto suggested fixes can be applied in the pipeline where we can tell kadana to actually create a merge request from the automatically suggested fixes which then you or an experienced engineer can review and merge it into the fidget Branch to fix all those code issues so we're basically automating the code quality fixes and of course we want this to work for different programming languages and usually you would have dedicated tools for different programming languages good thing about kodana and convenient thing is actually that you can use it for basically all the popular languages like Java JavaScript Python and so on so you don't have to switch between different tools so this is an opensource project on GitHub which I have forked in my own account so that we can make some changes run a pipeline and so on and I have this project open in my intellig ID so we're going to make the changes directly here and there are two things that we need to do to run the pipeline with code quality checks using kadana these are two easy steps the first one is to create a GitHub workflow I have removed all the workflows from the existing project so we can create our own one and just focus on that single workflow so we're going to create a GitHub actions workflow right here for the CI pipeline that will run those code quality checks and the second thing is that we need to create a kadana configuration file called kadana yl that we will pass to that CI pipeline that's it super simple to get started with this and to build our C pipeline for code quality checks starting with kadana yl since we are in intellig we actually have kadana tool and all these configuration options built in in the ID so tools and kadana and if I click on this option right here to try run kadana locally we get this autogenerated kadana yl file so we can either copy this whole thing or it will just automatically save it in the kodana yl file right there which is pretty convenient because we don't have to look up the boiler plate configuration we will leave everything as it is except for one change which is the profile here profile is basically a group of inspections that I mentioned like in ide if we go to settings and look for inspections you have the list of the inspections for different languages different databases plus HTML and so on and they are kind of grouped in a profile and you can create your own profiles in intell but it comes with a default profile and this this is the same concept because it uses the same mechanism kodana developers created a couple of profiles that you can choose from so if I remove this we actually have those three options and depending on how deeply you want to go and how detailed analyses you want to do you can choose different profiles there's a starter one which is checking the most obvious issues it's kind of lighter version doesn't go really deep into the code and then we have the recommended one which will execute way more inspection against our code so it will of course detect more issues so let's choose this one actually also the name suggests that it's the recommended one from kadana developers and that's our kadana yl configuration right here you see the linter which basically is referencing a Docker image that will be used to execute the analysis on all the Java related files and configuration if you had a JavaScript project then you would use another linter which is for JavaScript and you can actually see all these images in dockerhub we can search for kadana JavaScript jvm PHP Python and so on so if you had a JavaScript project you would simply use the kadana JS linter which will analyze JavaScript or typescript code so let's set it back to jbm kadana yaml configuration is ready and now we can also let intellig generate code for kadana skin in a CI pipeline so what happens if I click here we actually get options for different cicd tools like GitHub actions gitlab cicd team CD and so on so you can choose whichever cicd pipeline you'll be running since our code is on GitHub we're going to be using GitHub actions of course so that's the code we need and again I'm going to just edit directly to the project and right here we have kodana code quality. yl so that's also pretty convenient that we get the configuration for CI pipeline from the ID so we don't have to write it from scratch and it of course automatically uses the kadana action for GitHub actions which behind the scenes is executing all the kadana scans and by the way if you're new to GitHub actions I actually have a separate complete course on GitHub actions the architecture the syntax how to write pipeline jobs everything in detail explain there so if you want to understand all these syntax then you can actually watch that video but essentially what we're doing is that we're defining that whenever someone pushes to the master branch which is the main branch of this repository or there's a pull request then we want to execute or trigger this workflow and I'm actually going to specify here to trick bigger the workflow every time there is a pull request to be merge into the master Branch or the main branch and in the job section we just have one job called kadana which runs in Ubuntu environment and it has two steps one of them is just standard action to check out the code because it needs the entire code so that it can analyze all the files in the code and the second one is the actual kadana scan which is using kadana action from G actions with a specific version tag and notice that we also have this token or a secret token here as environment variable that is passed to the kadana skin so what is this about so the thing is it's great to run code checks and automated tests to identify any issues but let's say we have 50 issues that were identified going through them in logs is not going to be convenient when we run automated tests or code scans we always want to use a visualization tool with a UI where we can see the issues in a nice overview per file with description maybe with a suggestion on how to fix it we want to be able to sort it based on the level of severity like how severe the issue is is it critical is it low minor issue and so on and there are such tools where you can import the test results in case of kadana it's actually simpler because it comes with its own cloud platform with a UI where we can see the code issues that were discovered with kadana scan so we can connect our project to kadana cloud and it will automatically upload the results of each pipeline run or each job execution of the project to kadana Cloud so we can see the results there and it's very simple to do as well the way we do that is we go to kadana cloud and create just an empty team and as you see I don't have any projects here I'm going to create a project and all I need to do here is basically just drop in the htps URL of the project so I'm going to copy it from here next and there you go so now I have connected my project to kadana Cloud so kodana Cloud knows about the project but I also need to tell GitHub about kadana Cloud so that it will send the results of workflow execution to kadana so it needs to be a twoway connection and that's why we need the token that is displayed right here so I'm going to copy that so that's the token and that's exactly what is referenced right here and in GitHub actions the way you create environment variables which are sensitive data or secret is very simple we just go to settings and then here we have secrets and variables for GitHub actions and we just create a new repository secret I'm going to paste in the token from here and we're going to call this kadana token which is referenced right here so this way GitHub will have an ex's credential basically of kadana cloud to authenticate with it and send the kadana scan execution results which will be displayed in kadana Cloud so I'm going to add the secret and that's it we have configured our pipeline we have our code scan so now I'm just going to commit these changes I'm going to use a terminal from here and let's push the change so now there you go you see that the workflow was automatically trigger and inside that we have kadana job that will run kadana skin that is using this jvm image let's wait for this to complete and we will see the results so our job has completed and as you see it was successful let's check the logs first of all and right here we see the summary of the scan we have 91 problems detected with different severity levels and and these are some of the issues but as I said checking the issues in the logs is actually pretty inconvenient so we want to have a nice UI overview the first one we get is within the GitHub itself so if I jump in right here we have the UI visualization of the issues again with different severity levels so it has detected invalid EML configuration with 47 problems but of course we want to see details of where each one of those issues are coming from which file it is what is the issue and so on and you also have them here in a long list but as I mentioned we want to check kodana cloud and we have this link to detailed kodana report conveniently so if I click on this as you see we have a nice display of all the issues right here and these are actually coming from this view the project that we connected now shows an overview of the last run of the pipeline so every time we run the pipeline it will actually save those runs here and we also see that 661 different inspections were done and all these problems were discovered and we can actually click inside each issue and see exactly which file it comes from what the issue is we can also filter let's say we want to see those High severity issues so now you see a more diverse set of issues like visibility issues where a class is exposed outside of defined scope or configuration property cannot be resolved some improvement suggestions in the code like this one here that doesn't check is present before it calls optional doget method and all these other issues so now of course you can go through each issue one by one and try to resolve it in many cases try to understand whether it is an actual severe issue or not so again if I zoom out we have some moderate problems and let's go to moderate problems and we have some code duplications here and so on and finally we want to configure that autofix feature that kadana offers which I personally find really cool so I want to show you how it works and it's actually a pretty easy configuration all we need to do is set some parameters on our kadana job to the kadana action so I'm going to paste in the configuration so we're going to execute this codon action with argument apply fixes and those fixes will be pushed as a pull request in our repository and we have this attribute called PR mode here that we are setting to false so PR mode basically defines whether only the changed files should be analyz in the poll request and by default it's set to true so we're going to set it to false to analyze not only the changed files and by the way you can actually find all these configuration options in the kodana documentation as well so for GitHub actions you have these arguments here including PR mode push fixes so you can see here what other configuration options are available and in order to allow this job to actually create a poll request in the repository we're going to give it permissions or write permissions to create the poll request and alternatively you can actually configure this Auto F directly in kodana yl configuration file it's called fixes strategy and we have these options we're going to choose apply so we're telling kadana to actually go ahead and apply those automated fixes that it suggests and for this feature we're going to use a specific image version instead of the latest and now let's see how that works I'm going to commit this h autofix and this should trigger the pipeline and as you see after a pipeline execution a new pull request was actually created by kadana which has code changes to fix those issues that detected like making some variables final or getting rid of the if statement where it was not needed it actually removed some comments from the code as well and in some other comments it made the link a clickable link we also have this Java file where it actually imported a library called lombok to use Setter and getter annotations instead of writing the setter and getter like this which again makes the code cleaner another example of using lombok it added some null checks to the parameters and again as I said if you are a junior developer usually the workflow would be that you or another engineer in your team will go through these Autos suggested fixes and you can Implement them or merge them into your code now again as I explained at the very beginning This would run in a feature Branch to scan your commit in the feature branch and kadana will create the pull request to merge into the feature Branch again so all of this is happening before the code even gets to the main branch so that's basically how all this works and if I refresh this you see that another column was added with the list of issues so you kind of build up a history of how many issues were discovered whether it's declining or it's increasing so you'll have all those code scan runs list it right here for a nice overview so that's basically how you create a CI pipeline that will completely scan your code and identify any code quality issues and even give you fixed suggestions that you can directly merge back into your code now I hope this tutorial actually helped you to really understand why CI pipeline is needed and as one of the steps that we execute in the CI pipeline which is code quality check how we integrate a tool like kadana or basically any other tool in your CI workflow to give you a feedback loop and help you maintain good quality of your code especially if you have a large team and everyone's doing their own thing and you have Junior Engineers who are committing their own changes so you have this centralized automated process or workflow to help each engineer keep their code changes in check instead of having all the senior Engineers checking the code that that Junior Engineers are committing but if you want to dive deeper and start building real life devops pipelines for releasing your applications I actually have a complete gleb cicd course on it which I have Linked In the video description so if you're interested you can check it out there let me know if this was helpful for you in your daily engineering work and with that thank you for watching and see you in the next video