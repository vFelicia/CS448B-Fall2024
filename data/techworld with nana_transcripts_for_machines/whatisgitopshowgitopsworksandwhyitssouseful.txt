in this video we're going to talk about what is githubs and why it became so popular the short explanation of git ups is infrastructure is code done right with all the best practices now let's see a bit longer explanation so it all starts with infrastructure as code as you know the infrastructure's code concept is when you define your infrastructure as code instead of manually creating it this makes our infrastructure much easier to reproduce and replicate but note that infrastructure's code actually evolved into defining not only infrastructure but also network as code or policy as code and configuration is called etc so it's not only about infrastructure anymore these are all types of definitions as code or as they also call it xs code so in x as code unified infrastructure and configuration network and so on in code so for example instead of manually creating servers and network and all the configuration around it on aws and creating kubernetes cluster with certain components you define all of these in a terraform code or insible code and kubernetes manifest files and you have a bunch of yaml files or other definition files that describe your infrastructure your platform and its configuration now how do many engineering teams write and use infrastructure as code or x as code you as a devops engineer will probably create all these files locally on your machine you try to test it and once done execute them also from your computer so all these files are actually stored locally on your computer or you may even create a git repository for your infrastructures code and store all these files on git so you have a version control for your infrastructure code and other team members can fetch the code as well and collaborate but when you make any changes to the code you may not have a defined procedure like pull requests you may just have a main branch and when you change the code you commit it directly into the main branch as well as if someone else in the team changes code they can commit directly into the main branch so no code reviews no collaboration on the changes also when you commit your infrastructure's code changes into the repository no automated tests are running to test these code changes maybe you committed invalid yaml files or maybe you made a typo and the attribute names are wrong or maybe your code changes will break something in the infrastructure or your application environment now once you make the changes how do you apply these changes on the actual infrastructure or a platform how do you execute them you'll do it manually from your laptop you will do cube ctl apply or execute terraform or instable command etc so to execute the code changes each team member must access the kubernetes cluster or aws infrastructure and apply changes there from their local machine and this can make it hard to trace who executed what on the remote servers and have a history of changes applied to the infrastructure and if you made any mistakes in the code wrong configuration wrong attributes you will know about these problems only once you apply them so untested config changes end up in the development environment where you can then test whether you broke something or not and after manually testing the changes on the development environment you will then also from your local computer apply the same changes to the staging and then production environments so even though we have an infrastructures code which already has lots of benefits our process is still mostly manual and inefficient so that's where github's concept comes in to basically treat the infrastructure as code the same way as the application code so in github's practice we have a separate repository for the infrastructure is code project or xs code project and a full devops pipeline for it so let's see how this works and more importantly why is it so useful with github's infrastructure as code is hosted on a git repository where it's version controlled and allows team collaboration that's the first step now when you make changes instead of just pushing to the main branch you go through the same pull request process as for your application code so anyone in the team including junior engineers can create a pull request make changes to the code and collaborate with other team members on that pull request for these changes you will have a ci pipeline that will validate the config files and test them just like you test application code changes after testing these commits other team members can approve the final changes this could be developers or security professionals or other senior operations engineers who will review and approve the pull request this way you have a tested wellreviewed config changes before they get applied in any environment so only after that changes will be merged back into the main branch and through a cd pipeline get deployed to the environment whether it's changing something in kubernetes cluster or updating the underlying aws infrastructure so you have an automated process which is more transparent and produces high quality infrastructure or configuration code where multiple people collaborate on the change and things get tested rather than one engineer doing all the stuff from their laptop manually that others don't see or can't review now we said that once merged into the main branch the changes will be automatically applied to the infrastructure through a cd pipeline right in githubs we have two ways of applying these changes these are push or pull based deployments pushbased deployments is what we traditionally know from the application pipeline on jenkins or gitlab cicd etc application is built and pipeline executes a command to deploy the new application version into the environment so what is a pool model here you have an agent installed in the environment like in kubernetes cluster that actively pulls the changes from the git repository itself the agent will check regularly what is the state of the infrastructure code in the repository and compare it to the actual state in the environment where it's running if it sees there is a difference in the repository it will pull and apply these changes to get the environment from the actual state to the desired state defined in the repository examples of git ops tools that work with the pool base model are flux cd and argo cd which run inside kubernetes cluster and sync the changes from the git repository to the cluster before moving on i want to give a shout out to castin who made this video possible castings k10 is the data management platform for kubernetes k10 basically takes off most of the load of doing backup and restore in kubernetes from the cluster administrators it has a very simple ui so it's super easy to work with and has an intelligent logic which does all the heavy lifting for you for my viewers custom provided an ebook kubernetes backup and recovery for dummies which you can download for free so be sure to check it out in the video description and now let's see how git ops makes an easy rollback possible now when you have the version control for your code and the changes in the repository are automatically synced to the environment you can easily roll back your environment to any previous state in your code and that could be another big advantage for example if you make changes that break something in the environment so your cluster doesn't work anymore you can just do git revert to undo the latest changes and get the environment back to the last working state so overall this means that instead of spreading your infrastructure's code and configuration is code etc in different places and machines and basically having those files just lying around on your computer everything is stored centrally in a git repository and the environment is always synced with what's defined in that repository and this means that git repository becomes the single source of truth for your environment and of course this makes managing your infrastructure or your platform way easier and finally an important additional benefit is that git ops also increases security because now you don't have to give everyone in the team who needs to change something on the infrastructure or in kubernetes cluster direct access to it to execute the changes because it's the cd pipeline that deploys the changes not individual team members from their laptops but anyone on the team can propose changes to the infrastructure in the git repository through pull requests and once it's time to merge that pull request and apply those changes you can have a much narrower group of people who are allowed to approve and merge those changes into the main branch so that it gets applied and as a result you have less permissions to manage and a more secure environment so to summarize git ops is an infrastructures code with version control pull requests and ci cd pipeline now i hope you learned a lot in this video share with me in the comments what is your experience and what do you think generally about git ups with that thank you for watching and see you in the next video