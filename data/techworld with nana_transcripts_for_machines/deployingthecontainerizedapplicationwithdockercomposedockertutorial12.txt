so in this video we're gonna see how to deploy an application that we built into a docker image so after you package your application in a docker image and save it in the private repository you need to somehow deploy it on a development server or integration server or whatever other environment in this specific video we are using a docker registry of Amazon Web Services called ECR that's where we have pushed our own application docker image and we're gonna use docker compose to deploy that application this video is part of a docker tutorial series so if you want to actually follow through the whole process of developing an application packaging it into a docker image pushing it into a private repository and then finally deploying it on a application server here's a link to the video series so you can check that out so again back to our initial overview we have gone through all these individual steps so we built an image just like a Jenkins server would do and we pushed it into a repository so now let's actually simulate a development environment so let's imagine we have logged into a development server and we want to run our image that we just pushed the repository so our my app image and the MongoDB image both the database in the Express on the development server so the my app image will be pulled from private repository of EWS the in the to containers will be pulled from the docker hub so let's see actually how that would work so usually again you have developed your application you're done with it and you have created your own docker image right now in order to start an application on development server you would need all the containers that make up that application environment okay so we have a longer Express already so what we are going to do is here we're gonna add a new container in the list which is gonna be our own image so let's go ahead and copy the image from our repository so let's actually use the 1.0 so again remember we said that this image name is a shortcut for having a docker dot IO dot library slash with like a specific version so instead of that because we are pulling these images from a docker hub we can actually skip that repository domain in front of the images but here because we're pulling it from a private repository so if we were to specify our image like this docker will think that our image resides on docker hub so we try to pull it from docker hub and of course it won't find it because we have to tell docker go and look at this repository with this repository name in this tag and of course in order to be able to pull this image or the docker composed to be able to pull this image the environment where you're executing this docker compose file has to be logged into a docker repository so here as the development server has to pull the image from the repository what we would need to do on the development server is actually do a docker login before we execute the docker compose and obviously you don't need a doctor login for doc hub those images will be pulled freely ok so the next thing that we have to configure are the ports because obviously want to open the ports if we go back we see that our application runs on port 3000 so the port of the container or that where the container is listening on is 3000 and here we can open the port on the host machine so it's going to be 3000 map to 3000 we have actually the environment variables inside of the docker file but obviously we could have configured them in the docker compose just like this so it's an alternative so this will be a complete docker compose file that will be used on a development server to deploy all the all the applications inside so again if we're trying to simulate a development server that the first step will be to dock to the docker login in this case you have this on command for logging in to the AWS repository which I have done already in this terminal so the next step is to have the docker compose file available on this development server because we have to execute the docker compose file because we're simulating here the way I would do it is I'm gonna create an demo file in the current directory where I am I'm gonna copy this and save so now I have my ml file and now we can start all three containers using munger docker compose comment eff up and here we see that app started on 3000 and MongoDB and Express started as well so let's check again now and here we saw that database is lost every time we recreate a container and of course that's not good and we're going to learn how to preserve the database data between the container restarts using docker volumes in the later tutorials because this is not an ideal State okay so now that we have database in a collection let's actually refresh in our application works as well let's check awesome so our application works let's refresh this one as well and there is actually one thing that I needed to change in the code to connect no J's with MongoDB so let's actually go and look at that so this is my these are my handlers you know no J's where I connect to the MongoDB database so the your eyes are the same and what I changed here is that it was a localhost before so instead of localhost I changed it to MongoDB because this actually is a name of the container or of the service that we specify here so this actually leads back to the doctor Network and how docker compose takes care of it is that in the URI or when I connect one application in a docker container with another one in an other docker container I don't have to use this localhost anymore actually I wouldn't even need to use the port even because I have all that information so the host name and the port number in that configuration so my application will be able to connect to MongoDB using the service name and because of that you don't have to specify here a localhost and the port number which is actually even more advantage when you consider using docker containers to run all of your applications because it makes the connectivity between them even more easier and that actually concludes the this diagram that we saw previously we have gone through all of the steps where we saw how to develop a JavaScript application locally with docker containers then we saw how to build them into an image just like continuous integration build we'll do it then we pushed it into a private repository and we simulated a development server where we pull the image from private repository and the other images from the docker hub where we started the whole application set up with our own application in the two applications using a docker compose which is how you would deploy an application on a dev server so that now testers or other developers will be able to access the development server and actually try out the application that you just deployed or you can also use it for demos thanks for watching the video I hope it was helpful and if it was don't forget to like it this is a video series so I will create a new one every week so if you want to be notified whenever a new video comes out then subscribe to my channel if you have any questions if something wasn't clear in the video please post them in a comment section below and I will try to answer them so thank you and see you in the next video