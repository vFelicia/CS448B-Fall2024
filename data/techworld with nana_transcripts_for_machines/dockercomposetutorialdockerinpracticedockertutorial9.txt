so in the last video we created and started two docker containers mongodb and mong express and these are the commands that we used to make it happen right the first we created a network where these two containers can talk to each other using just the container name and no host port etc is necessary for that and then we actually ran two docker run commands with all the options environmental variables etc set now this way of starting containers all the time is a little bit tedious and you don't want to execute these run commands all the time on the command line terminal especially if you have a bunch of docker containers to run uh you probably want to automate it or just make it a little bit easier and there's a tool that's that makes running multiple docker containers with all this configuration much easier than with docker run commands and that is docker compose if you already know the compose and you are wondering why is it useful and what it actually does then bear with me in the next slide i'm going to explain that so this is a docker run command of the mongodb that we executed and previously so basically with docker compose file what we can do is we can take the whole command with its configuration and map it into a file so that we have a structured commands so if you have let's say 10 docker containers that you want to run for your application and they all need to talk to each other and interact with each other you can basically write all the run commands for each container in a structured way in the docker compose and we'll see how that structure actually looks like so on the right side in the docker compose example the first two takes are always there right version three that's the latest version of the compose docker compose and then we have the services this is where the container list goes so the first one is mongodb and that maps actually to the container name right this is going to be a part of container name when docker creates a container out of this configuration blueprint the next one is actually the image right so we need to know which image that container is going to be built from and of course you can specify a version tag here next to the name the next one is port so we can also specify which ports is going to open first one is on the host and the second one after the colon is on the container so the port mapping is there and of course the environmental variables can be also mapped in the docker compose and this is how actually the structure of docker compose looks like for one specific commands let's actually see the second container command for express that we executed and how to map that so now again we have a docker run command for express and let's see how we can map it into a docker compose so as i said services will list the containers that we want to create and again names express will map to the container name the next one will be the image again you can add a tag here if you want to be um have a specific one then you have the ports 80 to 80 to 8080 and then you have all the environmental variables again under the attribute environment and this is how the docker compose will look like so basically docker compose is just a structured way to contain very normal common docker commands and of course it's it's going to be easier for you to edit the the file if you want to change some variables or if you want to change the ports if you want to add some new options um to the run command so to say and maybe you already noticed the network configuration is not there in the docker compose so this network that we created we don't have to do it in a docker compose we go to the next slide because we have the same concept here we have containers that will talk to each other using just the container name so what docker compose will do is actually take care of creating a common network for these containers so we don't have to create the network and specify in which network these containers will run in and we're going to see that in action right away so let's actually create a docker compose file so i'm gonna paste all my contents here and this is exactly what we saw on the slides and i'm gonna save it as a yaml and we see the highlighting as well be very aware of the indentation they have to be correct so this is the list of all the containers on the same level and then each container has its configuration inside that so now compared to docker run commands it will be very easy for me to go here and change these environment variables or add some new configuration options etc so here again for demonstration we actually save the doctor compose in the code so it's part of the application code so now that we have a docker compose file the question is how do i use it or how do i start the containers using that so let's go to the command line and start docker containers using this docker compose file so the way to use it is using docker compose command now if you've installed docker on your laptop it usually gets installed with the docker compose packaged inside so you should have both docker and docker compose commands installed as a package so docker compose command takes an argument which is the file so i'm going to specify which file i want to execute and in my case it's called yemo and at the end i want to say what i want to do with this file in this case the command is up which will start all the containers which are in the yemo so let's actually check before that there there are no containers running so i don't have anything running here and i'm gonna start those two containers okay so there are a couple of interesting things here in this output so let's scroll all the way up so we've talked about docker network and how we created our own network at the beginning to run the containers inside and i said the docker compose takes care of it and here we see the output where it actually created a network called my app default this is the name of the network and it's going to run those two containers these are actually the names of the containers that docker compose created this is what we specified and it just added prefix and suffix to it and it created those two containers in that network so if i actually go here and do docker network ls i see the my app default is here so that's one important thing another one is the logs of both containers actually mixed because we're starting both at the same time as you see the express has to wait for mongodb to start because it needs to establish a connection so we here see the locks so mongodb is starting we still get connection reviews because it's not started completely and somewhere here when mongodb is started and listening for connections express is able to connect to it so this is something that you can also do with docker compose when you have two containers that where one depends on another one starting you can actually configure this waiting logic in the docker compose okay so now let's see actually that the docker containers are running so we have both of them here you see the container names that docker compose gave them and one thing here to note is that the express actually started on port 8081 inside the container so we can see that here so we are opening a port 8080 on my laptop that actually forwards the request to container at port 8081 just so that you don't get confused because it was 8080 on the slides so now that we have restarted the containers let's actually check the first one which is express so it's running on 8080. in the previous example we created a database and the collection which is gone because we restarted the container this is actually another very important concept of containers to understand when you restart a container everything that you configured in that container's application is gone so data is lost so to say there is no data persistence in the containers itself of course that is very um inconvenient you want to have some persistence especially when you're working with the database and there is a concept we're going to learn later in this tutorial series called volumes that makes it possible to have persistency between the container restarts okay so let's actually create the database again because we need it and inside the database we had actually users collection let's create that one as well and that is empty now let's actually start our application and there you go so now if i were to modify this one here and update i should see the updated entry here so the connectivity with mongodb works so now what do i do if i want to stop those containers of course i could go there and say docker stop and i can provide all the ids as we did previously or with docker compose it's actually easier i can do docker compose again specify the file and instead of up i'm going to say down and that will go through all the containers and shut them all and in addition to removing the containers or stopping them removing the containers it also removes the network so the next time we restart it it's going to recreate so let's actually check that token network ls that default my app default network is gone and when i do up see it gets recreated that should give you a good idea of what docker compose is and how to use it in the next video we're gonna build our own docker image from our node.js javascript application thanks for watching the video i hope it was helpful and if it was don't forget to like it this is a video series so i will create a new one every week so if you want to be notified whenever a new video comes out then subscribe to my channel um if you have any questions if something wasn't clear in the video please post them in the comment section below and i will try to answer them so thank you and see you in the next video