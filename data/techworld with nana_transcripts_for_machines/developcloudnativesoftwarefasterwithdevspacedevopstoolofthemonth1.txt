in this video we're gonna look at a tool which makes it easier for software developers to develop and deploy to kubernetes which is called devspace this is the first video of the new series called devops tool of the month each month you will get to know one new useful tool in devops space so first i will explain what problem devspace solves how it works and then we will see it in action with a simple demo imagine you are in a developer team working on a simple microservices application and maybe you have one devops guy in the team or maybe a separate devops team who knows kubernetes and helps everyone in the team to write the kubernetes yml config files configures the cluster deploys database applications in it and so on so you create a bug fix branch for one of the microservices and start making changes while you are making these changes you want to test in combination with other microservices but you want to test them on the real kubernetes development environment instead of just locally using docker compose or mini cube so that you don't have any surprises once you deploy that on the kubernetes environment because these are two different environments so normal workflow for you would be you test it locally with docker compose or minicube make sure it works create a pull request your branch then is merged into master a ci cd pipeline is triggered that tests the changes builds the new image and deploys it into kubernetes cluster on dev environment now you can test it on dev to make sure it works there the same way it worked locally and this is a long process to be able to test your changes on kubernetes dev environment so what if instead every change you make locally would be immediately deployed into kubernetes cluster so you can test your changes without having to know kubernetes or cube ctl or needing help from the devops team and the tool that lets you do exactly that is dev space so how does dev space work using a simple devspace configuration file in your application code devspace will automatically build your application into an image using your docker file and deploy it into the cluster but on top of that every time you make changes devspace will hot reload them by automatically recreating and restarting the container within the pod so basically syncing the changes you have locally with the container that is running inside kubernetes so this will be a development mode in which you can test every code change immediately but devspace has other use cases and features when for example you just want to deploy the application without the sync and push the image to your private docker repository etc what's also great about devspace is that it gives you shortcut commands to get the container terminal or logs without checking the pot id and namespace etc so let's jump into a demo to show you how to set up the development mode with hot reloading in four simple steps and also show you how this can make the development process much more efficient when working with kubernetes i have a small java project you can find the link in the video description and an empty kubernetes cluster with cubectl already connected for this demo i'm going to use minicube but it could be any kubernetes cluster on aws or any other platform so our steps will be to install devspace we're going to create a docker file initiate our project with devspace and finally start the dev mode so first of all we're gonna install devspace locally installation is very simple you have multiple options described in the official guide i will install it globally using npm so with npm install minus g for global and dev space and when i execute devspace command it will finish the installation and i have devspace available as a comment now the second step is to create a docker file in our project that devspace will use so i'm going to open my project which is in visual studio code and this is a very simple java application basically i just have one application.java file which just basically starts the application and i have one index.html so that we can see a ui to it when we deploy it so these are the two files that i have in here again you can find the link in the description and this is our docker file now usually when you build image from java you want your jar to be inside the image which you can then execute now how dev space works is that it syncs your local code and code inside the container image and checks for any code changes so that it can perform the hot reload so devspace will build the image with all our code inside and sync it and this will happen out of the box without any additional configuration from our site however some of these folders and files here are actually not really part of the code itself like the application code itself so we can easily just exclude them using docker ignore file so let's create a docker ignore file which is actually very similar to git ignore where we can just list all the folders and all the files that we want to exclude when we're building a docker image i'm gonna include dot idea which is actually from intellij because i had this project open intellij so we're gonna exclude that could be also any other editorspecific folder that gets generated we can also ignore the ignore files themselves so this will basically exclude all the unnecessary stuff which are not part of the application code itself from the build docker image so let's save that and we have our project ready for dev space so now we can actually initiate the project using simple devspace init command so first of all let's open a terminal window and execute dev space in it here and let's see what happens the first one is the docker file that devspace will use it has detected that our project has already a docker file and suggests to use it so we're going to go with this option as a next step it asks us to choose container image repository i'm already logged into docker hub where i have my private docker repository so i can basically just choose that because as i mentioned with dev space you can actually push the images also to the repository as part of the process of rebuilding the docker image when you make changes so i'm going to choose that one i can also choose image name on dockerhub let's actually leave it as is and finally devspace is giving us an option to configure how our application will be deployed inside the kubernetes cluster and we have four options here it could be deployed as helm chart so if you have helm chart in the project that your application is uses you can configure that or if you have a remote help chart we can also specify that one as well as just kubernetes yaml files configuration files like deployment.yml however if you do not have any kubernetes yaml files or helm charts for your project inside your application you can actually go with the first one which is component chart and this means that devspace will actually create a helm chart for your application and deploy it inside kubernetes cluster as a helm chart so basically you don't have to write any configuration files or helm charts all these will be taken care of by dev space so we're going to go with this easy option and choose it and we have initialized dev space in our project so let's actually see what happened or what devspace did in our project and as you see devspace automatically generated a devspace.eml file based on our docker file that we provided and note that if this was a microservices repository with multiple applications inside then devspace will generate a configuration file for all those applications based on their dockerfiles so here at the top you see the list of the images we just have one in this case and these are just configuration for that one specific image and we also have some other configuration which we're gonna see in a bit devspace also included the dev space yaml in docker ignore because this is also not part of the application code itself so we don't want changes in this file to be synced and as well as git ignore dot devspace folder is ignored so all this was done automatically now we can actually build and deploy our application so first of all let's actually build our jar file because that's what we are going to execute inside the container so we have a maven project so i'm going to do maven package and there you go we have target folder with the jar file inside if i go back to terminal i have a mini cube cluster running and my cluster is currently completely empty so now we're ready to actually deploy our application however in reality when you're deploying your application you don't want to deploy your stuff in default namespace or maybe mess with namespaces of other teams we want to create our own namespace to test with instead of using an existing one so with devspace we can actually set so we can tell devspace hey when you deploy the application please use this namespace we can do devspace use namespace and let's call it my app and if the namespace isn't there devspace will actually create it so let's set it so basically this is just informing devspace when we deploy our application please create and use that namespace so now everything is configured and set let's finally execute devspace dev comment so now this is an interesting part how does dev space actually connect to kubernetes cluster to deploy stuff in it because we didn't define any configuration for connecting dev space to our cluster well dev space uses the current cube context which is the same as the one configured currently for cube ctl so right now our cube ctl is pointing to the mini cube so that's exactly where devspace will deploy our application so no additional configuration needed for that so let's execute this command and see what it will do great so let's see what just happened so first of all right here you see the cube context was used the namespace was created in the cluster then the image was built these are all the steps and our application was actually deployed as a helm chart into the cluster and after that a port forwarding was configured automatically for the application service so that we can access the application on localhost so all that was done automatically that's why we see the application on localhost 8080 and finally devspace actually started syncing the local code with the code in the container and it also started streaming the logs from the container so right here we see actually the logs that container in kubernetes pod is actually logging so if the deployment didn't succeed if there was some error we would see that immediately in that stream so all the following logs we will basically be seeing them right here in our terminal without even having to go over to kubernetes and execute cube ctl commands so let's actually check out what got deployed and created in the cluster so first of all let's do cube ctl get namespace and right here you see that my app namespace was created and devspace actually sets the context to that namespace and this means that we don't have to add a namespace when we do getpod because it executes immediately in this my app namespace so this is our java application running we can also check the deployment which is right here i'll check the service my java app and now let's also check helm chart and this is my java app helm chart with the version one because this was the first deployment so to say so our application was deployed as a helm chart because as i said devspace configures that automatically so you don't need to write any kubernetes configuration files yourself and that configuration is actually right here deployment part using the information from docker file and right here it says helm so here you can define some other values if you want to configure additional stuff for application like volumes config map environmental variables and so on for example we could also set replicas here if we wanted to run multiple replicas of our application and so on however if you do have your own helm chart created for application or your own kubernetes yaml files you can specify them in this devspace yemo file instead and use them to deploy your application and this deployment is also at least just like the images here so you can configure multiple deployments here for additional containers again for other microservices or even some thirdparty helm charts databases or whatever you want to deploy together with your own application so as you see you can configure the whole environment for application to start in a fresh new namespace all in one devspace.yaml configuration file great so we have streamlined our app deployment from the local setup now let's see what happens if we change our code right now this is our application looks like so i'm gonna go and change index.html so right here let's say the new version of the app deployed and i'm going to save it and as soon as i saved you saw that container was restarted right here and the application reloaded so if i go back to the browser and refresh there you go you see the new version of the application so basically every time we make changes to any of the files that we copied into the container that we didn't exclude from the code the container will reload inside the pod right here you see the pod wasn't actually recreated it's the same pod but the container inside got restarted so within seconds we basically have our changes propagated inside kubernetes without going through the whole pipeline and building process which can really make your development process efficient especially when you're trying to test small minor changes in your application in the same way we can also change java code add another lock here for example then rebuild the jar file because that's how java code is packaged and there you go you see that container got restarted again and right here we have the new logline if you want to save yourself rebuilding the jar file you can also configure devspace to autorebuild the jar file whenever you make changes in your java code and one more thing that devspace gives us in addition to all of this is if i scroll all the way up right here you see that dev space ui actually also started in the background and this is the address that we can check out right now so here we see my java app and here you have cube context so if you had multiple kubernetes clusters that you were deploying your application to basically you can choose between them and for that cube context then you have the name spaces we are in my app currently and here you also have the list of all the applications that are deployed and managed by devspace so if i click inside here this is the pod name actually i can also see all the logs right here so as you see this tool basically makes the development process more efficient but also gives you easy ways to interact with the deployed container or pod inside kubernetes with shortcut commands for example so that's basically how devspace works now you may be wondering what about the cluster state itself what happens if every developer would push their changes and stuff into it all the time to test their changes developers would mess up the cluster or interfere with other resources running on the cluster or how do you manage permissions that you give to developers to actually test this in kubernetes cluster now they're actually really good solutions for that specific problem and this will be the topic of our next video in the devops tool of the month series so make sure to subscribe and stay tuned if you want to learn more about that too as always thanks for watching and see you in the next video