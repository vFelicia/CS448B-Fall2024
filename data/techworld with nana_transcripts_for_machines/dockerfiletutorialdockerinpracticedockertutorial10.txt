so now let's consider a following scenario you have developed an application feature you have tested it and now you're ready to deploy it right to deploy your application should be packaged into its own docker container so this means that we're gonna build in docker image from our JavaScript no J's backing application and prepare it to be deployed on some environment to review this diagram that we saw at the beginning of the tutorial so we have developed a JavaScript application we have used the MongoDB docker container to use it and now it's time to commit it to the game right so in this case we're gonna simulate these steps on the local environment but still I'm gonna show you how these steps actually work so after commit you have a continuous integration that runs so the question is what does actually Jenkins do with this application when it builds the application so the JavaScript application using the npm build etc it packages it then in a docker image and then pushes it into docker repository so we're gonna actually simulate what Jenkins does with their application and how it actually packages it into a docker image on the local environment so I'm gonna do all this on my laptop but it's basically the same thing that Jenkins will do and then on later step we're gonna push it we can actually push the built image into a docker repository in order to build a docker image from an application we basically have to copy the contents of that application into the docker file could be an artifact that we built in our case we just have three files are we gonna copy them directly in the image and we're gonna configure it and in order to do that we're gonna use a blueprint for building images which is called a docker file so let's actually see what is a docker file and how it actually looks like so as I mentioned docker file is a blueprint for creating docker images a syntax of a docker file is super simple so the first line of every dock file is from image so whatever image you are building you always want to base it on another image in our case we have a JavaScript application with no J's backend so we are gonna need node you know inside of our container so that it can run our node application instead of basing it on a Linux Alpine or some other lower level image because then we would have to install node ourselves on it so we are taking a ready node image and in order to see that let's actually go to docker hub and search node here and here you see there is a ready node image that we can base our own image from so here we have a lot of different text so we can actually use one specific one or we can just go with the latest if we don't specify any take so what that actually means basing our own image on a node image is that we're gonna have node installed inside of our image so when we start a container and we actually get a terminal of the container we can see that node command is available because there is no install there this is what from node actually gives us so the next one is we can configure environmental variables inside our dock file now as you know we have already done this in the using the doctor and comments or the docker composed so this will be just an alternative to defining environments of variables in a docker compose for example I would say it's better to define the environmental variables externally in a docker compose file because if something changes you can actually override it you can change the docker compose file and override it instead of rebuilding the image but this is an option so this end command basically would translate to setting the environmental variables inside of the image environment the next one is run so all these capital case words that you see from in and run they're basically part of a syntax of a docker file so using run basically you can execute any kind of Linux commands so you see make directory is a Linux command that creates a home slash home slash app directory very important to note here this directory is going to live inside of the container so when I start a container from this image the slash home slash app directory will be created inside of the container and not on my laptop not on the host so all these commands that you have in docker file will apply to the container environment none of them will be affecting my hosts environment or my laptop environment so with run basically you can execute any Linux comments that you want so that's probably one of the most use ones and we also have a copy command now you will probably ask I can execute a copy come in a Linux copy command using run yes you could but the difference here is that as I said all these commands in run for example they apply to they get executed inside of the container the copy command that you see here it actually executes on the host and you see the first parameter is dot and second parameter is slash home slash app so source and the target so I can copy files that I have on my hosts inside of that container image because if I were to execute run CP source destination that command would execute inside of the docker container but I have the files that I want to copy on my host in the last one so from an CMD or command is always part of the aqua file what commend does is basically executes an entry point Linux command so this line with the command actually translates to node server js so remember here we actually do node services so we execute so we start a node server with the nodejs this is exactly what it does but inside of the container so once we copy our server JS and other files inside of a container we can then execute node server chase and we are able to do it because we are basing on the node image that already has node pre installed and we are gonna see all this in action so another question here what is the difference between run and CMD because I could also say run node server chase the difference again is that CMD is an entry point command so you can have multiple run comments with the different Linux commands but CMD is just one and that marks for docker file that this is the command that you want to execute as an entry point so that basically runs the server and that's it so now let's actually create the dockerfile and just like the Taku compose file docker file is part of the application code so I'm gonna create a new file here and I'm gonna paste here the contents so again we're basing off note image and actually instead of just having the latest node I'm gonna specify a node version so I'm going to take 13 Alpine so all these that you see here are text so I can use any of them as a tag so I'm gonna say 13 Alpine like this so this is gonna be a specific node image that I'm gonna use as my base image let's actually stop here for a moment and take a little bit of a deep dive on this line so since we saw that docker file is a blueprint for every for any docker image that should actually mean that every docker image that there is on docker hub should be built on its own docker file right so if we actually go to let's actually look at one of the latest versions which is 13 alpine and then let's click inside and as you see this specific image has its own docker file and here as you see we have the same from that we just saw and this is what this node official image is based off which is a base image Alpine 3.10 right and then we have this environmental variable set and all these linux commands using run and some other environmental variable and you have this entry point which is a script so you can also execute the whole shell script instead of instead of separate commands and you have this final comment right so you don't have to understand any of this I just want to demonstrate that every image is based of another base image right so in order to actually visually comprehend how this layers stacking works with images let's consider this simplified visualization so our own image that we're building up with the version 1.0 is going to be based on a node image with a specific version that's why we're going to specify from node 13 alpine and the node 13 Alpine image as we saw in the dockerfile is based on alpine based image with the version 3.1 that's why it specifies from Alpine 3.10 so Alpine is lightweight based image then we install node on top of it and then we stole our own application on top of it and basically this is how all the images are built so now let's go back and complete our docker file so we have the from specified we have the environmental variables specified and in just a second we can actually see this commands in action so let's copy that and this is also very important docker file has to be called exactly like that you can't just give it any name it is always called docker file starting with a capital D and that's it it's a simple text file so just save it like this and here you even see the highlighting and this docker icon so now that we have a docker file ready let's see how to actually use it so how do we build an image out of it so in order to build an image using docker file we have to provide two parameters one is we want to give our image a name in the tag just like all the other images have so we are gonna do it using minus T so we're gonna call our image my app and we're gonna give it a tag of 1.0 the TEC could be anything you can even call it actually version 1 it wouldn't matter so we're gonna do 1.0 and ii required parameter actually is a location of a docker file because we want to tell docker here build an image using this docker file and in this case because we're in the same folder as the docker file we're just gonna say current directory when we execute this we're gonna see that image is built and this is an idea of the image that was built because I already have note 13 Alpine on my laptop dishes use the the one I have lying around locally for you if it's the first time you will actually see that it's pulling node image from the docker hub so now with the docker images I can actually see that my image is here it says created two days ago I don't know why but anyways so I have the image name which is this one here and I have the name of the image and the tag of the image so if we go back to this diagram that we saw in the review so basically we've gone all these steps or we have simulated some of the steps we've built the JavaScript application using a docker containers and once the application is ready let's say we made the commit and we're we just simulated what Jenkins server also does so what Jenkins does is actually it takes the dockerfile that we create so we have to commit the dockerfile into the repository with the code and Jenkins will then build a docker image based on the docker file and what is an important point here is that usually you don't develop a loan you are in the team so other people might want to have access to that uptodate image of your application that you developed it could be a test or maybe who wants to pull that image and test it locally or you want that image to be deployed on a development server right in order to do that you have to actually share the image so it is pushed into a docker repository and from there either people can take it for example a tester maybe want to download the image from there and test it locally or a development server can actually pull it from there so let's actually just run a container I'm just gonna say docker run the image name obviously and a tank like this and in this case I'm not gonna specify any other options because we just want to see what's going on inside of the container so I'm just gonna run it okay so the problem is that it can't find the server JS file which is actually logical because we are not telling it to look in the correct directory so since we're copying all the resources in this home slash home slash app directory server JS is gonna be there as well and this is another topic whenever you adjust a docker file you have to rebuild an image because the old image cannot be overwritten so to say so what I'm gonna do now is actually I'm gonna delete the one that I built so I'm gonna I'm gonna actually take the image this is how you delete an image but but I can delete it because as it says the docker is used by a stopped container so if I do docker PS a actually let's crap my app like this I have to first delete the container so this is how you delete a container it's toker RM and once I've deleted the container I can delete an image so the image deletion is RM I like this so if I do images now I see my image isn't there okay so we've modified the docker file so let's rebuild it now so talk a build okay and let's see the image is here so let's start it again so it's my app 1.0 and let's run it and you see the problem is fixed at listening on port 3000 so our app is running so this one here my app 1.0 first of all we can see the logs here like this we see that the app is listening on port 3000 we know everything is cool to actually just get a little bit more inside let's enter the containers or let's get the terminal the command line terminal of the container and look around there so I'm gonna say docker exec interactive terminal I'm gonna specify the container ID like this and since being bash doesn't work we can actually try shell so this is something you will also encounter because some containers do not have bash installed so I have to connect using pin SH so one of them has to work always so let's see in which directory we are so we are in the root directory and we see our virtual file system there and as you see the cursor changed as well so that means we're inside of a container so now let's actually check some of this stuff so first of all we specified some environmental variables here in the docker file and this means that this environmental variables have to be set inside the docker environment so if we do in we actually see the MongoDB username this one here and MongoDB password are set there's some other environmental variables automatically set we don't care about them so another thing we can check is this directory because remember because with this line we actually created this slash home slash AB directory so let's see slash home slash app and as you can see the director was created and with the next line we copied everything in current folder so if we actually go and see reveal in finder so this is where the dockerfile resides so basically we copied everything that is inside of this directory so all of this into the container now we don't actually need to have docker file and docker compose and these other stuff in here because the only thing we need are the Java Script files or if we build a JavaScript application artifact just an artifact so let's go ahead and improve that so what I'm gonna do is I'm gonna create an app directory and I'm gonna copy just the files that I'm gonna need for starting an application inside of a container so I'm gonna take those and the images as well so all these are just external ones we don't need them there and images the index.html file package JSON server J's and node modules are inside of app so what we can do it now is instead of copying the whole directory where the docker file is I just want to copy all the contents of EPP folder so what I'm gonna do is I'm gonna say copy all the contents and again because we modified a docker file we need to recreate the image in order to leave the docker container terminal you can actually exit so now we are on the hosts again so if I do docker images again I have to first delete the container and an image but in order to delete the container I have to first stop it so now I can remove the container and now I can actually remove the image that the container was based on and let's check again so let's actually execute that build command again so now that we have the image built let's actually run it so I'm gonna say my F one point zero and of course I could have executed with a minus D in a detached mode it doesn't matter now and if I do it or PS I see my image container running and now let's actually enter the container again so my team and as we learned it was in SH and again we're gonna see the home app and here we just have the contents of app directory so no unnecessary docker file docker compose etc files which is actually how it's supposed to be or as I said because I just had a couple of files here I copied all of them but usually if you have this huge application you would want to compress them and package them into an artifact and then copy that artifact into a docker image container okay but as I said this was just for demonstration purposes because I just wanted to show you how you can actually start it as a container in how it should look inside and in this case we improved a couple of things but usually we would start this container from a docker compose as well together with all the other docker images that the application uses and it also doesn't have any ports open so this is just for demonstration purposes so in the next video we're actually gonna see how to create a private repository and how to push images into that private repository again we're gonna simulate these from a local environments so I'm gonna execute these comments from my laptop but this is exactly the same comments that Jenkins server will execute thanks for watching the video I hope it was helpful and if it was don't forget to like it this is a video series so I will create a new one every week so if you want to be notified whenever and video comes out then subscribe to my channel if you have any questions if something wasn't clear in the video please post them in the comment section below and I will try to answer them so thank you and see you in the next video