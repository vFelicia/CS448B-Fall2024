With timestamps:

00:00 - quicksort is one of the fastest sorting
00:01 - algorithms out there but it can also be
00:04 - one of the hardest to understand in this
00:05 - video we'll go through exactly how the
00:07 - quick sort algorithm works in detail in
00:09 - a way that i promise you'll understand
00:11 - then we'll walk through coding our own
00:13 - quicksort implementation in java my name
00:15 - is john i'm a lead java software
00:17 - engineer and i love sharing what i've
00:18 - learned with you in a clear and
00:20 - understandable way i also have a full
00:21 - java course available and a link down in
00:23 - the description if you're interested
00:24 - let's get right into it okay before we
00:26 - just dive into eclipse and start coding
00:29 - it's important to know how the quick
00:30 - sort algorithm works the whole quick
00:33 - sort algorithm is basically just three
00:35 - steps the first step is choose one of
00:38 - the numbers in your array as the pivot
00:41 - so you might be thinking what do you
00:42 - mean choose a pivot i just choose any
00:44 - number in my array here as my pivot and
00:47 - essentially the answer is yes it's not
00:49 - so much that the pivot you pick isn't
00:51 - important but how you choose a pivot
00:53 - isn't important to understanding the
00:55 - actual algorithm what we're going to be
00:57 - doing is just choosing the last element
00:59 - in the array as the pivot and i'll show
01:01 - you how that works then at the end of
01:02 - the video we'll go over a better
01:04 - strategy for picking the pivot which is
01:06 - also still really easy to implement
01:07 - after you've chosen the pivot the second
01:09 - step is to move all numbers in the array
01:12 - that are lower than the pivot to the
01:13 - left of it and all numbers that are
01:15 - higher than the pivot to the right of it
01:17 - this step is also called partitioning so
01:20 - since we're using the last number as our
01:22 - pivot in this case it will be seven and
01:24 - the partitioning step will put all
01:26 - numbers less than 7 on the left side of
01:28 - the 7 so that means that the 1 the 3 the
01:33 - 4
01:34 - and 5 will all be moved to the left of 7
01:37 - and 8 and 9 will be moved to the right
01:41 - of 7. so after that partitioning step
01:44 - all the numbers to the left of 7 are
01:46 - smaller than 7 and all the numbers to
01:49 - the right of 7 are larger and the number
01:51 - that we chose for our pivot the 7 in
01:54 - this case is actually in its final spot
01:56 - in the array the partitioning step is
01:58 - probably the most complicated to code
01:59 - but don't worry we'll go through that
02:01 - part step by step after partitioning the
02:04 - third step is to recursively quick sort
02:06 - all the values to the left of that pivot
02:09 - and all the values to the right of the
02:11 - pivot and when we do the quick sort for
02:13 - those sub arrays it's done exactly the
02:15 - same way we just did it so first we
02:17 - would do the quick sort for the left
02:18 - portion here and we'll repeat the same
02:20 - steps that we did before which are first
02:22 - choose a pivot and again we're just
02:24 - going to use the last number as the
02:26 - pivot which in this case would be 1.
02:28 - then we do the partitioning where we
02:29 - take any number that is greater than 1
02:32 - and put it to the right of 1 and any
02:34 - number that is less than one and put it
02:36 - to the left in this case they all happen
02:38 - to be greater than one so they all go to
02:40 - the right of one then after the
02:42 - partitioning step of that quick sort we
02:44 - then recursively quick sort all the
02:46 - elements to the left of the pivot and
02:48 - all the elements to the right of the
02:50 - pivot there's no elements to the left of
02:51 - the pivot because our pivot was 1 in
02:53 - this case so we just have to recursively
02:55 - quick sort all the numbers to the right
02:57 - of the pivot and again we do that
02:58 - exactly the same way where we first
03:00 - choose a pivot which is going to be the
03:01 - last number for us or five then we move
03:04 - all the numbers in this subarray that
03:05 - are less than five to the left of five
03:07 - and all the numbers that are more than
03:08 - five to the right in this case three and
03:10 - four are both less than five and they're
03:12 - already to the left of five so there's
03:13 - nothing we have to swap then again we
03:15 - recursively quick sort the sub arrays to
03:18 - the left and right of that pivot since
03:20 - there's nothing to the right of 5 we
03:22 - only have to recursively quick sort the
03:24 - subarray to the left of 5 which is 3 and
03:27 - 4. again to quick sort this subarray we
03:30 - first choose a pivot which for us is
03:32 - going to be the last number in this
03:33 - array four then we do the partitioning
03:36 - again where in this case three is less
03:38 - than four and it's already to the left
03:40 - of four and then we recursively quick
03:42 - sort each sub-array to the left and
03:44 - right of four in this case we only have
03:46 - a subarray to the left of four here
03:48 - which is just the number three the
03:50 - number three is just one element so it's
03:52 - already sorted so now we've completed
03:54 - quick sorting all of the numbers that
03:56 - were originally next to the seven but
03:59 - remember we still have to recursively
04:00 - sort all the numbers to the right of the
04:02 - seven and of course we just quick sort
04:04 - this in exactly the same way first we
04:06 - choose a pivot which in our case we're
04:08 - just going to choose the last number
04:09 - which is nine then we do the
04:10 - partitioning where in this case there's
04:12 - no changes that we have to make because
04:14 - 8 is less than 9 and it's already to the
04:16 - left of 9. then we recursively quick
04:18 - sort these sub-arrays to the left and
04:20 - right of our pivot in this case we only
04:22 - have a subarray to the left of the pivot
04:25 - which is just the number 8. since it's
04:27 - only one element it's already in order
04:29 - and there's nothing that we have to do
04:31 - at that point we've completed all of the
04:33 - recursive quick sorts and we finally end
04:36 - with our perfectly sorted array and now
04:39 - for the fun part let's get to coding as
04:42 - always with these sorting algorithm
04:43 - tutorials i'm starting here with a
04:44 - little bit of setup just so we can test
04:47 - the sorting algorithm that we write this
04:48 - first part will generate an array of 10
04:51 - integers randomly between 0 and 99. so
04:54 - that just gives us a random array of ins
04:56 - to sort then we print out that array
04:58 - here in its initial completely random
05:00 - order then we call our quicksort method
05:03 - here which we are going to write where
05:04 - all the magic happens and it sorts our
05:06 - array from smallest to largest and then
05:08 - after that we print out the array again
05:10 - hopefully in perfectly sorted order so
05:12 - let's go ahead and jump into that quick
05:14 - sort method which is currently
05:16 - completely empty and we'll start our
05:18 - implementation you may have noticed that
05:20 - it's actually taking in three parameters
05:22 - the first one is the actual array that
05:24 - it's going to sort that makes sense but
05:26 - then it also takes in a low index and
05:28 - high index if you remember from the demo
05:31 - quick sort is a recursive algorithm
05:33 - where after we do the partitioning where
05:35 - we put all the numbers less than the
05:37 - pivot to the left and all the numbers
05:39 - higher than the pivot to the right we
05:40 - recursively quick sort all the numbers
05:42 - in the left partition and recursively
05:44 - quick sort all the numbers in the right
05:46 - partition that recursive step is why we
05:48 - need the low index and the high index
05:50 - when we tell it to recursively sort the
05:52 - subarray we don't want to just tell it
05:54 - to recursively sort the entire array
05:56 - again so we pass in basically a range a
05:59 - low index and a high index of that
06:01 - particular subarray so that it can
06:03 - properly do the recursive quick sorts
06:05 - however that does make it so that when
06:07 - you initially call the quick sort method
06:09 - in addition to passing in the array you
06:11 - need to pass in the low index and the
06:13 - high index too which of course when you
06:15 - want to just sort the entire array the
06:17 - low index is going to be 0 and the high
06:20 - index is just going to be the last
06:22 - element in the array which is just going
06:23 - to be the length of the array minus 1.
06:27 - near the end of the video i'm going to
06:28 - show you a trick where you can get rid
06:30 - of this for your initial quick sort call
06:32 - and just have to pass in the array that
06:34 - you want to sort all right now let's get
06:36 - to writing our quick sort method now
06:38 - what was the first step in our quick
06:40 - sort algorithm it's to choose a pivot
06:43 - and remember for our purposes we're just
06:44 - going to choose the last number as the
06:47 - pivot so to do that we'll just create an
06:49 - int and we'll call it pivot and set it
06:51 - equal to the value of the array at that
06:54 - high index that's passed in here
06:57 - remember that this is a recursive
06:59 - algorithm so we can't always just pick
07:01 - the last element of the entire array
07:03 - that we're sorting as the pivot in any
07:06 - given recursive step in the middle we
07:08 - might just be sorting one small sub
07:10 - array portion of the entire array and
07:12 - that'll be passed into this method
07:15 - recursively with a low index and a high
07:18 - index indicating that range that we want
07:21 - to be recursively sorting right now so
07:23 - the last element of that particular
07:26 - range that we want to be sorting is
07:28 - going to be passed in as high index now
07:30 - we've done the easy part we've chosen a
07:33 - pivot now for the hard part the
07:35 - partitioning where we have to move all
07:36 - the numbers lower than the pivot to the
07:38 - left of the pivot and all the numbers
07:40 - higher than the pivot to the right of
07:42 - the pivot how exactly are we going to do
07:44 - that in the code here's what we're going
07:45 - to do so we chose a pivot right that is
07:48 - just going to be the the last number in
07:50 - this case 7. so 7 is our pivot and for
07:53 - now we're just going to ignore that and
07:55 - let it be and just focus on all of the
07:58 - other numbers then what we're going to
08:00 - do is create two variables that we're
08:02 - going to use as pointers one we'll call
08:05 - the left pointer and we're going to
08:06 - start at the leftmost part of the array
08:10 - and the other will call right pointer
08:12 - and we're going to start it at the
08:13 - rightmost portion of the array we're
08:15 - going to start with the left pointer
08:17 - what we're going to do is start walking
08:19 - through our array a single element at a
08:21 - time until we find an element that is
08:24 - larger than the pivot so first we look
08:27 - at the number one is one larger than
08:30 - seven no so then we move that left
08:33 - pointer over to look at the number eight
08:35 - is eight larger than seven yes so we'll
08:38 - stop there and leave that left pointer
08:41 - pointing at the number eight and then we
08:43 - move on to our right pointer and what
08:45 - we're going to do with the right pointer
08:47 - is start walking from the right side of
08:50 - the list one element at a time to the
08:53 - left until we run into a number that is
08:56 - less than our pivot so our right pointer
08:58 - starts looking at the number five is the
09:00 - number five
09:02 - less than seven
09:03 - yes so we stop there with the right
09:06 - pointer pointing at the number five so
09:09 - at this point our left pointer is
09:11 - pointing to a number that is greater
09:13 - than our pivot and our right pointer is
09:15 - pointing to a number that is less than
09:18 - our pivot at that point we are going to
09:20 - swap the numbers at those two pointers
09:23 - so our eight will move over here where
09:25 - the five was and the five will move down
09:27 - here where our eight was then we repeat
09:30 - that process we move our left pointer
09:32 - over one spot so our left pointer is
09:35 - pointing at the number three is three
09:37 - greater than seven no it's not so we
09:40 - move our left pointer over to point at
09:43 - the number nine is nine greater than
09:46 - seven
09:47 - yes so we stop there with the left
09:49 - pointer pointing at nine then we move
09:51 - over to our right pointer and move it to
09:54 - the left to look at the number four is
09:57 - four
09:58 - less than seven
10:00 - yes so we stop there at this point our
10:02 - left pointer is pointing to a number
10:04 - that is greater than seven and our right
10:06 - pointer is pointing to a number that is
10:08 - less than seven at that point we swap
10:11 - the two numbers that our left pointer
10:14 - and right pointer are pointing to then
10:17 - we continue that same process we move
10:19 - the left pointer over one spot at this
10:22 - point our left pointer and right pointer
10:24 - are pointing to exactly the same element
10:27 - once that happens we want to stop that
10:29 - process of moving the left pointer and
10:31 - right pointer toward each other and then
10:33 - what we're going to do is swap our pivot
10:36 - with the number that our left pointer is
10:39 - pointing to so in this case the number
10:41 - nine so that will move our 9 out to here
10:43 - where our pivot was and our 7 in here
10:47 - where our 9 was at that point the
10:49 - partitioning step is complete so you'll
10:52 - notice that all the numbers less than 7
10:55 - are to the left of 7 and all the numbers
10:57 - that are greater than 7 are to the right
11:00 - of seven after that partitioning happens
11:02 - we're going to recursively quick sort
11:04 - the sub array to the left of our pivot
11:07 - and recursively quick sort the subarray
11:09 - to the right of our pivot that
11:10 - partitioning step is probably the most
11:12 - important part of the quick sort
11:14 - algorithm let's put what we just talked
11:16 - about into some code first we'll declare
11:18 - our two pointers left pointer and right
11:20 - pointer so we're going to have int left
11:22 - pointer and we're going to start the
11:24 - left pointer at the left side of the
11:27 - array that we're sorting so we can just
11:28 - initialize it to low index and we'll
11:31 - also create an int right pointer and
11:33 - we'll start it at the high index of the
11:36 - array that we want to sort now we need
11:38 - to create a loop that will move the left
11:40 - index and the right index toward each
11:42 - other until they hit each other so to do
11:44 - that we're going to create a while loop
11:47 - and the condition of our while loop is
11:49 - going to be while the left pointer is
11:51 - still less than the right pointer so
11:54 - once our left pointer runs into our
11:56 - right pointer this expression will
11:58 - evaluate to false and knock us out of
12:00 - our loop so inside of that loop we want
12:03 - to walk our left pointer from left to
12:05 - right until we find a number that is
12:07 - higher than the pivot or we hit our
12:10 - right pointer so to do that we're going
12:12 - to want an inner while loop so while the
12:15 - value of the array at that left pointer
12:18 - is less than or equal to the pivot and
12:22 - our left pointer is less than our right
12:25 - pointer so while that is still the case
12:27 - we want to increment our left pointer so
12:30 - left pointer plus plus so this will keep
12:33 - incrementing our left pointer until the
12:36 - value of the array at that left pointer
12:38 - is greater than the pivot or if it's
12:41 - walking from the left and never finds a
12:42 - value that's greater than the pivot
12:44 - eventually the left pointer will pass
12:46 - the right pointer and will also kick us
12:49 - out of this loop and we'll do exactly
12:50 - the same thing for walking from the
12:52 - right side we'll have another inner
12:55 - while loop we're going to walk from the
12:56 - right until we hit a number that is less
12:58 - than the pivot or until we pass our left
13:01 - pointer so it's going to look very
13:02 - similar while array at right pointer is
13:06 - greater than or equal to the pivot and
13:09 - left pointer less than right pointer
13:12 - because we want to move the right
13:13 - pointer from right to left we actually
13:16 - have to decrement it each time in the
13:18 - while loop instead so we'll do right
13:20 - pointer minus minus at this point we
13:23 - have a left pointer that's pointing to
13:24 - something that is larger than the pivot
13:26 - and a right pointer that is pointing to
13:28 - something smaller than the pivot and now
13:30 - we just want to swap those two numbers
13:32 - since we're going to have to do that
13:33 - swapping in a couple of places in our
13:35 - algorithm it's probably the best to do
13:37 - that in its own private method so let's
13:39 - scroll down here and create a new
13:42 - private static void method that we're
13:45 - going to call swap and it needs to take
13:47 - in three parameters one is the array
13:50 - that contains the two elements that we
13:52 - want to swap then it also needs to take
13:54 - in the two indexes that we want to swap
13:57 - so int index one and int index two in
14:01 - order to do a swap we just need to
14:02 - create a temporary variable we'll just
14:04 - call it temp to hold one of the values
14:07 - that we want to swap so in temp equals
14:09 - array of index 1 then we set the value
14:13 - of the array at index 1 equal to the
14:16 - value of the array at index 2. finally
14:20 - we set the value of the array at index 2
14:23 - equal to our temp variable so back up
14:26 - here in our quick sort method remember
14:28 - that at this point we wanted to swap the
14:30 - elements that were at our left pointer
14:33 - and right pointer so to do that now we
14:35 - can just call our swap method and pass
14:38 - in the array and also the left pointer
14:41 - and right pointer as the indexes that we
14:44 - want it to swap so what these while
14:46 - loops will do is keep moving the left
14:48 - pointer and right pointer closer and
14:50 - closer to each other swapping elements
14:52 - when it needs to until those pointers
14:54 - meet now remember from our demo that at
14:57 - that point what we want to do once our
14:59 - left pointer and right pointer meet we
15:01 - want to swap our pivot in with the value
15:05 - that our left pointer is pointing at
15:08 - like this so to do that it's very easy
15:10 - we can just call our swap method again
15:13 - pass in the array and we want to pass in
15:15 - our left pointer as the index of one of
15:18 - the elements we want to swap for the
15:20 - other index we actually want to pass in
15:22 - high index and that's because we know
15:24 - that this high index will be the index
15:26 - of our pivot because we've always chosen
15:28 - the last element as our pivot at that
15:31 - point the partitioning step is done all
15:33 - the numbers that are lower than the
15:34 - pivot should be to the left of it and
15:36 - all the numbers higher than the pivot
15:38 - should be to the right of it so the only
15:39 - step left is the recursive step where
15:41 - we're recursively quick sorting the
15:43 - partition to the left of the pivot and
15:45 - recursively quick sorting the partition
15:47 - to the right of the pivot so first let's
15:49 - make the recursive call for the
15:51 - partition to the left of the pivot so
15:53 - we'll recursively call our quick sort
15:55 - method we need to pass in our array but
15:57 - we also need to pass in a low index and
16:00 - a high index so at this point remember
16:02 - our pivot is right here so what we want
16:04 - to do is call quick sort for just these
16:07 - four elements so what do we need to use
16:09 - as the low index and the high index that
16:12 - we pass in well our low index will just
16:14 - be the very first number in the array
16:16 - that we were sorting in the first place
16:17 - right and that was passed in as low
16:20 - index to this method so for the low
16:22 - index we can just pass in low index now
16:25 - for our high index we want it to be the
16:27 - last element in the subarray that we're
16:29 - sorting now since our left pointer is
16:31 - going to be pointing at our pivot here
16:33 - the high index of this left partition is
16:36 - actually just going to be our left
16:38 - pointer minus one so we can just pass in
16:41 - left pointer minus one next we need to
16:44 - recursively quick sort the right
16:46 - partition and to do that is going to be
16:48 - very similar we'll call the quick sort
16:50 - method recursively pass in our array so
16:53 - what do we need to pass in for our low
16:55 - index well it's just going to be one
16:57 - number past our pivot which is where
16:59 - this left pointer is pointing so we can
17:02 - just use left pointer plus one so we'll
17:04 - just pass in left pointer
17:06 - plus one and for the high index that we
17:09 - pass in we can just pass in the high
17:11 - index of this entire array that we were
17:13 - sorting so we can just pass in high
17:16 - index before we finish this algorithm
17:18 - though there's still one case we haven't
17:20 - accounted for yet and that's the case
17:21 - where as these recursive calls keep
17:23 - going and going eventually it's going to
17:25 - be told to recursively sort a list of
17:28 - just one element at that point because
17:30 - an array of just one element is already
17:33 - sorted it can just return there's
17:34 - nothing that it has to do so we actually
17:36 - want to put that logic here at the top
17:38 - of our quicksort method so here if the
17:41 - low index is greater than or equal to
17:45 - the high index then we know we're
17:46 - dealing with a subarray of just one
17:48 - element and we can just return and
17:50 - there's nothing else we have to do okay
17:52 - and with that that should give us a
17:55 - working quick sort so let's go ahead and
17:58 - run our test program with 10 random ins
18:01 - and see if it works here we go okay so i
18:03 - printed our before and completely random
18:06 - order and then printed the after where
18:08 - everything looks to be perfectly sorted
18:11 - awesome let's go ahead and run it a few
18:13 - more times just to make sure everything
18:15 - is looking okay okay so now that we know
18:18 - our quicksort algorithm is working let's
18:19 - do a little bit of code cleanup to kind
18:21 - of optimize it and then we'll see
18:23 - exactly how fast quicksort is first just
18:26 - for code readability remember how we had
18:28 - three main steps in our quick sort
18:30 - algorithm choose a pivot do the
18:32 - partitioning and then do the recursive
18:34 - quick sort calls so here in this whole
18:37 - section right after we choose the pivot
18:39 - but before we do those recursive quick
18:42 - sort calls this is basically all
18:44 - partitioning code so it might be nice to
18:47 - split this out into its own method so to
18:49 - do that you can just highlight all the
18:51 - code that you want to put into that
18:53 - partition method and if you're using
18:55 - eclipse you can hit alt shift m that'll
18:57 - pop up this window here and all you need
18:59 - to do is name the method that you want
19:02 - to create so since this will be our
19:03 - partition method we will call it
19:05 - partition then just go ahead and hit ok
19:08 - and it automatically created our
19:10 - partition method with all the code that
19:13 - we wrote so now our quicksort method is
19:15 - even easier to read choosing a pivot
19:17 - performing the partitioning and then
19:19 - recursively quick sorting the left and
19:21 - right partitions next i mentioned at the
19:24 - beginning of the video that how you
19:25 - choose the pivot can be important
19:27 - because there are certain situations
19:29 - where if you choose the pivot really
19:31 - poorly it could result in worse average
19:33 - performance for quick sort so while
19:35 - choosing the last number in our array
19:37 - does work fine a strategy which ends up
19:40 - with a bit better average runtime is
19:42 - actually choosing a pivot at random that
19:45 - might sound like it'll be really
19:46 - complicated to implement but it's really
19:48 - just a pretty simple modification to
19:51 - what we have so far here's how that's
19:52 - going to work so we're going to choose a
19:54 - random element in this array as the
19:57 - pivot so let's say we randomly choose
19:59 - the number three instead of trying to do
20:01 - the partitioning with this three still
20:03 - in this same spot in the list what we're
20:05 - going to do is actually swap this
20:08 - element with the last element in our
20:11 - list right away so that way the three
20:13 - that we chose as our pivot is now at the
20:16 - end of the list and completely out of
20:18 - the way and at that point after we've
20:20 - swapped that pivot and put it at the end
20:22 - of our list everything else works
20:24 - exactly the same way that it did before
20:26 - we do the whole partitioning step with
20:28 - the rest of the array and at the end of
20:30 - that step we still swap out our pivot
20:32 - with the index of our left pointer so to
20:35 - do that in the code we're going to start
20:37 - here by creating an int that we'll call
20:39 - the pivot index this is going to be the
20:42 - index in our array that we're going to
20:43 - choose randomly as our pivot and in
20:45 - order to choose that randomly we are
20:47 - going to use the random class so we'll
20:50 - say newrandom.nextint
20:52 - and what we're going to pass into this
20:54 - method is high index minus low index and
20:58 - then we're actually going to add the low
21:00 - index this calculation will give you a
21:03 - random index somewhere between the low
21:05 - index and the high index that are passed
21:08 - in so now instead of just using the
21:10 - value of the array at the high index we
21:12 - want to choose the value of the array at
21:14 - the pivot index that we just randomly
21:16 - generated and then we need to do the
21:18 - swap that we talked about where we swap
21:20 - that random pivot with that last element
21:22 - of our array so to do that we can just
21:24 - do swap pass in our array and then swap
21:27 - our pivot index with the high index so
21:31 - that's all you need to change in order
21:34 - to choose your pivot randomly so you
21:36 - should be able to rerun your code
21:37 - everything should still be sorted
21:39 - perfectly except your algorithm will now
21:41 - perform a little bit better in the
21:43 - average case
21:44 - one other thing here is that it's kind
21:46 - of ugly that at the beginning when you
21:48 - call this quick sort method initially
21:50 - you have to pass in the low index and
21:53 - the high index it would be nice if you
21:55 - could just pass in the array that you
21:57 - want to quick sort like this well what
21:59 - we can do is actually create another
22:02 - private method and we'll actually also
22:04 - call it quick sort so we will overload
22:07 - the quick sort method overloading is
22:09 - when you have more than one method that
22:11 - has the same name but different
22:14 - parameters so in this case we'll only
22:16 - take in
22:18 - the array that we want to sort so this
22:20 - isn't the method that we're going to be
22:21 - calling recursively we'll only call it
22:23 - the first time when we want to initiate
22:25 - the quick sort all we have to do in this
22:27 - method is call this other quick sort
22:30 - method that does take in the low index
22:33 - and the high index so we'll just call
22:35 - that other quick sort method pass in the
22:37 - array and just as we did before we'll
22:39 - pass in zero as the low index and array
22:43 - dot length minus one as the high index
22:47 - so now we should again be able to rerun
22:49 - our program and have everything work
22:51 - exactly as it did before the only
22:53 - difference is now you can kind of call
22:55 - this quick sort method a bit more
22:57 - naturally where you just have to pass in
22:59 - the array that you want to sort now that
23:01 - we have everything fully optimized let's
23:03 - crank this up and see how fast quicksort
23:06 - actually is so instead of just sorting
23:08 - 10 numbers we're gonna have it sort a
23:10 - million numbers and instead of doing
23:12 - between zero and about a hundred we'll
23:14 - do between zero and about ten thousand
23:17 - okay it took a while for it to print out
23:19 - but it's already printing out the
23:20 - completed lists all right that finished
23:23 - really quickly i think most of the time
23:25 - it took there was actually just printing
23:27 - out the initial million numbers so what
23:29 - i'm actually going to do now that we
23:30 - know that the algorithm is working i'm
23:33 - going to take out the steps where it's
23:35 - printing the array out because i think
23:37 - that's probably taking the most time all
23:39 - right let's go ahead and run that again
23:41 - 1 million numbers okay it was done
23:43 - basically instantly in less than one
23:46 - second so let's crank this up to 10
23:48 - million okay that did take a little bit
23:50 - longer about five seconds let's keep
23:52 - going and do
23:54 - a hundred million okay so at a hundred
23:56 - million we actually hit a stack overflow
24:00 - error so what's happening here is that
24:02 - just due to the sheer size of the array
24:05 - that we're sorting it ends up having to
24:07 - make tons and tons of recursive calls
24:10 - and each time it makes a recursive call
24:13 - it adds that method that it's calling
24:15 - onto something called the stack and
24:18 - there's only a certain amount of memory
24:20 - allocated to that stack in java and once
24:23 - you hit that limit you get a stack
24:24 - overflow error and there's just nothing
24:26 - you can do about it but still for
24:28 - sorting an array of 10 million elements
24:31 - in less than five seconds that is pretty
24:33 - awesome and that's why quicksort is
24:35 - generally regarded as the fastest
24:37 - sorting algorithm out there if you
24:39 - enjoyed this video or learned something
24:40 - please let me know by hitting the like
24:42 - button and be sure to subscribe so you
24:43 - don't miss each new java tutorial and
24:45 - after you make sure you completely
24:47 - understand quicksort don't stop there
24:49 - and keep your momentum going by watching
24:50 - one of these other job tutorials below
24:52 - thank you so much for watching i really
24:54 - appreciate you being here with me i'll
24:56 - see you next time

Cleaned transcript:

quicksort is one of the fastest sorting algorithms out there but it can also be one of the hardest to understand in this video we'll go through exactly how the quick sort algorithm works in detail in a way that i promise you'll understand then we'll walk through coding our own quicksort implementation in java my name is john i'm a lead java software engineer and i love sharing what i've learned with you in a clear and understandable way i also have a full java course available and a link down in the description if you're interested let's get right into it okay before we just dive into eclipse and start coding it's important to know how the quick sort algorithm works the whole quick sort algorithm is basically just three steps the first step is choose one of the numbers in your array as the pivot so you might be thinking what do you mean choose a pivot i just choose any number in my array here as my pivot and essentially the answer is yes it's not so much that the pivot you pick isn't important but how you choose a pivot isn't important to understanding the actual algorithm what we're going to be doing is just choosing the last element in the array as the pivot and i'll show you how that works then at the end of the video we'll go over a better strategy for picking the pivot which is also still really easy to implement after you've chosen the pivot the second step is to move all numbers in the array that are lower than the pivot to the left of it and all numbers that are higher than the pivot to the right of it this step is also called partitioning so since we're using the last number as our pivot in this case it will be seven and the partitioning step will put all numbers less than 7 on the left side of the 7 so that means that the 1 the 3 the 4 and 5 will all be moved to the left of 7 and 8 and 9 will be moved to the right of 7. so after that partitioning step all the numbers to the left of 7 are smaller than 7 and all the numbers to the right of 7 are larger and the number that we chose for our pivot the 7 in this case is actually in its final spot in the array the partitioning step is probably the most complicated to code but don't worry we'll go through that part step by step after partitioning the third step is to recursively quick sort all the values to the left of that pivot and all the values to the right of the pivot and when we do the quick sort for those sub arrays it's done exactly the same way we just did it so first we would do the quick sort for the left portion here and we'll repeat the same steps that we did before which are first choose a pivot and again we're just going to use the last number as the pivot which in this case would be 1. then we do the partitioning where we take any number that is greater than 1 and put it to the right of 1 and any number that is less than one and put it to the left in this case they all happen to be greater than one so they all go to the right of one then after the partitioning step of that quick sort we then recursively quick sort all the elements to the left of the pivot and all the elements to the right of the pivot there's no elements to the left of the pivot because our pivot was 1 in this case so we just have to recursively quick sort all the numbers to the right of the pivot and again we do that exactly the same way where we first choose a pivot which is going to be the last number for us or five then we move all the numbers in this subarray that are less than five to the left of five and all the numbers that are more than five to the right in this case three and four are both less than five and they're already to the left of five so there's nothing we have to swap then again we recursively quick sort the sub arrays to the left and right of that pivot since there's nothing to the right of 5 we only have to recursively quick sort the subarray to the left of 5 which is 3 and 4. again to quick sort this subarray we first choose a pivot which for us is going to be the last number in this array four then we do the partitioning again where in this case three is less than four and it's already to the left of four and then we recursively quick sort each subarray to the left and right of four in this case we only have a subarray to the left of four here which is just the number three the number three is just one element so it's already sorted so now we've completed quick sorting all of the numbers that were originally next to the seven but remember we still have to recursively sort all the numbers to the right of the seven and of course we just quick sort this in exactly the same way first we choose a pivot which in our case we're just going to choose the last number which is nine then we do the partitioning where in this case there's no changes that we have to make because 8 is less than 9 and it's already to the left of 9. then we recursively quick sort these subarrays to the left and right of our pivot in this case we only have a subarray to the left of the pivot which is just the number 8. since it's only one element it's already in order and there's nothing that we have to do at that point we've completed all of the recursive quick sorts and we finally end with our perfectly sorted array and now for the fun part let's get to coding as always with these sorting algorithm tutorials i'm starting here with a little bit of setup just so we can test the sorting algorithm that we write this first part will generate an array of 10 integers randomly between 0 and 99. so that just gives us a random array of ins to sort then we print out that array here in its initial completely random order then we call our quicksort method here which we are going to write where all the magic happens and it sorts our array from smallest to largest and then after that we print out the array again hopefully in perfectly sorted order so let's go ahead and jump into that quick sort method which is currently completely empty and we'll start our implementation you may have noticed that it's actually taking in three parameters the first one is the actual array that it's going to sort that makes sense but then it also takes in a low index and high index if you remember from the demo quick sort is a recursive algorithm where after we do the partitioning where we put all the numbers less than the pivot to the left and all the numbers higher than the pivot to the right we recursively quick sort all the numbers in the left partition and recursively quick sort all the numbers in the right partition that recursive step is why we need the low index and the high index when we tell it to recursively sort the subarray we don't want to just tell it to recursively sort the entire array again so we pass in basically a range a low index and a high index of that particular subarray so that it can properly do the recursive quick sorts however that does make it so that when you initially call the quick sort method in addition to passing in the array you need to pass in the low index and the high index too which of course when you want to just sort the entire array the low index is going to be 0 and the high index is just going to be the last element in the array which is just going to be the length of the array minus 1. near the end of the video i'm going to show you a trick where you can get rid of this for your initial quick sort call and just have to pass in the array that you want to sort all right now let's get to writing our quick sort method now what was the first step in our quick sort algorithm it's to choose a pivot and remember for our purposes we're just going to choose the last number as the pivot so to do that we'll just create an int and we'll call it pivot and set it equal to the value of the array at that high index that's passed in here remember that this is a recursive algorithm so we can't always just pick the last element of the entire array that we're sorting as the pivot in any given recursive step in the middle we might just be sorting one small sub array portion of the entire array and that'll be passed into this method recursively with a low index and a high index indicating that range that we want to be recursively sorting right now so the last element of that particular range that we want to be sorting is going to be passed in as high index now we've done the easy part we've chosen a pivot now for the hard part the partitioning where we have to move all the numbers lower than the pivot to the left of the pivot and all the numbers higher than the pivot to the right of the pivot how exactly are we going to do that in the code here's what we're going to do so we chose a pivot right that is just going to be the the last number in this case 7. so 7 is our pivot and for now we're just going to ignore that and let it be and just focus on all of the other numbers then what we're going to do is create two variables that we're going to use as pointers one we'll call the left pointer and we're going to start at the leftmost part of the array and the other will call right pointer and we're going to start it at the rightmost portion of the array we're going to start with the left pointer what we're going to do is start walking through our array a single element at a time until we find an element that is larger than the pivot so first we look at the number one is one larger than seven no so then we move that left pointer over to look at the number eight is eight larger than seven yes so we'll stop there and leave that left pointer pointing at the number eight and then we move on to our right pointer and what we're going to do with the right pointer is start walking from the right side of the list one element at a time to the left until we run into a number that is less than our pivot so our right pointer starts looking at the number five is the number five less than seven yes so we stop there with the right pointer pointing at the number five so at this point our left pointer is pointing to a number that is greater than our pivot and our right pointer is pointing to a number that is less than our pivot at that point we are going to swap the numbers at those two pointers so our eight will move over here where the five was and the five will move down here where our eight was then we repeat that process we move our left pointer over one spot so our left pointer is pointing at the number three is three greater than seven no it's not so we move our left pointer over to point at the number nine is nine greater than seven yes so we stop there with the left pointer pointing at nine then we move over to our right pointer and move it to the left to look at the number four is four less than seven yes so we stop there at this point our left pointer is pointing to a number that is greater than seven and our right pointer is pointing to a number that is less than seven at that point we swap the two numbers that our left pointer and right pointer are pointing to then we continue that same process we move the left pointer over one spot at this point our left pointer and right pointer are pointing to exactly the same element once that happens we want to stop that process of moving the left pointer and right pointer toward each other and then what we're going to do is swap our pivot with the number that our left pointer is pointing to so in this case the number nine so that will move our 9 out to here where our pivot was and our 7 in here where our 9 was at that point the partitioning step is complete so you'll notice that all the numbers less than 7 are to the left of 7 and all the numbers that are greater than 7 are to the right of seven after that partitioning happens we're going to recursively quick sort the sub array to the left of our pivot and recursively quick sort the subarray to the right of our pivot that partitioning step is probably the most important part of the quick sort algorithm let's put what we just talked about into some code first we'll declare our two pointers left pointer and right pointer so we're going to have int left pointer and we're going to start the left pointer at the left side of the array that we're sorting so we can just initialize it to low index and we'll also create an int right pointer and we'll start it at the high index of the array that we want to sort now we need to create a loop that will move the left index and the right index toward each other until they hit each other so to do that we're going to create a while loop and the condition of our while loop is going to be while the left pointer is still less than the right pointer so once our left pointer runs into our right pointer this expression will evaluate to false and knock us out of our loop so inside of that loop we want to walk our left pointer from left to right until we find a number that is higher than the pivot or we hit our right pointer so to do that we're going to want an inner while loop so while the value of the array at that left pointer is less than or equal to the pivot and our left pointer is less than our right pointer so while that is still the case we want to increment our left pointer so left pointer plus plus so this will keep incrementing our left pointer until the value of the array at that left pointer is greater than the pivot or if it's walking from the left and never finds a value that's greater than the pivot eventually the left pointer will pass the right pointer and will also kick us out of this loop and we'll do exactly the same thing for walking from the right side we'll have another inner while loop we're going to walk from the right until we hit a number that is less than the pivot or until we pass our left pointer so it's going to look very similar while array at right pointer is greater than or equal to the pivot and left pointer less than right pointer because we want to move the right pointer from right to left we actually have to decrement it each time in the while loop instead so we'll do right pointer minus minus at this point we have a left pointer that's pointing to something that is larger than the pivot and a right pointer that is pointing to something smaller than the pivot and now we just want to swap those two numbers since we're going to have to do that swapping in a couple of places in our algorithm it's probably the best to do that in its own private method so let's scroll down here and create a new private static void method that we're going to call swap and it needs to take in three parameters one is the array that contains the two elements that we want to swap then it also needs to take in the two indexes that we want to swap so int index one and int index two in order to do a swap we just need to create a temporary variable we'll just call it temp to hold one of the values that we want to swap so in temp equals array of index 1 then we set the value of the array at index 1 equal to the value of the array at index 2. finally we set the value of the array at index 2 equal to our temp variable so back up here in our quick sort method remember that at this point we wanted to swap the elements that were at our left pointer and right pointer so to do that now we can just call our swap method and pass in the array and also the left pointer and right pointer as the indexes that we want it to swap so what these while loops will do is keep moving the left pointer and right pointer closer and closer to each other swapping elements when it needs to until those pointers meet now remember from our demo that at that point what we want to do once our left pointer and right pointer meet we want to swap our pivot in with the value that our left pointer is pointing at like this so to do that it's very easy we can just call our swap method again pass in the array and we want to pass in our left pointer as the index of one of the elements we want to swap for the other index we actually want to pass in high index and that's because we know that this high index will be the index of our pivot because we've always chosen the last element as our pivot at that point the partitioning step is done all the numbers that are lower than the pivot should be to the left of it and all the numbers higher than the pivot should be to the right of it so the only step left is the recursive step where we're recursively quick sorting the partition to the left of the pivot and recursively quick sorting the partition to the right of the pivot so first let's make the recursive call for the partition to the left of the pivot so we'll recursively call our quick sort method we need to pass in our array but we also need to pass in a low index and a high index so at this point remember our pivot is right here so what we want to do is call quick sort for just these four elements so what do we need to use as the low index and the high index that we pass in well our low index will just be the very first number in the array that we were sorting in the first place right and that was passed in as low index to this method so for the low index we can just pass in low index now for our high index we want it to be the last element in the subarray that we're sorting now since our left pointer is going to be pointing at our pivot here the high index of this left partition is actually just going to be our left pointer minus one so we can just pass in left pointer minus one next we need to recursively quick sort the right partition and to do that is going to be very similar we'll call the quick sort method recursively pass in our array so what do we need to pass in for our low index well it's just going to be one number past our pivot which is where this left pointer is pointing so we can just use left pointer plus one so we'll just pass in left pointer plus one and for the high index that we pass in we can just pass in the high index of this entire array that we were sorting so we can just pass in high index before we finish this algorithm though there's still one case we haven't accounted for yet and that's the case where as these recursive calls keep going and going eventually it's going to be told to recursively sort a list of just one element at that point because an array of just one element is already sorted it can just return there's nothing that it has to do so we actually want to put that logic here at the top of our quicksort method so here if the low index is greater than or equal to the high index then we know we're dealing with a subarray of just one element and we can just return and there's nothing else we have to do okay and with that that should give us a working quick sort so let's go ahead and run our test program with 10 random ins and see if it works here we go okay so i printed our before and completely random order and then printed the after where everything looks to be perfectly sorted awesome let's go ahead and run it a few more times just to make sure everything is looking okay okay so now that we know our quicksort algorithm is working let's do a little bit of code cleanup to kind of optimize it and then we'll see exactly how fast quicksort is first just for code readability remember how we had three main steps in our quick sort algorithm choose a pivot do the partitioning and then do the recursive quick sort calls so here in this whole section right after we choose the pivot but before we do those recursive quick sort calls this is basically all partitioning code so it might be nice to split this out into its own method so to do that you can just highlight all the code that you want to put into that partition method and if you're using eclipse you can hit alt shift m that'll pop up this window here and all you need to do is name the method that you want to create so since this will be our partition method we will call it partition then just go ahead and hit ok and it automatically created our partition method with all the code that we wrote so now our quicksort method is even easier to read choosing a pivot performing the partitioning and then recursively quick sorting the left and right partitions next i mentioned at the beginning of the video that how you choose the pivot can be important because there are certain situations where if you choose the pivot really poorly it could result in worse average performance for quick sort so while choosing the last number in our array does work fine a strategy which ends up with a bit better average runtime is actually choosing a pivot at random that might sound like it'll be really complicated to implement but it's really just a pretty simple modification to what we have so far here's how that's going to work so we're going to choose a random element in this array as the pivot so let's say we randomly choose the number three instead of trying to do the partitioning with this three still in this same spot in the list what we're going to do is actually swap this element with the last element in our list right away so that way the three that we chose as our pivot is now at the end of the list and completely out of the way and at that point after we've swapped that pivot and put it at the end of our list everything else works exactly the same way that it did before we do the whole partitioning step with the rest of the array and at the end of that step we still swap out our pivot with the index of our left pointer so to do that in the code we're going to start here by creating an int that we'll call the pivot index this is going to be the index in our array that we're going to choose randomly as our pivot and in order to choose that randomly we are going to use the random class so we'll say newrandom.nextint and what we're going to pass into this method is high index minus low index and then we're actually going to add the low index this calculation will give you a random index somewhere between the low index and the high index that are passed in so now instead of just using the value of the array at the high index we want to choose the value of the array at the pivot index that we just randomly generated and then we need to do the swap that we talked about where we swap that random pivot with that last element of our array so to do that we can just do swap pass in our array and then swap our pivot index with the high index so that's all you need to change in order to choose your pivot randomly so you should be able to rerun your code everything should still be sorted perfectly except your algorithm will now perform a little bit better in the average case one other thing here is that it's kind of ugly that at the beginning when you call this quick sort method initially you have to pass in the low index and the high index it would be nice if you could just pass in the array that you want to quick sort like this well what we can do is actually create another private method and we'll actually also call it quick sort so we will overload the quick sort method overloading is when you have more than one method that has the same name but different parameters so in this case we'll only take in the array that we want to sort so this isn't the method that we're going to be calling recursively we'll only call it the first time when we want to initiate the quick sort all we have to do in this method is call this other quick sort method that does take in the low index and the high index so we'll just call that other quick sort method pass in the array and just as we did before we'll pass in zero as the low index and array dot length minus one as the high index so now we should again be able to rerun our program and have everything work exactly as it did before the only difference is now you can kind of call this quick sort method a bit more naturally where you just have to pass in the array that you want to sort now that we have everything fully optimized let's crank this up and see how fast quicksort actually is so instead of just sorting 10 numbers we're gonna have it sort a million numbers and instead of doing between zero and about a hundred we'll do between zero and about ten thousand okay it took a while for it to print out but it's already printing out the completed lists all right that finished really quickly i think most of the time it took there was actually just printing out the initial million numbers so what i'm actually going to do now that we know that the algorithm is working i'm going to take out the steps where it's printing the array out because i think that's probably taking the most time all right let's go ahead and run that again 1 million numbers okay it was done basically instantly in less than one second so let's crank this up to 10 million okay that did take a little bit longer about five seconds let's keep going and do a hundred million okay so at a hundred million we actually hit a stack overflow error so what's happening here is that just due to the sheer size of the array that we're sorting it ends up having to make tons and tons of recursive calls and each time it makes a recursive call it adds that method that it's calling onto something called the stack and there's only a certain amount of memory allocated to that stack in java and once you hit that limit you get a stack overflow error and there's just nothing you can do about it but still for sorting an array of 10 million elements in less than five seconds that is pretty awesome and that's why quicksort is generally regarded as the fastest sorting algorithm out there if you enjoyed this video or learned something please let me know by hitting the like button and be sure to subscribe so you don't miss each new java tutorial and after you make sure you completely understand quicksort don't stop there and keep your momentum going by watching one of these other job tutorials below thank you so much for watching i really appreciate you being here with me i'll see you next time
