With timestamps:

00:00 - today we're going to be solving another
00:01 - lead code coding exercise this is going
00:04 - to be an interesting one to find a fast
00:06 - solution for and I'm also going to talk
00:07 - a little bit about the thought process
00:09 - behind coming up with the solutions for
00:12 - these sorts of problems but first thanks
00:13 - to mailgun for sponsoring this video
00:15 - mailgun is how modern companies work
00:18 - with email mailgun is easy to use has
00:20 - amazing 24 7 customer support and simple
00:23 - but powerful apis that smart developers
00:26 - can use to reach their customers at
00:28 - scale so their organizations can grow
00:30 - faster you can use mailguns API to send
00:32 - an email with just a few lines of code
00:34 - with whatever language you're using of
00:36 - course including Java it really couldn't
00:38 - be easier today mailgun is used by over
00:40 - a hundred thousand companies and top
00:42 - brands around the world to provide
00:44 - personal connected experiences through
00:46 - email and drive smart results you can
00:48 - send and track transactional and
00:50 - marketing messages remove invalid emails
00:52 - from your list or prevent fake signups
00:54 - in the first place easily mailgun also
00:57 - has an awesome send time optimization
00:59 - feature that automatically finds the
01:01 - perfect time to send to each and every
01:03 - individual on your list at the exact
01:05 - time that they're most likely to engage
01:07 - they also have a team of email experts
01:09 - ready to work with you to improve your
01:11 - email deliverability and also Drive
01:13 - higher conversion rates with its
01:15 - intuitive email Marketing Solutions and
01:17 - Powerful API mailgun Works through the
01:19 - whole email lifecycle from
01:21 - pre-development all the way to the inbox
01:23 - for more than 240 billion emails a year
01:26 - for companies like Wikipedia DHL toast
01:29 - Lyft and Microsoft helping them solve
01:32 - complex communication problems and build
01:34 - connected experiences through email so
01:36 - thanks again to mailgun for sponsoring
01:38 - this video try mailgun today by using my
01:40 - link which you can find down in the
01:42 - description mailgun.com John now let's
01:46 - get to it so this is lead code problem
01:48 - number three and it's a medium
01:50 - difficulty problem it's called longest
01:52 - substring without repeating characters
01:54 - so basically we're going to be given
01:56 - some string we'll call it s and our task
01:59 - will be to to find the length of the
02:02 - longest substring within that string
02:04 - that doesn't repeat any characters so
02:07 - they've got a few examples here so if
02:09 - our input string is a b c a b c b b well
02:13 - the longest substring within this string
02:15 - that doesn't repeat any characters is
02:18 - just ABC so if we were looking through
02:21 - this string we would go okay A B C all
02:24 - right we haven't repeated any characters
02:25 - yet and so far we've got a substring
02:28 - length of three but if we were to try
02:30 - and add the next character well that's
02:32 - an A and we already have an A so that's
02:34 - not a valid solution so the longest
02:36 - substring without repeating characters
02:38 - in this example is ABC and that has a
02:40 - length of 3 and so our output would be
02:43 - three one thing to note about this
02:44 - example is that technically the solution
02:46 - could have been BCA also or c a b those
02:51 - are also substrings that don't repeat
02:54 - any characters but they also just have a
02:56 - max length of three anyway so it doesn't
02:58 - change what our output is still the
03:00 - longest substring that doesn't repeat
03:02 - any characters in this string is just
03:04 - three so if we scroll down to the bottom
03:06 - here we can see that we have a couple of
03:08 - constraints on the string input that
03:10 - we're going to receive so one thing is
03:12 - that it'll only consist of English
03:13 - letters digits symbols and spaces that
03:16 - just means there's nothing really crazy
03:17 - for us to deal with as far as the
03:19 - characters go and it also says that the
03:21 - length of our string is going to be
03:24 - greater than or equal to zero so we
03:26 - won't have a negative number of
03:27 - characters in our string and the length
03:29 - of the string will be less than or equal
03:31 - to 5 times 10 to the fourth okay Elite
03:34 - code you're trying to be real fancy
03:35 - there with the scientific notation this
03:37 - is just fifty thousand ten to the fourth
03:40 - is ten thousand times five is fifty
03:42 - thousand and that really shouldn't be
03:44 - big enough to cause any sort of problem
03:46 - with any kind of solution that we might
03:47 - come up with as far as memory goes or
03:49 - anything like that so let's start
03:51 - thinking about the solution for this
03:53 - problem so with a lot of these leak code
03:55 - problems there's often like a Brute
03:57 - Force solution that most people come up
03:59 - with first and then often there's a more
04:02 - clever answer that's a little bit more
04:04 - tricky to come up with but leads to a
04:07 - much more efficient and fast solution
04:09 - now the same thing is the case here so
04:12 - to start let's look at an example string
04:14 - that we might be given and talk about
04:16 - what our Brute Force solution to this
04:18 - problem will look like basically we're
04:20 - just going to Loop through every single
04:22 - possible substring of this string until
04:25 - each of those substrings repeats a
04:27 - character and then keep a running
04:29 - maximum of the largest substring that we
04:31 - find that doesn't repeat any characters
04:33 - that might sound a little bit confusing
04:35 - so let's just walk through a quick
04:37 - example of what it's going to look like
04:38 - so what we'll do is start by looking at
04:40 - all the substrings of this string that
04:43 - start with the first letter A of course
04:46 - just the letter A by itself has no
04:49 - repeating characters so as of right now
04:51 - the maximum substring that we found that
04:53 - doesn't repeat any characters is of
04:56 - length one and then we say okay we
04:58 - haven't run into any repeating
05:00 - characters yet let's add the next
05:02 - character to our substring and the next
05:04 - character is B so now our substring that
05:07 - we're looking at is a b and so we say
05:10 - okay we're adding B does B already exist
05:13 - anywhere in our substring no it doesn't
05:15 - so there's still no repeating characters
05:17 - so now the maximum substring that we
05:19 - found that doesn't repeat any characters
05:21 - is of length two next we go ahead and
05:23 - add the C to our substring the C already
05:27 - exists anywhere in our substring no so
05:29 - we still don't have any repeating
05:30 - characters in this substring so our new
05:32 - maximum is three so next we look at the
05:35 - next character which is a does a re
05:37 - exist in our substring yes it does so
05:41 - now this substring contains repeating
05:43 - characters and so it doesn't count as a
05:46 - valid substring that we're looking for
05:47 - so now that we've run into a substring
05:49 - that has a repeating character we know
05:51 - that the largest substring that starts
05:53 - with this first a that doesn't repeat
05:55 - any characters is just a b c you know
05:58 - that has a length of 3. so next we have
06:01 - to look at all the substrings that start
06:03 - with the second letter of our string b b
06:07 - by itself doesn't contain any repeating
06:08 - characters but it's only of length one
06:10 - which is not greater than three so our
06:12 - maximum is still three and then we move
06:15 - this over to include c b c also doesn't
06:18 - contain any repeating characters but it
06:19 - only has a length of two so it's not
06:21 - bigger than the maximum we already have
06:23 - so we move over and look at BCA it also
06:26 - doesn't have any repeating characters
06:28 - but just has a length of three so
06:30 - there's no need to change our maximum
06:31 - and then when we move this over to
06:33 - include B now we have repeating
06:35 - characters and this isn't a valid
06:38 - substring anymore so then we move the
06:39 - beginning of the substring that we're
06:41 - looking at over to the C and do the same
06:44 - thing all over again so that would
06:46 - eventually get to c a b with no
06:48 - repeating characters which is still just
06:50 - a length of three and then when we add
06:52 - on the next C it now has a repeating
06:54 - character but then we will move on to
06:56 - starting with this a and this can
06:59 - proceed all the way to the end of our
07:01 - string without repeating any characters
07:04 - a b c d has a length of four and doesn't
07:07 - repeat any characters so when our
07:09 - program sees that it will update this
07:11 - maximum to four and then it'll Loop
07:13 - through all the rest of these characters
07:15 - in exactly the same way but it won't
07:17 - find any non-repeating substring that's
07:20 - any longer than four which is this a b c
07:23 - d and so we'll find that the solution is
07:26 - four so next let's go ahead and copy
07:29 - this over to IntelliJ so we can do our
07:31 - coding there and let's get to
07:34 - implementing that Brute Force algorithm
07:35 - so first a good thing to have is just
07:38 - going to be an INT variable a max length
07:41 - that we're going to use to keep the
07:43 - maximum length of the non-repeating
07:45 - substring that we've identified so we'll
07:47 - eventually return that as our solution
07:49 - and we'll initialize it to zero next
07:52 - we're going to want a loop that will
07:54 - look through each individual character
07:56 - of our input string and use each
07:59 - character as the start of the substring
08:02 - that we're looking at and we'll just
08:03 - keep that simple and use a for Loop this
08:05 - will be a pretty simple for Loop so for
08:07 - INT I equals zero we're going to keep
08:10 - looping while I is less than s dot
08:13 - length and each iteration through the
08:15 - loop we're going to increment I but now
08:17 - nested within that as We're looping
08:20 - through each character in our string
08:22 - being the start of each substring that
08:24 - we want to look at we then have to have
08:26 - an inner loop that adds on each
08:30 - subsequent character to our substring
08:33 - and you know keeps doing that and adding
08:35 - characters until we find one that
08:39 - repeats so in order to do that we're
08:41 - actually going to need a nested for Loop
08:44 - within this one or int J we'll call it
08:47 - and we'll actually start it not at zero
08:50 - but we'll initialize it to I because we
08:53 - don't necessarily want to start our
08:55 - inner loop at the very beginning of the
08:57 - entire string we want to start it at the
08:59 - beginning of the substring that we're
09:01 - looking at and that will always start
09:03 - with the ith character we will still
09:06 - Loop while J is less than s dot length
09:10 - we'll go to the end of the string with
09:12 - our inner loop as well and in the Inner
09:14 - Loop we will increment J each time but
09:17 - actually just within our outer loop we
09:20 - want to create something that we can use
09:22 - to build our substring something that
09:25 - for each iteration of our inner loop we
09:28 - can add to in order to build the
09:30 - substring that starts with a certain
09:32 - character now there's a bunch of
09:34 - potential ways you could do this but one
09:35 - decent way is with a string Builder now
09:38 - string Builder if you've never used it
09:40 - before is kind of what the name of it
09:42 - says it's an object that you can use to
09:44 - build strings and often we'll use it in
09:47 - situations like this where we want to
09:49 - add to a string in iterations through a
09:52 - loop so here we'll create a string
09:54 - Builder and call it let's say current
09:56 - substring we'll just initialize it to a
09:59 - new string Builder so now what we're
10:01 - going to do is in each iteration of this
10:04 - inner for loop we're going to be adding
10:06 - each subsequent character to the
10:10 - substring that we're building and along
10:11 - the way as we're building the substrings
10:13 - as long as the current substring we are
10:16 - looking at doesn't have any repeated
10:17 - characters we're going to be seeing if
10:19 - it exceeds our current max length and if
10:22 - it does we will update the max length to
10:25 - be the current large substring that
10:27 - we're looking at and we're going to keep
10:28 - looping through adding the next
10:29 - character to the substring that we're
10:31 - looking at until we find a repeated
10:33 - character and then once we find a
10:35 - repeated character we're going to break
10:37 - out of this inner for Loop and then
10:39 - start looking at every substring that
10:41 - starts with the next character in the
10:44 - string so for example as the outer loop
10:47 - is looking at this first character a our
10:49 - inner loop is going to be looping
10:51 - through each subsequent character after
10:54 - that a adding it to the substring that
10:57 - it's building that string Builder that
10:58 - we created it and it's going to do that
11:00 - until it adds a character that it
11:03 - identifies as being a repeat and so when
11:06 - we do find a character that repeats like
11:08 - that the outer loop is going to
11:10 - increment by one and we are going to
11:12 - start looking at all substrings that
11:15 - start with the next letter of our string
11:18 - and then our inner for Loop is going to
11:20 - do the same thing it's going to use that
11:22 - string Builder to add on each subsequent
11:26 - character in our string onto the string
11:29 - Builder until it identifies a repeat
11:32 - character so here's how we're going to
11:34 - implement that functionality into our
11:36 - inner for Loop first we're going to
11:38 - check whether the next character that
11:40 - we're about to add on our substring
11:42 - already appears in our current substring
11:46 - and if it does well we have a repeated
11:48 - character and we want to break out of
11:50 - our inner loop to do that we can say if
11:53 - so what we'd like to do is take our
11:56 - current substring and see if it already
11:59 - contains the next character that we're
12:02 - about to add to it but unfortunately
12:04 - string Builder doesn't actually have a
12:06 - contains method that just returns a
12:08 - simple Boolean so what we have to do is
12:10 - instead we have to call the index of
12:14 - method on it so the next character that
12:16 - we would add to the substring is the
12:18 - character that's at the jth position in
12:21 - our original string and so to get that
12:23 - we can just call s dot Char at and then
12:26 - pass in the index we're looking for J
12:28 - now again unfortunately this index of
12:31 - method can't take a character you have
12:34 - to pass in a string but luckily it's
12:37 - easy to convert a string to a character
12:39 - all we have to do is call string dot
12:42 - value of and then pass in our character
12:45 - like this so now what this index of call
12:47 - will return is it will return the
12:50 - position of this next character that
12:52 - we're about to add in the current
12:54 - substring if it already exists there and
12:57 - if it doesn't already exist there it
12:59 - it'll return a negative one when it
13:01 - returns a negative one that's its way of
13:03 - telling us I didn't find that character
13:06 - in this string Builder what that means
13:08 - is if the index of this character is
13:12 - anything except for negative one that
13:16 - means that that character already exists
13:18 - in our substring and we have a repeated
13:20 - character and as we said once we find a
13:23 - repeated character we want to break out
13:26 - of our inner for Loop so that is
13:29 - accounting for the situation where you
13:31 - know we're adding more things to our
13:33 - substring making sure there are no
13:34 - repeated characters but then once we do
13:37 - that and we're about to add a character
13:39 - that would be a repeat so in this
13:41 - situation when we're about to add an A
13:43 - but we already have an A that would
13:45 - break out of our inner for Loop and then
13:47 - it would start looking for substrings
13:49 - that start with the next character in
13:52 - the original string however if it gets
13:54 - past this point then we know that the
13:56 - next character that it's about to add is
13:58 - not already in the current substring
14:00 - that we're looking at so in that case
14:01 - great let's go ahead and add it to the
14:04 - current substring that we're building
14:05 - and to do that we just call current
14:07 - substring dot append and we want to
14:10 - append that same character at the jth
14:13 - position of our string so all this
14:15 - append method does is take the character
14:18 - that we're passing in and add it onto
14:20 - the end of our current substring so now
14:23 - we know that the current substring that
14:24 - we're looking at doesn't have any
14:26 - repeated characters so what we want to
14:27 - do is if that current substrings length
14:31 - is greater than the current maximum
14:34 - length non-repeated substring that we
14:37 - found so far then we want to set our max
14:39 - length to be the length of our current
14:42 - substring current substring dot length
14:45 - kind of a cooler way to do this though
14:46 - instead of having to okay let's check to
14:48 - see if the length is greater than the
14:50 - max length and if it is then we'll set
14:52 - the max length to be that one that works
14:54 - just fine but if you want to be really
14:56 - cool about it instead you can do
14:57 - something like Max length equals math
15:01 - dot Max and then pass in as the two
15:04 - parameters the current max length and
15:07 - also the length of the current substring
15:10 - and then you can get rid of this because
15:12 - this line of code is doing the exact
15:14 - same thing this math.max method will
15:17 - just return whichever one of these two
15:20 - parameters is larger so what that means
15:23 - is if the maximum length is already
15:25 - larger than the current substrings
15:27 - length it'll just get set to that max
15:29 - length again but if our current
15:31 - substrings length is larger then it will
15:34 - set max length to be that instead so
15:36 - it's just a little bit more of a concise
15:38 - way to do the same thing so then after
15:40 - all of that after it does all those
15:43 - Loops through all the possible
15:44 - substrings and maintaining that maximum
15:46 - length of the non-repeated substring
15:48 - that it finds at the very end of this
15:50 - method we actually have to return that
15:54 - maximum length that we found I think
15:56 - that should do it let's go ahead and
15:58 - copy this solution and paste it back
16:01 - over here into leak code and submit it
16:04 - and see what happens okay here we go
16:07 - alright so we see that our program is
16:09 - successful awesome right well yes but
16:12 - let's look at some of these facts here
16:14 - so our run time was a 433 milliseconds
16:18 - which says it's faster than
16:21 - 5.94 of all Java submissions for this
16:25 - problem that's not great right that
16:28 - means that 94 of all Java submissions
16:32 - for this problem were faster we're more
16:34 - efficient than our solution from the
16:36 - last leak code video I heard that a lot
16:38 - of people struggled with techniques for
16:41 - coming up with a faster more efficient
16:44 - solution to these sorts of problems now
16:46 - what should I consider what kind of
16:47 - things should I know how should I even
16:49 - start thinking about it so first let's
16:51 - talk about why our current solution is
16:54 - probably so slow so what we're doing in
16:56 - our solution is We're looping through
16:57 - each character in the string and then
17:00 - within that Loop We're looping through
17:02 - each subsequent character in the string
17:05 - so to do that that meant that in our
17:07 - algorithm we had to use a nested for
17:10 - Loop to do that so that means that the
17:12 - time complexity the Big O complexity of
17:15 - our algorithm is going to be Big O of N
17:18 - squared usually when you have in your
17:20 - algorithm a nested for Loop that Loops
17:23 - through your data set in both of those
17:25 - Loops usually that means that you have a
17:28 - quadratic time complexity a big O of N
17:30 - squared so literally like the bigger
17:32 - that this string s is that gets put into
17:35 - our program so as that s gets larger and
17:38 - larger with just a little bit of
17:40 - increase to the size of our input our
17:43 - program will take dramatically longer to
17:45 - run so what we want to do to try and
17:47 - make this run faster is to of course
17:50 - just lower the time complexity of our
17:53 - solution now that could mean a couple of
17:55 - things there could be various ways to do
17:57 - that but the main thing in this
17:59 - situation what we want to do is get rid
18:02 - of this inner for Loop one way or
18:05 - another if at all possible so if we can
18:07 - accomplish our task just by looping
18:10 - through our string one time then that's
18:13 - what we want to do but then of course we
18:15 - have to think well how can we do that
18:17 - there are a few things that you can keep
18:19 - in mind when you're trying to come up
18:20 - with that sort of a solution a big part
18:22 - of what you want to keep in mind is just
18:24 - the different types of data structures
18:26 - that you have available to you so that
18:29 - could be things like lists cues sets
18:32 - Maps trees and and knowing how each of
18:36 - them work what they're all useful for
18:38 - and the properties of each of those
18:40 - helps you to know what could be helpful
18:43 - to use in various situations but
18:46 - honestly a lot of it is just doing a
18:49 - whole lot of these challenges coming up
18:50 - with your own Solutions and when you
18:52 - struggle look up what other people's
18:55 - Solutions are and what they came up with
18:57 - see which ones are faster and try and
18:59 - understand why but for this specific
19:02 - problem what do we need to do in order
19:05 - to be able to get the solution with one
19:09 - pass through our string well we need to
19:11 - know the whole substring that we're
19:13 - looking at at any given moment but we
19:16 - also need some way to determine at each
19:19 - character in our Loop whether that
19:21 - character already exists in our
19:24 - substring but we want to do that without
19:26 - looping through all of the other
19:29 - characters in our substring because then
19:31 - we'll be right back in the situation
19:32 - where we have that inner loop now one
19:35 - way I can think to do that is with a
19:37 - hash map and we actually did use a hash
19:40 - map in kind of a similar situation in
19:43 - the last leak code video in this
19:45 - situation we can use a hash map to
19:47 - remember the index that we last found
19:50 - each character that we run into in our
19:52 - string so it'll be a map where the keys
19:55 - are the characters that we find in our
19:58 - string and the value associated with
20:00 - each of those keys with each of those
20:02 - characters is going to be an integer
20:04 - that represents the last position that
20:07 - we encountered that character here's
20:10 - what I think we can do let's walk
20:11 - through an example so in this case we'll
20:13 - actually use two pointers don't worry
20:15 - we're not going to use two for Loops but
20:18 - we are going to use two pointers a left
20:20 - pointer and a right pointer and we're
20:22 - going to start with both of those
20:24 - pointers pointing to the first character
20:26 - in our string so right now our substring
20:28 - is just the Single Character a we look
20:31 - at that character and we say okay does
20:33 - that character exist in our map yet and
20:37 - of course our map is empty we haven't
20:38 - done anything with it yet so no it
20:40 - doesn't so that tells us that there's no
20:42 - repeats in our current substring so what
20:44 - we can do is we check the length of that
20:46 - substring which happens to be just one
20:48 - there's just one character and then we
20:50 - go ahead and set our Max to one but then
20:53 - before we proceed we add that character
20:56 - we add that a to our map so what we're
20:59 - saying in our map is the last time I saw
21:02 - the letter A it was at position zero so
21:06 - a is the a key in our map and 0 is the
21:09 - value so what this means is later if we
21:12 - encounter the letter A again we can just
21:15 - look it up in our map and say oh the
21:17 - last time that an a appeared was at
21:20 - position zero and then we don't have to
21:21 - Loop through the entire string to find
21:23 - that out we can just do a constant time
21:27 - lookup in our map so that map is going
21:30 - to be the key here the map is going to
21:31 - be how we're going to essentially get
21:34 - rid of our inner for Loop and improve
21:36 - the time complexity of our algorithm so
21:39 - after we add the a to our map we then go
21:42 - to the next iteration of our Loop but we
21:45 - don't move the left pointer we only move
21:47 - the right pointer so that increments to
21:51 - the next character in our string so what
21:53 - we do first is we look up B in our map
21:55 - does it exist in our map no it doesn't
21:57 - so that's cool that means we don't have
21:59 - any repeated characters so we look at
22:01 - the length of our current substring
22:03 - which is 2 so we can update our maximum
22:06 - substring length to B2 and then we want
22:08 - to do the same thing we did before and
22:09 - we want to add B to our map now so we'll
22:12 - say okay the last time that we
22:13 - encountered the letter B it was at index
22:16 - one and then we moved to the next
22:18 - iteration of our Loop and the same thing
22:20 - goes for C is C in our map no it's not
22:23 - so we update our maximum to 3 because
22:26 - that's the current length of our
22:27 - substring and we add that to our map as
22:29 - well the last time we saw C was at index
22:32 - two and then we move on to the next
22:33 - iteration of our Loop and we look up a
22:36 - in our map does a already exist in our
22:38 - map yes it does so that means yes we've
22:42 - seen it before but another thing that we
22:43 - do want to check is did we see it before
22:47 - inside the current substring that we're
22:49 - looking at and we can know that pretty
22:51 - easily just by checking the index where
22:54 - we've seen it before so in our map we
22:56 - look up a and we say oh that a was last
22:58 - encountered at index 0. and we can see
23:02 - that judging by our left and right
23:04 - pointers our left pointer is at position
23:07 - 0 and our right pointer is at position
23:09 - three and that means this a at index 0
23:13 - is within our current substring so
23:17 - because of that we know that we
23:18 - definitely have a repeating character
23:21 - inside our current substring so we have
23:24 - to fix that before we move on we have to
23:26 - set our substring to be something that
23:29 - doesn't contain a repeating character
23:31 - and we actually fix that by moving our
23:34 - left pointer so this is the situation
23:36 - where we do move our left pointer so
23:39 - we're looking at an a currently with our
23:41 - right pointer and we can see okay the
23:42 - last time we saw an a was at index 0. so
23:45 - in order for our current substring to no
23:48 - longer contain that repeating character
23:50 - we're going to move our left pointer to
23:53 - be one past where we last saw that
23:57 - letter so we'll just do this so now
24:00 - we've shifted that substring that we're
24:02 - looking at to where we now know that it
24:05 - no longer has that repeating character
24:07 - now before we move on we still want to
24:10 - update our map because now the last time
24:13 - that we encountered the character a was
24:16 - not at index 0 and now we last
24:18 - encountered it at index three now as
24:21 - before we move on to the next iteration
24:23 - of our Loop which means moving the right
24:26 - pointer one character over so now we're
24:28 - looking at the letter b and we look that
24:30 - up in our map to see when we last
24:32 - encountered it and we last encountered
24:34 - it at the index one and one is within
24:37 - our current substring also so that means
24:40 - okay our current substring has repeating
24:42 - characters and so what we want to do is
24:44 - move again our left pointer to one past
24:48 - where we last found that character so
24:51 - our left pointer will move over here and
24:54 - then again same as before we still have
24:55 - to update our map to show that the last
24:57 - time we encountered B was at index four
25:00 - now in the next iteration of our loop
25:02 - we're looking at the letter c c does
25:05 - already exist in our map and it's in
25:06 - index of 2 is within our current
25:08 - substring so we want to move our left
25:11 - pointer to one past that to make sure
25:13 - there's not a duplicate and update our
25:15 - map to show that the last time we
25:17 - encountered a c was at index 5. and then
25:20 - we'll iterate through our loop again to
25:22 - uh for our right pointer to point to the
25:24 - letter D does d exist anywhere in our
25:26 - map no it does not so we know that our
25:29 - the current substring that's contained
25:30 - within our left and right pointers does
25:32 - not have any repeating characters and it
25:34 - has a length of four which is bigger
25:36 - than our current Max so we can update
25:38 - our Max to be four and it will go ahead
25:40 - and add that D to its map also it'll say
25:43 - okay the last time we encountered a d
25:45 - was at index six but at that point the
25:48 - right pointer has reached the end of our
25:51 - string and so our Loop finishes and our
25:53 - program finishes and we get the solution
25:55 - that the maximum was for one thing to
25:58 - notice about this particular solution is
26:00 - that it as it's going through the string
26:02 - there's always a particular section a
26:04 - particular window that we care about at
26:07 - any given time and it kind of slides
26:10 - right and grows and shrinks as it
26:12 - processes the string and there's
26:14 - actually a name for that kind of
26:15 - algorithm called a sliding window
26:17 - algorithm that's why if you're looking
26:19 - up solutions for this problem you'll see
26:21 - a lot of things about a sliding window
26:23 - algorithm and also notice that even
26:25 - though we do have two pointers we only
26:27 - have one Loop through the string and
26:30 - that makes this algorithm a linear time
26:33 - algorithm or a big O of N and also since
26:36 - we'll be using a hash map to do the
26:39 - lookups for the last time we encountered
26:41 - each character those lookups will
26:43 - actually be in constant time so they
26:45 - won't affect the linear time complexity
26:48 - of our algorithm so now let's go ahead
26:51 - and implement this sliding window
26:53 - hashmap algorithm and see how much
26:56 - faster it is all right so we're going to
26:58 - get rid of a lot of this but we are
27:00 - going to keep our max length variable
27:02 - declaration and our outer loop we still
27:05 - need that but we are are going to change
27:07 - a couple of things about this Loop to
27:10 - make our code a little bit easier to
27:11 - read with how our algorithm will now
27:13 - work so instead of just calling this
27:15 - variable I let's call it right because
27:19 - it's going to represent the right
27:22 - pointer in our algorithm so we'll change
27:25 - I to right in each of those places and
27:29 - also if we want we can go ahead and
27:31 - declare our left pointer here also and
27:34 - have it start at index 0. but remember
27:37 - we'll only be changing our left pointer
27:39 - if we find repeats while we're
27:41 - processing substring we only want to
27:43 - increment the right pointer in every
27:46 - iteration of our Loop now remember as a
27:49 - part of the solution we need to have a
27:51 - map that will hold the last position
27:53 - that we saw each character so let's
27:55 - create a map and remember this is going
27:57 - to be a map where the keys are
28:00 - characters and the values are integers
28:04 - we'll call it I don't know visiting did
28:07 - characters that's not my favorite name
28:09 - for a variable that I've ever come up
28:11 - with but let me know if you have a
28:12 - better one in the comments we're going
28:14 - to initialize that to a new hash map so
28:17 - now inside our for Loop where We're
28:19 - looping that right pointer through the
28:22 - string we want to check whether the
28:25 - character at that right pointer is
28:27 - already in our map so we can do that
28:29 - with if visited characters dot contains
28:32 - key and then passing in the character
28:35 - that's found at our right pointer so
28:37 - that's just s dot Char at right one
28:41 - thing to remember though is that even if
28:43 - we find the character that we're looking
28:45 - at is already in our map it doesn't
28:48 - necessarily mean that that character is
28:49 - within the current substring that we're
28:52 - looking at so once we find it in the map
28:54 - we still have to check whether the index
28:57 - that we found it in the map is actually
29:00 - a part of our current substring but
29:02 - luckily that's not too complicated to
29:04 - add so we just want to add another
29:06 - condition to to our if so yes we've
29:08 - already found that it's in the map but
29:10 - we also want to get the index where we
29:13 - last encountered that character so we'll
29:16 - get s dot Char at right and we can know
29:20 - if it's a part of our current substring
29:23 - if the last place that we found it is
29:25 - greater than or equal to our left
29:29 - pointer and if this whole condition is
29:31 - met if the result of this whole thing is
29:34 - true that means yes we saw this
29:36 - character before and it's within our
29:39 - current substring so our current
29:41 - substring has a repeated character and
29:43 - remember if that's the case then we need
29:45 - to move our left pointer to be one past
29:48 - where that repeated character is we can
29:50 - do that just by setting our left pointer
29:52 - to be the position where we last
29:55 - encountered that character so visited
29:58 - characters dot get s dot Char at right
30:02 - and we want it to be one more than that
30:04 - so we get just past that repeated
30:07 - character so we just add one now one
30:09 - thing I'm noticing as I'm writing this
30:11 - algorithm is that I'm using this s dot
30:14 - Char at right three times and it's kind
30:17 - of starting to look a little verbose so
30:19 - I think what I might do is create a
30:21 - variable for this so I'll go ahead and
30:24 - create a Char variable we'll just call
30:26 - it current character and we'll set it
30:28 - equal to that s dot Char at right and
30:32 - then we'll go ahead and replace
30:33 - everywhere we're making that call
30:35 - with that variable there we go so now
30:40 - it's a little bit easier to read and
30:41 - also might perform just a little bit
30:43 - better because it doesn't have to do
30:45 - this lookup three different times so at
30:47 - this point in the algorithm we know that
30:49 - either the substring that we're looking
30:51 - at either didn't contain any repeat
30:53 - characters so it didn't have to adjust
30:54 - the left pointer or if it did contain
30:57 - repeat characters it did adjust the left
30:59 - pointer so that it no longer has any
31:01 - repeated characters so now what we can
31:03 - do is update our max length and we can
31:06 - do that in the good old fancy way again
31:08 - by using a math dot Max and we'll take
31:12 - the maximum of either the current max
31:14 - length or the length of our current
31:16 - substring and we can get the length of
31:19 - the current substring that we're looking
31:20 - at by using our left and right pointers
31:24 - so what we can do is take right minus
31:27 - left and then add 1 to get the current
31:31 - length of our substring adding one might
31:33 - seem a little bit weird but it makes
31:35 - sense if you think about it because
31:36 - let's say right and left were both
31:38 - pointing to the same index they were
31:40 - both pointing to an index of zero the
31:42 - very first character well that of course
31:44 - has a length of one but if you took 0
31:46 - minus zero you'd have zero and that's
31:49 - not correct so you have to add one to
31:51 - right minus left in order to get the
31:54 - correct length of the substring that
31:55 - you're looking at now the only other
31:57 - thing that we have to do is we don't
31:59 - currently have anything that's actually
32:01 - putting the characters that we encounter
32:04 - onto the map we still have to do that so
32:06 - after all this processing we want to put
32:08 - on the map okay here's the last place
32:10 - that I saw this current character so
32:13 - we'll just call visited characters dot
32:15 - put to put a thing on the map and the
32:17 - key that we're putting on the map is
32:19 - going to be the current character and
32:21 - then the value is going to be the
32:22 - position where we're encountering that
32:24 - current character and that's just the
32:27 - right pointer okay so after our for Loop
32:30 - exits we'll just return the max length
32:32 - that doesn't change from our last
32:33 - algorithm I think that should be it so
32:35 - let's go ahead and copy this over paste
32:38 - it into lead code and we'll see if this
32:41 - is any faster so here we go
32:44 - okay so uh we have 12 milliseconds so we
32:48 - went down from what was it 400 something
32:50 - milliseconds down to 12. that is a
32:53 - dramatic difference it's a huge
32:55 - difference and that's probably largely
32:57 - because the complexity of our algorithm
32:59 - went from quadratic to linear and we
33:02 - also use quite a bit less memory maybe
33:04 - less than half of the memory that we
33:06 - were using before however you might
33:08 - notice that it looks like there's still
33:10 - some room for improvement of our
33:12 - algorithm of course we're way faster
33:14 - than what we were before but we're only
33:16 - faster than about two-thirds of other
33:18 - entries there are still plenty of
33:19 - entries that are faster than this one so
33:22 - that was kind of bothering me that you
33:23 - know a third of solutions were faster
33:25 - than this one so I was looking up other
33:26 - potential Solutions and one that I found
33:29 - that did end up being faster than this
33:31 - really caught my eye and I wanted to
33:33 - share it now remember back in our code
33:35 - we're using uh this map of visited
33:39 - characters to look up when we last
33:41 - encountered a certain character now this
33:43 - other solution that ends up being faster
33:45 - is structured in a very similar way
33:47 - except it doesn't use a map at all and
33:50 - so of course without that map all this
33:51 - other code that uses that map doesn't
33:54 - really apply anymore but then of course
33:55 - you might ask okay well how are they
33:57 - doing that look up to see when we last
34:01 - encountered the the current character
34:03 - that we're looking at and actually it's
34:04 - done in a very simple way let's just
34:07 - call it this is an awful name but
34:09 - location of first appearance in
34:13 - substring so all they're doing with this
34:15 - is looking for the index of that current
34:18 - character that the right pointer is
34:20 - looking at so s dot Char at right but
34:24 - they're not searching through the entire
34:26 - string to see where that character first
34:28 - appeared they have it start at the left
34:31 - pointer and that makes sense right you
34:33 - only need to know if that character
34:35 - already existed just in your current
34:39 - substring not in the entire string and I
34:41 - guess a better name for this might be
34:42 - just index of first appearance in
34:45 - substring okay so now we know where this
34:48 - particular character that we're now
34:49 - looking at first appears in the
34:52 - substring that we're looking at and so
34:53 - all we have to do is say Okay if that
34:56 - index where that character is is
34:59 - different from the right pointer it
35:03 - exists somewhere already in the
35:04 - substring because of course it exists
35:06 - where the right pointer is pointing at
35:08 - right now but if it appears any other
35:11 - time then that means we now have a
35:13 - repeated character and so if we do have
35:15 - a repeated character we essentially do
35:17 - what we did in our other algorithm which
35:19 - is just move the left pointer to be one
35:23 - past where that repeat character was
35:26 - found so we'll set left to be the index
35:28 - of the first appearance and the
35:30 - substring plus one and other than that
35:33 - the algorithm is all the same we still
35:35 - set the max length the same way as we
35:37 - did before and return it at the end of
35:39 - the algorithm and that's it but let's go
35:42 - ahead and copy this and put put it into
35:45 - leap code and see what our performance
35:48 - is like here we go
35:50 - five milliseconds and that's better than
35:51 - almost 95 percent of all Java
35:55 - submissions so it's just about twice as
35:58 - fast as the other solution and of course
36:00 - if you submit this a few times you do
36:03 - get a little a little bit of variability
36:05 - in the amount of time that it takes so
36:06 - at that time it took four milliseconds
36:08 - better than
36:10 - 97.75 percent of all Java submissions
36:13 - um so that's really interesting it was
36:15 - it was faster than our map based
36:18 - solution so that really got me wondering
36:20 - why that might be and I'm interested
36:23 - um what you all think in the comments of
36:26 - why this particular solution is faster
36:29 - than the map based one the reason I
36:31 - think that's interesting is because our
36:33 - map should give us a constant time look
36:36 - up to see where that character last
36:38 - appeared in our substring but the way
36:40 - that they have it doing the lookup here
36:43 - in this solution is it has to use an
36:47 - index of and I believe index of just has
36:50 - to Loop through each individual
36:53 - character in the particular substring
36:55 - that it's told to look at to see if that
36:56 - character exists anywhere in there so I
36:58 - would think at a glance that that should
37:01 - give you a worse time complexity than
37:04 - the map solution but it performs much
37:07 - faster two three times faster than the
37:10 - map solution the only thing that I could
37:12 - think of is that even though the time
37:14 - complexity might not be as good
37:16 - technically as the map solution perhaps
37:19 - given the particular strings that leap
37:21 - code uses to test the algorithms it
37:24 - could be that just index of performs way
37:27 - better than Maps do for just for that
37:30 - particular input even though the time
37:31 - complexity isn't as good there are
37:33 - definitely situations and some
37:35 - algorithms where certain inputs could
37:38 - perform better on algorithms that
37:41 - technically have worse time complexity
37:43 - so this could definitely be one of those
37:45 - situations so even though I didn't come
37:47 - up with this particular solution I
37:49 - wanted to share it because I thought it
37:51 - was so interesting so as always let me
37:54 - know what you think if you like this
37:55 - video learn something want to see more
37:57 - things like this let me know and give
37:58 - the video a thumbs up and of course if
38:00 - you're interested go check out my full
38:02 - Java course which you can find in the
38:04 - link down in the description it's a
38:05 - great way that you can support the
38:07 - channel and get a ton of value and Java
38:10 - knowledge in return so thank you all so
38:12 - much as always for watching and I'll see
38:14 - you next time

Cleaned transcript:

today we're going to be solving another lead code coding exercise this is going to be an interesting one to find a fast solution for and I'm also going to talk a little bit about the thought process behind coming up with the solutions for these sorts of problems but first thanks to mailgun for sponsoring this video mailgun is how modern companies work with email mailgun is easy to use has amazing 24 7 customer support and simple but powerful apis that smart developers can use to reach their customers at scale so their organizations can grow faster you can use mailguns API to send an email with just a few lines of code with whatever language you're using of course including Java it really couldn't be easier today mailgun is used by over a hundred thousand companies and top brands around the world to provide personal connected experiences through email and drive smart results you can send and track transactional and marketing messages remove invalid emails from your list or prevent fake signups in the first place easily mailgun also has an awesome send time optimization feature that automatically finds the perfect time to send to each and every individual on your list at the exact time that they're most likely to engage they also have a team of email experts ready to work with you to improve your email deliverability and also Drive higher conversion rates with its intuitive email Marketing Solutions and Powerful API mailgun Works through the whole email lifecycle from predevelopment all the way to the inbox for more than 240 billion emails a year for companies like Wikipedia DHL toast Lyft and Microsoft helping them solve complex communication problems and build connected experiences through email so thanks again to mailgun for sponsoring this video try mailgun today by using my link which you can find down in the description mailgun.com John now let's get to it so this is lead code problem number three and it's a medium difficulty problem it's called longest substring without repeating characters so basically we're going to be given some string we'll call it s and our task will be to to find the length of the longest substring within that string that doesn't repeat any characters so they've got a few examples here so if our input string is a b c a b c b b well the longest substring within this string that doesn't repeat any characters is just ABC so if we were looking through this string we would go okay A B C all right we haven't repeated any characters yet and so far we've got a substring length of three but if we were to try and add the next character well that's an A and we already have an A so that's not a valid solution so the longest substring without repeating characters in this example is ABC and that has a length of 3 and so our output would be three one thing to note about this example is that technically the solution could have been BCA also or c a b those are also substrings that don't repeat any characters but they also just have a max length of three anyway so it doesn't change what our output is still the longest substring that doesn't repeat any characters in this string is just three so if we scroll down to the bottom here we can see that we have a couple of constraints on the string input that we're going to receive so one thing is that it'll only consist of English letters digits symbols and spaces that just means there's nothing really crazy for us to deal with as far as the characters go and it also says that the length of our string is going to be greater than or equal to zero so we won't have a negative number of characters in our string and the length of the string will be less than or equal to 5 times 10 to the fourth okay Elite code you're trying to be real fancy there with the scientific notation this is just fifty thousand ten to the fourth is ten thousand times five is fifty thousand and that really shouldn't be big enough to cause any sort of problem with any kind of solution that we might come up with as far as memory goes or anything like that so let's start thinking about the solution for this problem so with a lot of these leak code problems there's often like a Brute Force solution that most people come up with first and then often there's a more clever answer that's a little bit more tricky to come up with but leads to a much more efficient and fast solution now the same thing is the case here so to start let's look at an example string that we might be given and talk about what our Brute Force solution to this problem will look like basically we're just going to Loop through every single possible substring of this string until each of those substrings repeats a character and then keep a running maximum of the largest substring that we find that doesn't repeat any characters that might sound a little bit confusing so let's just walk through a quick example of what it's going to look like so what we'll do is start by looking at all the substrings of this string that start with the first letter A of course just the letter A by itself has no repeating characters so as of right now the maximum substring that we found that doesn't repeat any characters is of length one and then we say okay we haven't run into any repeating characters yet let's add the next character to our substring and the next character is B so now our substring that we're looking at is a b and so we say okay we're adding B does B already exist anywhere in our substring no it doesn't so there's still no repeating characters so now the maximum substring that we found that doesn't repeat any characters is of length two next we go ahead and add the C to our substring the C already exists anywhere in our substring no so we still don't have any repeating characters in this substring so our new maximum is three so next we look at the next character which is a does a re exist in our substring yes it does so now this substring contains repeating characters and so it doesn't count as a valid substring that we're looking for so now that we've run into a substring that has a repeating character we know that the largest substring that starts with this first a that doesn't repeat any characters is just a b c you know that has a length of 3. so next we have to look at all the substrings that start with the second letter of our string b b by itself doesn't contain any repeating characters but it's only of length one which is not greater than three so our maximum is still three and then we move this over to include c b c also doesn't contain any repeating characters but it only has a length of two so it's not bigger than the maximum we already have so we move over and look at BCA it also doesn't have any repeating characters but just has a length of three so there's no need to change our maximum and then when we move this over to include B now we have repeating characters and this isn't a valid substring anymore so then we move the beginning of the substring that we're looking at over to the C and do the same thing all over again so that would eventually get to c a b with no repeating characters which is still just a length of three and then when we add on the next C it now has a repeating character but then we will move on to starting with this a and this can proceed all the way to the end of our string without repeating any characters a b c d has a length of four and doesn't repeat any characters so when our program sees that it will update this maximum to four and then it'll Loop through all the rest of these characters in exactly the same way but it won't find any nonrepeating substring that's any longer than four which is this a b c d and so we'll find that the solution is four so next let's go ahead and copy this over to IntelliJ so we can do our coding there and let's get to implementing that Brute Force algorithm so first a good thing to have is just going to be an INT variable a max length that we're going to use to keep the maximum length of the nonrepeating substring that we've identified so we'll eventually return that as our solution and we'll initialize it to zero next we're going to want a loop that will look through each individual character of our input string and use each character as the start of the substring that we're looking at and we'll just keep that simple and use a for Loop this will be a pretty simple for Loop so for INT I equals zero we're going to keep looping while I is less than s dot length and each iteration through the loop we're going to increment I but now nested within that as We're looping through each character in our string being the start of each substring that we want to look at we then have to have an inner loop that adds on each subsequent character to our substring and you know keeps doing that and adding characters until we find one that repeats so in order to do that we're actually going to need a nested for Loop within this one or int J we'll call it and we'll actually start it not at zero but we'll initialize it to I because we don't necessarily want to start our inner loop at the very beginning of the entire string we want to start it at the beginning of the substring that we're looking at and that will always start with the ith character we will still Loop while J is less than s dot length we'll go to the end of the string with our inner loop as well and in the Inner Loop we will increment J each time but actually just within our outer loop we want to create something that we can use to build our substring something that for each iteration of our inner loop we can add to in order to build the substring that starts with a certain character now there's a bunch of potential ways you could do this but one decent way is with a string Builder now string Builder if you've never used it before is kind of what the name of it says it's an object that you can use to build strings and often we'll use it in situations like this where we want to add to a string in iterations through a loop so here we'll create a string Builder and call it let's say current substring we'll just initialize it to a new string Builder so now what we're going to do is in each iteration of this inner for loop we're going to be adding each subsequent character to the substring that we're building and along the way as we're building the substrings as long as the current substring we are looking at doesn't have any repeated characters we're going to be seeing if it exceeds our current max length and if it does we will update the max length to be the current large substring that we're looking at and we're going to keep looping through adding the next character to the substring that we're looking at until we find a repeated character and then once we find a repeated character we're going to break out of this inner for Loop and then start looking at every substring that starts with the next character in the string so for example as the outer loop is looking at this first character a our inner loop is going to be looping through each subsequent character after that a adding it to the substring that it's building that string Builder that we created it and it's going to do that until it adds a character that it identifies as being a repeat and so when we do find a character that repeats like that the outer loop is going to increment by one and we are going to start looking at all substrings that start with the next letter of our string and then our inner for Loop is going to do the same thing it's going to use that string Builder to add on each subsequent character in our string onto the string Builder until it identifies a repeat character so here's how we're going to implement that functionality into our inner for Loop first we're going to check whether the next character that we're about to add on our substring already appears in our current substring and if it does well we have a repeated character and we want to break out of our inner loop to do that we can say if so what we'd like to do is take our current substring and see if it already contains the next character that we're about to add to it but unfortunately string Builder doesn't actually have a contains method that just returns a simple Boolean so what we have to do is instead we have to call the index of method on it so the next character that we would add to the substring is the character that's at the jth position in our original string and so to get that we can just call s dot Char at and then pass in the index we're looking for J now again unfortunately this index of method can't take a character you have to pass in a string but luckily it's easy to convert a string to a character all we have to do is call string dot value of and then pass in our character like this so now what this index of call will return is it will return the position of this next character that we're about to add in the current substring if it already exists there and if it doesn't already exist there it it'll return a negative one when it returns a negative one that's its way of telling us I didn't find that character in this string Builder what that means is if the index of this character is anything except for negative one that means that that character already exists in our substring and we have a repeated character and as we said once we find a repeated character we want to break out of our inner for Loop so that is accounting for the situation where you know we're adding more things to our substring making sure there are no repeated characters but then once we do that and we're about to add a character that would be a repeat so in this situation when we're about to add an A but we already have an A that would break out of our inner for Loop and then it would start looking for substrings that start with the next character in the original string however if it gets past this point then we know that the next character that it's about to add is not already in the current substring that we're looking at so in that case great let's go ahead and add it to the current substring that we're building and to do that we just call current substring dot append and we want to append that same character at the jth position of our string so all this append method does is take the character that we're passing in and add it onto the end of our current substring so now we know that the current substring that we're looking at doesn't have any repeated characters so what we want to do is if that current substrings length is greater than the current maximum length nonrepeated substring that we found so far then we want to set our max length to be the length of our current substring current substring dot length kind of a cooler way to do this though instead of having to okay let's check to see if the length is greater than the max length and if it is then we'll set the max length to be that one that works just fine but if you want to be really cool about it instead you can do something like Max length equals math dot Max and then pass in as the two parameters the current max length and also the length of the current substring and then you can get rid of this because this line of code is doing the exact same thing this math.max method will just return whichever one of these two parameters is larger so what that means is if the maximum length is already larger than the current substrings length it'll just get set to that max length again but if our current substrings length is larger then it will set max length to be that instead so it's just a little bit more of a concise way to do the same thing so then after all of that after it does all those Loops through all the possible substrings and maintaining that maximum length of the nonrepeated substring that it finds at the very end of this method we actually have to return that maximum length that we found I think that should do it let's go ahead and copy this solution and paste it back over here into leak code and submit it and see what happens okay here we go alright so we see that our program is successful awesome right well yes but let's look at some of these facts here so our run time was a 433 milliseconds which says it's faster than 5.94 of all Java submissions for this problem that's not great right that means that 94 of all Java submissions for this problem were faster we're more efficient than our solution from the last leak code video I heard that a lot of people struggled with techniques for coming up with a faster more efficient solution to these sorts of problems now what should I consider what kind of things should I know how should I even start thinking about it so first let's talk about why our current solution is probably so slow so what we're doing in our solution is We're looping through each character in the string and then within that Loop We're looping through each subsequent character in the string so to do that that meant that in our algorithm we had to use a nested for Loop to do that so that means that the time complexity the Big O complexity of our algorithm is going to be Big O of N squared usually when you have in your algorithm a nested for Loop that Loops through your data set in both of those Loops usually that means that you have a quadratic time complexity a big O of N squared so literally like the bigger that this string s is that gets put into our program so as that s gets larger and larger with just a little bit of increase to the size of our input our program will take dramatically longer to run so what we want to do to try and make this run faster is to of course just lower the time complexity of our solution now that could mean a couple of things there could be various ways to do that but the main thing in this situation what we want to do is get rid of this inner for Loop one way or another if at all possible so if we can accomplish our task just by looping through our string one time then that's what we want to do but then of course we have to think well how can we do that there are a few things that you can keep in mind when you're trying to come up with that sort of a solution a big part of what you want to keep in mind is just the different types of data structures that you have available to you so that could be things like lists cues sets Maps trees and and knowing how each of them work what they're all useful for and the properties of each of those helps you to know what could be helpful to use in various situations but honestly a lot of it is just doing a whole lot of these challenges coming up with your own Solutions and when you struggle look up what other people's Solutions are and what they came up with see which ones are faster and try and understand why but for this specific problem what do we need to do in order to be able to get the solution with one pass through our string well we need to know the whole substring that we're looking at at any given moment but we also need some way to determine at each character in our Loop whether that character already exists in our substring but we want to do that without looping through all of the other characters in our substring because then we'll be right back in the situation where we have that inner loop now one way I can think to do that is with a hash map and we actually did use a hash map in kind of a similar situation in the last leak code video in this situation we can use a hash map to remember the index that we last found each character that we run into in our string so it'll be a map where the keys are the characters that we find in our string and the value associated with each of those keys with each of those characters is going to be an integer that represents the last position that we encountered that character here's what I think we can do let's walk through an example so in this case we'll actually use two pointers don't worry we're not going to use two for Loops but we are going to use two pointers a left pointer and a right pointer and we're going to start with both of those pointers pointing to the first character in our string so right now our substring is just the Single Character a we look at that character and we say okay does that character exist in our map yet and of course our map is empty we haven't done anything with it yet so no it doesn't so that tells us that there's no repeats in our current substring so what we can do is we check the length of that substring which happens to be just one there's just one character and then we go ahead and set our Max to one but then before we proceed we add that character we add that a to our map so what we're saying in our map is the last time I saw the letter A it was at position zero so a is the a key in our map and 0 is the value so what this means is later if we encounter the letter A again we can just look it up in our map and say oh the last time that an a appeared was at position zero and then we don't have to Loop through the entire string to find that out we can just do a constant time lookup in our map so that map is going to be the key here the map is going to be how we're going to essentially get rid of our inner for Loop and improve the time complexity of our algorithm so after we add the a to our map we then go to the next iteration of our Loop but we don't move the left pointer we only move the right pointer so that increments to the next character in our string so what we do first is we look up B in our map does it exist in our map no it doesn't so that's cool that means we don't have any repeated characters so we look at the length of our current substring which is 2 so we can update our maximum substring length to B2 and then we want to do the same thing we did before and we want to add B to our map now so we'll say okay the last time that we encountered the letter B it was at index one and then we moved to the next iteration of our Loop and the same thing goes for C is C in our map no it's not so we update our maximum to 3 because that's the current length of our substring and we add that to our map as well the last time we saw C was at index two and then we move on to the next iteration of our Loop and we look up a in our map does a already exist in our map yes it does so that means yes we've seen it before but another thing that we do want to check is did we see it before inside the current substring that we're looking at and we can know that pretty easily just by checking the index where we've seen it before so in our map we look up a and we say oh that a was last encountered at index 0. and we can see that judging by our left and right pointers our left pointer is at position 0 and our right pointer is at position three and that means this a at index 0 is within our current substring so because of that we know that we definitely have a repeating character inside our current substring so we have to fix that before we move on we have to set our substring to be something that doesn't contain a repeating character and we actually fix that by moving our left pointer so this is the situation where we do move our left pointer so we're looking at an a currently with our right pointer and we can see okay the last time we saw an a was at index 0. so in order for our current substring to no longer contain that repeating character we're going to move our left pointer to be one past where we last saw that letter so we'll just do this so now we've shifted that substring that we're looking at to where we now know that it no longer has that repeating character now before we move on we still want to update our map because now the last time that we encountered the character a was not at index 0 and now we last encountered it at index three now as before we move on to the next iteration of our Loop which means moving the right pointer one character over so now we're looking at the letter b and we look that up in our map to see when we last encountered it and we last encountered it at the index one and one is within our current substring also so that means okay our current substring has repeating characters and so what we want to do is move again our left pointer to one past where we last found that character so our left pointer will move over here and then again same as before we still have to update our map to show that the last time we encountered B was at index four now in the next iteration of our loop we're looking at the letter c c does already exist in our map and it's in index of 2 is within our current substring so we want to move our left pointer to one past that to make sure there's not a duplicate and update our map to show that the last time we encountered a c was at index 5. and then we'll iterate through our loop again to uh for our right pointer to point to the letter D does d exist anywhere in our map no it does not so we know that our the current substring that's contained within our left and right pointers does not have any repeating characters and it has a length of four which is bigger than our current Max so we can update our Max to be four and it will go ahead and add that D to its map also it'll say okay the last time we encountered a d was at index six but at that point the right pointer has reached the end of our string and so our Loop finishes and our program finishes and we get the solution that the maximum was for one thing to notice about this particular solution is that it as it's going through the string there's always a particular section a particular window that we care about at any given time and it kind of slides right and grows and shrinks as it processes the string and there's actually a name for that kind of algorithm called a sliding window algorithm that's why if you're looking up solutions for this problem you'll see a lot of things about a sliding window algorithm and also notice that even though we do have two pointers we only have one Loop through the string and that makes this algorithm a linear time algorithm or a big O of N and also since we'll be using a hash map to do the lookups for the last time we encountered each character those lookups will actually be in constant time so they won't affect the linear time complexity of our algorithm so now let's go ahead and implement this sliding window hashmap algorithm and see how much faster it is all right so we're going to get rid of a lot of this but we are going to keep our max length variable declaration and our outer loop we still need that but we are are going to change a couple of things about this Loop to make our code a little bit easier to read with how our algorithm will now work so instead of just calling this variable I let's call it right because it's going to represent the right pointer in our algorithm so we'll change I to right in each of those places and also if we want we can go ahead and declare our left pointer here also and have it start at index 0. but remember we'll only be changing our left pointer if we find repeats while we're processing substring we only want to increment the right pointer in every iteration of our Loop now remember as a part of the solution we need to have a map that will hold the last position that we saw each character so let's create a map and remember this is going to be a map where the keys are characters and the values are integers we'll call it I don't know visiting did characters that's not my favorite name for a variable that I've ever come up with but let me know if you have a better one in the comments we're going to initialize that to a new hash map so now inside our for Loop where We're looping that right pointer through the string we want to check whether the character at that right pointer is already in our map so we can do that with if visited characters dot contains key and then passing in the character that's found at our right pointer so that's just s dot Char at right one thing to remember though is that even if we find the character that we're looking at is already in our map it doesn't necessarily mean that that character is within the current substring that we're looking at so once we find it in the map we still have to check whether the index that we found it in the map is actually a part of our current substring but luckily that's not too complicated to add so we just want to add another condition to to our if so yes we've already found that it's in the map but we also want to get the index where we last encountered that character so we'll get s dot Char at right and we can know if it's a part of our current substring if the last place that we found it is greater than or equal to our left pointer and if this whole condition is met if the result of this whole thing is true that means yes we saw this character before and it's within our current substring so our current substring has a repeated character and remember if that's the case then we need to move our left pointer to be one past where that repeated character is we can do that just by setting our left pointer to be the position where we last encountered that character so visited characters dot get s dot Char at right and we want it to be one more than that so we get just past that repeated character so we just add one now one thing I'm noticing as I'm writing this algorithm is that I'm using this s dot Char at right three times and it's kind of starting to look a little verbose so I think what I might do is create a variable for this so I'll go ahead and create a Char variable we'll just call it current character and we'll set it equal to that s dot Char at right and then we'll go ahead and replace everywhere we're making that call with that variable there we go so now it's a little bit easier to read and also might perform just a little bit better because it doesn't have to do this lookup three different times so at this point in the algorithm we know that either the substring that we're looking at either didn't contain any repeat characters so it didn't have to adjust the left pointer or if it did contain repeat characters it did adjust the left pointer so that it no longer has any repeated characters so now what we can do is update our max length and we can do that in the good old fancy way again by using a math dot Max and we'll take the maximum of either the current max length or the length of our current substring and we can get the length of the current substring that we're looking at by using our left and right pointers so what we can do is take right minus left and then add 1 to get the current length of our substring adding one might seem a little bit weird but it makes sense if you think about it because let's say right and left were both pointing to the same index they were both pointing to an index of zero the very first character well that of course has a length of one but if you took 0 minus zero you'd have zero and that's not correct so you have to add one to right minus left in order to get the correct length of the substring that you're looking at now the only other thing that we have to do is we don't currently have anything that's actually putting the characters that we encounter onto the map we still have to do that so after all this processing we want to put on the map okay here's the last place that I saw this current character so we'll just call visited characters dot put to put a thing on the map and the key that we're putting on the map is going to be the current character and then the value is going to be the position where we're encountering that current character and that's just the right pointer okay so after our for Loop exits we'll just return the max length that doesn't change from our last algorithm I think that should be it so let's go ahead and copy this over paste it into lead code and we'll see if this is any faster so here we go okay so uh we have 12 milliseconds so we went down from what was it 400 something milliseconds down to 12. that is a dramatic difference it's a huge difference and that's probably largely because the complexity of our algorithm went from quadratic to linear and we also use quite a bit less memory maybe less than half of the memory that we were using before however you might notice that it looks like there's still some room for improvement of our algorithm of course we're way faster than what we were before but we're only faster than about twothirds of other entries there are still plenty of entries that are faster than this one so that was kind of bothering me that you know a third of solutions were faster than this one so I was looking up other potential Solutions and one that I found that did end up being faster than this really caught my eye and I wanted to share it now remember back in our code we're using uh this map of visited characters to look up when we last encountered a certain character now this other solution that ends up being faster is structured in a very similar way except it doesn't use a map at all and so of course without that map all this other code that uses that map doesn't really apply anymore but then of course you might ask okay well how are they doing that look up to see when we last encountered the the current character that we're looking at and actually it's done in a very simple way let's just call it this is an awful name but location of first appearance in substring so all they're doing with this is looking for the index of that current character that the right pointer is looking at so s dot Char at right but they're not searching through the entire string to see where that character first appeared they have it start at the left pointer and that makes sense right you only need to know if that character already existed just in your current substring not in the entire string and I guess a better name for this might be just index of first appearance in substring okay so now we know where this particular character that we're now looking at first appears in the substring that we're looking at and so all we have to do is say Okay if that index where that character is is different from the right pointer it exists somewhere already in the substring because of course it exists where the right pointer is pointing at right now but if it appears any other time then that means we now have a repeated character and so if we do have a repeated character we essentially do what we did in our other algorithm which is just move the left pointer to be one past where that repeat character was found so we'll set left to be the index of the first appearance and the substring plus one and other than that the algorithm is all the same we still set the max length the same way as we did before and return it at the end of the algorithm and that's it but let's go ahead and copy this and put put it into leap code and see what our performance is like here we go five milliseconds and that's better than almost 95 percent of all Java submissions so it's just about twice as fast as the other solution and of course if you submit this a few times you do get a little a little bit of variability in the amount of time that it takes so at that time it took four milliseconds better than 97.75 percent of all Java submissions um so that's really interesting it was it was faster than our map based solution so that really got me wondering why that might be and I'm interested um what you all think in the comments of why this particular solution is faster than the map based one the reason I think that's interesting is because our map should give us a constant time look up to see where that character last appeared in our substring but the way that they have it doing the lookup here in this solution is it has to use an index of and I believe index of just has to Loop through each individual character in the particular substring that it's told to look at to see if that character exists anywhere in there so I would think at a glance that that should give you a worse time complexity than the map solution but it performs much faster two three times faster than the map solution the only thing that I could think of is that even though the time complexity might not be as good technically as the map solution perhaps given the particular strings that leap code uses to test the algorithms it could be that just index of performs way better than Maps do for just for that particular input even though the time complexity isn't as good there are definitely situations and some algorithms where certain inputs could perform better on algorithms that technically have worse time complexity so this could definitely be one of those situations so even though I didn't come up with this particular solution I wanted to share it because I thought it was so interesting so as always let me know what you think if you like this video learn something want to see more things like this let me know and give the video a thumbs up and of course if you're interested go check out my full Java course which you can find in the link down in the description it's a great way that you can support the channel and get a ton of value and Java knowledge in return so thank you all so much as always for watching and I'll see you next time
