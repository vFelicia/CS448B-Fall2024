With timestamps:

00:00 - in this video we are going to code the
00:01 - merge sort sorting algorithm in java
00:04 - in my bubble sort video i got a comment
00:05 - that said can you do merge sort next
00:07 - ask and you shall receive now we know
00:09 - this sorting algorithm is going to be
00:11 - faster it has a complexity of big o
00:13 - of n log n but how much faster does it
00:15 - actually work out to with a real
00:16 - implementation
00:17 - with bubble sort we got up to sorting a
00:19 - million numbers but it still took about
00:21 - 37 minutes
00:22 - with merge sort of course we're going to
00:23 - see how much faster we can do a million
00:25 - integers but we're even going to take it
00:27 - a step further and go to 10 million
00:28 - 100 million even a billion if we can get
00:31 - there
00:32 - if this is your first time watching this
00:33 - channel my name is john and i do a new
00:34 - java tutorial video like this one every
00:36 - single week so be sure to leave a like
00:38 - and hit the subscribe button so you
00:39 - don't miss the new video every week
00:40 - and as always you can get the full
00:42 - source code of this program in the link
00:43 - down in the description so go and get it
00:45 - as with all the sorting algorithm videos
00:47 - so far i start with a little bit of a
00:49 - program set up
00:50 - first i create this array of ins called
00:52 - numbers here we're just starting with a
00:54 - length of 10 so we'll have 10 numbers to
00:56 - sort and then we loop through that array
00:57 - to fill it with
00:58 - random ins essentially between zero and
01:01 - a million so that gives us our unsorted
01:03 - array that we want to sort and then
01:04 - after that we print out the before state
01:06 - the
01:06 - unordered array and then we have the
01:08 - call to our
01:09 - merge sort method which is currently
01:11 - empty that is what we will be writing in
01:13 - this video
01:14 - and then after that merge sort method is
01:15 - called we should have a sorted list and
01:17 - so we just
01:18 - print that array again and we should see
01:20 - it in perfectly sorted order
01:22 - i know we want to just dive head first
01:23 - into the code but before we do it's a
01:25 - good idea
01:26 - to get a mental model of how merge sort
01:28 - works
01:29 - this is a diagram just from the merge
01:31 - sort wikipedia page that gives a pretty
01:33 - good picture of how it works you start
01:34 - out with your unordered array
01:36 - you divide that array into two halves
01:38 - and merge sort each half
01:40 - recursively and then once each half of
01:42 - your array is sorted so this half is in
01:45 - order and this half is in order
01:46 - then you go through a process of merging
01:48 - both of those halves of your array into
01:51 - one array again and that one array will
01:53 - be in order
01:54 - how that merge process actually works is
01:56 - key and we'll get into that more when we
01:57 - get to the code
01:58 - we start with this completely unordered
02:00 - array then we divide it
02:02 - in half into two arrays and then we tell
02:05 - each array
02:06 - to merge sort itself that's the
02:08 - recursive part of this algorithm so you
02:10 - can see here this first array
02:12 - is being split into two halves and then
02:14 - the same merge sort algorithm will be
02:17 - called for each of these halves
02:18 - well the first part of the algorithm is
02:20 - to again split
02:22 - into two halves and merge sort each half
02:25 - so here you can see each half
02:27 - being divided again into two halves then
02:29 - here in the third level of this example
02:31 - we still recursively merge sort each of
02:33 - these very small arrays
02:35 - and again the first step to doing that
02:36 - is dividing them so eventually that gets
02:38 - us down to where we have a one
02:40 - element array for each number in the
02:42 - array that we started with so this is
02:43 - the whole dividing portion of the divide
02:46 - and conquer of this algorithm we divide
02:48 - divide divide into smaller and smaller
02:50 - problems
02:51 - until we get to where all of our arrays
02:53 - just have one element in them
02:54 - and we know that an array with just one
02:56 - element in it it's already in order
02:58 - it can't be out of order there's only
02:59 - one element in it so once we get to that
03:01 - state we
03:02 - start the conquer portion of our divide
03:04 - and conquer algorithm
03:05 - and that is the merging let's take a
03:06 - look at this example merge here
03:08 - so to start with we know that we are
03:10 - merging two arrays that are already
03:12 - sorted we know that each one is in order
03:14 - with itself so here we have 27 and 38
03:17 - and 3 and 43 each of those are in order
03:19 - with themselves
03:20 - what we do is we start by comparing the
03:22 - first element of each array
03:24 - which here is 27 and 3 and we say which
03:27 - one is smaller
03:28 - and here 3 is smaller we take the one
03:30 - that is smaller
03:31 - and add it to our merged array so here
03:34 - we add
03:35 - three as the first element in our merged
03:37 - array and then since we added
03:38 - three to our array we move over and look
03:40 - at 43.
03:41 - for our other array since we haven't
03:43 - added 27 yet we're still comparing
03:46 - 27 with that next element of the other
03:48 - array so the next step it would be
03:49 - comparing 27 to
03:51 - 43 which one of those is smaller it's
03:53 - 27.
03:54 - so we go ahead and add 27 to our merged
03:57 - array and then since we added 27 we move
03:59 - over to look at 38 so we're comparing 38
04:01 - to 43
04:02 - which one is smaller 38 so we go and add
04:05 - that
04:05 - to our merged array so then when we add
04:08 - 38 we now have no
04:09 - elements left in this array that haven't
04:11 - already been added to the merged array
04:13 - when that happens we'll go through all
04:14 - the elements in our other array that
04:16 - still has values yet to be added
04:17 - and just add them all in order in this
04:19 - case all we would have left is 43 so we
04:21 - would just add 43
04:23 - to our merged array so after that has
04:25 - happened our result
04:26 - is one merged array that has all the
04:27 - elements of the two arrays we were
04:29 - merging
04:29 - all in perfect order for a while what
04:31 - got me is how do we know
04:33 - that doing the comparisons and the
04:34 - adding in that way how does that result
04:36 - in a perfectly ordered merged array
04:38 - well the key is that both of the arrays
04:41 - that we're merging
04:42 - are already in order if neither of these
04:44 - two arrays were in order merging them
04:46 - with the algorithm we just talked about
04:48 - wouldn't work right we're looping
04:49 - through both of these arrays
04:51 - from their lowest values to their
04:52 - largest adding the lowest value that we
04:54 - find
04:54 - to our merged array and then we slowly
04:56 - progress to higher and higher numbers in
04:58 - each of these arrays
04:59 - and keep adding the next lowest one that
05:00 - we find along the way each of these
05:02 - merge steps that we see
05:03 - operate exactly the same way and then
05:05 - this final merge down at the bottom
05:07 - looks more complicated but it's really
05:08 - not we do the exact same thing
05:10 - so now that we've gone through all that
05:11 - let's get to the code so again all the
05:14 - magic in our code is going to be
05:16 - happening in this
05:16 - merge sort method the first thing we
05:19 - want to do here is to create a variable
05:21 - for the length of this input array
05:23 - because we're going to need the length
05:24 - of this input array many times
05:26 - throughout this algorithm so having a
05:27 - variable for it just makes our life a
05:29 - little easier so we'll call it input
05:30 - length and set it equal to input array
05:33 - dot length so remember we are going to
05:35 - be calling this merge sort method
05:37 - recursively which means yes we're going
05:39 - to be starting it by calling it on one
05:40 - larger array but even as it gets further
05:42 - and further down into these sorts of
05:44 - levels here where there's only one or
05:45 - two elements in each array
05:47 - we're going to be calling that merge
05:48 - sort method recursively on smaller and
05:50 - smaller arrays until we're eventually
05:52 - calling it on arrays with just
05:53 - one element in them and we know that
05:55 - arrays with just one element are of
05:56 - course
05:57 - already sorted so actually the first
05:58 - thing we want to do is check that
06:00 - if the input length is less than 2
06:04 - which of course means we either have an
06:05 - empty array or an array with just
06:07 - one thing in it then we just return so
06:09 - that accounts for like this part of the
06:11 - algorithm here
06:12 - where we have a bunch of arrays with
06:13 - just one element in them we don't divide
06:15 - that into two arrays and have each side
06:17 - sort itself we only have one element in
06:18 - it so we already know it's sorted
06:20 - so this accounts for that if the array
06:22 - that comes in is less than two elements
06:24 - long which is essentially
06:25 - either a zero or a one element array
06:27 - then we just return there's nothing for
06:29 - us to do it's already
06:30 - sorted but if that's not the case if we
06:31 - have two or more elements in the array
06:33 - that we're looking to sort right now
06:35 - then we continue
06:36 - the next thing to do in our algorithm is
06:37 - to divide our array into two arrays to
06:40 - do that we need to get the midpoint of
06:41 - our array which is just half of the
06:43 - input length so if we came in with an
06:45 - input array
06:45 - that was 10 elements long we want to
06:48 - divide it into two arrays
06:49 - split at that fifth element in the
06:51 - midpoint so to do that we'll create
06:52 - another variable we'll call it
06:54 - um mid index and set it equal to the
06:56 - input length
06:58 - divided by two and then we'll actually
06:59 - create our two arrays for the left and
07:01 - right half we'll create an int array
07:04 - call it left half and set it equal to a
07:06 - new
07:07 - int array that we will create and we
07:09 - need to give it a length and we can just
07:10 - use
07:11 - mid index because we know that'll give
07:13 - it half the length of our original array
07:15 - so again if our input array was 10
07:16 - elements long
07:17 - this mid index would be 5 and our left
07:19 - half array here would have a length of 5
07:21 - which is what we want
07:22 - now we have to create our right half
07:24 - equals new int array
07:26 - and we also need a length here and to do
07:28 - that we're actually going to use input
07:30 - length
07:31 - minus mid index you might be thinking
07:33 - hey we can just use mid
07:34 - index here also but that ends up not
07:36 - working right for arrays with odd
07:38 - numbers of elements in them so if this
07:39 - input array came in with
07:41 - 9 elements in it then input length
07:42 - divided by two would actually end up
07:44 - being
07:44 - four so the left half would be four
07:46 - elements long and we need to hold the
07:48 - other five elements in the right half
07:50 - so input length minus mid index works
07:52 - great for that that would be
07:53 - nine minus four which gives us the five
07:56 - elements that we need so now we've
07:57 - created these two arrays left half and
07:59 - right half
08:00 - but they don't have any elements in them
08:01 - yet so we actually have to populate them
08:03 - with all the elements from our original
08:05 - larger input array so first we'll fill
08:07 - up the left half
08:08 - by doing four int i equals 0
08:12 - i less than so what do we want to use
08:14 - here we're just trying to fill up the
08:16 - left half array so we can only loop
08:18 - until the end of that array
08:20 - so we actually want to use is this mid
08:22 - index
08:23 - and then of course increment i i plus
08:26 - plus
08:26 - so we're looping from zero to the length
08:29 - of our left half
08:30 - so this i is what we'll be using as the
08:32 - index of our array and what we want to
08:33 - do here is
08:34 - copy the elements from our original
08:36 - input array into our left half array so
08:38 - to do that we just set left
08:40 - half at i the i index of our left half
08:43 - array to be equal to the input arrays
08:48 - ith element so after this for loop
08:50 - completes
08:51 - our left half array will contain all the
08:53 - elements from the left half of our input
08:55 - array and now we want to fill up the
08:57 - right half array with all of the
08:58 - elements of the right half of our input
09:00 - array so it'll be similar but not
09:01 - exactly the same
09:02 - we can copy paste here as a start here
09:04 - we actually want to start with i
09:06 - at the mid index and loop until i
09:09 - reaches
09:09 - the original input length of our input
09:11 - array and of course still increment i
09:13 - each time so essentially what we're
09:14 - needing to do
09:15 - is loop through the second half of our
09:17 - original input array
09:18 - and that's what this allows us to do
09:19 - here so we start at that mid index at
09:21 - the midpoint
09:22 - and go until the end this input length
09:24 - and we still want to use input array i
09:26 - here
09:26 - but now using i as the index of this
09:28 - left half that we're assigning to
09:29 - doesn't really work
09:30 - again if we have a mid index of 5 we
09:32 - don't want to be starting by setting the
09:34 - fifth
09:34 - element of our left half we want to
09:35 - start at the zeroth element but we still
09:37 - do want to use i here because we do want
09:39 - to be starting at the midpoint
09:41 - of this original input array what we
09:42 - want to modify here is instead of
09:44 - setting
09:45 - left half i we want to set left half of
09:47 - i
09:48 - minus mid index so again for example if
09:51 - we have a mid index of five
09:52 - this will start with five minus five
09:55 - which will be
09:56 - zero the zeroth index which is what we
09:58 - want and then when it moves on to the
09:59 - next one
10:00 - then i will be six and we'll be setting
10:02 - the element at six minus five which will
10:05 - be one the next element in the array
10:07 - and of course also we want to change
10:08 - this to right half instead of left half
10:10 - we don't want to be overriding the left
10:11 - half again we want to be creating the
10:12 - right half
10:13 - essentially what is happening here is
10:14 - we're filling up the right half array
10:16 - that we created
10:17 - with all the elements from the right
10:19 - half of our original input array
10:21 - okay now after all of that is completed
10:24 - we have our left half and right half
10:25 - arrays that contain the left half and
10:27 - right half of our original
10:29 - input array what does our algorithm say
10:31 - has to happen next
10:32 - well what we do is we merge sort each of
10:35 - those two
10:36 - arrays and then later we'll merge them
10:38 - together so how do we tell our algorithm
10:40 - to merge sort each half of our array
10:43 - well that's actually the simplest part
10:44 - of this so far
10:45 - we have a merge sort method that we're
10:47 - writing so all we have to do is
10:48 - recursively
10:49 - call it with our left and right halves
10:52 - so we will literally just say
10:53 - merge sort left half and merge sort
10:56 - right half after this point in the
10:59 - finished algorithm
11:00 - we should have two completely sorted
11:02 - halves
11:03 - and the last remaining step would be to
11:05 - merge those halves together so that's
11:06 - what we need to do
11:08 - here we need to write the code to merge
11:10 - these two
11:11 - sorted arrays into one large sorted
11:13 - array and to simplify our code a little
11:15 - bit we're actually going to write a
11:16 - method to do that just so we don't
11:18 - clutter up
11:18 - this merge sort method too much so we'll
11:20 - create a private
11:21 - static void method called merge
11:24 - now it needs to take in actually three
11:26 - things it needs to take in the inter
11:28 - array
11:29 - the original combined input array so it
11:31 - can merge the left and right arrays
11:33 - into it in sorted order and the left and
11:35 - right half arrays
11:36 - int array left half and int array
11:41 - right half similar to how we did in the
11:43 - merge sort method first we actually need
11:45 - the length of our left half and right
11:47 - half
11:47 - so we can do that the same way int we'll
11:49 - call it left size
11:51 - equals left half dot length
11:54 - and end right size equals right half
11:58 - dot length next is the part of the
12:00 - algorithm that can probably be the most
12:02 - confusing this is where we're going to
12:03 - be lubing through the elements in our
12:05 - left and right arrays
12:06 - of course from lowest to highest because
12:08 - they're already in sorted order
12:09 - comparing the first elements of each and
12:11 - adding the lower one
12:12 - to our merged array and keep comparing
12:15 - the lowest element of each array and
12:16 - adding the lower one to our merged array
12:18 - until we run out of elements in our left
12:20 - and right arrays so we actually need
12:22 - three iterator variables one for walking
12:24 - through the left half array
12:25 - one for walking through the right half
12:27 - array and one for walking through our
12:28 - merged array so to do that we'll need
12:30 - three
12:31 - ins that start at zero so we'll need int
12:33 - i equals zero
12:35 - and j equals zero
12:38 - and into k equals zero now if you want
12:40 - to be cool you can put all these in one
12:42 - line and just separate them by
12:44 - commas if they're all the same data
12:46 - types you can do this
12:47 - so you can just have int i equals zero j
12:49 - equals zero k equals zero
12:50 - and put all those in one line and look
12:52 - really cool i will be the iterator for
12:54 - our left half
12:55 - j will be the iterator for our right
12:56 - half and k will be the iterator
12:58 - for our merged array we'll actually use
13:00 - a while loop here and we're going to
13:02 - loop
13:02 - while i is less than left size and
13:06 - j is less than right size so this is
13:09 - basically looping until
13:10 - we run out of elements in the left array
13:12 - or we run out of elements on the right
13:14 - array
13:14 - so here what we actually want to do is
13:16 - compare the i th
13:17 - element of the left half with the jth
13:20 - element
13:21 - of the right half so we're saying here
13:23 - if left half at i
13:25 - is less than or equal to the right half
13:27 - at j
13:28 - then this is the smaller of the two
13:30 - numbers or they could be equal and it
13:31 - doesn't matter which one we add so we'll
13:33 - just add the one
13:34 - in the left half array we will add that
13:35 - element at left half i
13:37 - to our merged array we know that is the
13:39 - lowest element that we are looking at so
13:41 - far
13:41 - so we'll say input array at k
13:45 - which remember is our iterator for our
13:47 - merged array and set it equal to
13:49 - left half at i so now that this i
13:52 - element in our left half array has been
13:54 - added already to our input array our
13:56 - merged array
13:57 - we want to increment i to then look at
13:59 - the next element
14:00 - of the left half array so to do that we
14:02 - just say i plus plus
14:03 - now otherwise else so here we checked if
14:06 - our left half at i
14:08 - is less than or equal to the right half
14:10 - at j and if this
14:11 - wasn't the case and it didn't enter this
14:13 - if then we know that this
14:14 - j element of the right half is actually
14:17 - the smaller of these two numbers
14:18 - so in that case we would add the j
14:21 - element of our right half to our merged
14:23 - array
14:23 - and so that looks very similar to our
14:24 - code above we'll say input array
14:27 - at k set that equal to right half
14:31 - at j and then since we're adding the
14:34 - element that we found in the right half
14:35 - array we need to increment
14:36 - j so in the example here what just
14:38 - happened is we've just compared the
14:40 - first element of our left and right half
14:42 - arrays we've compared three with nine
14:44 - in this case three was less than nine so
14:46 - we add three
14:47 - to our merged array so here in our code
14:49 - it's as if this element in our left half
14:51 - array was less than
14:53 - the value we were looking at in our
14:54 - right half array this assignment is like
14:56 - adding 3 to our merged array and then we
14:59 - increment
14:59 - i which means we will shift from looking
15:01 - at this 3 to looking at this 27
15:03 - and comparing it with the first element
15:05 - of the right array if the first element
15:07 - of our right array happened to be
15:08 - smaller then we would have added
15:09 - it to our combined array and increment
15:11 - it to look at the next element of the
15:13 - right array and that's what this else is
15:14 - accounting for
15:15 - now either way no matter if we added the
15:17 - element from the left or the right array
15:19 - either way we want to increment our
15:20 - combined array iterator
15:22 - which here is k so completely outside of
15:25 - that if else we want to do k
15:26 - plus plus now that we've set this first
15:28 - value we next want to set
15:30 - the second value so now this will keep
15:32 - looping through
15:33 - going through the arrays at each half
15:35 - and adding the lower element to our
15:36 - merged array until this condition is met
15:39 - which will go until
15:40 - we either run out of elements in our
15:41 - left array or run out of elements in our
15:43 - right array
15:44 - either way there's nothing left to
15:45 - compare but if we ran out of elements in
15:47 - either our left or right array
15:49 - we still have some numbers left in
15:51 - whichever array we didn't reach the end
15:52 - of and so after this while loop
15:54 - essentially we just need to do
15:55 - cleanup and add all of the elements that
15:57 - are still remaining in either the left
15:59 - or right array so using the smaller
16:01 - merge as an example
16:02 - first we start by comparing 27 and three
16:04 - three is lower so we add it
16:06 - and then we're comparing 27 to 43 27 is
16:09 - lower so we add it and then we move to
16:11 - comparing 38 with 43
16:13 - 38 is lower so we add it at that point
16:15 - we have added all the elements in this
16:17 - left array and there's nothing left so
16:19 - that would trigger this to exit the
16:21 - while loop but we still haven't added
16:23 - the rest of the elements from our right
16:24 - array and so we just need to loop
16:26 - through those remaining elements and add
16:28 - them to our merged list
16:29 - and in this point in the code it could
16:31 - be the left or the right arrays that
16:32 - have elements left over so we can just
16:34 - have code for both of them so to account
16:36 - for any possible elements left over in
16:38 - the left array we can say while i
16:40 - less than left size input array
16:44 - at k equals left half
16:48 - at i and then we went to increment the
16:50 - iterators of both i
16:52 - and k so how this works is if we already
16:55 - ran out of elements in our left array
16:57 - it would just bypass this completely and
16:59 - then we do the same for any remaining
17:00 - elements
17:01 - in our right array but just with
17:03 - different variables so we would say
17:04 - while j
17:05 - is less than right size then input array
17:09 - at k
17:09 - equals left half at j and we do
17:13 - j plus plus instead of i plus plus so at
17:15 - that point we've looped through
17:16 - each of our two halves constantly adding
17:19 - the lower of the two values to our
17:20 - merged array we loop through and add any
17:22 - remaining elements to the end of our
17:24 - combined array so now by the end of this
17:26 - merge method
17:27 - this input array will have all of the
17:29 - elements from the left and right half
17:30 - arrays combined in perfect order so now
17:33 - all that's left to do we've created
17:35 - our merge method we just haven't called
17:37 - it yet so here let's get rid of this
17:39 - and actually call our merge method with
17:42 - our left and right half arrays so what
17:44 - we have to give it is our original input
17:46 - array
17:47 - as we have here and then our left half
17:49 - and right half left half
17:52 - right half okay i think that completes
17:55 - the algorithm
17:56 - let's zoom out a little bit to have a
17:58 - look at our handy work but before we get
18:00 - too excited let's actually run it
18:02 - and make sure it works so here we'll do
18:04 - it with an array of just 10 elements
18:07 - let's give it a try
18:10 - ah i don't know we actually got an array
18:12 - index out of bounds exception
18:14 - so there's some problem somewhere where
18:15 - we're trying to reference an index
18:17 - of an array that doesn't exist we're
18:18 - trying to access like the fifth element
18:20 - of an array that only has four so let's
18:22 - click this line so we can see exactly
18:24 - where it's happening
18:25 - i see the problem it's a copy paste
18:27 - error i'm still using left half here
18:29 - when i should be using right half okay
18:32 - so that's an easy fix let's go ahead and
18:34 - run it again okay so we can see the
18:37 - before state here we started out with a
18:39 - completely unsorted list and then after
18:42 - it looks like this list is perfectly
18:44 - sorted okay so far so good that's
18:46 - looking great let's run it a few more
18:48 - times just to be sure
18:51 - looks good looks good
18:55 - looks good awesome okay so now that we
18:57 - have the algorithm working let's put it
18:59 - to the test right now we're only using
19:01 - 10 numbers let's crank it up let's do uh
19:04 - 10
19:04 - 000. run that so so it did that in
19:08 - in no time less than a second you
19:10 - couldn't even notice it so let's crank
19:11 - it up again and do a hundred thousand
19:13 - run that wow again pretty much
19:16 - instantaneous
19:17 - you know just one or two seconds it
19:19 - probably took more time to actually
19:21 - print out the sorted list than it did to
19:23 - actually do the sorting
19:24 - so 100 000 is that fast i don't see a
19:27 - reason not to keep going let's
19:28 - step it up to a million
19:32 - there goes printing out the randomly
19:33 - sorted list oh and it already is
19:35 - starting to print out the sorted lists
19:37 - and in that case in like seven seconds
19:39 - and really it looked like most of that
19:41 - time was just
19:42 - spent printing out the list themselves
19:43 - rather than actually doing the sorting
19:45 - so let's start getting nuts let's do 10
19:48 - million
19:50 - okay it's printing out the unsorted list
19:53 - so it hasn't even started trying to sort
19:55 - them yet it has to go through all this
19:57 - printing before it even begins sorting
19:59 - let's see you'll see it stop for a
20:01 - second in a moment while it when it does
20:02 - its sorting
20:04 - okay it stopped now it's sorting and
20:07 - it's already done
20:08 - now it's printing out the list in sorted
20:11 - order
20:12 - so this is the part that's taking a
20:13 - while not the actual sorting so i think
20:15 - what we'll do next is now that we know
20:17 - that it's sorting the arrays properly
20:20 - we'll just comment out the actual
20:21 - printing of it so that we know that the
20:22 - amount of time that it takes is the
20:23 - amount of time that it actually took to
20:25 - sort the list and not just print it out
20:27 - that took about a minute to run but as
20:28 - you saw most of that time was spent just
20:30 - printing out the lists
20:31 - so let's go ahead and comment out both
20:34 - of our print array calls so we're still
20:36 - creating the random array
20:37 - and we're still sorting it but we're
20:39 - just not bothering to print it so we can
20:41 - get a good feel for exactly how long the
20:43 - actual
20:44 - sorting is taking and let's
20:47 - run it before okay
20:50 - and after so we know when it printed out
20:52 - the word after that meant it had already
20:53 - sorted the list
20:54 - so we can see up here that took about
20:55 - three seconds to sort an array of
20:58 - 10 million ins so of course that kicks
21:02 - the daylights out of the last two
21:03 - sorting algorithms we made of course it
21:05 - just wrecks bogo sort which
21:06 - took five hours for just 14 ins but also
21:09 - it's
21:10 - worlds better than bubble sort which
21:12 - took about 37 minutes to do a million
21:15 - this did 10 million in just a few
21:18 - seconds
21:18 - okay so it took four seconds to do 10
21:20 - million let's
21:21 - let's keep going let's do 100 million
21:23 - how long is it going to take
21:28 - before
21:30 - sorting this one is taking a little bit
21:32 - longer but it's doing a hundred million
21:35 - after so it's done so it went from 11 35
21:38 - 19 to 11 35
21:40 - 43 so that is still less than 30 seconds
21:42 - that's less than 30 seconds
21:44 - to sort 100 million ins not to mention
21:47 - actually creating this random list and
21:49 - all of that
21:50 - but even setting that aside sorting a
21:52 - list that large in less than 30 seconds
21:53 - is awesome but hey i don't see a reason
21:55 - not to keep going let's see if we can do
21:58 - a billion what happens if we do a
22:00 - billion and
22:02 - run
22:06 - oh we ran out of memory it looks like we
22:09 - can't at least on my computer we can't
22:11 - create an
22:11 - array of a billion ins and sort them
22:15 - so at least on my computer java just
22:17 - doesn't have the amount of memory that
22:18 - it needs
22:19 - to do this sorting for a billion in so
22:22 - that's a little bit of a bummer i would
22:23 - like to have seen how long it would take
22:25 - but i mean that's okay that's a great
22:26 - problem to have we can sort
22:28 - so many numbers that the limitation is
22:30 - to the memory that we have on our
22:31 - machine rather than the speed of the
22:33 - algorithm
22:34 - so it looks like that's what an
22:35 - algorithm with big o of n log and
22:37 - complexity
22:38 - can do for you if you enjoyed this video
22:40 - or learned something please let me know
22:41 - by leaving a like and if you'd like to
22:42 - see more java videos like this one in
22:44 - the future be sure to subscribe so you
22:45 - don't miss the new video
22:46 - every week and really thank you for
22:48 - taking the time to like and subscribe
22:49 - it's the only way these videos get out
22:51 - to help more people and so i really do
22:52 - appreciate it and remember you can grab
22:53 - the source in the link below and so if
22:55 - you can run it on your computer and get
22:57 - it to work with a billion ins i would
22:58 - love to hear about it thanks for
23:00 - watching

Cleaned transcript:

in this video we are going to code the merge sort sorting algorithm in java in my bubble sort video i got a comment that said can you do merge sort next ask and you shall receive now we know this sorting algorithm is going to be faster it has a complexity of big o of n log n but how much faster does it actually work out to with a real implementation with bubble sort we got up to sorting a million numbers but it still took about 37 minutes with merge sort of course we're going to see how much faster we can do a million integers but we're even going to take it a step further and go to 10 million 100 million even a billion if we can get there if this is your first time watching this channel my name is john and i do a new java tutorial video like this one every single week so be sure to leave a like and hit the subscribe button so you don't miss the new video every week and as always you can get the full source code of this program in the link down in the description so go and get it as with all the sorting algorithm videos so far i start with a little bit of a program set up first i create this array of ins called numbers here we're just starting with a length of 10 so we'll have 10 numbers to sort and then we loop through that array to fill it with random ins essentially between zero and a million so that gives us our unsorted array that we want to sort and then after that we print out the before state the unordered array and then we have the call to our merge sort method which is currently empty that is what we will be writing in this video and then after that merge sort method is called we should have a sorted list and so we just print that array again and we should see it in perfectly sorted order i know we want to just dive head first into the code but before we do it's a good idea to get a mental model of how merge sort works this is a diagram just from the merge sort wikipedia page that gives a pretty good picture of how it works you start out with your unordered array you divide that array into two halves and merge sort each half recursively and then once each half of your array is sorted so this half is in order and this half is in order then you go through a process of merging both of those halves of your array into one array again and that one array will be in order how that merge process actually works is key and we'll get into that more when we get to the code we start with this completely unordered array then we divide it in half into two arrays and then we tell each array to merge sort itself that's the recursive part of this algorithm so you can see here this first array is being split into two halves and then the same merge sort algorithm will be called for each of these halves well the first part of the algorithm is to again split into two halves and merge sort each half so here you can see each half being divided again into two halves then here in the third level of this example we still recursively merge sort each of these very small arrays and again the first step to doing that is dividing them so eventually that gets us down to where we have a one element array for each number in the array that we started with so this is the whole dividing portion of the divide and conquer of this algorithm we divide divide divide into smaller and smaller problems until we get to where all of our arrays just have one element in them and we know that an array with just one element in it it's already in order it can't be out of order there's only one element in it so once we get to that state we start the conquer portion of our divide and conquer algorithm and that is the merging let's take a look at this example merge here so to start with we know that we are merging two arrays that are already sorted we know that each one is in order with itself so here we have 27 and 38 and 3 and 43 each of those are in order with themselves what we do is we start by comparing the first element of each array which here is 27 and 3 and we say which one is smaller and here 3 is smaller we take the one that is smaller and add it to our merged array so here we add three as the first element in our merged array and then since we added three to our array we move over and look at 43. for our other array since we haven't added 27 yet we're still comparing 27 with that next element of the other array so the next step it would be comparing 27 to 43 which one of those is smaller it's 27. so we go ahead and add 27 to our merged array and then since we added 27 we move over to look at 38 so we're comparing 38 to 43 which one is smaller 38 so we go and add that to our merged array so then when we add 38 we now have no elements left in this array that haven't already been added to the merged array when that happens we'll go through all the elements in our other array that still has values yet to be added and just add them all in order in this case all we would have left is 43 so we would just add 43 to our merged array so after that has happened our result is one merged array that has all the elements of the two arrays we were merging all in perfect order for a while what got me is how do we know that doing the comparisons and the adding in that way how does that result in a perfectly ordered merged array well the key is that both of the arrays that we're merging are already in order if neither of these two arrays were in order merging them with the algorithm we just talked about wouldn't work right we're looping through both of these arrays from their lowest values to their largest adding the lowest value that we find to our merged array and then we slowly progress to higher and higher numbers in each of these arrays and keep adding the next lowest one that we find along the way each of these merge steps that we see operate exactly the same way and then this final merge down at the bottom looks more complicated but it's really not we do the exact same thing so now that we've gone through all that let's get to the code so again all the magic in our code is going to be happening in this merge sort method the first thing we want to do here is to create a variable for the length of this input array because we're going to need the length of this input array many times throughout this algorithm so having a variable for it just makes our life a little easier so we'll call it input length and set it equal to input array dot length so remember we are going to be calling this merge sort method recursively which means yes we're going to be starting it by calling it on one larger array but even as it gets further and further down into these sorts of levels here where there's only one or two elements in each array we're going to be calling that merge sort method recursively on smaller and smaller arrays until we're eventually calling it on arrays with just one element in them and we know that arrays with just one element are of course already sorted so actually the first thing we want to do is check that if the input length is less than 2 which of course means we either have an empty array or an array with just one thing in it then we just return so that accounts for like this part of the algorithm here where we have a bunch of arrays with just one element in them we don't divide that into two arrays and have each side sort itself we only have one element in it so we already know it's sorted so this accounts for that if the array that comes in is less than two elements long which is essentially either a zero or a one element array then we just return there's nothing for us to do it's already sorted but if that's not the case if we have two or more elements in the array that we're looking to sort right now then we continue the next thing to do in our algorithm is to divide our array into two arrays to do that we need to get the midpoint of our array which is just half of the input length so if we came in with an input array that was 10 elements long we want to divide it into two arrays split at that fifth element in the midpoint so to do that we'll create another variable we'll call it um mid index and set it equal to the input length divided by two and then we'll actually create our two arrays for the left and right half we'll create an int array call it left half and set it equal to a new int array that we will create and we need to give it a length and we can just use mid index because we know that'll give it half the length of our original array so again if our input array was 10 elements long this mid index would be 5 and our left half array here would have a length of 5 which is what we want now we have to create our right half equals new int array and we also need a length here and to do that we're actually going to use input length minus mid index you might be thinking hey we can just use mid index here also but that ends up not working right for arrays with odd numbers of elements in them so if this input array came in with 9 elements in it then input length divided by two would actually end up being four so the left half would be four elements long and we need to hold the other five elements in the right half so input length minus mid index works great for that that would be nine minus four which gives us the five elements that we need so now we've created these two arrays left half and right half but they don't have any elements in them yet so we actually have to populate them with all the elements from our original larger input array so first we'll fill up the left half by doing four int i equals 0 i less than so what do we want to use here we're just trying to fill up the left half array so we can only loop until the end of that array so we actually want to use is this mid index and then of course increment i i plus plus so we're looping from zero to the length of our left half so this i is what we'll be using as the index of our array and what we want to do here is copy the elements from our original input array into our left half array so to do that we just set left half at i the i index of our left half array to be equal to the input arrays ith element so after this for loop completes our left half array will contain all the elements from the left half of our input array and now we want to fill up the right half array with all of the elements of the right half of our input array so it'll be similar but not exactly the same we can copy paste here as a start here we actually want to start with i at the mid index and loop until i reaches the original input length of our input array and of course still increment i each time so essentially what we're needing to do is loop through the second half of our original input array and that's what this allows us to do here so we start at that mid index at the midpoint and go until the end this input length and we still want to use input array i here but now using i as the index of this left half that we're assigning to doesn't really work again if we have a mid index of 5 we don't want to be starting by setting the fifth element of our left half we want to start at the zeroth element but we still do want to use i here because we do want to be starting at the midpoint of this original input array what we want to modify here is instead of setting left half i we want to set left half of i minus mid index so again for example if we have a mid index of five this will start with five minus five which will be zero the zeroth index which is what we want and then when it moves on to the next one then i will be six and we'll be setting the element at six minus five which will be one the next element in the array and of course also we want to change this to right half instead of left half we don't want to be overriding the left half again we want to be creating the right half essentially what is happening here is we're filling up the right half array that we created with all the elements from the right half of our original input array okay now after all of that is completed we have our left half and right half arrays that contain the left half and right half of our original input array what does our algorithm say has to happen next well what we do is we merge sort each of those two arrays and then later we'll merge them together so how do we tell our algorithm to merge sort each half of our array well that's actually the simplest part of this so far we have a merge sort method that we're writing so all we have to do is recursively call it with our left and right halves so we will literally just say merge sort left half and merge sort right half after this point in the finished algorithm we should have two completely sorted halves and the last remaining step would be to merge those halves together so that's what we need to do here we need to write the code to merge these two sorted arrays into one large sorted array and to simplify our code a little bit we're actually going to write a method to do that just so we don't clutter up this merge sort method too much so we'll create a private static void method called merge now it needs to take in actually three things it needs to take in the inter array the original combined input array so it can merge the left and right arrays into it in sorted order and the left and right half arrays int array left half and int array right half similar to how we did in the merge sort method first we actually need the length of our left half and right half so we can do that the same way int we'll call it left size equals left half dot length and end right size equals right half dot length next is the part of the algorithm that can probably be the most confusing this is where we're going to be lubing through the elements in our left and right arrays of course from lowest to highest because they're already in sorted order comparing the first elements of each and adding the lower one to our merged array and keep comparing the lowest element of each array and adding the lower one to our merged array until we run out of elements in our left and right arrays so we actually need three iterator variables one for walking through the left half array one for walking through the right half array and one for walking through our merged array so to do that we'll need three ins that start at zero so we'll need int i equals zero and j equals zero and into k equals zero now if you want to be cool you can put all these in one line and just separate them by commas if they're all the same data types you can do this so you can just have int i equals zero j equals zero k equals zero and put all those in one line and look really cool i will be the iterator for our left half j will be the iterator for our right half and k will be the iterator for our merged array we'll actually use a while loop here and we're going to loop while i is less than left size and j is less than right size so this is basically looping until we run out of elements in the left array or we run out of elements on the right array so here what we actually want to do is compare the i th element of the left half with the jth element of the right half so we're saying here if left half at i is less than or equal to the right half at j then this is the smaller of the two numbers or they could be equal and it doesn't matter which one we add so we'll just add the one in the left half array we will add that element at left half i to our merged array we know that is the lowest element that we are looking at so far so we'll say input array at k which remember is our iterator for our merged array and set it equal to left half at i so now that this i element in our left half array has been added already to our input array our merged array we want to increment i to then look at the next element of the left half array so to do that we just say i plus plus now otherwise else so here we checked if our left half at i is less than or equal to the right half at j and if this wasn't the case and it didn't enter this if then we know that this j element of the right half is actually the smaller of these two numbers so in that case we would add the j element of our right half to our merged array and so that looks very similar to our code above we'll say input array at k set that equal to right half at j and then since we're adding the element that we found in the right half array we need to increment j so in the example here what just happened is we've just compared the first element of our left and right half arrays we've compared three with nine in this case three was less than nine so we add three to our merged array so here in our code it's as if this element in our left half array was less than the value we were looking at in our right half array this assignment is like adding 3 to our merged array and then we increment i which means we will shift from looking at this 3 to looking at this 27 and comparing it with the first element of the right array if the first element of our right array happened to be smaller then we would have added it to our combined array and increment it to look at the next element of the right array and that's what this else is accounting for now either way no matter if we added the element from the left or the right array either way we want to increment our combined array iterator which here is k so completely outside of that if else we want to do k plus plus now that we've set this first value we next want to set the second value so now this will keep looping through going through the arrays at each half and adding the lower element to our merged array until this condition is met which will go until we either run out of elements in our left array or run out of elements in our right array either way there's nothing left to compare but if we ran out of elements in either our left or right array we still have some numbers left in whichever array we didn't reach the end of and so after this while loop essentially we just need to do cleanup and add all of the elements that are still remaining in either the left or right array so using the smaller merge as an example first we start by comparing 27 and three three is lower so we add it and then we're comparing 27 to 43 27 is lower so we add it and then we move to comparing 38 with 43 38 is lower so we add it at that point we have added all the elements in this left array and there's nothing left so that would trigger this to exit the while loop but we still haven't added the rest of the elements from our right array and so we just need to loop through those remaining elements and add them to our merged list and in this point in the code it could be the left or the right arrays that have elements left over so we can just have code for both of them so to account for any possible elements left over in the left array we can say while i less than left size input array at k equals left half at i and then we went to increment the iterators of both i and k so how this works is if we already ran out of elements in our left array it would just bypass this completely and then we do the same for any remaining elements in our right array but just with different variables so we would say while j is less than right size then input array at k equals left half at j and we do j plus plus instead of i plus plus so at that point we've looped through each of our two halves constantly adding the lower of the two values to our merged array we loop through and add any remaining elements to the end of our combined array so now by the end of this merge method this input array will have all of the elements from the left and right half arrays combined in perfect order so now all that's left to do we've created our merge method we just haven't called it yet so here let's get rid of this and actually call our merge method with our left and right half arrays so what we have to give it is our original input array as we have here and then our left half and right half left half right half okay i think that completes the algorithm let's zoom out a little bit to have a look at our handy work but before we get too excited let's actually run it and make sure it works so here we'll do it with an array of just 10 elements let's give it a try ah i don't know we actually got an array index out of bounds exception so there's some problem somewhere where we're trying to reference an index of an array that doesn't exist we're trying to access like the fifth element of an array that only has four so let's click this line so we can see exactly where it's happening i see the problem it's a copy paste error i'm still using left half here when i should be using right half okay so that's an easy fix let's go ahead and run it again okay so we can see the before state here we started out with a completely unsorted list and then after it looks like this list is perfectly sorted okay so far so good that's looking great let's run it a few more times just to be sure looks good looks good looks good awesome okay so now that we have the algorithm working let's put it to the test right now we're only using 10 numbers let's crank it up let's do uh 10 000. run that so so it did that in in no time less than a second you couldn't even notice it so let's crank it up again and do a hundred thousand run that wow again pretty much instantaneous you know just one or two seconds it probably took more time to actually print out the sorted list than it did to actually do the sorting so 100 000 is that fast i don't see a reason not to keep going let's step it up to a million there goes printing out the randomly sorted list oh and it already is starting to print out the sorted lists and in that case in like seven seconds and really it looked like most of that time was just spent printing out the list themselves rather than actually doing the sorting so let's start getting nuts let's do 10 million okay it's printing out the unsorted list so it hasn't even started trying to sort them yet it has to go through all this printing before it even begins sorting let's see you'll see it stop for a second in a moment while it when it does its sorting okay it stopped now it's sorting and it's already done now it's printing out the list in sorted order so this is the part that's taking a while not the actual sorting so i think what we'll do next is now that we know that it's sorting the arrays properly we'll just comment out the actual printing of it so that we know that the amount of time that it takes is the amount of time that it actually took to sort the list and not just print it out that took about a minute to run but as you saw most of that time was spent just printing out the lists so let's go ahead and comment out both of our print array calls so we're still creating the random array and we're still sorting it but we're just not bothering to print it so we can get a good feel for exactly how long the actual sorting is taking and let's run it before okay and after so we know when it printed out the word after that meant it had already sorted the list so we can see up here that took about three seconds to sort an array of 10 million ins so of course that kicks the daylights out of the last two sorting algorithms we made of course it just wrecks bogo sort which took five hours for just 14 ins but also it's worlds better than bubble sort which took about 37 minutes to do a million this did 10 million in just a few seconds okay so it took four seconds to do 10 million let's let's keep going let's do 100 million how long is it going to take before sorting this one is taking a little bit longer but it's doing a hundred million after so it's done so it went from 11 35 19 to 11 35 43 so that is still less than 30 seconds that's less than 30 seconds to sort 100 million ins not to mention actually creating this random list and all of that but even setting that aside sorting a list that large in less than 30 seconds is awesome but hey i don't see a reason not to keep going let's see if we can do a billion what happens if we do a billion and run oh we ran out of memory it looks like we can't at least on my computer we can't create an array of a billion ins and sort them so at least on my computer java just doesn't have the amount of memory that it needs to do this sorting for a billion in so that's a little bit of a bummer i would like to have seen how long it would take but i mean that's okay that's a great problem to have we can sort so many numbers that the limitation is to the memory that we have on our machine rather than the speed of the algorithm so it looks like that's what an algorithm with big o of n log and complexity can do for you if you enjoyed this video or learned something please let me know by leaving a like and if you'd like to see more java videos like this one in the future be sure to subscribe so you don't miss the new video every week and really thank you for taking the time to like and subscribe it's the only way these videos get out to help more people and so i really do appreciate it and remember you can grab the source in the link below and so if you can run it on your computer and get it to work with a billion ins i would love to hear about it thanks for watching
