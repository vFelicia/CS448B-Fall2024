With timestamps:

00:00 - what exactly are sets and hash sets in
00:02 - Java we'll talk about exactly what these
00:05 - are and how you can use them and we'll
00:06 - also talk about the situations where
00:08 - sets and hash sets are the perfect
00:10 - solution to your program as always my
00:12 - full Java course is available in the
00:14 - link down in the description if you're
00:15 - interested first thanks to mailgun for
00:17 - sponsoring this video mailgun is how
00:19 - modern companies work with email mailgun
00:21 - is easy to use has amazing world-class
00:24 - customer support and simple but powerful
00:26 - apis that smart developers can use to
00:28 - reach customers at scale so their
00:30 - organizations can grow faster with their
00:32 - detailed documentation you can easily
00:34 - integrate email into any application
00:36 - with just a few lines of code you can
00:38 - send and track transactional and
00:40 - marketing messages remove invalid emails
00:42 - from your list or just prevent fake
00:44 - signups in the first place easily their
00:46 - team of experts is available 24 7 to
00:48 - help you improve your email
00:49 - deliverability and drive higher
00:51 - conversion rates with its powerful email
00:53 - API for developers and intuitive email
00:55 - Marketing Solutions mailgun Works
00:57 - through the entire email lifecycle from
00:59 - plan all the way to the Inbox and it
01:01 - does that for more than 240 billion
01:04 - emails a year for top companies like
01:06 - Wikipedia DHL toast Lyft and Microsoft
01:09 - melgun also has an amazing send time
01:12 - optimization feature which automatically
01:14 - finds the perfect time to send the email
01:16 - to each and every individual on their
01:18 - list at the exact time that they're most
01:20 - likely to engage mailgun truly makes it
01:22 - easier than ever to build connected
01:24 - experiences through email so thanks
01:26 - again to mailgun for sponsoring this
01:28 - video try mailgun today for free by
01:30 - using my link which you can find down in
01:32 - the description mailgun.com John now
01:35 - let's get right to it alright so sets
01:37 - and hash sets well first just what
01:39 - exactly is a set well a set is one of
01:42 - the things available to you in Java's
01:44 - collections framework which means that a
01:46 - set is one way that you can group a
01:49 - whole bunch of like objects together and
01:51 - handle them as one unit so for example
01:53 - you can add items to a set you can see
01:56 - if a set contains an item and you can
01:58 - remove things from the set and it all
01:59 - works very very similarly to how you
02:01 - might use something like an arraylist in
02:03 - Java so if you used a list or an array
02:06 - list in Java then you're in luck this
02:08 - will be very familiar to you however
02:10 - sets do have some subtle differences
02:13 - from lists and those differences really
02:15 - are important because you'll end up
02:17 - using sets to solve completely different
02:19 - problems than you would want to solve
02:21 - with a list so first let's just go about
02:23 - actually creating a set so let's say we
02:26 - wanted to create a variable that holds
02:29 - like a collection of string names for
02:31 - example a set is one way that you can do
02:33 - that so if you wanted to create a set of
02:36 - strings you would say set and then in
02:38 - angle brackets here you have to tell it
02:40 - what type what class of things are going
02:44 - to be held as the elements of this set
02:46 - and here since we want it to be a set of
02:49 - names it makes sense to make them
02:51 - strings and then you can see that it
02:53 - automatically imported
02:55 - java.util.set so that's the import
02:57 - you'll want for set and then like any
02:59 - variable we have to give this a name
03:01 - since this will be a set that's supposed
03:03 - to hold names we'll call it names so now
03:06 - we've created this names variable for
03:08 - our set so now we have to initialize it
03:10 - now you might think that to instantiate
03:12 - your set you would just say equals new
03:14 - set right I mean that seems to make
03:16 - sense it's how you create the vast
03:18 - majority of your other objects in Java
03:20 - but if you try that you'll see that you
03:22 - get a compilation error and it says set
03:24 - is abstract and cannot be initialized
03:27 - this is a part that can be confusing to
03:29 - a lot of programmers so let's talk a
03:31 - little bit about what's going on here
03:32 - the reason we get this error is because
03:34 - a set is an interface and not a normal
03:38 - class like if we control click into this
03:41 - set we can see that it says public
03:43 - interface set not public class set and
03:47 - you can't create instances of interfaces
03:50 - you can only create instances of classes
03:54 - that Implement those interfaces now that
03:57 - is where hash sets come in so instead of
04:01 - saying equals new set instead we'll say
04:04 - equals new hash set and we'll go ahead
04:06 - and put in our Diamond operator here to
04:09 - make the compiler happy now if we
04:10 - control click into hash set here and
04:13 - scroll up we can see that hash set
04:16 - implements the set interface so
04:19 - basically how it works is the set
04:21 - interface is where Java says any kind of
04:24 - class that wants to be a set has to
04:26 - support all of these kinds of operations
04:29 - and methods like adding items removing
04:32 - them looking them up Etc it's totally up
04:35 - to each individual kind of set to
04:37 - determine how it wants to implement all
04:40 - of those functionalities behind the
04:43 - scenes the hash set here is one of those
04:46 - actual set implementations so you might
04:49 - think hey if a hash set is just one
04:51 - implementation of a set in Java are
04:55 - there any others available to me and the
04:57 - answer is of course yes there are we
04:58 - will talk about those just a little bit
05:00 - but hash set is the set implementation
05:02 - that you are probably going to use 99
05:05 - plus percent of the time you ever use a
05:08 - set so that's definitely going to be the
05:10 - one that we focus on here all right so
05:13 - now we've got our shiny new hash sets
05:15 - all declared and initialized let's give
05:18 - it a ride and see what we can do with it
05:19 - again if you have used lists before in
05:22 - your Java programs a lot of this is
05:23 - going to look very familiar which is
05:25 - great first let's go ahead and add some
05:27 - objects to our set and you do that by
05:29 - calling the add method so we'll just
05:31 - call names dot add and then we pass into
05:33 - this add method whatever we want to add
05:36 - to our set this is a set of string names
05:39 - let's add a name Walter now what we can
05:42 - do real quick here is go ahead and print
05:44 - out our set just to make sure it's
05:46 - adding this name correctly and to do
05:48 - that we can just do system.out.printline
05:50 - and print out our names set now if we go
05:54 - ahead and run our program we can see
05:56 - that it prints out the contents of our
05:58 - set which right now now is just one
06:00 - thing the name Walter now let's go ahead
06:02 - and add a few more names to our list
06:04 - names dot add Jesse Schuyler Mike
06:09 - Saul let's go ahead and run it again and
06:12 - make sure it now prints out all of these
06:14 - names and there we go we have Walter
06:16 - Mike Saul Skyler and Jesse now you might
06:19 - have noticed here that it printed out
06:21 - these names in a very different order
06:24 - than they were added that's different
06:26 - from how something like a list operates
06:28 - which always maintains a certain order
06:31 - so that's the first of the important
06:33 - differences between lists and hash sets
06:36 - in Java a list maintains the order that
06:39 - you add the elements to that list and
06:41 - you can also do various things to sort a
06:44 - list in whichever order that you want
06:46 - but a hash set has no particular order
06:49 - so there are absolutely zero guarantees
06:52 - as to what order the objects will be in
06:55 - your set after you add them now though
06:58 - let's talk about the second big
07:00 - difference between lists and sets let's
07:02 - say I wanted to add something to this
07:04 - set that already existed in the set so
07:06 - I'll try and add Walter again now if we
07:09 - go go ahead and run our code to print
07:11 - out our set again you can see that
07:13 - Walter exists in the set but it still
07:15 - only exists once even though we added it
07:18 - twice and that is because sets by Design
07:21 - do not allow duplicates so if I wanted I
07:25 - could add Walter to this set just
07:27 - hundreds and hundreds of times it still
07:30 - only gets added to the set once so now
07:33 - let's get rid of all these extra Walters
07:36 - one is quite enough next though to
07:39 - remove things from a set is pretty much
07:41 - exactly the same as removing an object
07:43 - from a list all you do is call names dot
07:46 - remove and then pass in the object that
07:49 - you want to remove from your set so
07:50 - let's say we wanted to remove Walter
07:53 - we'll run our program and see that
07:55 - Walter has been removed however one
07:57 - thing that you can do with a list that
08:00 - you can't do with a set is remove an
08:02 - item by using its index but that can be
08:05 - a bit deceiving and let me show you why
08:07 - so for example if you wanted to remove
08:08 - the very first thing from the list you
08:11 - would just pass in the index 0 because 0
08:13 - is the first thing in your list so you
08:16 - might notice we don't get any
08:17 - compilation errors or anything and we
08:19 - can even go ahead and run it without any
08:21 - errors however if we look at this we can
08:24 - see that nothing at all was removed we
08:26 - still have all five items in our set
08:28 - well what happened is for a list there's
08:31 - actually a separate remove method that
08:34 - takes the int index of the element that
08:38 - you want to remove but for hash sets
08:40 - that's separate remove method that takes
08:42 - an INT index doesn't actually exist and
08:45 - that kind of makes sense right because
08:46 - the elements of a hash set are in no
08:49 - particular order anyway so if you said
08:51 - okay remove the zeroth element from my
08:54 - hash set it's pretty much unpredictable
08:56 - which element of the set it's actually
08:58 - going to remove so what it's actually
09:00 - doing is just calling the version of the
09:01 - remove method that takes in the actual
09:04 - element that you want to remove from the
09:06 - set and of course the element zero
09:09 - doesn't appear anywhere in our set of
09:12 - strings so nothing is removed so even
09:14 - though there are no errors and it might
09:16 - look like it might be working it's
09:17 - probably not actually doing what you
09:19 - expected at all now there are a bunch of
09:21 - other methods available to you on sets
09:23 - as well for example you can get the
09:24 - current size of your set just by calling
09:27 - names dot size now there are five things
09:29 - in our list so when we run it it should
09:31 - print out five you can also use the dot
09:34 - contains method which will return a
09:36 - Boolean true or false depending on if
09:39 - your set contains the object that you
09:41 - pass in so if we say hey does my set
09:44 - contain saw it will say true it does
09:47 - contain Saul but if I want to see if it
09:49 - contains Gus it will return false
09:52 - there's also a method available called
09:54 - is empty which will tell you whether or
09:57 - not your set is empty and right now it
09:59 - will tell me false because my set's not
10:01 - empty next if you just want to get rid
10:04 - of all the elements in your set you
10:06 - don't need to individually remove them
10:07 - all one by one instead you can just call
10:10 - names dot clear and then if we go ahead
10:13 - and print out our names set one more
10:16 - time we can see that it now contains
10:18 - zero elements it's been cleared you'll
10:21 - probably pretty often run into some
10:23 - situations where you want to perform
10:25 - some kind of action on all the elements
10:28 - of your set so you might want to iterate
10:30 - through your set and print them all out
10:32 - add them all to a file something like
10:34 - that there are a few different ways that
10:36 - you can do that with sets one way is
10:38 - using what's called an enhanced for Loop
10:41 - now to do that I can say four and then I
10:44 - want to Loop through each element each
10:46 - string inside my names set so here I say
10:51 - okay for each string name inside my set
10:55 - of names I want to do the following so
10:59 - if I want to just print out each name
11:00 - here I would just say
11:02 - system.out.printline and print the name
11:05 - so what this should do when I run it is
11:07 - just print out every name in in the set
11:09 - on its own line and we can see that
11:12 - that's exactly what it does now one
11:14 - thing to remember here though is that
11:15 - since your hash set is in no particular
11:17 - order at all it could iterate through
11:20 - your hash set in basically any order
11:22 - however if you want to be really really
11:25 - cool and impress all your super nerdy
11:27 - Java programmer friends if you know how
11:30 - to use lambdas you can use a Lambda to
11:32 - iterate through your set now I have an
11:34 - entire other video on lambdas which you
11:36 - can find right here if you haven't seen
11:37 - it but to just do it real quickly here
11:39 - let's say I wanted to go through my
11:41 - names set and for each element in my set
11:46 - I wanted to print it out well I can just
11:48 - call this for each method on my set and
11:51 - then just pass in the Lambda the
11:54 - function that I wanted to execute for
11:57 - each element of my set so if I want to
11:59 - just print each element out I can just
12:01 - say system dot out colon colon print
12:05 - line it prints out all five elements of
12:08 - my set just the same but does it in a
12:10 - very impressive one line now you can
12:13 - also use
12:14 - names.iterator to give you an iterator
12:16 - object that you can use to iterate
12:19 - through your set and this iterator will
12:20 - work exactly the same way that it does
12:22 - for lists and other pieces of the Java
12:25 - Collections framework so we'll declare
12:26 - our iterator object it'll be an iterator
12:29 - of strings because our set is a set of
12:31 - strings we'll give it a name let's call
12:33 - it names iterator and set that equal to
12:38 - names.iterator now to use this to
12:40 - iterate over our set we will use a while
12:43 - loop so while names iterator has a next
12:48 - item has next so while there are more
12:50 - things and are set to iterate over we'll
12:52 - go ahead and print out names iterator
12:55 - dot next let's go ahead and get rid of
12:59 - this for each implementation just to
13:01 - make sure our iterator implementation
13:02 - works how we expect and there we go we
13:05 - got Walter Mikes all Skyler and Jesse
13:08 - looks good maybe a big question that you
13:10 - might have is all right when would I
13:13 - actually want to use this under what
13:14 - programming situation is a set or a hash
13:17 - set in particular useful now the simple
13:20 - answer to that is well whenever you want
13:23 - a collection of items and you don't want
13:26 - duplicates in that collection and you
13:28 - don't particularly care which order that
13:30 - they're in and of course that kind of
13:32 - varies depending on your particular
13:35 - programming needs for whatever you're
13:37 - working on but one area that you'll see
13:39 - sets used a whole lot is for something
13:41 - as simple as removing duplicate items
13:44 - from a list let's say you have some list
13:47 - that potentially contains a bunch of
13:49 - duplicates that you want to get rid of
13:51 - now you could write some kind of clever
13:53 - program to kind of iterate through that
13:55 - list a whole bunch of times and you know
13:57 - comparing each element to every other
13:58 - element to see if it contains a
14:00 - duplicate and remove them so it only
14:02 - contains one of each element when it's
14:04 - finished but a way way easier way of
14:07 - doing that is take all the elements of
14:09 - that list and dump them into a set and
14:13 - since a set cannot contain any
14:15 - duplicates when it tries to add a
14:17 - duplicate to that set it just won't
14:18 - happen and your resulting set will be
14:21 - the same as the list that you started
14:23 - out with but just with no duplicates now
14:25 - let me show you real quick exactly how
14:27 - to do that let's say we had some list
14:29 - how about a list of integers in this
14:31 - case we'll just call it number list
14:34 - equals new array list so now let's go
14:37 - ahead and add some things to our number
14:39 - list so numberless dot add one two three
14:43 - and now we're going to go ahead and add
14:45 - some duplicates so we're going to go
14:47 - ahead and add 2 again and then let's
14:51 - just go ahead and add one again so now
14:53 - if we print out our list number list we
14:57 - see that we definitely have some
14:58 - duplicates we have one two three two one
15:00 - so now if I want to get rid of all the
15:02 - duplicates from this list I can just add
15:05 - all those elements to a set so let's go
15:08 - ahead and create our are set it'll be a
15:10 - set of integers we'll call it number set
15:13 - equals new hash set so now what we can
15:17 - call is number set dot add all and then
15:22 - pass in our number list so this add all
15:26 - is another one of the really cool
15:27 - methods available to you with sets that
15:29 - allows you to take basically any
15:31 - collection and add all of its elements
15:33 - to another collection that's pretty much
15:35 - it what we should be able to do is print
15:38 - out our number set and our resulting set
15:41 - should now have those same numbers but
15:44 - just with no duplicates and it does so
15:46 - the list had one two three two one but
15:50 - putting all those items into a set
15:52 - automatically and very very easily
15:54 - removed all the duplicates so we're just
15:56 - left with one two three and you can do
15:59 - this in an even cooler way if you want
16:01 - you can see that I'm getting a little
16:02 - warning here that says hey add all can
16:04 - be replaced with a parameterized
16:06 - Constructor call and basically what it's
16:08 - saying is hey you you could yes you
16:11 - could do this and say okay number set
16:13 - dot add all and then pass in your list
16:16 - but instead what you can do is just pass
16:18 - in the number list to the actual hash
16:22 - set Constructor in the first place and
16:24 - you don't even need to call that add all
16:26 - method and it turns out that it will do
16:28 - exactly the same thing now though I want
16:31 - to give you just a little bit of insight
16:32 - into why this is called a hash set so
16:36 - the reason it's called a hash set is
16:38 - because this set implementation actually
16:41 - uses a hash table as its storage
16:44 - mechanism behind the scenes now how a
16:47 - hash table actually works is a bit
16:50 - outside the scope of this video but what
16:52 - using a hash table does is it allows for
16:55 - extremely fast operations on this set
16:58 - for most types of elements if they're
17:01 - constructed properly that allows for
17:03 - what is called constant time ads removes
17:07 - and lookups so what that actually means
17:09 - is no matter how large your hash table
17:12 - gets if it's very small or if it's very
17:15 - large adding another element to that set
17:18 - or removing an element from that set or
17:20 - checking to see if a given element
17:22 - exists in that huge set we'll always
17:25 - take the same amount of time it'll take
17:27 - a constant amount of time no matter how
17:30 - big or small your hash set is now that's
17:33 - compared to something like a list where
17:35 - the larger that your list gets the more
17:37 - expensive each ad remove and lookup
17:40 - operation on that list is now I did
17:42 - mention earlier that there were two
17:44 - other set implementations in Java
17:47 - besides hash set so let's talk about
17:49 - those a little bit now one of the other
17:51 - implementations is called a tree set now
17:54 - if you end up using a tree set instead
17:55 - of a hash set all the methods that we
17:58 - already went over work exactly the same
18:00 - way there's there's really no difference
18:02 - there now what a tree set offers that a
18:04 - hash set doesn't is that the elements
18:06 - that you put into that set will be
18:08 - ordered with what's called their natural
18:10 - ordering so for example in our original
18:13 - set our set of names here if I
18:16 - implemented that as a tree set instead
18:18 - of a hash set let's go ahead and run it
18:21 - and then see what the output looks like
18:23 - there okay so if I look at how it's
18:25 - printed I can see that they're not
18:27 - printed out in the order that I added
18:30 - them to the set but they are printed out
18:32 - in their natural ordering in this case
18:34 - since they're strings they're printed
18:36 - out in alphabetical order and that's
18:38 - because behind the scenes this is using
18:40 - a tree instead of a hash map as its
18:43 - implementation of the set so as things
18:45 - are added to that tree they're put into
18:47 - that tree in the correct ordering now
18:50 - that seems pretty cool right so hey why
18:52 - would I use a hash set ever if it does
18:54 - you know all the same things but a tree
18:57 - set I could get some ordering out of it
18:59 - why would I ever want to use a hash set
19:00 - and the answer is that a hash that is
19:04 - way way faster than a tree set so you
19:07 - should only use a tree reset when you're
19:10 - in a situation that you want to set but
19:12 - you really care about the ordering of
19:14 - the elements but if you have no need to
19:16 - maintain that ordering at all it's way
19:19 - better to use a hash set in your program
19:21 - instead just because it's so much faster
19:23 - now the last set implementation is
19:26 - actually called linked hash set so
19:29 - what's different about a linked hash set
19:31 - is that it doesn't maintain the natural
19:33 - ordering of the elements but what it
19:35 - does maintain is the insertion order of
19:38 - your elements so what that means is if I
19:40 - go ahead and run this I can see that it
19:43 - prints out these items in the exact same
19:47 - order that they were added to my set now
19:50 - as far as performance goes a linked hash
19:53 - that is almost as fast as a hash set it
19:55 - isn't quite as fast as a hash set but
19:58 - it's it's way better than a tree set is
20:00 - as far as performance so still you
20:02 - should only use a linked hash set if you
20:04 - care about maintaining that insertion
20:07 - ordering but if you don't care about
20:08 - that it's still in your best interest to
20:11 - use hash sets and you'll probably see
20:13 - hash sets used way more often in the
20:16 - real world than you will tree sets or
20:18 - linked hash sets but it's still good to
20:20 - know that they exist in case you need
20:22 - that kind of functionality for the
20:24 - program that you're working on if you
20:26 - enjoyed this video or learned something
20:27 - please let me know by leaving a like and
20:29 - let me know what other kinds of videos
20:31 - you'd like to see in the future in the
20:32 - comments as always really thank you so
20:34 - much for watching I really do appreciate
20:36 - each and every one of you taking the
20:38 - time out of your day to spend some time
20:39 - with me so I will see you next time

Cleaned transcript:

what exactly are sets and hash sets in Java we'll talk about exactly what these are and how you can use them and we'll also talk about the situations where sets and hash sets are the perfect solution to your program as always my full Java course is available in the link down in the description if you're interested first thanks to mailgun for sponsoring this video mailgun is how modern companies work with email mailgun is easy to use has amazing worldclass customer support and simple but powerful apis that smart developers can use to reach customers at scale so their organizations can grow faster with their detailed documentation you can easily integrate email into any application with just a few lines of code you can send and track transactional and marketing messages remove invalid emails from your list or just prevent fake signups in the first place easily their team of experts is available 24 7 to help you improve your email deliverability and drive higher conversion rates with its powerful email API for developers and intuitive email Marketing Solutions mailgun Works through the entire email lifecycle from plan all the way to the Inbox and it does that for more than 240 billion emails a year for top companies like Wikipedia DHL toast Lyft and Microsoft melgun also has an amazing send time optimization feature which automatically finds the perfect time to send the email to each and every individual on their list at the exact time that they're most likely to engage mailgun truly makes it easier than ever to build connected experiences through email so thanks again to mailgun for sponsoring this video try mailgun today for free by using my link which you can find down in the description mailgun.com John now let's get right to it alright so sets and hash sets well first just what exactly is a set well a set is one of the things available to you in Java's collections framework which means that a set is one way that you can group a whole bunch of like objects together and handle them as one unit so for example you can add items to a set you can see if a set contains an item and you can remove things from the set and it all works very very similarly to how you might use something like an arraylist in Java so if you used a list or an array list in Java then you're in luck this will be very familiar to you however sets do have some subtle differences from lists and those differences really are important because you'll end up using sets to solve completely different problems than you would want to solve with a list so first let's just go about actually creating a set so let's say we wanted to create a variable that holds like a collection of string names for example a set is one way that you can do that so if you wanted to create a set of strings you would say set and then in angle brackets here you have to tell it what type what class of things are going to be held as the elements of this set and here since we want it to be a set of names it makes sense to make them strings and then you can see that it automatically imported java.util.set so that's the import you'll want for set and then like any variable we have to give this a name since this will be a set that's supposed to hold names we'll call it names so now we've created this names variable for our set so now we have to initialize it now you might think that to instantiate your set you would just say equals new set right I mean that seems to make sense it's how you create the vast majority of your other objects in Java but if you try that you'll see that you get a compilation error and it says set is abstract and cannot be initialized this is a part that can be confusing to a lot of programmers so let's talk a little bit about what's going on here the reason we get this error is because a set is an interface and not a normal class like if we control click into this set we can see that it says public interface set not public class set and you can't create instances of interfaces you can only create instances of classes that Implement those interfaces now that is where hash sets come in so instead of saying equals new set instead we'll say equals new hash set and we'll go ahead and put in our Diamond operator here to make the compiler happy now if we control click into hash set here and scroll up we can see that hash set implements the set interface so basically how it works is the set interface is where Java says any kind of class that wants to be a set has to support all of these kinds of operations and methods like adding items removing them looking them up Etc it's totally up to each individual kind of set to determine how it wants to implement all of those functionalities behind the scenes the hash set here is one of those actual set implementations so you might think hey if a hash set is just one implementation of a set in Java are there any others available to me and the answer is of course yes there are we will talk about those just a little bit but hash set is the set implementation that you are probably going to use 99 plus percent of the time you ever use a set so that's definitely going to be the one that we focus on here all right so now we've got our shiny new hash sets all declared and initialized let's give it a ride and see what we can do with it again if you have used lists before in your Java programs a lot of this is going to look very familiar which is great first let's go ahead and add some objects to our set and you do that by calling the add method so we'll just call names dot add and then we pass into this add method whatever we want to add to our set this is a set of string names let's add a name Walter now what we can do real quick here is go ahead and print out our set just to make sure it's adding this name correctly and to do that we can just do system.out.printline and print out our names set now if we go ahead and run our program we can see that it prints out the contents of our set which right now now is just one thing the name Walter now let's go ahead and add a few more names to our list names dot add Jesse Schuyler Mike Saul let's go ahead and run it again and make sure it now prints out all of these names and there we go we have Walter Mike Saul Skyler and Jesse now you might have noticed here that it printed out these names in a very different order than they were added that's different from how something like a list operates which always maintains a certain order so that's the first of the important differences between lists and hash sets in Java a list maintains the order that you add the elements to that list and you can also do various things to sort a list in whichever order that you want but a hash set has no particular order so there are absolutely zero guarantees as to what order the objects will be in your set after you add them now though let's talk about the second big difference between lists and sets let's say I wanted to add something to this set that already existed in the set so I'll try and add Walter again now if we go go ahead and run our code to print out our set again you can see that Walter exists in the set but it still only exists once even though we added it twice and that is because sets by Design do not allow duplicates so if I wanted I could add Walter to this set just hundreds and hundreds of times it still only gets added to the set once so now let's get rid of all these extra Walters one is quite enough next though to remove things from a set is pretty much exactly the same as removing an object from a list all you do is call names dot remove and then pass in the object that you want to remove from your set so let's say we wanted to remove Walter we'll run our program and see that Walter has been removed however one thing that you can do with a list that you can't do with a set is remove an item by using its index but that can be a bit deceiving and let me show you why so for example if you wanted to remove the very first thing from the list you would just pass in the index 0 because 0 is the first thing in your list so you might notice we don't get any compilation errors or anything and we can even go ahead and run it without any errors however if we look at this we can see that nothing at all was removed we still have all five items in our set well what happened is for a list there's actually a separate remove method that takes the int index of the element that you want to remove but for hash sets that's separate remove method that takes an INT index doesn't actually exist and that kind of makes sense right because the elements of a hash set are in no particular order anyway so if you said okay remove the zeroth element from my hash set it's pretty much unpredictable which element of the set it's actually going to remove so what it's actually doing is just calling the version of the remove method that takes in the actual element that you want to remove from the set and of course the element zero doesn't appear anywhere in our set of strings so nothing is removed so even though there are no errors and it might look like it might be working it's probably not actually doing what you expected at all now there are a bunch of other methods available to you on sets as well for example you can get the current size of your set just by calling names dot size now there are five things in our list so when we run it it should print out five you can also use the dot contains method which will return a Boolean true or false depending on if your set contains the object that you pass in so if we say hey does my set contain saw it will say true it does contain Saul but if I want to see if it contains Gus it will return false there's also a method available called is empty which will tell you whether or not your set is empty and right now it will tell me false because my set's not empty next if you just want to get rid of all the elements in your set you don't need to individually remove them all one by one instead you can just call names dot clear and then if we go ahead and print out our names set one more time we can see that it now contains zero elements it's been cleared you'll probably pretty often run into some situations where you want to perform some kind of action on all the elements of your set so you might want to iterate through your set and print them all out add them all to a file something like that there are a few different ways that you can do that with sets one way is using what's called an enhanced for Loop now to do that I can say four and then I want to Loop through each element each string inside my names set so here I say okay for each string name inside my set of names I want to do the following so if I want to just print out each name here I would just say system.out.printline and print the name so what this should do when I run it is just print out every name in in the set on its own line and we can see that that's exactly what it does now one thing to remember here though is that since your hash set is in no particular order at all it could iterate through your hash set in basically any order however if you want to be really really cool and impress all your super nerdy Java programmer friends if you know how to use lambdas you can use a Lambda to iterate through your set now I have an entire other video on lambdas which you can find right here if you haven't seen it but to just do it real quickly here let's say I wanted to go through my names set and for each element in my set I wanted to print it out well I can just call this for each method on my set and then just pass in the Lambda the function that I wanted to execute for each element of my set so if I want to just print each element out I can just say system dot out colon colon print line it prints out all five elements of my set just the same but does it in a very impressive one line now you can also use names.iterator to give you an iterator object that you can use to iterate through your set and this iterator will work exactly the same way that it does for lists and other pieces of the Java Collections framework so we'll declare our iterator object it'll be an iterator of strings because our set is a set of strings we'll give it a name let's call it names iterator and set that equal to names.iterator now to use this to iterate over our set we will use a while loop so while names iterator has a next item has next so while there are more things and are set to iterate over we'll go ahead and print out names iterator dot next let's go ahead and get rid of this for each implementation just to make sure our iterator implementation works how we expect and there we go we got Walter Mikes all Skyler and Jesse looks good maybe a big question that you might have is all right when would I actually want to use this under what programming situation is a set or a hash set in particular useful now the simple answer to that is well whenever you want a collection of items and you don't want duplicates in that collection and you don't particularly care which order that they're in and of course that kind of varies depending on your particular programming needs for whatever you're working on but one area that you'll see sets used a whole lot is for something as simple as removing duplicate items from a list let's say you have some list that potentially contains a bunch of duplicates that you want to get rid of now you could write some kind of clever program to kind of iterate through that list a whole bunch of times and you know comparing each element to every other element to see if it contains a duplicate and remove them so it only contains one of each element when it's finished but a way way easier way of doing that is take all the elements of that list and dump them into a set and since a set cannot contain any duplicates when it tries to add a duplicate to that set it just won't happen and your resulting set will be the same as the list that you started out with but just with no duplicates now let me show you real quick exactly how to do that let's say we had some list how about a list of integers in this case we'll just call it number list equals new array list so now let's go ahead and add some things to our number list so numberless dot add one two three and now we're going to go ahead and add some duplicates so we're going to go ahead and add 2 again and then let's just go ahead and add one again so now if we print out our list number list we see that we definitely have some duplicates we have one two three two one so now if I want to get rid of all the duplicates from this list I can just add all those elements to a set so let's go ahead and create our are set it'll be a set of integers we'll call it number set equals new hash set so now what we can call is number set dot add all and then pass in our number list so this add all is another one of the really cool methods available to you with sets that allows you to take basically any collection and add all of its elements to another collection that's pretty much it what we should be able to do is print out our number set and our resulting set should now have those same numbers but just with no duplicates and it does so the list had one two three two one but putting all those items into a set automatically and very very easily removed all the duplicates so we're just left with one two three and you can do this in an even cooler way if you want you can see that I'm getting a little warning here that says hey add all can be replaced with a parameterized Constructor call and basically what it's saying is hey you you could yes you could do this and say okay number set dot add all and then pass in your list but instead what you can do is just pass in the number list to the actual hash set Constructor in the first place and you don't even need to call that add all method and it turns out that it will do exactly the same thing now though I want to give you just a little bit of insight into why this is called a hash set so the reason it's called a hash set is because this set implementation actually uses a hash table as its storage mechanism behind the scenes now how a hash table actually works is a bit outside the scope of this video but what using a hash table does is it allows for extremely fast operations on this set for most types of elements if they're constructed properly that allows for what is called constant time ads removes and lookups so what that actually means is no matter how large your hash table gets if it's very small or if it's very large adding another element to that set or removing an element from that set or checking to see if a given element exists in that huge set we'll always take the same amount of time it'll take a constant amount of time no matter how big or small your hash set is now that's compared to something like a list where the larger that your list gets the more expensive each ad remove and lookup operation on that list is now I did mention earlier that there were two other set implementations in Java besides hash set so let's talk about those a little bit now one of the other implementations is called a tree set now if you end up using a tree set instead of a hash set all the methods that we already went over work exactly the same way there's there's really no difference there now what a tree set offers that a hash set doesn't is that the elements that you put into that set will be ordered with what's called their natural ordering so for example in our original set our set of names here if I implemented that as a tree set instead of a hash set let's go ahead and run it and then see what the output looks like there okay so if I look at how it's printed I can see that they're not printed out in the order that I added them to the set but they are printed out in their natural ordering in this case since they're strings they're printed out in alphabetical order and that's because behind the scenes this is using a tree instead of a hash map as its implementation of the set so as things are added to that tree they're put into that tree in the correct ordering now that seems pretty cool right so hey why would I use a hash set ever if it does you know all the same things but a tree set I could get some ordering out of it why would I ever want to use a hash set and the answer is that a hash that is way way faster than a tree set so you should only use a tree reset when you're in a situation that you want to set but you really care about the ordering of the elements but if you have no need to maintain that ordering at all it's way better to use a hash set in your program instead just because it's so much faster now the last set implementation is actually called linked hash set so what's different about a linked hash set is that it doesn't maintain the natural ordering of the elements but what it does maintain is the insertion order of your elements so what that means is if I go ahead and run this I can see that it prints out these items in the exact same order that they were added to my set now as far as performance goes a linked hash that is almost as fast as a hash set it isn't quite as fast as a hash set but it's it's way better than a tree set is as far as performance so still you should only use a linked hash set if you care about maintaining that insertion ordering but if you don't care about that it's still in your best interest to use hash sets and you'll probably see hash sets used way more often in the real world than you will tree sets or linked hash sets but it's still good to know that they exist in case you need that kind of functionality for the program that you're working on if you enjoyed this video or learned something please let me know by leaving a like and let me know what other kinds of videos you'd like to see in the future in the comments as always really thank you so much for watching I really do appreciate each and every one of you taking the time out of your day to spend some time with me so I will see you next time
