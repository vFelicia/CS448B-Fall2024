With timestamps:

00:01 - hey everybody how's it going in this
00:02 - video we are going to create a program
00:04 - in java that can take a pool of
00:06 - letters like this and print out all the
00:09 - possible
00:09 - english words that can be made out of
00:11 - those letters so this can be used to
00:13 - solve like scrabble games words with
00:15 - friends
00:15 - any of those sorts of word scramble
00:17 - games we're gonna start from scratch
00:18 - program the whole thing beginning to end
00:20 - right here in this video so you'll see
00:21 - exactly how it's done if this is your
00:22 - first time on the channel my name is
00:24 - john and i make a java tutorial video
00:25 - like this one every single week
00:27 - so be sure to hit the subscribe button
00:28 - so you don't miss one and before we get
00:30 - started the full source code for this
00:32 - whole program is available in the link
00:33 - down in the description so
00:34 - go and get it okay so in this program we
00:36 - are going to have to of course take in a
00:38 - bunch of letters from the user via the
00:39 - keyboard
00:40 - and we're going to see what english
00:42 - words we can make out of those letters
00:44 - so of course in order to do that we're
00:45 - going to need like a dictionary file a
00:47 - list of
00:48 - a bunch of valid english words so i
00:50 - found one that i really liked
00:51 - and it's available in a link down in the
00:53 - description as well so go grab that but
00:55 - any dictionary file that you find
00:57 - will work great you can use any one that
00:59 - you you find if you like better
01:00 - separately
01:01 - just make sure it has like one word per
01:04 - line that's like a dot
01:04 - txt file a text file just to make your
01:07 - life easier
01:08 - so go ahead and download that file and
01:09 - put it in a location where you know
01:10 - where it is on your computer
01:12 - now the first thing we're going to do is
01:13 - make sure we can read in that dictionary
01:15 - file we're going to use
01:16 - the buffered reader class in java to do
01:19 - that and so we'll call it
01:20 - reader buffered reader reader equals new
01:24 - buffered reader and that buffered reader
01:26 - constructor takes a parameter and we
01:28 - need to tell that what we want it to
01:30 - read
01:30 - and for our purposes we're going to have
01:32 - it read a file
01:33 - so we actually have to pass in a new
01:36 - file reader
01:37 - and to create a file reader it takes the
01:39 - location of our text file so just go
01:41 - ahead and paste in
01:42 - the exact location on your computer of
01:44 - that text file but just pass in wherever
01:46 - you happen to put it on your computer so
01:48 - i know you guys are smart i know you
01:49 - know how to do that
01:50 - and we're working with eclipse so i can
01:51 - hit ctrl shift o
01:53 - to automatically organize my imports and
01:55 - you can see we have an import of
01:56 - java.io.bufferedreader and
01:58 - java.io.filereader so if you're working
02:00 - with some other kind of tool that
02:01 - doesn't automatically do the imports for
02:02 - you that's what they are and we also see
02:04 - that eclipse is complaining here that
02:06 - we have an unhandled type file not found
02:08 - exception
02:09 - and we probably won't do any fancy
02:10 - handling of that here if we can't read
02:11 - the file our program can't work so we'll
02:13 - just go ahead and say
02:14 - add a throws declaration here
02:17 - just add a throw file not found
02:19 - exception here and now let's make sure
02:20 - we can go through and actually use this
02:22 - reader to read all the lines of our file
02:24 - and we'll just print them out for now to
02:25 - prove that we can read the file properly
02:27 - so to do that to go through every line
02:28 - of a file using a buffered reader like
02:30 - this
02:31 - you use a special kind of for loop so
02:34 - we'll say
02:34 - four um and the object we'll create in
02:37 - our for loop is a string we're going to
02:39 - take uh the word that's on every line
02:40 - and so we'll have a string let's just
02:42 - call it a
02:43 - current word uh that's going to
02:45 - represent the current line that we're on
02:47 - and we'll set it equal to
02:51 - reader.readline
02:52 - and you can see that the the javadocs of
02:55 - this method here says reads a line of
02:56 - text
02:57 - and so what that's going to do is read
02:58 - the very first line of code and put it
03:00 - in this current word variable
03:01 - and so next we need uh the condition for
03:03 - staying in the loop like we're going to
03:05 - stay in the loop
03:06 - while there's still more lines to be
03:08 - read and we'll know there's another line
03:09 - to be read
03:10 - if the current word that we've gotten
03:12 - isn't null so we can just say
03:14 - current word not equals null so if it
03:17 - ever reads a line
03:18 - into this current word variable and it
03:20 - turns out to be null that means there
03:21 - wasn't the line anymore to read so we've
03:23 - reached the end of the file and then we
03:24 - need
03:24 - our iterator so in the normal for loop
03:27 - it'd be like i plus plus but we're
03:28 - working with a file reader here not like
03:30 - a normal sort of array
03:31 - so what we want to do to increment here
03:33 - is we need to get
03:34 - the next line of the file so all we have
03:36 - to do is say current
03:38 - word equals reader
03:42 - dot readline so that's kind of a long
03:44 - for loop decoration so
03:46 - i'm going to zoom out a little bit so
03:48 - you can see the whole thing
03:49 - for string current word equals
03:52 - reader.readline so to start we're going
03:54 - to read the first
03:55 - line of the file and put it in this
03:56 - variable we're going to keep going
03:59 - while the current word is not equal to
04:00 - null and to get the next line to iterate
04:02 - each time through the loop we'll do
04:04 - another current word equals
04:05 - reader.readline
04:06 - and you can see the eclipse is
04:07 - complaining here about an unhandled io
04:09 - exception
04:10 - so we'll just do the same thing we did
04:11 - before and just go ahead and add that
04:13 - throws declaration
04:14 - and a little tip there the the file not
04:16 - found exception that we had before
04:18 - was actually a subtype of i o exception
04:20 - so if we just say throws i o exception
04:22 - it covers them both and you can get rid
04:23 - of this file not found exception
04:25 - import because we don't need it anymore
04:27 - so i'm going to zoom back in so you guys
04:28 - can see a little bit more easily
04:30 - for every iteration in this loop this
04:32 - current word variable
04:33 - should hold the current line that we're
04:35 - on the current word that we're iterating
04:36 - over
04:37 - let's just go ahead and print that out
04:39 - to the console and see if we can print
04:41 - out our whole dictionary file so
04:43 - system dot out dot print line current
04:46 - word
04:48 - okay let's run this and see what happens
04:52 - whoo sweet looking great we go all the
04:55 - way to
04:56 - zzz which is somehow a valid scrabble
04:58 - word but hey good to know all right so
05:00 - our file input is working
05:01 - splendidly so next thing we're going to
05:03 - do here is uh the keyboard input part
05:05 - where the user can type in the pool of
05:07 - letters that they're working with so if
05:08 - they're playing scrabble or words with
05:10 - friends or something it's the six or
05:11 - whatever letters that they have in their
05:12 - hand
05:13 - but our program will be able to take any
05:14 - number of letters you can type in one
05:16 - letter you can type in a thousand
05:17 - letters
05:18 - and it's still going to work and we're
05:19 - going to want to do this kind of at the
05:20 - top of our program before we start
05:22 - looping through all the possible words
05:23 - we're going to want to get that input
05:24 - from the user so to do that we're going
05:26 - to use the scanner class as we always do
05:28 - scanner scanner equals new scanner
05:31 - and pass in system.in for keyboard
05:35 - keyboard input from the user add the
05:37 - import java.util scanner to get that to
05:39 - work
05:40 - we're going to print something out to
05:41 - the user just to prompt them to enter
05:42 - their pool of letters
05:43 - sis out please
05:47 - enter the pool of letters and we're
05:49 - going to take that input as a string so
05:51 - string
05:52 - we'll just call it letters equals
05:56 - scanner.nextline that will get the next
05:58 - line of input that the user puts into
05:59 - the console hit enter it'll get all
06:01 - those letters
06:02 - put them in that string all right so you
06:03 - might be wondering and it's a very good
06:05 - question how are we actually going to do
06:07 - this how are we going to take this
06:08 - scrambled list of letters
06:10 - and see which of all these dictionary
06:12 - words can be made
06:14 - out of that pool of letters how are we
06:15 - going to do that that's a really good
06:16 - question so here's how i think
06:18 - we can do it so what if we go through uh
06:21 - the pool of letters that we have
06:23 - and just count up how many of each
06:25 - letter that we have available so let's
06:27 - say oh we go through this this whole
06:29 - string of letters and say okay there
06:31 - were two a's there were no b's
06:34 - there were uh there was one c and so
06:36 - when we're done looping through that
06:38 - the pool of letters we know how many of
06:41 - each letter are available and then we
06:42 - can
06:43 - loop through each word in our word list
06:46 - and
06:46 - make sure that we can make the current
06:48 - word with the pool of letters that we
06:50 - have available
06:51 - so as a quick example let's say that our
06:53 - pool of letters was this
06:54 - aabrt that's the pool of letters we have
06:56 - to make words from
06:57 - what we're going to do is look at this
06:59 - string and say how many of each letter
07:02 - do we have here okay we have
07:03 - for a's we have two of those for b's
07:07 - we have one of those for r's we also
07:10 - have one
07:10 - and for t's we also have one
07:14 - and for anything that isn't in this like
07:15 - map here any letter that doesn't exist
07:17 - we know that we have zero of those to
07:19 - work with and then we're going to go
07:20 - through
07:21 - each and every word in our dictionary
07:23 - list
07:24 - and make sure that we have all the
07:25 - letters available in our word list to
07:28 - make the current word we're looking at
07:29 - so let's just say our first word in the
07:30 - dictionary was like
07:32 - aardvark well our program will say well
07:34 - for a's we're going to need
07:36 - three of them we're going to need uh two
07:39 - r's et cetera down the line and make
07:42 - that full map for this word also and
07:43 - then go through and make sure we have
07:45 - all the letters we need so the program
07:46 - will say okay i need three a's do i have
07:48 - three a's
07:49 - and they'll say nope you don't you only
07:50 - have two and then it'll quit looking at
07:52 - that word
07:53 - and try the next one and then say maybe
07:54 - later on it encounters the word
07:56 - a bar on our word list and then it says
07:59 - okay
07:59 - for a's i'm going to need one of those
08:02 - for b's
08:03 - i'm going to need one of those and for
08:06 - ours i'll need one of those as well
08:08 - and it'll loop through each of these
08:09 - letters and say okay do i have one a
08:10 - available yes i've got two
08:12 - so that's great do i have one b
08:13 - available yes i do
08:15 - do i have one r available yes i do and
08:17 - once it gets through all those letters
08:19 - and confirms it has enough to make this
08:20 - word
08:21 - we will print this word out to the
08:22 - console as a valid word that can be made
08:25 - from our list of letters so i hope that
08:27 - makes sense if not just
08:28 - ruminate on it for a bit until it kind
08:30 - of sinks in because it's going to be
08:31 - important
08:32 - to how our program works so let's
08:34 - actually go ahead and just uh comment
08:35 - this out so we kind of have it
08:37 - available for you know a mental model as
08:39 - we work through this code now what we
08:41 - want to actually do next is create this
08:43 - mapping in our code and to create a
08:44 - mapping like this
08:45 - it's of course of a character to a
08:47 - number so we can have say we have
08:49 - uh two a's we have one b or we're
08:52 - actually going to use
08:53 - a map and it's going to look kind of
08:54 - exactly like that and we'll say it's a
08:56 - map of
08:57 - character to integer and we'll call that
09:00 - letters count map because it's going to
09:04 - be basically a map
09:05 - of the count of all the letters that we
09:07 - have in our letter string
09:08 - you say equals new hash map that's a
09:11 - perfectly good
09:12 - kind of map to use here okay ctrl shift
09:15 - o again to organize
09:16 - imports but if you again are not using
09:18 - an ide we need java util map and
09:20 - java.util.have
09:22 - so now comes the jerky part where we
09:23 - have to like loop through the
09:25 - the the string of letters that the user
09:28 - has passed in
09:29 - and count up how many of each letter
09:31 - that we have available that'll be kind
09:32 - of a classic kind of for loop we'll just
09:33 - say 4
09:34 - int i equals 0. you've probably done
09:37 - this before
09:38 - i less than we're going to go to the
09:40 - length of the letters input that we're
09:42 - getting so we'll just do letters
09:44 - dot length and then i
09:47 - plus plus to iterate and then for each
09:49 - iteration through the loop we want to
09:51 - grab
09:51 - the current character we're looking at
09:52 - so we just say char current
09:54 - char equals letters
09:58 - dot char at the current index
10:01 - of i so this is going to do so let's say
10:03 - this was our pool of letters aabrt
10:05 - the first time through this loop this
10:07 - current char is going to get
10:09 - the character at the zeroth position
10:13 - in our string which is going to be a so
10:15 - what we want to do here is
10:16 - is set the the right count for the
10:18 - current letter that we're looking at
10:20 - but it isn't necessarily the first time
10:22 - we're encountering this letter as we go
10:23 - through this for loop maybe we've got a
10:24 - huge list of characters and this is like
10:26 - the fifth
10:27 - a that we're seeing already we don't
10:28 - know so what we want to do is get the
10:30 - current count for that letter
10:32 - off of our map and we can do that by
10:34 - saying int count
10:36 - equals so what we want to do here
10:37 - because we don't know
10:39 - uh at what iteration in the loop we're
10:40 - working with we want to say if we
10:42 - already have a count for this letter on
10:44 - our map
10:45 - get it otherwise it'll be zero because
10:48 - we don't have that letter yet
10:49 - so here's what that looks like we're
10:50 - going to see if our letters
10:52 - count map contains
10:56 - the key of the current char
11:00 - so this is just a true or false value
11:02 - hey do i have this value on my map
11:04 - already do i already have an
11:05 - account for a for example on my map so
11:08 - we can say
11:08 - if we find that we have a current count
11:11 - for that letter
11:12 - we are going to get that current count
11:14 - so we'll just say letters
11:15 - count map dot get
11:19 - the current char so this will get us the
11:21 - count of that current character
11:23 - and otherwise if it didn't contain that
11:26 - key already we know that our count is
11:28 - zero so quick note here this is using
11:30 - what's called a ternary
11:32 - operator and if you haven't seen it
11:33 - before it might look kind of scary but
11:35 - it's really not
11:36 - terribly complex so this piece of code
11:38 - is saying if i already have a count for
11:40 - the current character i'm looking at
11:42 - let's say i want to know
11:43 - hey i need to add an a do we did we
11:45 - already add any a's before
11:46 - so if we already have a count for that
11:48 - letter then i want to get it from our
11:51 - map
11:51 - otherwise if we don't have a count then
11:53 - we know that it's zero and then right
11:55 - after that we
11:56 - want to set our current count to be one
11:58 - more than whatever the count was before
12:00 - and then after that we just need to add
12:02 - one to that
12:03 - character's count on the map so all that
12:05 - looks like is letters
12:07 - count map dot put so we're telling java
12:10 - hey put on my map
12:12 - that for this current character i'm
12:13 - looking at current char
12:15 - that i have one more
12:19 - than i did a second ago so let's walk
12:21 - through again exactly what this code is
12:22 - doing because this is the central part
12:24 - of this program
12:25 - let's say that again this is our pool of
12:26 - letters that we're looking through aabrt
12:29 - we're going to loop through each
12:32 - character
12:33 - in this string first character is a and
12:35 - for the first time through the loop our
12:37 - map is empty we haven't added any
12:39 - letters to it yet so it's going to try
12:40 - to get a count
12:41 - it says hey does my map contain this key
12:44 - yet for the letter a
12:45 - no it doesn't so it's not going to do
12:47 - this it's going to instead get
12:48 - 0 because this is the first time we are
12:50 - encountering the letter a
12:52 - in our string of letters so now we know
12:54 - that our current count is zero
12:56 - but we want to record what our new count
12:58 - is now that we have encountered
12:59 - one letter a so we're putting one new
13:02 - entry on our map here
13:03 - where our current character is the
13:05 - letter a and we're telling java
13:07 - we now have one a and now the second
13:10 - time through this loop
13:12 - it's picking up the second character in
13:14 - the string
13:15 - the second letter a that goes into this
13:17 - current char here and again we're asking
13:18 - java hey do we have
13:20 - this key and our map anywhere for this
13:22 - letter a
13:23 - and java says why yes we do we have one
13:25 - for the letter a we have already
13:26 - encountered one letter a
13:27 - and so we say great get that current
13:30 - count and so the number one
13:32 - gets filled into this count variable and
13:33 - now we put a new value
13:35 - for the letter a on the map by adding 1
13:38 - to that count
13:39 - and so it will put in that same spot a
13:42 - the value
13:43 - 2. that kind of makes sense so it'll
13:45 - loop through again and then encounter
13:46 - the value b
13:47 - and it's for the first time so it'll say
13:49 - okay now we've got one b
13:51 - and then on down the line it'll say we
13:52 - have one r and one t
13:54 - so at the end of looping through all of
13:56 - this pool of letters
13:57 - we're going to have a letters count map
13:59 - that looks like this all right so that's
14:00 - a complex part of our program
14:02 - but we're going to need to use this uh
14:04 - piece of code later
14:06 - when we want to get all the letter
14:08 - counts for
14:09 - all of our words in our dictionary so
14:11 - because we don't want to have to rewrite
14:13 - this so because we're going to have to
14:15 - reuse
14:16 - uh this piece of code let's go ahead and
14:18 - put it in its own method so we can call
14:20 - it whenever we need it
14:21 - so to do that pretty easily in eclipse
14:23 - you can highlight all the code that you
14:25 - want to go
14:26 - into the method and hit alt shift m and
14:29 - it'll bring up this little extract
14:30 - method dialog for you and you just name
14:32 - the method whatever you want so let's
14:33 - just call it get
14:35 - character count map so we hit enter
14:38 - there
14:38 - so now it's created our method for us
14:40 - get character count map
14:42 - and it's going to take in a string of
14:43 - letters and we actually want it to
14:45 - return this letters count map which it's
14:47 - not doing right now it just made it a
14:48 - void for some reason
14:50 - so we instead want it to return this
14:53 - value a map of character to integer so
14:55 - let's
14:55 - change our return type to that and then
14:58 - at the end of our for loop all we have
14:59 - to do is actually return
15:01 - our letters count map okay all right so
15:04 - let's scroll back up here and notice uh
15:05 - we're just calling this method here and
15:07 - we're not actually
15:07 - storing uh the the map anywhere so so
15:11 - let's go ahead and still
15:12 - just grab this declaration so that we
15:14 - can set
15:16 - the result of this mapping to a variable
15:18 - that we can use
15:19 - so now after we call that fancy method
15:21 - that we just made our letters count map
15:23 - will have a mapping of every character
15:26 - that we had in that string
15:27 - and the number of times we had each of
15:29 - those characters and actually before i
15:31 - forget
15:32 - the more eagle-eyed of you may have
15:33 - noticed that in my dictionary file here
15:35 - all of my
15:36 - words are in uppercase but perhaps our
15:38 - user types something in lower case
15:40 - we don't want it to just break we want
15:42 - it to act correctly when that happens
15:44 - so what we can do is just take what they
15:46 - type in in the scanner input
15:48 - and just call to uppercase on it and
15:51 - then that'll make everything they type
15:52 - in
15:53 - all caps no matter what they type in so
15:55 - it'll match our words easily later on
15:57 - okay so let's move our little map
15:58 - comment example down here to where we're
16:01 - going to have to write some more code
16:03 - just so we can see it kind of for
16:04 - reference for a mental reference
16:06 - all right now remember what we were
16:07 - doing we gathered the input from the
16:09 - user to get the pool of letters uh
16:11 - that we want to uh descramble and find
16:12 - all the words from and
16:14 - we grabbed our dictionary file and we've
16:16 - got code that currently
16:18 - loops through all of the words in that
16:20 - file so now instead of just printing out
16:22 - this current word we now need to have
16:24 - logic to see if the current word we're
16:26 - looking at can be made from the letters
16:28 - that we've got so the first thing we
16:29 - want to do
16:30 - is get the character count map just like
16:33 - we did for our pool of letters we want
16:35 - to get it for the current word that
16:36 - we're looking at in our dictionary file
16:38 - as we're looping through it and now that
16:39 - we've made it a standalone method
16:42 - it's very easy for us to do we don't
16:43 - have to write that complicated
16:45 - logic again we can just call it so we
16:47 - again need to make a map
16:49 - of character to integer
16:52 - call it current word map and set it
16:55 - equal to
16:57 - get the character account map of our
16:59 - current word
17:00 - and it's just that easy now we have that
17:02 - same complicated
17:03 - character count map on the current word
17:05 - we're looking at in the dictionary now
17:06 - what that has given us remember we are
17:08 - we are looping through
17:10 - every word in our dictionary file here
17:12 - let's say we were
17:13 - looping over the word bar at the current
17:15 - moment what this is going to give us
17:17 - this current word map will have a map
17:19 - that looks like this
17:20 - for the current word we have one a one b
17:22 - and one r now what we want to do
17:24 - is loop through all of the letters that
17:27 - we have in our map
17:29 - and make sure that our pool of letters
17:32 - has
17:32 - at least that many available for us to
17:34 - make this word
17:35 - okay so now let's write the loop that's
17:37 - going to loop through our current word
17:39 - map
17:39 - one that one looks like this and um
17:42 - and do that comparison to make sure we
17:44 - have all the letters that we need so to
17:45 - do that we can just say
17:46 - for character character
17:49 - in current word map
17:52 - dot key set so what does that mean the
17:55 - key set
17:55 - is the set of keys in a map so a map has
17:58 - a bunch of key value pairs so for this
18:00 - map here like the keys
18:02 - are all these uh characters and the
18:04 - value
18:05 - is all of the counts of those characters
18:08 - so this loop is going to loop through
18:09 - the
18:10 - key set which is the set of characters
18:12 - here in this case abr for the word bar
18:14 - what we want to do is get the count for
18:16 - each character we run into
18:17 - and see if we have at least that many
18:20 - in our pool of letters count so we can
18:23 - say int
18:24 - a current word char
18:27 - count um equals current word
18:30 - map dot get character so for example
18:33 - here the first time through this loop
18:35 - we'll encounter the letter a
18:36 - and we're just saying uh hey java get me
18:38 - the count that relates to that letter a
18:40 - and so it's just going to get the number
18:41 - one
18:42 - so now we want to get the number of that
18:43 - character that is available
18:45 - in our pool of characters so similarly
18:47 - we'll say int
18:48 - letters char count equals we're gonna
18:51 - use our letters count map from our pool
18:53 - of letters
18:54 - and we'll say if that contains the key
18:57 - of the current character
18:58 - then we want to get its current value so
19:00 - we'll just use another ternary operator
19:02 - here so if we have that character in the
19:03 - map
19:04 - then we'll just get that value letters
19:06 - count map
19:07 - dot get character so that's going to get
19:11 - how many of that character we have
19:12 - available in our pool of letters
19:14 - otherwise if it doesn't contain this key
19:16 - then we know that we have
19:18 - zero of that letter available after that
19:20 - all we really have to do is compare
19:21 - these two
19:22 - ins so we can say that if our current
19:25 - word char count is greater than our
19:28 - letters
19:29 - char count so what this is saying is
19:32 - that if
19:33 - our current word needs more of this
19:36 - letter than we have available in our
19:38 - pool then we have to uh break out of our
19:41 - loop sorry we can't make this word
19:42 - with this pool of letters and on that
19:44 - note actually we're going to need
19:45 - another boolean variable
19:47 - created here so that we can know when we
19:49 - come out of this loop
19:51 - whether it had this problem or not so we
19:53 - can just call it boolean can make
19:55 - current word and we're going to start it
19:57 - out
19:58 - uh initialize it to true but then if we
20:00 - run into a situation
20:02 - where we require more of a certain
20:04 - letter than we have in our pool of
20:06 - available letters
20:07 - then we will set that to false so in
20:09 - this situation can make
20:10 - current word equals false so then now
20:14 - right after
20:14 - this for loop we can just look at the
20:17 - value of this variable
20:18 - if it's still true at the end of that
20:20 - for loop then we know we're good to go
20:21 - we can make this word
20:22 - so it's just a simple if statement if
20:25 - you can make
20:25 - the current word then let's print it out
20:28 - to the console
20:30 - system.out.printline current
20:32 - word okay now i think that should work
20:35 - let's uh cross our fingers and run it
20:37 - okay so please enter the pool of letters
20:39 - a good
20:40 - random pool of letters looks great let's
20:43 - see
20:45 - awesome i think that worked so we have
20:48 - s-a-f-o-i-j
20:49 - and this is totally valid we can make
20:51 - sofa we can make soja whatever the heck
20:54 - word that is
20:55 - ah that is so cool all right let's give
20:56 - it a tougher challenge let's enter in
20:58 - like
20:58 - a whole bunch of letters
21:02 - lot of letters so what can you make out
21:03 - of that
21:05 - wow wow there are a ton of words
21:08 - all right sweet the main part of our
21:10 - program is working it's successfully
21:12 - spitting out all the possible english
21:14 - words we can make from the pool of
21:15 - letters that we enter in
21:16 - sweet but we're not done quite yet we
21:18 - have some code cleanup we have to do
21:20 - if we're going to be decent programmers
21:23 - now first of all i noticed that if we
21:24 - type in like a pool of letters
21:26 - um you know it spins out a good list but
21:28 - it doesn't say that that's what it's
21:29 - doing we
21:30 - might want to just add a quick statement
21:31 - that says here's the
21:33 - uh the possible words that you can make
21:34 - from those letters now we can just do
21:36 - that right before
21:37 - our big for loop here so just with a
21:38 - simple uh
21:40 - s out statement all possible words
21:44 - you can make with those letters
21:47 - now another thing if you've watched any
21:49 - of my videos before you know that we
21:50 - still have a problem here with our
21:52 - scanner we are not closing it like the
21:54 - good boy scouts we are
21:55 - so let's go down to the bottom of our
21:57 - main method and just remember to close
22:00 - your scanner
22:00 - or you will have a resource leak and it
22:02 - is just embarrassing so now you can feel
22:04 - good about yourself
22:05 - except also we have the same thing with
22:08 - our reader
22:09 - object here we also need to close our
22:11 - readers all right so let's go ahead and
22:13 - zoom out and just take a
22:15 - look at our fine work we can get rid of
22:16 - these comments now that we used as kind
22:18 - of a mental image as we coded
22:20 - that we don't really need anymore so
22:22 - look that's a pretty small little
22:23 - program you know maybe what is that
22:25 - 60 lines less than that and does a
22:26 - pretty cool thing right you can enter
22:28 - like a pool of any letters you want
22:30 - and it's going to find you all the
22:32 - english words you can make
22:33 - out of those letters that's pretty
22:34 - awesome now you can use your powers for
22:36 - good or you can use your powers for evil
22:38 - like cheating against your mom
22:40 - at words with friends but don't do that
22:42 - don't be a terrible person
22:43 - babe i'm not gonna tell you how to live
22:44 - your life grab the program and do with
22:47 - it what you will
22:47 - now if you enjoyed this learn something
22:49 - got some value out of it please let me
22:50 - know by liking the video and if you'd
22:52 - like to see
22:52 - more java tutorial videos like this
22:54 - every single week
22:56 - be sure to hit that subscribe button i'm
22:57 - getting these tutorials out to
22:59 - more people totally depends on you
23:01 - liking subscribing and sharing
23:03 - so i want to sincerely thank you if you
23:04 - take the time to do that and if you do i
23:06 - will see you back here next week for
23:08 - another job tutorial

Cleaned transcript:

hey everybody how's it going in this video we are going to create a program in java that can take a pool of letters like this and print out all the possible english words that can be made out of those letters so this can be used to solve like scrabble games words with friends any of those sorts of word scramble games we're gonna start from scratch program the whole thing beginning to end right here in this video so you'll see exactly how it's done if this is your first time on the channel my name is john and i make a java tutorial video like this one every single week so be sure to hit the subscribe button so you don't miss one and before we get started the full source code for this whole program is available in the link down in the description so go and get it okay so in this program we are going to have to of course take in a bunch of letters from the user via the keyboard and we're going to see what english words we can make out of those letters so of course in order to do that we're going to need like a dictionary file a list of a bunch of valid english words so i found one that i really liked and it's available in a link down in the description as well so go grab that but any dictionary file that you find will work great you can use any one that you you find if you like better separately just make sure it has like one word per line that's like a dot txt file a text file just to make your life easier so go ahead and download that file and put it in a location where you know where it is on your computer now the first thing we're going to do is make sure we can read in that dictionary file we're going to use the buffered reader class in java to do that and so we'll call it reader buffered reader reader equals new buffered reader and that buffered reader constructor takes a parameter and we need to tell that what we want it to read and for our purposes we're going to have it read a file so we actually have to pass in a new file reader and to create a file reader it takes the location of our text file so just go ahead and paste in the exact location on your computer of that text file but just pass in wherever you happen to put it on your computer so i know you guys are smart i know you know how to do that and we're working with eclipse so i can hit ctrl shift o to automatically organize my imports and you can see we have an import of java.io.bufferedreader and java.io.filereader so if you're working with some other kind of tool that doesn't automatically do the imports for you that's what they are and we also see that eclipse is complaining here that we have an unhandled type file not found exception and we probably won't do any fancy handling of that here if we can't read the file our program can't work so we'll just go ahead and say add a throws declaration here just add a throw file not found exception here and now let's make sure we can go through and actually use this reader to read all the lines of our file and we'll just print them out for now to prove that we can read the file properly so to do that to go through every line of a file using a buffered reader like this you use a special kind of for loop so we'll say four um and the object we'll create in our for loop is a string we're going to take uh the word that's on every line and so we'll have a string let's just call it a current word uh that's going to represent the current line that we're on and we'll set it equal to reader.readline and you can see that the the javadocs of this method here says reads a line of text and so what that's going to do is read the very first line of code and put it in this current word variable and so next we need uh the condition for staying in the loop like we're going to stay in the loop while there's still more lines to be read and we'll know there's another line to be read if the current word that we've gotten isn't null so we can just say current word not equals null so if it ever reads a line into this current word variable and it turns out to be null that means there wasn't the line anymore to read so we've reached the end of the file and then we need our iterator so in the normal for loop it'd be like i plus plus but we're working with a file reader here not like a normal sort of array so what we want to do to increment here is we need to get the next line of the file so all we have to do is say current word equals reader dot readline so that's kind of a long for loop decoration so i'm going to zoom out a little bit so you can see the whole thing for string current word equals reader.readline so to start we're going to read the first line of the file and put it in this variable we're going to keep going while the current word is not equal to null and to get the next line to iterate each time through the loop we'll do another current word equals reader.readline and you can see the eclipse is complaining here about an unhandled io exception so we'll just do the same thing we did before and just go ahead and add that throws declaration and a little tip there the the file not found exception that we had before was actually a subtype of i o exception so if we just say throws i o exception it covers them both and you can get rid of this file not found exception import because we don't need it anymore so i'm going to zoom back in so you guys can see a little bit more easily for every iteration in this loop this current word variable should hold the current line that we're on the current word that we're iterating over let's just go ahead and print that out to the console and see if we can print out our whole dictionary file so system dot out dot print line current word okay let's run this and see what happens whoo sweet looking great we go all the way to zzz which is somehow a valid scrabble word but hey good to know all right so our file input is working splendidly so next thing we're going to do here is uh the keyboard input part where the user can type in the pool of letters that they're working with so if they're playing scrabble or words with friends or something it's the six or whatever letters that they have in their hand but our program will be able to take any number of letters you can type in one letter you can type in a thousand letters and it's still going to work and we're going to want to do this kind of at the top of our program before we start looping through all the possible words we're going to want to get that input from the user so to do that we're going to use the scanner class as we always do scanner scanner equals new scanner and pass in system.in for keyboard keyboard input from the user add the import java.util scanner to get that to work we're going to print something out to the user just to prompt them to enter their pool of letters sis out please enter the pool of letters and we're going to take that input as a string so string we'll just call it letters equals scanner.nextline that will get the next line of input that the user puts into the console hit enter it'll get all those letters put them in that string all right so you might be wondering and it's a very good question how are we actually going to do this how are we going to take this scrambled list of letters and see which of all these dictionary words can be made out of that pool of letters how are we going to do that that's a really good question so here's how i think we can do it so what if we go through uh the pool of letters that we have and just count up how many of each letter that we have available so let's say oh we go through this this whole string of letters and say okay there were two a's there were no b's there were uh there was one c and so when we're done looping through that the pool of letters we know how many of each letter are available and then we can loop through each word in our word list and make sure that we can make the current word with the pool of letters that we have available so as a quick example let's say that our pool of letters was this aabrt that's the pool of letters we have to make words from what we're going to do is look at this string and say how many of each letter do we have here okay we have for a's we have two of those for b's we have one of those for r's we also have one and for t's we also have one and for anything that isn't in this like map here any letter that doesn't exist we know that we have zero of those to work with and then we're going to go through each and every word in our dictionary list and make sure that we have all the letters available in our word list to make the current word we're looking at so let's just say our first word in the dictionary was like aardvark well our program will say well for a's we're going to need three of them we're going to need uh two r's et cetera down the line and make that full map for this word also and then go through and make sure we have all the letters we need so the program will say okay i need three a's do i have three a's and they'll say nope you don't you only have two and then it'll quit looking at that word and try the next one and then say maybe later on it encounters the word a bar on our word list and then it says okay for a's i'm going to need one of those for b's i'm going to need one of those and for ours i'll need one of those as well and it'll loop through each of these letters and say okay do i have one a available yes i've got two so that's great do i have one b available yes i do do i have one r available yes i do and once it gets through all those letters and confirms it has enough to make this word we will print this word out to the console as a valid word that can be made from our list of letters so i hope that makes sense if not just ruminate on it for a bit until it kind of sinks in because it's going to be important to how our program works so let's actually go ahead and just uh comment this out so we kind of have it available for you know a mental model as we work through this code now what we want to actually do next is create this mapping in our code and to create a mapping like this it's of course of a character to a number so we can have say we have uh two a's we have one b or we're actually going to use a map and it's going to look kind of exactly like that and we'll say it's a map of character to integer and we'll call that letters count map because it's going to be basically a map of the count of all the letters that we have in our letter string you say equals new hash map that's a perfectly good kind of map to use here okay ctrl shift o again to organize imports but if you again are not using an ide we need java util map and java.util.have so now comes the jerky part where we have to like loop through the the the string of letters that the user has passed in and count up how many of each letter that we have available that'll be kind of a classic kind of for loop we'll just say 4 int i equals 0. you've probably done this before i less than we're going to go to the length of the letters input that we're getting so we'll just do letters dot length and then i plus plus to iterate and then for each iteration through the loop we want to grab the current character we're looking at so we just say char current char equals letters dot char at the current index of i so this is going to do so let's say this was our pool of letters aabrt the first time through this loop this current char is going to get the character at the zeroth position in our string which is going to be a so what we want to do here is is set the the right count for the current letter that we're looking at but it isn't necessarily the first time we're encountering this letter as we go through this for loop maybe we've got a huge list of characters and this is like the fifth a that we're seeing already we don't know so what we want to do is get the current count for that letter off of our map and we can do that by saying int count equals so what we want to do here because we don't know uh at what iteration in the loop we're working with we want to say if we already have a count for this letter on our map get it otherwise it'll be zero because we don't have that letter yet so here's what that looks like we're going to see if our letters count map contains the key of the current char so this is just a true or false value hey do i have this value on my map already do i already have an account for a for example on my map so we can say if we find that we have a current count for that letter we are going to get that current count so we'll just say letters count map dot get the current char so this will get us the count of that current character and otherwise if it didn't contain that key already we know that our count is zero so quick note here this is using what's called a ternary operator and if you haven't seen it before it might look kind of scary but it's really not terribly complex so this piece of code is saying if i already have a count for the current character i'm looking at let's say i want to know hey i need to add an a do we did we already add any a's before so if we already have a count for that letter then i want to get it from our map otherwise if we don't have a count then we know that it's zero and then right after that we want to set our current count to be one more than whatever the count was before and then after that we just need to add one to that character's count on the map so all that looks like is letters count map dot put so we're telling java hey put on my map that for this current character i'm looking at current char that i have one more than i did a second ago so let's walk through again exactly what this code is doing because this is the central part of this program let's say that again this is our pool of letters that we're looking through aabrt we're going to loop through each character in this string first character is a and for the first time through the loop our map is empty we haven't added any letters to it yet so it's going to try to get a count it says hey does my map contain this key yet for the letter a no it doesn't so it's not going to do this it's going to instead get 0 because this is the first time we are encountering the letter a in our string of letters so now we know that our current count is zero but we want to record what our new count is now that we have encountered one letter a so we're putting one new entry on our map here where our current character is the letter a and we're telling java we now have one a and now the second time through this loop it's picking up the second character in the string the second letter a that goes into this current char here and again we're asking java hey do we have this key and our map anywhere for this letter a and java says why yes we do we have one for the letter a we have already encountered one letter a and so we say great get that current count and so the number one gets filled into this count variable and now we put a new value for the letter a on the map by adding 1 to that count and so it will put in that same spot a the value 2. that kind of makes sense so it'll loop through again and then encounter the value b and it's for the first time so it'll say okay now we've got one b and then on down the line it'll say we have one r and one t so at the end of looping through all of this pool of letters we're going to have a letters count map that looks like this all right so that's a complex part of our program but we're going to need to use this uh piece of code later when we want to get all the letter counts for all of our words in our dictionary so because we don't want to have to rewrite this so because we're going to have to reuse uh this piece of code let's go ahead and put it in its own method so we can call it whenever we need it so to do that pretty easily in eclipse you can highlight all the code that you want to go into the method and hit alt shift m and it'll bring up this little extract method dialog for you and you just name the method whatever you want so let's just call it get character count map so we hit enter there so now it's created our method for us get character count map and it's going to take in a string of letters and we actually want it to return this letters count map which it's not doing right now it just made it a void for some reason so we instead want it to return this value a map of character to integer so let's change our return type to that and then at the end of our for loop all we have to do is actually return our letters count map okay all right so let's scroll back up here and notice uh we're just calling this method here and we're not actually storing uh the the map anywhere so so let's go ahead and still just grab this declaration so that we can set the result of this mapping to a variable that we can use so now after we call that fancy method that we just made our letters count map will have a mapping of every character that we had in that string and the number of times we had each of those characters and actually before i forget the more eagleeyed of you may have noticed that in my dictionary file here all of my words are in uppercase but perhaps our user types something in lower case we don't want it to just break we want it to act correctly when that happens so what we can do is just take what they type in in the scanner input and just call to uppercase on it and then that'll make everything they type in all caps no matter what they type in so it'll match our words easily later on okay so let's move our little map comment example down here to where we're going to have to write some more code just so we can see it kind of for reference for a mental reference all right now remember what we were doing we gathered the input from the user to get the pool of letters uh that we want to uh descramble and find all the words from and we grabbed our dictionary file and we've got code that currently loops through all of the words in that file so now instead of just printing out this current word we now need to have logic to see if the current word we're looking at can be made from the letters that we've got so the first thing we want to do is get the character count map just like we did for our pool of letters we want to get it for the current word that we're looking at in our dictionary file as we're looping through it and now that we've made it a standalone method it's very easy for us to do we don't have to write that complicated logic again we can just call it so we again need to make a map of character to integer call it current word map and set it equal to get the character account map of our current word and it's just that easy now we have that same complicated character count map on the current word we're looking at in the dictionary now what that has given us remember we are we are looping through every word in our dictionary file here let's say we were looping over the word bar at the current moment what this is going to give us this current word map will have a map that looks like this for the current word we have one a one b and one r now what we want to do is loop through all of the letters that we have in our map and make sure that our pool of letters has at least that many available for us to make this word okay so now let's write the loop that's going to loop through our current word map one that one looks like this and um and do that comparison to make sure we have all the letters that we need so to do that we can just say for character character in current word map dot key set so what does that mean the key set is the set of keys in a map so a map has a bunch of key value pairs so for this map here like the keys are all these uh characters and the value is all of the counts of those characters so this loop is going to loop through the key set which is the set of characters here in this case abr for the word bar what we want to do is get the count for each character we run into and see if we have at least that many in our pool of letters count so we can say int a current word char count um equals current word map dot get character so for example here the first time through this loop we'll encounter the letter a and we're just saying uh hey java get me the count that relates to that letter a and so it's just going to get the number one so now we want to get the number of that character that is available in our pool of characters so similarly we'll say int letters char count equals we're gonna use our letters count map from our pool of letters and we'll say if that contains the key of the current character then we want to get its current value so we'll just use another ternary operator here so if we have that character in the map then we'll just get that value letters count map dot get character so that's going to get how many of that character we have available in our pool of letters otherwise if it doesn't contain this key then we know that we have zero of that letter available after that all we really have to do is compare these two ins so we can say that if our current word char count is greater than our letters char count so what this is saying is that if our current word needs more of this letter than we have available in our pool then we have to uh break out of our loop sorry we can't make this word with this pool of letters and on that note actually we're going to need another boolean variable created here so that we can know when we come out of this loop whether it had this problem or not so we can just call it boolean can make current word and we're going to start it out uh initialize it to true but then if we run into a situation where we require more of a certain letter than we have in our pool of available letters then we will set that to false so in this situation can make current word equals false so then now right after this for loop we can just look at the value of this variable if it's still true at the end of that for loop then we know we're good to go we can make this word so it's just a simple if statement if you can make the current word then let's print it out to the console system.out.printline current word okay now i think that should work let's uh cross our fingers and run it okay so please enter the pool of letters a good random pool of letters looks great let's see awesome i think that worked so we have safoij and this is totally valid we can make sofa we can make soja whatever the heck word that is ah that is so cool all right let's give it a tougher challenge let's enter in like a whole bunch of letters lot of letters so what can you make out of that wow wow there are a ton of words all right sweet the main part of our program is working it's successfully spitting out all the possible english words we can make from the pool of letters that we enter in sweet but we're not done quite yet we have some code cleanup we have to do if we're going to be decent programmers now first of all i noticed that if we type in like a pool of letters um you know it spins out a good list but it doesn't say that that's what it's doing we might want to just add a quick statement that says here's the uh the possible words that you can make from those letters now we can just do that right before our big for loop here so just with a simple uh s out statement all possible words you can make with those letters now another thing if you've watched any of my videos before you know that we still have a problem here with our scanner we are not closing it like the good boy scouts we are so let's go down to the bottom of our main method and just remember to close your scanner or you will have a resource leak and it is just embarrassing so now you can feel good about yourself except also we have the same thing with our reader object here we also need to close our readers all right so let's go ahead and zoom out and just take a look at our fine work we can get rid of these comments now that we used as kind of a mental image as we coded that we don't really need anymore so look that's a pretty small little program you know maybe what is that 60 lines less than that and does a pretty cool thing right you can enter like a pool of any letters you want and it's going to find you all the english words you can make out of those letters that's pretty awesome now you can use your powers for good or you can use your powers for evil like cheating against your mom at words with friends but don't do that don't be a terrible person babe i'm not gonna tell you how to live your life grab the program and do with it what you will now if you enjoyed this learn something got some value out of it please let me know by liking the video and if you'd like to see more java tutorial videos like this every single week be sure to hit that subscribe button i'm getting these tutorials out to more people totally depends on you liking subscribing and sharing so i want to sincerely thank you if you take the time to do that and if you do i will see you back here next week for another job tutorial
