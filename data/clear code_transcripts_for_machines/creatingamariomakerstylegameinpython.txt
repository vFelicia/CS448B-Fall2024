hello in this video you are going to learn how to create a Mario Maker Style game in Python using pi game you will be able to build huge levels with lots of monsters and decorations and then you can play them too while making this game you are going to learn how to manage a pretty large project with lots of data attached you will learn how to create an auto tiling system for the terrain and I will also cover the logic for a 2d platformer with a camera and basic enemy Behavior along with lots of other topics there's a reason this video is 10 hours long I do have to mention though that this is not a beginner's project I expect that you already know the basics of Pi game if you don't check out my ultimate introduction to pie game on YouTube or my paid udemy course the latter one teaches you pie game by making four advanced games and by purchasing it you also help me make more free stuff the last thing before I start the entire project is organized by a free folders one for the code one for the graphics and one for the audio the code folder contains the actual logic of the game you can download all of this from GitHub a quick note on that though inside of the GitHub project there are multiple code folders each of those corresponds to one chapter inside of the video that should make it quite a bit easier to follow along with all of that out of the way we can work on the intro and the editor of this project let's Jump Right In and let's have a look here is the code I already have there are two python files we have main.pi and settings.pi settings.pi let me minimize everything is quite an extensive file the most important one in here is edited data and in there we have a very chunky dictionary although for now just don't worry about it all we need for now are these bits up here more specifically the window width and the window height the rest you can ignore at least for now what is much more important inside main.pi in here if I run everything we can see a black window that right now doesn't do anything let's go over it really quick all the way at the bottom down here we are first checking if we are in the main file we are going to have quite a few different files so this one is important next up we are creating an instance of the class Main and this class we are creating up here I'll talk about it in just a second finally on this object we are calling main.run which is this run method here inside of that we are running the actual game meaning this here is going to become quite a bit more extensive and that would be a basic overview now inside of the main class we have an init method and we have the run method the init method initializes Pi game this happens here then we are creating a display surface and we are creating a clock I guess the important bit here is that when the width and window height come from the settings this is what we have created here and this is why this is important right now besides that nothing really happens inside of the initi method so I can minimize it at least for now inside of the run method all we're really doing is we are creating a while loop this one here and inside of that we're getting Delta time we are getting the events and finally we are drawing a frame this is a really simple setup for pi game let's talk about what we have to do right now we have a main object and later on for the game we are going to need two different states we have the editor State and we have the level State I assume the names here are quite selfevident editor is for editing the game and level is for actually playing the game the important thing we have to figure out for this is how we can switch between these two different states meaning how do we get from the editor to the level and how do we get from the level back to the editor and this is not going to happen straight between the two instead what is going to happen is that main is going to organize everything meaning that if we want to go to a level we go to the main file and then to level and the other way around if we want to go back from the level we go back to main and then to the editor although for quite some time we are only going to talk about editor because this one is the more extensive part so let's start working on that one at least for the basic setup here we are back in the code editor and I want to create a new file this one I'm going to save as editor dot pi in here as always we have to import Pi game besides that let me copy it from main.pi actually I also want from settings to import everything which means we have all of this here available inside of the editor as well once we have that I want to create a class called editor there's no inheritance and in here I want to first of all create a Dunder init method this one itself and nothing else at least for now and finally in here let me add a comment this is going to be the main setup for now all I want is self dot display underscore surface this we get with pygame.display.get underscore surface that allows us to draw on the display surface so what the player sees right away we don't have to go over main.pi and besides that I want to create a run method this one needs self and we also need Delta time Delta time we are getting from DT here and this one is really important to keep our game frame rate independent if you have no idea what that means check out this tutorial it explains all of that although for now inside of run all I want to do is to type pass so we're not doing anything actually just to see that this is working let's do instead self.displaysurface dot fill let's say with a white color that way we can tell what's going on and with that all I want to do is inside of main.pi I want from editor import editor that way I have this class available in main.pi and inside of the init method I want to create an instance of that which means self.editor is going to be the editor and on this editor inside of the while loop of the game I want to get my editor and get the run method now if I run this we are getting an error that there's one required argument missing Delta time this happened because in here we have the data time argument fortunately this one is easy because we have Delta time I can just pass it in here and now if I run this we have a white background this white background we are getting from this line here which means this one is working good start there's one more thing that we do have to do and let me explain why once again here are the different states of the game and the problem we have is that both the editor and the level need their own event Loop which means for the editor we have to check what we are doing for the mouse input if there's a certain kind of keyboard import or if we are closing the game and the same we have to do for the level as a matter of fact we actually have a third event loop as well the one from Main and all of this combined really isn't good because if you have too many event Loops things can get quite complicated as a consequence we are going to make some changes and that is that main does not have an event Loop by itself instead we only have an event Loop inside of the editor and inside of level and those event Loops are not going to run at the same time and that is because we either have the editor or the level open they are never open at the same time and this is what we have to implement which means back in the code I want to take all of this here and add it to my class inside of a method let's call it event Loop this one itself and nothing else and in here I want to have the event Loop and for now the only thing that we need is close the game that is going to be your exercise what I want you guys to do is to copy all of this paste it in here and then run the event Loop when the editor is open should be fairly straightforward so pause the video now and try to figure this one out yourself alrighty first of all I want to cut out a couple of things this while true Loop here has to stay same for this Delta time however this event Loop here I do want to cut out like this and now inside of editor I want to paste it I do have to fix the indentation but now this is more or less all I had to do all I need now is to actually call this event Loop so self dot event Loop and now if I run all of this again I should be able to close the game and I am although now I'm getting an error that name sis is not defined that is happening because now we are calling sys.exit inside of editor which doesn't have the sys module that we can fix quite easily by importing sys as well along those lines we don't need CIS and may not Pi anymore if I run this now once again we're getting a white background now we can close it and everything works as intended cool let me minimize the event Loop and also the init method because the editor class is going to become really long but that is what we are going to start building although for now I think this is a pretty good start so let's work on the next part in this section we are going to create the editor and the main Grid or at least we are going to display it and let me explain what that actually means for the editor we have an origin this origin is a vector and literally every single element is going to be relative to it this is literally just one position or more specifically this is a vector with an X and a y coordinate and this point we can move around later on this is actually what we are going to do in this section and every single element we are going to create for example let's say if we are creating a single tile these tiles are always going to be relative to the origin which means if we're moving the origin to the top right we are also moving all of the other elements in the same direction that way when we want to pan around the editor we only have to move one point and everything else is going to follow so let's implement it once again we are inside of the code I want to work inside of the editor more specifically inside of the init method in here I want to add another section let me call it navigation the really important part in here is self Dodge origin this one is going to be a simple Vector now for the editor we're going to use vectors quite a bit and as a consequence I want to save me some writing so I'm going to create a shorthand which means from pygame dot math I want to import a vector 2 and I want to rename this to vector that allows me to not write pygame.math.vector2 every single time instead all I have to do is type vector and I have a vector now we have ourself.origin and just to illustrate what is going on let me actually draw it which I do with pygame DOT draw dot Circle in here I need self dot display surface so the surface we want to draw on then I need to color let's go with red for now then I need a center and the center is going to be self.origin finally we need a radius let's go with 10 so we can see it quite easily if I run main.pi now you can see in the top left we have a red dot and this point we are going to move around and to move it around I want to add another method let me do it below the event Loop and let's call it pan input in here we need self and we need the current event this is what we're getting from the event Loop and since the editor is going to have a ton of methods I want to add quite a few different comments here to make it easier to follow which means this entire section here is always going to be the input and there are going to be a few more methods coming but for now let's not worry too much about it now pen dot input we are going to always call inside of the event Loop so pen input and I want to pass the event in here inside of this I have to figure out a couple of different things first of all I want to check if the middle Mouse button was pressed or released let me add this with a comment so middle Mouse button pressed or released which means if I am holding down the middle Mouse button I want to pan around the editor and if I'm releasing the middle Mouse button I want to stop panning although right now this is only the input besides that I need an actual let's call it panning update and how we are going to connect the two is by creating one attribute inside of the init method that I call Self dot pan active by default this one is going to be false in here I first have to check now if the event DOT type that is the event I'm getting from the event Loop although let me minimize it for now so we only focus on one thing if this is equal to pygame dot mouse button down that's not how you spell that like that if that is the case I want to set self dot pan active to true although we do have a problem here right now we are checking for any Mouse button down so any click of the mouse this could be a left click a right click or a middle click but I only want to check for the middle Mouse Button as a consequence I have to add another condition and this one we get with pygame dot mouse dot get underscore pressed this one is going to give us the different Mouse buttons that have been pressed although this I am also going to use a couple of times and it's quite cumbersome to write so let me cut it all out and instead from pygame dot mouse I want to import get underscore pressed and rename it to Mouse buttons that I think is much easier to understand and this I can now use S Mouse buttons and this is going to give me a tuple with the left right and middle Mouse button in my case I only care about the middle Mouse button this is the one with the index 1. I guess while we are here I can just print middle Mouse button and see if this is working which means in main.pi I am getting an error that name pan input is not defined the reason for that I think is that this should be called self.pan input if I run this again now and press the middle Mouse button we get middle Mouse button pressed or just middle Mouse button although if I press left and right nothing is happening which means this is a really good start and these two lines here work while we're at it we can also check if the button has been released that we are getting with if Mouse buttons don't forget to call it and one if that is not the case then I want to set self dot pan active back to false once we have all of that inside of panning update I can check if self dot pan active and if that is the case I want to set self dot origin to my mouse position in this we will get with pygame dot mouse dot get underscore pause although just like we have seen with getpressed this is going to be kind of annoying to write as a consequence I'm going to duplicate this line and replace get pause with the mouse position which means now the origin is just going to be Mouse position and now I can now if I hold the middle Mouse button move the origin around and this is working really well although now we do have a problem we have the origin right here that one is really obvious but every time we are pressing the middle Mouse button this point is moved to the mouse position which means if our Mouse position is somewhere down here we are jumping the origin Point all the way this distance which is not what's supposed to be happening and if we had more elements in the game this would be really confusing instead what I want to do is this point here if we press the middle Mouse button is going to stay in the same position and then if we are moving the mouse let's say in this position I also want to move the origin in the same position which means we are only getting the mouse movement we're not getting the actual Mouse position and to achieve that all we have to do is whenever we are pressing the middle Mouse button we are getting the offset between these two points which is going to be another Vector that looks like this and I think this is going to make much more sense when I actually implement it which means whenever I am pressing the middle Mouse button I want to get some kind of offset this offset I actually want to create inside of the initi method let's call it self pan offset this is also going to be a vector but by default it is going to be 0 and 0. and let me minimize the event Loop and now inside of this line here I want to get myself dot pan offset and now I have to figure out the size of this vector which honestly isn't that difficult all I need is my current Mouse position don't forget to call it and from that I want to subtract myself dot origin although for this to work in this most position needs to be a vector itself so vector and let me explain what's Happening Here this one is going to be the entire window and for Simplicity let's use examples the origin is going to be a point up here and the mouse position is going to be a point down here what we are getting with this entire operation is the distance between the two how I am going to use that is when I'm setting the origin when pan active is true I don't want to set the origin to the mouse position instead I want to turn the mouse position again into a vector and from that I want to subtract self dot pan offset and now let me run all of this again now if I only hold the middle Mouse button and don't move my mouse nothing is happening however now if I move the mouse we are moving the origin Point without moving the origin point to the mouse we are only getting the movement of the mouse but nothing else I hope that makes sense that way when we're moving the origin Point around it doesn't look too confusing and all we are really doing here let me minimize all of this so I have a bit of space to write on like so basically all we are doing whenever we are pressing the middle Mouse button we are getting the distance between the two this line here when we are moving the mouse in this direction we are setting this origin point to the same position so this point here however we are giving it an offset and the offset is again the same blue Vector we created here that way we are always getting the same kind of movement without putting the origin on the mouse position we are essentially panning the origin point all right that I hope wasn't too difficult although there's one more thing that I do want to add and that is a mouse wheel all we need for that is if event DOT type is equal to pygame dot mouse wheel and what that is doing let me print it actually I want to get event dot y event.y might be a bit confusing here the way you want to think about it is that when you have your mouse button something like this you can for most mice move it up or down some mice also allow you to move it left and right although the mouse I have doesn't do it and it's not very many mice that do it so I am not going to use it although you could and event.y is this up and down movement here event.x would be the left and the right movement which means if I run main.pi and I scroll up or down we get either one or a negative one depending if I go forwards or backwards or up or down depending on how you want to call it all we have to figure out now is how to use this to influence the origin position and this could be a really good exercise for you try to implement the mouse wheel yourself and see how you can use it to change the position of the origin this could either only be the X position but if you want to challenge yourself you could also add another mouse input and also do it for the Y position see how far you get all we have to do is get self dot origin and I want to move the X part of this vector and this I want to minus equal event dot Y and right now event.y is either one or a negative one which is going to be quite small which means I want to multiply it by 50. if I run this now I can scroll down and go in this direction and scroll up and go in the other direction which looks pretty good let me move it a bit more to the middle if I scroll down we're going in this direction if I scroll up we're going in this direction you might be wondering now why I'm using negative equal instead of plus equal and let me print event dot y again if I run all of this now let me move the Red Dot into the middle if I scroll away from me so four words I guess I'm getting a 1 and if I scroll towards me I'm getting a negative one and I found this to be most natural if I go forwards like this the entire level is going to move a tiny bit more to the right it's kind of hard to see right now but later on this is going to make much more sense just imagine this is the entire origin point for the game and if this thing is moving in this Direction the entire level is moving in this direction as well which is what I want to happen if I'm scrolling forward like this and then if I go in the other way it goes in the other way once we have some elements this is going to make much more sense for now just stick with me I suppose while we are here we can also make this a tiny bit more fancy I can check if pygame dot key dot get underscore pressed so right now I'm checking if I'm pressing any button on the keyboard although I only care about one specific one and that is pi game dot k underscore L control that is the left control button on Windows and I think on the Mac it's the command button and if I'm holding that one I want to copy this line here indented and now move the Y position with the X position being in the else statement this makes sure if I'm pressing left control and scroll of the mouse we're going up and down and if you're not holding this button we're going left or right let's try it and let me move the dot into the middle if I don't hold left control and use the mouse wheel I can go left and right if I hold left control I'm going up and down that way we have a pretty good scroll Behavior and that is going to be the pan input later on we will have to add a tiny bit more but for now this is fine there is one more thing that I want to add for this section although it is getting quite a long one let me add another section that I called Drawing in here I want to draw tile lines maybe not the best name but well it is what it is what this means is if this one here is the entire editor window or the entire game window I want to have individual lines that tell me where in the grid I am which is going to make it much easier to navigate through the entire thing and this is supposed to be infinite and also relative to the origin Point Let's Start and let me explain how the logic is going to work first of all I need to know how many columns and how many rows I will have and this I get with the window with or the columns and divide it by the tile size both of these are inside of settings I have the window width and the tile size both of these are static numbers so they are never going to change also I haven't mentioned but the entire game is going to be independent of the resolution of the game so if you have a very small or very large monitor you could change these numbers as you want although tile size because of the graphics has to stay at 64. and the same thing I want to do for the rows except this one is going to be window height once I have all of that I can run something like for call in range cults which means if I have 10 columns I want to draw 10 lines one for each column in here literally all I want to do is pygame dot draw dot line we first of all need a surface which for now is going to be self dot display surface after that we need a color and the color we have in the settings line color although just black is also fine but let me copy line color and line color in here finally I need a start and an end point both of which are going to be an X and A Y position let me add X and Y in here so this is easier to read border columns the Y position is going to be really easy let me draw it actually once again we have an entire window and right now I want to draw the column lines something like this all of these columns always start at the position 0 so the top of the window and end at the height of the window which means for the Y position this is either going to be zero for the start position and window height for the end position that's literally all we do the X position is getting a tiny bit more complicated so let me create a separate variable although that being said both X for the start and for the end position are going to be identical because each line is a straight line I probably should have drawn this a bit better something like this okay you get the idea the important thing here is that the X position for this and the X position for this is the same that's the really important bit here and what I want is self dot origin dot X Plus call multiplied by the tile size what that means let's say our origin point is at position 0 and 0 right now this is the point we're getting here and X is zero so let me write X is equal to zero and from this point I want to add column multiplied by the tile size column right now is going to be 0 and tile size is always going to be 64. which means for the first one we get zero and this is then going to be this line here however now if we add this to a 1 or the second cycle in this for Loop and multiply it with 64. we are getting 64. and this is then bringing us to this point here and this we keep on doing until we reach the end of the columns so now all we have to do is call this method and we should be seeing something although there are quite a few problems let me do it before we are drawing the origin and let me add another comment here to call this drawing so this is a bit easier to follow filling display surface should also be in there actually in here I want self Dodge draw tile lines and now if I run out of this there you can see the lines and if I move the origin point you can also see that they are moving along with the origin Point although I guess you can see the problem we are very easily running out of points and nothing is here anymore also what I can do is if I move the origin Point too far to the left we're also running out of points here all of which is not ideal I want to be able to scroll infinitely and just keep on going which means I have to make some adjustments but they aren't that big let me minimize the run method and in here now I want to make sure that the lines are always on the display we are never running out of lines and if you want to challenge yourself this could be a fun exercise although this one is getting quite a bit more advanced but see if we can figure this one with yourself you don't have to add that much more if you want a reference I fixed this entire problem with one additional line of code all right let's do together now and first of all let me talk about the logic that we need here right now we have the entire window and we have an origin Point somewhere on here let's say right now it is somewhere here and this point is going to be the origin for all of the other columns meaning we are always drawing them in this line here you can already tell the first problem is to the left we have nothing on top of that if we are moving the origin too far to the left we also have nothing on the right side both of which are problems we do have to account for so let me clean this up a tiny bit and instead what I want to do is let me move the origin point a bit further to the left let's say it is here and the X position is 100. the logic you have to understand that is probably going to take you some time to follow is we always want to draw some columns here is column zero then we have column one at 64 pixels then the next one would be somewhere here at 128 and we keep on going and always go by one Higher in our tile size however now when I'm drawing all of this I do not want to set this origin Point here as the origin because then we end up with the problem that we have the columns that always go to the right and we end up without points instead I want to create another vector and this Vector is always going to be in this first area here somewhere like this which means the vector can only be here or here or here it could also be higher up or lower up that doesn't matter but it could never be here or here those points are not possible we Are Always Somewhere in here now the Y position we are going to completely ignore the X position however is going to be really important and this one we are getting from this distance here it's kind of hard to see basically what I want to know is what is 100 this number here minus 64 which is this number here if I'm doing the math here this one would be 36. and this 46 is going to be the distance from the origin so we are moving a point here it has the same y position as the origin but the X position is going to be the distance between the next column and the actual point I hope that makes sense once we have this point here all I really want to do is to start drawing columns from this point so we are creating columns here columns here columns here and that way we can move the origin wherever we want it is always going to be somewhere in this position and that way the columns can never go outside of the window I hope that makes sense again this isn't the easiest logic to follow but let me actually implement it and let's see how far we get first of all I want to create let me call it an offset vector this is also going to be a vector and in here we have an X and A Y position and I'm going to put both of them on separate lines to make it a bit easier to see although if you have a large enough monitor you probably don't need to in both cases I want to first of all get self.origin and this is either going to be X or it's going to be y I now want to get distance between my current point so self.origen.x currently is 100. and from that I want to know the distance this blue line here between the next column which is going to be 100 minus 64. the 100 I already have I now have to get the 64. although I do have to be careful here my origin Point could also be let's say here or here or here so this 64 always has to be the next column this we are getting with self Dot origin dot X and I want to divide this by the tile size and this I want to turn into an integer once again if I use actual numbers self dot origin.x would be 100 and the tile size would always be 64. which means this combined would be something like one point let's say 1.4 and if we get the integer we are removing anything after the dot so this would be a one which means we are on the first column although again this one would just be a one it needs to be a 64. as a consequence I want to multiply all of this with the tile size once again that way this entire number is going to become a 64. the 64 we actually need and with that we have the actual origin for the X position the one we actually want and this I can just copy for the Y position just to have something in here so this is going to be origin.y and the rest can stay the same and now when I'm drawing The Columns I don't want to have self.origen.x instead I want to have the offset vector actually let me call this the origin offset that I think makes more sense the rest however can stay exactly as it is so now let's try all of this again now you can see once again we have the origin point we can move around but all of the columns are going to scroll indefinitely although there's one problem if I move the origin Point too far to the left you can see here all the way on the right we are missing one column but the rest looks pretty good so I am very happy with that the one change we do have to make is that when we're using this for loop I want to have colds plus one and now if I run this again now this is looking really good cool this is looking amazing now the main reason why this is working is because it only looks like the origin point is the origin of the columns however the actual origin is this point here which is the origin Point subtracted with the offset we have created and only from this point we are drawing all of these columns that way it looks like we have an infinite amount but we're always only drawing The Columns you can see on the window cool now all we have to do is do the same thing for the Y position so for Row in range rows plus one I want to create a y position and that is going to be the origin of set dot y plus the row multiplied by the tile size and once I have that let me duplicate the pygame dot draw line line and now I have to change the X and the Y position X is either going to be zero or it is going to be the window with and Y is going to be well the Y position once again if I draw the entire thing each row is going to look something like this for the X position we always starting on the left side of the window and we're ending on the size of the window width meaning this is ever going to be zero or the window width and Y is just going to be the distance from the top both on the left and on the right and now we have all we need I can run this again and now we have an infinite grid that we can scroll around in this is looking really good cool although there's one more thing I do want to do and that is that right now this black color is a bit too strong especially later on if we have the actual level this isn't going to look very good meaning I want to give all of this some transparency for that I'm going to draw all of this on a separate surface and then this surface is going to get some transparency the reason here is when you are drawing something you cannot influence the transparency this we have to do on a separate surface and this is going to happen inside of the init method I want to add another section let me call the common support lines in here first of all I want to create another surface let me call it support line surface and this is just going to be another pygame dot surface and in here I want to have the window width and the window height we are essentially copying our entire display surface if I scroll down a tiny bit you can still see it before we start to draw everything here right now our problem is these lines are black and this background here is black so you can only see black which isn't too helpful as a consequence before we are drawing The Columns or the rows I want to get my support line surface and fill it with a green color we are drawing not on display surface but instead on the support line surface and all the way at the end I want to have self.displaysurface.blit I want to Blitz self.support line surface at a position 0 and 0. since the support line surface has the same size as the display surface if we put it at position 0 and 0 it is going to cover the entire window let's try and now the entire thing is green not particularly helpful it actually looks really weird but what we can do in the init method we can set a color key this we get with self Dot support line surface and set underscore color key and the color key here is supposed to be green this means that we're going to remove any color with this color key Green in this case which is what we're using to fill the entire surface the consequence is that the entire green color is removed and right now we don't really see much of a difference however what we can do now is set the transparency on this support line surface all we need for that is set underscore Alpha and then here we need a value between 0 and 255. 0 being nothing at all and 255 is the full color in my case I went with something like 30. and now you can see some very faint lines but they don't get too much in the way but with that we have the actual grid that we can move around in this is looking really good and this section has gotten really long so let's finish it now and let's come to the next part now for the next part we can do something slightly easier and that is changing the mouse cursor that really isn't going to take long and this section is going to be shorter and easier so let's jump right into it here we are back at Main and I want to work inside of the init method of the main class because in here we have to initiate the cursor and let me add a comment to make this easier to follow now for a cursor we have to do a couple of things first of all we have to import an image as a surface let me store it as a surface and all we really have to do is to import an image and that we do with pygame DOT image dot load however once again I'm going to import quite a few different things inside of the main class later on as a consequence I don't always want to write Pi game image and load I just want to write load so what I can do just like I have done with these lines here I can let me put it here I want from pygame dot image import load that way I can just type load and import a graphic if I open the folder we have audio code and Graphics right now we are inside of code and here is what we have so far inside of Graphics though we have cursors and there we have a handle and we have a mouse the handle we look at later but Mouse is the important one for now this is what we are going to import and the file path towards this is one folder up then graphics cursors and mouse.png on top of that don't forget to convert Alpha all of this next up we have to convert this surface to a cursor object this I also want to store in the variable let's call it cursor and the command here is pygame dot cursors dot cursor in here we need two bits of information we need the let's call it the click yeah Bell area and we need a surface the surface we already have this surface here is totally fine the clickable area is let me actually open the graphic here we go and if I open this and scroll in a tiny bit what the clickable area essentially tells you is which part of this mouse is actually going to be the point we are controlling which right now in this case is going to be this point here so when I click the mouse button I want this area to interact and be my actual Mouse position with the entirety of this just being an attached graphic that doesn't really do that much this point here is what actually matters I hope that makes sense basically we are looking for a clickable area in my case the position here is quite simple I want the Tuple and this one needs X and Y and in my case both of them are zero that means we are having the top left of this surface as the clickable area there's one more thing that we have to do and that is we have to get pygame dot mouse dot set underscore cursor and then here I want to have the cursor if I run the code now we are getting an error because I have a typo in here this should be cursors now if I run this and you can see my mouse here we have a mouse cursor that looks much more appropriate everything else still works just as usual we have just changed the graphics of the mouse for the next part we're going to create a menu and let me start by talking about how this system is actually going to work inside of the editor we are going to create what is called a selection index and this is a variable with values between 2 and 18. and each number represents a certain kind of tile inside of the editor for example two would be terrain three would be water four would be gold coin and so on and this selection index can either be changed by clicking on the menu or via hotkeys and just to explain how we got the numbers 2 to 18 let me open the code right away here we are back in the project and inside of settings we have editor data which is a dictionary that contains other dictionaries and the key is always the index and then we have the dictionary with lots of information in here we have 0 and 1 those two are going to be ignored because 0 is the player and one is the handle for the sky those two are always going to be inside of the editor so we don't have to create them however from 2 to 18 we have objects that the player can actually create for example two would be terrain you can see it here then we have water then we have different kinds of coin for example we have a gold coin a silver coin and a diamond then we have a bunch of enemies a bunch of foreground palm trees and a bunch of background palm trees all of these things we have to account for so let's get started inside of the editor and let me minimize everything so it's a bit easier to follow right now I want to work inside of the init method and in here I want to add another section let me add a comment that I call selection for now all I want is self.selection index by default this one is going to be let's say 2 for terrain now that we have that we have to create the menu and the hotkeys to change this selection index the hotkeys are going to be easier so let's do it right away and this is going to be another method in the input section in here I want to have let's call it selection or keys we need itself and besides that we also need the event all we really have to check in here is if the event DOT type is equal to pygame dot k down this means we are checking for any kind of keyboard input in here I want to check if the event dot key is equal to pygame dot k underscore right so we are pressing to the right and if that is the case I want to set self dot selection index and increase it by one then I can do the same thing for the left key so if event dot key is equal to pygame dot k underscore left and if that is the case let me duplicate the line this should be minus equal one since the event type only checks if we are pressing a button and not if we're holding down a button we also don't need a timer in here which makes all of this quite a bit easier to work with although there's going to be one issue let me print what we get at the end of this so print self dot selection index and also don't forget to call this thing I want self.selection not index but hot keys and we have to pass the event in here if I run all of this now we're not getting an error and you can see two in the bottom left if I now press to the right we get higher numbers and if I go down we get lower numbers so this is working really well however I can go below zero and I can also go above 18. like so and if we try to use those keys inside of the dictionary we would be getting an error which means I want to limit the numbers we can get from this one here so that the lowest number is a two and the highest number is an 18. and that could be a really good exercise for you so pause the video and limit the numbers to a range of 2 to 18. it should be doable on a single line of code I first of all want to Target myself dot selectionindex after I have done all of this let's get started with the smallest number and this we get with the Min function this one takes two arguments and it always selects the lower one in my case this would be self dot selection not hot keys but index and 18. with this line already selection index can never exceed 18. let's try actually by printing self.selection index and run out of this again and now if I go further and further to the right I can never exceed 18. so this one is working now we just have to cover the minimum so that we can never go below 2. and for that I want to put this function inside of a Max function this one also takes two arguments and it always selects the larger one which means if I have my minimum and I add a 2 in here if this Min now goes below 2 we're always selecting the larger number which is the two as a consequence we can never go below 2. which means if I run out of this again I can go to the left and the number doesn't go below 2 and if I go to the right the number increases but only up to 18. so this is working really well cool with that we have some basic hotkeys let me get rid of the print statement we don't need it anymore and we can minimize all of this as well next up we have to work on the menu and this is going to be a larger part so I want to put all of this in a separate file let me create a new file I will save this one as menu dot pi in here I want to import Pi game and just as before let me copy it actually I need all of the stuff from the settings once I have that I want to create a new class called menu no need for inheritance but we do need it under a niche method and here we need self and nothing else now first of all we need to be able to draw on the display surface so we need to display surface which we get with self.display surface or name it whatever you want and here we need pygam.display.get underscore surface once we have that I want to create two more methods the first one let's call it create buttons itself and nothing else and for now this is just going to be a pass besides that I also want to create a method that I called display in here once again we need self and nothing else at least for now and this display is what we're going to call to run the actual menu let's do it right away actually so inside of the editor I want to from menu import menu next up I have to create an instance of this object don't forget to comment things properly and let's call it menu is going to be menu finally to actually show the menu inside of the run method all the way at the bottom I want self dot menu dot display right now if I run all of this we cannot see anything because the menu doesn't print anything but at the very least we're not crashing so that's a good start now we can start working inside of the menu class and actually do something the first thing I want to do is to create a general area for the menu let's say this here is the entire display surface and what I want is in the bottom right a square that contains smaller Square this red square is the entire menu inside of it we have a couple of smaller squares and those are the things the player actually clicks on and the red thing is what we're going to create right now let me add a comment here as well and let's call it menu area General first of all I want to create two variables the first one is the size of the menu in general and that I have set to 180 pixels and then I want to have margin and this I've set to 6 pixels I suppose both of those numbers are fairly selfexplanatory once I have them I want to create self.rect and this is going to be the area of the entire menu this is just going to be a normal python rectangle enter here we need a left a top a width and a height the width and the height are both fairly easy because they are just going to be the size for the left side let me explain how this is going to work actually once again we have the entire display surface and inside of that we have the menu the size of the menu so this Dimension here and this Dimension here is going to be the size and this is what we have done already next up I want to have a margin and the margin is going to be this distance here and this distance here and this shouldn't be too difficult of a thing to implement so I think this could also be a pretty good exercise try to figure this amount yourself and see how far you get you have to set the left and the top meaning this point here to get this kind of margin on the right and on the bottom try to figure this one out and see how far you get let me get rid of the drawing and basically all we have to do first of all I need the window with from that I want to subtract the size and from that I also want to subtract the margin if I draw on all of this again basically what we have done let me scroll down a tiny bit so now you can see it better when the width is this point here then the size is going to be this area here and the margin is going to be this bit here meaning if we subtract the two from the other we are getting to this point here this bit which is exactly what we need for the left side of this rectangle once we have that the top shouldn't be too difficult all we have to do is copy all of this and for the top I want to have not the window width but the window height and this is going to be really hard to read so let me put it in separate variables for the top left I want to have all of this and I can just paste it in here since this is now a tuple we need a position Tuple and a size Tuple meaning the size has to be inside of another Tuple otherwise pygame gets confused you'll either need two tuples for the position and the size or you need four numbers for the left the top the width and the height both are okay but well you can't mix them if I now run this we're not getting an error so that's a good sign to actually see something now I can run pygame dot draw dot rect now we need a surface so self dot display surface then we need to color that one doesn't matter let's go with red and finally we need the rectangle self.rect finally before we can start we have to call create buttons which we do with self dot create buttons and now if I run this you can see in the bottom right we have a menu and this one stays on top of the level so it doesn't move around which is exactly what I want now that we have that we have to create the button areas and let me get rid of the general it's not needed and it kind of annoyed me I want to create four rectangles that go inside of the menu meaning if this one here is the menu I want to have four smaller rectangles inside of this larger box on top of that between the buttons there should be some margins so we do have to be careful with the numbers here the easiest way I found to work with this is to first of all create a generic button rectangle since all of the buttons have the same size we can just create this rectangle once and then copy it and move it in different positions meaning once again I want to create a pygame rectangle in here we need a position and a size the position is actually quite simple because all I want to do is self.rect.top left which means if I am drawing again the position we are looking at right now is this point here and the first rectangle we are creating is right on this point next up we have to make sure that we have a rectangle that is one quarter of the size of this entire box we're going to shrink that in just a second for now I want to keep the number simple so for the size I want to have a tuple with self.direct DOT with divided by two and besides that self.direct dot height divided by two with that we have a generic button rectangle or we almost have one that works let me turn it into an attribute so now we can draw it that makes the entire thing easier to see self dot generic button rectangle and this shouldn't be red let's go with green if I run this now we can now see we have a green rectangle inside of the larger rectangle that's a pretty good start but not ideal the problem we have right now is that this rectangle is a tiny bit too large if we had four of these rectangles they would fill out the entire menu rectangle perfectly since I do want to have margins this is not ideal as a consequence let me create another variable let's call it button margin and this in my case I've set to 5. also this generic button rectangle shouldn't be an attribute and this I also want to comment out at least for now we now have a generic button rectangle and we have a button margin with those two things we can actually create the first rectangle and this one is going to be an attribute and now I have to create four different areas for the specific kinds of buttons the first button area I want to create is the tile button let's call it rect all I want to do here is get the generic button rectangle and create a copy of it and just to see what is going on let me copy the entire thing and paste in the tile button rectangle if around all of this you cannot see any difference because we have copied a rectangle so nothing has changed yet however what we can do now is to run the inflate method on this rectangle in here we need an X and A Y position by how much we want to increase or decrease the size of the rectangle in my case I want to shrink this rectangle by the negative button margin both for the X and for the Y if I now run this again there is a tiny gap on the top left so we can see this is working the rectangle has shrunk in all four directions the reason why this is really useful is because the original rectangle was something like this and we were right up in the top left and this rectangle we have now shrunk in all four different directions by keeping it centered on this position here that makes it really easy to place this area and not have to worry about the map of positioning to get exactly the right area here and the right area here I hope that makes sense you're going to see in a second how this is really helpful so with that we have the first button or button area next up I want to create this one I called the coin button wrecked and here once again I want to get the generic button rectangle and create a copy of it although for this one I want to move it in here we have to give X and Y values to tell Pi game by how much we want to move this rectangle since the coins are going to be right next to the tiles we're not going to move the X position at all however what I do want once again if this is the entire menu and right now we have this array here already covered that is the tile button rectangle what I want to do next is for this coin button rectangle to move it right here which means since we right now have a copy of this original rectangle we want to move this point here to this point here which is exactly in the midpoint of this self.rectangle which means all we have to do is move this rectangle by itself dot rect dot with divided by two once I have that I can copy the drawing logic here and now I want to draw self dot coin button rectangle with a different color let's go with blue if I now run this you can see that I made a mistake because I confused the X and the Y position since the coins are supposed to be on the right side of the tiles I want to move only the X and not the Y let me cut it out and paste 0 in here and this one should be self.rect dot height divided by 2 and 0. now if I run this again this is looking much better all I have to do now is to call the inflate method let me actually copy it from here and paste it in there and now we should be good to go and there we go this is looking really good and I hope now you can see by using the inflate method here is really useful it allows us to create a rectangle that is exactly one quarter of the original rectangle size and then once we have the better position we can shrink it to have a tiny bit of margin all we have to do now is to copy this thing two more times we have an enemy button rectangle and we have a palm button rectangle The Palms I have in the bottom left and this is the area we have already seen I can just add a 0 for x and for y I want to have self.rect dot with divided by two and let me draw all of them so it's a bit easier to follow right now I have the pump button rectangle if I run this now you can see another area in the bottom left I guess I should change the color let's go with yellow you can see we have another rectangle and finally we need the enemy button rectangle this one is in the bottom right which means we need self.directed height divided by two and on top of that we also need self.rect.wiff divided by two as well so let me copy it and paste it in here and now the last thing I have to do is to draw the final thing as well or enemy button rectangle for the color here a color we haven't used yet let's go with brown and finally we have all four rectangles and this is looking really nice it looks even better if you don't draw the original rectangle let me comment it out and there we go now we have different areas for the buttons that we want to create so this is working very well now that we have all of that we need to actually fill these areas with an actual button and for that I'm going to create a whole separate class that I called button and this is going to be a Sprite Which means this one has to inherit from pygame dot Sprite dot Sprite and inside of that we need it done there in it method and then here we need a couple of different things besides rect we need the rectangle so the area we want to use then we need a group so what group this button Sprite should be part of and finally we need items and besides that I also want items alternative although items alternative by default is going to be none the reason here is when we have the palm trees we have the foreground and the background ones the foreground ones are going to be the items while the background ones are going to be the alternative ones and if you middle click on the Sprite it is going to switch between the two that felt like a good system to handle all of this but no other button is going to have alternative items unless you want to add some yourself but that's something Beyond this tutorial now once we have all of that the first thing we have to do is to create a super thunder in Niche method and pass in the group in here next up we have to create self.image and this is going to be a plain pie game dot surface with the size of the rectangle the rectangle that we have created up here for each individual button besides that we also need self.rect for each individual Sprite and this is just going to be the rectangle besides that we have to capture all of the items and this is going to be a dictionary that I called self.items in here we have the main ones and this is going to be items ideally spelled correctly and then we have the alternative ones and this is going to be items alternative besides that I also want to have self.index which by default is going to be 0 and self dot main underscore active which by default is going to be true main.active is going to decide if we are in the main ones or in the alternative ones and index is just going to tell us which item we are on you're going to see in a second how that is going to work however first of all we do have a problem we have to import a bunch of items and alternative items and that is going to be a bit more extensive and for that I'm going to create a separate method that I called create data itself and nothing else in here and all of this is going to be stored inside of self dot menu surfaces but now it's going to be an empty dictionary and let's have a look what we are actually going to import inside of settings we have this editor data dictionary with a ton of different things and let's have a look at the terrain for now in here we have a style we have a type we have a menu and then we have a menu surface the menu surface is really important and this we have for a lot of different elements all of them besides the player and the sky because those are not supposed to be in the menu also note here this is just going to be a path it is not a surface which means we have to use this path to create an actual surface and that is what we are going to do now for that first of all I want for key and value in editor data Dot items don't forget to call it and let me just print what we get so we have a key and we have a Vel U don't forget to call it and really important here self.create data needs to be called before created buttons because we need a data to create the buttons properly in just a bit but now if I run all of this and extend this one here where you can see we have a ton of different things we have the index and we have a dictionary with the stuff we have seen earlier so for example for the player we have seen this one here and the first thing we have to do in here is to check if each particular item even has a menu surface if it doesn't have one we just want to ignore it which is quite easily done all we need to do if I get rid of the print statement I want to check if value and menu exists in the first place that is this one here you could also check for the menu surface both would be fine and here you can see that the player doesn't have a menu and the sky also doesn't have a menu once I have checked that essentially what I want to create is a key value pair that is going to be inside of this dictionary the key is always going to be the menu entry here for example for these two elements here I want to have one key that's called terrain and attached to this key are two surfaces the surfaces from this one here and the surface from this one here it is always going to be one individual surface which means what I want to do is if not value and menu in self dot menu serves and if that is the case I want to create a new entry inside of this dictionary so self dot menu serves and then I want to get my value menu and for now let me just add an empty dictionary and this is probably confusing so let me print what we actually get self dot menu surfaces if I run all of this now we are getting a couple of keys with an empty Tuple as the value we have terrain oin enemy Palm foreground and palm background if I look at settings you can see we have terrain we have the coin we have the enemy and then we have Palm foreground and palm background and essentially what I now want to do is for example for the terrain I want to have this graphic here and this graphic here as a tuple associated with this terrain key and this is what I am going to pass into each of the buttons these buttons here as the items which means first of all I want to create a list inside of a tuple because I want to add more elements inside of this I want to run pygame dot image.load however we have already seen this inside of main.pi typing pygame.image.load is kind of cumbersome so I'm going to copy this from Main and paste it in here so now I only have to type load makes my life a bit easier and what I want to load is the current value we have and then the menu surface that is going to be this file here although now this Surface by itself isn't going to be enough but I guess for now let me run the entire thing and see if it works there we go at least it didn't crash so it has to start now for terrain we have one entry as a matter of fact for all of these we always have one entry which isn't ideal because in settings for example for terrain we have two entries and right now we are checking if Terrain is not inside of this surface and if it is not in there so this if statement here then we are creating a new entry the problem with that is once we come to the next entry that has the same menu then we are just going to ignore it and this we have to account for meaning I want to add an else statement if we already have this entry and if that is the case I can actually just copy this entire thing I want to append something to the list we already have this list we created just now and what I want to append is the same thing and now if I run this again we get for example for terrain two surfaces one surface for the terrain and one surface for the water although we do need one more thing right now we only have the graphic but we need a bit more information we have to know for each graphic the associated key for example for terrain we need to know the two because this is how we identify each individual graphic that is quite easy all you have to do is turn this surface into a tuple that right now contains only a surface but I also want to add the key here this I also want to do in the else statement when I append the value and now I want the key in here and now if I run this again we for example get for Terrain we have a tuple with two and the terrain surface and then we have three and the water surface for coin we have another list with a tuple and this one is a four and then we have a surface with the gold coin and that is actually all we needed so I can get rid of the print statement and minimize the entire method and now inside of create buttons I can actually create the buttons although first of all for that we need a group for the Sprites this one is really easily created all we need let me actually do it inside of the buttons that makes a bit more sense in here I want to have self dot buttons and this is just going to be pygame.sprite.group and now I can create individual buttons for example the first button just button is going to have a couple of arguments these four here or the rectangle first of all we need self tile button rectangle the group is going to be self dot buttons the items is going to be self dot menu surfaces and in here I want to have the terrain key finally for the alternative items I can just ignore the entire thing and this is going to be the first button now I can copy the entire thing and I think this is going to be a really good exercise for you to see if you can still follow along because the Imports I think did get a tiny bit confusing so definitely work with this and well try to create the other three buttons so we have all four buttons and see if we can figure this one out yourself let me actually copy it two more times and first of all besides the tile we also need the coin button rectangle this one is in the same group although for the surfaces we don't need terrain we need coin let's work on the enemy button rectangle this one again same group but for the surfaces we need this one I called enemy inside of settings you can see here we have the enemy finally we need the Palm button rectangle and this one is going to have items and the alternative items for the items this one is called Palm FG and this I have gotten from here and besides that we have Pawn BG and this is the alternative item here so I can just copy the entire thing and this one should be Palm BG and with that we can minimize create buttons because we don't need it anymore although let me run the entire thing and nothing is crashing that's usually a good sign right now we can work inside of the button in here first of all we need some kind of update or display method this one actually displays what we have inside of the Sprite first of all in here I want to have self dot image dot fill and for the fill now we need a color that color we're getting from settings and in here we have button BG color and button line color right now I want button BG color and this I want to pass in here next up we have to create a surface and a rectangle from the items or the alternative items and this information we are then going to use for self.image.blit and we are going to Blitz the surface and the rectangle the best way to think about it is that the actual Sprite with the image and the rectangle this is just going to be the background which means we are just filling it with a simple color but on top of this Sprite we're going to Blitz another surface and this surface is going to come from the items or the alternative items which means for now this is just going to be self dot items and then here for Simplicity I'm just going to work with the main ones for now these ones here actually just to make this a bit simpler let me print what the surface is going to be so print surface and now I can copy out all of this and instead I can run self dot buttons dot update and self dot buttons dot draw and in here we need self.d display surface if you have forgotten the buttons are just going to be a Sprite group and this has the methods for update and draw so we don't have to worry about it if I run this now you can see four different squares and besides that we can see a very long list and this is always going to be a list and inside of the list we have a tuple with the relevant surfaces this is what we actually want to draw on top of the Sprite Which means in here I first of all want to get the self Dot index the one we have created up here and by default this one is always going to be zero with that we are returning a tuple with the index of the graphic so if I go up a tiny bit this one here and then we have the actual graphic the one we imported here for example since we only want the graphic I want to use indexing again with a 1 so we're only picking the graphic with that we have a surface now that we have a surface I also want to create a rectangle a rectangle is quite simple I just want to get the surface and get underscore rect for this one I want to place this Center although for the center here you might be tempted to run something like self.rect.center that would not work and let me explain why it's really important to understand the rectangles here if this is the entire display surface and the menu is somewhere down here with one item inside of the menu being here what we want to do is to draw one surface inside of the center of this individual button which means we want to go half the width of this button and have the height of this button so that we end right in the center of this button the problem is if we used self.rect.center we will get the global position of this rectangle which would be a problem here because the origin or the local origin is this point here and if we use self.direct.center we would move this point here by this distance and this distance which would be way too much instead what we need we need a tuple with self.rect.wiff divided by two and self.rec Dot height divided by two and now if I run this this is looking really really nice so what you really have to understand here why all of this works is you have to imagine that this is the origin point for the surface we are currently drawing on and we only want to go a tiny bit to the right and a tiny bit downwards to get the center of this point if we used selfdirected Center we would get the distance all of this distance here which would be way too much understanding the global and the local area for rectangles is really important this is definitely something you want to practice if you want to get really good at Pi game all right with that we can see what we are doing what we now have to figure out is how to actually change the item or more specifically self.index this is going to happen inside of menu in here I want to create another method that I called click this one needs self we need position and we need a button how this click is going to work for now just so that something is working I want to print menu click this click method here is going to be called from inside of the editor which means inside of input I want to create another method this one I called menu underscore click for this one we need itself and we need the event once more what I want to check in here is if event DOT type is equal to pygame dot mouse button down and self dot menu dot rect dot Collide point with my mouse position essentially in here I am checking if I'm pressing the mouse button and if I'm pressing on the menu if that is the case I want self.menu dot click and for this one we need two arguments the position of the mouse and the button that we have pressed with the mouse which we can get very easily we need the mouse position and we need the mouse buttons the naming here might be a tiny bit confusing when I talk about buttons here I mean the mouse button let me actually change it a tiny bit Mouse button and I guess Mouse position you could also Import pygame.mouse in here and get the information from there but I think doing it like this is a bit cleaner now that we have that what I want to do first of all I want to check if we're actually clicking on any of the buttons so for sprite and self dot buttons if Sprite dot direct dot Collide point with the mouse position then I know print let's say button pressed let's try and now I can click on any of the buttons and nothing is happening and the reason why nothing is happening because I'm not calling Mouse click this once again happens inside of the event Loop in here self Dot menu click don't forget to pass in the event and now let's try this again if I now click on any of the buttons with any Mouse button we get button pressed which means all of this is already working at least to an extent in here now I have to check for the different Mouse buttons so if Mouse button and one this would be the middle Mouse click besides that we have if Mouse button two then this would be a right click however I do not want to have if Mouse button 0. the reason for that is if I click on the button with any of my mouse buttons so left right or middle Mouse button I always immediately want to select the current item imagine my terrain button in there I have terrain and water if I left click on it to switch to water I want to immediately select water as a consequence even if I right click on the button I want to select the new item as a consequence there's not going to be if Mouse button 0 instead I want to return a Sprite and then get ID this one doesn't exist yet but but we're going to create it in just a second first of all though inside of menu click I want to save self.selection index and storing it whatever we get from menu click and from when you click we're getting the current Sprite ID which is going to be any of these numbers here for example if we're clicking on land we are getting a number two the logic here does get a tiny bit more complicated I hope it still makes sense let's start by implementing get ID this one should be fairly simple inside of the button I want to create another method get underscore ID in here we need self and all I want to do is I want to return self dot items and now I first of all have to know if I am in main or in Alt this is quite easy to do I am in main if self dot mainactive else alternative this main is going to toggle if we are in main or alternative and this is what I'm checking with here which means self.items is the entire dictionary and with this line here we are either selecting items or items alternative which means we have a new list and from this list I want to get self.index which is once again going to give me a tuple with a key and a surface from this one I want to get the index 0. this is very similar compared to what we have done down here except now we don't get a Surface we get a key while we are here I can also copy all of this and paste it in here it is the exact same logic and with that inside of the editor I can look at my run method and let me print self.selection index if I run main.pi again we're getting an error that we have expected into the block after an if statement on line 46. that happens inside of menu and the problem is I should have added a pass in here Pass and Pass and now let's try this again right now our index is 2 if I click on the coins we have 4 11 and 7. so this is already working not all too badly we are definitely making progress what we now need is the middle Mouse button and the right click the middle Mouse button is the easier actually because all I have to do in here is Sprite dot main active is going to be not Sprite dot main active that way we're just toggling this on and off however this is only the behavior if the Sprite has alternative Sprites which is only the case right now where are the buttons inside of the buttons Only The Palms have alternative items the other three buttons don't and the code right now would crash here because we would have an empty list for the alternative items which we can fix quite easily I only want to have this behavior is Sprite dot items and ALT exists in the first place and if that is not the case this one should be true which means if the Sprite has alternative items then I am switching and toggling them on or off however if the Sprite does not have alternative items this is always going to be true I suppose what you could be doing to make this a tiny bit easier to read you could add the if statement here and then all of this and put else at the bottom and this should be Sprite dot mainactive is going to be true or rather since main active is by default true and we can't change it if there's no alternative item we can just leave it like this let's try this one actually so now if I middle click on the palm trees you can see this one is changing although if I click on anything else nothing is happening besides the selection index changing so this one is working quite well now for the right click I want to get my Sprite and run a switch method that's which method doesn't exist right now so let's create it all we need in here is self and basically what I want to do is self.index is plus equal one which should already work to an extent now if I right click on any of these buttons we get something else although if I keep on clicking for example on the terrain we're getting an error list index out of range for example for the terrain buttons we only have two items so if index gets greater than that we are getting the error that we have an index error to fix that once again we have to limit the index so sell for index is going to be zero if self dot index is greater or equal than the length and now we need to know if we are in the main items or the alternative items which is what we have done a couple of times already so I can just copy it this one here and paste it in there however if that is not the case so else I just want to get myself dot Index this entire line means I want to set self.index to zero if self.index is greater than the length either of the main items or the alternative items however if it is not greater or equal than the length I just want to keep self index as sub index and not make any changes that is all that we are doing in here although I just realized this should be self dot items and then we're indexing on it but now if I run out of this and I right click on any of the buttons we are cycling through the different things that we can do and now for the palm trees if I'm going to click on it and right click we're getting different kinds of palm trees so this is looking really good also if you look in the bottom left we get the different selection indexes I am very happy with that with that I can minimize the buttons and get rid of all of these comments here and the last thing we need I can also minimize the click the last thing we need is a highlight in the cater this one itself and besides that I also want to have an index this method makes sure that it highlights the currently selected button so we have an idea of what we're actually doing in here first of all we have to know what the currently selected rectangle is the easiest way for that I found was to get the editor data again check the index we are currently working on and then I want to check one specific item in here for example I could check if the menu is terrain or coin or enemy and that I think was the best way to approach it I guess you could also go with style but that we're going to use in a bit but now I want to check the menu and if the menu is equal to terrain then I want to draw pygame dot draw Dot rect and here I want to draw on self.display Surface the color we are getting from settings and in here we have the button line color yes I want to pass it here and finally we need a rectangle for the terrain this is going to be the tile button rectangle it's called tile button rectangle by the way because both the water and the terrain are both going to be tiles and they're kind of unique in that respect you'll see later on what that means but now all I have to do is call self.highlight indicator and in here I need the current index which I don't have right now so inside of display I want to have another parameter called index and now inside of the editor I can get rid of this print statement and when I display the menu I want to pass self.selection index into it and now if on all of this you can see that we have highlighted out the terrain so if I click on it you can't see anything but at the very least we know it's working the problem here is that we have to specify a border with with ifset to five besides that there's also border rounding which I have set to four and now if I try this again this is looking at least a little bit better another thing that you can do here is to inflate this rectangle which I do with the inflate method in here again I need X and Y values which I've both set to 4. if I now run this again this is looking much better it's kind of hard to see right now because the background is white but it definitely works I guess inside of the editor I can change the background color to something like Gray and now you can see much better what's going on you can definitely tell the terrain is currently selected same with the water it works the same way all we have to do now is do the same thing for the other three items let me copy the entire thing paste it in here and now I want to check if we're not on terrain but on coin and if that is the case I want to draw a rectangle around the coin button rectangle besides that I can paste this one more time now we have the enemy at least I think that's what it was called if I look at the menu here we have enemy if that is the case I want to have the enemy button rectangle and finally we have to do this one more time and now I want to check if menu is not equal to but inside of a list because the menu here we have to check all of these different items it could either be Palm FG or Pawn BG which means I want to check if the value we currently have selected is either a pawn BG or Pawn FG and with that let's try all of this and now if I select any of them they work except for the pawn tree the problem here I think is that this final rectangle should have been Pawn button rectangle so now if I run this again I can select the different buttons also change the item and this is looking really good cool I'm really happy with that and with that we have finished the entire menu this was once again a larger section but we have made a ton of progress I can actually close the entire menu because we don't need it I think ever again so let me minimize everything and this was one major chunk of the game done now that we can select things I want to start working on creating the tiles that basically means if the player clicks anywhere on the editor we're going to start a position and what the selection index is later on this will be used to draw the entire editor although for now we just work on the input and storing the information let's go over what we have to do number one whenever the player clicks on the editor we have to get the mouse position and convert it to a cell and this cell has to be relative to the origin point think of it like this this one here is the origin point and this one here for example could be the entire map if I for example click here I want to know the distance on the X from the origin and on the Y from the origin if for example this position is inside the First Column with the First Column being 64 pixels and the origin point being at point zero this should be in column 0. you could do the same thing for the yaxis or for the rows if we are somewhere in here then this position should be 0 and 0. however if we are clicking somewhere let's say here then this should be I don't know let's say this is zero this is one this could be two and if I draw another one down here then this would be zero this would be one this would be two which means this cell here would be the cell two and one and that is the information I want to store or that I first have to get on top of that which is really important is that this system has to work with negative numbers because we could get into this direction here and get Negative cells stuff up here for example we could have a cell I don't know what this is but let's say negative 4 and negative 1. these cells we also need to get what is really important about this system is that this origin Point can be moved wherever we want it could be positive or negative infinity and we have to account for that so this is a system we have to implement once we have that what we are going to do is we are going to be creating a dictionary with a key and a value pair like any dictionary the key in this case is going to be the cell position the associated value will be an object that tracks all of the IDS we have used on the cell for example this is again two for terrain free for water four for gold coin and the objects we are using for storage could contain any number of them for example if a cell has water and a gold coin we'll be storing three and four inside of this object and that is what we have to do so let's Jump Right In once again here we have everything and I want to work inside of the editor and let me minimize everything so it's easier to see first of all I need to figure out whenever I click where my mouse position is let's put this in another method that I called get current cell for now we don't need any parameters besides self and for now all I want to do is to print my mouse position don't forget to call it and also we have to figure out when to call this method here for that I need another kind of input which is going to happen inside of the inputs section in here I want to add let's call this one canvas add this is going to be triggered whenever we are clicking on the canvas this one only in itself and nothing else and in here I want if Mouse buttons and zero so we are left clicking on the canvas and not self dot menu Dot rect and Collide point with the mouse position with this we're checking if we're left clicking and we are not clicking on the menu if that is the case I want to run self and get current cell finally all we have to do is to run this canvas ad this again is going to happen inside of the event Loop and here I want to call self.canvas AD and for this one we don't need the event which means if I run this now and I click I get the mouse position however if I click on the menu nothing is going to happen cool so this one is working I can minimize the event loop again and now we can work on getting our current cell and the first thing we have to do let me actually do this in the editor and let me show my mouse there we go right now you can see my mouse moving across the entire editor and if I for example click on this cell here this should be 0 and 0. the actual position if I move this to the side a bit where I have clicked was 24 and 24. this I have to convert to 0 and 0. however we do have a problem because if I show a mouse again and I am doing the same thing again after moving the origin point if I now click again in the top left I am getting roughly the same position but now this number needs to be negative for the simple reason that I clicked on this cell all the way up here which is really far negative from the origin point basically what we are going to do when we are checking for the cells we are checking how far each cell is away from the origin point this is what really matters I guess the confusing thing here is that for the display surface when we're getting the mouse input the origin point is here but we want to have the origin point to be this point here and this is what we have to change I want to get distance to origin and this I think could be a really interesting exercise for you try to figure out the distance to the origin so what is the distance and X and Y from a mouse position to the origin alrighty basically what we want to do here I want to get my mouse position and from that I want to subtract self dot origin there is one adjustment that we are going to need because this mouse position right now is a tubo but we need a vector to do proper Vector math like so and this is all we needed let me print distance to origin so we see what's going on if I run all of this again and I click let me show my mouse if I click here we get 29 and 22. this is now the distance from the origin so this distance here if I click somewhere else we get a larger number which is working as intended so far there's no difference however now if I move the origin Point somewhere here and now I click again in this top left corner we now get a really large negative number only if I click again next to the origin point we get the small numbers that get us to zero and zero and this is working everywhere on this map or editor it works pretty well so this system is already working although we have to make one more adjustment let's have a look at the numbers we got here right now they're all pixel positions let's find a good number let's go with this one here 146 and 91. this right now is simply a pixel position how far we are away from the origin point this I have to convert because I want to have the cells away from the origin not an actual pixel position what this is supposed to be is that we are in cell I think this is going to be three and two these numbers we are getting by dividing this number by the tile size and then getting the integer of that for example this three here would be a 146 divided by 64 and then we're turning all of this into an integer I'm looking at this like this this is probably a 2 and this is going to be a one but you get the idea let me make this a bit smaller and back in the editor I now have to know a column and I have to know a row and this is going to tell me exactly what cell I am on all we need to do is the integer of distance to origin and since this is a vector I can get X and Y quite easily and this I want to divide by the tile size the same thing I want to do for the row in here I can just copy the entire thing and this should be a y and now I can print a tuple with the column and the row and let's run all of this again if I now click let me show my mouse again next to the origin point we get 0 and 0. if I click to the right we get one and zero and we get one and one two and two three and two and so on this is working very well also if I move the origin point we can still click and get the right cell position however if I now click on this cell here we're getting a problem this is 0 and 0 and this is zero and zero which is a minor problem with omf let's talk about it let me draw a couple of columns that makes it much easier to explain we have a bunch of columns here and I'm really bad at drawing straight lines and the origin point is going to be this point here the issue we have right now if we have a point here that is some small number let's say on the xaxis we have 20 pixels and on the yaxis we have 15 pixels if we divide 20 by 64. we are getting 0 if we're taking the integer and if we are getting 15 over 64 we are also getting 0. which means that this x here has a coordinate of 0 and 0 in the coordinate system we have created so far so good however if I clean all of this up and now if I go the other way and I go in this direction here and this direction here and I end up in this point which is let's say negative 40 and negative 50. if I divide negative 40 by 64 or negative 50 by 64. we are also going to get 0 and 0. which in our logic is going to be a problem because 2 pi game this cell here and this cell here have the same position which would break the entire game and would be a massive headache to work with so we have to account for it what I want to do let me do this over multiple lines although you could do all of this on one line but it's easier to read over multiple lines I first want to add an if statement if distance to origin dot X is greater than zero if that is the case I want to have this column the one we have already seen however if that is not the case so else I can copy the entire thing and just subtract one from it that fixes the entire issue it really isn't that difficult the same thing we have to do or let me actually copy it if distance to origin dot Y is greater than zero then we want to get this row however if that is not the case so else then I want to get the same thing 1 and that is it if I run this again now and show my mouse I can again click here and we get 0 1 this looks pretty good however now if I click on the top left of the origin point I get negative 1 and negative 1 negative two and one and so on this is also working very good now cool so with that we have fixed the entire issue all we have to do now is I want to return column and row at the end of this method and with that I can minimize it and not worry about it anymore now we can continue working in the canvas ad method in here first of all I want to get my current cell that is the one we are getting from the method we just created although now I need some way to store the information we are going to create in here this I want to create inside of the init method and in here in the main setup I want to create self dot canvas data right now this is an empty dictionary that's all I need for now although I also want to add this section here I want to call support it's going to be a bit more methods later on in there but let me all of this a bit more properly because we are going to add a ton more methods in here but all right now we can actually work in here if the player is clicking on the editor this is what we already have this is this line here then I want to check if the current position we have is inside of canvas data if that is the case we want to add something if it is not the case we want to create a new key value pair which means I first of all want to check if the current cell is in self dot canvas data if that is the case we don't really know what to do right now so let's just write pass in here however if that is not the case else I want to get self dot can this data and then I'm going to get my current cell as a key and for now let's say I want to add cell in here and after every time we are clicking I want to print self dot canvas data if I now run this and show my mouse you can see that I can add more and more cells and we always have the position of the cell and then cell this cell here is going to become much more complicated but the position is what we really care about for now this is working really well whether there's one more thing that I do want to do later on when we are going to run this we are going to run quite some code that is going to be a bit more processor intensive as a consequence I only want to run this if we are changing the cell which means if the current cell is different from self dot let's call it last selected cell only if that is the case which means we have changed the cell so we went to a different one then I want to run all of this and at the end of it I want to run self dot last selected cell is going to be the current cell all we have to do now is to create this as a proper attribute inside of the init method let's do it below selection and by default this can just be none all this one does is it safeguards us against wasting some resources but if I run this again we can't really see any difference what we now have to figure out is how to create a data structure that can capture all of the data what this basically means is we need some kind of object that can store hypothetically all of these numbers and since that is going to be a tiny bit more complex I want to create a whole new class for it so all the way at the end of this document I want to create a new class this one I called canvas tile there's no inheritance but we do need as always a Dunder init method in here we need self and tile ID this one is going to store quite a bit of information so let me add comments to explain what is happening first of all it is going to check self dot has Terrain this could ever be true or false by default it's going to be false besides that I also want self dot terrain Neighbors and this for now is going to be an empty list imagine we have a Terrain tile here just some empty land what kind of graphic we need for this terrain tile depends on what surrounds it for example if there's a tile here this one would need to be some kind of bottom tile if we had a tile below we would need a top tile something like this which means whenever we have a Terrain we also need to know what neighbors this terrain has and all of this is going to be stored in here next up we need the water and then here the logic is going to be fairly similar first of all we want to check has water and this by default is going to be false besides that I also want to know if self dot water on top this by default is also going to be false the important thing here I can actually show this in the folder here's the game folder I want to look at Graphics terrain and then there we have water and in the animation this is what's supposed to be on top of the water however this is only on the top layer of the water if water is below that we want to have this graphic here if we have two water tiles this one and this one only the top one needs to have the water animation the bottom one can just be a full tile that doesn't need animations next up we need to know what coin we have this one is very simple all we need here is self.coin and by default this is going to be none the system I want to have is that each tire can only have one kind of coin so we couldn't have a gold and a silver coin on the same tile which means this attribute here could either be four five or six and if we're changing it we're getting rid of any other coin besides that we have the enemy and that's the same logic as the coin we have self dot enemy and this is going to be none we can only ever have one enemy per tile finally something we are going to work on much later we are going to need the objects and this is self.objects and for now this is an empty list the logic for the objects like the palm trees and the player are going to be much more complicated for now I am not going to worry about it however what we do need is a method that I called self dot add ID this one itself and a tile ID that is the one we're actually getting from up here and this inside of the editor is going to be the selection index so basically later on when we are creating this object I can actually do it right now we're going to create a canvas tile and pass in self.selection index for example if in settings our selection index is 2 right now we are adding a Terrain tile which means this number here would be a 2 for example and then this is going to be a 2 in here and this two will be passed in here and now we have to create add IB with self and tile ID what we now have to figure out is if this tile ID here is 2 we want to add in self dot terrain that this is supposed to be true and then we need to find the neighbors the neighbors is going to be topic on its own but we want to change this one here and the same would also be the case for water for the enemies for the coins and so on first of all I need to know what options are available this I know from the settings again I need this editor data if again my current selection index or the tile ID is two I want to know the style of this current dictionary and this is going to be a dictionary comprehension which means I want curly brackets and I want key and value for key and value in editor data dot items this right now would duplicate the entire dictionary so we haven't really achieved very much but all I really care about is the style part of the dictionary that we are getting let me actually print what we get that should make all of this much easier to see if I run this now I hope it doesn't crash and it does crash because this self ID here shouldn't itself it just needs tile ID now if I run this there we go this is working and we are getting now in the canvas data 0 and 0 and then an object and this is not what we're doing here but instead this happens because of this line so let's get rid of it and that should make all of this much easier to see there we go now we can see what's going on if I click anywhere on the editor we're getting a dictionary that is the dictionary I have created here the options dictionary we have 0 and player one and Sky to enter rain 3 and water we basically have this key and then only this value here how I want to use that is with a match case statement I want to check match options with my tile ID remember here using match needs python 3.10 if you have an earlier version this is not going to work but you can make the same thing work with an if statement as well although update your python version the first case is going to be Terrain and if that is the case I want to set self dot has terrain to true if the case is water I want self dots as water to be true if the case is coin then I want self.coin and in here I want to have the tile ID for the coin the same thing I can just duplicate it actually for the enemy then selftaught enemy is going to be the tile ID now what does all of this mean and let me try to get all of this on one image let's do some examples to illustrate how this is working the case we have already seen is that tile ID is 2. from the dictionary we have created here we always have key value pairs for example 2 is going to be Terrain and if we're getting indexing like this we know that this 2 is going to be this case which means we want to set self dot has terrain to True which is going to set this terrain all the way up here to true on the same line if this for example let me get rid of all of this if this tile ID was a four a four bought a coin this one here if that was the case we would get this case statement here and we will set self.coin to the tile ID which means this self.coin here would be F4 which would tell us on this tile we want to have a gold coin and later on when we are clicking on this again with for example the number five then we're going to overwrite this and change this 4 to a 5. that way we're getting rid of the gold coin and replace it with a silver coin the same logic is going to happen with the enemies as well I hope all of that makes sense it is a lot of data management later on we have to add a tiny bit more in here to account for the objects but for now I am not too concerned all we have to do now is figure out if this system actually works let me minimize it for now and now we can work inside of this canvas ad again and instead of printing the entire thing I now want for key and value in self.canvas data I want to print an F string with the key which is going to be the position for the value here let's just print the value itself also let me add a bit of white space here so all of this is easier to see if I now run all of this and click on it we are getting something weird and I think the issue here is that this should be canvas dot items or canvas data.items now if I run this this is much better now we're getting a canvas tile object at a certain position which doesn't help us too much but I could now for example check as the rain and if I now click on it we're getting true and we're getting false okay this is very hard to see but trust me it is definitely working illustrating how it works is very hard to do once we get to drawing things all of this is going to make much more sense but first of all the last thing for this section is inside of this when we are clicking on a cell that already has a canvas tile I want to add to this tile and this I get with self dot canvas data and current cell so now instead of creating a new key value pair I am targeting an existing one and this is going to return a canvas tile and on this canvas tile I want to run add ID with myself.selection index this is going to work because inside of this canvas tile we can run this add ID multiple times it is going to work every single time which is all we need here and with that we can add stuff to our editor although we can't really see anything but I guess that is going to come in the next part or rather I'm going to cover this over multiple sections the logic here is a bit more extensive let's get started on drawing the level in here we already know what to draw and where to draw it all of that is coming from the last section where we have created a canvas data dictionary with a position and then a canvas tile that tells us what we want to draw basically all we have to do is to cycle through this camera started dictionary and draw the things associated with it which sounds much easier in theory but it certainly is doable let's Jump Right In and let's have a look at it once again we are in main.pi and I want to keep on working in the editor more specifically I want to add to the drawing section in here I want to have another method let's call it draw level this should be an underscore and then here we need itself and nothing else the main thing we have to do in here is for let's call it cell position and the tile in self dot canvasdata dot items first of all we have to convert this cell position into an actual pixel position so that for example something like 1 and 2 would rather be a 64 and 128. on top of that we have to make sure that this is the position from the origin Point not from the top left of the window this is really important to take care of I'm going to store all of this in a separate variable position seems like a good name and in here I first of all always want to start from the origin once again this is a vector and to this I want to add the cell position and this cell position I want to multiply with the tile size there's one problem this cell position right now is a tuple which we cannot multiply with a number but I can do that if I convert it to a vector there we go this is all we needed now comes the kind of tedious part we have to check all of the different possibilities the one that is most common I think is going to be if tile dot has not water but rain if that is the case I want to Blitz a certain thing let's say self dot display surface and then I want to Blitz something in here we need a surface and we need a position the position we already have that is coming from here the surface is going to become a bit more complicated for now just to have something in here I want to create a let's call it a test surface and this is going to be Pi game dot surface and for the size I want to have the tile size and the tile size again on top of that I want to fill this test surface with a brown color so it's easier to see what's going on once we have that inside of the run method before we are drawing the lines I want self Dodge draw level if I run this now and click we're getting an error the type object is not subscriptable the issue happened on this line here and I realized this shouldn't be square brackets this should be normal brackets like so now they're on this we're getting another error that this should be test surface and now there we go we can draw on this thing and we have a nice logic that works really well also now if I Pan the entire thing all of this is still going to work I should actually show my mouse that I think is going to make all of this easier to see so all of this is working really well we are definitely making some progress and this is looking really nice while we are here there are going to be three more things that we need to add we have to add the water we have to add the coins and we have to add the enemies all of those are going to look kind of like this and they all need the individual if statements and this could be a really good exercise copy this and create the same thing for water coins and enemies and make sure to properly check what kind of tile you are going to have in this position in my case I am going to copy all of this and now for the water I want to check if as water if that is the case I want to create another surface like so and this one I want to have not water this should be blue I can copy The Thing One More Time although for this one I just want to check if tile dot point because of type conversion here if coin is none which is the case by default coin is none this if statement is not going to trigger however once this coin has a 4 a 5 or 6 this if statement is going to trigger so this is still going to work the color here I want to have yellow and we need one more if statement for the enemies like so and just one if tile dot enemy exists and for this one I want to have a red color and with this let's try main.pi let me show my mouse again and now if I draw a Terrain tile we're getting the brown color but if I click or right click on the water and draw again we are now getting blue tiles also if I click on the brown tile you can't really see the result because the terrain is on top of the water but it definitely works I guess if I draw terrain on the water we get brown on top I can also do this for the coins and I can do this for the enemies we are definitely starting to have a start of the game all we really need now is to import a bunch of different Graphics to make this look actually decent let's do that in the next part it is going to be a bit of a larger topic I suppose the most important part of the level editor is drawing the terrain let's work on this one in here we first of all need to import a lot of data and when I say a lot of data I really mean a lot of data let me show it actually here is the project folder there we have Graphics inside of there is terrain and inside of the app we have the land and in there we have a few hundred different graphics these are all the possible Graphics that we could potentially have how the naming scheme here works you are going to see it is a very strange file if you don't know what's going on just be aware we have to import all of this once we have that whenever we are placing a Terrain tile we need to know what's going on with the neighbors and only once we have all of that we can draw the right terrain tile and that is giving us a list we can work through so let's jump into the code and let's figure all of this out here we are back in the code editor and now we have to figure out where to import all of the land tiles and here we do have to be careful because these land tiles need to be available in the editor and later on in the level as well and since there are a ton of Graphics I only want to do this once which means I want to import all of this inside of Main and then pass it into the editor I guess what we can do in here is create another method let's call it Imports need self and nothing else and then here we can import a bunch of different things the one we care about for now is self.land tiles for this one I want to create a function that I called something like import folder as a dictionary this one doesn't exist right now but it's going to exist in just a second and here we need a path to a folder for that we need to go up one folder then to graphics and in there we have terrain and inside of the app we have land if I show defolder again in here you can see we have Graphics terrain and land this is the file path we are following which means what we have to do now is to create this function and since we are going to use it quite a bit I am going to Outsource all of this to a separate file which means I want to create a new Pi file and save it as let's call it support dot pi in here as always we have to import Pi game besides that we need to have access to the file system and this we get with the walk module which we have to import from OS import walk and using this I want to create two functions the first one is import folder and this one needs a path and does a certain thing and besides that I want to have another function that is import folder as a dictionary and here we also need a path those two are going to be fairly similar so let's create them both at the same time the easier one is going to be the import folder let's start working on this one and just to illustrate what's going on let's use this one for now so I'm just importing a folder and I am going to get a ton of surfaces but I don't know the file name of each surface which in some cases I don't really care about it I guess why we're here I also want to run the import this is going to happen right at the top self dot Imports just to make sure that this is working inside of support I want to print the path also I want to add a pattern here so we're not getting an error if I run this now we are getting name input folder is not defined the reason for that is I have to import it so from support import everything now if I run this we can see Graphics terrain land and that is what we're getting from here so this one is working good start what I now want to do in here I want to ultimately create a surface list and this for now is going to be an empty list I want to cycle through whatever files we have inside of this path and then any kind of picture is going to be imported as a surface and placed inside of this list for that we have two for data in Walk and Walk needs a path so this path in here and just to see what we're getting let me print the data it's going to look slightly different if you see this for the first time if I now run off this we are getting a very very long list this list is going to contain three elements although it looks like there's much more the first element we get here this is the name of the folder this is not something we care about at all besides that we get another list and this one will contain all of the subfolders also not something we care about finally we have all of the actual files inside of this folder this is what we actually care about and this is what I want to import which means inside of this I can split this data up into three bits we get the folder name we get sub folders and then we get the image files the image files is all I really care about as a consequence let me just print the image files and let's see what we get we are getting a ton of different image files or not really image files rather it is names of image files a.png is just a string right now we have to convert it to a full path and then use this path to import the image as a surface although first of all I have to cycle through this list which means for image name in image files I want to do a couple of things first of all I have to get a full path and this full path is going to be the folder plus the file name once I have to fold path I can create an image surface and then I want to let me add this as a comment I want to add the image surface to the surface list first of all we need the folder path in here and the folder path we are getting from this path remember in main.pi we are passing in this folder path in here and this is what leads us to the folder which means the folder path is just going to be the path to that I want to first of all add slash and then I want to have the image name and just to see what we get let me print the full path and comment this one out and if I run main.pi we're getting a whole bunch of file names but in here the important bit is we always start with Graphics terrain and land then we're adding a slash and then we're getting the file name and this happens hundreds of times once I have that I can use this image path to import an image surface and this is going to be pygame dot image dot load and that should be an equal sign and I want to use my full path this is going to give me the actual surface and this surface I want to add to this surface list which means I want to have the surface list append a surface and the surface I want to append is the image surface and that is all we need all I have to do now is to return this surface list and that way all of the land tiles are going to be surfaces from this folder which means I can print self.land tiles run all of this again and we are getting a huge amount of surfaces all the stuff we have just imported although for the land tiles I need to know the file name and this one is not going to give me that as a consequence I have this import folder as a dictionary the key here is going to be the name of the file and the value is going to be the actual surface and this I think could be a really good exercise try to convert this function here so that we are creating a dictionary with key value pairs the key being the file name and the value being the surface pause the video now and try to figure this one out I think the easiest way to start is to copy all of this and now we don't have a surface list we have a surface dictionary which means curly brackets these two lines can stay exactly as they are as can full path the image surface is also fine let me remove the white space here this one isn't really necessary and finally the only real change that we have to make is now we have a surface dictionary and for this one I want to have the file name and for the value here I want to have the image surface so I can delete this one here as well one more change that we do have to make this shouldn't be file name this should be the image name the image name right now would be something like a DOT PNG and this dot PNG is going to be kind of annoying so I want to get rid of it which I can do with the split method I want to split this string wherever we have a DOT this is then going to return a list with the file name and the file ending in this case I only care about the one with the index 0 which is always going to be the file name without the file ending after I have that I can return the surface dictionary and we should be done if I now use import for that dictionary and run the entire thing I now get a really large dictionary that always has a key with the name of the file and then an Associated value which is the surface which seems to be working just fine cool with that I can close the support file because we don't have to change it anymore with that we can import a bunch of things quite easily and now when I'm creating the editor I want to pass in self.land tiles which means inside of the editor we need another parameter which is going to be land tiles on top of that let me add another section here that I call Imports I want to store my land tiles as an attribute inside of the class and tiles so now we have a bunch of Graphics that we can be using and we could already implement this to an extent at least when I'm drawing the level I only care about terrain right now let me minimize everything else in here for the test surface we could actually use self.land tiles and a generic one in here is the one with x I could just use that and don't fill it with a color and now if I run this and I let me show my mouse and I draw a Terrain you can already see a graphic which is not looking bad at all the problem is you can see it quite easily all of those look identical but that is not something I want for example for this title here I want this to have something like this where we have a connection to this tile and to this tile and also to this tile here we have to always find the neighbors for each of these terrain tile and then get the appropriate graphic which is going to be a fun little topic to work on let's have a look basically what we have to do inside of canvas tile we have to fill this terrain Neighbors and for that we need a bunch of logic which I have stored in a separate method inside of the support section I created a method called check Neighbors there is one parameter we need in here and this is going to be a cell position the most important thing we have to do in here as the name of the method applies we have to check the neighbors obviously but there is going to be a problem and let me draw the issue actually let me add pass in here and run this entire thing again and I'm going to draw a whole bunch of terrain tiles all of that something like this now we have a ton of different terrain tiles and now I want to add a new tile in here and this tile needs to check what its neighbors are doing which in this case would be I want to check these three tiles here and then change this tile here the problem is I want to make sure that I am only changing this grid here the cells that are surrounding the current tile I am working on what I do not want to do is check every single terrain tile that we have because we could have thousands of terrain tiles I do not want to check all of them and as a consequence I want to create what I called a local cluster and those are the terrain tiles that surround the current tile we have just placed sounds a bit complicated it's not that difficult to implement but first of all I wanted another comment and I want to create create a local cluster and then here first of all I want to create a cluster size which I have set to free and from that I want to create my local luster and this is going to be a list comprehension what I want in here if this is the current cell I'm working on this would be my cell position I want to know this style here this tile here is tied here here here here here here and here so by the end of it we have eight tiles that we are going to look at I guess nine theoretically because this one is going to be included but this one doesn't matter so much also the cluster size here refers to this distance here and this distance here we have a cluster that is three by three columns at rows you could make this larger if you really wanted to but there isn't really a reason to I guess the one thing you want to be careful here if you're placing a new tile here it might change existing tiles for example if this tile before we place the yellow tile was a top tile that looked something like this after we are placed in the yellow tile it needs to be a bottom tile once I Implement all of this it's going to make a lot more sense I want to place let's say a tile which is just going to be a string for now but that is going to change or call in range cluster size this is going to give me the columns and then again I want for Row in range Laster size as well just to illustrate what is happening right now let me for Row in local cluster and print row now we have to figure out when to call this check neighbors and this is going to be called whenever we use canvas add I want to run self dot check Neighbors this cell I want to pass in here is the current cell now if I run the entire thing press anywhere we are getting a bunch of tiles okay it's not particularly helpful but if I minimize canvas add and just print the local cluster that might illustrate a bit better what's going on print local cluster and click anywhere we're getting a list with nine different tiles because we have three columns and three rows we are going to get nine items in total what we now have to figure out is the actual position for each of these tiles and this is always going to be a tuple with a row and a column although here we do have to account for quite a bit although let me print it right now if I do it like so we're always getting from 0 to 2 and 2. also I want to put this over multiple lines so it's easier to read and fits on my screen there we go I think this is going to be a bit easier for the row and by the way I think this could be a really interesting exercise what I want to do in the end is if I for example click on let me use a simple number if I click on this tile here I want a local cluster to be these tiles the top left one is going to be 0 and 0 then we have one and zero and we have two and zero and so on the same thing this should be zero and one and zero and two and then down here we have two and two right now this is what we always get however if I now add a tile let's say here the local cluster should be this area with this bottom one here there should be negative one and negative one then we have negative two and negative 1 and negative three and negative one and so on these numbers here always have to be relative to the position you just placed you basically want to create a row and a column that is always relative to the sub position and then circles around the cell position so positively now and see if we can figure this one out all right let's get started and I realized already this should be column and row because this one is X and this one is Y which is how our position also works this column right now is always going to be 0 1 or 2 because of this range here this number we want to add to the cell position and I want to get cell position and X the same thing I want to do for the row so let me copy the entire thing paste it in here and this should be a one if I now print the entire thing let's do it somewhere here we're getting the start position here one and one and then keep on going down so we are making progress although if I am drawing what we're doing right now if I place it here again and give me a bit of space this is actually working very good the first cell I get is one and one which is this one here then I'm getting 1 and 2 which is this one here then I'm getting one and three this one here then I go to the next row which is this one here and here we're getting these three cells which is 2 1 2 2 and 2 3. finally we're going to the third row here we have three one three two and three free which means whatever terrain we are placing we always get this area here which is a good start but not exactly what we want the area we actually want is this one here to fix that we have to move the entire local cluster up by one cell until left by one cell or more specifically and to be a bit more flexible I want to subtract it by the cluster size divided by 2 and then I want to have the integer this I want to have both for the column and for the row and now if I do this again and draw for example a tile here and move it to the side again the first tile I'm getting now is one at one which is this one and one here the final cell I get is free and free which is the one down here which means the entire thing now is this area exactly what I wanted so we are making some really good progress now that I have that I can actually check the neighbors with that first of all I want for cell in local cluster I want to go for all of the cells I have just created and now I want to check if cell is in self dot canvas data meaning I want to check if any of the cells I've just created actually exist and have a Terrain tile or exist in the first place for now if that is the case I can get myself dot canvas data and pass in the cell I am currently looking at and whenever we start this I want to set my terrain neighbors to an empty list that way if we are running this check neighbors multiple times we're not adding pointless data in here which can be very problematic and once we have all of that we can actually check the neighbors of all of the tiles inside of this local cluster if this is the tile we have currently placed we have to check all of its neighbors all of the eight neighbors it can possibly have on top of that for all of the neighbors so all of the tiles in our local cluster these tiles here they also need to check what their neighbors are meaning once again we have to check what their neighbors are doing which means for every cell in local cluster if it exists we want to check all of the neighbors and for that inside of settings let me minimize the editor data we have neighbor directions inside of this dictionary we have a key a and then a position the way you have to think about it if this is the cell we are currently checking a is the one on top then we have b c e e f G and H the keys we have here these are all the four possible directions and this is what I want to check for which means in here I want to check for name and site in neighbor directions dot items don't forget that I want to get my current neighbor cell just to make the math a bit easier and this neighbor cell is going to be a cell I'm currently looking at and in here again we need X and Y so let me do cell zero and cell one right now we are copying the cell but that's not what I want to do instead I want to add a side which here is going to be side 0 and for y it is going to be side 1. aside as a reminder is always this position here for example for a the cell right on top if we're going zero for the xaxis and negative 1 for y we are staying here for x and we're just going up by one cell if we for example use D we are going one to the right this one here and then we're going one down this is this one here and that way we're ending up in the bottom right which means with this line we are getting the current neighbor inside of this for loop on this neighbor cell I first of all want to check if it exists in the first place so if neighbor cell in self dot canvas data if it's not in there there's no point doing anything because there is no cell however if there is one we can check if self dot canvas data I want to get the neighbor cell and now I want to check if it has a Terrain if that is the case I want to get myself dot canvas data and to sell I am currently looking at I want to get the terrain neighbors and I want to append the name this name here that we are looking at if we have a tile here and there's one tile on top only this tile would mean we are adding the letter A to terrain Neighbors and what that means if I open the graphics folder again here we go inside of this folder we for example have a and if we only have the terrain neighbor a it means this is the tile we are currently looking at and there's one tile on top and as a consequence we want to have a tile that ends at the bottom and that is all we need here I am fully aware that this logic here does get quite a bit more advanced so if you're following this there's a pretty good chance you're confused definitely go over this a couple of times to understand the logic but for now this is all we need so I can minimize check Neighbors and now when I'm drawing if tile has terrain I first of all want to have a Terrain string and this terrain string is going to be the title I'm currently looking at and then terrain neighbors this right now is going to be a list this list I want to convert to a string which I do with an empty string and then the join method although there's one more thing that we have to do let's say I want to have a Terrain Style this is not going to be self.land.x instead this is going to be the terrain string but only if the terrain string is in self.land tiles if that is not the case I want to add X what that means is if the terrain string we have created doesn't exist in the graphics we have imported I want to have the generic graphic X that basically always works this is both a safeguard so if we forgot to import one graphic the game doesn't crash on top of that some tiles are just by themselves and I didn't really account for that they are just way too many graphics and this way if they're by themselves we always have this outcome and we are nearly done the last thing we need is now I'm using this terrain style as a key to get the surface so terrain style in here and now this should be working let's try and let me show my mouse if I now print something we are getting something that almost Works uh not great yet but we have to work with this a tiny bit more let's have a look on the editor I'm pretty sure draw level works just fine because we are getting something so let's have a look at Czech neighbors and I can tell the error happened in here in the neighbor cell because this side should be one not zero now if I try this again and let me show my mouse again if I now draw on here we have a proper tiling system and this one is looking really good also if I move around all of this is still working just fine and with that we have the terrain I am really happy with this and this system is really satisfying cool so this covers a really large section before we finish with this part I do want to go over the main logic and just quickly explain it again I think this is a really important part that you absolutely have to understand inside of the editor Let Me minimize everything our starting point is always the canvas add method in here we are adding something to our editor these lines here in particular are the most important ones because in here we are creating a new canvas tile or we are adding to this canvas tile depending on what id we have after that we are checking all of the current neighbors and this is really important especially for the terrain tiles because this one determines the graphic of the terrain tile so let's have a look what check neighbors actually does and how it works first of all we are creating a local cluster think of if this one here is the title we are currently looking at we need to know all of the neighbors there are eight Neighbors in total that we are going to care about these eight here and that information is incredibly important because whenever we are placing a Terrain tile we need to know what its neighbors are doing for example if a Terrain tile has something on top it needs to be a bottomish tile and if there's a tile on top and a tile below it should be some kind of connector tile something like this that is open both on top and on the bottom also really important here why we are creating a cluster is later on in the game we might have thousands of terrain tiles and we don't want to check all of them we only want to check the ones that are right next to the current tire and this is why the local cluster here is incredibly important now once we have that what we need to do is to go for every single of these local tiles that we have created that is important because when we are placing a new tile let's say we are placing this yellow tile here if there's a tile to the right of it this one here this one needs to change as well if this one for example previously was by itself now if there's a tile on the right the yellow one here then this one needs to be open to the right and as a consequence we have to check for every cell in the local cluster we have to check all of these tiles here that is super important let me clean this one up a tiny bit so we can see what's going on on the next line we are checking if the cell is inside of the canvas data and once we have that we are creating an empty list for the neighbors and this list is going to contain some letters that are going to be important I'll talk about that right now actually what we're doing in this bit here most importantly for a name site in neighbor the directions and the items how this one is essentially going to work for every single one of these tiles we're going to check all of the neighbors the top neighbor would be a the top right would be B then we have C then d then e for the one right below then we have f d and H and essentially what we're doing we're going clockwise for every single tile inside of the local cluster and we are checking what neighbors are there and depending on what neighbors are available we're going to add the relevant number to terrain Neighbors let's say a tile has the neighbors a c and d then the strings we are going to attach in here are going to be a c and d all of that is happening down here which means by the end of it the terrain neighbors is just a list with a couple of strings inside and each string is one letter once we have that bit of information I can open the graphics folder again go to Graphics in here we have the terrain then we have land and inside of there we have all of these files with weird names but I hope now they make sense for example if we have a tile let's choose one it's a bit more random let's go with this one here this one is called CEF this means if we have a tile here we want to check if there's a tile in not in a not in B but there should be one in C then not in D but then in e f but not in G or h this CEF is going to come from the c e f depending on what the neighbors are that is how the entire system is going to work and that is also why there are going to be a ton of different Graphics in here on top of that there are quite a few duplicates in here for example if you check these two they are identical you could probably optimize this entire system quite a bit but in my case I'm not too concerned so all right the last thing we now need is to understand the system when we are drawing the level and we have some terrain like this one here we are combining the terrain neighbor strings into one larger string then we are checking if the string is inside of the imported graphics if that is not the case the string name is going to be x and x is if I open this again all the way at the bottom we have this tile here this one fits basically everywhere oh well it doesn't fit everywhere but it looks fine by itself and then this is going to be the graphic we are blitting on the screen I hope all of that makes sense the logic here does get a bit more complicated all right with that we have our terrains next up we can start working on the water let's talk about the water now and the water is going to work quite a bit like the terrain we again have to import some graphics and then check the neighbors of every tile and then we can draw the water although the water is going to be a little bit easier all we really care about if we have two water tiles like so the top water tile should have a water animation whereas the bottom water bit should have a plain graphic this one doesn't need to be animated for this section we are going to have the bottom graphic and we are going to know if we need a top graphic animation but the animation itself we are going to cover in the next part I want to keep things separated and the animations are a larger bit by themselves but we already have all the major Concepts in place so this shouldn't be too difficult let's Jump Right In once again we are in our code and I want to work inside of the editor I guess you could import the water surfaces in here like we have done for the land tiles although there aren't that many water tiles so I'm going to do all of this inside of the editor to keep things a bit cleaner and more selfcontained inside of the editor what I want to do in here since we are going to import a few more things I want to create another method that I called import all we need in here is self and water bottom and this is just going to be a graphic we want to load for that I want to have the load method that is not available right now which I can fix quite easily I want from pygame dot image import load only now is a file path to my water bottom file this one if I open the graphics folder and make this a tiny bit smaller we have to go through Graphics inside of there we have the terrain and inside of the terrain we have water and there we have animation and water bottom water bottom is what we care about right now which means we have to add a string go one folder up then to graphics then to terrain and there we have water and in here I care about water bottom dot PNG water top we are not going to import right now because later on for the animations we are going to have separate Logic for that meaning for now this is all we are going to need don't forget to call it and this I have done after I have imported the lamp tiles I guess it kind of makes sense in here self dot Imports I think this was just import yeah just import let me actually self.import and now we have to figure out a few more things most importantly we have to work inside Czech neighbors one more time because in here we are checking the neighbors right now all we're doing in here is we are checking the neighbors of the terrain tiles let me actually add a comment in here to rain nay verse besides that I also want to know if water top neighbor exists to figure out the top neighbor here we are going to need a couple of things although before I am doing this I would really recommend you to try this one yourself you kind of have to modify the logic here a fair bit to figure out if there is let's say water in the current tile and another water tile on top if these conditions are true you know the tile on top has water if that is the case if I look at the canvas tile again in there we have has water this one we can already cover but what we care about is if we have to set water on top to true or not this is what we are trying to figure out however if these two conditions are true then we can set water on top to true so pause the video now and see if we can figure this one out yourself I want to check if self dot canvas data and now I want to look at the neighbor cell that's the one we have created up here on this one I want to check if it has water on top of that I want to check if self dot canvas data and my current cell that is the cell we are checking from the current cluster and that's basically our current cell the one that we are working with right now if that is the case I know one of the neighbor cells has water but what I care about here in particular is if this cell is on top of the current cell and that I can check with another condition the condition being if name is equal to a there you can see it all this works because if I go to settings in here we have the neighbor directions and a is the cell right on top or in other words it's the top neighbor this is the only one we really care about if that is the case I want to get self.canvas data and my current cell on this I want to set water on top to true on top of that there's one more thing that I do want to do like we have done with the terrain neighbors I want to set self dot canvas data and sell water on top should be false meaning every time we are running this we first of all remove all of the neighbors that makes it much easier later on when we're deleting tiles to not worry about this again the reason why this one is important and let me remove the comments here if we didn't have these two lines later on when we are deleting tiles we would have a problem let's say you have two tiles of water and as a consequence the top tile here has water for the animation on top of that the bottom tile here this one would have water on top being true however if we delete it this top tile the bottom tile would still have water on top as true and as a consequence the graphic now would be wrong the same would happen with the terrain neighbors and all of this can be avoided with these two lines here we are basically resetting the entire system and then recreating it from scratch and that way later on when we delete things this makes everything much easier so with that we have the neighbors for the water or the one neighbor all we need now when we are drawing the level we have to account for that and this happens inside tile has water in here I want to check if tile water on top if that is the case I want to get myself dot display surface and I want to split something once again I need a surface and I need a position the position we already have that's the one we created up here the surface we also have that's the one we imported in self dot Imports this one here which means all we have to do now is self.water bottom I think I called it and that is literally all we need I guess one more thing that we do need is the rest should be inside of an else statement and I'm going to change the color to make this a bit more emphasized let's change this to a red color so it's definitely visible now let me run main.pi again and we are getting an error that we have some problem in selfimport and I believe I know what the issue is import is a restricted name because we are using import here and that one confuses python let's change it to Imports and that should fix the entire thing there we go this is much better now if I show my mouse and I switch to water we are getting a key error let's have a look I think I already know where the issue is it is definitely going to happen somewhere in here and while we are here I realized on this self canvas data and cell we want to check if this one has water the main problem we have right now is when we're using the neighbor cell on canvas data this tile does not exist that wasn't a problem for the terrain neighbors because they have we are checking if the neighbor cell was in the canvas data this if statement we want to do for the water as well like so and this one has to be indented and now this should be working we are only doing this operation if the neighbor cell actually exists now let's try this again and let me show my mouse again right now I have the terrain and this one works just fine if I now change to water we're getting a red cell but now we're getting a water tile and the water tile we are only getting if we have water on top if we don't we don't get that and this one also updates perfectly fine so this is a pretty good start for the water definitely a good start and sorry about the errors it's kind of hard to keep this much code organized and explain it at the same time but with that we have the water or at least parts of the water what we know to figure out is a bunch of animations and that's gonna be its own section for the next part we are going to create the animated tiles in the game there are lots of tiles that can be animated like the top water the coins and the enemies those are the main ones there is also going to be the player and the palm trees but those are going to be objects not tiles welcome to those later in this tutorial now for the animations to work we first of all have to import a ton of different graphics after that we have to figure out how to animate all of these separate objects and for this one we are not going to use Sprites you might actually Wonder so far for each tile why am I not using a Sprite for example each terrain tile could be a Sprite the answer here is that Sprites are generally fine but in the editor we could potentially have thousands of items on the screen at the same time and for that Sprites would be very slow and avoiding them improved game performance significantly when I tested all of this if I remember correctly when I use Sprites you could only place about two to three hundred terrain tiles and then the game would slow down drastically if we don't use Sprites we can place up to a thousand and not really have performance issues although later on we are going to use them to an extent but alright with that covered we can start working in the code once more we have main.pi again and once again I want to work inside of the editor Let Me minimize everything and I want to add a bit of white space Here and Now work in Imports again what I have to do in here I have to import animations let's just call it animations because we already importing in here anyway essentially what I want to have I want to have a dictionary that I called animations for now it's just going to be an empty dictionary inside of it I want to have something like this I want to have first of all a key let's go if I look at settings we can look for example at the water and the water would have an index of three this three I want to keep here and then the associated value is going to be another dictionary with three items we have a frame index and this one is always going to start at zero then I want to have the frames and those are going to be let's say it's going to be a list and this list is going to contain surfaces the surfaces we're going to Loop through for the animation finally the last thing I want is going to be the length of the animation and this could be an integer let's say four or rather for the water we have three animation frames once we have all of this we can create animations fairly easily first of all I need for key and value in editor data dot items meaning we are looping through this entire thing here inside of that I want to check if the value has an entry for graphics and only if that is the case I guess let's talk about Graphics first if I look at settings for example for water and I scrolled to the right quite a bit all the way at the end we have a graphics key and the associated value is a folder for the water it would be the animation for the top this is what we care about here for example for the gold coin that's this one here we have a folder for the gold coin and all of these contain animations and this is what I want to import which means first of all I want to create a graphics variable and now I want to import a folder like we have done in main.pi let me copy from support import everything and this I want to do in here as well and let me add a bit of white space all of this is a bit easier to understand the file path we are getting from value graphics there we go and with that we have Graphics imported next up we need to actually create an entry inside of this dictionary for that I want to have self.animations and now I need a key the key I am already getting from this one so I can just pass in key in here the value I am going to give it is going to be another dictionary the dictionary we have created here or we are going to create we always start with a frame index and this one is always going to be zero after that we want some frames and the frames are going to be the graphics finally I want to have the length of the animation and this is just going to be the length of my frames which is going to be the length of the graphics folder that is all we need I can now delete the example and print what we actually get print self dot animations if I now run all of this you can see if I for example look at the first bit we have zero and this one has a bunch of different things this is all the stuff for the player that's not what we care about right now I guess this one here is better we have three that's the one for the water we have a frame index of zero then we have frames and this is a list with three items these free bits here and finally we have a length this one is telling us when we have to stop the animation and start again that looks really good with that I can minimize let me first get rid of the print statement now I can minimize the Imports method what we are now able to do inside of draw level we can start using these imported Graphics let's start with water first of all in here I want to have the frames more isolated and those I get with self dot animations and I know the water is always going to have the index three so I can just pass it in here and from that I want to get the frames this is going to give me the water animation frames besides that I need to have some kind of index because this here is a list and we have to pick one item from it for that we have self dot animations the same entry again for the water and in here we want to have the frame Index this one we're going to increase over time and if this for example gets to one or two we're going to pick a different item by default it's going to be zero although since this value could potentially become a floating Point number I always want to convert this to an integer finally let me get rid of these two items here and instead I want to create another surface and this is going to be frames and index finally all I have to do is get rid of this test so we're using this surface here and now let's try if this is working I can still draw terrain just fine and now if I print water we are getting at least a proper graphic so this is already definitely some progress although not entirely what we needed but at the very least this one is working all we have to figure out now is how to increase this index over time for that I'm going to minimize draw level and inside of support I need another method this one I called animation update and then here we need self and we need Delta time all I really want to do in here I want to go through my self.animations dictionary although for this one I only really care about the values which means or value in self dot animations dot well use in here for each value I want to get the frame index and this I want to increase by what is called the animation speed this is a constant that I have defined inside of settings it's always going to be eight although you could change the number if you feel the animations are too fast or too slow and this value I want to multiply with Delta time that way its frame rate independent if your game slows down or runs really fast the animation speed is going to be the same finally we have one more problem and that is if value and frame index is greater or equal than value and the length of the animation think of it like this the frame index always starts at zero and we are increasing this number by a small amount on every single frame let's say by 0.2 which means on the first frame we have zero then we have 0.2 and we have 0.4 let me separate this properly and so on this is fine for quite some time at least a couple of frames however quite fast we are going to get a number that is let me put it on the next line we are going to get a number that is let's say a 7.2 completely random number the issue with this 7.2 is that we only have for the water we have three animation frames and since we are indexing later on this 7.3 is going to cause an error because we are trying to get a larger index that exists inside of a list which is going to be an issue that we have to account for accounting for it is very easy though I just want to get my value frame index again and set it to zero which means every time the frame index gets created in the length of the list so we are exceeding the animation we want to restart the animation with that we have the animation update all we have to figure out now is when to call it for that let me minimize it inside of the run method we only have a drawing part right now I want to add I'm going to call it updating as a section in here I want self.animation update don't forget to pass Delta time in here and now we should be done actually if I now run this again show my mouse the terrain tiles work just as before and now for the water we have animations the bottom ones still work just fine and I can add things and have all of this work perfectly fine and the reason why this is working if I look inside of draw level again we still have the same logic here the only difference now is that this number keeps on increasing at the start it is always going to be zero but because of Animation update this number gets larger and larger although at some point if we're exceeding the length of the animation it goes back to zero but that is literally all that this one is doing with that I can minimize hairspot it has terrain because those two are done and now what we have to do is cover the coin and the enemy and those two I think would be a really interesting exercise for you inside of the dictionary there are coin animations and they are enemy animations try to draw them with the animation and see if you can figure this one out let's start with the tile coin in here once again we need to get some frames and the frames I want to get in here is once again self dot animations the same thing we have done for the water up here although now for the coins we are not entirely sure what kind of index we have because title coin could be either 4 5 or 6. the number here depends if we have a gold or silver coin or a diamond fortunately that's not really something we have to worry about because we can just pass in tile.coin in here because this one stores the number four five or six depending on what coin we have and on that I want to get the frames with that I have the graphics next up I need the index for that I can just copy the line we have created up here and change the three to tile and coin I can get rid of this test surface and replace it with frames and my index I also don't want to fill anything anymore instead I want to get the surface and get the position and then we should be almost done there's one more thing we have to do but we should at the very least have an animation if I run this again and select a coin I can place some coins also now if I select the silver coin I can't draw them and if I draw them over gold coin the gold coin disappears this also works with the diamonds so this is working really nicely on top of that if I pan around this also works with the panning around however let me actually run this again if I only create one coin the problem you can see right now is that this coin is always in the top right corner instead it should be right in the center which means we have to make a few more adjustments the way I approach this I have created a rectangle and for this one I want to get the surface we just created and then get underscore wrecked I want to place this center for the center we need an X and A Y position although we already have that to an extent we have position 0 that's the X bit and we have position one that's the way but this is what we have created up here the problem is these two numbers are too far to the top left let me draw a tile that looks like this these two positions are this top bit up here and since the surface doesn't cover this entire area we are placing the surface here which is why the coin is in the top left of each tile to account for that I want to move the center of the coin so this Center here to the middle of the current tile for that I have to get the top left move it to the center or increase it by half of this entire width the same thing I have to do for the height this is going to be one half of the entire thing if I do that this top Point here is right in the center and this is exactly the point I'm looking for which means all I have to do is to add tile size and divide it by two the same thing I have to do for the Y position and now what I'm placing all of this with blit I don't want to have a position I want to have a rectangle let's try it now and now if I place the coins this is looking much better also works with the other coins and with the diamonds and big nozzle pan around all of this looks pretty good I can also still place the terrain and I can place the water oh this is looking really good finally I can minimize the tile coin and we have to work on the enemies although truth be told this is going to be quite some luck compared to the coins so let me copy a bit of code here although I guess you could make this a tiny bit more efficient but in my case I'm not too concerned fourth childhood enemy we want to have tile and enemy and then the frames for the index we also want to have the enemy index surface can remain identical though and the center we probably have to change in just a bit but for now let's see what this one is actually doing if I now select one of the enemies this is the bottom right bit here I can now Place some spikes this one's looking good I can place this little guy here he animates and we can place the shells also the shot can go left or right most of this is looking pretty good although we do have a bit of a problem and that is this area down here right now all of the shells are floating and there's a tiny Gap below the enemy this I do have to account for which I'm doing inside of this line here what I want to do now I want to place the mid bottom if you imagine that this is the cell and this is the top left part of the cell this used to be our origin point now what I want to do is this mid bottom is going to be this point and this is what I want to have for the origin Point as a consequence kinda similar compared to what we have done with the coins we have to go halfway one half to the right except now we have to go the entire height down so just one the entire height of the tile and then we're ending on this point here which means for X we don't have to make any kind of change only for y we have to get rid of the divide by two and that should be all if I now run this again I can select some spikes they still work just fine but if I now place an enemy he is right on the bottom and most importantly the shells are also on the bottom and that is looking really good cool so with that we have the animations there's one more really important thing that we have to cover and that is deleting tiles for now we are only able to add more tiles but well we couldn't get rid of them let's work on that and that's not going to be too difficult so we can jump right in once again we are in main.pi and I want to work inside of the editor in here inside of the input section I already have canvas add I now want to add canvas remove neat self and nothing else and the first thing we have to check in here is if we are right clicking on the canvas and if we are not clicking on the menu this means I want to check if Mouse buttons don't forget to call it and two this is going to be the right click and not self dot menu Dot rect and Collide point with my mouse position and it should be fairly obvious I only want to delete tiles if I am right clicking and if I'm not clicking on the menu if that is the case I first of all want to check if self dot canvas has any kind of Entry if it doesn't there isn't any point in deleting anything if that is the case however I want to get my current cell that I get from self and get current sell once I have that I want to check if the current cell is in self.canvas data now I know that I have right clicked somewhere on the canvas there's something inside of the canvas and I know the position of where I have clicked if where I have clicked actually targets an existing tile I want to get this tile so self dot canvas data and the current cell and on this I want to remove ID with self.selection Index this remove ID is going to work kind of similar compared to ad ID if I scroll down a tiny bit and minimize the init method we have ADD ID remove ID is going to be another method that has the same parameters and is kind of going to do the opposite once again I want to get my options I can just copy them and besides that I can actually copy the entire thing because we are going to check for every single kind of option we have here I should probably explain for the tile delete Logic the way deleting is going to work is we can only delete the currently selected tile index for example I only want to be able to delete terrain if I have terrain currently selected same for water same for the coins and so on that way I have some control over what I am going to delete all I have to do in here now is when I'm removing something I'm going to set terrain and has terrain to false the same thing I want to do for the water this one should be false self.coin should be none and self dot enemy should also be none there's one more thing that I do want to check this I have called is going to be another method self dot check content let me create it right here again what this one is going to do is if all of these cases are false meaning on this current tile there simply is no data I want to delete this entire tile the problem is I cannot do this from inside of the tile because all of this is stored inside of self.canvas data the dictionary which means for now inside of this check content I want to have an attribute that is called self dot is empty if there's nothing left inside of this tile meaning all of these cases are false or none this one should be set to true that being said by default inside of the init method let me do it all the way at the end self dot is empty is going to be false all I have to do now is to figure out when this is going to be empty and that is basically just a bunch of if statements so if not self dot has not water but Terrain and not self.s now we have water and not self.coin and node self Dot and me if all of these are wrong I know this one is going to be empty once I know that it is going to be empty inside of canvas remove I can now check after I added a bit of white space if self dot canvas data and my current cell if this one is empty then I want to delete this current cell or the entire key value pair like so and then I am done let's try this actually so inside of the event Loop besides cell dot canvas Edge I also want to have self.canvas remove and I guess I could add a bit of white space here to make all of this a bit more spacious cool so now inside of main.pi I am getting an error that I made a typo this one should be delete not Define never on this again this is looking good and I can place some terrain tiles and now if I right click we are getting an error this remove ID we have a problem the reason here is this should be remove ID now if I play some terrain tiles I can right click and it disappears although you can see a problem we have to call check neighbors again to update this entire thing otherwise it would look a bit weird but that we can do quite easily if I minimize canvas tile after I have run all of this I want to run self.check Neighbors in here don't forget I have to pass in my current cell although I messed up the annotations here a tiny bit those two should only be run if we are or if the current cell is in the canvas data otherwise this line here might cause an error because this tile might not exist but with that let's try all of this one more time I can place some terrain tiles and now if I right click they disappear and this is feeling really good I can keep on adding and removing also now if I add some water I can also remove this and it updates perfectly fine and now to understand the system if I place a gold coin like so and if I right click now on the water the water isn't being affected but if I go over the coins the coins are affected that way I have quite a bit of control over what I am going to delete which I quite think is useful well with that we have been making quite a bit of progress this is definitely a very satisfying system or the next part we can start working on the objects and let me explain what that is going to mean so far we only worked with tiles those are always going to be placed in a grid however some objects in the game are supposed to be working differently and those are going to be called objects these can be moved flexibly anywhere on the screen the best example here is the player this one needs to be moved anywhere wherever we want and I think the best way to think about it is to actually illustrate it so let me run the finished game this one here and here you can already see we have the tiles just as before and I can also Place water tiles all of this is what we already have however now we can move the player around wherever we want there is no limitation in terms of tiles the same thing is also going to work with the sky so the sky we can move up and down as we want there's no limitation in terms of tiles furthermore we have the palm trees and those can also be moved around freely because for those let me place a few more those just don't really fit exactly on a tile grid I want it to be more flexible here and all of this is what we are going to implement via objects so this is what we have to work on all of this though is going to require quite a bit of additional logic so let's Jump Right In and let's cover all of it here we are back in the project and once again I want to work inside of the editor in here we need some kind of object that can actually work as well an object and in my case I have used Sprites for that so fundamentally we have two different things to draw the level we have all of the tiles those are the canvas tiles and besides that I want to create another class this one I have called canvas object and importantly here this one is going to be a Sprite so we have to inherit from pygame.sprite dot Sprite as a consequence the first thing we have to do is declare an init method and here we need itself besides that we're going to need a position we are going to need some frames as well because the objects are also going to be animated besides that each object is also going to have a tile ID that way we can identify it this for example means inside of settings all of the palm trees are going to be objects and I want to store the 11 12 13 and so on for each of them that way I know exactly what kind of object I am working with besides that I also want to have an origin point this one I'm going to explain more in just a bit but this one is really important to figure out where this canvas object is placed inside of the grid finally we need a group because we have a Sprite and we need to place the Sprite inside of a group with all of that covered we have to call this super init method and pass in the group in here just to get started for now I want to create a basic self.image and this is just going to be pygame Dot surface in here we can create a surface with the size of 100 times 200. this I want to fill with a color so we can see it more easily let's go with red and finally we are going to need a rectangle so self.rect and this is going to be self.mage.get underscore rect this should also be spelled correctly in here I want to place the center wherever the position is and I am getting much worse at typing there we go with all of this at the very least we have some kind of sprite that we are able to see we just have to figure out how to place it for that we have multiple angles if I look at settings we have all of these different palm trees here we have the foreground palm trees and the background palm trees those I want to be able to select from the menu and then place anywhere on the screen however besides that I also have the player and I have the sky those are going to be on the level when we are starting the level meaning those cannot be placed they are always there as a consequence both of those have to be created inside of the init method so we already have them and that makes it quite easy to fix things as they come along so let's get started by placing the player this one is just going to be another canvas object all of this is going to happen inside of the init method in here let's do it all the way at the bottom I want to place the objects for that first of all I have to create a group this let's call it canvas objects this is just going to be pygame.sprite dot group once we have that I want to create one canvas object and that is going to be the player I suppose I could add a comment here that is going to be the player we don't actually have to store this canvas object inside of an attribute you could but there's simply no reason for it in here we now need all of the parameters that we have created in here let me copy them and fill them with some kind of argument for the position we can go Fairly random in my case I went 200 pixels from the left and then I place the player in the center of the window in the yaxis which means window height divided by 2. after that we are going to need the frames those we are getting from settings as well because in settings if I scroll down the player does have some graphics we can just use those we already have them imported those we have inside of imports and inside of the animations which means I want to get self.animations the index I'm looking for here is zero that is the player and on this I want to get the frames I hope you can remember this is what we have imported here next up we have the tile ID for the player this one is going to be zero and the origin is going to be the origin of the actual editor which means it is this origin here meaning I can just place self.orgion in here and I'm good to go inside of the class later on we are going to work with this quite a bit for now don't worry too much about it finally we need to group and this is self dot canvas objects with all of that going over multiple lines let me use named arguments so it's a bit easier to read we have the position we have the frames then we have the tile ID next up is the origin and finally we have the group much easier to read if I run this now we can't say any difference the reason is we are not drawing any of these objects that we can do quite easily inside of raw level after we have done all of this here I want to get my self dot canvas objects and draw them on the display surface and now if I run this we can see we have an object this is going to be the player we can't really see it right now but at the very least something is going to happen although the issue is if I pan around you can see the player doesn't update or doesn't pan around with the rest of the level which is something we do have to work on all of that is going to happen inside of the canvas object or at least most of it is I am going to add a movement section here like so and this one is going to first of all need self and distance to origin this is a really important thing we have to know and this needs to be a vector with the distance of my current object let me draw this actually I want to know when I am placing or creating the Sprite we have the entire window and somewhere in here we have the Sprite besides that we have the origin somewhere here what I want to know in distance to origin is going to be this distance here we have done this earlier so it shouldn't be too difficult the math here really isn't too challenging all we need is a vector of self.rect and top left and from that I'm going to subtract the origin this is the origin we're getting from the parameters which is the origin we are passing in here which is the actual origin up here of the level or the editor once I have that bit of information I can create another method let's call it pan position in here we need self and we need to know where the origin point is which means I want to pass in An Origin in here and now we are going to do basically what we have done way earlier in this tutorial which is when we are panning around meaning we have the origin point and we are moving the origin point in this direction if we now have a Sprite we want this Sprite with this origin point we want this Sprite to move in the same direction those two errors here are supposed to be identical I'm just bad at drawing to achieve that what we are going to do we are going to place the top left on the position of this new origin and then we already know the distance to the origin when we have placed it that is going to be this distance here once we have this distance we can simply move this thing around and then we have this new Vector that is going to be identical to the original I hope all of that makes sense the logic here well you definitely want to play around with this a bit but all I really want to do is I want to get self.direct.top left and I want to place this wherever the origin is and to that I want to add self dot distance to origin which means now if I do all of this again we are starting with the blue part this is the blue part I have drawn in here we are setting the top left of our Sprite to the position of the origin this however isn't enough because we need to get this distance to origin here to account for a distance and that way we go from this point to this point here all we have to do now when we are panning the entire editor this one here I want to in the panning update besides updating the origin I also want to update every single Sprite this is going to be for sprite in self dot canvas objects all I have to do in here is Sprite dot pen position and pass in self dot origin now if I run all of this and Pan the entire thing we are always accounting for the origin and that way everything works as intended very happy with this this is looking good now we can minimize the pan input and we never have to worry about this one again which means we can Flash out the canvas object quite a bit more the first thing I want to work on is the animation because I don't want to have a plain red rectangle for all of the images I want to have an animation for that animation we need frames first of all and those are the frames we are already getting we don't do anything with them right now I am for now just going to store them inside of an attribute besides that we are going to need self.frame index this we have already done some animations is the number we are going to increase and now instead of drawing a plain red rectangle I want to get myself dot frames and on that I want to get myself dot frame index just as a reminder self.frames right now is just a list with surfaces and we are picking one of those with that we don't have to fill the entire surface anymore and this should already give us something that looks much better meaning if I run minute pipe we can see the pirate and the pirate can also be panned around this is definitely making some progress all we have to do now is to create an animate method this one itself and Delta time inside of this one if you want to challenge yourself you should be able to create an animate method quite easily at this point so positively now and see if you can figure this one out first of all I want to increase self dot frame index with plus equal and then I want to get the animation speed and multiply it by Delta time once I have that I want to update myself dot image and this is going to be self dot frames in here we want to get self dot frame index there are going to be a couple of major problems first of all this self.frame index is probably going to be a floating Point number because Delta time is a very small number and if you multiply it with animation speed which I believe is eight we are going to end up with a multiplication of 8 by 0.01 or something like that since we cannot do indexing with a floating Point number I want to convert this Frame index into an integer the next problem we have is that inside of self.frames we probably have something like five to six surfaces and we're always getting them by indexing however this self.frame index is going to be larger than the length of this cell.frames very quickly and this we have to account for what we have to do in here is self dot frame index is going to be zero if itself dot frame index is greater or equal than the length of self dot frames if that is not the case meaning else I just want to keep self frame index as the frame index and that is all we need all we have to do now is to actually call the animate method inside of an update method in here we need itself and Delta time just as before and call Self dot animate with Delta time we are nearly done with the animations we just have to call this update method inside of the run method inside of updating since all of the canvas objects are going to be inside of the canvas objects group I can call it update on this one and now if I run main.pi we are getting an error the canvas object update needs Delta time which we can just pass in here and now if I run this we have the animation for the player this is quite nice although there's one more thing that I would like to add in here and that is for each animation I also want to update the rectangle that way if the surface changes too much we're not moving this thing around and this is just going to be self.mage.getwrecked again and in here I want to place them at bottom with the position being where the mid bottom of the rectangle was in the last frame this way the rectangle or this entire Sprite is always going to stay in the same position which definitely makes a small difference but that is all we need for animate now we can minimize it and never worry about it again next up we have another problem if I run main.pi again I guess I can show my mouse if I click on the player nothing is going to happen there's no way to interact with it at all right now and this I want to change the first thing I want to do is that we can drag this object around in the editor for that we need two more attributes I'm going to put them inside of movement first one is self dot selected this by default is going to be false this is just going to be an attribute that tells us if we currently have this spread selected or not besides that I want to have self and this one I called Mouse offset by default it's going to be a vector with 0 and 0. and let me explain why we are going to need this we want to move a Sprite that could look something like this on the Sprite we are always going to be constrained to moving one point say we could move this point here or at this point here or at this point here and these are all of the predefined points inside of a rectangle so we have top left top right center and so on in my case I am always going to move the top left let me get rid of the other points and this is the point we are actually going to move for the Sprite this however is a problem because when the player is clicking on a Sprite we might get a click here or here or here or here and the player expects that we don't instantly jump the top left position to let's say this point here and to account for that we have this mouse offset this is always going to be the distance between the top left and the pointer player clicked on this point we have to get every time the player is clicking on this object let me put all of this inside of a separate method let's call it start drag this one itself and nothing else in here we first of all have to make sure that self dot selected is going to be true besides that I want to have self dot mouse offset as a reminder this point is going to be the distance between the top left and the position the player actually clicked on just to make sure that you can still follow along try to figure this one out yourself this should be a very simple Vector operation don't overthink this we first of all need to get the mouse position don't forget to call it this mouse position is going to be one of these blue axes from this I want to subtract self.rect dot top left which is going to be the top left position this one here the problem we have right now is that both of these are two builds which we couldn't really work with but that is an easy thing to fix all we have to do is to convert both of them to a vector with that we know when we are dragging and we also have an offset to the mouse which means now I can minimize the method and the next thing that I want to do let's actually put this inside another method to keep things a bit more organized and this one I called drag in here we need self and nothing else if self dot selected is true I want to place self.rect dot top left to the position of my mouse although remember this is what I just talked about right now we are just placing the mouse position which is going to be this top left here this point we have to adjust a tiny bit because we need this offset here to get to this point which we can get very easily because this is what we have done inside of start drag meaning I want to subtract self dot mouse offset with that I can drag things around all I have to do is call Self dot drag I suppose we could test this one if I set selected to true if I now Run the game and show my mouse you can see the player is always going to be following the mouse this one is working really well although the problem right now is I can never get rid of the player anymore which is a tiny bit annoying which means we have to add a bit more code that we can control if a Sprite is selected or not let me set it to false again for that I'm going to minimize the canvas object and the run method inside of the input I want to have another method which I called object rack in here we need itself and we need an event for this one I want to check if the event DOT type is equal to pygame dot mouse button down meaning right now I know if I am clicking anywhere on the editor besides that I also want to know if Mouse buttons and zero that means I am left clicking somewhere on the editor if that is the case I want to look at all of my Sprites which I'm doing with a for Loop for sprite in self dot canvas objects inside of this I want to check if I'm actually clicking on a Sprite so sprite.rect dot Collide point and I want to check we can go either with the event position or with mouse position both is fine it's going to give you the same result I guess since we're using events let me use the event position if this if condition returns a true I want to set Sprite and start drag this is the method we have created just a few minutes ago this start drag here which means if I inside of the event Loop add self dot object drag with an event we should be getting something and let me show my mouse I can now click on the player and move the player around although there are quite a few different problems the first one is even after I release my mouse the player keeps on following me however if I keep on clicking I am also drawing while dragging the player meaning this is something we do have to work on this is a very strange Behavior I'm going to start by not drawing a tile if I have an object selected for that inside of the init method I want to create self dot object drag and I'm going to call this active by default this one is going to be false but anytime we have any kind of drag for any object active this one is going to be true which means inside of this object drag if this if statement is true I also want to set self dot object drag active to true this I can now use inside of canvas ad this is where we are drawing all of the tiles right now and we are checking if we are pressing the left Mouse button and if we're not colliding with the menu I want to add another if statement in here and that is going to be and not self object drag active which means I only want to draw a Terrain tile for example if we are left clicking if we're not clicking on the menu and if we don't have an object currently selected there is one more change we do have to make and you might be able to spot it if I run main.pi and I click on the player if I click for the first time we are placing a Terrain tile but if I click again nothing is going to happen the reason for that is inside of the event Loop we are calling canvas add before the object drag as a consequence we are drawing something and then we make it impossible to draw as a consequence we are drawing one terrain tile this we can fix quite easily by just placing the object drag before canvas add now I can select my player let me show my mouse again move them around and everything works just fine I am not drawing anything on the editor the problem now is I can't get rid of my player that's going to be the next bit this is also going to happen inside of object drag inside of here I want to check another if statement I first of all need to create another if statement where we are checking if we are releasing the mouse button which means if event DOT type is equal to Mouse button up however this we only want to check and this should be pygame dot mouse button up this we only want to check if we currently have something selected which means and self object drag active if these two conditions are true I know we currently have something selected and we are releasing the mouse button which tells me I want to unselect whatever Sprite I currently have selected and for that I need for sprite in self dot canvas objects once more and if Sprite is selected then I want to let's put all of this in another method that I called and drag in here once again we need the origin you will see in a second why although besides that I also want to set self dot object drag active back to false that is all we need inside of this one I can minimize it and now inside of my canvas object I can Define drag end in here we need self and don't forget the parameter for the origin the most important thing now is self dot selected is going to be false and now I think this drag and I called something else inside of the object drag ah I called it and drag this should be drag end we have drag end and we have drag end this one's looking good now inside of main.pi I can run this let me show my mouse again I can now click on My Player move the player around and release the player and now we are getting an error that error is happening inside of here because this needs to be self dot origin now let me try this again I can click on the player I can release the player and this one seems fine although now you can see it if I pan around let me do it again let me move the player somewhere here and if I now pan the player is teleporting around the reason for that is inside of the player or the canvas object after drag end we have a problem because this distance to the origin which we needed for the panning has changed so once we start to pan the player is going to be teleported around depending on where this position is to account for that I can just duplicate this line and paste it in here and now we get a new distance to origin and that way we can pan around properly again meaning if I try this now I can move the player around I can also pan and everything is working perfectly fine I am very happy with this this is looking really good there's actually only one more thing that we absolutely have to do inside of this canvas object and that is we have to store the tile ID this one is honestly super simple all we need is self.tile ID is going to be the tile ID this part is going to become really important later on but for now we don't really need it but I can't minimize the canvas objects and now we need one more thing before we can place objects from the menu and that is inside of the init method we have two objects we have to create when the editor is starting we have the player and besides that we also need the sky this is going to be a simple object that is not animated and it's basically the thing that determines the height of the sky this is also something we have to store inside of another attribute let me call it Sky handle this one is going to be a canvas object and we need a couple of different things in here the most important one is for the frames we are only going to have a single surface and this one we have to import which is going to happen inside of imports besides water Bottom I want let me call this the sky handle surface I just have to load it and then here we need a string with one fold up then Graphics inside of there we have the cursors and inside of there we have handle dot PNG inside of the folder I want to look at Graphics inside of there we have cursors and there we have the handle this is what we are going to import on top of that I forgot for both of those they need to be convert Alpha that way the game is going to run a tiny bit faster and as I'm saying this I realized if I open support again when we are loading this image surface here and this image surface here we're not converting them which is going to be really bad for performance which means I want to convert Alpha both that is going to help massively for the performance of the game with that covered we can create a sky handle and that I want to be an exercise the position should be in the middle of the window the graphic we already have and the index you can also figure out so all you really need is the position which means you have to create a canvas object that is right in the middle with this graphic here and the index you can get from the editor data you're looking for the sky and pause the video now and see if you can figure this one out we have to start with the position and this is going to be a tuple with X and Y since I want to Sky handle to be right in the middle of the window this is going to be window width divided by 2 and window height divided by two next up we have to work on the frames and in here you do have to be a tiny bit careful obviously we need self.sky handle surface the one we have imported down here however inside of the canvas object class we are cycling for a list for the animation so for the frames we don't need one surface we need a list with surfaces as a consequence this one needs to be a list with this one surface you could make this a tiny bit more fancy to only animate this canvas object if there's more or if there's a list of surfaces but in my case this isn't going to be too much of an issue next up we need the tile ID this one we are getting from the editor data and sky is one which means tile ID is one as well the origin is going to be self dot origin and finally group is going to be quite simple because we only have one group self dot canvas objects with that I can get rid of this position here and finally let me show my mouse I can click on the sky handle and move this one around I can release it and it doesn't move anymore and now I can move the player and I can also pan around all of this is working really well obviously I can combine this with terrain tiles as well and all of this is working super well there is some definite progress being made I can now minimize the init method and the last thing we are going to need for this section it is getting quite long but I want to have all of the main part of the object inside of one section when I am adding something to the canvas this canvas here I am always adding a tile but this isn't necessarily the case because sometimes I'm going to place an object which means inside of here I have to check if I am placing a tile or if I'm placing an object this I can do with another if statement I want to check if my editor data in here I want to look at myself Dot selectionindex and on this I have a type if I look at settings we have type this is either object or it can be tile for the tiles we have placed so far there's coin there's enemy and there's the terrain and water these are all tiles however for the poems we have object and this we can check specifically we're checking this in here meaning we want to do all of this only if this one is a tile I want to have all of this indented and if that is not the case so else then I want to place an object which means all I have to do is create another canvas object this one is going to need the mouse position I guess let me use named arguments I want to have the position where my mouse is next up I'm going to need some frames this I get with self dot animations in here we have self.selection index and this once again is what we're getting from import on this I want to get the frames next up we need a tile ID that in this case is just going to be self dot selection index and the same is going to be with the origin in here we need self dot origin finally the last thing we need is the group once again we only have one group we need self dot canvas objects and with that every time I am clicking on the editor with an object selected we should be placing an object although before testing this I realized there's one error this should be a comparison operator not an assignment operator and now if I run out of this and let me show my mouse once again I can now click on the palm tree and place it somewhere here and we have a new object I can also move this around and this one I can do multiple times this one is working really well we do have a problem though and that is if I hope I Mouse down and drag it around I can place a whole bunch of palm trees a substantial amount actually and well you can probably tell this isn't exactly ideal for performance so we do have to account here for quite a few different things but at the very least for now we can place different things I guess while we are here I can try to place another tile or palm tree there and I can also place the background ones it's kind of hard to see because there's no preview but all of this we are going to work on more at the very least now you can see something is working and we can definitely Place different things all of this is coming together just fine now that we have the basics of objects we can refine some things for this part I want to keep things a bit more simple I want to do two things number one there should be a timer when we are placing objects that way I couldn't drag around and create tens of thousands of palm trees besides that the player should also be able to delete objects both of these things are fairly easy to implement so let's Jump Right In Here we are back in our code and I want to keep on working inside of the editor to start with the timer inside of the init method when I'm creating all of the objects I want to create one more attribute and this I called self.object timer this is going to be a timer a class I'm going to create in just a second and when I'm creating this class I want to specify how long the timer is which in this case is going to be 400 milliseconds and this time of class I'm going to create in a separate python file and save it as timer dot pi inside of this one I as always have to import pygame but I don't need anything else I want to create a timer class inside of this I want to have an init method we need itself and we need a duration iteration should be an attribute and besides that I also want to know if this timer is active or not meaning we need another attribute by default it is going to be false there's one more thing that we do need and that is the start time which by default is going to be zero but we are going to overwrite this anyway now inside of this I want to have an activate method and I want to have it the activate method when we are activating the timer I want to set self.active to true and self dot start time is going to be the current time in the game which is going to be Pi game dot time dot get underscore ticks deactivate is going to be basically the opposite we are setting self DOT active to false and self dot start time is going to be zero with that we have a couple of basic attributes that we can use to actually create a timer this one I am doing inside of an update method in here we need self and nothing else and now to explain how the timer is going to work let's say this one here is a timeline of the entire game with this point being 0 or the start of the game when we're calling pygametime.getix we're getting some number in here it really doesn't matter what it is to create a timer I now need three bits of information the first bit is the start time this one we create up here and we are setting when we are calling the activate method let's say for Simplicity the start time could be somewhere here at 500 milliseconds so we are running this method half a second after the start of the game that is the first bit of information the second bit of information is the duration that is what we are getting up here this one is telling us how long this timer is going to last let me draw a random error and the timer I want to create is supposed to run for 400 milliseconds or a bit less than half a second with that I know how long the timer is going to last all I have to do now is to constantly check my timer and this I want to do inside of the update method down here what this method is going to do it is going to check the time constantly all the time and we are at some point going to end up with this point here which is greater than the start point plus the duration as a consequence we know this timer has run out that is the entire logic I want in here so let me clean this one up a tiny bit I guess I can keep the main drawing up there that's quite helpful inside of the update method actually this could be a really good exercise from the drawing try to create your own timer logic and see if you can figure this one out first of all I have to get the current time this I get once again with pygame DOT time dot get underscore ticks this is what I've talked about earlier this one checks the time constantly if you are here here here here here here or here and if you are wondering the difference between these two get ticks is the method itself does the same thing the difference is that disk ethics is being called constantly while this get ticks is only called once whenever we are starting this timer as a consequence those two do slightly different things once we have that I want to check if my current time minus my self dot start time is greater or equal than self dot duration and if that is the case I want to run self.d activate and the logic here I hope is quite straightforward we are checking the current time this one could be here for example right now and we are checking if this number minus self dot start time that is this number here is greater than self dot duration which is this distance here and if that's the case we can deactivate the timer now we have a timer class that we can use inside of the editor although we first of all have to import it which means from timer import timer let me run my notepad to make sure everything is working we're not crashing that's generally a good sign with that covered when I am running canvas ad and I am placing an object I only want to place the object if the timer is not active which means if not self dot object timer DOT active only if this timer is not active I want to be able to place an object and once we have place an object I want to activate this timer which means self dot object timer dot activate the one thing we need now is to actually update this timer because inside of update we have this update method and this one isn't being called right now this I am going to do inside of the run method in here we have an updating part and inside of that I want to call self.objecttimer Dot update and this should be all we need if I now run main.pi again and select a palm tree I can now only place them every so often I cannot drag them like crazy anymore I can still place a huge amount of them and if I draw too many performance is going to suffer although it is going to be much less bad than it used to be so I'm kind of okay with that what we have to work on now is to give the player the ability to delete objects and for that we already have a method called canvas remove although in here we are only checking if we want to remove a tile or not meaning we have to make this thing a tiny bit more flexible let me put all of this stuff here under tiles or rather delete tiles besides that I also want to have delete object to delete an object we first have to know if there is an object selected so we know that we have an object that we currently are targeting this object I want to store in a separate variable let's call it selected object this one we can't get particularly easily right now as a consequence I'm going to create another method this I called Mouse on object this I'm going to create inside of the support part Mouse on object we need self and nothing else and all we are really going to do in here is we're going to check all of the Sprites or Sprite in self dot canvas objects and I want to know if my mouse is currently on any of these Sprites which I get with Sprite dot rect dot Collide point and my mouse position if that is the case I want to return the Sprite that is all I need in here and now if this is the case if we have a selected object then we can do something and the thing we want to do is get this selected object and destroy it with the kill method I can run main.pi and if I now left click on the player the player disappears same with the sky handle and I think you can already tell where the problem here is the player should not be able to delete the player or rather the pirate for that I want to add another if statement and that if statement is going to be could be a good exercise actually make sure that the player is only able to delete the palm trees all of these here the player should not be able to lead ever the player or the sky and when I say player here I mean the pirate I hope that makes sense try to figure this one out it should be doable inside of this one line of code that the player cannot get rid of the pirate or of the sky pause the video now and see if we can figure this one out I want to check if inside of the editor data I have a selected object dot tile ID remember tile ID is inside of settings and I can close the timer we don't need it anymore inside of settings we have all of these keys and this is telling us what kind of object we have inside of each of the associated dictionaries we get a certain kind of style this is what we want to check for meaning I want to check the style and only if this is not in the player or in the sky only if that is the case I want to delete the object which means now if I run main.pi and I left click on the player nothing is happening anymore although I can still drag the pirate around however now if I place a palm tree and right click on it it disappears this I can do multiple times let me place a couple of palm trees they all disappear if I right click on them and with that we have made a ton of progress this is all we need inside of this method for the next part we are going to create a preview and this basically means right now it is really hard to tell what is currently being placed as a consequence there should be a preview so the player knows what kind of tile or object is going to be placed however there's one caveat and that is if the player hovers over an object there should be an indicator that this object can be dragged in my case what I went with if we have an object here I want to draw some indicators around it these pinkish things are going to be the indicator this is what we are going to do all of this is going to happen inside of one method inside of the editor so we can all cover it in one part so let's get right to it once again we have main.pi but I only care about the editor inside of here I want to first of all add a bit of white space and then inside of drawing I want to create a preview method that doesn't need any custom parameters and this preview method is going to do two major things it is going to give us a preview of the tile or object that we want to place and it draws lines around objects when hovered over that way we know what we are going to place or if we have something selected although first of all we have to figure out which of these two we currently are doing so is the play hovering over an object or is the player placing a new element so we need an if statement to separate these two cases and for that we already have a really useful method that is the one I created earlier Mouse on object this one telling us if the player is hovering over an object or not this I want to use to get the current let's call it selected object and this we get with self.mouse on object remember this mouse an object is going to return the object we are currently hovering over meaning we are getting a Sprite once we have that we can check if selected object exists and if that is the case I want to draw lines around this object and if that is not the case so else I want to show a preview although there's one more thing we do have to do and that is all of this should only happen if the mouse is not over the menu meaning I want to indent all of this and add another if statement that if not self dot menu.rect dot Collide point with the mouse position that part should be fairly selfexplanatory we don't want to show any preview if the player hovers over the menu that'd be kind of weird and with that we can start working on let's start with the first if statement and let me add a pass in the other so we're not getting an error if we have a selected object I want to draw lines around it first of all for that I need a few bits of information the most important one is I need some kind of rectangle and this rectangle I'm getting from the selected object since this one is a Sprite I can Target the rectangle and let's just leave it at that although I do want to copy it once we have that just to make sure we can see something I can for example do pygame dot draw dot rect in here we need a surface we need a color and we need a rectangle the rectangle is the easiest part this we already have the color we are going to change anyway so for now let's use red so it's something we can see quite easily finally we need a surface and this in my case is going to be the display surface and with that we should already be able to see if we are hovering over an object the last thing we have to do is to call this method that happens inside of the run method in here inside of the drawing section I want to draw the preview this I have done before we are drawing the menu I want the menu always to be on top so and here self.preview let's call it and this should be all we need if I now run the entire thing and show my mouse I can hover over the pirate we get a rectangle and also if I hover over the sky handle this also works on top of that even if I move around the pirate the red rectangle stays around which is a really good start even if I add a new palm tree you can see if I have over it it shows that it's being selected so this is working really well although just showing let me minimize this just showing a red rectangle really isn't ideal so we have to refine this and I want to get rid of this drawing method here instead let me explain what I want to do the rectangle we have right now looks something like this and what I want to do is to draw the lines around it something like this every single line in here is going to be drawn with pygame.draw.lines this one allows us to draw a line although we first of all need to figure out how to expand this rectangle so these indicators are a bit further outside this we fortunately can do quite easily instead of copying the rectangle I want to inflate the rectangle I'm going to inflate it by 10 and 10 pixels which means we're inflating it in this and this direction by 10 pixels or rather 5 pixels on the bottom and 5 pixels on top the same thing is going to happen for right and left they are both going to expand by 5 pixels that way we're getting a bit of a distance between the actual Sprite and the indicators all of this is going to happen inside of this rectangle once we have that I want to figure out how to actually get these lines here and for that I want to declare a couple more variables the first one is a color that's why I don't have to write the same color over and over again but this one I want to go with black next up I need a width the width is the line width I set this one to three and finally I want to have a size this I have set to 15. what this size means if I show this one again this size here for example could refer to this distance here or to this distance here once we have all of that we can actually start with the drawing and what we need in here is pygame dot draw dot lines inside of that we need a couple of different arguments we need a surface to draw on we need a color we need to tell Pi game if the line is closed or not then we need the actual points we want to use and finally we need the line width most of these are really easy for example the color we already have with the color here the line width is also very easy that is the width here let me change the line with just a width and we are good to go the surface is also quite easy I want self.d display surface closed means if we have a couple of points let's say I have a point here a point here and a point here and Pi game is going to connect them like so if closed is activated it is going to draw another line from the last to the first point which in my case I do not want which means I'm going to add a false in here the only really complicated bit inside of here is points because for this one we need a list and this list has to contain three points each of them is going to be X and Y so let me add X and Y in here and then I can talk about this in detail what I want to happen in here if this is the original Sprite that we have selected that we are getting from up here the selected object around that we have created a larger rectangle this rectangle here this one looks something like this the larger size we are getting from inflate what I want to do now is to draw for example in the top left to do that I need to figure out three points I need this point here I need this point here and finally I need this point here these are the points I'm going to figure out down here down here and down here and I think this could be a really good exercise for you try to figure out these three points and see if you can draw this line so pause the view now and try this one all right let's do together now the easiest point we can get is the top left point because this one is literally just the top left and I can clean this one up a tiny bit we also don't need the inner rectangle anymore this second Point here that is the red one we just need the top left of the rectangle which we get with rect DOT top left with that we already have the first point covered next up I'm going to work on this point here for this point we know we are on the left side of the rectangle which means X is quite easy to get all we need is rect dot left why we can get quite easily as well because we know we are all the way at the top and we want to go down by a certain amount the amount being this size here in our case we want to go down 15 pixels as a consequence for why I want to get rect.top minus the size there's only one more point that we need and that is this point here or the yellow point this one is going to work in kind of a similar way we know for this one we are all the way on the top of this rectangle which makes y quite easy all we need is rect dot top for X we know that we are all the way on the left side and we want to go 15 pixels to the right the same 15 we have gotten here as a consequence for X I want to get rect.left plus this size and with that I can clean all of this one up and now let's try to run this and see if it works if I now hover over my player I can see this is almost working I just messed up the blue point but this we can fix quite easily the problem here is this line this should be less instead of minus if I run this again now now this is working just fine cool the problem with this one was that the origin point is in the top left and if you want to go down we have to increase y instead of decreasing and this is what I got wrong here but well all we have to do now is to this three more times meaning I can duplicate it and well we already have the top left besides that I want to have the top right then I want to have the bottom right and finally I need the bottom left all of these points are going to be fairly simple geometry so let's go for them one by one this one here is the top right if I make all of this visible and we have a rectangle like so the one we already covered is this one here so we don't have to worry about it the one I'm going to work on next is going to be the top right this one here well that once again I want to have one rectangle a second rectangle and then a third rectangle once again the red one is the easiest one because this one here inside of the top left we want to have the top right for the blue rectangle we know we are on the top of the rectangle and we want to go 15 pixels to the left that I can do in here for X I want to have rect not left but right and from that I want to subtract the size for why I am happy just with the top that is giving us the blue and the red rectangle finally we have to work on the yellow one for this one for X we just want to stay on the not the left side but the right side and from the top we want to go down so plus 15 pixels and with that we should have the top right let's try if I now hover over the player this is looking really good cool next up and I guess I can do this one without drawing we have the bottom left bottom right actually is this one and we have the bottom left or the bottom right I want to have as the Middle Point the bottom right and the first point we want in here is rect dot right and from that I want to subtract the size with the Y part we can just use the bottom one or the final point for X we want rect dot right this one doesn't need the size and then I want to have rect dot bottom and from that I want to subtract the size with that we should have the bottom right let's try this one and this is also looking pretty good and if you are struggling just draw these points yourself it's not that hard to follow along if you play around with this a tiny bit finally we need the bottom left meaning the Middle Point again is very easy then for the starting point I want to have rect.left this one I can leave as it is but now I want rect dot bottom minus the size besides that we need a point that goes horizontally that is going to be this one here meaning I can leave this one as it is but this one should be rect dot bottom and this is all we need at least as long as I didn't make a mistake so let's try and this is looking really good this works with any kind of object even for place of objects like a palm tree they can all be selected and we can move them around so I'm really happy with this let's try another palm tree like so or this one or this one and they all look really good so with that we have the overlay if we have something selected covered so next up we can work on the else statement that we want to actually preview something if we are placing a new element for this one we first of all have to know are we placing a tile or are we placing an object because those two need different logic to separate the two I want to create a type dictionary this one we are going to create with dictionary comprehension meaning in here I want a key and a value or key and value in editor data dot items with this line here once again we are copying this entire dictionary which we don't need all I want in here is the type do I have an object or do I have a tile that's all I care about so instead of getting the entire value all I want is the type of the value we are currently looking at once I have that I want to get a Surface now for that I need a bunch of surfaces which I don't have right now however if you look at settings inside of this dictionary we have a menu surface and we have a preview these I want to import this is going to happen inside of the Imports method and here all the way at the bottom I can add another comment for preview and now we have to import all of these surfaces and I want to store them as preview surfaces and what I want to get out of here is another dictionary that has key value pairs the key is always going to be the ID for the object for example if we have a number two in here if I look at this dictionary again I want to have this 2 and Associated as a value here should be this previous surface which is going to be for the land tiles the same for water although this one should have a key of three which means for this dictionary for example I want to have 2 and a rain surface and all of that we can get with dictionary comprehension once again in here I want to have a key and on this key I have a value and let's do the same thing again for key and value in editor data dot items right now once again we are just going to copy this entire dictionary so wouldn't be helpful however what I can do now I know on this value which is another dictionary and this dictionary has one key called preview and the associated value for that is going to be a path to one surface and this I want to import which means here I can use the load method to actually import a surface and with this you would get the different surfaces however there's one issue if I look at settings again the player and the sky do not have a previous surface which means if we were to run this we would be getting an error but this we can fix quite easily I only want to run any of this if value and preview actually exists if it doesn't we just want to skip it and that is all we need here now we have our previous surfaces and I can use them inside of here so I want to get myself dot preview surfaces and since we once again have key value pairs I can get the surface here quite easily although for that I need indexing and I want to have myself dot selection index on this one I want to copy the surface that we have the reason for that is for the surface we have currently selected I want to change the alpha value to something like 200. that way it is going to be a little bit transparent which is quite important for a preview I don't want this to be too obvious once we have to surface we just have to find the position and for that we have to separate between tile and object and now all we have to do is if the type dictionary and self dot selection index is actually a tile that is working because this dictionary here has a key for the ID and the value is the type and the type is either object or tile which enables this if statement here if that is the case I need to find some kind of position and for the position I need to currently select itself meaning I want to have a current cell and this I get with self dot get current cell this is a method we created all the way in the beginning this get current cell here and now that we have a current cell I want to create a rectangle this rectangle is going to be the surface we have just imported and on that I want to get wrecked here I want to place the top left position and on this I always want to start from self.origin to that I want to get the current cell although I want to multiply this one by the tile size since the current cell is a tuple I have to convert this to a vector but that is actually all I need now all the way at the end of this method or rather of the if statement I want to self dot display surface.blit and since I now have a surface and a rectangle I can just pass the surface and the rectangle in here and I should be good to go at least on a very basic level and now if I run this and let me show my mouse I can see the preview of the lamp tiles this also works with water this also works with the coins and this is also going to work with the spikes and with the enemies so I am very happy with that the only problem we have right now is the palm trees are not going to work and we are getting an error the reason for that is we are not doing anything with the objects so we are getting an error fortunately that one is really easy to fix we need to first of all an else statement so besides the tile we are working on an object and for this one now we have to create a rectangle and this part is going to be your exercise try to get the rectangle for the object and see what you are going to need if you want a tip check out the canvas ad to see how the object is going to be placed that is going to be really important but pause the video now and see if you can figure this one out the answer here is going to be I want to get the surface I already have and on that I want to call Get Wrecked and now the point I want to place is the center and the center needs to be wherever my mouse position is if I run this now and let me show my mouse again I can select the palm tree and you can see it follows my mouse perfectly and if I place it this is looking pretty good now I can move it around and place another element all of this is working very well the question now is how do I know that I have to place the center and for that if I minimize preview and go to Canvas add inside of here when I'm placing the canvas object the position is always going to be the mouse position and now if I look at this canvas object the rectangle here is going to be the center position so anytime I'm clicking with an object selected I want to place the object or the center of the object where my mouse position is as a consequence inside of my preview when I'm running a preview of the surface this one here I have to show the object in the same position that is really important but well with that I can remove a bunch of comments here and now we are done at least with the preview for the final part of the editor at least purely for the editor we have to work on the sky now for this guy we need a couple of different methods to make all of this work and I think all of this is best explained by actually doing it so let's jump right into the code and let's have a look once more we have main.pi which I don't care about I want to look at my editor and first of all in here inside of the drawing section I want to create a new method that I call display this one is going to need self and Delta time for the cloud movement although we're not going to use that for a bit on top of that before I start working on this let me call it right away inside of the run method and now really important this display sky has to be called before we are drawing anything else so display sky in here with Delta time and this always has to be in the background so it needs to be before the level the level lines the preview and so on and I guess while we are here I can also comment out the origin point because this one we don't need anymore ready now I can start working on displaying the sky there are going to be two major parts to all of this let me draw the entire window something like this and first of all I want to create a horizon something like this then we have the actual sky up here and we have some water at the bottom meaning we have to draw three different things and those are always going to cover the entire background and even more important this middle line here has to be controlled by the sky handle we created earlier let me actually run the game by adding pairs in here and running main.pi this handle here is going to determine the vertical position of the sky which more specifically means from this point I want to draw a horizontal line and that means first of all I need to get a y position that I get with self and I call this one this guy handle in here we need rect and we need the center y with that we know where the Horizon is going to be although there's one thing we can do first of all and that is self dot display surface dot fill and in here inside of settings if I scroll down a tiny bit to the colors we have a sky color which I can copy and paste in here and I guess this one we could do right at the start if I run this now you can see some kind of Sky color by itself it looks kind of weird but it definitely works so with that we have a starting point although not a very good one but definitely something we can work with now with that inside of the editor we now have a y point so we can use that for now I want to use it to draw some Horizon Lines we actually have multiple you're going to see in a second what I mean bodies let me create a horizon rectangle and this rectangle is going to be pygame Dot rect and then here we need a left a top a width and a height left and width are really easy because I want this rectangle always to start on the left side of the window and cover the entire window so window width the top for this one is going to be let's just go with Y for now and let's give it a height of 10. and now with that I can pie game Dodge draw Dot rect and once again I need a surface so I display Surface body color inside of settings I have a horizon top color this I want to copy paste it in here and the last thing we need is the actual Horizon rectangle now if I run this let's see what we get you can see we have a rectangle that now works as a horizon line and this one only cares about the wine part so it always covers the entire width of the window which is really nice because now if I move the entire editor this one well the Horizon is always going to work so this is exactly what I wanted here although the one part that I don't really like is that I think this Horizon is a tiny bit too low but that is fairly subjective if I run this now and you look very closely The Horizon is a tiny bit higher but it really doesn't make much of a difference what I can do is this shouldn't be the Horizon rectangle this should be Horizon rectangle one because I want to have two and three and those are going to be other rectangles on top of this original one that way basically what I want to have this one here is going to be the entire display surface and the first rectangle we created is something like this on top of that I want to have a smaller line just imagine I can draw straight lines that would definitely help and on top of that I want to have an even smaller line okay this is very hard to see but once I actually implement it you can definitely tell what's going on now first of all when we're drawing this there should be Horizon rectangle one for a horizon rectangle two I want this to be a tiny bit higher and for the height I want this to be four if I draw this one and run the entire thing again you can now see we have a bigger line on top of a smaller line this I want to do one more time with Horizon rectangle three this one should be 20 pixels from the center and should have a height of 2. if I draw this one now and run main.pi again we now have a third line in here and all three of these lines work with the sky handle so this is working really good although there's one minor thing we can do here to optimize all of this and that is I want to draw all of this only if a certain if condition is true and that if condition being that Y is greater than zero if the sky handle is really far up there's no point drawing any of this let me visualize this actually right now this guy handle is right in the middle of the window and if I move further up and up at some point the sky handle is going to be well on top of the editor and if that is the case we are only supposed to see water as a consequence there's no reason in drawing anything of the horizon and with that here we're not drawing them if we only want to show water this isn't going to make much of a difference in practice but every tiny bit helps now besides that I want to draw the C for that I want to create a c rectangle and this once again is going to be pygame Dot rect and in here once again we need left top width and height the left once again is really easy we just need zero the top is going to be y that one is also easy the width is going to be the window width and for the height here we could be fancy but well we can also just add window I that makes things a bit easier and I guess I should draw all of this again we once again have a display surface and we have the horizon line somewhere here this C rectangle is now going to be this rectangle here although I was a bit lazy with the window height Because the actual rectangle I am going to create is probably somewhere in size like this which in practice doesn't make much of a difference so it's not too much of an issue this rectangle I now want to draw which I do with pygame DOT draw dot rect in here once again we need a surface to draw on the display surface or the color inside of settings we have C color this I want to use in here and then I want to draw the CU rectangle and if I run this again now this is starting to come together we now have a prophecy that is starting to look much better and it also works along with the sky handle also if I go down you can now see an issue that the C at some point stops and this I have to work on the idea here once again is going to be this should be an if statement if the Horizon is on the screen I want to do all of this however if that is not the case so else I want to fill the entire surface with water I'm pretty sure you can already see where this is going this is going to be your exercise so try to figure out the if statements here it is going to look somewhat similar compared to what we have done here with the Horizon Lines possibly now and try to think about this to figure out if the Horizon is on the window I want to check if Y is smaller than the window height only if that is the case I want to do all of this once again we have the display surface and here is y that is our Horizon and what I'm doing with this if condition here is I'm checking if this y currently is somewhere on top of this thing here imagine if this y was moved further down there wouldn't be any point in drawing water because the water wouldn't be visible for example if the player wants to have a level without any water this one should also be possible so let me clean this one up a tiny bit that is looking better now this is one part and there's no point running Pi game right now because you wouldn't be able to see the difference there's one more thing I do want to do and that is zero is smaller than y is smaller than window height this means I am only drawing water if this y here is inside of this range we already covered the case if the water is below we only want to show Sky if the water is on top I want to do something else I want to fill the entire window with water and that I want to do instead of drawing a rectangle and let me actually implement this right away with this we know that the Horizon is somewhere on the editor but now I can add another if statement that if Y is smaller than zero if that is the case I know I only want to have water to fill the entire surface which I get with self dot displaysurface dot fill and in here we have the C color which I have already used here so I can just copy it and paste it in there and now you should be able to see what's going on if I move this thing up and down nothing is going to happen but now if I move a bit further down you can only see water forever and that is because if this Sky handle here is somewhere up here or smaller than zero then we are filling the entire display surface with the watercolor which means if I do that we are filling the entire display service with the blue color so it looks like we only have water but if I move it the other way so I go up now we are only drawing the sky and if the Horizon is anywhere in between we are drawing all the other stuff I hope that makes sense if you play around with numbers I think this should be fairly straightforward let me get rid of the comment here and here and this is starting to come together there's one more thing that I do want to do and this is going to be all the way at the end I want to draw one more line for the Horizon and this I get with pygame.draw.line in here I want the display surface for this one we have another color The Horizon color this one I can paste in here and now for the points I need X and Y for the start and I need X and Y for the end X is either going to be 0 or the window width remember here we always want to cover the entire width of the window and Y is going to be well y this is the point we are getting up here finally we need a width and this one I've set to 3. and for this one if I draw this now you can see we have another horizon line that if it makes the entire thing look a bit nicer cool so with that we are displaying the sky the problem right now is that we are going to need some clouds also I should mention that you could optimize this one here a tiny bit more that this horizon line only really needs to be drawn if we have this condition here so technically I could move it in here and indent it properly run this again and we have the same outcome but now we're not drawing this line if it's not on the window but more importantly we now are going to need some clouds that is going to make out of this look much better and really important here those clouds need to be running inside of this display Sky because the clouds are supposed to be behind the water but on top of the Horizon Lines this is why I separated these two parts in between the two I want to run something like self dot display clouds since the clouds are going to move this one needs Delta time and this I can create right here we need a method called display louds and don't forget a parameter for Delta time first of all in here we need to know the position of the Horizon that is the same thing we have done in here so I could just copy it although to be a bit more elegant here I can also pass this y inside of this method that way we get Delta time and Y on top of that inside of the clouds there's one more change that we can make before we actually write any code inside of this method and that is I only want to display clouds if Y is greater than zero if the Horizon is above the entire editor and we only want to show water there's no point in displaying clouds and this if statement we already have up here which means I can put display clouds in there and then I can skip this if statement and now I can actually work on displaying the clouds essentially what I want to do in here I want to create some kind of let me call it self dot current louds these are the clouds that currently exist they don't right now but we are going to create them in just a second and I want to look at every single Cloud inside of here so for cloud in the current clouds current clouds is just going to be a list inside of that every single Cloud will be represented by a dictionary and this dictionary has a surface of the cloud we have a position and we have speed I want to get my cloud and in here I want to get the position this is going to give me a tuple with X and Y and for now I want to move all of the clouds to the left so it looks like they're moving put that in here I want to get 0 that is X and move it by the cloud and the speed of that cloud and this I want to multiply with Delta time once I have that I want to self.display surface and lit the cloud and in here we have the cloud surface although one thing we do need is a position and this position is going to be X and Y this one I want to create on separate lines to make it a bit easier to understand X is going to be the easier bit in here we have cloud we have a position and once again this is a tuple with X and Y I care about X Y is going to be a bit different although I can copy this bit in its entirety and change the 0 to a one this is a good start but what we have to be careful about is that all of this has to be relative to this y that way if this one here is the Horizon and we have some clouds here and let's say another Cloud here those are horrible clouds but the basic idea is if the player is moving the Horizon up all of the clouds should move up as well by the same logic if the player is moving the Horizon down the clouds should move down as well and this Behavior we get with Y minus the cloud position that way the clouds are always relative to The Horizon the one issue here is we have y twice which is going to be a bit confusing so I'm going to rename this y to Horizon y and with that we can work with our clouds the problem we have right now is that current clouds doesn't exist also even if it did exist it wouldn't have any content so there are two things we have to work on let me start by creating another method that I called create louds in here we need itself and we are going to need an event this is important for the timer I'll explain that in just a second but for now let me add pass in here and I can minimize the display Sky method and I can all the way in the init method let me do it right after the Imports I want to create clouds in here first of all we need the current clouds that is going to be an empty list and to for loop I have written down here is for the current clouds in just a bit we're going to populate this list with dictionaries but there are some things we have to cover first the most important one for now is we actually need some surfaces that we can use and those I am storing in a cloud surface and this is also going to be a list in here I'm going to use my import folder function and there's one path we want to import from this path is one folder up then we have graphics and then we have clouds that is horrible spelling like so if I look inside of the project folder we have Graphics inside of there we have clouds and then here we have three different clouds those I want to import next up we have to create a timer the basic idea is every time a timer ticks we want to create a new cloud and to create that we need Cloud timer and since this one is a repeating timer that is quite simple pygam has something inbuilt here this we get with pygame DOT user event and now we need plus one to not confuse the events in pi game once we have that we have a custom event and on this event we have to create a timer which we do with pygam.time and set timer for this one I want to set the self Cloud timer and now in milliseconds we need the duration of this timer in my case I want a new Cloud every two seconds or every 2 000 milliseconds once we have that I can minimize the init method and inside of my event loop I can call Self dot create clouds and important here I need the event with that I can minimize the event Loop and look at my create clouds the first thing I want to check in here is if event DOT type is equal to self dot Cloud timer I only want to run whatever is going to come next if this event is true so if the timer triggers and ultimately what I want to do I want to create a dictionary for each cloud with a surface a position and a speed which means I want to get myself dot current clouds and on this I want to append a dictionary that has his surface that has a position and finally that has e speed so let me add the colons here and we have to figure out these three bits of information and since there's going to be quite a bit of Randomness I want to have the random module or at least parts of it I want from random import choice and rent int for this surface we already have a list of surfaces that we can use the list of surfaces is self.cloud surfaces and this is right now a list with three different surfaces I want to have one of those at random for that I need choice and this surface I want to store in a separate variable now you could place the surface straight away in here but to add a bit more Randomness I want to do one more thing and that is surface is going to be pygame dot transform dot scale to X with this surface this method would scale the Surface by a factor of two and this I only want to do some of the time which I get with if Rand int between 0 and 4 is smaller than 2. only if that is the case I want to double the size of this surface I suppose we could make this a tiny bit more elegant by copying this if statement here and pasting it all the way at the end and then else we keep the same surface that way we only use one line here like so besides that we need a position and we need this speed this speed is the really easy bit I just want to have a random integer between 20 and 50. that is going to be the speed since it is so simple I could just do Straight inside of the dictionary here that makes the code a bit more readable the only slightly more complicated bit is the position this one is going to be a list with X and Y and really important this has to be a list it cannot be a tuple because inside of this for loop we're going to update the position and with a tuple we couldn't do that for X I want to have my window width and to that I want to add a random number so rent in between 50 and 100. let me draw this actually we have our entire display surface here and the window width is going to be this line here to this I want to add a random number which I'm getting from here this is going to be the start position for my clouds they are always going to be slightly to the right of the window for the white part I also want to use Rand end and here I just want to use 0 and the window height this means if I reopen the drawing all of the clouds can be somewhere inside of this range here and this might be confusing because you might be wondering aren't we going to have some clouds down here for example but that is not going to happen because of this line here we are always going to subtract this lowest point here from The Horizon which means effectively for most of the games we're going to move up the clouds to wherever the Horizon is and that is all we need let's try it actually if I run main.pi we are getting an error that we are missing something and that's something is I forgot to add the position in here now if we run this again if I'm waiting for a bit they can see a cloud all the way in the top right and those clouds if I move the editor around are only affected by the Y position not by X and this is intentional because if the player is moving too far left and right this would get confusing but this by itself is looking pretty good yep I'm definitely happy with this the issue is you can already tell when we are starting the editor we have to wait for the clouds which isn't ideal as a consequence I want to create another method here and this I called start up louds doesn't need any custom parameters and in this one I want to create a couple of clouds let's say for I in range I want to have 20 clouds when the game is starting and at the end of this for Loop what I basically want to have is a duplication of this line here again I want to create a dictionary for every single cloud and put them somewhere where the sky is and this is going to be the exercise here I want you guys to create a surface a position and a speed the position here is the most important bit when we are starting the game the clouds should be randomly covering the entire width of the sky so there shouldn't be to the right there should be in the middle somewhere try to figure this one out and definitely run the game a couple of times to see what looks good but possibly now and see if you can figure this one out the speed is the easiest one because this one we already have we can just get rid of it wasn't even necessary the surface is also quite easy because we basically have to do the same thing we have done here although to be a bit more fancy we can now optimize this to have it all on one line I want to have this surface and this one is going to be I can copy this entire line here except now for the surface I want to have this Choice function here but this I only want to do if the random condition is true and if that is not the case so else I just want to choose a random surface like so that way if your monitor is a bit larger you have all of this on one line and this Fields quite a bit more elegant besides that we need a position once again this has to be a list with X and Y and this one now is going to be really easy because I just want to have Rand int from 0 to the window width this is for x and for y I want to do the same thing I want to go from 0 to the window height we are placing the clouds somewhere in the middle of the window and that is all we need all I have to do now is actually call this startup clouds method this I do inside of the init method self dot start up clouds and now let's run main.pi and they can already see we have a bunch of clouds and this is looking much better I can also go up and down left and right all of this is working really well I guess the one limitation here is if you go too far up the clouds at some point disappear but I wouldn't imagine this to become too much of an issue although I guess if it is an issue for you you can definitely play around with this and make this more flexible but I am fine the way it is right now that being said there's one more thing that we do have to change and that is inside of create clouds the problem essentially is we keep on creating more and more clouds so we have more and more objects which at some point in the game is going to slow down performance because we keep on creating objects we never get rid of them for example once again we have the entire surface clouds keep on going further to the right and we keep on amassing more and more clouds on the left of the window if the game runs for an hour We're going to have hundreds maybe even thousands of clouds in here which we honestly don't need and this is going to be a drag on performance as a consequence every time we are creating a new Cloud we are also going to remove layouts and this is going to be self dot current clouds is going to be a list comprehension and I want to have Cloud for cloud in self dot current clouds right now we are literally just copying the current cloud list but I only want to have the elements inside of the list if cloud and position with zero is greater than let's say negative 400. this means I only want to have the clouds inside of the list if they are somewhere here so they are greater than negative 400. if they are further to the left I want to get rid of them which specifically here means I am not going to copy them over into my new list so they're just going to disappear this is not going to be visible in the game but I can run it make sure nothing breaks and now we can also see some new clouds and this is looking pretty good I guess the one limitation here is you are going to have a bit of a gap somewhere here but nothing too major so I'm quite happy with this and this covers the entire editor so with that we now have to figure out how to export all of this and create the actual level from it now that we have the editor we have to export the level data or at least we have to be able to and for that we need a couple of things most importantly we have to export the entire thing into some kind of grid this grid is going to make it much easier later on to build the level we already have a good start for this because the canvas tile here is really useful this one is going to become really important later on to build the actual level although there's one more thing that we do have to do and that is the objects right now are not in the system at all remember here all of the objects are just individual Sprites they are not part of the canvas tile system at all which means we somehow have to get them in there that's going to be a really important part for now and that is also what we are going to start with but let's start off this trading code and let's see how far we get once again we have the code and I want to keep on working inside of the editor the very first thing that we are going to need is going to happen inside of the event Loop inside of here I want to check if event DOT type is equal to pygame dot key down and the event key we are getting at that moment is going to be pygame.k underscore return those two statements combined check if the player is pressing the enter button if that is the case I want to export the map and create an actual level although in our case there are quite a few more steps before we get to that stage now in here all I want to do for now I want to print let's call this one self dot create grid on this grid method here is going to actually export the level this one doesn't exist right now so let's create it create grid and then here we don't need any custom parameters inside of this method first of all we have to add the objects to the tiles and once we have that I want to create a grid where each cell is going to be one cell inside of the actual level let's go for this step by step and first of all I want to add the objects to the tiles for that since I do have access to all of the objects we have four let's say obj in self dot canvas objects in here for example I can print obj dot top left oh and this should be object.rect dot top left and now if I run this and press enter we are getting the top left positions of both of the objects we currently have in the game which means in here we do have some starting positions although we don't really care about the top left instead we care about the current tile let me explain what that means right now the player has a border that's something like this and the top left of the player is this bit here as a consequence the player is going to be inside of this tile or rather this is the tile that I want to add the player to same for the sky handle the top left of the sky handle is this bit here and this I want to add to this tile and that way we're getting the object into the grid system I hope that makes sense basically what we are going to do we're getting the top left of any kind of object and we are adding it to the canvas tile in this particular cell for that first of all we need to get the current cell of this canvas object now we already have a method that kind of works here we have self and get current cell although so far we always use this with the most position but I want to expand this method a tiny bit so that it can also deal with basically any kind of object which means we have to work inside of get current cell first of all in here we have to create another parameter let's call it obj and by default this is none that way we don't have to change any of the other method calls that we so far have used we only want to get this line here if obj is none or if it exists at all so if not obj that way once again we don't have to change anything else however if that is not the case so else meaning we have some kind of object what I didn't want to return is the vector and the vector is going to be obj and distance to origin from this I want to subtract self dot origin this might sound a tiny bit confusing but this logic here is basically the same thing we have done here for the mouse except now for the position we are not using the mouse position we are using the distance to the origin and that way we can leave all of this exactly as it is and we are good to go let's try this actually instead of printing the top left of the current object I want to get the current cell meaning now if I run all of this and place the player in the top left if I print enter now we get 0 and 0 down here and 9 and 5 for this guy handle let's say if I move this thing one cell further to the left press enter again and now we get 0 and 0 for the player and eight and five this seems to be working just fine let's try it one cell up and we get eight and four so I'm quite happy with this this seems to be working just fine with that we know the current cell of whatever object we are looking at although there's one more thing that we do need and that is the offset what this one means is if this one here is one individual cell inside of the game let me add a couple of supporting lines something like this this could be one cell inside of the editor inside of here we could for example have a player that covers an area like this the offset is going to be this offset here I want to know how far is the top left of the object from the origin point of the cell this is going to become important later on to place the Sprite exactly in the right position because remember right now the cell is always fairly static we only really have the top left but the objects are going to be a bit more flexible and this we have to account for and the offset here could actually be a really interesting exercise for you so try to get the distance between the top left of the cell and the top left of the object and see how far you get first of all we need the distance from the object to the origin point this we get with obj DOT distance to origin this is the same thing we have done up here in get current cell I guess I should mention here we can't use the top left because this always has to be relative to the origin but essentially this one here is the top left in our more flexible system and if I draw all of this if we have once again here the entire level and let me draw a couple of cells we have one cell here one cell or rather a column and a couple of rows with the origin point being here and the distance to the origin could be let's say we are here meaning this distance is what we are getting right now but in my case I don't want to get the entire distance what I want is the distance from this point here to this point for that we need to get the current tile which means we have to know the column and the row this we already have because we know the current cell that we are in which means from this point I want to subtract the current cell although this I want to multiply by the tile size remember here the current cell is a position like 1 2 and 3 but we need actual pixel positions which we're getting by multiplying this by the tile size although once again distance to origin and current cell both are tuples which means I want to convert both to a vector that way we can multiply the current cell with the tile size and not get an error and let me put this into brackets so it's a bit easier to see and I want to do the same thing for distance to origin so this is going to be a vector for sure and that way we are getting the offset I suppose let me print it to see what's going on if I now run the entire thing and press enter we're getting some random numbers they don't tell you that much right now but if you look at the player and I can place the player roughly in the top left if I press this now the player moves closer to the top left the player here is a tiny bit confusing because the actual area the play occupies is something like this the player is much larger than the graphic here I guess you could be seeing it a bit easier with the sky handle if I move it here now you can see we're getting much closer to the top left than we were in the last time we called this method at the very least it works definitely play around with this yourself and see how it works with that we know where the object is and what the offset is going to be both of these are going to give us the exact position where the Sprite needs to be now we need to figure out how to get this one into a canvas tile and for that first of all I need to check if this current cell actually exists inside of our canvas data meaning if in the current cell we actually have something already which means if the current cell is in self.canvas data this means a tile exists already and let me add a pass in here and besides that we have else which means that no tile exists yet but now I am only going to worry about this case here that we already have a tile if that is the case I want to get this tire which means self dot canvas data and the current cell and I want to call add ID although now I want to have object dot tile ID and I want to have the offset I should probably explain object.tile ID is going to tell us what kind of object we have if I go all the way down inside of the canvas object we have the tile ID once again this is one of these IDs here and we want to know which one we are currently dealing with besides that I also need to know the offset so the distance from the top left this is really important to place the object properly although this offset we can't really account for yet as a consequence we have to expand this add ID method which I am going to do all the way down here we have ADD ID for this one once again we need another parameter let's call this one offset as well and in here since we are using this add ID already I want to have a default argument by default this offset is going to be an empty Vector that way we don't have to make any changes to the ad ID we already used multiple times inside of this I want to have another case in this case is going to be an underscore which means if none of these cases are true we are going to do this one here and this is then going to tell us that we are working with objects inside of the canvas Tire I think way earlier I created objects which is just going to be an empty list this we want to fill and what I want to fill it with let me get self.objects I want to append a tuple with the tile ID and with the offset and you could leave this as it is but I added one more if statement and that if statement is if the tile ID and the offset is not in self dot objects only if that is the case I want to append this the idea here is that it shouldn't be possible to have the same object in exactly the same position so for example we couldn't have a palm tree exactly in the same spot that would be kind of weird but other than that we are good to go although well not really because we are only accounting for one case we need to account for the other case if there is no tile yet I have to create a new one which means self and canvas data once again I want to get the current cell and now I have to create a canvas tile remember again if I minimize everything and look at the canvas tile right now we only have the tile ID this we definitely need I need the tile ID however now we also need the offset otherwise we couldn't place the object properly so we have to change the init method of the canvas tile to account for the offset and this is going to be an exercise for you update the canvas tile so that by the end of it we get the object in there even if there's nothing else in there so positively now and try to figure this one out there aren't too many changes you have to make first of all we need another parameter let's call it offset once again that one seems to make the most sense also once again you do want to have a default value in my case Vector 2. that way we don't have to make any changes to the existing canvas tiles we have used if you didn't add this one you would have to change every single canvas tile you have created so far would be kind of a pain and besides that when we are calling add ID for the offset I want to use the offset that way if we have a value here we are going to pass it through and this is all you have to change wasn't actually so bad although I do want to get rid of the comment here that's going to be annoying otherwise cool so with that we are adding the objects to the canvas tile system which is all we really needed however there's one more change that I do want to make and that is if we kept the system like this we are only ever adding more objects to the canvas tiles but we're never cleaning things up so let's say I place the player in one position start the level then go back to the editor place the player in another position and then start the level again we're not getting rid of the original player which we do have to account for and this is quite easy all we need is for tile in self dot canvas dot uh not objects but data dot values inside of here I want to empty all of the objects and with that we have a proper system to account for all of the objects so now we can actually create the grid however for that we are going to need a couple of things so let me go through this one by one first of all we need a red offset once again we have the entire window and inside of this we have a couple of columns and a bunch of rows something like this I am getting better at drawing straight lines the issue we have right now is that we have a huge amount of data that we don't really need because it's completely empty so for example if we exported the game without placing anything we would have the player let's say here and we would have to Sky handle in this cell here everything else we could basically disregard which means we have to figure out a system to only get the cells that we actually want specifically in this case I want to have only these two cells here this is what actually is going to build the level everything else is just going to be empty data that I'm going to ignore now later on obviously we are going to fill this with terrain tiles palm trees enemies but in the most basic sense we only really want to create two tiles and for that the first thing we need is the top left of all of the tiles that actually exist in this case right now it would be the player but it could be any kind of tile so more specifically what I want to get is the top left tile that is actually filled and this one I have separated I want to have the left side or the left tile position that is actually filled and the top one how we are going to do this first of all I need self.canvas data and then here I only really care about the keys because the keys are the position and this I want to have inside of a sorted function which means for this I also need a key the key here is going to be a Lambda function and let me call the parameter here a tile and I want to sort all of this by tile and zero canvas data.keys is going to give us a position for example this could be 64 and 128 for X and Y positions here this we are going to pass into the tile parameter and on this we are only getting tile zero which is going to be the X bit this is the one we actually care about from this one here and once we have that this sorted method is going to sort all of this from the lowest to the highest number and since we only care about the leftmost tile we want to know the tile here with the lowest x value which means from this list I only want to get the first item that is going to be the very lowest x value or the leftmost position of all of our canvas data positions and this is going to return an X and A Y value I only care about the X1 so I want to get another indexing of 0. the same thing we have to do for the top position and this is going to be your exercise to see if you can follow along try to get the top left position of all of the filled canvas tiles should be fairly similar to this one you do have to make some minor changes though I am going to copy the entire thing like so and now first of all of this here can stay identical because we once again care about the positions but now for the key I don't want to sort the items by the x value but rather by the Y value with this one now I'm going to get a sorted list from the lowest to the highest y position of all of the existing canvas tiles from this once again I want to get the first item but now I want to get the Y position of this first item instead of the X position and with that I have the leftmost at the topmost position of all of our filled canvas tiles let me print this one actually to see what we get I want to print the left and I want to print the top if I now run main.pi and press enter we are getting an error and the error we get here on tile ID because this one should be object.tile ID if I run all of this like so we get 2 and 5 which I think is the top left position of the player but if I move this object here to let's say somewhere here we get 1 and 3. so we now have a different top left position this seems to be working just fine once we have that I want to create an empty grid what this actually means is now we can start working on the actual data structure we need for the level for this one I want to have various layers which is going to be another dictionary and in here let me copy paste a couple of things I want to have these items these are going to be all of the different layers we are going to have inside of the actual level the order here also is important because later on for the level I'm going to cycle through and for example I want to have the water all the way in the back then I want to have to back on palm trees then the terrain and so on but all we are really going to do for each of these dictionaries I want to have an X and A Y position and then I want to have some kind of value for example for terrain this could be what kind of terrain we are going to need which means we want to fill the grid and this we do with or tile position and the actual tile in self dot canvas data and items with this we're getting the tiled position and the tile and this we can use to actually fill all of this here although first of all we need to get an X position and we need to get a y position unfortunately this isn't as easy as getting something like tile position and zero because we have to normalize this position to the top left the values we get up here let me actually move this one down a tiny bit so this is easier to see like so and let me explain what this actually means once again we have a couple of columns and rows inside of the editor and when we are exporting everything and once we start to exporting things the player could be in this cell here for Simplicity let's say this cell is 2 and 3 for X and Y also this is going to be the top left cell of all of the filled canvas tiles inside of the actual level this has to become the top left cell which means instead of 2 and 3 this needs to be 0 and 0 because it is the top left cell so this is the one we are starting with now to get that I first of all want to get the row and the column and those are going to be adjusted for so let me rename it actually row and column adjusted for this one now we are going to need for the column we have tile position 0 and for the row is going to be one so we have X and Y from this for the row I want to subtract the top and for the column I want to subtract the left remember here the left and the top are giving us a cell position so this could be one two or three depending on what cell we are in and this number we are subtracting from the cell we have and that way the top cell if I draw this again with this cell being the top left cell left would be two and top would be three and these are the numbers we're subtracting from the cell and that way we're getting to zero and zero if we had another cell let's say here that had three and four we would be doing the same thing and that way the number would become a one and two which will be the distance that we now need here although all of this is still going to be in Grid positions but I want actual X and Y positions to make this easier to place later on and this is quite easy for X I want to have the call adjusted multiplied by the tile size and for y this is going to be row adjusted multiplied by the tile size this is giving us actual pixel positions we can place right away we don't have to multiply with anything and once we have that this is now going to involve a couple of if statements for example if a tile has water I want to get my layers in here I want to get the water and I want to create a new key and this key is going to be the X and Y position although now for this water position we have to know if we have a top water cell or a bottom water cell and this logic I want to keep inside of the tile which means I'm going to create a method that is going to be called get water let's create it right away inside of canvas tile I want to have another method get water all I really want to do in here is return bottom if self and water on top if that is not the case so else this is going to return top with that for every water cell we know exactly what kind of water cell we need to place next up I want to check if the tile has to rain if that is the case once again I want to get my layers and then here I want to Target terrain so we just work with water now I'm working with Terrain once again I want to get an X and Y key here and the value for this is going to be something like tile and get the rain this one once again we have to create which means all the way in the bottom Define get Terrain what I want to return here is going to be a string that is going to contain with the join method self dot terrain Neighbors essentially if I look at the init method all I really care about for the terrain is the actual terrain Neighbors because this one is going to tell me what kind of graphic I need for each individual terrain tile so we can just leave it at that which means we don't need anything else I can move up although in here we are going to need one more thing and that is if we don't have a Terrain or is specifically named Terrain in here I want to get the X1 which means I want to get this terrain but only if tile and get the rain don't forget to call it is in self dot land tiles we only want to get this graphic if the graphic actually exists inside of here if that is not the case so else I want to have the X graphic the one that works as a default tile besides that if tile and coin that I want to look at my layers for the coin that is going to be this one here and once again I want to get X and Y and this one is going to be easier because all I want is tile.coin this one doesn't need any method however there's one thing that we do need this one here is always going to be the top left position but the problem we have seen here is that if this is one tile a coin is going to be stuck here in the top left which is going to look weird as a consequence I need to adjust these X Y values to place the coin right in the center of the tile that is something we can do quite easily all we have to do is plus the tile size divided by two we are getting closer to the Finish Line next up I want to check if tile dot enemy exists if that is the case I want to get my layers once more I want to look at the enemy this is enemies actually so in here we have enemies this one can just be X and Y and in here I want to get tile dot enemy this one is very similar compared to the coin finally for the last one we need if tile dot objects which means if inside of this tile we have an object I want to look at for obj and offset in tile dot objects remember here inside of tile objects we always have a tuple and the Tuple is going to contain the object and the offset from the top left which is what we're getting here inside of the for Loop but now the important thing that we do have to figure out is inside of this layers dictionary we have background palm trees and we have foreground Pawn trees both of these are going to be objects while ground objects also has the player so this is why it's not called palm trees but this separation we have to create ourselves which means inside of this for loop I want to have an if statement if we have VG palm trees and if that is not the case so else I want to have all of the foreground objects what we need in here I want to check if the object we currently have is inside a certain list remember here object refers to a number so this could be one two three or more likely it's going to be somewhere between 11 and 18. although it could also be zero for the player but this is what I have to check for and more specifically what I want to check for is the key for key and value in editor data dot items meaning this right now is going to give us all of the keys of this dictionary here but we only care about the keys if the value of that particular key more specifically the style is equal to Palm BG this basically means we are only getting the keys from this dictionary if the value has style and pawn BG which means this comprehension here would return the numbers 15 to 18. and if the object is inside of that we know it's a background palm tree meaning inside of here I can get my layers I can get BG Palms that is the layer we have created here and on this once again I need to get an X and A Y position with the value being the object now for the X and Y position here we have to account for the offset which means for X I want to have plus offset dot X and for y I want to have the offset dot y and while I was testing this sometimes because the offsite is going to be a vector we had some problems so I want to convert all of those to integers but once we have that we are good to go the last thing we need I can just duplicate the entire thing here and now instead of the background palm trees I want to have the foreground objects the rest can remain identical though finally the very last thing we have to do this for Loop here is done so I can minimize it and now all I want to do is to return this layers grid and with that we should be done with exporting the entire editor map let's try it actually if I run this now and press enter and let me see what we get we get nothing for water palm trees terrain and so on but for the foreground objects we have the player here and we have the sky handle which means something is definitely working if I try this again and place some elements let's say some terrain some water palm tree enemy and a coin and run this again we are getting an error let's have a look this happens inside of the for Loop when we are adding the coin and I think the problem here is the layers called coins not coin like so and now let's try this again I want to have a couple of things of all of the different elements like so if I run this now we didn't get an error but now I forgot the water and we don't have background trees but we do have terrain tiles with the name of the terrain and the position quite a few of those then we have an enemy we have coins and we have foreground objects this seems to be working really well although just to make sure I also want to place a background palm tree and I want to place some water just to make sure this is working if I run this now we have some water and if I find it really quick we have background palm trees that seems to be working quite well and with that I can minimize the entire create grid method and this covers another major part for the game before we are going to continue I realized I forgot one important thing and that is a quick drawing fix in the editor to properly display everything let me actually show what the problem is right now back inside of the editor if I run the entire thing I can place some background tiles I can place a foreground palm tree and a background palm tree but now if I move the player the player is behind the background palm trees which is kind of weird because they are supposed to be in the background this also looks a bit weird because they can just be in front of the terrain which I really don't like the fix for that though is quite simple inside of the editor in the init method when I am creating all of the objects right now we only have a single group for all of the objects I want to create two more we have self and foreground and self and background both of those are going to be a Sprite group I guess I can copy this one and paste it in here now we have a few more groups and this we can use when we are adding where did I put it canvas at down here we are adding all of the objects when I'm placing the groups I want to be a bit more careful let me put all of this in a separate variable the groups should be self canvas objects and self background but only if we have the editor data again and in here I want to check myself and selection Index this is going to give me one of these items here on this I want to check this style and only if the style is Palm and this one is called Palm BG the one we are creating all the way at the bottom here if that is the case I want to have these two groups however if that is not the case so else the groups should be still self and this one I called canvas objects but now I want self and foreground once again if you have a bigger monitor this is going to be much better to see now that I have that I can replace this canvas objects with the groups by itself this isn't going to change anything but when I am drawing the level in here currently I am always drawing all of the objects on top of all of the tiles which is not necessarily what I want I can actually minimize the entire cell drawing logic so all of this and instead what I want now I want to have self dot background and this I want to draw on self dot display surface that way all of these background objects are going to be behind all of the tiles and in the foreground so self dot foreground I want to draw all of the other objects and now if I run this again we can't see anything however you could already see it if I hover over with the mouse over this area the player does exist we just can't see it same with the sky handle it is somewhere here it still exists we just can't see it the reason is never the player nor the sky handle are inside of either the foreground or the background group however if I place a palm tree or a background palm tree those still work and more importantly now if I'm placing a Terrain tile those are going to be in front of the background palm trees which makes the entire thing look much nicer but the other palm trees are always going to be in front of it the last specific thing now is that the player is not visible at all and this we have to change which is going to be your exercise change the code so that the player and the sky handle are going to be visible again pause the video now and see if we can figure this one out or this one I can minimize the drawer level method and go all the way to the init method when I'm placing the player and the sky handle the problem we have right now is that for the group we only have the canvas objects but we're only drawing the foreground or the background groups which means we have to change this one and this one into a group the player I want to be in the foreground so self dot for ground while the sky handle I want to be in self dot background and now this should be visible again that is looking much better now I can move them around everything still works just fine although now if I have terrain I can move the sky handle behind it you can still use it but I think this one looks a tiny bit better it's a matter of preference here there's no clear answer but now everything else works really well and this entire thing is coming together very nicely cool I am really happy with this finally we can start working on the actual level and first of all we need some kind of transition basically there should be a transition from the editor to the level if we switch them right away it would feel a bit too abrupt but for this transition to work we need to have at the very least a very basic level for now this level is not going to do anything it is just going to be a red background but at the very least we are going to be able to see something once again we are in the code and for once I don't want to work in the editor I want to create a new file this one I want to save as level dot pi in here we are going to need a couple of things let me copy them from the editor at the very least I want to have highgame and sys and the vector besides that I also want to have these two Imports here and the rest we don't need for now once I have all of that I want to create a class called level there's no need for inheritance and in here I want to have an init method and this one as always needs self and for now this is all that we are going to use inside of the method I want to get self dot display surface and this one I get as always with pygame.display.get underscore surface once I have that this level class is going to have an update method with self and Delta time although inside of this one for now all I want is self.display surface dot bill and just so that we can see something I want to have a red color although there's one more thing that we need in here and that is the event Loop this we absolutely need because remember inside of main.pi we don't really have an event Loop we are just running the game the event Loop either runs inside of the editor or inside of the level which means in here I need for event in pygame dot event dot get don't forget to call it and here I want to check if event DOT type is equal to pygame dot quit which means we are closing the game which means I want to quit Pi game and says.exit also don't forget to call self.eventloop so we are actually able to run it with that in place inside of main.pi I can from Level import level with this inside of the init method of the main I can create self dot level which is going to be level there are no arguments needed right now and once I have that I can run self dot level dot run and comment out the editor also I think I just realized inside of level I called this update let's call it run to keep more consistent also don't forget the other time and now if I run this we can see a plain red window which isn't what we want but at the very least this is working which means we now have level and we have an editor we just have to figure out how to switch between the two back and forth also I want to have an animation between the two so let's get started most of this is going to happen inside of main.pi inside here first of all I want to have another attribute that I called editor active by default this one is going to be true the reason here should be obvious that by default the editor should be open that is the first thing the player should see and with that in mind inside of the run method of the main class I can run if self dot editor active only if that is the case I want to actually run the editor and if that is not the case so else I want to run the level next up we are going to need another method that I called toggle in here we need itself and nothing else and all that is going to happen inside of this method is self dot editor active is going to be not self dot editor active meaning whenever we are calling this method we are switching editor active either to true or to false on this one now you might be tempted to just pass this toggle method into the player and into the level which would be possible but not ideal because I want to have a transition I think it's best to actually show the finished thing that's going to explain this the best here we have the final level and I already have a couple of terrain tiles if I now press enter we have this nice little animation that moves us from one to the other this is what I want to have as well in here to create this one I want to have a transition object to create this effect I want to have self dot transition this is going to be a whole separate object let's call it transition and only this one is going to call Self dot toggle meaning I want to pass it in here but make sure not to call it because I want to call this method from inside of transition this transition object I want to create right in here so class transition this is just going to be an animation it doesn't need inheritance though but we do need an init method this one itself and toggle first of all we need as always the display surface and this we get with pygame dot display dot get undescore surface we also have to store ourself.toggle which is going to be the toggle and finally I want to know if this thing is active or Not by default it is not with that I can start talking about the actual animation we are going to do how it's going to work is we have the display surface again and I'm going to draw a circle around like so by default this circle has a border width of zero meaning this width here is zero but once the animation is starting this border width is going to get bigger and bigger because of that it is going to cover more and more of the display surface in a circular manner so we're getting smaller and smaller circles and at some point we can't see anything of the actual editor anymore however once we are reaching this Middle Point here I want to reverse the animation so we are going this way again and that way it looks like the thing is opening also importantly here only when we have reached this blue point then I want to call the toggle method that way you can't see the switch between the editor and the level that way we don't get a sudden switch between the two makes the entire thing look much better for all of this I need a few more attributes the first one I want is self dot border with by default this one is going to be zero then I want to have a Direction so self dot Direction by default this is going to be 1 then I need self Dot Center and this is literally just going to be the window with divided by 2 and the window height divided by 2. next up I am going to need self dot radius this is going to be if I draw all of this again let me use a different color the radius the red color here is going to be the size from the center to where I want my actual Circle to be and the best size here I found is from the center all the way to one of the corners of the window they all have the same distance so it doesn't really matter which one and this is going to be the radius for the circle so I'm going to draw the circle roughly here you get the idea I hope for this one you could do some math but we don't really need it because we already have the center and this I want to convert to a vector so self Dot Center in here and since I know that this is going to be the center of the window I can just get the magnitude on this one and call it a day that being said I don't think the vector exists in here right now it does not so from the editor I want to import vector let's put it all the way at the top now this is going to work the last thing that I want to do is create a threshold and this is going to be self dot radius Plus 100. what this one is going to do is it gives us a threshold when we want to stop the entire thing you're going to see in a second how this is going to work but now that we have all of those I want to create let's call it a display method in here we need self and Delta time I want to check if self DOT active is true meaning I want to play the animation then I want to get myself dot border with and increase it by some number let's say 1000 is what iPhone look best multiplied by the Delta time and multiplied by the direction that way we are increasing the Border width by 1000 but since we're multiplying this with data time this becomes a much smaller number and Direction means we are increasing this in the positive direction so the thing is growing I'm not actually sure what happens in a negative direction if the starting point is zero but that doesn't really matter right now but with this we should already be seeing something although we need to draw the entire thing which means I want pygame dot draw dot Circle in here we need self dot display underscore surface for the color I'm just going with black then we need the center of the circle this is going to be the center of the entire thing then we need the radius and we do have a radius that is the radius finally we need a border width this we also have itself and Border width although this I want to convert to an integer because due to this operation we are almost certainly going to get floating Point numbers and this one here expects integers but now that we have that inside of the run method after we are checking if the editor or the level is running I want to run self.transition dot display I believe I called it and pass in Delta time we are calling this method here if I run the entire thing nothing is going to happen for the simple reason that active right now is false if I set it to true though and run the entire thing again we are getting an error I already see why this should be self dot Direction next attempt and there we go this is looking much better now we have this circle closing but we never know once it's opening again so this we have to work on and for that I have if self water width is greater or equal than self dot threshold if that is the case I want to set self dot direction to negative one if I run this now again we are getting a nice animation basically the way this one is working and this is what threshold is doing let me explain it properly now if this one here again is the entire window we have the radios looking something like this that is this radius here for Simplicity let's say this one could be 500 and this 500 is going to be important for the animation however once we are in the center I want the center to be closed for a tiny bit so we can only see a black window for a while the way I achieve that is with this threshold because this threshold is this 500 plus this 100. which means even after we are reaching the center we are increasing the border with a tiny bit more and that way the entire window stays black but only once we are exceeding this threshold we are reversing the entire animation I hope that makes sense if you play around with this for a tiny bit I think the logic is going to become obvious also what we can do in here is called self dot toggle I want to call this toggle when the entire thing is going to be black so the player cannot see the transition finally the last thing we didn't hear is if self and border with is smaller than zero if that is the case I want to set self.active back to false the border with should be zero and finally self dot direction should be one again that way when we restart the animation later on this works all properly meaning now if I run the entire thing this is working really good almost better than I expected actually you could see we started with the editor and then moved to the level so all of this is working which means now I can minimize it and I just have to figure out actually by default this active here should be false what I have to figure out now is how to call this transition from inside of the editor and from inside of the level for that I have created another method this one I called switch in here we need self and we need a grid although by default the grid is none the grid here is what we created inside of the editor inside of create grid what I'm expecting inside of this method is this return statement here the layers if we are running this first of all I want to set self.transition DOT active to true that way we are starting the animation and now if there is a grid we know we are going from the editor to the level which means I want to create a new level so self the level is going to be the level right now there are no arguments so we can just ignore it although I guess while we are here we can pass the Grid in here and inside of the level we can store the grid we are not going to use it for this section but later on this is going to become useful although what is also important in order to go back from the level to the editor this level object needs to know or needs to have access to the switch method which means in here I want to pass in self dot switch for this we have to create a parameter in here I want to create switch and that I want to store inside self.switch is going to be switch and to make all of this work inside of the event Loop if the event and type is equal to Pi game and K down and the event dot key is equal to pygame dot k underscore Escape this means we are pressing escape inside of the level if that is the case I want to call self.switch without any arguments what this means inside of this switch method we are only calling the transition we are not creating a new level as a consequence we can just see the editor speaking of the editor this editor when we are creating it up here we also need self dot switch this self.switch inside of the editor I want to minimize everything again and only work on the init method we need switch in here as well in this switch I want to turn into an attribute self.switch is going to be switch and now we just need to figure out when to call it and this we already have to a pretty good extent this happens inside of the event Loop in here right now we are just printing self.grid but instead of printing self.grid I want to self dot switch and pass the Grid in there meaning now when I call self.switch from inside of the editor this one here is going to be true meaning we are going to create a new level from the data we're getting from inside of the editor and that is the reason why inside of the editor we can have self.switch with an argument and inside of level.pi we can have switch without an argument and we have the same method except the method does a different thing depending on which way we are going also I realized this should be a double equation sign once we have all of that we don't actually have to create level inside of the init method because by default the level shouldn't exist we only want a level to exist once we're switching from the editor to a level and now with all of that let's try I can press enter we're getting to the level I can press escape and we're going back to the editor and in here we can keep on working all of this is working really well let's try it again obviously we cannot see the editor but at the very least all of this seems to be working just fine cool so with that we have covered another major section so next up we can actually flesh out the level so for the next part we can place the terrain on top of that I am also going to place the basic version of a player that isn't going to have any animations yet I just want to have something for the player so let's Jump Right In and let's see what we have to do once again we have main.pi and we have level.pi the editor we are not going to use for quite some time inside of the level we also have the grid available this one is going to contain all of the information we need to build everything which means I want to work inside of the init method and then here I first of all need a few more things since we are going to use Sprites for most of this I want to have self dot all Sprites this one is going to be at least for now pygame dot Sprite dot group a basic Sprite group we use to place everything in once I have that I want to create one method that I called build level and in here I want to pass in the grid and I also want to create something else that I called the asset dictionary this as a dictionary I am going to get from the init method when we are creating the level and basically what this one means anytime we are creating the level we are going to need a ton of different graphics and those I really don't want to import every time we are creating a level because we're going to create a level multiple times anytime we are switching we are creating a new instance of the level as a consequence importing more Graphics every single time is going to be a nightmare and really bad for performance to account for that I am also going to pass in a dictionary and this dictionary is going to be quite long so I'm going to put it over multiple lines in here one entry the one entry we are actually going to use is called land and this is going to be self.land tiles this is what we got way earlier inside of imports when we use this for the editor this we can reuse and just place it in here later on we are going to add a lot more in here but for now I just want to have the land this I can now use in here and I have to build the build level method I want to create build level in here we need a grid and we need the assets I guess let me call it asset dictionary to be a bit more consistent also this needs self we need to first of all get all of the different layers for reference inside of the editor what we are getting if I create grid we have to cycle through all of the layers of this dictionary which means I want to have for layer name and layer in Grid dot items inside of each layer we have more information we have the position and we have the data in layer dot items as well which means this first for Loop goes for the entire dictionary and the second for Loop is looking at every individual dictionary for every layer once I have that I can look for the layer name for example if the layer name is terrain the one we have specified here then I want to place some terrain tiles for that though I'm going to need some kind of vehicle to contain the graphics in my case I'm going to use a Sprite for that I'm going to create a new python file and save it as sprites.pi in here once again I want to import by game and besides that I also want to use vectors as always so let me add it right away in here for now all we need is pi game the first thing I want to do is I want to create a class called generic this one is going to be pygame dot Sprite dot Sprite to create an actual Sprite and inside of here we need an init method for the parameters here obviously we need self besides that we need a position we need a surface and we need the groups once we have all of that we have to do the basic setup the one that we always need for any kind of group I want to call Super init for the group then I have to create self.image this is going to be the surface and then self.rect is going to be self.mage.get underscore rect and I want to place the top left wherever the position is which means this group goes in there this surface goes in there and the position goes in there we are using all of our parameters once we have that I can return to level.pi and in here I have to import from Sprite import generic although I call this one Sprites this I can now use in here I want to create a generic Sprite and let me copy over the parameters we need we have position surface and group those three number one we need a position this position we already have that is the key for the layer items dictionary meaning this one is quite simple the next thing we need is the group or the next easy thing we need is the group because we only have one group here and this is all Sprites finally we need a surface and this is going to be your exercise figure out where you can get this surface from and well it shouldn't be too difficult just look at what parameters we have available and what you have in here all the information you need is available in there so pause the video now and see if we can figure this one out the surface is going to be inside of the asset dictionary meaning I want to use the asset dictionary and in here I want to look at land the reason I want to look at land is because inside of main.pi this is where we are storing the land tiles this by itself is going to be a dictionary as well and the name of this dictionary is going to be the name of the graphic we need which means in here we can pass in data this one here you get the proper tile that we need remember here inside of the inside of editor for terrain here what is inside of this dictionary is going to be first of all the position for the key let's say 128 and 64. this is going to be a tuple for the key and the associated value is going to be a string with the file name that we need this could for example be ABC this ABC we can then use to pick one of the graphics from this land tiles here that is basically all that's going to happen inside of this one which means once I have all of that I can get self dot all Sprites inside of the run method and draw the entire thing on self.display Surface and let's see if this is working the game is still starting and now let me draw a couple of tiles and now if I go to the other part you can see in the top left we have our terrain this is looking really good also I can return back to the editor make some more changes go back to the level and this is looking really good I'm very happy with this also while we are here the red background isn't needed anymore this one we can replace with the color from settings in here we have the sky color that is going to make the entire thing look much nicer next up we can start working on the player and for the player we have to look at the objects which means inside of the editor I want to look at the foreground objects I want to inside of this for Loop here use a match case statement and what I want to match is data for example inside of this one case could be zero and this would be the player in another case we could cover here let's say case one this one would be the sky and besides that we could also have for example case four and this would be a gold coin we're going to expand on this quite a bit but for now I only want to work on the player the main thing you have to understand here is that data most of the time refers to the ID of the object we are working with only the terrain and the water are a bit different here but everything else we can cover on the data so with that I want to create a player object and this I also want to store as an attribute meaning self.player is going to be layer this one doesn't exist right now which means inside of Sprites I want to create it I want to have a class for the player and this player has to inherit from generic that way we already cover all of these basic attributes saves me a bit of writing but this one inside of the init method I want to have self I won't have the position and for now all that I need besides that is the group inside of here I can call the super init method and now I have to cover these three parameters here position is super easy because we're getting that from the parameter same is going to happen for the group this one we can just ignore the only thing we have to work with is the surface and this one we don't have right now and for this entire section I am not going to import the player assets as a consequence this is going to be a plain pie game dot surface with a size of let's say 32 by 64 pixels finally after this one to have a slightly different color I want to get self.image and fill this one with a red color now with that back inside of my level besides generic I want to import the player and for this player now I need a position the position I already have and for the group I want to have self dot all Sprites if I run this now and let me draw a Terrain around the player and if I run the entire thing you can see we have the terrain and we have a red rectangle inside of it this is going to become the player later on that is looking really good so now we can add a tiny bit of input for the player to be able to move around all of that is going to happen inside of an input method and here we need self and nothing else we first of all have to get all of the keys that could be pressed this we get with pygame.key.get underscore pressed once we have that I can check if keys and pygame dot k underscore right and let me spell this one properly then I want to do something the same is going to be the case for left and this needs to be an L if statement and finally I want to have an else statement now we can check if the player is pressing right left or neither of the two I do however need some kind of logic to store the movement of the player for that inside of the init method I want to create a section that I called movement in here first of all we need the direction of the player and this I want to be a vector that by default is going to be zero now the shorthand for this Vector we have to import once again which I can do from the editor I want to have this one here we are essentially going to create a vector 2 and I just shortened all of this to Vector to save me some writing this is all that happens in here next up to store the position of the player I want to have a position this one is also going to be a vector although by default this Vector position is going to be self.rect dot top left the last thing we need is a speed and this one I've set to 300 but play around with it it's a fairly subjective value inside of the input when the player is pressing right I want to get self dot Direction I only care for this one about X and this one I want to set to 1. if the player is pressing left there should be negative one and if the player is pressing neither of the two it should be zero the logic here should be fairly obvious if the player is pressing right the direction should be positive all we need now is some way to implement this direction into actual movement for that we are going to need an update method this one is going to need self and Delta time first of all and here I want to check for the input besides that I want to have self dot move this one is going to actually implement the movement and this one needs Delta time this doesn't exist right now so let me create move with self and Delta time and for now what we did in here is self dot pause plus equal self dot Direction multiplied by self dot speed multiplied by Delta time this position here by the way is needed because while self.speed is an integer Direction and Delta time are not going to be integers as a consequence the value we are getting here is going to be some kind of floating Point number and by default pygame is only going to store integers for rectangles which is going to cause some inconsistent movement but if you store that position inside of a separate variable like a vector then you can store floating Point numbers and once you have that you can set self.rect dot top left to the rounded version of self.post.x and the rounded version of self.post.y okay with that we can go back to the level and in here besides drawing all of this I also want self.ul Sprites dot update and in here we have to pass in Delta time and now if I run this and create some terrain tiles like so I can run the entire thing and now the player can go right and left we can't go up and down but for this I want to have proper jumping logic this is going to come later cool but so far this is working really well with that we have another section covered so for the next part we can flesh out the level a tiny bit more for the next part we can work on the animated tiles this means we're going to create the water and the coins inside of the level both of which are not going to be terribly complicated if you can animate a Sprite so let's Jump Right In and let's have a look once again we are inside of main.pi and first of all I want to work inside of the level in here inside of build level besides the layer name right now we only have terrain I want to do a bit more because the other layer name that we have in here is going to be water so inside of the editor if I check create grid we have water as a reminder here this dictionary is going to consist of a position for the key 128 and 64 as an example and the value Associated is either I think I call this water top or water bottom this is what we are going to look for inside of level I want to check if data is equal to and I just realized this one I called top if that is the case I want to create an animated Sprite however besides that so else we also have the plain water or the water bottom this one is not animated as a consequence I can turn this into a generic Sprite and here once again inside of Sprites I can copy the parameters and we have a position a surface and the groups position is really easy this one we are already getting from here a group is also easy we only have a single group I want to have all Sprites however now we are going to need a surface and this one we don't have right now this one I want to import inside of this inputs here and then pass it inside of this dictionary in the level when we are creating level which means in here we need to import a water tile and then inside of this one we need water with something something with a water surface and to be a bit more specific this one should be water bottom and this could be a really good exercise for you try to figure this one out import the bottom water tile place it inside of this dictionary here and then try to use it to create a generic bottom water tile and see how far you get first of all we have to import the bottom water tile this I want to store in an attribute water bottom in here I just want to load one individual surface for this I can use load although I'm not sure if I have it available I do I'm using it here so we can use just load instead of pygame.image.load for the folder pattern here I want to go up on folder then to Graphics then to Terrain in there we have water and there we have water bottom dot PNG like so and this should be spelled like this also important here I want to convert Alpha all of this to improve performance now that we have that inside of the dictionary that we pass into the level I can create a water bottom key and the value Associated is going to be water bottom this I can now use inside of the level inside of asset dictionary we have the entire dictionary available this I want to use for the surface which means acid dictionary in here I want to get water like so and now I can add pass in here for the top part of the water and run main.pi and we are getting a syntax error because you've probably seen it I forgot a comma now if I run this again this is looking pretty good let me Place some terrain tiles and now some water tiles remember for now we are only going to be able to see the bottom water tiles or at least I hope we will and this is looking really good we have bottom water tiles that is going to cover one easy bit so now we can start working on the actually animated tiles and for that first of all we are going to need a list of water surfaces this I can do right away let's call this one the water top animation this I can just import SE holder and in here the folder path is going to be one folder up then we have Graphics then we have terrain and in here we have water and animation this once again I want to place inside of the dictionary and this one I called water top this is going to be self dot water top animation and this should be all we need for this part now inside of level in here I want to create an animated Sprite this one is going to need some assets I want to have a position I want to have a group these are the things we are going to need and I guess while we're here we can pass in the proper arguments right away the position we already have this is what we're getting from here the group is also easy we still only have a single group assets you should be familiar with this at this point we need the asset dictionary and in here I want to have water top that is what I imported just a second ago this bit here finally after generic I want to have an animated Sprite this I can now create below generic I want to have class animated this one also has to inherit from generic 4D init method we are going to need self as always then we need assets then we need a position and then we need a group and for the animation in here we need first of all the animation frames which I want to have as an attribute this is just going to be the assets besides that I want to have self dot frame index which by default is going to be zero and essentially what's going to happen is that we are using this Frame index to pick one surface from this list although first of all we have to call this super thunder in it method and in here we need to have the arguments for the generic class although it's quite simple position we already have this is what we're getting from here and the group we are also getting from there all we have to do is to convert this animation frames and pick one surface from there to get started and this could be a good exercise for you to see if you understand what is going to happen here use the frame index to pick one surface from the animation frames and pass them into the parent class and see if we can figure this one out this one honestly should be really simple we need self.animation frames and this is a list with surfaces which means in here we can get self dot frame index and this right now would pick the first surface from this list that is going to give us one Sprite Which means now inside of the level this one here sorry this one here should actually work let me get rid of the comment and let's actually try if I run the entire thing I can create some terrain again for reference and now I can place some water like so and let me run the entire thing and we're getting an error that error happens inside of here that we have list index out of range which is a very common error what it basically means is that inside of this animation frames we don't have any items let me actually demonstrate if I print self.animation frames and I run main.pi again and I am drawing some water tiles you can see that what we've imported is an empty list the reason for that most likely is that I messed up the folder path here and I can already see that Graphics is misspelled the rest looks pretty good though if I run the entire thing with this fix and play some tiles again and now I can play some water you can now see we have the water on top of that you can see now we have a list with all of the surfaces one for each Sprite that we are going to create although I don't actually want to do that although you can probably already tell this thing is not animated for that I want to have an animate method in here we need self and Delta time this I also want to call inside of an update method in here we also need self and Delta time and I want to call Self dot animate with Delta time all we have to do in here is we have to get self.frame index and add the animation speed this is what we're getting from the settings all the way at the top here we have animation speed this is what I'm going to use in here this I have to multiply with Delta time to be frame rate independent and this I want to now use with self.image and I want to get self Dodge animation frames and I want to have self dot frame index essentially what we're doing here self.frame index is going to become a larger and larger number and this larger larger number we're using in here to pick other animation frames for the water tiles although there are going to be two problems problem number one is that self dot frame index is a loading point number and we cannot use 30 point numbers for indexing so this we have to fix besides that self Dot frame index is going to be two large very fast the way you have to think about it for the water frames we have three surfaces as a consequence we could only use very small numbers for the indexing 0 1 or 2. if we have a number larger than that we're going to get an error the problem is frame index is going to be quite fast much larger than that so this is what we have to account for and this is going to be your exercise see if you can figure this one out and again if you know animations this shouldn't be too difficult first of all this part here is really easy all we have to do is this self.frame index we need to convert to an integer that way we can always use it for proper indexing besides that let me get rid of this first part we have to make sure self.frame index is never getting too large this I want to do on a separate line of code in here I want to get self.frame index is going to be zero but only if self dot frame index is greater or equal than the length of self dot animation frames which means if this cell.frame index becomes a number so large that we will get an error here for the indexing we are setting this number back to zero however if that is not the case so else I just want to keep self.frame index s cell dot frame index so no change and with that we have the second part of the exercise since we already call update inside of the level on all of these Sprites there's not much else we have to do which means I can now call main.pi and draw some terrain tiles once again and now some water tiles and let me run the entire thing and we are crashing because animation speed is not defined this happens because inside of here we're not importing settings which means from settings import everything let's try this again now some terrain and some water enough around this this is looking much better and you can see all the way in the top we have some water animations I guess I could make this a bit more visible if I add the water down here and here you can make this look very silly if you really wanted to like so and well there we have animated water now that we have that we can use this animated class for the coins as well it's not actually that much of a change for that though I have to import some more Graphics this is going to happen inside of main inside of imports once again let me actually add some comments here to make this a bit clearer this one is going to be the coins and this one is going to be the terrain for the coins I want to have self.gold self.silver self dot diamond all three of those are going to be import folder and the folder path for all three of them is going to be fairly similar we have to go one fold up then we have Graphics inside of there we have items and then here we have gold we have silver and we have a diamond I suppose I should probably show all of this a bit more visually here is the folder that I can make it tiny bit smaller we have Graphics inside of there we have the items inside of there we have diamond gold and particle I'll talk about this one in a second but the folder path here is what we need so Graphics items and then diamond gold or silver for now this we now have to get into the level which happens inside of this or rather this dictionary here which means in here I want to have gold this is going to be self dot gold like so I can copy this two times I want to have silver and I want to have a diamond and this is looking pretty good with that inside of the level I have to figure out when I have any of these coins this is going to happen inside of this match data because in here I know case 4 is going to be gold case 5 is going to be silver and case 6 is going to be a diamond I know this from settings we have 4 5 and 6 for Gold Silver and diamond all three of those though are going to get the same class I want to have a coin glass in here like for the animated class I want to have assets I want to have a position and I want to have groups spelled properly now once again we know the groups already we want self.all Sprites this one doesn't change besides that for the assets we know this one already we have the asset dictionary and in here we either want gold we want to have silver or we want to have a diamond there is one more thing I do want to add in here all the way at the beginning I want to have something like a coin type this could be gold this would be silver this would be a diamond that way later on I can identify what kind of coin the player collided with although for this tutorial I'm not going to use it it's just if you want to expand it yourself now we have to actually create a coin and let me import it right away so inside of Sprites below animated I want to have glass coin this one since we do want to have an animated Sprite it has to inherit from animated which means inside of the init method we first of all have to use all of the arguments we used here let me copy them actually we first of all want to have some kind of coin type then we need assets the position can stay as it is and finally we have a group all of this now we have to pass into the parent class with super init on the parent class we have assets position and group these I want to pass in here and I think you can tell this is going to be quite easy because these parameters are identical so we don't have to do anything the one thing that we do have to do though is store this coin type here as an attribute which means sales.coin type is going to be coin type however there is going to be one issue although you're going to see in a second what I mean for now though this is looking pretty good which means I can run main.pi again let me play some terrain and now I want to place one of each type of coin and if I now run this we are getting an error that coin.net takes four position arguments but five were given which means I forgot the self in here now if I run this again do the same thing let's Place one of each coin and let's try this now and there we go we have the animations for each coin although I hope you can see the problem in there because all of the coins are a bit off center if this one here is the grid you can see this looks weird there should ideally all be on one straight line and they all look a bit weird right now the reason for that is once again if I have a bit more space here in our game we have 64 by 64 tiles so 64 by 64. and all of the coins are smaller than that as a consequence Pi game is going to place them in the top left and we're going to have some weird positioning this we can fix quite easily though all I want is self.rect is going to be self dot image and get underscore rect and now this Center should be the position this is working because when we exported the position for the coins inside of the editor I hope I find it for the coins we added half of the tile size for x and half of the tile size for y that way we're placing the coin in the middle of this tile and this we can use in here earlier on inside of generic for all of the other Sprites so far we always place the top left which is not what I want to do for the coins but this should now fix the entire thing let me Place stuff again let's do a few more coins actually and if I run the entire thing this is looking much better cool so with that we have some coins now all of this is a good start but we can't actually do anything with the coins so let's work on that it's not that complicated inside of the level I want to create another group this one I called self.coin Sprites this one once again is just going to be another group I can just copy this one and minimize the edit method and now every time I am creating a coin I want to have all of the coins inside of both old Sprites and inside of self.coin Sprites that way I can Target them easily and this I can use inside of another method let's call it get points in human itself and nothing else and all I really have to do in here I have to get the collided points and this I get with pygame DOT Sprite dot Sprite or light I forgot the assignment operator and then here once again we need a Sprite we need a group and we need new kill the Sprite is going to be self dot layer the group is going to be coin Sprites and do kill I want to set to true because I do want to get rid of the coin and with that inside of the event Loop let me clean this one up a tiny bit more we essentially have an update part and we have a drawing part inside of the update part I want to call self and get coins if I run this now and I do have to be careful here because the player can only move left and right so I'm going to place the coins to the right if I run this now and the player moves to the right the coins disappear that's a good start although it's not exactly an exciting thing here for that I want to create a particle effect every time the player collects a coin which means after running all of this I want to or Sprite in collided coins I want to create a particle effect and this particle effect is going to be kind of like the animated Sprites except it's only going to play one animation and then destroy itself although and here once again we need assets we need a position and we need a group also this one we do have to import so besides animated I also want to have a particle or this one let's cover a couple of the arguments first position is the easiest one because in here I want to have Sprite Dot rect.center I'm going to place this particle in the same Center where we add the coins we just collided with for the group I want to have self.allsprites that is all we are going to need next up we are going to need the assets this I first of all want to import inside of main.pi inside of the coin section in here I have self dot particle this is what you have seen just a second ago inside of the items folder I also have particle let me open this one once again we have particle and inside of that we have a simple particle effect it's nothing particularly fancy this I now have to get into the level which I do with the asset dictionary in here I want to have particle and this I get with self Dodge particle now with that inside of the level we have something available although the problem is this get coins doesn't have access to this as a dictionary we have to figure out something else in my case I added another section that I called additional stuff not the greatest name but it gets the job done and yeah I want to have particle surfaces and this I get with the asset dictionary and what I want in here is the partic hilts I think I called it I actually just called it particle so self dot particle and with that I have some particle surfaces that I can pass in here for the assets now what we actually have to do is to create this particle class this once again is going to happen inside of the Sprites let's do it on top of the coins I want to have class particle this one I also want to inherit from animated and for the init method we know we need self we need the assets we need a position and we need a group and the first thing I want to do in here is called the super Thunder init method and pass in the assets the position and the group once again this and this thing is identical so we essentially are just creating an animated class although once again we have to account for the position which I can copy from here and we are good to go if we didn't add this line here the position of the particle would be slightly offset from the coin which I'm trying to avoid besides that we have to overwrite the animate method although we also need self and delta type the problem here is inside of animated this animate is designed to run forever but for the particle I only want to play the animation once and then destroy the object so we have to create a different kind of animate method this one could actually be a really interesting exercise for you write to write an animate method that only animates over all of the surfaces once and if we are beyond that we are going to destroy the entire object so pause the view now and try to figure this one out once again I want to have self.frame index plus equal animation speed multiplied by Delta time this part doesn't change but now I want to add an if statement that if self dot frame index is smaller than the length of self dot animation frames only if that is the case I want to update self.image with self dot animation frames and now in here I need the integer of self dot frame index so far we have kind of covered the first two lines of the first animation although this animation would simply stop once we reach the end of the animation which in our case means I want to have an else statement and I want to destroy with the kill method the entire object and with that I am good to go if I now run main.pi and I can place a gold coin and run the entire thing and if I now get over the coin you can see an animation this one worked really well which means we have a working particle on top of that what you could be doing in here is if Sprite dot coin type is equal to for example gold then we could I know I could print gold in this case and let me run the entire thing again place a couple of gold coins run it and now I'm getting gold and this information you can use to do well whatever you want in my case though I don't really care about it and I want to keep the entire thing a bit more streamlined this video is already getting really long so with that we have the coin logic and I can minimize a bunch of things and this is covering another major section for the next part now that we have some basic system to place things we can place all of the remaining objects and well let's Jump Right In most of this is not going to be too difficult we just have to create a few more classes once more we are inside of main.pi and I want to keep on working inside of the level specifically inside of build level because in here I want to have a few more cases quite a few of those are going to be fairly simple for example for case 11 I want to have another animated Sprite and this one is going to be for the small foreground palm tree let me type it in here small Palm foreground although this is just going to be an animation it doesn't do anything else so the class we already have we can just reuse and in here we need assets we need a position and we need a group once again the group is going to be self dot or Sprites the position we also have this is the one we have used up here and this we don't have to change the only problem we have is we are going to need some assets and this once again is going to happen inside of magnet Pi inside of imports in here I want to have another section that I called Palm Breeze in here we do have a bit of a problem now let me illustrate what I want to avoid here's the project folder I can go to graphics and inside of there we have terrain and we have palm trees in here we have a bunch of different folders and all of them contain some animation for palm tree my issue is I don't want to type the import for every single one of these folders which would be kind of annoying to do as a consequence I am going to store all of them inside of self dot Pawns and now we are going to use dictionary comprehension to import all of them what this is going to mean I want to have a folder as the key and inside of the folder I want to have import folder the function we already created and inside of the app we need a path and this path is going to be to all of the folders which is inside of Graphics inside of terrain inside of palm and then I want to look at the folder although this one has to be a variable and I should spell this properly as well this I want to do for folder in all of the folders my problem now is how do I get all of the folders I hope the rest of the logic here makes sense though all we're really doing we are importing a folder and for that folder we need a specific kind of path this we are getting from here the path to the main folder is always going to be the same but inside of that folder I want to look at every folder that exists inside of that folder which means here is the graphic folder and we are going inside of terrain and inside of palm every single folder is going to be the name of one of these folders this is what I want to get or rather this is what I'm trying to get here and that is information I am getting from walk although right now I don't have work available but that I can change quite easily I want from OS import walk if you remember from way earlier when we did all of the import folder this one here import folder addict and import folder we have used walk there as well so it shouldn't be entirely new inside of work I need a file path that is going to be the same file path I have used here let me copy it and paste it in here and this is going to give me way too much information also by default I can only use this in the for Loop so I have to convert this to a list and this is probably going to be really confusing so I'm going to cut all of this out comment out the entire line and just print what we're getting from this if I run this you can see we have a long list with information all I really care about is the first item in here that is this bit because what this one is telling me as a reminder when we are using work we are getting three bits of information and that is the name of the folder then we get all of the subfolders and then we get all of the actual files besides folders inside of this folder all I really care about is this list here everything else I can get rid of entirely so how can I get this bit then and this is actually quite easy I only care here about the first element so if I run this again and close the game now I'm only getting the first item returned and on this I can run indexing again I only care about item number one which means indexing here again with one I now get a list with all of the folder names and this is what I want to use inside of my dictionary comprehension I can uncomment this and paste what we have just created in here and now we are good to go once again if you have a large enough monitor this is going to be much easier to work with once we have this I'm going to print self dot this should be homes I am definitely getting worse at typing like so if I run this now we didn't get an arrow and this is looking pretty good for example now we get large background and this is a list of a bunch of surfaces and this we can use I hope this line here makes sense honestly it's not that complicated although you do have to look at it for a couple of seconds but then it should be fairly straightforward all right this I now want to get into my level which means inside of switch I want to have all of the poems and this is going to be self dot ohms now this I can use inside of the level to get the assets here I want to have the asset dictionary and inside of there we have the Palms which is going to give us another dictionary on this dictionary I want to use indexing again for example this pointer here number 11 is going to be the small foreground and this one needs to be a string once I have that we should be good to go let me try it actually if I now place a small palm tree run the entire thing we are getting a key error this happens inside of the level and I think the problem here is this key is Palms while I used Pawn now if I run this and place a palm tree and go to the level you can see we have one palm tree this is looking pretty good what we have to do now I can get rid of this comment and duplicate this thing a few more times because now we have 12 13 14 15 16 17 and 18. those are respectively we have the large foreground we have left foreground we have right foreground and then we basically have the same thing except for the background so we have small background we have large background then we have left background and finally we have right background all of those are just going to be animated Sprites that don't do anything else meaning now I can try all of this and place a bunch of palm trees to make sure I can work with all of them so I want to try the alternative ones like so and now let's try this and there we go we have all of the palm trees this looks really good later on we are going to add a few more things in here but for the basics this is literally all we need and I suppose I could add a couple of comments here this is going to be the palm trees and this part is going to be the coins the one thing we have to do now is to get the enemies the enemies are going to be a larger topic so I am just going to place some basic Sprites here that show us that we have an enemy but for those we have case seven we have the spikes then we have case eight this is going to be tooth that's the name of the enemy that's the walking one and this should be an eight and then we have case nine this is going to be the shell pointing left and this I can duplicate because now we have the shell pointing right these are the four cases we now have to account for the easiest one in here is spikes because this one is well not that complicated at all although I still want to place it in a separate Sprite class so I can work with it and the rest I can comment out so we're not going to get an error now for the spikes in here we don't need very much we need once again some assets we need a position and we need the groups position once again it's a really easy bit we don't have to worry about it for the groups I want to have two groups here I want to have self dot all Sprites and besides that I want to have another group that I called damage Sprites these are all of the Sprites that if the player collides with them the player is going to get damaged this doesn't exist right now but that we can change quite easily inside of the init method I want to have self.damaged Sprites and this is going to be pygam.spright dot group and now we have the same issue again we need to get the assets for the spikes this is going to happen inside of main.pi in here in the import I want to have the enemies the spikes here are going to be really simple because we have self.spikes and this is literally going to be a single surface so we can just use load and the file path is going to be one folder up then Graphics then we have enemies then we have spikes and inside of there we have spikes.png although don't forget I want to convert Alpha all of this so just to be thorough here we have all of the graphics I want to look at the enemies inside of there we have the spikes and there we have the spikes literally just one surface this I now have to get into the level in here I want to have spikes and this is going to be self dot spikes so with that inside of the level I can get the asset dictionary and I just care about this spikes cool all we have to do now is to actually create the spikes bikes like so and now inside of sprite I am going to add let me put it here I want to have all of the enemies this could actually be a comment enemies and this could be simple animated objects that way we keep the entire code a bit more organized in an actual example you might even want to think about separating all of this into multiple files for example the player could be its own file the enemies could be their own file and so on but in my case I think this is still fine I want to now create the spikes this one since there's no animation this can just inherit from generic and we don't have to do very much I want to create an init method in here we have self we have a surface we have a position and we have a group this is what we have done here we have a surface position and the groups those we now have to pass into the parent class with super and init and the generic class has position surface and group I can just pass them in here and we are good to go at least for now spikes is just going to be a copy of generic but later on we're going to add a tiny bit more to make this class better for the Collision I am basically going to add a mask but that's a fairly simple thing to add although now inside of level I am already importing the spikes so this should be working now inside of main let me add some terrain and some spikes I can place them anywhere I want actually let's do it like this if I run this now this is looking like we have some enemies very happy with that so that's one part covered next up we can work on tooth this once again is going to be another class and in here we need the assets again that we don't have yet then I want to have a position and then I'm going to need some groups position we have seen multiple times by now although for the groups I want to have the same groups I had for the spikes like so which means if the player is touching tooth the player should get hurt the last thing we have to figure out now is the assets and the same pattern we have already seen is going to follow here I want to have the asset dictionary and then here I have two although this one is going to be a bit more comprehensive than the spikes let me demonstrate actually here we have the folder with all of the graphics inside of there we have tooth and tooth has three different animations we have idle this one's quite long then we have run left and we have run right all of this we have to import this is going to be kind of similar compared to the palm trees which means in here self dot tooth is going to be something that looks somewhat comparable to this line here and to see if you understood that line this could actually be a really fun exercise import all the surfaces images from the file path that you need here is going to be let me copy it really quick this is the folder path you are going to need one folder up Graphics enemies and two and specifically what I want you guys to do is to create a dictionary for self.tooth and every subfolder inside of this folder is going to be the key and then the value is going to be all of the images inside of that subfolder so pause the video now and try to figure this one out should look very similar compared to this since all of this is going to be kind of similar I can just copy the entire bit and paste it in here and well mostly what we have to do is change some names in here most importantly I want to go to Graphics then enemies and inside of there I have two this I have to do for both of the folders so we have one here and we have one here the rest however can remain basically identical which means if I now print self.tooth not toggle move let's see what we get this is looking pretty good we get one key with idle this one has a bunch of surfaces then we have run left and we have run right I'm pretty happy with this and once again this we have to add to the level via the dictionary this is going to be tooth and then here self dot Doof which means now this one should be working so all we have to do is to create this class here and while we add it I want to import it as well so tooth in here and now inside of Sprites we can create tooth class two and just like the player TUF is going to inherit from generic in here as always we need a Dunder init method that needs self the assets the position and the group this is what we have done in here we have assets position and group should be fairly straightforward at this point and at some point in here we have to call Super init and the arguments we need here are for generic we need a position surface and group and in here we already have the position and we have the groups so once again all we need is going to be the surface for that this is going to be kind of similar compared to animated I want to have self dots animation frames this is going to be the assets we get and I want to have self dot frame index by default this one is going to be zero this is going to be identical to what we have done in here unfortunately though we couldn't just inherit from animate it because we have to make a few more changes the major issue is that this animation frames is not a list it's a dictionary what we have in here essentially is we have for example idle and inside of there we have the surfaces besides that we had walk left and this one also has a list of surfaces the issue is we have to first identify what our current state is and then we can use indexing to get the surface which means we have to get one more thing which in my case I get with self dot orientation and by default I want to to go in the right direction this I can now use to create a surface this surface is going to be self Dodge animation frames and in here I now want to create an F string that says run underscore and then the orientation remember here the frames could ever be run left or run right idle is essentially only for the editor inside of the actual game tooth is always going to run which means all we really have to change is the orientation to left or right and then tooth is going to run and phase in that direction with this we are getting an actual list and on this list we are getting self dot frame index and now we are good to go this surface we can pass in here which we already have and we should have a basic start let me get rid of this dictionary here and let's try this now I can play stuff as usual and now if I place tooth and some spikes let's see what happens we are getting an error and I can already tell where this is going this should be self dot orientation next attempt let's Place some spikes and proof and now let's try this and there we go we can see tooth doesn't do anything right now but at the very least we have something finally we need case 9 and 10 and both of those are going to be shells so I'm going to cover both of them at the same time which is quite simple because they are both made by the same class the only difference between the two is that one is going to face left so we're going to pass left and here's an argument and the other is going to face right besides that we have the normal arguments we have the assets we have the position and then we'll get a bunch of groups at least for now I only want self dot or Sprites the reason being the player should be able to stand on the shell without being heard as a consequence the shell is not going to be inside of the damaged Sprites which means all we have left is the assets and this we can work on inside of the Imports once again and then here I want to have self and shell like so and for this once again I want to have something that looks like this let me copy it and now we have to work with this import statement here inside of Graphics we have enemies and there we have shell we actually have left gel and we have right shell in our case fortunately we only need one and I'm gonna go with shell left let me show the folder actually here are all of the graphics we have enemies and there we have shell left and shell right if I got shell left we have idle looks like this and we have a tag looks like this and then we have the same thing for right something like this what we can do for the shell is import only shell left and then flip the entire Sprite if we have a right shell that way we don't have to import so much which means now all I have to do is copy all of this here and paste it inside of this one and we should be good to go let me print what we get self.shell just to make sure if I run this we now get attack and we get idle this is all we need so we have to get this into the level once again this happens with shell enter here self dot shell so now inside of the level I can get the asset dictionary once again and this is going to be shell which means now we just have to create the class for this one which is going to be shell and inside of Sprites we have to make the actual class so class shell this one as before is going to inherit from generic and in here we need it init method we need itself we need orientation we need the assets we need a position and we need a group orientation I do want to store as an attribute so self.orientation is going to be orientation besides that I want to have self dot frame animation frames and this is going to be the assets we just passed into although here's one thing that I realized while testing the game once it was finished this you want to copy because we are going to flip all of these assets if the shell is pointing to the right side and if we didn't add copy we would flip all of the assets even for other classes so this copy here is really important otherwise all of your shells are going to point in the direction of the last shell you have used although speaking of I can now check if the orientation is equal to right then we want to flip all of the frames inside of this frames and this could be an exercise for you I want you guys to flip all surfaces inside the animation frames keep in mind here animation frames is a dictionary with key value Pairs and only the values are actual surfaces and those you want to flip so pause the video now and see if we can figure this one out I want to start with four key and value in self dot animation frames and items and here I want to get once again my animation frames and I want to overwrite the current key or the key value pair and the item I want to add is going to be another list I can start by just copying what is in there and this is going to be surf for surf in value like so we're getting the value here and we are copying all of the surfaces but this is not exactly what I want to do instead what I want to do I want to manipulate this surface and this I get with pygame DOT Brands form dot lip and now we need to surface and we need information if you want to flip this in X and in y and those are going to be true fault statement I do want to flip this thing in X but I do not want to flip it in y and with that we are flipping all of the surfaces if the shell is pointing to the right so I can minimize this one and work on the rest of it what we need now is self dot frame Index this one once again is going to be zero and then I want to have self dot status by default this one is going to be idle and once I have that I can call this super in Niche method and once again we have the generic parameters that we need to cover I can just copy them and paste them in here the position we are getting from up here so this one is very simple the groups we're also getting from up here so nothing to worry about surface is what we do have to think about and this is going to be quite similar compared to two because animation frames is a dictionary we first have to get the status and then we can use indexing for this one I'm not going to create a separate variable because we don't really need it I can just self dot animation frames inside of there I can get self dot status and then I can use indexing with self dot frame index and for start this is all we are going to need let me run main.pi again without cutting an error I can play stuff as usual and now let me play some spikes the enemy and two shells and now if I run this we are getting an error that name assets is not defined this is happening inside of here because I forgot to pass in the proper value for this assets here this is literally the same information because we are flipping all of this data inside of the class now next attempt let's run out of this again let's Place some enemies like so nothing's crashing and there we go we have all of the enemies although you can see they all have a bit of an offset from the floor this area here looks a bit weird yes we can fix right now and then we are nearly done and once again the problem here is that we have a tile size of 64 by 64 and the shell for example is only covering this size which is why we're getting the Gap below that is a very easy thing to fix now we have self.rect and I want to update the bottom of this rectangle and the bottom here I get with self.rect.top plus the tile size which means I am getting the top of the rectangle this line here and I am adding the tile size so 64. and this is why I'm placing the bottom which means now we are getting the bottom information here the same thing I am going to tooth and make sure you're calling this after the Super method otherwise you are going to get an error but now I can run this again and let's try all of this one more time like so and now I can run this and this is looking much better cool so with that we have literally all of the objects inside of the game we just have to make them work a little bit better but at the very least we have a really good start in this section once again is getting quite long so let's finish this one up now that we have the level we can start working on the player movement and for that we are going to need a couple of things first of all the player already can move left and right that's a good start but I also want the player to be able to fall and jump however for that we are going to need collisions with the level otherwise falling and jumping is going to be kind of annoying which means we are going to start by creating collisions with the level let's have a look how that's going to work and let's do all of this trading code once again here we are in the code editor and I want to have a look at my level file in here there's one important thing that I have to figure out and that is when I'm building a level I also want to when placing all of these Sprites I have to figure out what kind of object I want to place that the player can collide with and here we do have to be quite careful for example for it to rain those are going to be fairly simple if we have for example a block or a Terrain block that looks like this I want all of those to be collidable where this becomes a bit more complicated is if we look at all of the palm trees these ones here because for all of those a palm tree could for example look like this with a long stem and what I want is that the player can only collide with this top part here which means for those we have to create some custom way to create collisions which we couldn't do with the animated class so we have to figure out something else and here's what I'm going to do I'm going to create a whole separate class for that inside of Sprites I am going to create a whole another class and this is going to be a very simple one so let me minimize everything else that way we can focus on things a bit easier there we go the class I'm going to create is going to be called class I call this one just block once again this one can inherit from generic because we are just going to create a very simple Sprite or the init method here I want to know I need a self I need a position now I need a size and now I need a group importantly here we do not have a surface the reason for that is imagine once again I have a palm tree that looks in a simplified way something like this what I want to do for this block is to spawn the block on top of the palm tree in this position with this size and this block is going to be collidable while the yellow part is not going to be collidable as a consequence the pink rectangle will not be visible so we don't need a fancy surface I am just going to create a surface from the size and since it's going to be invisible that's really all we need as always we need some kind of super Thunder image method and for this one we have to figure out these parameters here position surface and group position and group are going to be easy those we already have what we have to figure out is how to convert the size to a surface which means in here we need a surface this surface we get with pi game and surface and for this surface we always need a tuple with a size and that is the size we are actually getting so whenever I'm creating this kind of block the size here is going to be a tuple with X and Y once I have that surface I can pass it in here and I am good to go this is literally all I need with that I can minimize this class and back in level I first of all have to import it let me do it right next to generic I want to have a block now we just have to figure out how to use it for that inside of the init method when I'm creating my groups I want to create one more group in this one I'm going to call self.collision Sprites once again this is just going to be pygame.sprite.group and that's all we need in here so I can minimize this and now any kind of object that we are creating inside build level that is going to be inside of the group is going to be collidable with the player for example when I'm creating a Terrain this part here I want this to be in all Sprites and in self.collision Sprites just with that I can make this generic collidable with the player while this one here the water bottom tile is not going to be collidable because it's not inside of the group so with that we already have the terrain covered next up we have to figure out this slightly more complicated bit and that is all of these animated trees and also the shell needs to be collidable the shell is the easier bit because this one we can treat like the terrain I want this to be in all Sprites and self.collision Sprites that way the player later on can collide with them now a slightly more complicated part is going to be these palm trees here because those I couldn't just put into two groups and well that wouldn't work because we will be ending up with the entirety of the palm tree being collidable which I don't want let me first of all separate them into foreground palm trees and background palm trees the background ones we can just ignore because those are not going to be collidable at all those can just remain an animated Sprite and we don't have to worry about them what we have to worry about is the foreground palm trees and then here let me do one example besides the animated palm tree I also want to create a block for this one I'm going to need a position a size and a group for the group for now I'm going to place them in self dot all Sprites and self.collision Sprites although later on I'm going to remove all Sprites that way this block is not going to be drawn but the Collision is still going to work besides that we need position and size position once again is easy we already have that and we used it multiple times what we have to figure out is the size and for what this one well I could measure this in Photoshop it depends on the graphic but for this palm tree I want a width of 70 and a height of 50. also let me move this block that way we can see this a bit easier which makes bug fixing a bit more visual let me actually try this if I switch to main.pi and I play some small Pawn trees and run the entire thing there you can see we now have a black rectangle on top of the palm trees this later on is going to be the collision and I did notice here this I could probably make a tiny bit wider just to be a bit more accurate let's say 76 and let's try this again how to place palm trees again and this is definitely looking better you can play around with this as much as you want there's basically no end to it this we now have to do for the other palm trees as well next up we have the large foreground palm tree this one fortunately has the same top size as the small one so we can just copy this bit and call it a day besides that we have the left palm tree and the right palm tree those have a palm trees that look like this and then we have the top part here which means this is the entire bounding rectangle for the surface and we have to move the Collision One somewhere here that would be the case for the right one but for the left one we can keep it somewhere here because let me use a different color because the left one is going to look like this that is the one we are going to work on in here once again I want to copy the block and since we're always placing this position in the top left I can also leave this one as it is which means I can copy this one more time and now we have to figure out the right foreground Pawn Tree in my case all I really did was I added a vector with 40 and 0 to this and that's basically all I needed that way this block is going to be a bit further to the right which is perfect to capture this top part and let's try all of this if I now Place different palm trees like so and so and run the entire thing you can see that this is working reasonably well although this part here could do some more work let's move it a tiny bit further let's say I want to move it by 46 pixels and place all of them again and that is could still do a tiny bit more let's say I want to move this by 50 pixels and this is the only one I want to place and there we go this is looking really good with that we have a collidable object for all of the foreground palm trees body shells and for the terrain this is literally all we need obviously for the terrain and for the shell we can't really see them right now because we are using the object itself as a collision object but that is something we can work on later for now what I want to do is to remove these self.all Sprites from all of the palm tree Collision objects that way they're not going to be visible anymore but once we work on the player they are definitely going to be felt like so and this is all I need for this stuff here there's one more thing that I do need and that is when I'm creating the player all the way up here this player needs to know the position of all of the collidable Sprites I can just Place self dot Collision Sprites and here and that way the player is going to have access to them and really important here for the player I am assigning the player Sprite to the group all Sprites and I'm giving the player a reference to the Collision Sprites but the player itself is not inside of the group or is not going to be inside of the group this is different for example to the terrain the generic type we create up here we are placing this generic inside of all Sprites and collision Sprites understanding the difference here is really important the player only has a reference to Collision Sprites but is not itself in it because it couldn't collide with itself that would be weird but now the player has access to all of the collisions which means inside of sprite I can look at my player one more time and first of all we need another parameter this one is going to be the Collision Sprites this I want to capture inside of a variable let me add another section here that I called Collision I want self.collision Sprites it's going to be Collision Sprites and while we are here there's one more thing that I do want to do and that is that the player should have a hitbox and this is supposed to be a rectangle as well the size of it I think is best explained by looking at the graphics here is the folder for all of the graphics I want to look at the player and let's say I want to look at run left if I open a random one inside of this the entire surface is going to have a size something like this but not all of this is supposed to be collidable what I want to have is that the player can only collide with this rectangle here more or less which means I have to shrink the original rectangle quite a bit and for that I want to get self Dot rect and this I want to inflate and now I need to inflate it by an X and A Y amount Y is going to be zero because I'm happy with the height X however I want to shrink by 50 pixels and with inflate we are keeping the Center Constant which means if this one here is the original rectangle we are creating one that looks something like this that we are shrinking by 25 and 25 pixels on each side that looked best when I tested the entire game now we have to incorporate this hitbox into the player movement as well that is going to happen down here inside of the move method and this one for the collisions we have to change quite a bit anyway the most important thing that we have to do here for now is we have to split this into horizontal and vertical movement why that is you're going to see later but it is going to be really important for the collisions to fix this one first of all I still want to get myself.poss but now I want to get the X part of it to this I want to add self dot Direction dot X multiplied with self dot speed and multiply this by Delta time this I now want to use to move the hitbox so self Dot hitbox and remember the hitbox is just going to be a rectangle but you couldn't use the left for this one because this would make the math kind of awkward if I show the drawing again I want to start by moving this Collision rectangle and then later on make this actual rectangle that shows the position of the player follow in the same position and then placing this Collision rectangle in the top left is going to be kind of awkward because we couldn't translate this easily to the original top left which means in my case I'm going to place the center of the hitbox that way I can use this Center also for the positioning of the larger rectangle that shows the player that is going to make my math quite a bit easier so for this one I want to place this Center and this I'm getting with round self dot post dot X and once I have that I can place self.rect.center X it's going to be self dot hitbox dot Center X and I noticed this one should be Center X not Center because we only care about X or the horizontal movement for now the same thing we now have to do 40 horizontal movement which means I can copy all of this paste it in here and this bit I can get rid of and essentially now I just have to replace all of the X's with y's and then I should be good to go sort of the X should be a y and now we basically have the same outcome with one intermediate step we can see the hitbox however when we are creating the position when I'm creating this Vector I don't want to have the top left I want to have the center just to keep things consistent and with that let's try all of this actually so let me draw some terrain tiles run the entire thing and the player can still move left and right so that's a good start we make this even more visual let me minimize the build level and inside of run right now we are drawing all of the Sprites on top of that I also want to pygame dot draw Dot rect on self dot display surface with let's say a yellow color I want to draw self.player Dot hitbox if I run all of this again I can run the level straight away we can't see anything the reason for that is that right now the player has a width of 32 pixels and if we shrink this by 50 pixels we can't see anything but if I change this let's say to 80 now if I run the entire thing let me draw some terrain tiles and run this this is looking much better the yellow bit is now what is actually going to collide with the level so with that back and Sprites I can actually start working on the Collision logic this I'm going to cover in another method let's call it Collision in here we need self and we need the direction first of all here we have to look at all of the Collision objects which we get with four Sprite in self dot Collision Sprites remember all of the collidable Sprites we put inside of this group once we have that I want to check if Sprite dot rect dot collide rect with self Dot hitbox now I'm checking after I have all of my Sprites I want to check if the player hitbox collided with any of these Sprites inside of that if statement I want to add another if statement because now I want to check the direction is the direction equal to horizontal that I want to do horizontal collisions for now I'm going to add a pass if that is not the case so else I want to check vertical collisions for now I'm just going to add a pass in here in here now we just have to figure out some basic things let's say for example we have the player here and the player is moving to the right this direction we can get from up here the direction of the player that one is quite easy to get so we always know if the player is moving right or left and if the player for example is moving to the right and he just overlapped with an object like so all I really have to do is put the right side of the player so this part here on the left side of the obstacle and once I have that I basically have collisions which means inside of Direction I first of all want to check if self.direction.x is greater than zero this means we are moving right if that is the case we are moving right and we have a collision that means the players colliding with an object on the right side and this I can use to set self dot hitbox dot right equal to Sprite Dot rect.left if I draw all of this again the right side of the player is going to be this bit here and the left side of the obstacle is going to be this side here that way as soon as there's any kind of overlap we are putting the right side of the player on the left side of the obstacle and we have a collision the same thing we now have to do with if self.direction.x is smaller than zero if that is the case we are moving left and in here we can check self.hitbox.left is going to be sprite.rect dot right once we have done all of that I have to do two more things first of all we have to update the rectangle this is the one that the player is actually going to see for this one I also want to update the center X and I want to set this to self dot hitbox dot Center X what this means is imagine we have the player moving to the right but then because of a collision we moved this rectangle a bit further to the left as a consequence the center of this rectangle moved from here to let's say somewhere here all of that just means that the Collision has changed but it doesn't tell Pi game without this line here that we want to draw the player in a different position as well but once we have this line we know that we also want to draw the rectangle so what the player actually sees around this new center that way the player can actually see the Collision finally the actual position that we have so self.post.x I also want to update this is going to be self.hitbox.center X and that is all we are going to need for horizontal collisions I can call this method now self.collision don't forget to pass in horizontal in here and now if I run main.pi again and draw some terrain tiles next to the player and run the entire thing if I now move too far to the right I can't go any further same as the left side this is looking really good the same thing if I return to the editor I can also do with a palm tree let's place it here run the entire bit again and the same thing is also going to work with a palm tree so I'm very happy with this which means all we have to do now is copy all of this for the vertical collisions and this is going to be your exercise let me add a bit more space I want you guys to copy the logic here and apply it to the vertical axis so pause the view now and try to figure this one out this one is going to look basically identical compared to this one although we can make all of this a bit more space efficient but I also want to be able to test out of this for that first of all let me copy these lines here and now I want to check if the player is moving down or up and if that is the case I want to move y for all of these with that I have to add a pass in here again let me test this and Run the game and switch to the level now I can move the player around as I want obviously this is not going to be the logic for a side scroller but that we're going to implement in just a bit this is good enough to test things now in here I now want to copy this logic but make it a tiny bit more space efficient because there isn't that much happening here and writing six lines of code is kind of Overkill we can set self dot hitbox.top so this is what I'm doing here basically except for top and bottom I want to set this to sprite.rect dot bottom this means if the player is moving up and overlaps with a wall on the top if that is the case I want to move this top side here to this position the bottom of the wall but I only want to do this if self dot Direction dot Y is smaller than zero meaning the player is moving up if that is not the case so else I want to keep self.hitbox.top as it is the same thing I can do for the bottom so now I want to place the bottom of the player to the top of the rectangle which means now the player is moving down like so and overlaps with a wall on the bottom I want to get this bottom part of the player and move it on top of the wall this is what I'm getting here and this I only want to do if the player is moving down so Y is positive or direction that Y is positive to be a bit more specific if that is not the case I want to keep bottom as it is this Alliance basically do the same logic as these four lines here except in well much less space all we have to do now is copy these two lines here I want to set self dot rect.center Y and I want to set self dot pause dot y both of these are going to be self Dot hitbox Dot Center y all I have to do is copy this one and I am good to go with that we have covered the same logic that we have here for the vertical side in half the amount of lines which I think is also a bit more readable but it's a bit subjective let's try it actually now let me place a couple of terrain tiles all over so it's easy to test like so if I run all of this I can move around this Collision works pretty well and in here there is a bit of a problem the other collisions seem pretty good though oh this one is also not great so we have to look around here a bit so the vertical collisions definitely not ideal yet let's have a look I think I actually realized what the problem is I am not actually calling inside of the move method self dot collision with vertical now let's try this again if I now run main.pi let me draw a few things again like so now the collisions are working much better and this is pretty good I'm quite happy with that part okay this seems to be working just fine so I can leave this one as it is I can't see any kind of problem here while we're here I also want to make all of this as space efficient as this bit down here I guess I can also explain the logic a bit better I want to place self dot hitbox dot write to sprite.direct.left but only if this condition here is true if it is not true I want to keep self.hitbox.right where it was before this is going to cover this part here so I can take it out and duplicate this line and to duplicate this one here I want to place the left side of the hitbox to the right side of the wall but only if the direction is smaller than zero that way we're moving left and now I can get rid of this bit here finally I want to assign self.rec.centerx and self.post.x where the hitbox is like so and with that all of this is much more easily readable yes one thing I forgot and here at the end this should be hitbox left but with that we should be good to go let's try this if I now place a few more elements and try all of this still looks pretty good so yeah this is working just fine cool very happy with this with that we have Collision logic and the entire Collision logic here really isn't that complex this is still fairly simple it's like a minimize for now and now we have to work on the actual player side scroller movement logic which means that the player actually moves like a 2d platformer for that we first of all want to get rid of this one here because well the player shouldn't be able to just move up and down we should only be able to jump and fall inside of the init method I want to create a few more attributes the first one is going to be self dot gravity this one I have set to 4. besides that there's one more attribute that I want and this I called self and on lore this by default is going to be false later on the player is only supposed to be jumping if he is on the floor if it is not the player shouldn't be able to jump that way the player couldn't keep on jumping in the air now we have to implement all of this and for this let me minimize a couple of methods here besides move I want to have a method I called apply gravity this one needs self and since we have movement this is also Delta time and that is some horrible spelling all I really want here is self.direction.y plus equal self dot gravity multiplied by Delta time as always gravity just means we are falling down so y gets larger and larger and this number I now want to add to self.rect.y plus equal self.direction.y note here what is really important I am using plus equal twice which means that we have an exponential false speed this Direction gets larger and larger every single time and this number we're always adding towards the position but that is all we need I can minimize this one before I'm running move I want to self dot apply gravity with Delta time if I run this again now and let me just go to the level and the player is indeed falling that is a good sign now let me try the same thing again with some terrain and we have a platform and there we go now we have some basic movement although if I wait for a bit this should eventually break I just have to wait for a bit maybe it doesn't but basically now if I fall down the player moves down really really fast the reason here is when the player was still standing here we kept on increasing self.direction.y which means every millisecond the player stood on this platform the gravity that he would be subjected to was larger and larger in practice pygame would put the player down to let's say this position here realizes it's on top of a Terrain and place the bottom of the player back to this position here if this was running for long enough though we would eventually get to an arrow that is somewhere here and then pygen would assume that the player just jumped over the entire platform another problem that we have seen is if we wait on the platform here for a while and then fall down all of a sudden the player falls down at a really fast speed so we have to account for a couple of things here this is actually going to happen inside of collision what I want to do if the player is colliding with something vertical I want to reset the gravity which means I want to set self dot Direction dot y back to zero which effectively cancels out all of the Gravity we have applied inside of this method here and this is really important that way the player doesn't accumulate gravity while standing on the platform which would become a massive issue when we're trying to jump or falling down from a platform kind of hard to test but this is basically all we need in here okay and now that we have that I also want to cover the jump mechanic this one we are going to start inside of input and what I want to check in here is if he's is pygame dot k underscore space meaning the player is pressing the space button and self dot on floor is true if that is the case basically all I want to do is move the player upwards so self.direction.y is going to be 2 and just to test this let me set self dot on floor this we get up here to true if I run all of this now and let me add a platform here so we can see what we're doing we are getting an error that I have made a typo this one here now let's try this again and I create another platform and now if I press space the player goes up and comes down again this is looking really good I'm quite happy with this all we have to figure out now is how to check if the player is actually standing on the floor since we don't have that right now let me actually show what problem we have and let me add a couple of terrain tiles here so this is a bit easier to show if I am in the air the player can keep on jumping which um well I hope you can see the problem with this is is not his side scroller we rather have some kind of Flappy Bird kind of thing this we have to account for which means by default I want to set on floor back to false the input we don't need anymore and we also don't need the init method instead I want to have another method that I called check on floor no custom parameter needed here and essentially what I am going to do if this one here is the player I'm going to create a rectangle below the player like so and if this rectangle here is colliding with some kind of collidable object we know the player is going to be on some kind of floor for that first of all I want to create a floor rectangle this one is going to be pygame Dot rect and now we need the left the top the width and the height the height is going to be fairly subjective I've set this one to a 2. two pixels for this one is perfectly fine but we also have to figure out the width the top and the left side and this I think could be a really good exercise for you try to figure out all of these values and see what you can come up with so pause the video now and try this one yourself the width is very easy I want to get self.hitbox.wiff that part should make quite a bit of sense if this one here is the hitbox of the player and this one is the entire player drawing what I want is this area here this one right now is two pixats high that's what we are getting here and the width is going to be this area which is the same width as the hitbox which is what we are getting here while we have that let me draw this again we have the player hitbox and we have the floor rectangle now we have to figure out the top left and this one is going to be quite simple because all this is going to be is the bottom left of the hitbox let me turn the width and the height into a tuple that way we can turn the positioning also into Tuple and here I want self.hitbox.bottom left just to check if this one is working I want to turn this self.floor into an attribute now after we're moving I want to run self.check on floor and inside of the level after we are doing the update that's really important so after this line here I want to draw all of this I guess I can copy this rectangle Here and Now self.player.floor rectangle and I'm going to use a different color let's go with pink if I now run off this again draw something here it doesn't really matter what it is and now we have a very small pink rectangle on the bottom of the player it's quite difficult to see but if you squint you can definitely see it so this is working I guess just to make it a bit more visible let me change this to a 20. and try out of this again there you go now it's much more visible but this one should only be two otherwise we get weird results this rectangle we want to check if there's any kind of collision with the floor or rather with the Collision Sprites for this one I'm going to create another variable let me call it floor Sprites and in here I want to get all of the Sprites that this self.flor.rect is colliding with and this I get with Sprite or Sprite in self dot Collision Sprites now I'm copying all of the existing Sprites but I only want so if Sprite dot rect dot collide rect with the floor rectangle and this self we don't need anymore what this list comprehension here means is we are copying all of the Sprites from the Collision Sprites but only if a Sprite is colliding with the floor rectangle this we can now use to check that self on floor is going to be true if there's anything inside of this list meaning if we have floor Sprites if that is not the case so else it is going to be false that is all we need in here now inside of level I want to get rid of this line here because this one would throw an error but now inside of main.pi let me draw once again a couple of platforms and run this again now I can jump but I can only jump if I am on a platform this is quite nice I can also jump to another platform and this is looking much more like a side scroller except I can't play it well so with that we have the player movement another major step for the next part we can actually show the player that is going to make the game much more visually appealing with the player movement coverage we can work on the player graphics and this one isn't going to be terribly difficult first of all we have to import a couple of different things all to play animations then we have to figure out what the status of the player is so is the player falling jumping running we also have to know what direction the player is facing so left or right but once we have all of that we just need a simple animation and we are good to go which means once again let's jump into the code editor and let's have a look at all of this back in main.pi I need the first step I have to import some player Graphics which I want to do in here because the player has a ton of different Graphics I am going to place this all the way at the end here I have the player and all of this is going to be inside of one attribute let's call it player graphics once again if I open the folder we have the project here there we have Graphics there we have the player and here are all the different possible states that the player can have for example we have idle right we have four left lots of different things that we could import and what I want is a dictionary and the key is always the name of the folder and the value is going to be all of these surfaces imported this we have done a couple of times already which means I can just copy this one here for example and paste it in there the only difference being that when I look at the folder there should be graphics and layer and the same we're going to do for the other folder this should be graphics and layer there we go and now let me print self.player graphics just to make sure this is working and there we go this is looking pretty good now we have four left we have fall right and we have lots of other states I am quite happy with that now we have to get this into the level this once again is going to happen inside of the switch method in here I want to have another entry for the player this is going to be self dot player graphics that is all we need to import the graphics next up we can work inside of the level in here the important thing is that we are getting all of these Graphics into the player class so in here let me do it all the way at the top I want to have the asset dictionary and I want to have the player Graphics this I now have to store inside of Sprites inside of the player Sprite with another parameter so in here I want to have the assets this I now want to turn into some animation logic and here first of all we want to have animation frames and those we're getting from the assets next up we need self.frame Index this one is going to be 0 and now we need self dot status this one by default is going to be idle finally we're going to need self dot orientation by default this one is going to be right these two lines here are already the second step of what we have to cover now we have the graphics with this part here the next step is figuring out the player's status so what is the player doing and which way is the player facing once we have that though we can create a surface and for the surface we have a dictionary with all of the different states as a key and then Associated we have a list of values right now I want to combine these two here to pick one key from this dictionary to get one value or one list of surfaces and from that I want to get the first Index this could be a good exercise for you to see if you can follow along try to get the surfaces that are either right and pick the frame index 0 from that and set this as the surface and then you can pass this surface in here like so okay first of all we want to get all of the animation frames in here I want to get some kind of string that is going to be idle right so I'm combining this one with this one with an underscore separating the two and this I want to be more flexible so I'm going to use an F string replace the first one with self dot status like so and right should be self dot orientation this is going to give me the full status of the player and this entire thing here is going to return a list of services on this list of surfaces I now want to perform indexing with my frame index and that is the entire line that we need so if I now run may not Pi let me play something and go to the level we can't see anything the reason here is we are drawing over the entire surface this I don't want to do anymore I also don't want to draw this happen inside of level in the run method I don't want to draw the hitbox anymore like so and now let's try this if I now switch to the level we can now see the player it doesn't actually update but well that is something we can work on next the rest is still working just fine let me minimize the init method and now what we are going to need is two more methods the first one is going to be get status and here we need itself and nothing else let me add pass in here and besides that I want to have an animate method this one needs self and Delta time in here as well I also want to have pass let's work on animate first that one is going to be the easier one and this is the kind of method we have already seen a couple of times so if you want to do an exercise here right to write the animate method it's going to be quite similar compared to the one we have created in here I could actually just copy the entire thing at least for now and pass it in here all of these are actually I think the naming are kept fairly consistent so all of this should still work just fine we just have to call it so inside of update all the way at the end I want to have self Dot and made with Delta time oh although I did realize there's going to be one error in here and that is these animation frames by default are not going to work because as you have seen here we need something quite extensive to get the actual animation frames I think the best way to approach this is copy all of this and create a current animation and this is going to be what we get in here but we're not indexing from it I hope I didn't go too fast just now but once again we're getting the animation frames and then we are getting one list of surfaces by using the full status once we have that I can replace these animation frames with the current animation and those ones as well that way later on inside of get status all we have to do is change this status and this orientation and we always get the proper current animation but this one should already work let's try this one and if I now run the entire thing you can see we have an animation doesn't change but at the very least the player is animated very good so now we have to get get status in here I want to check if self.direction.y is smaller than zero if that is the case self dot status is going to be jump after that I want to have an L if statement and the condition is going to be self.direction.y is greater than zero now we are falling so self dot status is going to be all if neither of those two are the case I want to have an else statement and this else statement is only going to trigger if direction.y is zero and this means the player is standing somewhere on the platform all I really have to check is if self.direction.x is different from zero if that is the case the status of the player is going to be run however if Direction dot X so else if this one is zero then self dot status should be idle and I don't really like that we're using four lines of code for something so simple which means I can rewrite this a tiny bit I want to have self.status being run only if this condition here is true if it is not so else then I want to have self.status being idle this one down here and with that we have the entire thing much more concise this get status we now have to call let me do it right before animate self dot get status what is really important here is that you're calling this get status always after applying gravity and move especially move here is important because in there if the player is on a platform we are changing self.direction.y to zero and that way we know if the player is falling or jumping or standing on a platform and now let's try this one and you can already see something is working although the player is always falling that is not ideal also the player doesn't face in the right direction so there are a couple of things we have to work on first of all let's start with left and right that's actually the easier one because in here inside of input if the player is pressing right I want to set self dot orientation to write and if the player is pressing left the orientation should be left let's try this one now and let me Place once again a few more terrain tiles I guess while we're here I can also place a couple of palm trees like so and we are definitely making progress so I can move left and right I can see the player jumping and this is definitely looking better the problem now is if I am on the floor the player is always falling so this is not ideal or this one I can minimize the input method and the easiest way I found to fix this is when we are checking get status here right now I am checking if the direction.y is greater than zero but I want to set this to 1. if I try this now and create a few more platforms once again now this is going to work the reason here is highgame basically moves the player down a tiny bit on every single frame and then checks if we are colliding with something if that is the case Pi game moves to the bottom of the player here but because of this Collision check we always have a very low y direction and this one we know that this is so small it is never going to exceed one so if we have a one here this is fairly safe and with that I can clean all of this up a tiny bit and now we have the animations for the player so let me place a few more platforms to make sure this is working and I can place I guess a few more palm trees in here like so and let me also place a couple of background ones so we know that those don't cause a problem this is looking pretty good and the player can move around just fine and the animations also look really good so I am very happy with this the game is definitely taking shape so yeah we are absolutely making progress for the next part I want to create the camera there are basically two major things that we need here number one the camera should always follow the player meaning the player is essentially always in the middle of the window and everything else gets drawn around the player besides that I also want to sort all of the objects in the level by depth this one is going to ensure that we for example always have the background palm trees in the actual background right now Sprites are going to be sorted by the way they are being created so if one Sprite is being created after another Sprite the Sprite that is created later is going to be on top which isn't terribly reliable to well create any kind of graphic system so let's work on those two things this shouldn't be too difficult inside of the code I want to work inside of a level and the way the camera is going to work is we are drawing everything inside of all Sprites this I want to change a bit or well I want to instead create a camera group this is still going to be a spread group but a special one that is going to draw everything in relation to the player this I want to create in the same file so let me create another class here that I called camera group this one has to inherit from pygame.spright.group this one as always is going to need a niche but there's no need for any kind of custom parameter however we do need to call Super thunder in knit once we have that though we have basically created a perfect replica of a normal pygam Sprite Group which means if I run the entire thing now let me draw a couple of terrain tiles and let's test a few more just to make sure everything is still working is looking pretty good so we are now drawing everything via a custom group but so far this custom group is a perfect copy of its bright group this we want to change though and first of all I need a few more attributes the first one is the display surface this one I'm getting with pygame DOT is Lay dot get underscore surface and besides that I want to have an off set this one by default is going to be a vector what we are now going to need let me call it a custom raw method this one in itself and we also need to know where the player is in here though first of all we need to draw something in general and what pygame does internally it does for a Sprite in self works because we always attach all of the Sprites to this group and now all we need is pi game and now we can use this for blitting so I want to get self.displaysurface dot lit and then here I want to have Sprite dot image and Sprite Dot rect this I can now use inside of the run method instead of running all sprites.draw let me comment this one out I want to get self dot all Sprites dot custom draw and in here I don't need to display surface because this group always has the display surface instead what I need is the player this I get with self.player well now this doesn't do anything but later on we are going to draw everything in relation to this player but let me first of all try this if I draw and run the level so far we haven't made any kind of change and let me get rid of the comment here we don't need that one what I can do in here when I'm drawing or blitting all of the Sprites I am always putting them in the same position where the rectangle is but I don't necessarily have to do that instead I could for example get an offset rectangle and this offside rectangle is going to be Sprite dot right let's copy it and this offside rectangle I now want to offset this I can do with offset rect and let's move the center minus equal by self dot offset which means now instead of drawing this sprited rectangle I want to draw a surface wherever the offset rectangle is this one we have created here since the offsite right now is 0 and 0 this isn't going to do anything meaning if I run out of this once again there is no change whatsoever we always starting in the top left however what I can do now if I change this Vector to let's say something like 250 if I run this now and let me add a few more things in here now everything is drawn 200 pixels in this direction and 50 pixels up this I can use by default though this Vector here should be 0 and 0. the way I want to use this offset this should always be relative to the player and in here I need self.offset.x and self dot offset dot y I want to get player.rect Dot Center either X or Y depending on what axis we are looking at and from that I want to subtract the window over to window with like so or the window height like so and both of these I want to divide by two what this basically means is imagine that this one here is the player and I want to draw everything else in the level so all of the tiles everything relative to the position of that player this means I want to look at the center of the player this is what I'm getting here and then the top left of the current part of the window should be half of the window width to the left that's what we are getting here and half the window size up this is what we are getting here the resulting point is going to be the top left of the window if I try this one now and let me draw lots of terrain tiles like so go to the level and now you can see we have a camera following the player and with that we have some basic camera logic so this one here is kind of all we need for the camera although there's one problem that I do want to account for if I run the level editor again and let me draw some terrain tiles and place lots of palm trees floating in the air that should make it a bit easy to illustrate what I'm talking about also a couple of background ones like so and run the entire now inside of the level the player this one actually worked really good I want the player to be on top of the background palm trees and behind the foregone palm trees at least for the stem bit I place them a tiny bit too high but the problem here right now is that the depth of all of these tiles is decided when we are creating them so the later Sprite is going to be created the more on top it is going to be which sometimes could mean that the player is behind a palm tree which I really want to avoid and for that inside of Sprites let me minimize the player I am going inside of generic going to add one more parameter that parameter I called that and that by default is going to be I have different settings actually down here we have the different layers of the level all the way in the back we have the clouds then we have the ocean then we have the background water and Main most things are going to be in Main which means the default argument let me copy level layers in here is going to be inside of main that way once again we don't have to make any change to the existing Sprites which would be a pain to do this I now want to turn into an attribute so self.zet is going to be Z for the block we can ignore this system entirely because the block doesn't really care about where it's drawn oh well it's not even drawn at all so this one doesn't matter at all next one for animated this one doesn't need that although here once again I want to have a default argument that I can just pass in there so we don't have to make any change to the existing parts and this is that I want to pass into the parent class like so and this is the only change we really have to make here inside of level let me minimize the camera group and the init method and I want to look at my build level in here when I'm creating these palm trees and these palm trees this is the only time where I really care about the depth because those always need to be in the background and this I can achieve by adding one more argument all the way in the back and this is level layers this is what we're getting from settings and in here we have the key BG so inside of settings we have BG that way all of these palm trees are going to be drawn in the background in particular behind Main the other place where I really have to care about this for now is when I'm creating the water this one here this one also is going to need another argument for the level layers and this one here I called water so in here we have water this one I want to be on top of the background but behind Main and with that we have the basic information for all of the layers if we don't specify this one here these Sprites are always going to be on the main layer and for all of those I'm pretty happy with them we only really care about these and the water tiles those need to be in the background all we have to do now is to actually implement the logic for this drawing which means when we are doing our custom draw we know that every single Sprite has a z parameter and this set parameter can be really useful to draw the level inside of a layered manner all I really want to do is for a layer in level layers dot values this is going to give me the numbers between 1 2 3 4 and 5. and this I can now check if I indent this information I only want to draw a certain layer if Sprite dot Z is equal to the layer and only if that is the case I want to draw all of this and with that we have different layers let me run the entire thing now and let me Place lots of palm trees I hope some of them are going to be visible well this is a slightly more difficult thing to test let's try this one and well at the very least this one is working and this one is more deliberate later on when we have the clouds you're going to see the system a bit more but this one by itself is a pretty good start so all right with that we have another major part now that we have the player we can work on the enemies the first enemy I want to work on is the shell for this one it doesn't damage the player on contact that way the player can stand on top of it I think that should already work however the shell does shoot a pearl and this one damages the player so what we basically have to figure out is if this one here is the shell we want to shoot a pearl whenever the player is in a certain distance let's say in this radius here let's have a look at that once again I'm on the code editor and I want to work inside of the level more specifically inside of build level where we are creating this shell that happens here bodies we have to do a couple of things number one is they need a I called this one a pearl image this is what they are going to shoot next up number two they need to know where the player is this one should be quite obvious I want them to shoot if the player is in a certain distance and once the player is I want them to start shooting this Pearl image once we have those two we can work inside of the shell and add the stuff that we need but let's get started with the Pearl image this one as before is going to be imported inside of imports I will do this right below the shell I want to call this self dot Pearl and this is literally just a single surface so I can use load again and the file path here is going to be one fold up graphics and there we have enemies and in there we have Pearl and pearl dot PNG also don't forget to convert Alpha all of this just to double check this here we are in the folder I want to go to graphics and there we have enemies there is Pearl and inside there we have this simple image that's called Pearl this is what we are going to import and this we now have to get into the level that is once again happening inside of the dictionary here and I want to have Pearl with self dot Perl all right now we have this available in here and for both of the shells let me put them on separate lines that's going to be a bit easier to read actually this is probably best if I use named arguments we have orientation then we have assets and we have position and then we have groups and then I can put all of this over multiple lines that is going to make everything so much easier to read like so much more visible and in here I want to add one more entry this is going to be let's call it the Pearl surface this we also get from the asset dictionary although in here this one I called Pearl that's the one we just imported this one here or this one here with that we have covered the first part we have a pearl image the next part is going to be a bit different because now we have to know where the player is unfortunately now we do have a problem because we couldn't just add the player in here as another argument the reason is we are only creating the player here and there's a reasonable chance that this player will be created after these shells which means if we try to pass the player in here the player might not exist yet which is well not ideal the easiest way I found around that is I created another Sprite group let me call itself and shell brights this group we do have to create so inside of a knit I want to create self.shell Sprites once again this is going to be pygame dot Sprite dot group and that way I can Target all of my shells quite easily this I can then use all the way at the end of this entire statement here all the way at the end of this I want to Loop through all of my shells which means for sprite in Self Storage shell Sprites I want to add Sprite dot player is going to be self dot layer and let me minimize the match data for Loop because this one here I want to have on the same notation level as this original for Loop but this is literally all we need here and with that I believe we are done with the second part let me get rid of it and now inside of Sprites I have to account for all of these parameters although I already see I made a typo this is group and this I called groups so let me fix this one the rest is looking pretty good though although we do need one more parameter and that is the Pearl surface this I also want to store let me add another section here that I called I guess Pearl works first of all I need the Pearl surface as an attribute so per surface is Pearl's surface besides that though I do want to have a few more attributes here the first one is has shot by default this one is going to be false next up I want to have an attack cool down and this one is going to be a timer fortunately we already created a time up way earlier if I open my files in here we have timer and I can reuse one of these timers so inside of Sprites I want to from timer import timer now we have to create a duration I went with two seconds or 2 000 milliseconds there's one more thing that I forgot to add and that is self dot damage group what this one means inside of the level again if the player touches spikes for example the player is supposed to later on get damaged because these spikes are inside of damaged Sprites any kind of sprite inside of this is going to damage the player if the player is in contact with it and I want the Pearl surface to be inside of this damage Sprites as well as a consequence since we are creating this pulse surface inside of the shell I want shell to have access to the damaged Sprites but not be in it itself which means I want to have another argument in here and let's call this the damage Sprites is going to be self dot damage Sprites this is kind of similar compared to the player this Sprite has access to the group but is not in the group itself but now inside of my Sprites again I can add I think I called this damage Sprites yep and those let me name this properly damaged Sprites is going to be damage Sprites right with that we have all of the parameters we are going to need for the Pearl which means now we can start to animate it adding here I want to have animate with self and Delta time as always and I want to have an update method that also gets self and Delta time and this one is going to call self.nmate with Delta time this we have seen a couple of times already and in here once again we have to get the actual animation so let me start off this in a separate variable that I get with self dot animation frames and self dot status this one so far is quite simple we only really have two statuses we have idle or attack so not much can go wrong here then I want to get self dot frame index plus equal the animation speed multiplied by Delta time this one should also be fairly straightforward but now we do have to make a change and that is if self dot frame index is greater or equal than the length of the anime not animation animation I think earlier I call this the current animation that probably makes a bit more sense like so I want to have a proper if statement and this is different compared to for example animated where I put everything on a single line the reason is inside of this line here when we are checking if the animation is ending I want to do a few more things although for now I want to set self dot frame index back to zero and at the end of all of this I want to set self dot image back to the S is the current animation with integer and self dot frame Index this animation here is basically the same thing that we have done up here except a bit less concise but the function is basically identical but let's try this one actually I haven't run the code in a while so let's check if everything is still working I want to create two shells let's run this entire thing it doesn't crash and that's looking pretty good and the player can also stand on the shelves so we are definitely making some progress although right now you can see that the shells don't do anything but at the very least nothing is crashing that's usually a good sign right now they are animated but they're not doing anything because they are idling and the idle animation is a single image so it looks like a static image for that we have to add a bit more logic and I guess I can put out of this inside of a get status method or this one we need self and nothing else all I really want to check in here is if player is close enough that could be a random number then I want to set self dot status to attack and if that is not the case so I want to have an else statement then self.status should be idle remember here we do have access to self.player because of this line here all the way at the bottom which is all you really need to figure out the distance between the player and the shell and if you want a specific number let's say if the player has less than 500 pixels between himself and the shell I want the shell to attack and this could be a good exercise for you try to use some math to figure out the distance between the player and the shell and if the player is closer than 500 the shell should have the status of attack pause the video now and try to figure this one out obviously this is going to be an if statement and first of all I need a position of my player and this I get with self dot player.rect dot Center this I want to turn into a vector with Vector because this allows me to use one specific method that is called distance 2 which is giving me the distance to another vector and the other Vector I want to look at is self.rect.center or at the center of the shell and if the resulting number is smaller than 500 then the status should be attack however if that is not the case so else I want the status to be idle like so and I can get rid of this comment here and this is going to cover most of it so now before we animate we also call self.getstatus and let's try this one and let me add a longer level with a bit more stuff and I can play shells all throughout here let's try this and they can see the shells in the bottom are attacking so this one and this one is attacking but this one is just chilling however if I go closer at some point it starts attacking and they can see it perfectly this distance seems to working just fine cool also let me close the timer we don't need this one anymore now that we have that we can start to think about how to actually shoot a pearl and for that we need to work quite a bit more inside of this animate method but essentially all I really want to do in here is if a certain condition is true and there are quite a few in here let me go through them actually the first one is if in self dot frame index is equal to two this by itself is going to be kind of confusing I'm checking if we are on the third frame inside of the animation remember here we are starting at zero the reason why I'm choosing this Frame let me open the folder actually here we have it and we have Graphics enemies shell left and attack the frame we are looking at right now is this one here and I have chosen this one because this is the best frame to actually start creating the Pearl you can see here the shell is charging and here it's basically recovering so on this one I actually want to shoot it just imagine if it were on this Frame here and we would have one Pearl here it would look kind of silly because we have the Pearl in there and we're also shooting one that I want to avoid so I only want to create the Pearl if we are on this Frame that is this if statement here besides that obviously I also want to check if self dot status is equal to a tag this should be a comparison operator there we go and there's one more condition that we need and that is and not self dot has shot this one should be obvious once we have shot I want to run a timer that the shell can only shoot every two seconds that we are going to control up here with the timer and inside of here I need to do a couple of things I first of all need to get a pearl Direction so is the Pearl going left or right and this one is quite easy I want to have a vector with negative one and zero this one is going left if self dot orientation is equal to left this is the orientation we created earlier all the way at the top and this one is telling us what way the shell is facing if that is not the case so else I want to have a vector that goes 1 and 0. this one is going right once we have that I want to create a pearl for this one we are going to need another class I'm going to do that in a second but for now I just want to print Pearl was shot this we're going to replace in just a bit and after I have done that I also want to set self.hashot to true that way we're not going to trigger this multiple times what we now have to figure out is how to reset this self.hash shot and for that we have the timer up here and basically what I want to do after we set the self.frame index back to zero I want to check if self dot has shot is true which is going to be the case after we have short or after we have run this if statement here if that is the case I want to activate my attack cooldown which I do with activate and besides that I also want to set self dot has shot back to false with these two lines I can look at this get status again because I only want the status to be attack if the player is close enough and self dot attack cooldown is not active which means I want to have a not in here that way after we have activated this timer here the shell cannot attack which means this entire statement here would not be run the last thing we have to do is to update the timer so self dot it tag cooldown I called it dot update and with that we should be good to go and I just realized this one should be an end instead of an if this is looking much better so now let's try this and let me just create one shell then we can test this a bit better so right now it doesn't do anything because the player is too far but if we get close enough we get probably shot and there again after about two seconds and this keeps on going so this is looking pretty good and for this one it might be kind of hard to follow the logic I would definitely go over this a couple of times you want to understand how this part this part and this part here interact with each other but in my case I am going to continue and I'm going to create another class that is going to be the Pearl this one as always is going to inherit from generic and in here I want to have an init method for this one we need itself we need a position we need a direction we need a surface and we need a group and first thing that we are going to do in here is a super init method this one is going to come from generic so we need positions surface and group that's the stuff we are getting all the way to top here position surface and group that we can just ignore we now need a few more things first of all since this Pearl is going to be moving we need some movement attributes we want self.position and this is going to be a vector and a position here is self.rect dot top left besides that I want to have self.direction and this is the direction we are getting from the parameters this direction here we're just going to pass in here finally this one needs self Dot speed and I've set this one to 150. finally I want to have a selfdestruct mechanism because this Pearl if we didn't destroy it would keep on going forever and at some point we would have too many of them for that I'm going to create self.timer and this is going to be the time up we have already seen and I want to have a duration here of 6 seconds and after these six seconds are over I want to destroy this entire object which means right when I create this Pearl I want to activate the timer like so activate with that covered I can create an update method and here we need self and data time and now we have to figure out the movement and the timer for this class and I think this could be a good exercise for you move this Perl here in the direction by a certain speed this is either going to be left or right for the direction and then after the time has over destroy the entire class and if you want to go further you can also create the Pearl right in here as well and see if this one is going to work so possibly now and try to figure all of this out I want to have self.post.x plus equal self dot Direction dot X multiplied by self dot speech multiplied by Delta time this is going to give me new position and this position I'm going to use to update the rectangle which I'm doing with round self dot pause dot X and that is all we need for the movement next up for a timer I first of all want to self dot timer dot update so the thing actually runs and now I can check if self.timer is active but I only really care if this is not active and if that is the case I want to destroy the Sprite with the kill method and with that we have the Pearl I am going to copy the parameters and minimize this thing and now inside of these two lines here I can create a pearl with these arguments the direction we already have this is the Purl Direction surface we also have this is self dot Pearl surface bought a group we are going to need two important groups in here the first one is self dot damage Sprites this one should be obvious this is what we're getting from here however there's one more group that we need and that is all Sprites and this we absolutely need because this one is the only group that draws anything unfortunately we don't have all Sprites easily available but we do know when we are creating the shell we are assigning self.uspirites as the first group inside of this list and this we can use because this list is always ordered and we can access it so inside of Sprites when I am creating the Pearl besides the damaged Sprites I also want to get self Dot groups don't forget to call this and this is going to return a list with all of the groups that this shell Sprite is in and I want to get the first one this is going to be all Sprites Auto make sure here that you have the same order if this all Sprites for somewhere else you would need a different index but with that we have a pearl let's try so I can run the entire thing let me create a longer level and let me create two shells and now we're getting an error the reason is that this position has not been defined but that we can do quite easily I want to create this Pearl wherever self.rect.center is now let's try this again and I want to create a few more terrain tiles and let's put a shell here right now nothing happens but if I get close enough we are getting one shell two shells this is not looking bad at all the issue is right now the shell is a bit offset and this makes the entire thing look a bit weird so when we are creating the position of the shell I mean the Pearl we need to get an offset inside of this if statement here I want to have an offset and for this one I first of all need to get my Purl Direction and multiply this by 50. but this I only want to do if self dot orientation is equal to left if that is not the case else I want to get an offset and the number I found for this one is 20. the different sites here look a bit different so these numbers are necessarily equal but once we have that remember Pearl direction is a vector so we can just add this to the position and now this should be looking a bit better and let me try to add two shells here like so and so and now this is already looking much better the only problem now is that all of these pearls are a bit too low which I also don't really like so if you look at them they don't really align with the mouth of the shell or the opening or whatever it's called which means I want to have a bit more to this offset or both if statements I want to add plus vector and this is going to be 0 for x and 10 for y this should actually be negative 10 because we are going upwards and now let's try this again I want to create two more shells and now this is looking much better so I'm quite happy with this with that we are concluding the shell now obviously the player is not going to be heard by the Pearl but that I want to have in a separate chapter there we are going to add the interaction between the player and all of the enemies but next up let's work on tooth that's the other major enemy so let's start working on tooth and tooth is ultimately not that difficult he basically runs around and reverses Direction every time he collides with an obstacle or a cliff importantly here he doesn't actually have gravity he just moves left and right that is much easier to calculate that's kind of all we need so let's Jump Right In and let's have a look once again we are in the code editor and in here we first of all need the tooth Graphics those fortunately we already have we imported them way earlier so this I don't have to worry about which means inside of level we are creating two in this line here and most of this is perfectly fine that being said there's one thing that I do want to add and let me add tooth on the next line since tooth needs to reverse if there's some kind of collision tooth has to know where all of the Collision objects are as a consequence I'm going to add one more argument in here and that is self.collision Sprites with that kind of like the player tooth is inside of all of these groups but also has access to the Collision Sprites although he himself is not in it but once we have that I can work inside of the Sprites and I want to flesh out tooth right now he's quite simple and he needs Collision Sprites I want to start by creating a movement section and let me add in section here let's call it the general setup like for the Pearl we need self.direction first of all and this by default is going to be a vector that points at 1 and 0. although actually while we are here we could randomize this a tiny bit and for that I want to have from random import choice and this choice I want to use with Choice and then here I can pass in if one or a negative one that way the start direction is ever going to be left or right next up we need to position this we get once again as a vector and then here self.rect dot top left this should look like this finally I need a speed so self dot speed is going to be a hundred and twenty and I did forget we do need to turn the Collision Sprites into an actual attribute so Collision Sprites here and then we are good to go however there's one more thing that I do want to do and that is to destroy tooth at the beginning like so if e is not on a lore the reason here is tooth is going to move left and right and it's going to switch Direction every time he faces a cliff and there's no gravity for him whatsoever the problem with that is if we place them in the air it would look really weird so I want to add the logic that if tooth is just placed somewhere in the air without a floor tile I just want to destroy him right away and that could be a really good exercise for you try to figure out at the beginning when we are creating the Sprite if tooth is standing on the floor or not and if not destroy the Sprite immediately to figure out if tooth is standing on the floor I want to use list comprehension in here I want Sprite for sprite in Collision Sprites that's why I am checking all of the Collision Sprites but I only want to get a Sprite if sprite.racked dot Collide point and this point is going to be self.direct dot mid bottom and plus a vector of 0 and 10. that's why I'm checking if there's a point below the player and I'm going to check all of my Sprites in Collision Sprites if they are colliding with that this is then going to return a list and if this list is empty I know there's nothing below the player which means I want to destroy the Sprite this we can actually test right away let me run main.pi again and let's create a few terrain tiles and let's place two here here and then let's say here and here and let's see what happens and they can see all the ones in the air just disappeared so this is looking pretty good that's a very nice Safeguard and once we have that we can work on the other bits in here first of all I want to have an animate method as always with self and Delta time and this one is actually going to be quite simple so current animation is going to be self dot frames and for this one I want to have an F string and we always want to have run and the other thing we need is self dot orientation remember this is also what we got earlier up here although once I have this bit the rest is going to be very simple I want to increase self.frame index by the animation speed multiplied by Delta time and besides that I want to set self dot frame index to zero if self dot frame index is greater or equal than the length of the current animation and else I want to keep self dot frame index and finally I want to set self dot image to the current animation with self.frame index with cell frame index being an integer this we have already done a couple of times and well shouldn't be too difficult at this point once we have that I can call the update method with self and Delta time and actually call self.animate with Delta time and let's try if I run this again and select tooth we are getting an error that we have no frames because this frames here I called animation frames next attempt let's try this so and there we go now we have an animation looks pretty good we just have to move him now for that I'm going to create another method self dot move this one also needs Delta time in here move and solve with Delta time in the most basic sense all I want here is self.post.x plus equal self dot Direction dot X multiplied by self dot speed multiplied by Delta time we have seen this plenty of times already and once I have that self.rect dot X is going to be round self dot pause dot X with this I can run this one more time and let me place a few things here I can place two in many different places run the entire thing and there you can see they are moving except we have no bottom Collision so not ideal yet but at least something is happening now we have to figure out how to limit this movement only to a platform and for that what I have done this one here is tooth and I'm going to create a gap rectangle here and here and I'm also going to create a wall rectangle here and here the red ones here are checking for a cliff and the green ones are going to check for a wall and if there's any collision with any of them I'm going to change the direction so for example if tooth is moving to the right and there's a collision either with the green rectangle or there's no collision with this rectangle I want to reverse the direction to the left for that first of all I have to create a couple of things I want to have a right Gap I want to have a right lock then I want to have a left Gap and I want to have a left lock all of these unfortunately are going to have different positions for the right Gap or the right Cliff or whatever you want to call it I want to have self.rect.bot right and then here I want to add a vector that is one and one this means if this one here is tooth I am getting this bottom position and I am moving one and one pixel to the right and down next up for the right block I want to have self.rect dot mid right that is horrible spelling midrite and then here a vector that is one and zero for the left block this one is going to be self.rect dot bottom left plus a vector of negative one and one for this one we're going one to the left and one down finally the left block is self.direct dot mid left plus a vector of negative one and zero with that we have all of the different blocks we want to check now we just have to use them and then here first of all I want to check my Direction so self dot Direction dot X is greater than zero this means we are moving right we now have to check two conditions number one is going to be no floor Collision and number two is going to be a wall Collision the idea here is if this bottom right point doesn't have contact with the floor we know that tooth is facing a cliff and tooth should return this is going to be this part here the second part is going to be the wall collision and this we're checking with this point and all I'm really checking here is if there's any kind of collision with the wall and if that is the case I want two to return as well all of this by the way is going to look kinda similar compared to what we have done up here which means this could be an interesting exercise try to check those two conditions to see if tooth is either facing a cliff or a wall if that is the case I want to change direction.x and multiply it with negative one and self dot orientation is going to be left that is all you need for the movement so you have to figure out this if statement here try to see if you can do it I am going to put all of this over multiple lines that is going to make it much easier to read and let me call it floor Sprites for this one once again I want to have list comprehension and in here I want Sprite for sprite in self dot Collision Sprites this is going to copy all of the Sprites but I want to add an if condition that I only want a Sprite if sprite.racked dot Collide point with my right Gap this way I know if there's going to be a collision between the bottom point of my player this one here and the floor and if this list here is empty I know there is a cliff this I guess I can now copy and call it wall Sprites for this one I want to check the point right lock like so but the rest can stay basically identical once I have those two conditions I can I guess let me put the comments here a bit more proper once I have those two I can check if we have Wall Sprites or not lore rights then I want to do all of this the idea here is if there's anything inside of the wall Sprites or if lowest price is empty if either of those two is true then I know the players facing a wall or a cliff and should reverse Direction this we can test right away let me add a few platforms because I can't control the starting direction of tooth so let me just create a bunch of them and at least one of them should work out there we go and now on the right side you can see they are reversing this is looking pretty good and also if I add a wall in here let me do it for this one and run the entire thing you can see this is also working cool so this is definitely working now we just have to cover the other side and that part is going to be your exercise so possibly now and see if you can figure this one out first of all I want to check if self.direction.x is smaller than zero that means we are moving left and after I have that I guess I can copy all of this although now I want to check the left Gap and the left block and if that is the case these two are still working out as is this one but now the orientation should be right and by the way in actual code what you would probably do is not declare separate variables but instead you could do list comprehension right away inside of the if statement and if you add a line break this isn't even that hard to read like so and then I can get rid of these statements here although I did realize here I flipped the thingies so this should be like this we want to reverse direction if there's a collision with the wall or if there is not a collision with the floor so now let's try this everything is still working let me create a couple of terrain tiles and place tooth in here and now this is almost working so this is quite good the only problem is if I'm starting all of this again when we are starting at the beginning we have a random Direction this is what we are getting I can minimize move and animate when we're getting this random Direction here we are not updating the orientation that way it could happen that tooth is moving to the left while having the right orientation to fix that all we have to do is self.orientation is going to be left if self dot Direction dot X is smaller than 0 and else it is going to be right now we can try this again and let me add lots of platforms here it's not this one and now we can actually play around with this quite a bit because we have a fair bit of elements available oh and by the way since a shell is also considered a obstacle this one should also work as a limiter and this is looking pretty good so and complain about this one very happy with it obviously once again the player can't be hurt by tooth but that is going to be the next section actually but for this one we have once again made a ton of progress now that we have all of the enemies we can work on the player damage and this one basically means the player gets damaged when there is contact with the spikes the pearls or tooth and direction of the player is going to be a jump and a white Flash I didn't Implement a proper Health mechanic because I think this is already our 10 of this tutorial and well I do want to keep things at least somewhat focused but you could very easily implement this yourself finally we're going to need a mask for every object so the player despite the pearls and two that way we have much more precise collisions it's going to be really important for a platformer that is all we need so let's Jump Right In and let's have a look we are back in the code editor and the first thing that we have to do is to give all important objects a proper mask that way we have more specific collisions let's start with the spikes because that's the easiest one in here we are basically copying the generic Sprite on top of that I want to give this one a mask that we get with pygame DOT mask Dot from underscore surface added here I want to pass in self.image that way these Spikes have a mask which is much better for collisions this I do want to copy because we're going to use it a couple of times for tooth after we are doing all of this I also want to assign a mask however for all of these animated enemies after we are doing animation we also have to assign a new mask because in here the surface has changed not by very much but it's still good practice but that is all we need for the shell we don't need to do anything but for the Pearl we do need to add a mask this we can do right here and since this one doesn't animate we can just leave it here finally for the player all the way at the top I want to have a mask and now after every animation I want to have another mask or I want to update the mask and with that all of the important objects have a mask and this I can now use inside of level four collisions I am going to add another method below get coins because this one I want to call get damage there's no need for custom parameters in here and I want to get my Collision Sprites this I get with pygame DOT Sprite dot Sprite Collide and here first of all I need a Sprite that is myself dot player then I need a group for this one I have self dot damage Sprites then I want to kill so do I want to kill the Sprite my players colliding with in my case this is false finally we have to tell this method that we want to use a mask for the collisions that we get with pygam.spright DOT Collide underscore mask and once we have that I can simply check if there's any kind of Sprite in there so if Collision Sprites then self dot player and here I want to run a damage method this is going to happen inside of the player so in here let me do it all the way at the top Define damage funnel self and nothing else and I want to print ouch let's try this one and I want to have a couple of different elements here I want to have spikes I want to have two and I want to have this shell and I guess also a palm tree so the player isn't always a danger so if I collide with the spikes nothing is happening in fact nothing is happening at all and I can already tell why because I am not calling this get damage this happens inside of the run method in here self dot get not coins but damage next attempt let's try this again just with the spikes and we are getting an error because in here I have a typo next attempt let's see if this is working now that seems good and I get ouch this is definitely working so once I have that I can also place two and the shell and now let's try this again oh this one is still working and if I get hit by a shell we also get some updates this seems to be working pretty good we can't see too much yet but at the very least it's something okay so with that I can flesh out the player damage and what is going to happen first of all in here I want to have a timer this I call Self dot invulnerability timer and this is going to be timer with a duration of 200 which means after the player was damaged I want the player to be invulnerable for 200 milliseconds and I only want to be able to damage the player if this timer is not active so if not self dot inverldtimer dot active and we are calling this method then I want to start the involved timer with the activate method and then I want to make the player jump so self dot Direction dot y minus equal 1.5 I think was a good number we do have to make sure though that we are updating the timer all the way at the bottom actually let's do it right here self.inveltimer dot update and I think there are a bit too many methods open this is going to be confusing we don't need any of this or this or this the gravity can also go so this is basically all we need for now like so what we're doing is we are updating the timer constantly and we are only allowing damage if this timer is not active and by default it is not so let's try this and I'm just going to use some spikes and let's see if this has been working and there we go the player is jumping and this is at least something once again you could flesh this one out quite a bit more but well for this part it's pretty good I think finally what I also want to do this is going to happen inside of animate if the player is being damaged which means if self dot involt timer is active if that is the case I want to make the entire player flash white and for that I need a new Surface and this surface is going to be self dot mask and this I want to turn to a surface in this surface I want to set as the image so self load image is going to be this surface with that let me actually show what we get with some spikes and now we are getting something the problem here is this looks weird because we have the black background but other than that we are basically using the mask to create a new Surface and this turns the entire surface into a black and white silhouette kind of thing to make it look actually good we have to get rid of the black part and this we get with surface and set underscore color key and the color key I want to get rid of is going to be black this color key gets rid of one particular color inside of a surface which in my case is black that way we only have the white color left and now let me add a shell and let me shoot it and there we go we have some interaction so with that we have the interactions between the player and the enemies I guess I should try this one more time with tooth to make sure this one is working as well and there we go we also have collisions obviously we couldn't hurt tooth but well that could be your own project but with that we have the interactions between the player and the enemies another major step we are nearly finished the last major part is to create the sky this one is going to be like in the editor we have to create clouds continuously besides that we also have to create the Horizon and at this point if you still follow along this shouldn't be too difficult given that we have done this before I want to work inside of a level once again and in here I have to do a couple of things most importantly I guess we can start with the Horizon this we get when I'm building the level we also have case one this one is the sky and this I want to use in two ways first of all I want to create self dot Horizon this is the information I'm getting from position one if you remember ages ago when we created the editor this guy handle is what we are looking for right now and the sky handle is going to be inside of the canvas groups this one here actually and on this object we really just care about the Y position this is going to be our Horizon this we need to have available inside of our level and also inside of all Sprites so self dot all Sprites dot Horizon Y is going to be pause one we need it in both because we're going to create the clouds inside of the level so in here and we're going to draw all of them inside of all Sprites so both need this but this is all we need here so besides that inside of the camera group I want to add one more method and that is going to be raw or ryzen for this one and itself and nothing else in here first of all we need a y position and this I stored in a separate variable let me call it Horizon position for this one we need self.orizon.y this is what we already have but from this I want to subtract the self.offset dot y that way this one scales along with the player and now I can check if the Horizon position is smaller than the window height if that is the case once again I can create a rectangle and this is going to be pygame Dot rect and now we need left top width and height left is going to be zero top is going to be the Horizon position width is going to be the window width and height is going to be the window height minus the Horizon position meaning this one here is going to be our C this I can draw right away pygame.row.rect and self dot display surface here I have a c color I believe I called it this we get in settings we have C color this is what I want to draw and finally I want to draw this rectangle and I guess I should name it properly it should be the C rectangle all I have to do now is to call this and this importantly here I have to do before I'm drawing all of the Sprites self dot draw Horizon the reason should be obvious all of this should be in the background so let's try this one now I don't have to draw too much and we're getting an error the reason is I made a typo somewhere this should be Horizon position instead of horizon y I made the same mistake here and here now let's try this next attempt like so and there we go this is looking really good and now that we have that position we can draw up all of the other things which in my case means I want to have the horizon line that is the white line and then I want to have the three extra rectangles this if you look back at the editor Let Me minimize everything in here at some point instead of drawing the sky I think it was in here yeah in here I basically want to do this thing again and this could be an exercise for you inside of the level draw all of the stuff we used to see inside of the editor you could even copy it quite a bit of this is similar so pause the video now and try to figure this one out I guess the easiest way to approach this is to just literally copy all of them and paste them in here since the naming here I am using the same display surface this should actually still work although the one change I do have to make is this isn't y anymore now this is the Horizon position now if I try this and create some tiles and there we go with that we have a horizon we just need the line in between this I am getting with pygame DOT draw dot line and then here self dot display surface the color is going to be inside of settings I call this one the Horizon color I believe like so and now I need X and Y for the start point and I need X and Y for the end point the line width is going to be 3. X is going to be super simple because this is going to be 0 and the window width Y is also going to be quite simple because for this one I want to have the Horizon position and now let's try this one and there we go I am very happy with this with that we have some background all we have to do now is to figure out the clouds so I can minimize this method here although I guess what we could be doing is if the Horizon position is on top of the entire window so to draw all of this if this one here is the display surface and what we have checked here is if the Horizon is somewhere below the window height what we can also check is if the Horizon is somewhere up here that way I want to fill the entire surface with a blue color which means if the Horizon position is below zero then self dot display surface dot fill with the C color let's try this one and I am going to move this one really high up roll this thing and now everything is going to be blue if you have an underwater level this would be the start for it all right this is all we need inside of draw Horizon and let me get rid of this one white space here next up we have to work on the clouds and for that I'm going to create one more Sprite so inside of my Sprites I want to have let me put it all the way here at the top because this one is a fairly simple class I want to have class Cloud once again this one inherits from generic and in here inside of the init method I want to have self I need a position I need a surface and I need a group then we can call Super thunder in Niche and in here I have to pass in the surface the position the group and now for that this is what we usually didn't specify because most things are on Main however the clouds need to be in the background for that inside of level layers we have clouds here and this I want to pass in here with my clouds that way this is always going to be in the background the rest though is going to be for the movement and here I want self.position this is going to be a vector with self.rect DOT top left and besides that I want to have a speed and in here I want to have a random integer between 20 and 30. rent and we don't have right now so I'm going to import it finally all we need in here is the update method with self and Delta time and literally all we have to do in here is self.post.x minus equal self dot speed multiplied by Delta time a direction here we don't need because the clouds always go to the left so once we have that self.rec.x is going to be round self dot post dot X and with that we have a cloud so next up we need graphics for this Cloud this we get inside of main.pi and when I'm importing all of this stuff I need one more import I'm gonna put all of this all the way at the end and here we have clouds and self.clouds is going to be import folder and in there we have graphics and we have clouds this I now want to put inside of my level once again the same way I have clouds and then here self.louds I believe this is the last graphic we are going to need in there so besides that inside of the level we can now start to create some clouds and this I want to put in a separate method Define and create loud and here I want self and event I'm going to check if the event DOT type is equal to self and now we need a timer for the clouds I'm going to call this one Cloud timer although it doesn't exist right now let's actually create it right away so for now print cloud and inside of the init method I'm going to put all of this under additional stuff in here I want to have the cloud timer and this is going to be pygame dot user event and for this one I want to go with plus two because we already have a user event that was plus one and now pygame dot time dot set underscore timer self dot Cloud timer and I want to create a new Cloud every two seconds this I can now use inside of my event Loop and what I want to do in here is if the event DOT type is equal to self dot loud timer and in here I want to create the clouds actually I don't need this create Cloud I can do all of this straight inside of this method here or the if statement rather and here I need a surface I need the X position I need a y position and once I thought of that I want to create my cloud This Cloud I have to import so all the way at the end I want to have a cloud and for this Cloud just as a reminder we need a position surface and group the surfaces we have stored actually nowhere right now so we need to have access to them this I can also do in here self.load surfaces let me call it serves is going to be the asset dictionary and then here I want to have clouds with that I always have access to these surfaces meaning this I can use in here now I want to pick a random item from self.cloud services I don't think we have Choice available right now we don't so from random import choice next up we need an X and A Y position and for now let me set them to zero and 500. just to make sure that something is working once I have all of that I want to create a cloud and as a reminder I need a position I need a surface and I need a group the position is going to be super easy this is going to be X and Y the surface we already have that's the surface we created here and for the groups all I want is self dot all Sprites oh although I did make a mistake this shouldn't be 500 this should be self taught Horizon y by default I want to create the clouds on top of the Horizon so at the very least we can see something and for X since I want all of them to move to the left let's start with 500 for this one this still isn't going to be the ideal position but at the very least we should be able to see something if I now run main.pi let me run the entire thing and we should be able to see a cloud there and the second one in a second there we go we have a second cloud they still don't look ideal but at the very least we have a start so with that we can work but first of all I want to draw the clouds always in the background and more importantly I want to draw them behind the horizon for that I have added a second for Loop and this is going to be quite similar so for sprite in self and if Sprite dot Z is equal to level layers and in here I only want to draw the clouds which means I can copy all of this and only draw the clouds and nothing else and then down here I want to draw all of the other layers except if Sprite dot Z is then I can copy this part here I hope the logic here makes sense basically we start by drawing all of the clouds then we are drawing The Horizon and then we are drawing all of the other elements or all the elements that are not a cloud that way we have the clouds behind the Horizon which I think looks a bit better with that we can minimize the camera group and now since the clouds are going to be behind the Horizon we have to give this one an offset which I want to be a random number so Rand inch which we don't have just yet besides choice I want to import rent int and the random integer here is going to be between 100 and 1000. if you want to create a really tall level you probably want to have a higher number or something more flexible but I'm fine with this one so let's try all of this run the entire thing and now we should be able to see something at some point but we don't I think one problem here could be that we just got really unlucky with the numbers let me change this to 100 to 200 so we're always going to see something let me try this again and now there I go there we can see a cloud and second cloud and the third cloud and so on so in the last part I just draw the clouds too high cool this is definitely looking pretty good what we now have to figure out is let me change this to a 500. next up we have to figure out this number here the X part and for this we have to figure out what the level limits are and since I only want to do this once this is going to happen inside of the init method before I'm doing all of the additional stuff I want to get the level limits and think of it like this if I have a level that has a couple of tiles here a couple of tiles here stuff here and so on I want to by default create some clouds inside of roughly this area here and later on when I create new clouds the clouds should come from this side here on top of that if a cloud goes too far to the left or rather exceeds the left side of the level I want to destroy that cloud and for all of that I have to know the size of my level for that I have put all of this inside of a separate dictionary that I called level limits in here I want to have a left side and I want to have a right side the left side is actually the easier part because this I always want to set at negative 500. the reason here is I know left or the left side of the level is always going to be at position 0. so I want to have this with some offset so the player can never see a cloud disappear the right side however is going to be a tiny bit more complicated the way I approached it is I looked at all of my terrain tiles and got the one with the highest number so the right side should be the right most terrain tile with an offset let's say plus 500 and this I think could be a good exercise for you try to figure out the width of the level and there are different ways to approach this but I think using the terrain tiles is the best one because be always going to use them so positively now and try to figure this one out in here I first of all want to get my grid and inside of there I have my terrain tiles since I only care about the position I only want to have the keys this I want to sort which means I can put all of this in the sorted method oh and I forgot I do want to turn all of this into a list and this list I want to sort for it sorting I am going to need a key or this one as always we need a function and let me pass in a position as the parameter here we always get a position with X and Y as a tuple I only care about X this is going to return a list with all of the terrain tiles sorted by the horizontal position I only care about the last one the one with the highest number on this one I only care about the X part and this is going to give me the rightmost tile and to this I want to add 500. I guess there's one limitation here and that is if the player doesn't place any terrain tiles we are going to get an error although I don't expect this to happen and this you could expand yourself I think at this stage the project is more or less done we just have to make some minor things but you can definitely expand this quite a bit but alright with that I have the level limits when I am creating all of the clouds I want to have my self dot level limits get the right side and to this I want to add a random number so my clouds look a bit more random let's go between 100 and 300. oh I can see the problem here I am adding an equal instead of a plus now let's try this again if I now draw some level and now the clouds should come all the way from the right and there we go this is feeling much better kind of hard to see but it's definitely working now there are two more things that we do have to do and by default the clouds I want to randomly scale up like we have done in the editor that we can do by writing surf is going to be Pi game dot transform dot scale to X and I want to scale up the surface but only if Rand in let's say between 0 and 5 is greater than 3. else I want to keep the surface as it is if I try this one now draw a new floor and now at some point we should see a cloud that's twice as big and I think the first one there or already looks pretty good also I do want to change this to negative 50 to 600 for the Y position that way you do have a chance to have a cloud right behind the Horizon Lines which looks pretty good cool so with that I can minimize the event Loop and one more thing that I do want to do is to create some clouds by default this I can I think I call this start up louds all the way in the beginning and the name still works and for this one I want to create a random amount so for cloud in let's say range 100. and this probably shouldn't be Cloud we can just call this I because I'm not going to use this number anyway and here I'm going to do a fairly similar thing compared to what I have done here and you could be more elegant by putting all of this inside of a separate function but in my case I'm not too concerned although that being said we do have to make some changes here because all of these clouds are supposed to come in from the right whereas all of these clouds are supposed to be randomly distributed across the level y can stay the same but 4X I want to have a random number so Rand int between the left side and the right side of the level which means I want to have self dot level limits and in here I only care about the left side and then for the right side I only care about the right side here that is pretty much all I need so at the end of additional stuff I want to have my start up clouds and let's see if this is working if I now create some terrain again and now we have potentially too many clouds so this number here where did I put startup clouds there this number here you probably want to scale along with the width of the level so if I set this to a 40 probably looks a lot better yeah this is definitely better so in here the longer a level is the more clouds you want but in my case I think this is a pretty good start with that being done there's one more thing that we do have to do and that is in these clouds if a cloud goes further than the left side limit I want to get rid of the cloud and for that every time I'm creating a cloud so let me once again minimize everything I am creating a cloud either in the event Loop or inside of startup clouds both times I want to pass one more argument in here and that is going to be self.level limits and then here I only care about the left side this inside of Sprites I can now work with because in here I have the let's call it left limit this I want to store into an attribute self Dodge left limit is going to be left limit and this I can now use inside of update to destroy the cloud if it goes further than this which means if self.rect.x is smaller or equal than self dot left limit and if that is the case I want to destroy this object and with that we should be limiting the amount of clouds that we have it's going to be kind of hard to see but I'm going to assume that if there's no major crash this is probably fine and here you can see the limit is probably a bit too low so if I jump it you can see clouds disappearing but an important thing here is that the left side of the map so this area here is going to be 0 and 0 and this point here roughly would be negative 500. that way we have a bit more control over the numbers here but well I guess what I can set for the left level limit let's set this one to negative 1000. or I guess to be even better here this could be negative the window width that probably makes the most sense so now let's try this again let's create a platform and now the player should not be able to see when things are ending and this is looking pretty good we can just see a bunch of clouds and everything else works just fine okay there we go with that we have finished up the clouds and with that we have finished up all of the visual parts of the game for the last section all we really have to do is to add the sound and then we are good to go this isn't going to be a major section so let's Jump Right In we are in the code editor and I want to start with the editor because this one is going to need some background music this I want to do inside of the init method and in here all the way at the bottom I want to have some music this I get with self dot editor music and this we get with pygame.mixer DOT sound with proper spelling here and the file path now is one folder up then audio and inside of there we have a file called explorer.ogg and this I want to play right away so self dot editor music dot play importantly here you want to set Loops to negative one so it plays forever on top of that before we are playing it I want to set the volume this I get with set volume and I set this one to 0.4 now you can hear some music so this one is working already the problem is now when I am switching to the level I want to switch off the music for the editor and play some music for the level the logic for that I can actually keep inside of the editor if I minimize the init method and look at my event Loop for this one whenever I'm calling this if statement here I also want to stop playing the music so self dot editor music dot stop like so and that way we are stopping the music once we go to a level let's try this one and there we go no more background music although now if I return we also don't have music playing again because we don't restart it this we can Now cover inside of main because in here inside of toggle I can check if self dot editor active and if that is the case self dot editor like so and editor underscore music and this I now want to play let's try it up on way back in the level there's no music and now if I return we got some music so this one is working now and this is all the music I'm going to add for the editor that's basically all we need with that I can close the editor we don't need it anymore next up for the level I want to have a couple of music files and those once again I'm going to import in main.pi so I'm only doing it once this is also going to happen inside of imports and in here I want to add some sounds all of this is going to be inside of one dictionary let me call it sounds let's call it level sounds and here we have a couple of different files the first one is going to be coin let me indent this and this I get with pygame DOT mixer dot sound and here once again one fold up then we have audio and then we have oin dot wav this I want to do three more times we now have hit besides that there is jump and finally there is the music these files are called Hit then we have jump and finally we have a file that is called super hero file ending being Ogg with that we have all of the level sounds these we now have to get into the level and this once again happens with all of this thing here I actually don't want to use the dictionary instead I want to have another entry and that is going to be self taught level sounds it's going to be kind of hard to read so let me put every entry here on a separate line with some proper indentation like so and this bracket here can go like this now this means for the level besides the asset dictionary we also need music all of those I do have to store in their separate variables so I'm going to add another entry sound and we have self dot BG music this one is going to be music actually I don't think music is good here let's call it audio and audio in here this I called music but this one like for the editor I want to add self.pg music dot set underscore volume once again this should be 0.4 and finally I can play the entire thing with loops being set to negative one that way this one's going to play Forever let's try all of this thank you and at the very least we do have music but now we have to make sure that this sound here also stops once we leave the level that we can also do quite easily inside of the event Loop when we are switching back to the level inside of here I want self.pg music to stop and since we are creating a new instance of the level this one is always going to start playing once we start the level and it's going to stop once we end the level so this is all we need for the background music next up we have to work on the coins and this part is quite easy because in here we do have access to the coins which means after I have the sounds I also want self.coin sound and this I get with audio and this entry I called coin so in here coin and now for every Sprite or every coin the players colliding with I want self.coin sound dot play this is supposed to only happen once though and just to test this let me not play the background music inside of the level that makes it a bit more noticeable there we go we have some coins and now if the pet touches them we get sound this one is working really well possibly a bit loud but that we can change simply by setting self dot coinsound dot set underscore volume to 0.3 it's something fairly subjective just play around with this that covers the next part so next up we have hit and we have jump it is going to be the easier one because we have a get damage method here and we can basically do the same thing we have done for the coin sound which means in here self dot hit sound is going to be audio and this one I called Hit and while we're here it's sound set volume with 0.3 and now every time the player is hit I want to play self dot hit sound dot play and we should be good to go let's try this one and I've only placed a single Spike and we get some sound that's working pretty good now I can minimize those two methods and this is all I need here the last bit we need is the jump sound for the player and this we can only do inside of build level because in here we are creating the player which means I want to pass in audio and this one I called jump so on here I want to pass in the jump sound this I guess I can now minimize the init method and for build level we need one more parameter and that is the jump sound this I also want to pass into the player all the way at the end we have the jump sound and now inside of Sprites when I am creating the player all the way here I have a jump sound this I can store all the way at the end with sound and self.jump sound is going to be the jump sound this I now just have to call and this I get inside of input because in here the player is pressing jump if that is the case I want self.jump sound dot play with that covered let's try and we have a very annoying jump sound this is definitely too loud right now which means inside of the Sprites once again I want to set self Dodge jump sound and set the volume to 0.2 possibly that is definitely a major Improvement but once again this is something you can play around with a lot and that is going to cover all of the sound that we are going to need I guess I can close level Sprites and settings and with that we have the entire game although I just realized if I reopen level I do want to play that background music now we are basically done with the entire project with all of that in place we can finish up the game and there isn't that much to do we only have to fix a couple of bucks and then we are done I think the best way to illustrate this is let me actually run the game and then here we have all the stuff we created so far and most of this is working just fine but if I play some tiles and some palm trees and now use the mouse wheel you can see that the mouse wheel doesn't work either horizontally or vertically so this we have to fix on top of that if I show my mouse clicking on the menu works just fine however if I click between the menu buttons like so the entire game crashes and we get a key error those are the two bugs I want to work on and both have them inside of the editor for this one I want to minimize everything and in here we have to work on menu click and Pen input and if you want to challenge yourself you should be able to fix both of them yourself quite easily the problems really aren't that big let's start with the menu because this one is game breaking the issue essentially is let me draw this actually we have our main menu rectangle and this is what we're getting from the menu inside of there we have a couple of boxes like so and they all return a number so for example for terrain and water this was two or three for the items I think it was four five or six and so on this is the value we are storing in self.selection index and this is then what we use to select an item to draw in the editor Works reasonably fine the issue is when the player clicks between the buttons this area here the return value is going to be none and none you cannot use for indexing which is why we're getting an error here which obviously isn't very good this is a very easy thing to fix though in my case I'm going to store the value we are getting from menu click this one here inside of a new variable that I called new index and this value I'm going to assign to the selection index but only if new index actually exists so if we have a value different from none if that is not the case I want to keep myself.selectionindex and with that I should be good to go let's try the game still runs I can still select everything inside of the menu and now if I click between the buttons nothing happens either left clicking or right clicking it all works just fine cool so we have fixed the first bug so now we can minimize the method and not worry about it again next up we have pan input in here the mouse wheel is covered in these lines of code the issue we have right here is we are updating the origin but we don't tell all of the Sprites to update as well you can see the issue down here we covered this a couple of hours ago when pen is active I want to change the origin and also update all of the Sprites this part here is what is missing inside of the mouse wheel and all I really have to do after we are covering all of this I want to add a for Loop so for sprite in self dot canvas objects the same thing we have done down here as a matter of fact I want to copy all of this and paste it in here that should be all we need let's try I can place some elements doesn't really matter what it is but let's try a few different ones just to be sure there we go and now if I use the mouse wheel this works in both axes so with that we have fixed another bug and with that I think the entire game is basically ready to go so I hope you enjoyed this video and I'll see you around