hello there in this tutorial we are going to be creating this flappy bird clone in pie game it's ultimately a fairly simple project there really isn't too much to explain before we start i guess the one thing i do want to talk about is the folder setup here is our game folder and we have three subfolders we have code graphics and sounds and sounds is the easiest one it's just two sounds for jumping into background music then for graphics we have the environment font obstacles plane and ui all of these i think are fairly straightforward and then finally we have the code section and then here right now we have two files we have main and we have settings and we are going to add quite a bit more in here but let's go into the code and let's have a look at this and that's actually bringing us to the very first part of this project the basic setup so i'm just going to go over the parts we already have and once we have that part covered we can actually start adding stuff to it so let's have a look so here we are in the files we have main.pi and settings.pi and settings.pi is the easier one in here we just have a couple of constants so we have the width and height of the window and our frame rate and besides that well nothing else is happening in here so we can more or less ignore this file the main.pi file is the much more interesting one and if i run this one we can see a black window that doesn't really do anything right now but let's talk about the code really quick before we do anything else at the top i am importing a couple of basic things for pygame so we have pie game itself sys and time and then besides that i am importing settings and all the constants so that's the stuff we have created up here and we are using all of this to create a game class i will explain this one in just a second but what we are essentially doing is we are checking if our current file is the main file and if that is the case we are creating one instance of the game class and then we are calling game.run so this really isn't anything complicated so let's have a look at the game class itself it's not too difficult i think we first of all have a setup part in the init method and then here we are calling init on python we're creating a display surface then we are giving it a title and we are creating a clock so all of this is really basic pie game if you have no idea what any of this does check out my introduction to pygame it explains all of this in quite some detail now besides that we also have a run method all of this here and all we really have in here is a while loop and in this while loop we are updating pi game and we are calling the frame rate besides that we also have an event loop and we are using delta time if you have no idea what delta time is check out this video i have explained all of it there it's basically there to account for different frame rates and there's one more thing i would like to do to set up this project i want to create two pi game sprite groups one is going to be called all sprites and this one is going to contain well all the sprites and it's going to draw and update them and besides that i want another group that is called collision sprites and this one is later going to contain all of the things our player can collide with so the floor and the obstacles and as a challenge try to create these two groups yourself all i need to do let me add another section let's call it sprite groups and here i want to have self.all sprites and this is just going to be pygame.sprite.group and then i can copy the entire thing and let's call the second one collision sprites we are not going to do anything special with either of them they are just going to contain some sprites and all right with that we have the first part covered so now we have a basic setup next up i want to work on the background and this one i want to be moving continuously in the background and that isn't too much of a difficulty although there are a couple of things we have to take care of but i guess let's jump straight into it and let's have a look at it here i am back in the project and i want to create a new file that i'm going to save as sprites.pi because this one is going to contain all of our sprites and first of all i have to import pygame itself and besides that i also want from settings import star so all of this stuff here once we have that i want to create a class that i called bg for background and this one is going to be pygame.sprite.sprite a basic sprite and for this one when we called the dander init method i want to have self and for now i want to have groups although we are going to need one later on but don't worry about that for now now the first thing we always have to do is call this super that's not how you spell that the super and the dander init method and pass into groups so whatever group we pass in here for example our all spreads group then this sprite is going to be allocated to these groups which is exactly what we want now besides that we need to set self.image and we need self.rect and we do have an image this one we can just import with pygame.image.org and for the folder we have to go one fold up and we have to go to graphics there we have environment and inside of environment we have background.png and as always don't forget to convert this thing for this one though we don't need convert alpha because there are no alpha values and once we have that for the rectangle i just want to get self.image dot get underscore rect and the top left should be at position 0 and 0. so we essentially create an image that we are placing in the top left of the window so far this really isn't anything difficult and i realized i have a typo in there so back in my main file i want from sprites import bg and then after i've created sprite groups let's add another section and let's call this one i guess sprite setup doesn't sound too bad and what i want to do in here is to create my background and i have to pass in the sprite groups and in my case this is just going to be self.all sprites so this argument is for this parameter here and now around all of this we can see nothing for the simple reason that we are not drawing this spread group that's the one i forgot just now so in my game logic i want self dot all sprites dot draw on self dot display surface and now let's try this but now we can see a problem that this thing is way too small and it needs to be much bigger nearly twice as big actually so this image here should scale all the way down to the bottom of the window and for that we have to scale method but there's a bit of a problem so essentially what i want to do when i import this image i don't want to set it straight as the image of the window so let me first import it as another variable and let's call this one bg underscore image and for now this is going to be the same image and what i could be doing now is when i create the image i could call pygame.transform.scale what scale essentially does is it takes a surface and a scale and this scale is going to determine how big the surface is going to be for example if i pass in our window width and our window height let's actually copy those from settings so window width and window height and for the surface i just want my bg underscore image if i run this now we get an image that covers the entire background the problem now is that all of this is kind of weirdly stretched you can see it especially at the clouds so this bit here looks kind of weird and that's what i want to avoid and i guess the best way to think about it is to open all of this in photoshop and explain what we have to do instead alrighty here you can see the entire thing in photoshop the black frame is our pie game window and the blue thing is our background and you can already see the initial problem that our background doesn't cover the entire frame of pie game and what we have done just now of the scale method is to change the scale of this thing to something like this which does work but stretches the background image quite a bit so i don't really like that one so let's undo it and essentially what i want to do is i want to keep the aspect ratio of this thing constant meaning that the width of this thing and the height of this thing should keep the same ratio towards each other so i guess right now the image is always about 1.5 times as wide as it is high and when i scale it i want to keep the same ratio which in practice means i want to do something like this and once we're doing that the entire thing is going to look significantly better but to achieve it we are going to need a bit of math but let's do this once trading code i think that's going to make more sense here i'm back in the project and the first thing i want to do is to get rid of the scaling method so let me copy this thing back to what it used to be and copy this one out and now i've run this again we can see the thing we had earlier so let's talk about what we have to do essentially i want to get this image here so let me just make a square and i want to multiply this by a certain size so this is what we need to find out and the result of that multiplication should be an image large enough to cover this entire height of the window which in my case right now is 800 pixels on the yaxis so let's say for simplicity in here this one should become 800. for y and this means we have to find this y here and how can we do that let me actually get rid of all of this text here to figure out what we have and how we can use it so we still know our entire window is 800 pixels high and we also know how high this surface here is that's something pi game can give us let's say for simplicity here this is 400 pixels high so what we essentially want to know is by how much do we have to multiply 400 to get to 800. now obviously this by itself is a very simple calculation but we want to make this a bit more flexible so at the height of this surface could be basically anything and the formula would still work but really all we have to do to get this y here is to multiply the height of the entire window divided by the height of the background this number simply came from moving this 400 down here and then using it as a divider for 800. so very simple math all right let's actually implement this this number i do want to reuse later on so i am going to get this number in my init method you're going to see later on why this is going to become important and essentially i want to create another section and let's call this one the scale vector and the first we have to do in here is to actually get my bg height and for this one i want to get my pie game.image.load and the image i already have it's this path here now for this one we don't really care about the image we just want to know how tall it is or how high it is so all i want to do is get underscore height and let's actually print it to see if this is working so bg height and if i run this we get 480. so this entire thing is 480 pixels high and we want to know by what number do we have to multiply this to get to 800 so x is just going to be 800 divided by 480 and that is a number we can get quite easily and i want to store this number in self.scale underscore vector and all i really want to do here is to get my window height and divide this by bg height and let's print this one just to see what we are getting so self.scale vector is i need to use self as soon as now it's 1.66 and this is the number we can now use to create this bg so i want to pass in self.scale vector in here now in my sprite class i can create another parameter that i'm going to call the scale vector as well now the first thing i want to do is to uncomment bg dot image and first of all i want to get my full height and my full width and only once i have those i want to use pygame.transform.scale and in here i again want to use my bg image but now for the scaling part i want to get my full width and my full height and now let's do an exercise try to figure out for yourself how to get the full width and the full height of the bg image that we are going to need and here again the important part is you should scale both of these sides by the same number so the same scale factor all i have to do is to get my bg image and then get for the height get the height and this number i then want to multiply with the scale vector and once i have that i can do the same thing for the width so bg image except now i need to get the width of this thing and multiply this one by the scale factor as well and now we should be good to go let's try this now and there we go this is looking significantly better so now our background does cover the entire image but it's not stretched in a weird way so this is working quite nicely and let me get rid of this print statement here it doesn't seem necessary so now that we have that let's animate it and this also happens in the sprite class all i really want to do in here is to give this one an update method it needs self and it also needs delta time because whenever we move anything with the other time it has to be multiplied with delta time and on top of that i also have to create self dot position and this is something i've explained in my delta time video that when we're using delta time to move we can't really store the position in direct attribute anymore because this one only stores integers but when we use delta time we get lots of floating point numbers and if we start of them as integers we would get inconsistent movement so i want to store all of this in a position that is just going to be a vector so pygm.math.vector2 and self.rect.top left so by default we're getting a vector in position 0 and 0. and now all i want to do is self.pause dot x minus equal some kind of speed let's say in my case 300 seems like a good number and this i want to multiply with delta time and once we have done that i want to get myself.rect.x is going to be round self.x and if you're used to normal pi game this does seem kind of annoying but it's the only way to get consistent movement with delta time although grounded it is a bit tedious but alright so now we should be having some basic movement once we're coding the update method so before i am drawing all of my sprites i also want self.osprites.update and now for run this we are getting an error that i forgot delta time now let's try this again and there we go we have some decent looking movement although there we have a problem that at the end we get something weird and the problem here is that i didn't fill the screen with any kind of color so self dot display surface dot fill and let's just fill it with a black color and now let's try this again now you can see what's going on so the image is moving just fine but now the image is moving too far to the left the problem essentially being that this thing keeps on moving left perpetually but we never stop it so at some point it is going to leave the screen and this is kind of easy to change all i really want to do is if self.rect.write is smaller or equal to zero actually let's look at this in photoshop so here you can see the entire thing again and what we're doing right now is once this background is here i want to set it back to this position here so in the if statement we are essentially checking if we are on this position then i want to set the position of this background back to 0 and 0. so once right is small or equal to 0 then i want to set self.pause.x back to 0. and now this self.react.x has to be all the way at the end of this so now if we run this again we can see this is kind of working with one exception there we go that we always can see the black background for a while which isn't ideal as a matter of fact it's unacceptable so let's talk about how we can change it and this i guess is best again explained in photoshop so here's what we have just done we have the background image and we're moving it further to the left but once it is all the way to your left you basically can see the background which well looks terrible now the way to overcome this is to simply copy the background and paste it twice like this so we have the same background exactly on the right of the original background and we're always moving them together so now if i move these two things together and i just keep on moving until i hit the right side of the original one then you can see the second background but now if i again move this thing to position 0 and 0 then you can see the original background and since both of these are identical this image is going to be the same so the player shouldn't be seeing a difference in practice all we really have to do is to duplicate our background image and make it twice as wide by copying the original image which is honestly a very simple thing to achieve here i'm back in my code and in my sprite i want to create a new self.image that is twice as wide as the original background image and then place this background image on that twice one on the left side and one on the right side and for that this self.image i'm going to rename to full sized image so this is the fully sized image that i want to create twice and now my self dot image is just going to be a pygame dot surface and in here i have to get a width and a height and the height is very easy to get i just want to get my full height which is essentially the number i get from here but for my weft i want to get my full width and multiply this by two which is this number here multiplied by two and this way this self.image is going to be twice as wide as this background image or well rather this background image at its full size and once i have that i want to get self dot image dot blit and i want to paste the full sized image at position 0 and 0 and then i want to do this again but now i want to paste this on the left side being the full width so essentially what we have done is we have created a surface that is twice as wide as the original background image and into this we have pasted background image once at position zero and zero so this point here is essentially this point here once we have that we have blitted the same surface on the right side of this original surface so this point here is this full width and with that we have a double background and now what i want to do i don't want to check anymore if the right side of this rectangle is to the left of the screen instead i want to check if the center x is to the left of the screen actually let me reopen the image we just had so this is our new surface and we now know that these two surfaces are identical so we don't want to check this right side instead we want to check the center x because we know that this is the end of the original surface so this is now what should be working let's try all of this and now let's just keep it running for a couple of seconds and i think this is looking really good and yeah i am quite happy with this so this is looking just fine and all right with that we have a background now next up we can work on the ground and the ground is going to work in basically the same way as the background it's actually a tiny bit easier the reason for that is that i already doubled it in photoshop before this tutorial i am going to explain in a second why that is let's first implement it and then i'm going to explain what's going to go different here we are back in main.pi and in my sprites i want to create another class this one i called ground so let's import it straight away and in my sprites class let's minimize class.bg and i want to create class ground and this one is going to be pygame.sprite.sprite and in here i want to create an init method that again is going to need self groups and the scale factor again oh yeah and this is also something i didn't really explain yet that we need to use the scale factor here again and let me explain right now why so when we scaled the background we also want to scale the ground by the same number so that those two stay relative to each other and the bg is what determines how big the scale factor is going to be which is why we get the scale factor essentially from this number but later on we're also going to scale the plane and all of the obstacles by the same number and this is important to keep the game consistent so i hope that makes sense all right now we have those numbers i again need super and under init and we pass in the groups in here now once we have that i want to get my ground let's call it ground surface and this one is going to be pygame dot image dot load and in here we need a string that goes up a folder to graphics then we have environment and there we have ground dot png and for this one we need to convert alpha that's actually really important and now this ground surface we want to use for self.image and from self.image we are going to get self.rect all we have to do for the image is to get this ground surface and scale it by the scale vector and we could do this in the same way we have done for the bg class so we have a full height a full width and a full sized image although that's three lines of code it's a bit much so instead what i usually do is pygame dot transform dot scale and here we do need our ground surface but for the scaling what you can also do is to get the ground surface and get underscore size and this i just want to multiply with the scale factor now this by itself wouldn't work because we can't multiply a tuple with a number but we can multiply a vector with a number so i'm going to turn this tuple here into a vector so pygame.math.vector2 and now this would be working just fine and this puts the entire logic into a single line which i think is much cleaner now for the rectangle all i really want to do is self.image.getrekt and for the position we now have to think about what we are doing because i can't just put top left at 0 and 0. actually i can but it wouldn't really work let's actually try and see what happens so in my main.pi i also want to get the ground so let's create the ground and the ground for now is just going to be in self dot all sprites and self dot scale vector and i've heard of this we can see why this isn't working the ground is way too high up so this is no good and fixing this shouldn't be too hard and i think this could actually be a fun challenge so try to change this argument here in such a way that our ground is always at the bottom of the window all right all i have to do is get the bottom left and that's the position i want to place and now for this one the x is going to be zero by default but for the bottom height i want to get my window i believe i called it so right now this is this number 800. and with that we're placing the bottom left at the bottom left of the window itself and now let's try this again and that is feeling much better cool and let me just clean this thing up a tiny bit so let's call this the image and then for the rect let's call it the position and i guess while we are at the position we can also animate this thing and for that we again are going to need self.pause and just like we have done before i want to get pygame.math.vector2 spelled correctly and in here self.direct dot top left and now i want to create an update map again that is going to be self and delta time and really all i want to do in here is self.post. and then minus equals some kind of number that ideally should be different from this 300 so that those two move at different speeds which look a bit better and i went with 360. and don't forget multiplying this by delta time is really important and now if self.rect.center x is smaller or equal to zero then self.post.x is going back to zero and then finally self.rect.x is going to be rounded self dot pos dot and that is essentially all we needed now what you could have done is use inheritance because those two numbers are nearly identical that would have cleaned this thing up a tiny bit but well do it in your own time if you really want to it's not that much that it would really justify that much extra work all right let's try this now and there we go now all of this thing is moving and it never stops moving that looks good now you might be asking yourself why did i double the size of this ground surface in photoshop and for this background image we're doing all of this in pygame so this line here and the answer is later on for the ground i want to use a mask to check the collision between the plane and the ground and if i created this self.image this kind of interfered with the mask which was kind of annoying and broke the entire game so this is kind of a workaround it's not ideal but it does work so i hope that makes sense but alright so with that we have our background and our ground so next up we can actually start working on the plane itself then the game is going to look much nicer so let's talk about the plane and this one needs to do a couple of different things it first of all has to animate so that we can see different frames after a certain amount of time besides that it also needs to fall down and be able to jump and the jump is going to be determined by player input and finally we also need some kind of rotation mechanic and later on we also need collision but that well we are not going to worry about right now so what we're going to do for now is create a basic plane that doesn't collide with anything just yet and let's do all of this straight in the game i think that is the easiest so here i'm back in my main file and i want to go to my sprites and create a new class that i have called plain and this one again is going to be a sprite dot sprite dot sprite spelled correctly ideally and in here for the init method i again want self my groups and the scale factor and the first we need in here is super and then the dunder init method and passing in the groups to allocate the sprite now what we are going to need we have to figure out some kind of image and later on some kind of rect for the positioning and for the image we want this to be animated so i have to import a couple of frames first and this i want to put in its separate method so self dot import underscore frames and in here every time i import a surface i want to scale it immediately so i want to pass my scale factor in there now besides that i also want to have self.frame index and this by default is going to be 0. so essentially what's going to happen is that this import frames is going to import a list of surfaces and this frame.index we are going to use to pick one of these surfaces and then for myself.image is just going to be self dot frames and we're going to pick self dot frame index and later on this frame.index we are going to increase to pick another frame and that way we are going to animate this thing and once we have the image we can create self.wrecked and this is just going to be self.image.getunderscorerect and this shouldn't be capitalized and in here we have to think about where we are going to place it and let me draw this out actually let's say this is going to be our entire window and i want to play a starting position to be here ish where the center of the thing is roughly in the middle or well exactly in the middle and the x position has some kind of offset to the left so we're not right at the left edge of the window but there should be quite some space to the right of the plane so we have to figure out this positioning here and basically what i have done i am placing the mid left so i am placing this point here and for this point let me actually get rid of all of this we need an x and a y position now the x is the easier one i just want to get my window height and divide it by two for the x position i essentially get my window and i divided this by 20. if this here again is our entire game window right now we have this entire distance is our width and i think right now this was 480 and if i divide this by 20 we get to 24 which is roughly this distance here or 1 20th of the entire width of the window and this distance then is going to be the left side of my plane which does give it a nice offset from the left side and that's also relative to the entire window so if the window gets very large this still works and now that we have that the last thing we have to do to get started is to actually create the import frames method and itself and the scale factor and essentially what i want to do in here first of all i want to create the attribute self.frames and that's just going to be an empty list now once we have that let's actually look at our folder and that one is this one and in my graphics i have a plane and in the app we have red 0 red 1 and red 2. so essentially what i want to do is create a for loop that runs three times and imports all of these three images and places them inside of this frames as the scaled surface and this i think could be a pretty fun exercise so try to import these three images of the plane scale them and put them in the surface in the self.frames list and see how far you get first of all i need for let's say i in range three so we're running the code three times then i want to get a surface and this is just going to be pygame.image.load and in here i first of all want to get the string itself and we go up one folder then graphics then plane and inside of that folder we have a red and this could either be zero one or two and this is the same information i get from my eye here so i'm going to turn this string into an f string and place in the i in here now after that don't forget this is a png file and also i want to convert alpha all of this so now we have a surface next up i want to create a scaled surface and this is going to happen in kind of the same way that i have done up here so i'm going to use transform.scale get the surface and then use a vector to scale it up and we want pygame dot transform dot again i want to place in my surface and then for the scale i want pygame.math.vector2 and mysurface.get underscore size and then this number i am going to multiply with the scale vector and then just realize this scale factor should be outside of that that is looking better all right and now that we have that self.frames.append and the scaled surface so now that we have all of that back in my main file all the way at the top i can also import the plane and let me spell it properly and then i can create lane and all the parameters we need are the groups and the scale factor so i can just copy them from the ground they didn't change very much so far and now if we are running all of this we can see a plane although you might see that this is way too large so the problem here is that the scaling behavior of some of these images are a bit well if they scale too much it looks a bit weird but that's not that difficult to fix all you really have to do is divide this scale factor by a certain number in my case i divided it by 1.6 and if i run it now this feels much better it would even be a little bit smaller let's say 1.7 yeah i guess that even feels better and i guess depending on your resolution play around with this number and see what looks best this is partly subjective and partly depends on what you feel is best for the game so just see what feels good and i'm sure you'll be fine but all right so now we have a plane and i guess now we can start working on the gravity and on the jumping mechanic and for that since we are going to move the plane i want to give it a self.position again that is going to be pygm.math.vector2 and self.rect.top left and now we are going to need two more things for the movement and let me put those in a separate part let's call it movement and first of all we need some kind of gravity and in my case gravity is 20. and then besides that i also want to get self.direct and this by default is going to be zero and the reason why we need direction is because our plane can go up and down whereas for the ground and for the background they always went in the same direction but for this one it's slightly different which is why we have a direction but now that we have that we have to create a couple of methods i guess the first one we can start with is define update we need self and delta time in here again and in here ultimately i want to create three different methods they're called self dot gravity then i have self dot animate and finally self.rotate and what is important is that all three of those are going to need delta time and for now i am only going to work on gravity so let me comment out the other ones so let's create the method gravity and we need self and delta time and the really important thing you always have to understand about gravity is that gravity is not linear and all this really means is let's say you're standing on a cliff and you're here and you're jumping down you don't fall like this you fall something like this where the longer you fall the faster you fall and this is also what we want to include in here if we didn't it would look very weird and the way this is usually implemented is we first got our self dot self.direction and we add towards it our self.gravity and remember this needs to be multiplied with delta time and now this direction we are going to also add towards our position dot y and this also has to be plus equal and in here we are going to add our self dot direction and this one is also going to be multiplied with delta time and now finally self.rect.y is going to be the rounded version of self.post.y and i guess let's try all of this so now things are not working let's have a look ah the problem i have made right now is that we have a method called gravity and we have an attribute called gravity which is not great so let me rename gravity to apply gravity that even makes a bit more sense and now our plane is going down ever so slightly i guess the amount is a bit low and i guess 20 is a below let's set this to something like 250 i think that's gonna be better and there we go that is more appropriate all right so with that we have a plane that is falling down now to counteract we have to give it the ability to jump so that's going to be the opposite of gravity and this is just going to be another method that i called jump that only needs self and all we really need in here is set our self dot direction to something like let's say negative 400 and let's see how far that gets us now the only thing we have to figure out is how to call this kind of method and this we could do in two different ways we could either run a method inside of here that would be perfectly fine although in my case since we're only checking for one simple thing i am going to look at my event loop and in here i am going to check for if event dot type is going to be equal to pygame dot mouse button down so whenever we click the mouse button i want to run this jump method here now for that to work we need to figure out where our plane is and right now we can't it's just one sprite inside of all sprites but we can just assign this after plane to an attribute and now we can target it right away so all we have to do now is self.plane dot jump and that is all we needed now let's run the code and we're getting an error because this needs to be a comparison operator and now if i run this this is kind of working although i think the gravity is still a bit too weak so let me change this 250 to something like 600. and now this feels much more responsive okay um you can play around with the numbers here so the gravity and the jump speed just play around with those and see how far you get and what feels best there isn't really an objective answer it really depends on how you want your game to feel but alright with that we have our player movement now next up we have an animation and a rotation and i guess let's work on the animation and this is just going to be another method with self and delta time and the basic idea how this is going to work is we are going to do the same thing we have done up here that we have a frame index and we are going to use that frame index to pick one frame from our frames so this is a list of surfaces and pretty much what we are going to do we are going to always increase on every single frame our frame index by a very small number let's say by 0.5 now if you do this only once you would get to 0.5 and you couldn't use that number for an index so what we are going to do is we are going to take the integer of this number which in practice means we're going to get rid of anything after the period so we are going to get to a zero so on the first frame if we add 0.5 we're going to stick to a zero but if we're doing this twice this 0.5 would become 1 and then our frame index would take the next surface that's the basic idea and how this is being implemented is we are first going to get our self.frame index and we're going to add some animation speed just to get some number let's go with five and remember this also needs to be multiplied with delta time and basically now what i want to do is self dot image is going to be self dot frames and in here we want to get the integer of self dot frame index and this would work but we would run into an error really fast and let me explain why right now we have a folder with three surfaces we have zero one and two or red zero one and two and by default we are starting with our index of zero so we keep on increasing this number at some point we get to one at some point we get to two now the problem we have is that we keep on going so our frame index would sometimes reach free then we will get to 4 then to 5 and so on and these numbers don't exist in our list so python would be very unhappy and give us an error message which means in practice what we have to do is after we have crossed a two we want to go back to zero so we are looping back to the first item in this list and that is also fairly easily done all we really have to do is if our self.frame index is greater or equal than the length of our self dot frames and if that is the case self dot frame index is going to be zero and that is all we needed so now back in the file now we have an animation it's a bit slow i guess we can make it a touch faster let's change this 5 to a 10 let's see how that looks and yeah i think this is alright possibly still a bit slow but again play around with this and see what you like the most so all right let me minimize all of these methods so they don't get in the way actually let's do this one here as well and now finally we have to work on the rotation and again another method with rotate and self and dt and the first thing i want to do is to create a new variable with rotated plane and this one is going to be pygame dot transform dot roto zoom now in pygame you have a couple of different methods that can rotate row to zoom i think is the one that tends to look the best because this one applies a certain kind of filter that makes things look a bit better and this method needs three different arguments we first need a surface then a rotation and then a scale now in our case the scale we don't care about so this is just going to be a 1 meaning that we don't want to scale anything now for the surface i just want to get myself dot image and finally for the rotation i just want to get my negative self dot direction so the idea here is that the faster we are falling down the more we want to rotate clockwise let me actually draw this i think it's going to make more sense let's say this one here is our plane and if we are going down i want this thing to rotate this way so clockwise and if we are going up then i want to rotate counterclockwise and because of that i want to link my rotation to my direction and what you might have noticed here as well is there is in all of this not a single delta time for the simple reason that we don't actually move anything here at least not directly we're just setting the rotation relative to the direction but we don't rotate anything by itself but with that we can remove delta time from the rotation because we don't need it and now all i have to do is self.image is going to be the rotated plane and well let's try this and well it's a bit high now the problem here is that this self.direction is quite a large number so we want to reduce it by let's say i want to multiply it with 0.06 and now if i run this this is feeling much better and that is looking quite good so now we have the rotation the animation and the movement and there's one important thing you really have to understand here that the order of these three methods really matters at the very least the animate method should come before the rotation and i guess let me rotate them around to see what happens we don't get any kind of rotation at all anymore the reason being here is when we rotate something we are setting the image and whenever we animate something we are creating a new image which effectively means we are overwriting anything inside of the rotate method and as a consequence rotate would become basically pointless so just keep rotate after animate and you should be good to go but alright with that we have our plane and let me run it again and this isn't looking bad at all cool so now we can start working on the obstacles and here again the obstacles really aren't that difficult so let's jump straight into the code and let's have a look at this we are back in the main file and i again want to go to my sprites and create a new class that i called obstacle it's also sprite so pygame.sprite.sprite and again we need it under indeed method that needs self groups and let me spell it properly and the scale factor and first of all in here we again need the dander init method and pass in the groups in there and now in here we have to get as always self.image and self.rect but now we have kind of a problem let me actually open the folder to illustrate what's going on so here's the folder with the obstacles and we have two different kinds of obstacles first of all we have zero and one and i want to pick a random one of those two but besides that i also want to randomly make those two either pointing upwards or pointing downwards and all of this i have to create in the init method so the first thing i want to do is figure out or randomly allocate the orientation and since we now need random numbers i want from random import choice and my orientation is just going to be choice between up and down now for the image itself we are still going to import the image but i guess first of all let's move this one down and i want to import the surface by itself so pygame dot image dot load and let me fix the typo and in here we are looking at the folder that goes one folder up then graphics then obstacles and in here we have either the image zero or the image one and i want to pick one of those at random so i have to turn this into an f string and then in here i want to get choice and in choice there should either be 0 or 1. and now again don't forget this has to be png and at the end of this we want to convert alpha all of this and now we have to do the same thing again with pygame.transform.scale i want to get my surface then pygame.math.vector2 this surface dot get underscore size and then multiply all of this with the scale vector and all right with that we have our scaled surface but now let me move the rectangle a bit further down i want to check if my orientation is equal to up then i want to leave my surface as it is so let's say for now i want to add a pattern here but if that is not the case so if the orientation is down i want to create self.image and the new image should be this image but flipped around and this we can do with pygame dot transform dot flip and in here we need three different arguments we need the surface we need a horizontal flip and we need a vertical flip and both of these are going to be boolean statements now in my case for the surface it's just going to be self.image for the horizontal flip i want to set this to false because i don't want to flip it in this direction but for vertical this should be true so with that there's a 50 chance that we are flipping the entire image so with that we have to figure out the rectangle and now we kind of have a problem and let me draw this really quick if this again is our entire window if our orientation is downward we want to spawn the mountain somewhere here but if the orientation is upward we want to spawn the mountain at the bottom of the window so we have different kinds of origin points depending on our orientation hence we can't just create a rectangle for every orientation so instead we need one rectangle for up and one rectangle for down so i want to have self.wrecked in here and i also want to have a self.direct in the else statement and in either case i want to get self.image.getrekt so that part stays the same but now we have to figure out which point to place and in my case i think what makes the most sense is if the orientation is up i want to place the mid bottom and if the orientation is down i want to place the mid top so back in my drawing essentially what i'm going to do is if the orientation is up so we're in the bottom one then i want to place this point here and if the orientation is down i want to place this point that way i can just use zero or this green height but now i have to figure out for both of these an x and a y position and this i think could be a fun exercise for you so try to figure out the x and the y position for both orientations and see how far you get the x position for both orientations is going to be the same so i'm going to create that before the if statement and basically what i want to do in here is i want to get my window width and then add a random amount of space so i want to get a random integer let's say between 40 and 100 and since we're using rent ind we have to import that one as well and the entire idea for this one is if this is our entire window we are getting this entire width which brings us to this point here and then i want to have some kind of offset here that is a bit random and that way our game looks a bit more organic but that's all it is now for the y position we have to do this for each orientation so the y if we are looking up is just going to be the window height and here again i also want to add some random amount let's say between 10 and 50. and this is going to be the same logic that you have just seen let me move this a bit up so what we want to do is to get to this point down here and wiggle around that point so we want to be in this area here and to get there we essentially need to get the entire height of the window and then add some random amount to it which is exactly what we have done down here and now finally for the downward facing orientation y can just be rand int and in here let's go with negative 50 and negative 10. so technically to make this in the same style as this one we could say zero plus rent end so zero is the top of the window and from that we are adding some negative numbers so we're going up by a tiny bit but well we don't need the zero i hope this makes sense and all right with that we have an obstacle what we can do now is give this thing an update method straight away this should be here this one itself and delta time is always oh and what i just forgot we have to set self.position again and this again is going to be pygame.math.vector2 and self.rect.top left and now basically all i really want to do self dot pos dot x minus equal let's say 400 times delta times and then self.rect.x going to be rounded self.x and that way this object is going to continuously move to the left now there's one thing i do want to implement straight away and that is if this entire sprite goes too far to left i want to destroy it and if we don't do that at some point we are spawning too many objects and the game will slow down so all we need for that is if self dot wrecked dot right is smaller or equal to let's say negative 100 and this means that the right side of the sprite is 100 pixels to the left of the left side of the window the player will definitely never see it again and if that is the case we can run self.kill now i guess technically this number could be zero but i do want to have a bit of a wiggle room here but all right with that we have the entire obscure class that's kind of all we needed but now what we have to figure out is how to spawn this obstacle because we want to spawn this one continuously and for that we are going to need a timer so let me add another section here that i call timer and first of all we need to create an obstacle timer and this one is going to be pygame.userevent don't forget this always wants a plus number by some integer so in my case just plus one and once we have that i want to start this timer so pygam the time dot set underscore timer then self the obstacle timer and now we need to figure out how often this timer should run in my case 1400 milliseconds so 1.4 seconds felt like a good number and now with that one in our event loop we can actually check for this sort of event so in here if event dot type is equal to self dot obstacle timer and if that is the case i want to create an obstacle that's shouldn't be all capitalized so i want to create one instance of this class and i guess for that to work we first of all have to import it so obstacle and now in here we again need two different arguments we need the groups and we need a scale factor so self dot all sprites and self dot scale factor and that should be all we needed for now so let's try this and there we can see one mountain another and there we can see some downward facing ones this is working just fine cool i am quite happy with that now if you want to make the game harder here you could make this scale factor actually a bit larger so for example if you multiply this scale factor with 1.2 i think the game becomes really hard so now the mountains are 20 larger which makes the whole game quite a bit difficult so let's leave it at let's say 1.1 but again here play around with the numbers but all right with that we have our mountains we have our plane we have all of the background so what we can start working on now is the actual interaction between the plane and the mountains and the one important thing we have to consider here is that we are going to need a mask but i guess this we are going to talk about when i actually implement it so let's go straight to the code and let's have a look at this here i am back in my main file now there's one thing i first have to do that right now i have all of my sprites so all of my obstacles all of my oh well my plane my ground and my background they're all in all sprites but for the collisions to work properly i need to have first of all one sprite my plane this one i already have but now i need to group with all of the obstacles my plane can collide with and this i don't have right now oh well i have it it's my collision sprites but this collision sprite is empty right now because for now i always put all of my sprites inside of all sprites but this we can change fairly easily so the ground should be in all sprites and self dot collision sprites and this thing i want to copy now and also the obstacles should be both in the old sprites and in the collision sprites and these collision sprites i will use only for the collisions they don't really do anything else so now that i have that i can create another method that i just call collisions in here we need self and nothing else and for now i just want to check if there's any kind of collision between my plane and my obstacles and this happens with pie game dot sprite dot sprite collide and in here we need one sprite we need a group and we need what is called do kill the sprite is the one sprite we want to look at in my case this is myself dot plane the group we want to look at is self dot collision sprites i think i called it yeah and do kill means if this sprite here collides with any sprite inside of this group do we want to destroy that sprite inside of this group now in my case it actually doesn't matter because we want to crash the game as soon as there's any kind of collision so my case i went with false but it really doesn't matter and i guess just to test this let's put this entire thing inside of an if statement and if that is the case let's say pygame dot quit and sys dot exit and now we can call it let's say after the update method so self dot collisions and let's see what's going to happen so the game doesn't throw an error and that looks pretty good i can also just fall on the ground and this also looks pretty good so this is working pretty well however it's not actually working well and let me actually play it again and if i play this for a while so they could see we didn't really touch any of the obstacles but the game still ended and the reason for that is this let me give a bit of space our obstacles look something like this they are some kind of mountain but if we just use this kind of collision mechanic here we are using rectangle collisions so pygame essentially draws a rectangle around this mountain and that is going to be the collision which in our case is a pretty substantial problem because these areas here shouldn't count as a collision but right now they do which makes the game basically impossible also our ground looks something like this so technically if the player is here for example the game shouldn't end but since we are using rectangles our actual rectangle box to check the collision is something like this so even if the player is in some kind of valley the game would still consider this a collision right now so all of this combined this isn't really working right now and the workaround we have to go with is mask collisions now i have made a whole tutorial exclusively on how to use a mask for collisions and for basically anything else in pygame so check this tutorial if you want to get an indepth look at this but in the most basic sense a mask just collects all of the pixel positions of each of our sprites and then checks the collisions between them it's really easy to implement and well let's do it right now so i want to get a mask for my plane my obstacle and my ground and i guess the ground is the easiest one let's start with this one we actually only need a single line of code and let me add another comment here mask and we have to add self.mask and this has to be called mask you cannot give this any other name and now to get our mask we need pygame dot mask dot from underscore surface and then here we just need a surface and in my case this is going to be self dot image and now we have a mask for our ground and this line i can actually just copy and minimize the ground and for the obstacle i can just add a mask in here at the end that's basically all we needed so we can minimize this one as well now for the plane things get a bit more complicated but first of all when we call the init method we need our mask so it has to be in there as well the problem for the plane is that we are updating this surface so this surface here quite a bit before we are actually drawing it so this animate here and this rotate here in particular change the actual surface and in practice think of it like this if this is our surface for the plane when we are finishing the animate method then we have a mask that's going to look basically identical to this but now when we call the rotate method so the one all the way at the end here we might get something that looks like this and as a consequence if we didn't account for this new surface we might get a collision here for example or all the way up here which might be frustrating so after we are doing a rotation we want to set a new mask and this is done by just creating a new mask here or while updating the attribute and well that is actually all we needed so now each of our main sprite our ground our plane and our obstacle each have a mask the only sprite that doesn't need a mask is the background because this one doesn't have any collisions but now if we run all of this again we still can't see any kind of difference so the collision still breaks the reason for that is that sprite collide is going to need one more argument and that is going to come right at the end and what we have to add in here is dot pygame.sprite.com underscore mask and now this should be working so now okay terrible example now let me move down here now you can already see it there so now i was definitely in the bounding rectangle box of these obstacles but the game didn't crash only when i actually flew into an obstacle the game did crash so this seems to be working just fine now i guess while we are doing the collisions there's one bug in our game it's not really a bug but if i just go all the way up and keep on clicking the game basically well we never collide with anything because we're on top of the entire game so this isn't exactly helpful and to account for that all i really have to do is extend this if statement and add or wrecked self.plane.rect. top is smaller or equal to zero so we want to trigger a collision if the plane collides with an obstacle or if the plane goes too high and now let's try this again if i go all the way to the top the game crashes that way the player can not circumvent all of the obstacles now with that we can actually work on the final part that we want to display a score and if the player has been crashing into something we want to get some kind of game over or restart menu that also shows the score oh and i forget after this section we're also going to add some sound but that is really easy to implement so let's work on the score and the game over screen here we are back in our main.pi file and i want to start working on displaying a score and for that we need a couple of things to get started most importantly we need some kind of font and this i'm going to do in the init method so in here i'm going to add another section let's call it text i think makes the most sense and in here i want to create a self.font and this we get with highgame.phone and in here we need two bits of information we need a font itself and a font size now the font size is just an integer in my case i went with 30. and for the font itself we will need a file and in my case this one looks like this and if you open up the project files you have to go to graphics let me move it down a bit and there we have font and there we have bd cartoon shout and that's the true type font file or ttf and that is what we're importing in here now besides that we also need a score attribute to save the font which in my case is just score that starts at zero and that is basically all we need for now to get started with the score now to display it i want to keep all of this in a separate method so let's call this one display score and then here we need self and nothing else and now we have to figure out how to get a score and there are different ways of getting the score so one method could be that we get a plus one in our score whenever the player crosses an obstacle another way would be to just measure the time since the game started and that's the one i went with but honestly all of these methods are fairly easy to implement so choose whichever one you prefer but in my case i am just going to go with time and well all we really have to do is get our self.score and then here to get the time since our game has started is pi games spelled correctly dot time dot get underscore ticks and this is going to give us milliseconds but for now let's just keep it so you see what we actually get now once we have that information we want to create a score surface and we want to get a score rectangle and then basically all i want to do is self dot display surface dot blit and then the score surface and the score rectangle so we have to figure out the score surface and the score rectangle and i think this could be a pretty good exercise for you so the score we have right now is a text turn this text into a surface and from that surface get a rectangle and then blit both of those on the display surface and see how far you get to turn a string into a surface we first of all need our self.font so the font we have created up here and then we need render and in render we have three bits of information we need a string we need antialiasing and we need a color and let's go through them i guess from the start our string is just our self.score the problem is i actually misspoke this isn't a string it's an integer right now that gives us the milliseconds since the game has started so we have to turn this into a string which isn't very difficult i am just using the string method you could also use an f string it really doesn't matter next up we have antialiasing and this basically means if we want to apply a filter to the text to make it a bit more smooth which in my case i do want to do and the only time you don't want to use this is if you have picks a lot because then it makes it kind of weird but if you have anything else you do want this to be true and finally for the color i kept it simple and went with black and with that we have a surface now next up to get the rectangle we want the score surface dot get underscore rect and in here we have to figure out a position and let me illustrate what i want to achieve let's say this here again is our entire display and i want the score to be up here while the game is active which specifically means that i want the middle of the window in the middle of the entire window so this is the width of the window divided by two and then i also want some kind of offset from the top and this is some reasonably large number it doesn't really matter specifically what it is the middle part here is much more important to get to that point i have placed the mid top and for the mid top we need x and y and x is the easier part for this one i just got the window width and divide it that one by two and for the height i just went to window height divided by ten so that the top of the text is ten percent from the top of the window that's kind of all that means here and that is all we needed for the basic thing so now we just have to call this method let's do it after we're drawing all of the other sprites so self.display score and let me add a bit of white space and it's actually really important that this display score comes after all of the sprites drawing because this one draws on a display surface if we are calling this before this method here we wouldn't see it because the draw method draws the background on top of it so the order here does matter but right let's run this and we can see we have a score except one that gets way too high way too fast so this is not ideal and the reason here is that this number is giving us milliseconds instead of seconds and well to change that all we have to do is to floor divide this by 1000 and now let's try this again and this is feeling much better except i am terrible at this game so this is feeling well it is working cool so with that we have a score now next up i want to work on the game closing down as soon as we have any kind of collision and instead i would rather have some kind of game over screen and then if the player clicks again the game restarts and that is also fairly easy to implement now basically in my game i want to have a attribute that i called self.active and this is essentially going to attract the status of the game so if we have crashed into something it's going to be false and once we're restarting self.active is going to be true again so essentially once we have a collision we want to make some changes to this and specifically in here i want to have self dot active is going to be false so now instead of closing down the game we're getting to a different state and now for this state to work properly i need a few more graphics and this is going to work in the init method so in here i'm going to add one final section that i call menu and in here we get self dot menu underscore surface and i want self dot menu underscore rect and really all i'm going to do in here is pygame.image.load and for this one we just need another string to graphics dot ui menu dot eng and don't forget we need convert underscore alpha as always and just to demonstrate what we are getting here is again the game folder we go to graphics we go to ui and there we have this menu thing so that's what we're importing all right and next up for the menu rectangle we are just going to get self.menu surface dot get underscore rect and this i want to place square in the center of the window so center is going to be my window width over 2 and my window height over 2. and the basic idea is if self.active is equal to false i want to display this menu here and i guess what i haven't done for this project is this thing doesn't have any scaling right now so if the game gets really large this might look very very small but that's something you can work on yourself all you would really need to do is get this scale factor and apply it to this menu surface as well it should be fairly easy to implement okay now the basic idea of what i want to do is further down here that if self dot active then i want to check for self dot collisions and this is what i have done so far up here but this i only want to do if the game is active so i want to remove this one which really just means that i am going to delete this line and let me put it on another line so it looks a bit cleaner now if that is not the case i want to self dot display surface dot split and self dot menu surface and self dot menu rectangle so the basic idea is if the game is active we're checking for collisions if not we are blitting the menu and if we run out of this the game is still working but now if i crash we can see our logo and this is working quite well we can't do anything with it right now but it does work at the very least also the score keeps on running so that's stuff we have to work on but i guess step by step let's start working on the score i guess that's the most important one and this is going to happen in the display score again here and basically what i want to do this score should only update if the game is active so all of this should be in if self dot active and only if that is the case we want to get a new score and i guess while we are here we can also implement something else that while the game is active i want the score to be on top of the window but if the game is not active i want the score to be below the menu and that we can also work in this method here and basically all we have to work with is right now with our window height divided by 10 and this is the top middle part of the window i want to cut this thing out and change it to a y and now if the game is active i'm going to set this y to the same number so far this wouldn't really be a difference but what i can do now i can set an else statement and in here y should be a different position and what i went with is window height divided by two and this is right now the exact middle of the window and i want an offset to be a bit below that and to get this offset i want my menu rectangle and the height of that and well basically what we are doing is this here again is our entire window this would be the center of the window and we want to go down by the height of the menu so the height of the menu rectangle that's basically all we're going to do here and i guess let's try if this is working so if we run the code now the game is still working and if i crash into something we can see a number below the menu now and it's well not counting anymore although i guess the number is a bit too far down so i want to move it up a tiny bit and to achieve that i'm going to divide this number by let's say 1.5 and let's put it in brackets that should look a bit better so now let's try this again game is still working just fine if i now crash into something this is looking much better cool so now we have the score almost working properly there's going to be one more thing we do have to work on but for now i'm happy with this now i guess next up we can work on restarting the game because right now we can't really do anything and for that we have to look at the event loop so all of this stuff here and basically what i want to achieve is when the player presses the mouse button i want to restart the game so inside of this if statement i need another if statement that if self dot active so if the game is active and i press the mouse button i want the plane to jump but if that is not the case so else i want set self active to true let's actually see what we get so if i run the game it's still working but if i crash now we well get nothing and the game continues after i press and i think if i press fast enough there you can see if i think press fast enough you can kind of tell the idea okay now what is the problem basically let me draw it this here is our game window and the problem we have right now is if we stop the game the plane continues to exist and keeps on going downwards and once we are restarting the game the plane is still down here somewhere and since all of our obstacles are here and here and here the plane doesn't reach them whatsoever and as a consequence the game keeps on running but we can't see the plane so that is something we have to work on and in my case here's how i approach this in my collision method after we have a collision i am destroying the plane so self.plane.kill and then when we are clicking to create a new game so down here i am creating a whole new instance of the plane so self dot plane is equal to plane and let me actually copy this from earlier we just need this line here and with that let's try this again so the game is still working now crash into something and now my plane is well at least in the right position back the problem we have now is that we keep on having all of the obstacles in the game which is kind of unfair if you are just spawning a new game also the score doesn't start at zero it starts at the previous score so the score keeps on rising so there are two things we have to work on i guess we can start working on the obstacles that's the easier well both are really easy but let's work on the obstacles first so essentially what i want to do once we have a collision i want to destroy all of the obstacles and this happens again in the obstacle class and really all i want to do here is for sprite in self dot collision sprites dot sprites i want to sprite dot kill and also in my timer so in this timer here i only want to spawn new obstacles if the timer is running out and self.active is true so that way we are not spawning any new obstacles and we are destroying all the existing obstacles although right now there's a bit of a problem if we are doing that let me run the code to demonstrate so the game is still working but now if i crash into something we are also losing the ground and if i now click again it well doesn't come back which isn't ideal and the problem here is that in my sprites let me minimize all of those my ground and my obstacle are all in the same sprite group which is causing the problem here and i think the easiest way to fix this is i want to give each of these sprites a sprite type and then in here if sprite dot sprite underscore type is equal to obstacle that is horrible spelling stick kill only then do i want to kill the sprite so now in my sprites i have to give them different sprite types and this we can do straight at the top so in here self dot sprite underscore type is going to be let's call this one ground and then for the obstacle this could be self.sprite underscore type is going to be obstacle and now we should be good to go let's try this again now and now if i crash into something the obstacles disappear but the ground remains and now if i restart the game this is looking much better cool so this seems to be working quite well if i crash again this same thing happens again cool this is working now the final problem we have is the score because this one doesn't go back to zero instead it keeps on updating and the problem here happens in this line pygame.time.getticks gets the time since the program or our game has started it doesn't really care what we are doing in the game it's always starting from zero whenever we start our program so we have to account for that and to account for that here's what i have done is this score is always going to be offset by self. i call this the start offset that is i'm getting worse at spelling and this start offset is just another time when the game became active again so if we're starting the game at 2 seconds start offset is going to be 2000 so 2 seconds in milliseconds and this start offset we get down here so all i want to do is self dot start offset is going to be pygame.time.getunderscore ticks and obviously we also need the same number up here up here we need self dot start offset and by default it's going to be zero and now let's try all of this and now the time keeps on working i get 2 for the score and now if we start again we start again at 0. so this is working pretty well cool i'm quite happy with this and i can crash again and this keeps on working really well cool so with that we have our score and our game over screen so the last thing we are going to need are two sound effects and those are incredibly simple let's go straight into our code and let's work on them here we are back in main.pi and we want to add some sound and let me just demonstrate what we have so in our third folder we have sounds and in here we have jump and we have music and that's kind of all we need let's start with the jump sound although it doesn't really matter which one you start with and i can minimize everything else in here and in the init method of the plane i want to add some sound so all the way at the end i want to add some sound here and all we really need is self dot let's call it jump sound and to import music we need pygame dot mixer dot sound and now we need a path to the sound file which in my case is going one fold up then we have sounds and then we have jump.wav and now before we are going to use that sound by itself it's kind of loud so i want to set self.jumpsound.set underscore volume to 0.3 in this set volume 1 would be the maximum and 0 would be well 0. and in this case 0.3 means 30 percent of the original volume and now i just have to play this sound whenever we jump and we know we jump when we are running the jump method that kind of makes sense so in here i just want to run self.jumpsound.play and that should be all we need it although i just realized this should be jump.wav not slash and now let's try this and let's see what we get and well that is working except it feels absolutely horrible but that's only because we don't have any kind of background music right now but that we can fix quite easily and that's gonna happen in the main file and this could be a pretty good exercise for you as well so add the background music yourself and see how far you get all we need is first of all i want to add another section in here i think this one is going to be the final one now and in here i want self. let's just call it music and this is going to be again pygame.mixer.sound and the path here is again a string we go up sounds and then here we have music.wav and i'm happy with the volume here and to play this one i just want straightaway self.music.play and the really important thing for this one is we need to add one argument in here and that is loops that should be negative one and this one tells pygame to play this music perpetually so we never stop and we played in a loop so if we run the game now okay that works really well so i hope this tutorial was useful and i will see you around