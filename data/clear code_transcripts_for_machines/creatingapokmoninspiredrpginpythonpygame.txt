n hello there in this tutorial we will create a Pok√©mon inspired RPG in there you can explore an Overworld full of characters and you can fight trainers and wild monsters the battle system is also quite complex you are able to choose a range of attacks switch monsters and even catch Wild Ones the entire thing includes a lot of animations and visual details to make it look nice also monsters can level up and evolve they also learn new attacks on some levels to visualize all of that information there will be a monster index that shows you the attacks stats and abilities of all of them all combined this will become a fairly large tutorial but you are going to learn how to organize complex projects how to manage databases and how to build your own user interfaces from scratch skills that can be incredibly useful now creating these projects requires a broad range of skills for example in this game I have relied heavily on Vector math and geometry if you want to practice these Concepts more thoroughly check out the sponsor of this video brilliant.org they offer courses on all of these Concepts that are full of interactive lessons and HandsOn problem solving skills not only is this approach uniquely effective at learning it is also much more fun than just passively reading a book or watching a lecture it is also really good at getting you to build problem solving skills since this is what you will doing from day one on top of that all of the content has been made by awardwinning teachers researchers and professionals with industry experience you can access brilliant via a website or an app and spending just a few minutes on it every day will help you learn a lot so instead of scrolling idly on the bus or at the gym you can build a powerful habit that will make you a more competent thinker brilliant also recently added a lot more content like programming with python data visualization and how llms work and they regularly add more content if you head over to brilliant.org clear code you can get 20% off a subscription and the first 30 days are free so not much to lose and if you subscribe you also help me make more videos so thanks again to brilliant for sponsoring this video let's get started with the game and the first thing that we need is the Overworld with all of the characters this will include a lot of imports since we have to to cover quite a bit of artwork so I suppose let's start by looking at the project folder in which we have four subfolders audio code graphics and data the only folder that we will work in is the code folder this one actually already contains a few python files I will talk about them once they are needed besides that we have a data folder with a whole bunch of tiled Maps those store the various layouts of the Overworld finally the graphics folder contains well all of the graphics it's probably a good idea to have a quick look at all of these files just so you have an idea of what we are working with although I will also talk about it when we import them into pame you can get the start folder and the folder for each stage of the tutorial on GitHub and from Google Drive just check the video description now to get started I want to go to the code folder and open main.py and settings.py here we are inside of m.p and at the moment nothing is really happening we are simply importing everything from settings let's have a look at that one all the way at the top we have a couple of imports the most important one is py game but on top of that we are importing from py MAF a vector 2 as a vector for this project we are going to rely very heavily on vectors so I want to have them available quite easily this part isn't strictly necessary but it makes our life a bit easier finally from CIS import exit is going to be used to close down the game later on after that we are defining a couple of basic constants like the window width and the window height the tile size the animation speed and so on none of this is too complicated or at least I hope it isn't after that we have a couple of dictionaries for example this one defines all of the colors in the game these dictionaries aren't too important for now so don't worry too much about them I'll cover them in more detail later so that's the basics of settings. Pi although before we continue there's one really important thing for this project I am going to use py game C or pame Community Edition not the regular or traditional pame that is because there are two versions of pame the traditional pame and py game c and the version that you want to use is py game CE this one has frequent updates it has more features it runs faster and it is 100% backwards compatible there really isn't any reason to use the old py game anymore and if you want to install it you either go to the Powershell or The Terminal and type pip install py game CE that's all you need to install it in my case I already have it installed so I don't have to do it now the one important thing you want to keep in mind is that inside of python you are importing pame and pame C in the same way both are imported with import py game that is important to ensure backwards compatibility for pame C but if you have both versions installed then this is going to cause some problems so I would recommend to get rid of the old pame entirely and only use pame C you are retaining all of the features and you get some additional ones so you're not losing anything and all of your old projects are still going to work just fine righty with that we have the setup that means we can work inside of main.py and create the basic game class let's call it class game no need for inheritance but we will need a thunder init method in which we first of all want to initialize py game with pygame do init next up we will need a display surface let's call it self. display uncore surface this one we are creating with py game. display. set uncore mode this one wants to have a tupile with the window WID and the window height which we are getting from the settings there we have window Wii and window height and those we want to pass into a tupal inside of set mode also while we are here we can set a window title with py game. display. setor caption and to make sure that I am not getting sued let's Call it Monster Hunter cool with that we have the basic setup next up we want to have a run method in which we are going to run the game Loop meaning while true then we want to get an event Loop and we want to run the game logic the event Loop is fairly simple for event in py game. event. getet at the moment the only event that we care about is if event. type pame dowi if that is the case we want to run pame do quit and the exit method that we are getting from settings this one that way we are able to close down the game after that inside of the game logic at the moment we can't really do anything but I want to set py game. display. update so we're making sure that whatever we are drawing inside of this run Loop is going to be displayed and that is it to get started all we have to do now is inside of the global scope check if Dunder name is equal to the string Dunder main so we are checking that we are in the main file if that is the case we want to create one instance of the game class and on that class called the run method if I now Run the game we should be seeing a window and there we go that looks good we can also close it so all of this is working just fine oh and by the way if you have no idea what these terms are so if you don't know what a display surface is or what an event Loop is I should mention that this tutorial is for more advanced users I will already assume that you have a basic understanding of P game G if you are entirely new to it check out my ultimate introduction to pame this one is going to cover all of the basics the next part that we have to work on is going to be the Imports for the level and for that let's have a look at the project folder in there we want to look at data and then there we have all of the maps those contain the data for every level inside of the game and the most important one is world. TMX and by the way all of the files have been created en tied which is an open Source map editor if you have that one and you open a map there you can for example see the Overworld now for this tutorial you don't have to know tiled in too much detail although if you want to expand the game on your own you should probably know the basics of it and I have made a tutorial specifically on it so check this one out if you are interested but the basic gist of it is if you look on the top right there we have a whole bunch of layers like terrain terrain top entities and so on the layout that we care about for now is called terrain so let me hide everything else like so this is going to be the background for the level and this is basically a grd if I go to view and show GD you can see we are simply dragging from the layers specific Graphics into a position I could for example select this mountain and then place it in these positions that's all that's happening in here here so ultimately what we want to do is import all of these graphics and then display them via py game so inside of py game I want to create two more methods the first one is called import assets no need for custom parameters and in there we going to import all of the assets for now the only one that we really care about is going to be self. TMX maps and this is going to be a dictionary with key value pairs where we have a world and then an Associated TMX map now to import this TMX map we need a specific python module or rather one specific part of a custom module we want from PMX do _ pame import load uncore iame PMX is a module that is really good to import TM X Files into py game and this specific method that we are looking for is called load py game now if you run the code you should not be getting an error message from this line if you do you have to install PMX which you do inside of the Powershell you want to type pip install py TMX and that's all you have to do with that we can import PMX maps and we using this with load py game and then a file path in our case we want to go upper folder then we want to go to data in there we have the maps and in there we have world. DMX so if you look at a project folder we are starting inside of the code folder in main.py then we want to go up to project to data maps and then world. TMX that is the relative path we have just created that being said approaching file paths like this isn't ideal because some operating systems use a forward slash others use a backward slash and if you have a hardcoded relative path this might cause some problems to fix that we can use another python module from os. paath import join and all that join does is it creates custom paths the way you use it is instead of one hardcoded path you simply specify the folders or the notes you want to go through you want to go up a folder then we want to go to data then we want to go to maps and finally we want to go to world. TMX and that is all we need those two things for windows are basically going to be identical but depending on the operating system you might get a different kind of slash now we don't need the original path anymore and we can print self. TMX maps on top of that inside of the done ended method I want to run self. import assets if I now run the entire code after a second we are getting a dictionary with a tile map so that is looking really good that means we don't need to print statement anymore and next up we can create a setup method which is going to need two custom parameters the first one is the TMX map that we want to use the second one will be the player start position later on this setup method is going to load different kinds of levels depending on what TMX map we are putting into it but for now we only have a single one so this one isn't too complicated all that we want to do for now is Loop through one of the layers of our TMX map and if I open tiled you can see that the one layer we care about for now is called terrain this is the one that we want to import we getting that with TMX map and then get underscore layer uncore byor name the layer name for this one is terrain and it's essentially going to be a list with all of the positions and the images that we have laid out inside of til although to access all of that we need dot tiles afterwards with that we can put this data inside of a for Loop for x y and the surface in this particular layer that way we can print x y and the surface and we would get access to the position so X and Y and the surface and that is all we need in the setup method for now so next up we can call self. set up with two arguments the first one is the TMX map which we get with self. TMX maps and this one has the key world the one we have just created the player stop position doesn't matter too much but later on this is going to be house if I now run the code we can't see anything but we are getting positions and then a surface and quite a few of those the way to read this information is the surface is simply the graphic that we have placed and then the numbers next to it are going to be the column and the row keep in mind for this one we are at the moment working inside of a grp we do not have pixel positions or in other words if we are inside of til I can zoom out and if we go all the way to the top left this tile here would be tile zero and zero the one to the right of it would be tile one and zero or in other words x would be one and Y would be zero that would be the position inside of the grid but it's not a pixel position since our tile size is 64 pixels this tile would start 6 64 pixels to the right of the origin Point that's an important thing to keep in mind and something that we want to use right away so instead of using X and Y we want to multiply both of these values with the tile size that we are getting from the settings and there we have tile size I want to multiply X and Y with the tile underscore size and then we should have the correct position if I run this again you can see that we get much much larger numbers and that does look quite a bit more accurate so ultimately our map is going to be 4,500 by 4,900 pixels so with that we know what graphic we want to display and where to display it but we don't actually show it and for that I want to create a Sprite Which I'm going to do in a new python file let's save this one as Sprite dop and first of all in there we want from settings import everything and then I want to create a class called Sprite Which has to inherit from py game. sprite. Sprite and be careful on this one about the spelling the second Sprite should have an uppercase s inside of the Sprite we want to call a thunder inage method and then Define a couple of basic parameters we for now want to define a position a surface and the groups after that we want to Calla super Dunder init to initialize the parent class and then pass the groups in there as an argument in case you don't know how Sprites work you should really check out the basics of py game but basically a Sprite is a simple class that contains a position rectangle and a graphic that we are placing inside of a group then via the group we have updating and drawing the Sprite to make all of that work we have to Define self. image and self. rectangle the image is simply going to be the surface that we getting from the parameters meaning we are simply passing this thing right through and saving it as a parameter for the rectangle we want to get self. image and then get underscore F rectangle where we are defining the top left and setting this to the position that we are getting from the parameters once again and I should mention get fct is short for G floating Point rectangle which is something unique to pame C if you're using the traditional pame this would get you an error hence make sure to update the reason why you want to use a floating Point rectangle is because in the traditional rectangle you are storing all of the points via integers for example the top left could be a position of one and two two very simple numbers and importantly those are both integers which are a good start but very often you want to be a bit more precise and for that you want to have floating Point rectangles which work exactly like the old rectangles except now you can store floating Point values for the position so the top left could be for example 1.5 and 2.13 significantly more precise and that's basically the entire difference but this ision can be incredibly useful so I would generally recommend to use floating Point rectangles but anyway with that we have a basic Sprite inside of main. Pi first of all we want from Sprites import the basic Sprite after that inside of the dunder init method let's do it all the way at the top we want to create a whole bunch of groups or Well for now we only want to create a single group self. allore Sprites which is going to be pam. sprite. group this group all Sprites is going to contain well all of the Sprites or at least all of the visible Sprites and then via this group we're going to display and update all of these Sprites so after we have that inside of the setup method when we are looping through all of the terrain tiles I want to create a Sprite and then we want to get a position a surface and a groups let me paste it in position is going to be a dupal that we have just created with X multipli by tile size and Y multiplied by tile size the surface is the surface we are simply going to get from the for Loop I.E we are taking this surface and we are passing it into the class finally for the groups we only have a single group self. all Sprites and with that we have a basic Sprite if I now run the code we getting an error message that's a good sign but we still can't see anything the reason for that is that we have to draw this all Sprites which is going to happen inside of the run method before we updating the screen we want to run self. or Sprites do draw and the argument we have to pass in there is the surface we want to draw on in our case we want to draw on self. display surface if I now run the code we can see the top left of the map so if you look at til we are currently drawing this top left part more or less and I realized there's one graphical issue this part here that isn't looking correct that we can fix right away so I want to select this one tile and then place it in there and that looks much better if I now save the tile map go back to my code editor and run all of this now we have fixed this corner much better that covers the basic Imports but that's still not really useful simply because we want to display more than this top left corner we have a huge map that we want to display to make all of this visible we have to create a basic player along with a camera to create the player I want to create a new python file and save this as entities. Pi besides the player later on we are also going to store all of the other characters in there but that is going to come later but now I first off I want from settings import everything and then create a class called player like the Sprite this one has to inherit from py game. sprite. Sprite and then we will need a thunder in it method with self a position and the groups for now after that we will need Super Thunder init along with the groups after that we will need self. image and self. rectangle the image isn't too important for now later on we are going to have proper graphics for now I simply want to create pame do surface with a size of let's say 100 by 100 also this self. image I want to fill with a color so it looks a little bit better let's say red for the rectangle I want to get self. image and getorf rectangle where I am setting the center to the position that we're getting from the parameters with that we have a basic player that is very similar compared to the Sprite we have just created which means inside of main.py I can from entities import layer and then we can use that class inside of the setup method although for that we need another for Loop because the player is not inside of the terrain layer if you look at all of the layers inside of til we have one object layer called entities and you know it's an object layer because of these purple dots next to it if you enable that one you can see two things oh well you can see all of these markers those can do two things if you look on the left side a name could either be player or a name could be a character a character would either be a trainer or a hospital nurse but now we don't really care about either we only care about the player notes and if I display all of the objects they're going to make a bit more sense so for example this note here for the player would be the start position if we just came from the planned Arena and if we go for example to this point it is Hospital 2 and the marker right in front of it would be the start position if the player just came from this Hospital 2 and so on basically we have a whole bunch of start positions for the player and the one that we want to start with is is this one which at the moment is not in the right position it should be in front of this house inside of your project it should have been in the right position I was simply testing things this should be the starting position for the player where we have a position so house and the direction that way we can identify this particular marker now inside of the code first of all we have to Loop through this particular layer from tiled and since we have an object layer we have to approach this just a little bit differently compared to the styled layer instead we want for obj in TMX map do get layer by name and the name we want to look at is called is enter no need for DOT tiles afterwards and now we could print obj if I run the code we are getting a print out of all of the objects on this layer we have a name either player or a character at the moment we only care about the player once which means we want to run some code if objname is equal to player if that is the case for now let's say I want to print the object node so if I run all of this we are only getting all of the player start positions that's that's a good start now from this object we can get quite a bit of information for example we can get X and Y for the position or we can get the properties that we have to find if you look at til the custom properties I'm talking about are in this case the direction and the position direction for now doesn't really matter the one that we care about is the position and this one would Define where the player came from this case the starting position would be the house or this house to be a bit more specific if you go to another start position this one it will be planned for this planned Arena now back in the code when we are calling the setup method early on I have passed in the house for the starting position and we basically want to look at all of the objects and then find the object that has the custom property house for the position to get that one we want to get the properties and then look for the position if I run the code like that we can see we have all of the starting positions and the one we care about is the house which means to single out this one object we want to expand this if statement if obj name is player and obj do properties with the position is equal to the player start position if that is the case we want to get obj dox and obj doy I can now run the code and we should only be getting one position that looks really good perfect that also means now that we have a position we can start working on the player because this one needs a position and groups both of which we have meaning I want to create a player objx and obj Y will be the position and then for the groups I want to have self. all Sprites and if I fix my typo this should also work if I now run the code we are not getting an error message but we also cannot see the player simply because at the moment we are only displaying the top left of the map and to see the player we have to create a camera that being said inside of til if you move this player start position all the way to the top left like this save the tile map return to pame and then run this again we can see the player so this one does indeed work which means we have everything we need to get started with the camera although before that there's one more thing that I would like to do the player should be able to move around without that the camera is going to look a little bit weird now moving around is going to involve two parts number one we have to capture input let me add a pass in there for now and the second part is is going to be the actual move method which will need self and Delta time I'll explain that one in just a second although for now I will simply add pass in there to get started with input we first of all want to get all of the keys being pressed which we get with pame dokey. getor pressed that we can use for example via keys and py game. Kore up which is a constant inside of pame that tells us that we are pressing the up Arrow key if that is the case I want to for example print up and that logic should be sound but we have to call the input method for it to work in the first place and that we do via an update method which for now is only going to accept self as a parameter in there we want to call Self do input now to call this update method we have to look at the all Sprites group because this one can draw all of the Sprites and it can call the update method which is quite easily done before we are drawing all of the game logic we want to get self. all Sprites and then call the update Method All That update is doing is it looks at all of the Sprites inside of all Sprites or whatever group you have and then call the update method in our case this will only apply to the player because the Sprites do not have an update method but other than that if I now run the code we are getting an error that inside of pame I have a typo this should be py game if I now run all of this and I press the up Arrow key we can see up so that is looking really good we can now capture keyboard input we just have to use it inside of the game and the way I usually approach that is by first of all creating another Vector that I call input Vector which is simply going to be a vector without any values the default value for a vector is zero and Zer for X and Y meaning if if you simply create a vector like this you're getting zero and zero this Vector I want to update for example if we press the up Arrow then I want to get the input Vector update Y and subtract one from it all of this I want to copy because next up we want to check the down arrow if that is the case we want to increase y by one I can do this once more next up we want to look at left and if that is the case we want to get the export of the vector and reduce it by one finally we want to walk to the right which means we want to increase X by one the end result if I print the input vector and run main. Pi you can see if I press different arrows on my keyboard we are getting the various directions so that's looking really good one thing that I do want to mention before we continue this input Vector is quite important because it gives us a blank Vector with values of 0 and zero that way whatever we're doing here simply gives us the keyboard input and nothing else if the input Vector already had any other value this would cause some problems hence I want to keep this inside of the input method and not have anything else influence it but that causes another issue because we're getting the input in there but we want to use it inside of the move method to actually move the player I.E we have to connect these two and this I do via another attribute of the class that I'm going to call self. Direction which by default is going to be another Vector now after we're doing all of the input I am updating self. Direction and set it to the input Vector that way we can use Direction inside of the move method and I think for now we don't actually need Delta time so let me get rid of it to move the entire Sprite all we really need to do at least for now is self. w. Center plus equal self do Direction multiplied with some kind of speed for now let's go with 250 and that is it if I now run self. move after the input run may not Pi again I can move around but you can see that the player is moving way too fast fast if I run this again and simply tap right once we are going way too far to the right I suppose if I reduce the speed to something like five and that is looking significantly better at least now we can see the player movement this is still not ideal simply because this update is not frame rate independent that means inside of the game we have some kind of frame rate that we can actually measure via a self. loock which we get with py game. time. clock that clock inside of the game Loop we have to call self. clock. Tick this simply tracks the frame rate and once we have that we can measure the frame rate and print it out self. clock doget uncore FPS and don't forget to call this one if I now run all of this you can see that our frame rate is around 250 frames a little bit more than that meaning we are running this while loop 270 times per second and then apply this update to the player position by the same amount so 270 times per second we are changing the center of the player which is fine on its own however it does not work when the frame rate changes which we can emulate by adding an integer into the tick method if you leave it empty the game tries to run as fast as possible but if you add a 60 in there then our frame rate is going to be 60 and now our player is going to move significantly slower which is not ideal our movement problem at the moment is that the game tries to run as fast as possible and then update the player position since we are doing this by default very often the player is going to move really fast however some levels especially the smaller ones like the hospital are going to run even faster because we don't have to render as many elements not to mention that the game is going to run on a variety of computers some more powerful than others and because of all of that the frame rate of the game is not really going to be predictable on some computers it might run at 30 frames per second on other computers you might get a thousand frames and we want to account for all of that and that we are going to do via Delta time or DT in short now I am not going to cover Delta time in detail in this tutorial that being said I have made an entire video on Delta time so check this one out if you want to learn about all the details essentially we want to run our game as fast as possible no arguments inside of the take method and then capture the return value of the take method and stored inside of DT this DT is now going to give us the time difference between the current frame and the last frame or in other words how long it took in seconds to render the current frame and this we want to have in milliseconds at the moment we have all of this in seconds so we want to divide it by a th since they're 1,000 milliseconds in a second and just to print out what we are getting I want to print Delta time run this entire thing again and now if I run around for a bit you can see on the last frame we had a frame rate of 270 and a Delta time of 0.003 which means that it took my computer about 0.003 seconds render the current frame which by itself isn't particularly useful but we can use that information inside of the update method so I want to pass it in there although for that to work inside of the update method in the player we have to create another parameter Delta time which we then want to pass into the move method so now we can recreate the Delta time parameter basically all we have to do to use Delta time is to multiply it with the update of the movement and now I can use a speed of 250 again because if I run main. Pi even though our speed is 250 we are moving at a reasonable speed which is going to be the same speed regardless of the frame rate if I set for example the frame rate to 10 really low we are still moving at the same speed now the game is going to look really choppy because the frame rate is terrible but the actual movement is the same cool so with that we have some very basic player movement that's all we need for this part which means next up we can work work on an actual camera because at the moment the player can simply move outside of the window and then it disappears so we want to create a camera to follow the player and the way that works in pame is by creating a custom group for that I'm going to create a new python file that I want to save as groups. Pi and there first of all we will need from settings and I want to import everything then we can create a class called all Sprites which needs to inherit from pygame dos sprite. Group after that we will need it under init method with self and nothing else for now the only thing that we will need in there is super Thunder init to initialize the parent class and with that we have basically created a copy of the inbuilt Sprite Group which means inside of main. Pi I can from group import all Sprites and then instead of assigning py game. sprite. group to all Sprites I can simply assign it all Sprites if I now run out of this we cannot see a difference the game runs just as before that being said we are now able to customize the drawing logic basically what we want to do we want to create a custom draw method which by default will need self and a surface to to draw on so this draw method is what we are already using down here so if I don't to anything in there and simply add pass I can run main not P again and now we can't see anything anymore simply because this draw method doesn't do anything to recreate the default Behavior we will need a for Loop for sprite in this one would give us all of the Sprites inside of this group self is going to return all of the Sprites that are contained inside of it now by default all that pame really does in there is it takes the surface and then runs the blit method with sprite. image and sprite. rect I can now run all of this again and we get the default behavior that looks good except now we can customize this quite a bit more for example in our case we always want to draw on the display surface meaning we don't really want to pass a surface in there instead in the dunder init method I want to get self. display uncore surface which I'm going to get with py game. display doget uncore surface only on this surface do I want to blit all of the Sprites because of that I don't need the surface parameter anymore I want to get rid of it in there and then inside of main. pi as well if I now run the code everything still works just as before that's the first step the next one that we need is to offset all of these Graphics by default we are placing the Sprite image always in the position of the rectangle but that we don't have to do for example we could Define self. offset which would just be a vector and let me add in a default value let's say 100 by 20 that value I can use to offset all of the Sprites which I'm doing by getting the top left of the rectangle and then adding self. offset I can now run my not Pi again you can see that we are drawing Everything 100 pixels forever to the right and 20 pixels further down which means all that we really have to do is somehow connect this offset to the player position so that we are always centering the player for that first of all we need to get access to the player itself which I want to do via a parameter let's call it player uncore Center that we can get inside of main.py although for that we will have to store the player inside of an attribute self. player is going to be the player that way inside of the draw method I can get self. player. rec. center after that inside of groups I can update self. offset let's say for now self. offset dox is going to be player Center and zero remember this player Center is a tup with X and Y which means to get the offset y we want to get player Center one also by default the offset shouldn't have any values if I now run m not Pi again and I move the player around we are getting something this isn't working perfectly yet but well we are making progress the way you want to approach all of this if this is the entirety of the window our offset position by default is going to be in the top left or Zer and zero we want the player to always be in the center of the window which means this offset point should have a distance to the center of half the window width like this and then half the window height on the vertical axis like this which means on the X part I want to subtract window on _ WID divided by two and then on the vertical axis I want to get window height and now if I run this again we are getting something well that is working a little bit better the only thing that's left to do is to get the negative value for both of these let me put it inside of parentheses and then add negative now all of this is going to work just fine so that is looking much better I can move around freely the camera is working now the reason why we have to get the negative values is imagine once again we have the window we have the player in the center and then we have a whole bunch of tiles around it let me just draw them in something like this and there are some elements outside of the window all that the camera is really going to do if the player is moving down we are moving all of the elements up by the same amount or in other words we always want to move the camera in the opposite direction compared to the movement that way we keep the player in the center of the window and well that is all we need to get started with the camera which means back inside of til I can move the starting position of the player back to the original Point here is and now inside of main P we are starting in a really nice spot so that is working much better although you can see if we go outside of the map everything still falls apart that is because we are not filling the background what is happening here is that py game doesn't discard the previous frame it simply draws on top of it because of that we're getting all of the fragments if we're not filling the background that is an issue we can fix quite easily before we are drawing all of the Sprites using the draw method I want to get self dot display surface and then fill it with a black color I can now run this again and now we don't see the fragments anymore which is feeling much better now later on we're going to fill this area with a coastline and with water and the player is never going to see the black background simply because we're going to have collisions for example here with the rocks and the player will then not be able to see any of the black areas but that's a problem for later and I think this part has gone on long enough so let's do an exercise and then we have finished with this part what I want you guys to do is number one place all of the objects from til and make them visible inside of P game in other words if you look at TI we have an object layer called objects which contains all of the houses trees rocks and so on this one is quite extensive I want you guys to display all of these elements inside of the game after that import the hospital TMX map and also display all of the tiles on the terrain top layer inside of til you want to open hospital. TMX this one contains a level very similar compared to the Overworld I want you guys to launch this level inside of the game and also we have terrain top which contains the countertop thingy this I also want you guys to display inside of the game this is going to take you a little bit of time so try to go through it slowly and if you can't do it don't worry too much about it I will go through it in just a second pause the video now and try to figure this one out on your own to get started I want to work inside of the setup method and add a few comments to make this thing a bit more readable we have the terrain tiles and then we have the entities besides that I also want to have the objects which we're getting via another for loop I want to have for obj in TMX map doget layer by name the layer name for this one is objects all we want to do in there is to create a Sprite at least for now which like before is going to need three arguments position surface and groups the position we can get from obj dox and obj doy the surface we get from the object as well obj do surface the surface we can get from the object as well obj do image and finally for the groups we only have a single one self. all Sprites and that should be it if I now Run the game we can see all of the objects now this isn't perfect for example this tree is on top of the house and also if you go a bit further down we have a few more issues so this isn't working perfectly yet but it's good enough to get started which means we have covered the first part so next up I want to work on the hospital first of all for that we have to import it inside of import assets I want to add a second entry to the dictionary and let me do this over multiple lines in fact I can duplicate all of this and add a second key value pair the key is going to be hospital and we want to import data maps and hospital. TMX after we have that inside of the setup method I want to load TMX map and Hospital although if I run the code now we are going to get an error that game object has no attribute player that is because inside of the hospital we don't have a house starting position to get the actual starting position you want to look at tiled and then the entities let me hide everything else this marker is going to be the starting position of the player and that position is called World which means for this part we want to start the player in the world position if I now run the code we get the hospital hit so that is working pretty well there's just one more thing that we have to do we want to display terrain top this one contains the counter on top of all of the other tiles so that part is going to be fairly similar compared to the terrain which means we can literally copy the entire four Loop and then change the layer name to terrain pop if I now run all of this we have a counter that is later going to have collisions now that being said there's one important thing you do want to keep in mind for all of this and that is the drawing order at the moment we are sorting all of the Sprites by the time of their creation which means the terrain tiles were created first so they are always at the bottom then we are creating terrain top then the objects and then the entities meaning the entities are always on top of everything else however if I create ter top before the terrain and run this again we cannot see terrain top anymore that is because the terrain is now on top of the rain toop which shouldn't be the case now later on we going to create a much better system to sort all of the spres in fact if you look at settings there we have World layers this one we will later on use to sort all of the Sprites but for now that's a bit more advanced and we don't have to worry about it too much the one thing you want to keep in mind point is that you want to have the terrain tiles first then terrain top then objects and then the entities if you couldn't see some Sprites that was probably the reason but all right with that we have a basic level set up there's just one last thing that I want to do to clean this thing up just a bit because we have two four Loops that basically do the same thing that we can simplify with another for Loop we want for layer in and then we have the rain and ter rain pop which needs to be a string inside of this for Loop we want to have the for Loop that actually creates the Sprite except we don't want to have the terrain name we want to have the layer that way we shouldn't need the second for Loop anymore and now if I fix my typo this should be terrain all of this should also work just as before and that looks really good cool perfect with that we have covered the basic outline of the level the next major part are going to be the Overworld animations specifically we want to have a coast animation and a water animation that is going to make everything look significantly nicer for these animations we have to go through two steps the first part is the actual animation itself and this part is fairly easy inside of a Sprite we're going to store multiple surfaces and then cycle through them for example we could have four Sprites like this and we we are simply going to play one after the other and that way we are getting an animation what is actually a bit more difficult is to get all of the data because for these animations we have to import a lot of data and this we cannot do manually so we want to create a couple of functions to mass import data and that is going to be the main part of this section as a matter of fact we already have a couple of functions ready but step by step first of all let's have a look at the project folder in there we want to look at graphics and for now we only care about the water animation and the coast animation I want to start by looking at the tile sets and in there we have a folder called water and then a graphic called Coast those two we want to work with and they are different styles of graphic if you look at the water folder we have four graphics and if you combine them you get a water animation besides that for the coast we want to import all of this and then take it apart if I make this full screen the way you want to think about all of this is we have a tile here a tile here a tile here and a tile here and if you play all of those in sequence so with 0o 1 two and three then you would get one Coast animation or this style of Coast if you then go a bit further to the right you can import all of the center tiles and get another kind of animation for the same Coast type but for a different section of the coast so when we are importing this graphic we have to take it apart and then store it in a way that is more easily usable that will be the most complicated part of this section although ultimately it's not going to be too hard back inside of the code I want to first of all go back to the Overworld meaning TMX map. world and the start position is going to be house if I now run the code we are back in the overw world and we can move around that still looks just fine with have that covered we have to talk about the Imports and for that we actually have already a python file so in my case I want to open up support. Pi in there we have five functions that take care of the Imports the first one is the easiest one this one simply Imports a single image and there are two things it simplifies number one when we are creating the path for the import we are using the join method meaning this is going to work across operating systems without a problem and on top of that we are also specifying a default format so when you're using this import image it's a bit easier to use than py game. image. load not terribly but it's a bit more convenient after that we have import folder and this one basically goes through a have and then Imports all of the images inside of that folder now for this function we are only storing the surfaces but if you want to retain the name you would look at import folder dictionary this one stores the file name and the actual Surface after that we have import subfolders this one goes through a folder with lots of subfolders and then Imports all of the images inside of each subfolder and finally we have import tile map This One Imports a tile map and slices it up depending on how many columns and rows we have now these functions I am not going to explain in too much detail because I have made a separate video on them so if you want to know all about them check out that video but for now I want to work with import folder because if you look at our title set folder inside of Graphics there we want to import the water folder this one simply contains four surfaces and we don't really care about the inside of main.py I first of all want from support import everything and then in the import assets method create another dictionary self. Overworld uncore frames for the key I want to go with water and for the value I want to use import underscore folder the function function I've just talked about this one and then we have to specify a path with comma separated values we want to go upper folder then we want to go to Graphics in there we have a folder called tile sets finally we have the water folder so the folder path we have just specified is upper folder Graphics title sets and water if I now run the code we not getting an error message that is a really good sign on top of that I could print self. Overworld frames and if I then run the code we are getting a dictionary with one key called water and the associated value is a list with surfaces these are going to be our water surfaces so this one is working just fine now we have to figure out how to display them and for that we will need a new type of sprite animated Sprite Which will need to inherit from the Sprite we have already created IE this Sprite will be the parent class of the animated Sprite Which means when we are creating the dunder init method with self we will need a position surface and groups to also satisfy the parameters of the parent class which we are doing by calling super Thunder init then pass in the position surface and groups that way we would simply duplicate the Sprite although that's not actually what we want to do instead of a single surface for animated Sprite we want to have a list of surfaces that I usually call frames and then when we are initializing the parent class so the Sprite I want to get frames and for now use the first item inside of the list now that is not going to create an animation but at least with that setup we will not get an error message so we can get started with this class right away which means next up inside of tiled we have to figure out where water actually is and for that we have another layer called water if I make this one visible you can see we have a whole bunch of objects that are going to Define where water is all of those are going to be rectangles in various sizes the way we are going to use them is we are always going to separate each area for example this would be one area that we are going to import a simple rectangle this we are then going to separate into three individual Parts this would be one this would be the second one and this would be the third one by that system we're getting the proper position for every water Animation Sprite Which means back inside of the code and I want to move support. Pi all the way to the right that just feels a bit cleaner next up inside of main. Pi in this setup method I want to add another section we can do that one all the way at the bottom for the water and there we want for obj in TMX map and then get layer by name the layer name is water and just to see what we are getting let me print obj do WID obj do height obj dox and obj do y if I now run the code we are getting a whole bunch of output so we have a lot of areas for the water but the way you want to think about it we always have triple values with an exp position a y position a height and a width these numbers we have to use to create the proper areas so what we want to do is first of all a for Loop where we are going through all of the x positions which we're getting for X in and then a range where we need a start position an end position and a step size imagine that this is the entirety of the map area and we for example have one Water Area here at the moment we want to splice this thing up into columns and rows something like this at the moment inside of our four Loop we are simply looking at the columns meaning we want to start here and there and then jump by these column sizes that would be our step size and also the easiest part that one is simply going to be the tile size we always want to move an increments of 64 pixels also let me clean this one up a bit so we can see what's going on next up we have to figure out the start and the end position and those are going to be fairly simple because the start position is this one and the end position is this one which we can get with obj dox and this at the moment is a floating point value which the range function does not like meaning we have to convert this to an integer right away but that way we're getting the left side of the object area or other words this line next up we have to figure out the end point which is simply going to be the start point plus the WID of the entire area this one also has to be an integer we want to get obj dox which is the left side plus obj do wi that way we're getting the right side next up we have to do all of that for the vertical part so for y in range in obj doy that's the start then integer obj doy plus obj do height that would give us the endp point or the bottom of the rectangle area and finally for the step we want to use the tile size and now we have an XY position which we want to use inside of the animated Sprite the one we have just created although for that to work all the way at the top we have to import the animated sprite from Sprites that way we can use it and we have to pass in a position the frames and the groups the position is super easy that one is simply going to be X and Y the frames are going to be self. Overworld frames and water the one we have just imported this one and finally for groups we only have a single one self. all Sprites and now if I run all of this and move a bit down we can see the water and at the moment the water is on top of the player because we are creating it after the player that's going to be an issue we have to deal with later on but for now that is looking pretty good and by the way this black area between the sand and the water is going to be for the coastline that's the intentionally first of all though we have to create an animation for that I want to create two more attributes self. frame uncore index and self. Frames we can do all of that on a single line because the frame index is going to be zero and the frames are going to be the frames we are getting from the parameters these frames here self. frames is simply going to store the frames so we can reuse them and we are going to pick one frame via the frame index for example when we are initializing the parent class we don't want to have a static integer we want to have self. frame index which is not going to change anything this value is still zero but if we increase the frame index we would get a different kind of graphic that system we can use by creating an animate method which will need self and Delta time all that we are going to do in there is self. frame index plus equal some animation speed let's for now say four and this we have to multiply with Delta time that way all of the animations are going to be at the same speed regardless of the frame rate and that we can then use to update self. image for which we want to get self. frames and then pick one of the self. frame index values that however is not going to work for two reasons number one self. frame index after this line is going to be a floating point value remember Delta time is a really small value something like 0.004 if you add that to the frame index which at the moment is zero you are going to get a value that will not be an integer which we we have to fix right away by turning this into an integer that's the first issue after that we have to account for this number growing without any kind of constraint but we have a limited number of frames at the moment for water we have four animation frames so the frame index cannot exceed that and that we can Implement via modulus where we want to get the length of self dot frames that way if the frame index exceeds the length of the animation frames we are starting back from the beginning and that is all you need for the animation it's ultimately very simple all we have to do now is to create an update method with self and Delta time and then call anate or more specifically self. animate Biff Delta time that should be all we need if I our run made of Pi we have animated water and that is looking pretty good cool the only thing I want to change is instead of using this four I want to go to settings and then use the animation speed let's paste it in there and now main.py looks about the same but now we have more control over it or rather we know a bit more what's happening inside of this method this feels more readable that's the first part next up we have to work on the coast tiles for that we are still going to use the animated Sprite class but we have to figure out a few more things the first thing that we have to work on is what frames to use and for that let's have a look again at the graphic I talked about earlier this is what we want to import and then take apart so that we can use it for animations after that we need to figure out which of these tiles to play so do we want this grassland this inverted grassland the beach the snow or any of these other graphics on top of that we also need to know where to place that animation all of that you can find inside of til let's have a look at the moment we don't need the water anymore and we also don't care about the objects instead we want to look at the coast layer let me make this one visible and this is going to give us a whole bunch of object areas that all have the same size that part actually doesn't matter very much what we really care about is the X and Y position along with their custom properties there we have the site and the terrain the terrain should be fairly straightforward this one could either be sand or it could be something like up here where we have grass inverted and just to explain inverted if I maximize this all of these tiles would be the grass tile sets and all of those tiles would be grass inverted so with that we know where to place this tile and what kind of graphic we want which means we can now go through the entire process step by step and let's start with the Imports that is going to happen inside of support. Pi in there we already have one function that can import a tile map it's called import tile map for this one we have to specify the amount of columns rows and then a path that function we are going to use but we need a bit more extra functionality which means I want to create a function called Coast importer for which we are going to specify the amount of columns the amount of rows and then once again a path that information we are going to use right away to create a frin dictionary which will be the return value of import tile map let me copy it and then we have to pass through the columns the rows and then the path that we also want to unpack right away and just to make sure you see what's going on on let me print the frame dictionary right away after we have that I want to copy Coast importer and then inside of import Assets in the overbo frames we want to create post tiles which is going to store the return value from import folder for which we will need the columns the rows and the path to look at the graphic once again this one is going to have 24 columns and 12 rows it's a bit hard to see but basically every single one of these individual tile groups like one of those is going to be 3x3 tiles and we have eight of those in total and each of those has four iterations which means we have 3 * 8 on the WID and 3 * 4 on the height I.E 24 by 12 meaning 2 4 by 12 and the file path is going to be a folder up then we want to go to Graphics then we want to go to tile sets and the actual file that we want to import is called Coast if I now run all of this P game is going to load for a second and then we are getting a pretty substantial dictionary so what happened here well we are getting a dictionary where each of the keys is a tall that has an X and A Y value or rather a column and a row value with the associated key being a surface what that means if I open up the graphic again all the way in the top left this first tile is going to have the key zero and zero if we then go one field further to the right this one we would have a column of one and a row of zero that would be the key for for this surface and this we're going to do for every single one of these tiles until we reach the end of the graphic which is going to result in this entire dictionary it is actually quite long that's a good start but not actually what we want what we instead want is a list with surfaces let's say this one then this one then this one and finally this one along with an appropriate name that is going to give us the position on the tile set and the kind of tile we are working with for that we are going to write a bit more logic inside of Coast importer first of all I want to create a new dictionary which for now is simply going to be an empty dictionary and then we're going to create a list of terrains for that value let me paste it in so you don't have to watch me type we're going to have a list with all of the types of terrain that we are working with I.E if I open the graphic once again the first tile set would be grass that is this one the second one would be grass inverted that's this one then we have sand inverted that's this one and we keep on going until we reach the end of the tile set after that we will need the sites that we are working with and for that we will need a dictionary that gets a bit more extensive so let me copy this one in as well it's going to look like this and this should happen over multiple lines I guess we can do do it like this that looks good for this one we are looking at the various sides of the coastline for example in the top left we have this part and that is zero and zero then we have the top which is going to be the one right next to it where we have column one and row zero however if we take another example the bottom right one this one would be the one in the bottom right where we have the second column and the second row the way you want to think about the sides is that we are looking at the first eight tiles or rather the first tile group and that can be really useful because if we are offsetting all of these numbers for example to go three columns further to the right then we are getting all of these tiles while still keeping the same top left the same left side the same bottom side and so on also in the description of this video I'm going to add a note with all of these values so you can copy them right in anyway after we have that we can work on the actual logic and essentially what we want to do we want to look for Terrain in uh Reigns The List we have just created although on this one we also want to know the index we are on which we get via enumerate and then we can expand the for Loop we want to have the index and the terrain which means what we're going to get is index and terrain let me print it run main. pi and we can see we get zero for grass one for grass inverted and so on after we have that inside of the new dictionary I want to create a new key which means I want to get the new dictionary and the new key is going to be the terrain which itself is going to have a value of a dictionary and this dictionary we're going to fill with key value pairs where the key is the S side and the values are the associated Graphics that we need for that we're going to need another for Loop for key and position in sites do items after we have that I want to work inside of the dictionary we have just created which we can now access via this value and then we want to create a new key value pair where the key is going to be the key I.E top left top top right and so on with the associated value being a list of frames those frames we are going to get from the frame dictionary the values we imported all the way in the beginning now this is a dictionary meaning if we specify a tupal with a column and a row we are going to get a value for example what we want to do at the moment we are inside of this for Loop and have some kind of a position let's say we have the top left that would be this top left tile from this tile we want to jump down three tiles to get this one then three more tiles to get this one then three more to get to this part these are the four tiles that we actually want to store which means first of all we need to figure out the row and that we can do via a for Loop and by the way we are going to use list comprehension I already started doing that we want to use for row in a range for this one we always want to start all the way at the top so zero then we want to go to the amount of rows that we have that's the number we have specified in the parameters for the step size we want to go with three that would almost give us the row the one thing we have to add is we want to get position one the position we getting from the for Loop and then add the row to it this position one is really important because in the top left we get a default value of zero so in there it's not going to do anything but if we are going to go a bit further down for example to bottom right there the start row is going to be two this we have to account for and after that we have to work with the column for which we once again will need a start position which is going to be position zero we want to add the index and multiplied with three the index is what we're getting from the enumerate of the parent for Loop if we are on grass this would be a zero if we are on grass inverted this would be one and so on that way if we are on grass has inverted the column wouldn't be zero anymore it would be three because we are multiplying one with the number three that is always going to give us the right column and with that we are done all we have to do now is at the end of the function return the new dictionary then we can work inside of the Overworld frames and print self. Overworld frames and we only care about the coast if I now run all of the is we are getting an error and that is a really easy one to fix I have simply made a typo inside of the dictionary let's try this again and there we go this is looking much better now we still have a massive dictionary but now the first key is going to be grass the associated value is a another a dictionary where the first key is top left and then we have a list of surfaces and those we can use for the animation that is a really good start now we just have to figure out how to use all of these Graphics that is going to happen inside of setup specifically after the water I want to have a section for the coast and figuring this part out is going to be your exercise I want you guys to use the coast tiles we have just imported to actually display the graphics all of that information you can get from the TMX map first the video now and see if you can figure this one out on your own we are going to need another for Loop for obj in TMX map doget layer by name the layer we want to work with is called Coast for each of those objects we want to get a Terrain and a side for that inside of til you want to look at the properties because there we literally have a side and a Terrain those values we can access via obj do properties and for the terrain we want to get the terrain and for the site we want to get the site finally we can create an animated Sprite Which is going to need three parameters position frames and groups groups is the really easy part we only have a single one all Sprites position is also fairly easy it's simply going to be a tuple with objx and obj doy the only thing that's a bit more complicated is going to be the frames for that we will want to get self. Overworld frames then we want to have the ter Rin and finally we want to have the right side and that's basically it if I now run all of this we are getting an error and I hope you can see the problem at the moment I am getting all of overbo frames that would be this dictionary which at the moment has only two Keys Water and Coast but I am trying to get the terrain right away to fix that what we have to add is first of all we want to get the dictionary coast and now this should work and now we have an animated coast line so that is looking pretty good now the coast is on top of the playup which looks a bit weird but that's an issue for later I think for now this is working pretty well and let's try and check the other Coastline should come up there we go this is looking pretty good so I am quite happy with that perfect I hope this section wasn't too complicated basically the Imports can get a bit confusing but ultimately when you're looking at this again we not doing anything fundamentally complicated we are simply writing in nested for Loop so I would really recommend to go over this thing a couple of times to make sure you understand it mastering list comprehensions and python is a really important skill and something you definitely want to practice for the next part we are going to start with the characters meaning we are going to animate the player and we're going to create all of the other characters they are not going to do anything and we have no collisions but at the very least we are making some solid progress now for the logic of this part the player and all of the NPCs share quite a few attributes meaning we can rely on inheritance where we have a parent entity class this one for example covers the animations and the setup of the character this will then be the parent class for the player and for all of the characters after that for example for the player we are going to capture user input and check collisions while for the characters they're going to get some other code for example to look around or for the dialogue should be a fairly straightforward section although before we get to any of that we have to do a few more Imports because if you look at the project in graphics there we have the characters and we have to import all of this let's get started with that part for that I want to work inside of import assets besides the water and the coast I want to have another key value pair which is going to be for the characters and essentially I want to have a function called all character import where we simply have to specify the parent folder which is going to be going one folder up then we are going to go to graphics and finally we want to go to characters that would get us to the folder I just talked about this one now this all character import doesn't exist at the moment so let me copy it and inside of support I want to minimize everything so we have a bit more space and then below the import tile map I want to Define all character import where we have to specify a path for this one like we have done with the coast tiles we want to create a new dictionary where for example we have a character like the player and then the associated value is going to be another dictionary for example one key could be called downcore Idol and this would be a list with a single surface so basically this is going to be our player and the down idle key is going to get a list with this surface only so if the player is facing down and not moving this is the animation we are going to play now since we have an animation with a single frame we are only going to play this individual frame so that's not going to do very much however another key that we are going to add could be for example down where we want to have a list of frames specifically we want to import the entire first row if you play all four of those frames in sequence you get a down walking animation that's all we have to do and by default I do not want to have any value inside of the new dictionary instead first of all I want to get all of the characters meaning I want to get all of those images to get that we could look at the other functions we have already in there for example if you look at import folder we have a for Loop for folder path subfolders and image names in the walk function this one simply walks through a folder and then gives you all of the content this is what we want to do as well for this one as a matter of fact I can literally copy this line and just to demonstrate what we are getting let me print the folder path the subfolders and we want to get the image names if I now run may not Pi we are getting some data the first entry is the folder name that we don't really care about because we already have that one then we get an empty list and this is what we're getting from the subfolders since in the folder we are currently looking at there are no subfolders we are getting an empty list returned that's also not a part we care about so we can just ignore it finally the only value that we really care about is image names that would be a list with all of the images inside of the folder or to be a bit more specific this is going to be a list with the name of every single file in that folder in our case it just happens to only have image files now this is the only value that we actually care about meaning I can replace the folder path with an underscore and the subfolders with a double underscore to indicate that I don't care about these values all I want to look at is the image names this is a list that I want to cycle through which we do before image in image names if I print the result we only care about the image we are getting the file name for every single one of these files this data I want to retain and use it as the key for the new dictionary although I do want to get rid of the PNG let's create a new local variable I guess we can call it image name which we're getting with image and then using this split method we can separate the string wherever we have a DOT and then only pick the first value that way we are getting rid of anything after the dot once we have that we can get the new dictionary and create a new key which would be the image name the value we want to assign to it is going to be another dictionary where for example we have a key with down and then a couple of frames along with it but this we can't do easily right now now you could use the import kle map function the one we already have and we know if you look at the folder or any of these Graphics we have four columns and four rows for every single one of the characters meaning we can get four and four along with a file path that file path we can get from the parameters the one all the way at the top along with the image name that we have created here if I now run m Pi we are not going to get an error and if I print self. Overworld frames with the characters I can run this again and now we are getting none that is because at the end of this function we are not returning anything so return new dictionary and now let's try this again that looks a bit better basically the first entry is called blonde and then we have all of the frames that we have gotten from the tile map importer then we get the second character fire boss and a similar kind of dictionary that's a good start but we have to organize this better inside of support. Pi I don't want to use import tile map so let me cut it out and instead I want to create another function that I called character importer where we are specifying rows and columns just as before and then we are assigning a path let me create that function right away actually define character importer where we have the columns the rows and a path inside of that function we are still going to use import tile map although now we are only going to need a path Because the actual path we are creating inside of all character import all we have to change is that instead of A4 we want to have the columns and the rows and then we should get roughly the same result if we are returning the values from this tile map function so so far we haven't really achieved anything but what we can now do is instead of returning the value right away I want to for now store it inside of a local variable called frame dictionary now this value we want to change quite a bit so I want to create a new dictionary which for now is going to be entirely empty and now to separate the graphics let's have a look at it if you look at the first row you can see that we are just moving down so on zero we get all the down animations then on the second row or Row one we are going to the left on the one with index two we're going to the right and on index 3 we are going up that information we can use right away inside of a for Loop you want to have for row and direction in a numerate and then we can add a tuple with the values down left right and up just to demonstrate what we are getting if I print the row and directions I can run main. pi and we are getting for every character zero down one left two right and three up meaning we're getting the right row along with the state of the character for that row that information we want to use to create a new key value pair inside of our dictionary which means new dictionary and the direction is going to be a list of frames where we are looking at our frame dictionary the one we are getting from import tile map and for this one we have to specify a tuple with a column and a row the row is the easy part because this is what we're getting from the for Loop that part we don't have to worry about the only thing we have to worry about is the column and for that part we can use the list comprehension once again because I want to go for column in range alss very much a similar thing compared to what we have done with the coast importer this stuff down here with that we are getting a new value inside of our dictionary so at the end of the function I want to return the new dictionary which we are capturing inside of this other dictionary which we are then storing inside of the Overworld frames in the characters key let me print the result self. Overworld frames we want to get the characters and now if I run all of this we don't need the output for the blond character we still have a dictionary but now the first value is going to be down with a list of surfaces there should be four in total those four and then we get the left movement there we have four more entries then we get right and so on that is looking really good but we want to have just a little bit more this is only going to give us the walking animation besides that I also want the idle animation which is always going to be the first frame of the walking animation for each individual Direction the way we're going to get that I want to get a new dick entry where we're going to get the direction but now this part is going to be inside of an F string where we are going to add underscore idle at the end the value for this one and this is really important has to be a list even though we are only going to add a single surface in there we still need to have this inside of a list that will simplify the animation logic a lot but other than that we want to get the frame dictionary again for which we have to specify a tuple with the column and the row the row once again we are getting from the four Loop and the column is always going to be zero and that is it if I now run m. Pi we get the dictionary printed out and you can already see at the bottom we're getting right idle that has a list with only a single surface inside and well then we have a whole bunch more Valu I am pretty sure that this is working well cool so with that we have done a lot of importing let's minimize this and now we can actually create the characters that's going to happen inside of entities. Pi in there all the way at the top I first of all want to create a class called entity that is the class I talked about in the beginning which will become the parent for the player and for all of the other characters for this one we we want to inherit from pygame dos sprite. Sprite we also want to create a thunder init method where we are specifying self then a position frames and the groups also we have to initialize the parent class which we do with super Dunder in it and pass the groups in there now this entity class will become the parent of the player which means the player shouldn't inherit from a Sprite it should inherit from the entity mean meaning we have to update the super Dunder init method or in other words we have to get a position frames and groups let me copy all of those parameters actually now position and groups are fairly straightforward we're getting those for the player right away via the dunder init method although frames we do not have at the moment to fix that the player's going to need another parameter frames which means inside of main.py when we are running the setup method and create the player that happens here we have to add another argument in there we want to get self. Overworld frames in there we have the characters which is going to be a dictionary on its own which has the key layer also I am running out of space and later on we're going to add more values into the player I want to use multiple lines and then named arguments we have the position we have the frames and finally we have the groups that is much more readable cool with that inside of entities we get all of the arguments for the player and to initialize the parent entity class which means if I run main.py the code runs just as before we are not using any of the data but at the very least the game doesn't crash so that's a good start next up then inside of the entity class we want to organize the animation or in other words I want to set up the graphics for that like in the animated Sprite we will need two attributes a frame uncore index and self. Frames the frame index will always going to be Zero by default and the frames are simply going to be the frames after we have that we can cover the actual Sprite setup for which we are going to need self. image and self do rectangle the image is going to be self. frames and from that we want to pick a single surface however that we can't do immediately because these frames are different compared to the frames we using inside of animated Sprite inside of that class frames are simply going to be a list with surfaces so indexing is very easy we simply have to specify a value like 0 1 or two and so on for entities this gets more complicated because this one has a dictionary where we have a state like down and only then do we get a list with all of the surfaces which means to get a single surface we first of all have to get the state of the animation and then we want to get self. frame uncore index I suppose to get started the state could simply be down for now although later on this we are going to change next up we have the rectangle this is quite simple self. image. getet F rectangle we want to set this Center to the position after we have that inside of the player since entity is already covering the image and rectangle the player doesn't need that part anymore let's try main.py and now we can see the player there's no animation yet but at the very least we have a basic graphic to animate all of that we have to create an animate method meod with self and Delta time for this one we want to get self. frame index and then plus equal the animation underscore speed multiplied with Delta time after that self. image needs to be updated where we are going to get self. frames then don't forget we will need the state and then we can pick one surface from the list of surfaces via the frame index which is going to happen basically in the same way compared to what we have seen inside of the animated Sprite class we want to get an integer with self. frame index then the modulus operator along with the length of self. frames although once again this is a dictionary to get the actual frames we need the state again cool that looks pretty good next up we need an update method with self and Delta time in which we are going to call self do animate with Delta time let's try out of that and nothing is happening the reason for that is that we don't actually have an entity class we have a player class and we are only calling the update method on that class or on the instance of that class meaning in there we have to call self. animate with Delta time we do not have to do that inside of the entity class what happened there is that we have this this update method inside of the entity class but since we also have an update method inside of the player this update method overwrites this update method we can actually get rid of it entirely it's not needed but if I now run main.py we get a walking animation we are only walking down so not amazing but at the very least we have something to actually have a proper animation we will need another method that I called get uncore State no need for custom parameter in this one and then there we basically want to get the state of the player I.E if the player is going down left right if the player's idle or not things like that and the way this function is going to work is we're going to have a whole bunch of logic and by the end of it we are returning the proper state for example this one could be right and then instead of always having a default value let me select all of them so all of the down values should instead be self. get underscore state with that if I run the code now the player is always walking to the right we could also change this to return right uncore idle then the player is always going to idle in the right direction that is looking pretty good now we just have to figure out the logic to make this get State interactive this get State needs to know in what direction The Entity is moving and that's actually a really good start this self. direction should be inside of the entity class not inside of the player let me add another section in there for the movement there we have self. direction also while we are here at the moment for the player we have a generic number for the speed this should be an attribute that we are going to store inside of the parent class self. speeed which can be 200 and 50 this self. speed we actually want to use for this move method that just feels a bit cleaner after that we have to figure out the logic for the get State method and the first issue we have to address here is that we only want to update the state if the player is moving which we can do by creating a local variable moving that is going to be the Boolean value of self. Direction the reason why this is necessary imagine that our player is moving and we are currently moving to the right and then we are stopping if that is the case we do not want to play the animation anymore but we still want the player to look to the right which means we want to store the last thing the player has done when he was moving and then use that information when the player is idling which we can do by only updating the movement Direction when the player is moving so when the player stops moving and we have been moving to the right then the player is still going to face to the right when we are idling I hope that makes sense I suppose to do this a bit more practically inside of the graphics I want to create another attribute self. facing underscore Direction by default this one could be down this is the value we actually want to update for example inside of get State we want to return an F string where the first value is always going to be the direction or self. facing direction to be a bit more precise but after that we want to add another value which is going to be empty if we are moving that way we would simply get down left right or up which is going to be the walking animation however if we're not moving so else then we want to add underscore idle that way if I run main. Pi we are currently not moving so the player is idling but if I start moving we are getting to walk in animation now this at the moment only works in a single Direction so not great but we are making progress what we now want to do is to check if the player is moving then we can check if self. direction dox is different from zero if that is the case we know we are moving on the horizontal axis which means self. direction is going to be right if we are moving to the right I.E if self. direction dox is greater than zero if that is not the case else we know we are moving left that we can already try if I now Run the game and I move to the right we are getting an error that the string object has no attribute X and I think I can see the issue so the error happened on this line but the actual problem happens on the next one because on this line we are overwriting self Direction which is supposed to be a vector where we get X and Y but we are now assigning a string to it either left or right this is simply a typo I meant to update self. facing Direction now this should be working if I move to the right or to the left we get the walking animation for that state so that's looking pretty good however down and up don't work yet that we can fix quite easily by simply duplicating this if St statement and check if self. Direction doy is different from zero it is going to be down if self. Direction doy is greater than zero and if that's not the case we are going up and now I can walk around and we are getting the proper animation for each Direction so that is looking pretty good that means we can minimize both of these methods and then we can start working on the other character s for that if you look at tiled we don't need the coast anymore and we only really care about the entities so let me hide everything else basically we have in the Overworld a whole bunch of markers some of these markers are going to be just for the player you can identify all of those via the name if the name is player we don't really care about them for this part we only care about the markers with the name character for those we also get a graphic Like Straw for example and this graphic is simply the file name for example straw would be this character on top of that we're getting a direction and this will be the starting direction of this character we have all the information we need to create a character so this is going to be your exercise create a new class for all of the characters and then display them via this class inside of the game with the correct start facing Direction the one that you're getting from til pause the video now and see how how you get first of all inside of entities. Pi I want to create another class called character which needs to inherit from The Entity class then we will need a thunder in it method self a position frames and groups later on we will also add the facing Direction in there but let's keep it focused for now next up we have to initialize the parent class with super thunder in nich and pass through the position frames and the groups now at this point we don't need to animate the characters meaning there's no need for an update method which makes our life a bit easier meaning next up inside of main.py inside of the setup method we want to look at all of the character markers we are already isolating the player if we add an else statement then we can print objname and let's see what we get we are getting mostly characters but there are some players in there that is because for this if statement we have two conditions which is not ideal let me take the second condition cut it out and then add an inner if statement we only want to create a player if obj name is player and we are on this starting position after that we can indent self the player one more time and now if we run this we are only getting characters that looks pretty good so now we can create an actual instance of the character class although for that first of all all the way at the top from entities we want to import the character and the character class next up for each character we're going to need a position frames and groups now these arguments are going to be fairly similar compared to what we are doing with the player hence we can literally copy all of the named arguments from the player so I have to write just a little bit less there we go now we have a character class with position frames and groups this is actually already going to work if I run the code we can see there's one NPC and if I go a bit further down here there we have another one there's one more and that's a good start but the graphic isn't right that is because we are always using the player graphic from the Overworld frames for this one I want to get obj do properties and then get a graphic let's thr off this again and now this is working much better we're getting a whole range of different characters so I am quite happy with that cool the last thing that we have to figure out is the start facing direction for each entity at the moment this one is always going to be downwards but that we want to customize via another parameter let's call it facing Direction and this value we are assigning to the self. facing Direction attribute that means when we are creating the characters and a player we have to add one more argument facing Direction which we are getting when we are creating this class so for the dunder init method for both of these classes we will need a another a parameter facing Direction once we have that we can work inside of main. Pi and to both of those class Constructors we want to add facing underscore direction if we set this one to right we should always have a right starting Direction so that is working pretty well cool to make this Mo interactive let's have a look at til in there when you look at the markers for the characters you can see that we have a direction this one for example should Face Down by default this one should face left by default and so on we got a few more this one for example faces up and then for all of the player starting markers we also have a direction which we can use this one would be down then we have one here for down as well and I think all of the markers in the Overworld are down but if you look at the hospital or the marker for the player the direction is going to be right although this this one should actually be up anyway you get the idea back inside of the code for the player we are currently working with a marker that's our object and on this one we can get obj do properties along with the direction the same thing we want to do for all of the characters it's actually the same property if I now run this again the player looks down by default this character looks to the left this character looks down and this character also looks down and if we go a bit further up then we should see a character looking up as well this one here and that is working pretty good cool so with that we have a pretty good start to all of the characters they don't do anything at the moment and we have no collisions but at the very least we are making some pretty solid progress so at this point we do have a basic level but there are a couple of things that could be improved and that is what we are going to work on in this section number one we are going to add all of the grass tiles those we are later going to use from Monster encounters but for now they're simply part of the Overworld number two is going to be a better drawing order that way we don't have trees on top of houses or the player below the water anymore and finally we're going to add collisions which is going to make the game feel significantly more realistic that should be fairly straightforward let's get started with the first point the monster grass patches for that we have to first of all look at til here we are and at the moment we only have the terrain visible on top of that we have a layer called monsters if you make this one visible we have a whole bunch of grass tiles also if you look at the top left there we have a few ice grass tiles also what is very easy to miss if you look at the beach and select this section there we have a bunch of beach tiles those are not going to be visible but we can use them to control where monster encounters happens when the players on the beach sadly there's no grass on the beach available but anyway if you look at one of these grass tiles you can see we have a couple of custom properties the biome the monster level and the Monsters available although for now this isn't really information that we care about we simply want to have the graphic that we can use inside of the code I want to work in the setup method and in there we can create below objects although the actual position is not going to matter in just a bit I want to add the grass patches for that we will need a for Loop for opj and TMX map doget layer by name the layer we want to look at is called Monster and I suppose for now we can simply create a Sprite for which we are going to need let me copy the parameters a position surface and groups position is super easy we have obj dox and obj doy for the surface we want to get obj do image and for the groups self. all Sprites if I now run main. Pi we are getting an error because this layer is called monsters if I now run the code you can see that we have the grass patches so that is looking pretty good and if you go all the way to the top left there should also be the ice grass patches there we go that is looking pretty good so we are making progress but it's still not ideal because there should be some overlaps and that is going to bring us very nicely to the next part that would be the drawing order so for example if you look at these two trees right next to the player the drawing order here is a bit messed up because the shadow of this tree is on top of this other tree the same same happens to this tree as well and if you walk a bit more around you can see that this is a very common problem you can see it here as well you can see it here in particular because the player is below the water and finally with the houses it becomes incredibly noticeable so on there the tree is on top of the house and the issue here is that at the moment we are sorting all of the Sprites by the time of their creation I.E the stuff that we are doing in the setup method which is not a reliable solution at all what is going to be a much better approach is to give each Sprite a layer and then when we display the game we are going layer by layer or in other words what we are going to do is we are first going to draw the water then we're going to draw the backgrounds and then we're going to draw the characters with all of the other objects like the houses and the trees now this system isn't terribly difficult to implement but there are going to be two complications number one is that each character should have a shadow and this we have to incorporate with the layout approach to drawing besides that there's one object that should always be on top of everything else and that is the top bit of the pillars or in other words if I run the game again and I go down a bit this pillar thingy here should always be on top of the player that way we can walk below it and it looks like there's a bit of threedimensional depth in the game so how can we start approaching this kind of problem and first of all if you look at settings there we have a dictionary code World layers this is going to define the drawing order I.E we're going to draw water first then we're drawing the background then we are drawing the Shadows then Main and then top because of that since water is drawn first everything else will always be drawn on top of it so what we need to get started is to tell each Sprite what layer it is on and for that inside of Sprites I want to give every single Sprite a z parameter which is going to get a default value we want to get the dictionary World layers the one I just talked about this one and by default a Sprite should be on the main layer so dictionary indexing and Main this value we now have to store as an attribute self. Z is going to be Z after that we also have to update the animated Sprite and for that I can duplicate the parameter and don't forget to pass it through to the parent class so we want to add Z in there as well with that we can store the Z parameter that means inside of the setup method we have to actually pass in that information when we are creating the terrain we want to have worldcore layers and those will always be BG our after that we can work with the water and with the coast because for those we have World layers and water and then we have for the coast World layers and BG and I realized while recording you could combine the water layer and the BG layer since they're both simply going to be in the background it's not going to make a massive difference but in practice this isn't going to make a difference although what I do want to do is to copy all of these lines and then move them up just a bit so we have the terrain the water and the coast all in one place like so you don't have to do that but it just feels cleaner all righty next up we have to cover the objects the grass patches and the entities and while we are here I realized the character objects do not have a z parameter this we have to fix right away and each entity should have a z parameter I suppose we can put it all the way at the top self do Z and this one is really easy because an entity should always be on the main layer World layers and we want to go with main no need for a parameter for this one that way we have finished the entities as well and the grass patches we don't have to touch those will always be on the main layer as well the one thing that we do have to care about is the object objects because for those we have to be a bit careful to understand why let's have a look at til and I want to look at all of the objects so in there we have a whole bunch of trees and houses and then random objects like the rocks and those pillars and the top thingy now basically all of the objects should be on the main layer with one exception and that is this top part this one should always be on top of everything else that way the player can walk below it and this object we can identify by its name it is called name top and this is unique no other object has any name which means inside of this for Loop for the objects we can add an if statement if obj dotame is equal to top if that is the case we want to create a Sprite that has all of the same arguments that we have used before so let me copy them and then add World layers with the layer at top however if that is not the case else then I want to create the Sprite we have already created later on for the collisions we have to add a bit more logic in here hence I do want to have a proper if statement anyway let's try and the game is still running as before but we do not have any update to the drawing method because so far we only added a single attribute it's not actually used yet for that we have to look at the groups because in here we are drawing everything this is the part that we have to refine and essentially I want to create three lists of Sprites I want to have the BG Sprites I want to have the main Sprites and I want to have FG Sprites after we have that inside of the for Loop for the actual drawing we're going to go through all of these lists and then draw them one by one I.E we're going to first draw all of the background Sprites then the main Sprites and then the FG Sprites because of that the FG Sprites will always be on top of everything and the main Sprites will be on top of the background Sprites for the background Sprites I want to use list comprehension with Sprite for sprite inself that way we are simply going to copy all of the Sprites inside of the class but there's going to be a condition I only want to get a Sprite if Sprite doz is smaller than worldcore layers and Main i e I want to get all of the background Sprites that come before the main layer we can do the same thing for the main Sprites because in there we simply want to check if we are on the main layer and finally for the FG Sprites we want to check if we are greater than the main layer that we can now use with another four loop I want to have four layer in the tupal BG Sprites main Sprites and FG Sprites and the order here is really important BG Sprites has to come first then we have main Sprites and then we have FG Sprites the for Loop is going to go through those in order and this is really important for our purposes once we have that we want to go through every Sprite inside of the layer and for that we already have have this for Loop we simply have to indent it remove the white space that should be all we need to get started if I now fix the extra character here and run main. Pi you can see that so far not much has changed however if I go a bit further down the player should at very least be below this part and that is working really well also if I now walk over the water the player is always going to be on top so that is working pretty pretty well we are definitely making progress and I hope the logic for all of this makes sense ultimately we are simply splitting up all of the Sprites into three separate groups and then draw the groups in order but we are not entirely done yet if I run the game again we still have this kind of issue where for example the trees are on top of the house this issue here that happens because this tree this tree and this house are all on the same layer meaning we still have the same issue that they are being drawn by the time of their creation it simply happens to be that this house was created first and then we created those two trees which means when we are creating the main Sprites layer we want to sort them in a different way which we can do with the python sorted method we just have to figure out a specific e to sort and by and let me talk about the logic here really quick imagine we have two characters although it could be any two objects for those we want to have a criteria to figure out which character should be drawn on top and which one should be drawn in the background and usually the best approach is to Simply use the vertical position we have the vertical center for the player and for the other character you put some actual numbers on this let's say the player centery is a 100 and for the other character it is 120 all we really have to do is to look at the largest number I.E the character has a greater white position so it should be drawn on top of the player that's literally all we have to do that way the further down an object is the later it is going to be drawn inside of python the key we want to assign is a Lambda function with one parameter that I usually call Sprite or and by the way what is going to happen in here the sorted method wants to have a list that we already have it will then go through every single element of this list and pass that element into this Lambda function or whatever function you specify from that Lambda function it is then expecting some kind of return value ideally some kind of integer all of those integers are then stored in the list and this list will be sorted from the lowest all the way to the highest value or in other words what we want to do this Lambda function is going to get a Sprite whatever Sprite we getting from the list and the value that we want to get from the Sprite is sprite. rec. Center y bya that system we are extracting all of the vertical Center points and then sorting them from the lowest to the highest value and well that's literally all we need for this part if I now run main. Pi again you can see that the trees look significantly better and if the player walks through the house at some point the player disappears and with that we have a much better looking game this feels drastically better also you can see with the grass patches they are starting to come together but we do have to refine things just a bit because something like this shouldn't happen in the game now to fix that we want to work inside of the Sprite class in there I will add another parameter self underscore let's call it y sort for now this can simply be self. re. Center y that way when we are sorting all of these Sprites we don't need sprite. rec. Center y instead we can simply get sprite. Yore sort although once again I forgot that we have to do the same thing for the entities I.E below self. z i also want to have self. Yore sort which is going to be self. re. Center y if I now run may not Pi we are getting an error that happens because when we are running this y sword erect does not exist yet we only create this one down there so I guess we have to move y sword all the way to the bottom with that I can run all of this again and now we are getting something weird the player is always on top of these Sprites but he will always be below all of the others so what happened here y sword is not being updated and when the player is moving around y sword is always going to remain the same that way the player sorting doesn't really work but for that for the player when we are updating everything first of all we can update self. y sword if I now run of this again the player should integrate much better and that is looking good also if we're now walking over the grass this is working perfectly fine again all righty so with that we haven't really achieved very much the game still looks the same but what we are able to do now is to customize this y sword or in other words we have a bit more control over what kind of sorting Behavior we have for example if you reduce the center Y for the Sprite by by 40 and run m. Pi again now this grass is going to overlap with the player much much faster which is going to look a lot better now for the other objects this is going to look a little bit weird but we are making some progress basically what we are going to do I want to have one kind of drawing Logic for the grass and then another drawing Logic for everything else and by drawing logic I simply mean mean that we have a different offset for the Y sword and for that I have actually created a whole another class although for now this isn't going to be the most useful part I want to have a monster patch Sprite Which has the Sprite as the parent which means in there we will need position surface groups and z and we don't need Z in the dund ended method of the class itself with that we can pass position surface and groups right through and Z at least for now is going to be World layers and Main and only in there do we want to update self.y sort and we simply want to reduce it by 40 pixels we don't need to do that in the original anymore and now inside of main. Pi when we are creating the grass I don't want to create a Sprite I want to create a monster patch Sprite although this we have to first of all import all the way at the top I want to import Sprite animated Sprite and monster patch Sprite let's try this one now and the grass is still looking much better but if I look at the other objects there the player disappears once we are behind the object and once we have collisions that is also going to look much better cool so with that we we have quite a nice overlapping Behavior there's just one issue we do have to work on and that is here we have the sand monster Sprites overlapping with the player and this shouldn't happen those tiles should always be behind the player that is an easy part to fix inside of Sprites dop when we are setting the Z layer for the monster patch Sprite it should only be main if we are on grass or ice grass if we are in the sand it should always be in the background now for that we have to know what kind of monster patch we have or in other words inside of til if we're looking at the monster layer again we want to look at the biome because in there we have have a forest we have sand or if you look all the way in the top left we have ice which means if we are on the sand layer we want to change the layer for the drawing now for that we will need to know the biome that will happen inside of main. pipe when we are creating all of the grass patches in there I want to get obj do properties and then the biome property with that inside of Sprites after groups I want to have a biome and for now let's simply print what we get so if I run m.p again we are getting sand ice and Forest and that is looking pretty good that information we want to store right away so self. biome is going to be biome that will become important later on although for now I simply want to update the world layers this one should be main if biome is different from Sand and if that is not the case then we want to have the BG layer let's run main notp again the game doesn't crash the overlapping still works but now there should not be any visible sand patches here anymore and there aren't so this is working perfectly well cool so with that we have the drawing logic that is going to work much better and ultimately the only really important part is inside of the groups because in there we are separating the Sprites via the world layer and then we are drawing the layers one by one that part alone will make the game feel significantly nicer that nearly finishes this part there's just one more thing that I would like to add and that is a shadow below all of the characters something like this a shadow below all of them now this Shadow needs to follow all of the characters in fact it needs to be in the same place and also it needs to respect the drawing order or in other words it has to be on top of all of the BG Sprites but below the main Sprites because in there we have all of the characters but let's go through it step by step first of all we will need an import and since the graphic is fairly simple we can do it right away and by the way what we want to import is inside of Graphics there we have I believe it's an other we have a shadow that is what we want to import let's save it as the attribute self. shadowcore surface and this we are going to import via support and import image which means from support I want to import import image then we are going to need a file path I want to go up a folder Graphics then I want to go to other and finally we have Shadow let's try to run main.py and the game is not crashing so the UT is working cool next up when we are drawing the entirety of the game we want to draw a shadow before we are drawing any of the entities I.E before we are drawing a player or a character the easiest way I think to approach this problem is inside of this for Loop to check if we have an entity and if that is the case before we are drawing the actual Sprite we're going to draw a shadow for that we have to do one more import I want from enti import entity or in other words I want to import this class that allows me before we are blitting the image to check if is instance the Sprite and the entity class if that is the case then we know the Sprite that we are currently getting from the for Loop is an entity which means it would be this entity it could be a character or it could be a player since character and player inherit from entity they would also fall into this is instance and if that is the case I want to get self. display surface and then blit self. Shadow surface after that we are just going to need the position let's go with sprite. re. toop left plus self. offset basically the same thing we have done right below if I now run main. Pi we are getting an error because inside of groups this shouldn't be entity this should be entities let's try it again and there we go now we have a shadow below all of the entities let's have a look at another one there we go so this is working but the shadow is in the wrong position now to fix the shadow we could do a couple of things we could create a rectangle around the shadow surface and then place the center or to keep things a bit more simple we could add another vector door 2 with a certain position I found that the numbers 40 and 110 work really well if I now run myp again the shadow is right below where it's supposed to be and that is working pretty well and now the game just feels a lot better and all of the other characters are also looking really good perfect so with that we have finally covered the entirety of the drawing order which means now we can work on the collisions and before we start working on the actual logic we need to do a bit of groundwork number one the player can collide with other characters the objects I.E houses and trees and rocks and with Collision rectangles those we are getting from tiled now the last part I do have to explain and let's do that in tiled right away here we are inside of tiles and at the moment we have the object layer and the entities layer don't those are what really matters at the moment and when it comes to Collision I think there are some fairly easy parts for example we want to have a collision with the tree we want to have a collision with the house or generally any kind of object we want to have a collision with on top of that if there is a character like the one here we want to have another collision with that one as well all of those are going to be fairly simple because they have a simple area that we can work with however what is going to be a bit more complicated are these Cliffy areas all of this stuff here because those don't really have a regular shape we could have one area here then we have another one here we have a weird one here all of those are kind of annoying to work with as a consequence to make our life a bit easier I created another layer that is called collisions and this one is full of let me isolate it it is full of of very small areas all of those are also going to be collidable and if you combine it with the terrain you can see that those collisions are basically there for all of the walls and the cliffs and things like that could also be a safety area like this one so the player cannot exit the window those are the three kinds of object that the player can collide with on top of that I want to have a Custom Collision size so at the moment this is our player and the rectangle around the player looks like this it is quite large since we imported the player via a tile set which I should probably explain here we have the graphics folder again and in there we have the characters with the player although this applies to all of the characters we are importing all of this and then we are cutting out one part for the player this would be the rectangle of the player which as you can see is quite large which for collisions is going to look really weird so what would be much better is a smaller rectangle for the hitbox that doesn't even cover the entirety of the player that way since we have an overlap these parts and these parts are going to give additional depth to the game which looks really good you're going to see in a second what that means in detail but first of all we have to get all of our areas I we have to get the player hitbox and the character hit boxes in general and then all of the collidable areas and I suppose we could start with the entities for all of those I want to create another attribute self. hitbox which is going to get self. wct do inflate and in case you don't know all that the inflate method does is it takes a rectangle and then expands it or shrinks it and all of that happens around a center point for example in my case I want to get Negative self. rec. wift divided by two this would be the horizontal size change and for the vertical one I want to go with 60 what is happening here is we are taking the original rectangle which would look something like this and then via the inflate method we are looking at the center point and then we are creating a new rectangle from these numbers for example self. rec. WID and this is negative really important so we are shrinking the new rectangle in this case we are getting half of the width of the original rectangle so the new rectangle would have a width of something like this and then on the vertical axis we have 60 so we are removing 30 pixels at the bottom and 30 pixels at the top at the end we have a rectangle that looks something like this and this rectangle is what we actually want to use for the collisions for that since the characters are not moving we can ignore them for now but for the player we have to make sure that when we are moving the player we are also updating the hitbox otherwise the hitbox would always remain in the starting position of the player which would obviously look very silly now luckily that part is fairly simple we simply want to get self. hitbox and place this Center to where ever self. w. Center happens to be and that is all we need for now if I now try to run main. Pi again the game doesn't crash that's a good sign but we can't really see the hitbox and I suppose that's okay for now we are going to make all of this a lot more visual in just a second first of all though we have to get all of the collidable objects those I want to store in another Sprite group I usually call this one self. Collision uncore Sprites and this one can just be a normal pygame dos sprite. group it is just there to identify all of the collidable Sprites so it doesn't have to actually do anything speaking of which when we are setting up the Overworld we have all of these objects the top one we can safely ignore this one is not going to have any Collision however for the Sprite we do want to have a cision because of that this Sprite will be in self. all Sprites and self. collision Sprites besides that the other collidable object is going to be the character meaning for the group or this one we have all Sprites and collision Sprites as well this would give us the objects and the characters that leaves us with the collidable areas those we first of all have to import I suppose the best place would be right below the object but for this one the position really does not matter we want to have the Collision objects as always for obj in TMX map. getet layer by name the layer name we're looking for is called collisions this Sprite that I want to create I called a border Sprite that is going to get a position a surface groups and that's all we need for this one now this border Sprite does not exist at the moment so let's create it by first of all importing it and then inside of Sprites below this Sprite I want to create a class border Sprite Which will inherit from the Sprite class then we need Thunder init with self position surface and groups we also have to initialize the parent plus with super Dunder in it and pass through the position surface and groups now those border Sprites are not going to be visible so the that layer doesn't actually matter we can just keep it with the main one the one really important thing that we have to add to this one is self. hitbox which for the Border Sprite is simply going to be self. w. copy we want to have for the hitbox the same size as the rectangle at least for the Border Sprite however later on when we are placing the objects so all of those we want to have a custom hitbox for the Sprites as well for now I am not going to do that because that way it's a bit easier to see what's going on but what we do want to do is we only want to check collisions between the hitboxes so all of the collidable Sprites will need a hitbox so inside of the Sprite class we also need self. hitbox which for now can be self. rec. hoopy so with that we have all of the hitboxes I think the last thing that we have to do is to actually add proper arguments in here for the position we want to have obj dox and obj doy for the surface we want to create pygame dot surface with obj do WID and obj do height finally for the groups this one is only going to be in self. Collision Sprites and that is really important if this Sprite was inside of all Sprites it would be visible which we really want to avoid as a matter of fact I can actually demonstrate I want to place this Sprite inside of collision Sprites and self do all Sprites on top of that when we are creating this surface there should be Pi game do surface and we have to add a tupal in there as an argument now the game should work and there you can see we have all of the Collision shapes that looks pretty good there we have a few more and those we can work with now obviously those we do not want to see hence Collision Sprites should not be inside of all Sprites rights that way if I run the game we can only see the actual objects so with that we have all of the collidable Sprites and those we have to make accessible inside of the player because only in there are we going to run Collision logic meaning I want to give the player another named argument Collision Sprites is going to be self. Collision Sprites after that inside of entities the players going to need another argument Collision underscore Sprites those we want to store as an attribute self. Collision Sprites is going to be Collision Sprites and now that we have that we can create a method to check collisions for the parameters we will need self and the AIS that we are looking at this could be either horizontal or vertical and before we continue let's talk about Collision Logic for the Collision we are first of all going to split the axis meaning we do first of all the horizontal collisions and then the vertical ones now the order does not matter but separating them is going to make our math a lot easier after we have that we are going to check for overlaps for example if we're doing this on the horizontal axis we have one object that we can collide with and our player so in the the current example we have an overlap on this side which would indicate that we have a collision on the right side of the player or the left side of the obstacle but this doesn't necessarily have to be the case because it could be that the player came from the right side and simply moved really fast the correct answer could also be that the player actually collided on the right side of the obstacle we simply don't know yet so we need one more piece of information which is going to be the direction of the player let's say if the player is currently moving to the right and we have a collision on the right side of the player then we know we are on this side that's kind of all we need to know so in other wordss the direction of the moving object tells us on which side the Collision happened now this is a very easy Collision method to implement it does however have the downside that it only ever works with one moving object which for this game is the case the only object that can move and Collide is going to be the player all of the other characters aren't really going to move or rather when they are moving we're going to block the player so they can never overlap although if you want to learn more about complex Collision behaviors check out this tutorial of mine it goes into much more detail or if you want to do all of this in practice I have also made a Mario Style platformer that is going to do a lot of collision logic anyway in inside of the Collision method we first of all want to go through all of the Sprites for sprite in. Collision Sprites after that we want to check if sprite. hitbox do Collide rectangle remember we only want to check the collision between the hitboxes of all of the Sprites so at the moment we are checking the hitbox of the Sprites and we want to check that against self dot hit box if that is the case we know we have an overlap as a matter of fact we can print that I want to print Collision this we want to call inside of the move method self. collisions we also have to add the axis and this one could for example be horizontal if I now run main. Pi by default nothing is going to happen but if we are overlapping with the house we're getting Collision the same would happen to the tree or any of these objects we always get a collision that is a really good start so now we know that we have an overlap but that's not a collision so basically once we have an overlap we want to resolve that overlap and place the player in the new position and for that we have to go through the logic I just talked about and the first step was to separate the axes which is also going to involve the movement which means in this case we want to update self. re. Center X and to this we want to add self. direction. X multiply it with self. speeed and Delta time after that the hitbox is also going to be updated to only include the horizontal movement and after we are doing that we are covering the horizontal collisions now this at the moment means that we can only move left or right there's no up or down movement which I think for now is okay so we can focus on one Collision axis the way we want to approach this one is inside of this if statement if we have an overlap we want to check if self. direction dox is greater than zero if that is the case we know we are moving to the right which means self. hitbox do WR is going to be sprite. hitbox do left the way you want to think about this one imagine we have the player and the player is moving to the right or in other words self. direction dox is greater than zero this means we're moving right and then we are overlapping with some kind of object that information we are getting from this line if that is the case we basically want to move the right side of the player and move it to the left side of the obstacle that way it looks like the player is stuck on this side and then we have an actual collision and that's literally it although at the moment there's one more thing that we have to do currently we are only updating the hitbox but what is actually displaying the player is the rectangle which means at the end of this line we have to get self. rec. Center X and set it to self. hitbox do Center x with that we should have a collision on the right side and if I move to the right that looks pretty good so we now have one side which means we only have to cover three more and then we also have to give all of the Sprites a smaller hitbox this part is going to be your exercise for this one I want you guys to first of all finish the other three Collision sides and on top of that create another class called collidable Sprite this one should be for all of the collidable objects I.E the trees and the houses and the Rocks this class is going to be basically identical to a Sprite with one major difference and that is that the hitbox should be 100% of the width but only 60% of the height with the same Center Point once we have that we should be done with the collisions so pause the video now and see if you can figure this one out I suppose we should start with the player or more specifically the player movement so that we can move around freely again I want to copy all of this for the horizontal logic and then change it to be vertical this should be self. re. Center y self. direction doy and then Center Y and Center Y and after that we want to do the vertical collisions that means inside of collisions we actually want to check if we have a vertical or a horizontal Collision for that we are going to need another if statement if AIS is equal to horizontal only if that is the case do we want to do all of this and if that is not the case else then we want to do something else let's say pass for now because on the horizontal Collision we have to check if the player is moving left or in other words if self. direction dox is smaller than zero then we want to set self. hitbox do left to sprite. hitbox do right and that is pretty much it next up for the vertical side I want to check if self. Direction doy is greater than zero that means we are moving down and if that is the case self. hitbox do bottom should be sprite. hitbox dotop finally and for this point I can simply duplicate these two lines I want to check if self. Direction doy is smaller than zero meaning we are moving up and if that is the case we want to check the top of the player hitbox and if there's an overlab we want to set it to the bottom of the colliding object and finally we want to update self. rec. Center y to self. hitbox do Center y that should give us proper movement again I can move in all directions and now we have collisions so there is the house there is a tree and we have a hospital we should also try the characters that looks pretty good and cool I am quite happy with that now there is a bit of an issue that I don't really like and that is let me find a single tree this one the collision with the tree happens right here or here on the side or here at the top and I think there is a bit too much of a space between these two objects or in other words the Collision side of the tree looks something like this and for the player the Collision hitbox looks something like this because of that we have just a little bit of overlap right here which which is looking really good and I want to have more of that and to get that we want to reduce the size of the hitbox of the tree to make it something like this in fact for the tree you could even create a smaller horizontal hitbox so you get this part for an overlap as well which is probably going to look really good but that you can do in your own time what I want to do when we are creating the objects that we can collide with all of those I want to create a collidable Sprite that does not exist at the moment so once again we want to from Sprites import the collidable Sprite and then inside of Sprites we have to create that class since it's going to be fairly similar to The Border Sprite let me copy this one and then create a collidable Sprite nearly done the last thing that we have to do is for the rectangle we don't want to create a one toone copy instead we want to use inflate to keep 100% of the width and 60% of the height which means for the width we want to have zero pixels in change but for the height we want to get Negative self. wct do height and multiply it with 0.4 that way we are reducing 40% or 20% at the top and 20% at the bottom and now if I run M do PI let's move back to the tree this one over there now we get quite a bit more overlap I think it's easier to see here now the player is much more behind the tree and I think we could push this even more inside of Sprites let's go with 0.6 and see how good that is going to look so let's try this tree we are quite close to the center but I think it's working fairly well let's try this one and yeah now we get a ton of overlap which is actually looking pretty good and yeah I am quite happy with this one but once again play around with the numbers and just see what looks good on your end either way we have finished another important part although before we finish up there's one more thing that I do want to cover and that is if the player is simply moving left and right we have one kind of speed the same if we are moving up and down however once the player starts moving in the diagonal direction we actually moving quite a bit faster and this is a noticeable change so I think you can see it fairly well the reason why the player is moving faster when we are moving diagonally is because inside of the input this line here we are not normalizing the input vector if our direction is one and zero I.E we are moving to the right if that is the case our speed is just going to be one multiplied by whatever speed we have which is totally fine however if our direction is one and one so we are moving right and down then the actual movement is actually going to be 1.4 multiplied by the speed that we have simply because we are moving on two axes via speed speed and those two add up together the way around that is to normalize the vector that way we are setting the length of the vector always to one all we have to do is to use the normalize method this however if I run the code is not going to work we're going to get an error right away that we cannot normalize a vector of length zero and that should actually make sense if you think about it imagine you are Python and we are telling python that we have an arrow that looks like this or like this we are moving to the right or we are moving down and right all that normalize is going to do is it takes this vector and it sets the length of it to one so if we're going down and right or simply right it is always going to work but now imagine we have a vector with zero and zero this thing doesn't really move in any direction it's simply a point hence python cannot set the length of this thing to a one it's simply not possible it doesn't know which way to go as a consequence we are getting an error now the way around that is fortunately fairly simple we simply want to check if we have an input Vector if this Vector is zero and zero which it is by default then we want to do something else which in our case is going to be the input Vector on its own if I now Run the game again I can move left right up down and if I move diagonally we still get the same speed which feels much more consistent well and with that we have made a whole bunch of progress for the game now we actually have a proper Overworld and the player cannot leave the game anymore oh and also I didn't mention for the beach we have collisions so there's no way for the player to see the black background of the map perfect so at this point we have basically finished the Overworld which means next up we can start working on the dialog tree that way the entire game is starting to become interactive and to get the dialogue system we Broly need two things number one we have to check if dialogue is available in the first place and number two once we have that we need some kind of dialog tree system I'll buy a fairly simple one first of all we have to check if dialogue is available in the first place and this will involve a couple of things first of all we we want to check if the trainer and the player are on the same axis for example if this is the trainer we want to check if the player is roughly on this Axis or on this Axis or in other words if the player is for example here or here or here or here only then should the player be able to talk to this character after we have that we want to make the entities face each other that should be fairly straightforward then we have to block player movement and then we can start the actual dialogue none of this should be too difficult so let's Jump Right In back in the code first of all we have to get access to all of the trainers easily and for that I want to create another Sprite group on the groups I can duplicate the Collision Sprites because besides that I want to have a character sprites Group which like the Collision Sprites doesn't have to do very much it's simply there to get easy access to all of the characters when which means when we are creating all of the characters which happens down here we have to place them in three groups all Sprites Collision Sprites and self. character sprites that's all we need in here next up inside of the Overworld I want to check input as well at the moment the only input that we have is inside of the player class to move the player itself but I also want in the actual main game class have an input method let's place it right above run I want to check for input no need for custom parameters on this one and just as before I want to get all of the keys which we are getting with pame dokey doget rest and the key I care about is keys and pame Dot aore space and if I spell this correctly this could also work much better now if the player presses the space button I want to print for now dialogue now don't forget to run this method that is going to happen before we are doing anything else self. input now if I run all of this we getting an error because this should be key and Dot get pressed if I now press space we getting dialogue that means input is working but it's not working as intense it because even though I only pressed space once we got dialogue a few hundred times that is because of the frame rate all that py game really checks is if this button is pressed and then it prints dialogue and this happens on every frame of the game in our case our frame rate is probably around 2 to 300 meaning this method runs way too often and we getting way too much output if we had actual dialogue and we press space then we would skip dialogue 200 times so that's not ideal and there are broadly two ways to get around this number one you could create a timer that after Keys was pressed we have to wait let's say half a second to press the button again could be implemented and later on we are going to do something like that but for now an easier way of solving this is get just pressed if I now Run the game and I press space we only ever get a single dialogue output essentially get just pressed is only going to return newly pressed Keys which for any kind of UI work is incredibly useful so that is what I'm going to use also get just pressed is a pame c feature if you're using traditional py game you would get an error at this point so do be careful and make sure you have the most recent version of py game anyway after the play has pressed space we want to check if we are close to one of the characters for that we will need four character in self. character sprites this would give us all of the characters and basically what we want to do is we want to check the connection now this check connection is going to involve two parts imagine this is the trainer and this is the player first of all what we want to check is the distance between the two I.E if the player is within a certain radius of the character these two entities should only be able to interact if they are close enough should be fairly straightforward and on top of that we want to check if they are roughly on the same axis I.E if the player is either roughly here let's say with a margin of error or on this axis now this kind of check connection we are going to reuse a couple of times meaning I will keep this as a function and then actually keep it inside of support So in there let me minimize everything and all the way at the bottom I want to have some game functions while all the other stuff is import functions which means in here I want to have a function check uncore connections the same function we are using here and in there I want to have three arguments the radius the player and the character radius for this is always going to be 100 and player is going to be self. player after that inside of support we want to have a radius we need an entity and we will need a Target also we can set a tolerance that by default is going to be 30 pixels inside of this function first of all I want to get the relationship between the entity and the target which we can do via vectors very easily I want to get the vector of target. rect do Center and from that that subtract the vector of entity. rect do Center if this is our current entity and we have a Target their relation would be an arrow pointing from the center of one to the center of the other like this which is already really useful because on this thing we can get the length and then check how far apart these two entities are which we actually are going to do right now I want to check if relation do length is smaller than the radius if that is the case for now I want to return through and if we don't return anything this function is going to return none which is going to be falsy hence we only need a single return value now with that inside of main. Pi we can check if these two entities are nearby and if that's the case only then do I want to allow the dialogue output meaning now if I run all of this again I press space and we are getting an error because this should be check connections let's try it again if I press space nothing happens but if I get close to this character I can press space and we are getting dialogue I can move away if I press space nothing happens but if I get to this other character I can press space and we are getting dialogue once again so this is working really well that means next up we can work on the second part where we are checking if the player and the character are on the same horizontal or vertical axis now to understand how this is going to work imagine once again we have the player and we have the target with an arrow between the centers of these two ultimately all that we really have to check to for example test if those two are on the same horizontal axis we simply need to know the height of this line if it is below 30 then we know it is inside of the tolerance although we do have to be careful because below 30 could be any negative number which means what we actually want to check is the absolute value of relation doy if that value is below the tolerance only then do we want to return true with that I can run main. Pi I can press space nothing happens if I am on the left side of the character we are getting dialogue but if I go on top I can press space and nothing is going to happen because of the collisions this is a bit hard to see let me try another character this one so at the moment I'm on top of the character I can press space nothing is going to happen but if I am on the side we're getting dialogue so the system is working so this is kind of working but at the moment it looks a bit weird because the player is facing downwards and what I would rather want to check is if the player is is on the same horizontal axxis and if the player is facing the opponent only if those conditions are met as well then I want to allow dialogue now we do know which direction the player is facing that we are getting from get State we have a facing Direction this we want to use again which means what we actually want to check is first of all if entity dot facing underscore direction if that is for example left then we know the player is facing left on top of that we want to check relation dox is smaller than zero that way we know the player is facing to the left and we are to the right of the opponent and then finally we are also on the same horizontal plane only if these three conditions are met then I want to allow dialogue so at the moment we should only be able to talk to an opponent if we are on the left side and if we are facing that character so for this one there's no way to talk to her at the moment but if I go to the other character and I'm on the right side and I'm facing left I am getting a dialogue but if I am on any other side it doesn't work and if I'm facing the wrong way we also do not get a dialogue but if I'm facing her and the other conditions are met then we are getting a working system system cool so with that we have one side this we just have to expand a bit to cover the other sides as well for that I can actually just copy all of this because we only have to change a few things for the second line I want to check if we are facing right then we want to check if we are currently on the left side of the opponent and we still want to check if we are on the same horizontal plane that's the next part after that we have to do up and down I want to check if we are let's start with facing up then we want to check if relation doy is smaller than zero and we want to check if relation. x the absolute value is smaller than the tolerance nearly done the last thing that we have to cover is going to be if the player is facing down relation doy is greater than zero and the tolerance part is still just fine that should actually be all we need so we don't need the or at the end anymore and for once let's try a different character this one I can talk to him from this side from this side from this side and from this side but if I face another way or I am diagonally compared to him we are not getting a dialog so that system is looking to be working pretty good cool that also covers the check connections function we are going to reuse it later on but for now this is all we need from this one we want to block ler input after that we want to make the entities face each other and then finally we can create the dialogue to go through it step by step let's start with blocking the player input for that we have to work inside of the entities and let me minimize all of this so it's a bit easier to see inside of the entity under movement I want to add another parameter self. locked which by default is going to be false on top of that I'm going to create two more methods Define block with self which is going to set self. blocked to through and on top of that self. direction is going to become a vector with zero and zero that is definitely going to stop player on top of that I want another method unblock with self and all that this one is going to do is self. blocked is going to be false with those attributes in place I can look at the player input essentially what we want to do if the player is blocked we don't want to allow any input and we also do not want to allow anything inside of the move method which means inside of update these two methods should only run if not self. blocked I suppose we could put animate in there as well it's not really going to make a difference with that we can go back to main.py and then if there's a connection self. player. block let's try and if I talk to this character the player cannot move anymore although you do get some weird Behavior we simply stopped mid animation so actually I was wrong this animate does care about being inside of self do blocked if we take it out of it and try all of this again now we are getting the player blocked and we also getting back to the default State let's try this one again just to make sure it wasn't an accident with that we can block the player next up we want to make the enti face each other or in other words if the player talks to this Buck catcher the buck catcher should start facing the player for that we want to get the character and then call a function change underscore facing uncore direction for which we will need a Target position which will be self. player. rec. center now this method doesn't exist right now and we want to create it inside of the entity class it is going to be used both for the player and for the characters let's place it right below get State Define change facing Direction with self and a Target position like we have done with check connections we first of all want to get the relation between the Target and the current character the same thing we have done here I can actually just copy the line although we do have to update it because now the tar Target is going to be the target position and instead of entity. rec. Center we want to have self. re. center after that we want to check if they are on the same horizontal plane if absolute relation doy is smaller than 30 if that is the case we have to decide if we're going to face right or left in either case we want to update facing Direction and let's say by default we are going to go with right that should already work at least for One Direction if I now talk to this guy nothing is going to happen that is because this change. facing direction is being called but inside of the character simply nothing is going to happen the character never updates so it doesn't really matter what this attribute is doing it's not being used inside of the character all we need to fix that is Define update with self and Delta time and proper spelling and then call self. animate with Delta time the character already has the animate method because this one is part of the entity class if I now try this again we should be seeing an update and there we go this is working really well so next up let's finish up this method we only want this character to face right if the player is to the right of it or in other words if relation dox is greater than zero if that is not the case else it should be left after that we want to check if the player is on another plane I.E on the vertical one if that is the case self. facing direction is going to be let's say down by default if relation do y is greater than zero if that is not the case else it should be f facing up and with that let's try another character and make her face down that is working well and one more attempt let's try the character down here and she is facing up so that seems to be working just fine cool so finally we can start working on the actual dialogue which we want to initiate with create dialog a method we have to create let's do it right below Define create dialogue for the parameters we want to have self and the character which means when we are calling this create method we have to pass in the character that we currently have after that we want to create a dialogue tree class that is going to get the character it is going to get self. player it will need self. Sprites so we can show things and then it is also going to need a font now the font we don't have at the moment and that's the easiest part to fix after we have that we can create the actual class but let's first of all import some fonts that is going to happen inside of import Assets in there I want to have another dictionary self. FS now later on we are going to have quite a few key value pairs for now though I only want to have one for the dialogue which we create with py game. font do font then we will need the join method for the path and I want to go up a folder then I want to go to Graphics in there we have a folder called fonts and in there we have a file called pixel lloy ss. ttf for the font size I want to go with 30 now if I run the game we are not getting an error message so that is looking really good with that we have a font and that we want to paste into the dialogue tree right away which we do with self. fonts and we want to have the dialogue font next up we have to actually create this dialogue tree for that I want to create a new python file that I saved as dialog dopy as always we will need from settings and we want to import everything after that we can create a class called dialogue tree no need for inheritance and then inside of the dunder init method we have to cover all of the arguments I just talked about these ones here we want to have a character we want to have the player we want to have all Sprites and then we want to have let's call this one simply the font all of those need to become attributes so self. player is going to be player self do character will become the character self. font will become the font and self. all Sprites will be all Sprites with that the game is not going to crash anymore once we are talking to a character but fundamentally we're not really doing anything so how can we actually display some text for each of the characters well first of all for that we have to get some data and for that we need to import a file I haven't really talked about yet that one is called game data which is a massive dictionary so let me hide everything for now we only want to look at trainer data and this is a giant dictionary with the data for all of the trainers in the game and if we look at the first one 01 stands for Overworld one in fact if you look at all of the entities inside of the Overworld I believe the first character is this one yeah this one is called 01 or in other words via the character id we're going to associate this marker in the tile map with this entry inside of trainer data now in there we have quite a bit of information we have the monsters of this character we have the dialogue options we have the looking around directions and if the player looks around I.E if this character is looking out for the player then we're checking if this player was defeated and what biome he is in that could be Forest sand or a bit further down we have ice as well like this one now that is quite a bit of data and I suppose before we continue we have to get this data into the character class I.E inside of entities we have to get all of the data into this thing here for that I want to create another parameter character data for now I suppose let's simply print what we are getting after that inside of main.py when we are setting up the entirety of the Overworld inside of the characters we will need another named argument character data now the value from this one we are getting from game data this one and there we have trainer data although I suppose a better name would be character data but I guess both work just fine and from this dictionary we want to pick one item which we're getting via obj do properties the property we want to look at is called character uncore id or in other words this character id I just talked about if I now Run the game we are getting trainer data is not defined that's an easy thing to fix all the way at the top we need from gamecore data import everything now let's try this again and there we go we are getting the data for all of the trainers for example for the first trainer we have monsters then we have the dialogue options they start here we have directions defeated biome and so on that looks really good this character data we do want to store as an attribute self. character data is going to be character data on top of that I want to create a method for get dialogue no need for custom parameters and then we want to return the data for this character although this could be one of two options if you look at game data for example trainer 01 has a dialogue option for default and for defeated we want to get the right option depending on the character being defeated or not which means we want to return self. character data and the dialogue but then we want to create an F string which is going to be the defeated if self. character data is indeed defeated if that is not the case so else then we want to get default inside of game data we are simply checking if this value is true or false oh and by the way it's really important to keep all of the data inside of this dictionary I.E later on once the character is defeated this value changes we do not keep that data inside of this class that is important later on because when the player changes the map for example to go from an arena back to the Overworld then we are going to recreate this class and any attribute would be reset so we cannot keep data in here it wouldn't be persistent anyway with that we have get dialogue this we can use inside of the dialogue because in there we have the character so we can print character and get under score dialogue let's try this one if I now talk to the blonde girl we are getting an error that dialog tree is not defined that is quite fixable I want from dialogue import dialogue three let's try this again and if I talk to her one more time we're getting one more error that we are taking four positional arguments but five were given that is because I forgot self in there next attempt and there we go we are getting an actual dialogue output and I realized I was really bad with consistent quotation marks but doesn't really matter I suppose we should try another character this one here and this one also has a dialogue that looks pretty good cool next up instead of Simply printing the dialogue I want to store it as an attribute self. dialogue I suppose works on top of that I also want to have self. dialog number which is simply going to be the length of self. dialogue and finally I want to have self. dialog index which by default is always going to be zero once we have all of that I want to create self. Curren uncore dialogue which is going to be a dialogue Sprite this one doesn't exist just yet but we are going to create it in just a second for that we want to have a message we want to have the trainer we want to have groups and we want to have a font this dialog Sprite is what will actually display the message let's create it right away plus dialog Sprite Which has to have a parent of pygame Dos sprite. Sprite there we want to initialize the class with the message we want to display the trainer the groups and the font with that we can add actual arguments into this class for the message I want to have self. dialogue and then pick one of the options with self. dialog index trainer is quite easy this one should be self. character and I suppose I should always call this character groups is super easy this one is simply going to be self. all Sprites and for the font we want to have self. font we only have a single one inside of the dialogue Sprite then first of all we want to have super Dunder init and initialize the groups we will also need self. Z which is going to be World underscore layers and these Brides should always be on top after that we have to create the actual text I want to have a text underscore surface which we create with self. font. render we want to render the message nlas should be fults and the colors we're getting from settings in there we have a colors dictionary which means inside of dialogue I want to get colors and for this one I want to have a black color so that would give us the text surface but what we actually need is self. image I suppose for now we can simply set the text surface to the image just so we have something but this we do have to change anyway next up we want to create self. rectangle which will be self. image. getorf rectangle where we are placing the mid bottom to character do rect do mid up and we could add a bit of an offset let's say Vector 0 and 10 that should give us something if I now run main. pi and I talk to the girl we are getting an error message that we do not have a font that is because this font is not an attribute let's try this again and there we go I don't like sand we are getting one dialogue output now unfortunately it doesn't look particularly good for that inside of dialogue we have to work more with the Sprite the problem that we have to fix is that the image is simply going to be a text surface hence we have no background whatsoever after we are creating the text surface I want to set the width and the height of the background both of those should be basically the Tex surface and then we add some padding to it that padding by the way should probably be a local variable padding and I went with five pixels but simply choose what you like the most for the WID we want to get the text surface and then get underscore WID this would give us the width of the text surface this we want to increase by self. padding multiplied by two I.E this is our text and we want to have padding to the left and to the right and we're multiplying padding with two now there's one more thing that I do want to do and that is to set a minimum width which I'm doing with Max and then 30 that way our width is either 30 pixels or the text width that's the padding which every one is larger that way even if we don't have much text we always have a bubble that is noticeable for the height we have to do something fairly similar I want to get the Tex surface then get underscore height and to that I want to add self. padding multiplied by two there's no need to set a minimum height like we have done for the width because the height is always defined even if we only have a single character we always getting a sufficient amount of height next up we can create the background this is going to be a surface which we are creating with pame do surface for the two BS I want to have Whi and height and for now I want to fill the surface with a color self. fill color then I want to get my colors and the bubble color should be a pure white one of the colors we are specifying inside of settings this one this surface will then become the surface we are actually going to display which is a good start but with this system we're not going to see the text anymore we are simp getting a surface with the same size as the text which means we have to put the text on the surface which we do with serve. blit I want to blit the text surface in the center of this surface I want to get the text surface and then get F rectangle where we are setting the center to the center point of this surface or in other words we're getting the width and the height and the div either of those values by two we have a tuple with width divided by two and height divided by two and that should be it although I did realize that this shouldn't be self do padding it should just be pading because pading is a local variable if I now go to the character and I can talk to him we are getting a speech bubble that looks pretty good although it is very blocky that happens because this surface is simply going to be a rectangle and we are going to fix that by adding another argument pame do SRC Alpha that way we can set an alpha value for the surface and by default I want to fill the surface with well nothing I.E a tupo with z z and zero for RGB this value doesn't actually matter because we are going to specify another value for Alpha which is zero so we going to see anything of the surface let's try this one and there we go now we cannot see the background anymore which is totally fine because before we are drawing the text I want to go with py game. draw. rectangle I want to draw on the surface I want to draw with colors and pure white the rectangle I want to draw is surface and get F rectangle where we can set a top left of 0 and zero that way we are simply covering the entire surface with a rectangle so far that isn't going to do very much but what we are now able to do is specify two more arguments a border width of zero and then a corner radius of four with that if I run my Pi again and I talk to a character we are getting rounded Corners so that is looking pretty good and I suppose with that we can close the dialogue Sprite for now we will not need it for a while instead we have to figure out how to get to the next dialogue option at the moment we are only ever getting the first one for that inside of the dialogue tree I want to look for input just as before I want to get all of the press keys with py game. key get uncore just underscore rest then I want to check if keys and P game. Kore space if that is the case first of all I want to get rid of the current dialogue self. Curren dialogue. kill that way we are not going to see a dialogue anymore after that I want to get to the next dialogue index I.E the dialogue index we are using to pick one of the dialogue options this one we simply want to increase by one self. dialog index plus equal one finally we have to make a choice if self. dialog index is smaller than self. dialogue number if that is the case we know there is a next dialogue option available which means we can create another self. Curren dialogue which will be another dialogue Sprite with the same options we have specified up here I can literally just copy all of them and paste them in here however if that is not the case else then we want to end the dialogue although for now we can't really do that so I'm going to add pass in here also to make sure that we are actually calling the input method we will need Define update with self and in there we want to call Self do input however now we have an issue inside of this dialog tree we are checking for the space bar but inside of the main game we are also checking the space bar here so we have a bit of a problem at the moment we would activate both of those options meaning we would get the next dialogue option but we would also get an entirely new dialogue which we want to avoid I only want to check this input if not self. dialog tree only if we do not have a dialog tree do we want to check for this input although at the moment this attribute does not exist but we can fix that very easily when we are creating a dialogue I want to assign the dialogue tree to this attribute and then inside of the dunder init method and let me clean this one up a bit inside of the dunder init method I want to create self. dialog tree which by default is none and once we are creating a dialogue we want to assign the dialog tree to this value that way this if statement is going to run and give us all of this there's just one more thing I do want to do and that is we only want to create a new dialog tree if we currently don't have one I.E if not self. dialog Tree in here as well just as a safeguard that we don't create two dialog trees at the same time cool so with that we have our dialogue tree we just have to make sure that we are actually calling this update method for that inside of the game logic I want to create another section for the overlay and then check if self. dialog tree exists that I want to run self. dialog tree. update let's try I can now go to this character talk to him and we get some updates although this is way too fast let's try it again actually just so we can go through this one by one I am standing next to the character and if I now press space we very quickly go to the second dialogue option although if I press space again we get progress and then the dialogue disappears so this works but we cannot move we do have something but this is not ideal to start with the first issue when we are starting a dialogue we almost immediately switch to the second dialogue option that is because when we are creating the dialogue we are checking this input for the last time but then we also immediately get this input that way we are switching right away to the second dialogue index to avoid that we are going to need a timer that way we are ensuring that we only get this input let's say once every half second unfortunately the inbuilt pame timers aren't particularly flexible however I have made a timer class so if you open the file explorer and go to timer you can open this one and there we have a fairly simple timer class for which you can set a duration repeat auto start and a function you want to call once this thing times out now the class itself isn't terribly complicated and if you want to know more about it check out this video it builds the entire class up from scratch now in our case I am simply going to use it which we start doing by from timer import time and then we want to create one instance of a timer which I want to store in self. dialogue timer for that we want to create a timer class and the one argument we will always need is the duration in milliseconds which in my case is 500 or half a second after that I want to specify one named argument which is auto start true once we have that inside of the input method I only want to skip to the next dialogue if we are pressing the space key and not self. dialogue timer is active also whenever we are getting a new dialogue in this if statement I want to activate the timer which we do with self. dialogue timer and activate that way after we're getting a new dialog timer we have to wait for half a second to get to the next option finally the last thing that we have to do is call self. dialogue timer. update the entire logic of the class is basically inside of this update method if you look at the timer class in there we are basically checking our current time and then a start time if that difference is greater than a duration we want to deactivate the timer that's basically all that's happening inside of the class because of that we always have to call the update method to make sure that this class actually does something but with that if I now try the dialogue again we are getting Hi how are you do you want to fight and fight and then we are finishing the dialogue although we cannot move anymore and later on we also want to start a battle but for now I simply want to end the dialogue below create dialogue I want to Define end dialogue which will need self and the character we have for now we are simply going to set self. dialog tree To None also we want to get self. player and unblock the entire class so we can move around again with that when we are creating a dialogue I want to pass in self dot end dialogue for that to work inside of the dialogue we have to add another parameter and underscore dialogue and then save this one as an attribute let's do it all the way at the top self do and dialogue is and dialogue and then inside of the input if we are exceeding the number of messages we want to call self. end dialogue also this method expects one argument the current character which we have inside of an attribute so we simply have to pass in self. character so with that let's try to have a dialogue with this guy and while I'm talking with him I cannot walk around and we get to the next dialogue option and afterwards I can move around freely again so that is looking pretty good let's try the other lady this one and that is also working pretty well cool so with that we have a basic dialogue system there's just one more thing that we do need and that is if the player is walking in front of any of these characters I want them to talk to the player or a bit more generally for all of the characters I want to check their view Direction and if the player crosses it like we are doing right now then I want the character to move towards the player and start a dialogue for that we have to work inside of the entities and let me minimize things because we only care about the character at the moment to get started we first of all need a bit more information inside of the class we will need the location of the player we will need the ability to create a dialogue and we going to need the Collision Sprites now in case you're wondering we do need Collision Sprites because if this is the character and this is the player we might get a line of site between the two but this we want to block if there's an obstacle between the two which we are getting from the Collision Sprites now first of all we have to create a few more attributes self. player is going to be the player self. create dialogue will be create dialogue and finally for self. Collision Sprites we don't actually care about the Sprites themselves instead we want to have a list of collision rectangles which we can get via sprite. rect or Sprite in Collision Sprites although for this one we do have to be careful because we do not want to get the character itself remember all of the characters are also collidable objects meaning they are in inside of collision Sprites I.E we want to have all of the Collision Sprites if Sprite is not self with that we have the basic setup afterwards we will need a couple of movement attributes self do has underscore moved by default should be faults self. cancore rotate should be true by default and self. has underscore noticed which is going to be false has moved it's going to check if the player has already walked can rotate is going to tell us if this character can rotate around to look in different directions and has noticed is going to tell us if this character has noticed a player or not on top of that we will need two more attributes self. radius and we will need what I called view directions which is going to be list that for example contains left and right meaning this character is going to look left or right at random the radius we can get from til if you look at that and you click on any of the markers if they are a character they always have a radius although I think I was a bit lazy for this one because every single marker has a radius of 400 customize this in your own time for the game it's not going to make that much of a difference anyway in our case we want to get the radius that we put into the Class via the parameter radius for the view directions we have to look at game data in there for example for trainer 01 we have directions down so this character can only look down but for trainer O2 this one can look left or down and trainer 03 can look in all four directions this one we can get a bit more easily because we have the character data I want to get the character data and then get the directions with that we just have to figure out all of these extra parameters that we do inside of main. P when we are setting up the character down here we will need a whole bunch more arguments we will need a player this one is going to be self dot player then we will need create underscore dialogue I believe I called it which is self and create dialogue and make sure to not call this method after that we will need the Collision Sprites and the radius Collision Sprites are simply going to be self. Collision Sprites and finally the radius is going to be obj do properties and I think I C this want the radius let's run the entire thing and we are not crashing and if I talk to a character it's still working just fine cool good start but still the characters don't actually do anything meaning we have to add just a bit more Logic for that I have created a method that I have called Ray cast because ultimately what we are going to do is well we're going to cast AR Ray from the current character in the viewing Direction direction for example if this character is looking to the right we are casting out array in this direction if the player intersects with it then we want to do some more stuff that for now isn't too important we have to go through this step by step for this rast method we don't need any custom parameters and basically what we want to do in there is we want to check our connections once again the same method we have used inside of main. pipe when the player wants to talk to to a character this one or in other words the one that we have created inside of support. Pi this check connections for which we are going to need a radius entity and Target radius is going to be self. radius entity is going to be self and the target is going to be self. layer if that is the case for now to test it let's print layer also we have to make sure that we are calling self. rcast oh and finally we also have to make sure that we are from support import check connections after that inside of main.py we are getting an error that we cannot do a comparison between a float and a string that happens inside of entities with raycast and check Connections in there we are getting a problem on this this line and the issue is fairly simple when we are importing the radius this one is coming from til in there the radius if you look at the data type it is a string for some reason that is my mistake and not terribly easy to fix simply because we have a whole bunch of characters or rather I would say it's not easy to fix inside of tiled inside of pame we can simply convert all of the radi into integers and then this should be working so if I now go in front of this Buck catcher we can see player and if I go to other lady down here for all of the sides nothing is going to happen but if I am below her then we are getting player and finally if I go to this lady we can be below nothing happens but if I am to her left then we get more player output so if that is the case I want to get self. player and block the player also I want to update the player facing Direction which we do with self. player and then change facing Direction the method that we have created earlier inside of entity this one we can reuse that quite easily all we have to do is change the target which in this case is going to be self. re. Center self in this case is referring to the character let's try that one and if I now walk in front of the buck catcher the player cannot walk anymore and we are facing the character cool although the issue is that this is going to work even if there's an obstacle so even if we walking here the player is going to stop and face the opponent but this shouldn't happen because we have an obstacle in the way that we do have to check for to incorporate that I will create another method that I called hasore Lo short for line of sight no need for custom parameters in this one and basically all we want to check first of all if the vector of self. Rec do Center and then distance to self. layer. rect do Center if that value is below self. radius I.E we are only doing stuff if the player is inside of the character radius if that is the case we want to check for all of the collisions between these two entities which should be a list of Boolean values I.E we only really care about if there's an object in the way or not we do not care about the size or the position we simply care if there's an object in the way that is all we need to know I.E this this should be a list of either true or false values but step by step first of all I want to get W for re in self. Collision rectangles the list we created in the dunder init method early on and on this rectangle we want to run a method called clip line this one wants to have two points a starting point and an end point our starting point is self. do Center and our end point point is self. player. rec. Center and clip line is basically going to check if we have a line if it passes through a rectangle if that is the case it will give us the line inside of the rectangle which we don't really care about we just want to know if this line exists in the first place which means we can wrap the return value into a Boolean function that way we ever get true or false and after that we can return not any and the collisions any is going to check if there's any True Value inside of the list if that is the case it is going to return true overall and in our case via this list we're getting lots of true or false values if there's even a single obstacle between the player and the character all of this is going to evaluate to true or to be a bit more precise because of this not we're getting the very opposite I.E if there are no collisions whatsoever this value is going to be true however once we have a single obstacle this value will become false that way we will know if we have line of sight or not which we can use inside of raycast I want to check the connection and self. L if I now try to run the game and walk below this obstacle we we do not get anything but if I walk on top of it so there's no obstacle we once again get the player block and we are facing the character so we can start working on the next issue and that is that I want the character to start walking towards the player for which we're going to need two methods the first one will be start underscore move with no custom parameters and in there we want to set a direction for this character so in other words self. direction is going to get a value self. Direction by the way already exists inside of the character because the parent class entity has a direction this one which means all that we have to find is the direction from the character to the player let's do that on the line before I want to get the relation between the character and the player for that I want to get the vector with self. player. re. Center and then subtract another Vector with self. re. Center this value we need to normalize or in other words we want to call the normalize method now for the direction I do not want to set the relation right away because imagine that this is the character and we have a line of sight going straight down but there is a bit of tolerance so the ual line is something like this and if the player collides with it like so our relation would be an arrow that tilts a bit to the right which might be okay for the game but I want the character to only move up or down or left or right there should not be any diagonal movement to get that I want to create a new Vector with relation dox and relation doy and then the trick is to round both values after that if the player gets into the ray casting area we want to start move now this is not going to do anything because the direction is not being used there's no move method inside of the character so let's create one no need for custom parameters we want to self. rec. Center plus equal self do Direction multiplied with self do speed multiplied with Delta time oh and for that we do need Delta time as a parameter so when we are calling self. move we can pass in Delta Time by default direction is going to be zero so there shouldn't be any movement let's try main. pi and if I go in front of the character it is well it's doing something the issue is we never stop moving but this part at the very least works now to fix that issue while the character is moving we're going to create another larger rectangle around it and if this area coll lights with the player then we are going to stop moving or in other words we want to check if not self. hitbox do inflate and let's go with 10 and 10 if this new hitbox collide rects with self. player. hitbox then we know we have a collision so we only want to move if this is not the case else I want to set self. Direction back to a vector with default values I.E 0 and zero and also I want to wrap all of this inside of another if statement we only want to do all of this if not self dot has moved and if there is a self dot Direction now self dot has moved we haven't touched yet but basically after this if statement is correct we know that the character has moved I.E inside of the El statement we can set has moved to R after that the character should not be able to move anymore all of the characters should only be able to move once so with all of that let's try main. p and the buck catcher should only work to the player and that didn't work and I think I know why when we are updating the rectangle of the buck catcher we are not updating the hitbox that is the same issue we had with the player because in there after moving the rectangle we also had to update the hitbox which at the moment we are not doing but we can fix that quite easily self. hitbox do Center is going to be self. rec. center now this should be working let's try and and the buck catcher is walking to the player and then keeps on walking nearly done we just have to fix the animation the issue we have at the moment is that the character spots the player inside of raycast and then moves towards the player and once we have reached a player we keep on checking the ray cast and then we are starting to move again and we're calling to move method and this keeps on going forever we have to break the loop which we can do with another condition in the if statement and not self do has moved let's try this again now and we should not be getting a walking animation that looks good also what we can do at this point after the character has reached the player we want to initialize the dialogue with self. create dialogue as an argument we have to pass in the character itself let's try that part and now we are getting dialogue and I can go to the next option fight and then walk around that is looking pretty good let's try another character this lady and this part is also working perfectly fine there's not that much more that we have to do and I think at this point we should do an exercise number one make the characters look around using the values inside of self. view directions on top of that create a timer that changes this direction I call this one the look around timer but you could call it whatever you want after this exercise you should have characters that look around in random directions and that should make the game feel much better so pause the video now and see if you can figure this one out inside of the character class I first of all want to create a timer for that all the way at the top we need from timer import timer next up in the dunder init method of the character I want to create self. timers this is going to be a dictionary because in just a bit I want to add a second timer but for now I simply want to have the look around timer which is going to be a timer with a bunch of values we want to have a duration auto start repeat and a function called once the timer times out now the duration is going to be 1,500 so the character rotates every 1.5 seconds auto start should be set to True repeat should also be set to true and then for the function that we are going to call once this timer times out I want to get self. random view Direction a method that does not exist right now so let's create it I guess we can do it right below random view Direction without any c parameters in there first of all we want to check if this character can rotate so this attribute if self dot can rotate if that is the case we want to update the facing Direction I.E self. facing direction is going to be one value of self. view directions for that we can use the choice method that we have to import all the way at the top I want from random import choice and that's more or less all you need to get some rotation although you do have to keep in mind that we have to update all of the timers for that inside of the update method before we are doing anything else we can do for timer in self. timers Dov values don't forget to call this one and then timer. update that should be it if I now run main.py and I look at the lady although I think she can only look left I don't there you can see she's looking e left or down so that is working pretty well let's have a look at this character I think she can look in all four directions and that is working pretty well cool and finally we have this guy who can only look down now the next question is is the dialogue thing still working and yep that looks good although you can see once the character is starting to talk to us it is still rotating that we need to fix which is going to happen inside of the raycast method once the character has notice the player we want to set self dot can rotate to false that way if I talk to a character again let's go to the lady at the bottom because she has more rotate options he's still talking to us and now she always looks in the player Direction so that is working pretty well also while we are here I want to incorporate the has noticed attribute once the character has noticed the player self do has noticed is going to be true and then we only want to check the raycast if the character hasn't noticed the player yet I.E and not self. has noticed on occasion I get a buck without this one where the character kept on looking for the player but any anyway we are making some pretty good progress there are just two more things that I want to implement the first one is if you look at the game data you can see that some characters can look around While others cannot look around for example character O2 should not be looking around for the player or in other words if the player walks in their line of sight they shouldn't start to talk to the player only the player can talk to them the way we are going to implement that is we only want to call rast and move if that condition is true I.E if self. character data and we are looking for look around only if that is the case do we want to call these two methods if I now run all of this we are getting an error because inside of game data I call this look underscore around let's fix that one really quick look underscore around and now main pi I think this one is character two and now even though I'm in her line of sight we are not getting any kind of dialogue but if I talk to her we are still getting the dialogue but she keeps on rotating so that we have to fix I suppose the easiest way of doing that is once we have start talking with the character this if statement we want to get the character and then set can underscore rotate to false or in other words we are only rotating if this can rotate is true if I talk to the character she's pointing at us and she stops the rotation that looks pretty good that was the first point and for the second Point let me run the game again imagine that this lady has line of sight and actually wants to talk to the player if that is the case I want the player to stop for a little bit let's say a second and also have a notice symbol at the top so the player notices that he was well noticed for that we have to implement a couple of things number one inside of the entities I want to work in the player for just a second in there I want to create self. noticed which by default is going to be false after that we can work inside of the character and once the player has been noted inside of this if statement I want to get self. player and then set noticed to grp that way we know that the player was noticed and if that is the case I want to display an exclamation mark on top of the player or rather if I look at a graphics folder inside of UI we have a notice graphic this is what I want to display above the player once the player has been noticed the easiest way to implement that is in inside of the all Sprites group first of all in there I want to get self. notice uncore surface which we get with import image I want to go up a folder then I want to go to graphics and there we have UI and the graphic I want to import is called notice after that basically after we are drawing all of this I want to add another check if Sprite is equal to player and player do noticed in that case I want to get self. display surface and then blit self. notice surface after that we will need a position for that first of all I want to create a rectangle which we get with self. notice Surf and then get underscore F rectangle where we want to place the mid bottom the the position for this one should be sprite. w. midtop which should be the midtop of the player remember the Sprite is going to be the player after that for the position I want to get the rectangle and don't forget we have to add self do offset for the camera and with that we are getting an error that player is not defined and that I believe happens inside of groups ah there we have the issue the player at the moment does not exist inside of this draw method I suppose the easiest way of getting the player is for the one parameter we don't want the player Center we just want to have the player IE inside of main. Pi we are not passing in player. rec. Center we are simply passing in the player itself and then when we getting the player Center this would be player. rec. centerx and for player Center one we would simply get player Center y after that the game does work again the camera also works that's a good sign and now if I walk into the notice radius we are getting another error that we are inside of groups uh adding an offset to a rectangle this should be re. top left next attempt and there we go now we have the exclamation Mark although the character starts walking way too fast so you can't really see it very well first of all I want to create another timer I call this one noce it's going to be another timer the duration for this one is 500 and we want to declare a function which is going to be self. start move the start move we already have so the idea is once the RAS triggers then we want to start the timer and once the timer triggers out we are calling start move or in other words we do not want to cause. move right away instead we want to get self. timers and notice and then activate the timer also there should be a comma at the end of this and that's basically all we have to do this function is now going to be called after the timer times out and then means if I walk in front of a character we have to wait half a second for anything to happen but the rest still works just fine although the notice sign doesn't disappear not ideal after the character has walked towards the player we want to set self. player. noticed back to vaults I can walk in front of him again we have to wait we are talking and that looks pretty good cool we can try this again with another character down here there we go that looks pretty good and we are getting dialogue and with that we have finished the character dialogue this was a larger section but now the game is much more interactive another really important part of the game will be a transition system so for example we can transition from the Overworld to an arena or we can transition from a dialogue to a battle scene for that let's start with a level transition the basic logic is actually fairly simple number one we are going to fade to a black screen during this black scene we are going to delete all of the Sprites and then we are going to rerun self. setup with another titled map by the time the player can see the level again we have a whole new level although before we can start with that we need to get the level transition areas for that inside of til let me display all of the objects and then we have another layer called transition this one you have to zoom in a bit is basically just a layup full of very small areas which are going to be the entrance areas for the doors for example this one gets us to the hospital this one would get us to the house or if you look at another one a bit further up we have the entrance for the arena this one all of those transition areas have two custom properties a position and a target the target is going to be the tile map we want to load and the position is the position within the tile map where the player should start that means inside of main. Pi we need to do two things number one inside of the setup method I want to add another let's do it below the objects I want to have my transition objects just as before we will need a for loop with for obj in TMX map. getet layer by name the we want to get is called transition for this one we want to have a very specific kind of sprite one that doesn't exist yet which means inside of sprite I want to collapse all of this and then create a new class transition Sprite Which will inherit from the Sprite class fundamentally nothing too complicated is going to happen in here we want to have self we want to have a position we want to have a a size then we will need a Target and we will need groups notice for this one we are not going to load a surface simply because we don't need to those tiles are not going to be visible we can simply create a surface with pame do surface right inside of the dunder init method using the size next up we can call Super Dunder init and pass in the position the surface and the groups on top of that we we want to store the target IE the ti map we want to load as an attribute self. Target is going to be Target that is all we need next up inside of main.py I want to import the transition Sprite as well with that inside of the for loop I want to create a transition Sprite for every single one of the objects let's copy all of the parameters we need all of this position is fairly simple obj dox and obj doy for the size it's not going to be much more complicated obj do WID and obj do height now for the Target we want to have it Tuple that is going to contain both of these properties IE which map we want to load and the starting position of the player for that we will need obj do properties and we want to get the Target and then obj do properties with the position nearly done the last thing we need is the groups and for that I want to have all of those Sprites inside of self. transition uncore Sprites this group does not exist yet so all the way at the top in the dunder init method I want to create self. transition Sprites which once again is going to be pame dos sprite. group like with Collision Sprites and character sprites we are only using this group to identify the transition Sprites that's all it needs to do which means next up I want to create another method although before that I think we should organize the game class just a bit better for example the input along with create dialogue and end dialogue should all be the dialog log system under init import assets and setup is going to be General stuff after that I want to have a transition system I think that organizes the entire thing just a little bit better anyway I first of all want to do a transition underscore check no need for custom parameters and really all we want to do in there is first of all check if the player is colliding with any of the transition Sprites or to be a bit more specific I want to check if the hitbox of the player collides with any of these areas I want to store them inside of a sprite's variable and for that we can use list comprehension Sprite for sprite in self. transition Sprites if sprite. rec. collide rect with self. player. hitbox or in other words we are are looking at all of the Sprites inside of transition Sprites and pick the Sprites that are colliding with the player hit box if there are any Sprites then we want to get the player and block it let's check if this is working in the first place meaning inside of the run method sometime before we are drawing everything I want self. transition check and I think this part could also be a bit better organized we first of all want to fill the entire surface with a black color and this could even be all the way at the top there we have Delta time and self. display surface. fill then we are updating the game in there we check input transition check and all of the updates after that we are doing the drawing then we're doing the overlays and then we are updating the screen that feels much cleaner anyway let's try all of this and if the player goes to this area we cannot walk anymore that is working pretty well so now we have to work on a transition Logic for that first of all we are going to need a few more attributes I suppose right below the groups we can add a transition or screen tint system first of all we want to have a transition uncore Target which by default is going to be none this target we can update right away actually because what once the player is colliding with any of the transition Sprites then we want to set self. transition Target to sprite. Target although we do have to be careful Sprites at the moment is a list and we only want to get the first item of this list I.E Sprite index zero and then the Target also this should be Sprites next up we have to work on the tinting logic first of all for that we will need a tintore surface which is simply going to be pame do surface with the same Dimension as the actual window I.E the display surface which means I can copy the window width and window height and paste it in there I also want to have self. tint mode which by default is going to be untint if we are tinting the screen we're going to Black and if we are unting it we're going from black to transparent after that we want to have self. tintore progress which by default is going to be 255 we want to have self. pintore Direction which by default will be negative 1 and finally self. hore speed which I have set to 600 that will give us all of the basic attributes that we need now we have to implement the system although first of all once the player collides with a transition Sprite we also want to set self. tint mode to tint with that we can actually start with the system I call this method tintore screen this one is going to need self and Delta time we want to check if self. tint mode is equal to tint the value we are setting inside of the transition check if that is the case we want to get self. tint progress and increase it by self. tint speed multiplied with Delta time Delta time is really important so we have the same transition speed regardless of the frame rate that way we are increasing the tint progress although by default it is 255 let's set it to zero for now that's going to make debugging a bit easier I want to use the tint progress to update to transparency of the tint surface self. tint surface do set uncore Alpha to self. tint progress in case you haven't used set Alpha all it does is it well sets the alpha value I.E the transparency of a surface and the value goes from zero all the way to 2055 at the moment our tin progress is going to be zero but because because of this line we are going to increase it and to actually see it we will need self. display surface do blit with self. tint surface with the starting position being zero and zero this tin screen we actually have to call which needs to happen on top of everything else I did it right below the display update self. tint screen that part is really important because if there's any other element on top of the tinting it's going to look really weird also don't forget we need Delta time in there let's try and if the player collides with a transition Sprite we are fading out so this system is more or less working we just have to add a few more parts to it most importantly we want to check if self. tint progress is greater or equal to 255 I.E our screen is entirely black if that is the case I want to call self. setup again and remember for the arguments we will need a TMX map and a starting position for the player for the TMX map I want to get self. TMX Maps along with self. transition Target and this one should be zero for the player starting position I want to get self do Transition Target with one remember transition Target is simply going to be a tupal the first value is the map we want to load and the second value is the player starting position inside of that map on top of that we want to set self. tint mode to untint and also we want to clear the transition Target I.E self. transition Target is going to be none next up we have to implement the logic for the UN tinting I suppose we can do that one all the way at the Top If self. htin mode is equal to untint if that is the case self. tin progress is going to be minus equal self. tin speed multiplied with Delta time let's try all of that and now if I get to a door we are getting a key error the reason for that is inside of import assets we only have two TMX Maps world and Hospital let's try to hospital instead if I get to this part we first of all get a huge waiting time and then we're getting a key error so step by step the first issue is when we are calling self do untint the tint progress is actually a really large number in fact let me print self. tint progress if I now Run the game this number becomes increasingly negative and only once we reach the door then this number reverses and it becomes larger and larger but we have to wait for it to become positive for actually something to happen to fix that I want to limit self. tin progress to a value between 0 and 255 which we can do by setting self. tin progress we are using the max function with a floor value this one would be zero and the other value would be self. tint progress with Max we are selecting the larger of the two numbers I.E we are never going to go below zero after that I want to use the mint function for a ceiling via that we are always going to pick the lower value which can be tint progress or 255 with that we can never go beyond 255 or below zero let's try this one and now we get zero at our lowest value and if I hit the hospital we are getting to 255 at the most not even that however then we're getting a key error direction for that error we want to look at the character because in there we are not getting a Direction and that is an error inside of the tile map if you look at the TMX map that we want to load for our player starting position we have a direction and a position that part is fine but for the mark 2D for the nures we don't have a direction or radius now that we can fix quite easily by adding a property we need a direction which should be down by default and we will need a radius which can be zero for nurse after we have that I want to run the game again and now if I go to a hospital we get well we get something so the issue is we have the hospital but we also have the arena and well that's not ideal the problem we have is that when we are calling the setup method we are not getting rid of all of the previous Sprites I.E we can still see the original Overworld which is going to look incredibly weird and to fix that we want to First of all clear the map all we need to do for that is for group in self do for Sprites self. Collision Sprites self. transition Sprites and self. character sprites we want to call group. Mt that way if I try all of this again we are only able to see the level although other than that we still get collisions and that is working pretty good and we can also go back to the overw world so quite happy with that now the issue is if we try to go to another area we're getting a key error to fix that we have to import all of the TMX maps that is going to happen inside of support. Pi and let me minimize everything I want to create a TMX importer which is going to need a path unpacked and then we want to create a TMX dictionary which by default is going to be entirely empty after that I want to have the for Loop that we have already seen in which I am getting the folder PA the sub folders and then in this case the file uncore names this this will be all of the TMX files in walk with join and the path we are getting from the parameters after that we want for file in file names and I suppose for now let's simply print what we are getting that way inside of main.py I want to print the return value of TMX importer for the path we want to go up folder then we want to go to data and in there we have our Maps if I now run all of this we are getting all of the TMX Maps also we are getting a whole bunch of zeros that happens because of this print statement that we don't need anymore so at the moment we can get all of the names of the TMX maps that we want to import that we can use to create a new ENT tree inside of the TMX dictionary I simply want to get the file and then split it wherever we have a DOT and then pick the first value that way we are getting rid of the TMX ending the value Associated is going to be ladore py game the method we have already used inside of the Overworld this one this we want to reuse and we already have the import statement I want to create a path via the join method I want to get the folder path and then the actual file after that I can return TMX dictionary and now if I run main.py again we are getting a dictionary with all of the tiled maps that value we want to store inside of the attribute TMX Maps I want to cut this part out and then get rid of this entire dictionary and simply use the return value for from TMX importer felds significantly cleaner and now that we have that let's try the game and if I go into a house we have a house along with the collisions and that's kind of all we can do in here so if I go out again we are back in the Overworld I can try the hospital again and this one is also working we cannot talk to the nurse at the moment but that we can cover later anyway for now I think this is looking pretty good what you can also do at this point is you can take the start position and then drag it let's say all the way up here to test the water Arena don't forget to save if you not run the code you can check out the water Arena and there you go looks pretty good we can also leave again and then we could check out the other Arenas do that in your own time and with that we have finished the entirety of the Overworld now in dat bits we have to come back to add some additional Parts like the nurses or the dialogue to battle system but I think for now we have a pretty good setup which means next up we can actually start working on the monsters now that we have the Overworld we can start with the actual monsters and there are three things we have to cover the most important part is the actual battle system and this one will become quite large besides that we have the monster index and we have the evolution system now these three system systems work kind of independently so we can approach one at a time and I think the best way to get started is with the monster index this one is going to show us what monsters we have and all of their stats along with their abilities on top of that we are also going to create a pretty fancy UI although before we can get started with that there is a bit of groundwork we have to cover most importantly for all of the monsters there will always be a dedicated monster class that stores the data and there we are going to keep the health the energy the level the XP all of the stats and abilities and so on now this monster class will never be visible we are always going to create a dedicated Sprite or an animation for example in the battle we have a monster Sprite that is connected to the monster class and inside of the monster index we simply have to play an animation by add that system we can keep all of the stats inside of the class and then simply use them in different parts of the game let's start with that part here we are in the code and I do have quite a few tabs open I don't really need them anymore we don't need the dialogue we don't need the timer we are going to need the game data we are not going to need the groups at least for now we don't need the entities we are not going to need the Sprites and we are not going to need support So at the moment I only have main.py game data and settings.py open although I do want to create a new python file that is going to be monster do I in there I want to create a class called Monster no need for inheritance and also notice here we are not using py game since this class is only going to store data there's nothing we need from py game for this I want to create a Dunder init method with self I want to have the name of the monster and then I want to have the level of the monster now the way the system is going to work to get all of the stats and graphics for the monster via the name from game data we're going to pick one of the monsters so if you look at Monster data there we have all of the monsters and if you look at one of those let's say chamad there you have all of the stats for example this monster has the element fire Max health max energy attack defense and so on there's a bit more data in there besides that we have the abilities and whenever the monster reaches a level we're going to unlock and ability finally we have an evolution although this monster doesn't have one but if you look at the next one Finster there we have an evolution we are going to get to gulfin at level 15 so essentially this is what we are going to import and then we have the level that one should be fairly straightforward and basically what we're going to do later on inside of the game data let's have a look at chamad again and let's say for now we only care about the health and this monster has a max health of 27 this is the basee health and that we're going to multiply with the level for example if the monster has a level of 10 then we are going to multiply that value with Max Health I.E 27 so the actual health is going to be 270 all of this data we have to store first of all I want to have self. name and self. level which is simply going to be the name and the level after that I want to get all of the stats of the monster first of all I want to have self. element this we're going to get from the monster data so let me import it all the way at the top I want from gamecore data import monster data and then I want to have monster data I want to use the name of the monster and then I want to go to Stats and finally in there I want to get the element besides that I also want to get all of the base stats which are going to be gotten in basically the same way I can copy the last line and I simply want to get all of the stats with that we have a monster with a name a level and some stats that we can use right away inside of main.py first of all in there I want from Monster import monster and then inside of the dunder init method let's do it all the way at the top I want to create the player monsters which we can store in a dictionary self. player monsters we have the first Monster and for that we need the monster class along with the name of the monster and the level let's say the first Monster could be charm mod pillow at level 30 after that we have monster number one this needs to be another monster what a name for this one let's go with frea and level 29 if I now Run the game we still get the same outcome and I should fix the start position but at the very least nothing is breaking that's a good start now I would recommend to create a few more monsters on your own if you look at game data you can find all of the available monster names in my case I can simply copy it in where we have a whole bunch more monsters also it's really important to keep an integer as the key that way we can sort the actual monsters that will become important very soon anyway at this point we have a bunch of monsters so we can start with the actual index for that I want to create a new python file and save it as monster uncore index don't forgetp and in there we need from settings and import everything then we can create a class I call this one monster index no need for inheritance but inside of the dunder init method we will need self we will need the monsters and then we are going to need some fonts for now after that we want to create self. displore surface which we're getting from pame do display doget uncore surface next up we have to store the font as an attribute self. font is going to to be the font oh and actually this should be self. fonts because we are going to have quite a few different ones in fact inside of main.py when we are importing the assets we want to import a few more I suppose we can do all of the ones that we are going to need for the rest of this tutorial just duplicate the line besides dialog we want to have a regular font which is going to have the same file path the only difference is that the font size is going to be 18 we can duplicate this one more time next up I want to have a small font and this one same font again except now the font size is going to be 14 and finally I want to have a bold font and this one is going to get a different font this one is called doic pixel bolt. ttf and the font size is going to be 20 let's try to run all of this and we are getting an error probably because I have a typo in there somewhere let's double check inside of our Graphics font folder we have DOA pixel Boldt so I think the spelling is correct although the file type is wrong this one is an open type fun file which means the ending is going to be OTF let's try this again and there we go the game is running again now that we have that we can minimize this method and then inside of thunder in knit all the way at the bottom I want to create the overlays so in there we're going to have the monster index and the battle system along with the evolution system in fact the dialog tree could also be in there because it's technically an overlay I want to have a self. monstore index for which we are going to need the monster index class that we are not importing at the moment let's do it below here from monster uncore index I want to import the monster index after that we have to pass in I believe it was two arguments we need the monsters and the fonts monsters are going to be self. player monsters and the fonts are going to be self. fonts the thing we have just imported those ones let's try to run all of this the game doesn't crash that's a good start so with that we can start drawing the actual monster index for that first of all I want to create an update method with self and Delta time Delta time in case you're wondering is what we're going to need for the animation inside of this method there are four things that we want to do number one we want to get input number two we want to tint the main game so that we have a bit more of a separation between the game and the monster index after that we want to display the list and finally we want to display the main section just to explain the last two bits if this is our window our monster index is going to look something like this on the left side we are going to have a list of all of the monsters and this one is scrollable so if the player presses up or down we can select one of the monsters and then on the right side we have the actual information with the monster on top all of the stats and then all of the abilities and when I say tinting the game I am talking about tinting the entire rest of the screen and input is well input and I think the easiest thing to get started is with the tint screen that we can do in the dunder init method I want to create a tint surface section and in there I want to have self. tintore surface this is going to be just another surface so pame do surface with the same size as the original display surface I.E from settings I can copy the window width and the window height and then add them in there as a tuple the color of this surface we don't have to change because we want this thing to be black but we do want to change the tint surface Alpha that we do with zore Alpha and for the value in here I went with 200 once we have that all we need to do inside of the update method is call Self dot display surface dot blit we want to blit The Tint surface at position zero and zero that way we cover the entirety of the window after that inside of main. Pi in the run method let me get rid of the whes space inside of the overlays we want to add another section if self. monster index then we want to run self. monster index do update with Delta time if I now Run the game we can see we are tinting the entire screen so this is definitely working now obviously we don't want to display the monster index all the time for that we have to work with the input method inside of main.py at the moment we are only checking if the player is talking to another character besides that I also want to check if keys and pame do Kore turn that is the enter key if that one is pressed we want to display the monster index and there are basically two ways of approaching this either inside of the dunder method you could set none for the monster index and then as soon as the player presses this button we are creating a new monster index very similar compared to what we have done with the dialogue although that's a bit Overkill since the monster index doesn't have to change that much we can approach this in another way that is a bit easier I want to create another attribute self. index open which by default is going to be false and then inside of the run method instead of checking if the monster index class exists I want to check if self. index open and only if that is the case I want to run the update method on this monster index after that whenever we are pressing K return I want to toggle self. index open which you can do by setting it to what it is not I.E not self. index open with a Boolean value we are always going to get the opposite value I.E true becomes false and false becomes true and if I now press enter we can toggle the overlay that is working pretty well now the issue is while the monster index is open we can still walk around which is going to look really weird to fix that we have to do is get our self. player do locked and set it to what it currently is not I.E not self. player dot locked that way in the overboard I can run around if I press enter we get the overlay I cannot walk around anymore and if I press enter again we can walk around once more cool this part is working that covers the first part now we have a background tinting now we can work on the actual monster index and first of all I want to set the dimensions that we are going to do via self. mainor rectangle which is simply going to be pame do F rectangle where we are setting a left side a top side a width and the height now the left and top doesn't actually matter so I can set those to zero and and zero for the wi I want to get window wi and then multiply this with 0.6 I.E we're getting 60% of the window width for the height I want to get the window height and then multiply this with 0.8 or in other words we're getting 80% of the available window height now this rectangle has to be moved to the center and at the moment we are always placing the top left and I am too lazy to calculate the proper position for the top left to Center this rectangle but fortunately I don't have to do that I can simply use the move uncore 2 method and then set Center to window Wii over two and window height over two although all of this needs to be a tal with that we're getting the main rectangle in the center of the window let's try that part actually I want to run P game. draw. rectangle on self. display surface the color doesn't really matter let's go with black and then we want to draw self. main rectangle inside of main. Pi if I press enter we can see the available area for the monster index and that looks pretty good and if you want to have different dimensions go with it you can choose whatever you like in here next up I want to work on the actual list I.E with we're going to start by displaying the list of all of the available monsters for that actually we're going to need all of the monsters as an attribute let's do that at the top self. monsters is going to be monsters after that we can work on the list and there are quite a few attributes that we need to get I want to get self. visible items which I have set to six I.E how many monsters do we want to display at any point in time besides that we want to have self do listor wi this number we're going to get from self. Main rectangle do WID and I want this thing to be 1/3 of the entire available WID of the main rectangle although once again these numbers can be subjective so just choose later on what you think looks best after that I want to get another attribute self. itmore height which is going to be self. main wct do height divided by self. visible items the way you want to think about that is if this is our entire monster index the thing we are setting with main rectangle on this thing we want to create a list roughly on the left side the width of this thing we are setting with list width and then the item height is going to be the item height of all of the items in there and I think that's all we need for now so next up we can work on let's call this method display uncore list no need for custom parameters and in there we want to get four index and monster inself do monsters. items remember monsters is a dictionary that we have created earlier this one I.E the index is going to be zero and then the monster is going to be all of this for the first four Loop and that continues until we get all of the monsters most importantly in there we want to create an item rectangle which we create with pame do F rect where we have to set a left a top a WID and a height like we have done for the main rectangle WID is going to be self dot list wi and the height is going to be self. item height left is also going to be super easy this is simply going to be self. main rectangle do left the only thing that gets a bit more complicated will be the top argument because of that I want to store this in a separate variable imagine we have our list and on this thing we want to have a whole bunch of entries for each of those we have specified one rectangle which means we get a height we get a whift we are getting a starting position that's the left side and the only thing that's left to cover is the top side now we always want to start at the top of the main rectangle the one we have to finded earlier but then for each individual item we want to go a bit further down to actually get a list which essentially means we do want to start at self. main. toop but to that we want to add the index that we getting from the four Loop and this we want to multiply with self do item height that way on the first for Loop index is going to be zero I.E we stick to this top side however if the index goes to one then we are adding one times the item height I we are moving down by the height of one item and we are getting the top of the next item that's basically all that's happening in here after we have that we want to draw the result pame do draw. rectangle self. display surface the color should be red so we can see something and then the item rectangle after that inside of update I can get rid of the display list comment and it's that self. display list if I now try m not Pi I can press enter and we are getting something now this is very difficult to see because all of the items have the same background color but essentially we get one of those items here we get another item there another item down there and so on in total we are going to see six items that cover the height of the main rectangle but after that we are continuing because the player has more than six monsters in fact at least for now if we keep the monster size 26 this should actually work perfectly and there we go this is looking a bit cleaner now later on we're going to account for more monsters so I do want to keep them in there but at least at the moment we know this is working on the basic level and I suppose to make sure we can see things just a bit better I want to create a text surface which is going to be for the name of the monster for that I want to get self fonts and I want to get the regular font this I want to render with monster do name ntls should be fults and for the text color for now I want to use colors and the white color so inside of settings then we have a white color for this text surface we are also going to need a text rectangle text surface. getorf rectangle I want to place the mid left and this point should be the item rectangle do midle as well if this is the entire list we have currently one item rectangle this one here and the text should be let's say roughly here for that I want to place the mid left of the text to the mid left of the entire item rect angle and in just a bit we can add a bit of an offset to the right first of all though I want self. display surface do lit with the text surface and the text rectangle let's try all of that if I not press enter we are getting all of the monster names and that is looking much better and to add just a bit of offset I want to add a vector with 90 and zero that way if I remain. P again we are moving quite a bit further to the right and later on to the left of the name we have a Monster icon for every single Monster in fact if you look at the graphics folder there we have icons and this is going to contain all of the Monster icons we want to display next to the name that is a part we could do right now actually this could be an exercise I want you guys to import all of the Monster icons and then display the appropriate one next to the monster name pause the video now and see if you can figure this one out to get started we have to work inside of import assets because we have to import all of the Monster icons and to keep all of that a bit better organized I want to create another dictionary I call this one the monster uncore frames which is going to be a another dictionary that works basically like the Overworld frames first of all in there I want to have all of the icons and to import those we need our support file again meaning I want to open support. pi and in there we want to use one of those functions to import all of the icon surfaces and what is really important is that we want to keep the name of all of these graphics and for that import for the dictionary is the best one because this One Imports all of the graphics and then keeps the name so we are going to get a dictionary with the name and a graphic I want to import a folder dictionary and the folder path is going to be a folder up I want to go to Graphics then I want to go to icons and that's the folder I want to import then I can print self. monster frames and icons to see what we get if I now run all of this we are getting addictionary with the name of the file along with a surface that means next up when we are creating the monster index I also want to pass in self. Monster frames we don't need support. Pi anymore and inside of monster index I want to have the monster frames from that let me add another section with the frames for now I simply want to get self. iore frames which is going to be the monster frames and I want to get the icons after that inside of display list I want to create an icon surface which is going to be self. icon frames with the monster name next up I want to create an item rectangle which is going to be icon surface and then get F rectangle for this one I want to place this Center once again I want to get the item rectangle do mid left and to that I want to add a vector with 45 and zero to give it just a bit of an offset since the offset for the text is 90 this 45 is going to be right in the middle between the left side of the main container and the left side of the text the last thing we have to do is self. display surface do blit with icon surface and icon rectangle let's try main. p and there we go we can see all of the monsters and if we had a better background color this wouldn't look entirely terrible so instead of using the red color I want to get the colors and the color that I actually want to use is going to be gray next attempt and that is already feeling significantly better and while we are here we should also get rid of the overlap I.E monsters that are not inside of the main rectangle should not be displayed which is actually fairly simple we only want to draw an item if it is inside of the main rectangle which we can check with if item rectangle do Collide wed with self. main rectangle only if that is the case do we want to do all of that let's try this again and there we go now we can only see six of the monsters although the issue at the moment is that none of this is interactive for that we have to get some input I.E Define input no need for custom parameters and then there as usual we want to get all of the keys with pame DOT key and get uncore just uncore rest at the moment there are only two keys that I care about P game. Kore up and I care about py game. Kore down so what do we actually want to do inside of them and well we want to get an index and either increase it or decrease it if we are pressing up we want to decrease it by one and if we are pressing down we want to increase it by one now this index doesn't exist right now I suppose let's create it in the list section self. index is going to be Z by default and with that we can update an index and increase it or decrease it although first of all for that we have to call self. input and just to make sure that this is working let me print self. index if I now run m not Pi I open the index and we are getting a number that's increasing or decreasing so that's pretty good that's a good start with that we don't need to print statement anymore and next up there's one more thing that I really have to do inside of input and that is self do index is going to be self. index modulus and the length of self. monsters very soon we are going to change the color of one of these rectangles depending on their index and for that purpose the index index from the input cannot be greater than that number but that's all we need from input so next up we have to figure out and let me draw this imagine we have a list with at the moment a random number of entries let's say three for now they would all have the index that we are getting from the index in the for Loop I.E we would have zero 1 and two besides that we also have the index that we are getting from the input if those two numbers are the same I.E the input index and the rectangle index are the same then we want to change the color of this current rectangle that way it looks like it's selected for that I want to add a section that I called colors we want to have a custom BG color and later on we also want to have a text color I suppose the text color we can keep white for now let me paste it in there and then when we are rendering the text we want to have the text color for the BG color though right now we are using the gray color so let me copy it in there and then use the BG color when we are drawing the rectangle however this color we only want to get if the current index is different from the input index I.E we want to get gray if self. index is different from index and the name here might not be perfect but just to make sure you understand this index refers to the for Loop index while this self. index refers to the input index that's part of the class however if that is not the case so else then we can get a different color and I want to copy this one the color I want to use is called light and that should already do something if I now open the menu and there we go we can see that we have at least some basic ability to select the monster now this isn't perfect yet and if I go too far down the thing disappears that happens because further down there we have a few more monsters but those we cannot see that's going to be the next issue we will fix but for now this is working reasonably well so next up then imagine this is the entire index or in other words this is the main rectangle the one with have been using throughout on the left side of the Swing we have a list and this list contains a whole bunch of entries on top of that we have a few more entries at the bottom at the moment I believe there are two extra ones as a consequence when we are trying to get the color and we exceed this point we highlighting either this or this monster but since those aren't visible it doesn't really do anything now to fix that issue basically if the index goes too far down we want to lift up the entire list or rather we want to lift up every single rectangle and for that we are going to create a v offset that by default is going to be zero however when we are getting the top side of each of the rectangles we want to add this V offset so at the moment this is not going to do anything if I run all of this no change however if I set the V offset to let's say 200 and I run all of this again we are now drawing every element 200 pixels further down however if I make this number negative let's say 00 and I run this again we are now able to see a few more elements at the bottom which means we have to make this V offset relative to the index I.E if we go too far down we want to make this offset negative or in other words by default this value should be zero but only if self. index is smaller than self. visible items if that is not the case else let's say for now 100 just to see what happens so if I now run may not Pi again in the menu I can move around just as before but if I go a bit further down we are now moving the entire list up and that's a good start and we can also reset it but this needs to be a bit more finetuned the way you want to approach this problem we once again have the list at the moment with six entries on top of that we are also checking if our V offset is below that point so our index would be further down here if that is the case we want to move the entire thing up by the height of one of those rectangles which means first of all we have to understand how many indexes we are below that list that number we can get and I want to put this in parenthesis right away self. index minus self. visible items and also this number needs to be negative all of that we want to multiply with self. item height let's try that and now if I go a bit further down this is almost working so we have to go two steps further down for this to work which means all we really have to do is to this number add a plus one and then it should be working and that is looking pretty good now we have a nice drop down menu that works just fine that covers the basic part of the list but there's one really important functionality that I also want to cover and that is that the player can rearrange all one of the monsters when a battle starts we are always going to select the first three monsters and the player should be able to choose what those are to implement that we want to look at the input first of all we want to check for another input if keys and py game. Kore space then we want to select one of the monsters for all that I want to create another attribute that we can put right below the index I want to have self. selected index which by default is going to be none basically as soon as we are selecting a monster we are selecting the index of that monster and by default this value shouldn't exist that value we can use because first of all we want to check if not self. selected index I.E at the moment we have not selected anything if that is the case self. selected index should Simply Be self. index that value by the way we can use right away because when we are displaying the list if a monster is selected we want to highlight it which we can do by changing the text color so by default the text color should be white but only if self. selected index is different from the index of the monster if that is not the case so else that I want to get colors and get the gold color let's try all of that if I open the index and select the first Monster by pressing space we get a gold color so that is working really well that means we can check the El's statement and I should explain the basic system is going or in other words we have a selected index then we want to switch those two monsters however if we are pressing space and monster has been selected for that we first of all want to get this selected monster which is going to be self. monsters with self. selected index and notice here we getting the actual monster on top of that we want to get the current monster which is going to be self. monsters with self. index once we have those two monsters we can assign them to a new index I.E self. monsters self. index is going to be the selected monster then I can duplicate all of this because self. selected index should be the current monster and finally self. selected index should go back to being none so inside of the game I can select a monster and then select another monster and this didn't work although if I now click on the first Monster again they do switch so logic does work but something else has gone wrong and I think I know why the issue is this if statement this one is going to trigger as soon as we have one selected monster but that's not exactly what I want instead I want to have if selected index is different from none if that is the case I want to get all of this with the El statement covering the monster being selected for the first time let's try this one now and if I select a monster and another monster they switch places so this system is working much better and I suppose I should go through all of this one more time imagine we have a list with a few entries they all have an index 0 1 2 and three if the player presses space on one of them we're getting a selected index let's say this one could be Z that way we are selecting the first Monster after that if the player presses space again we are triggering this if statement and let's say this happens on index 2 if that is the case we are first getting the monsters we have selected I.E the selected monster and then the monster we currently have targeted after we have that we are simply switching them around or in other words we are simply overwriting the indexes and after that we are getting rid of selected index and then we are done that covers the input there's just one more thing that I really want to do for the list actually two things I want to do for the list the first one is going to be rounded Corners if you look at this thing again it doesn't look amazing and the big reason for that are the really sharp Corners which usually do not look great those we can fix inside of the drawing logic let me add another comment check or nurse so what we want to check in here is if this is the entire main rectangle we have to check if an item rectangle is in the top left or in the bottom left if I of those is the case we want to have one rounded Corner either here or here which means we want to check if item rectangle do Collide point Enter point we want to check is cell main rectangle. toop left or in other words if the top left of the main rectangle collides with our current rectangle we know we are in the top left if that is the case we want py game. draw. rectangle self. display surface BG color item rectangle so all the stuff we have done already but then we want to set a corner radius that is going to be 0 0 and 12 and the logic for the drawing of the other rectangles we can put in an L statement although the text and the icon need to be always visible so let's add a bit of white space if I now run main Pi we are getting a rounded corner at the top left now this isn't perfect because we are also drawing the entire background main rectangle which we don't actually have to do so let's try this again and that is looking much better so next up I want to have an L if statement that checks if item rectangle. Collide point with self dot main rectangle bottom left although to this one I want to add a very minor offset of one and negative 1 I we're going one pixel to the right and one pixel up sometimes the bottom left wouldn't be properly detected by Collide Point don't know exactly why but it happened fairly consistently and if we had a minor Vector offset this problem disappears entirely so once we have that we want to draw a rectangle with a different Corner radius this one is going to get or zeros then a 12 and then another zero so let's try this one again and there we go if you now look at the bottom left we are getting around the corner and this one always seems to be working just fine now in case you're wondering what arguments you need for all of this if you look at the documentation for pame and you look at draw. rectangle you can see that we have a whole bunch of Border radi where you can for example set the top right radius the bottom left radius the bottom right radius and so on these numbers can be a bit confusing especially early on it even took me a few minutes to get this one right with that we have rounded Corners there's just one more thing that I would like to add and that is let me run all of this again actually in just a bit we're going to draw a whole extra thing to the right something like this and to separate these two areas I want to add a very minor Shadow down here so it looks like that all of these elements are a bit in the background now in practice all that we are going to do is we are going to draw a semitransparent surface down on here and then we can call it a day which means all the way at the end and this one should be outside of this for Loop let me minimize the for Loop actually we want to draw a shadow for which we're going to need a shadow surface first of all pame do surf then we will need a whift and a height for the whift I simply went with four pixels and the height is going to be self do main rectangle do height and then we want to get self. display surface do blit where we are blitting the shadow surface in a certain position for which we are going to need an X and A Y point now Y is PR simple self. main. toop for X we're going to get self. mainr do left and to that we want to add self do list wi although don't forget to subtract four to actually show The Shadow surface actually let me run the entire thing without it if I now run may. Pi we have a thing to the right of the list and together to the right border of the list we want to subtract four or the width of the surface and there we go now it's on top of all of the other items that however isn't terribly visible because this Shadow surface doesn't have a transparency which we can change with Shadow surface and set Alpha and then set some kind of value let's go with 100 and if I now run M of Pi that is looking quite nice later on once we have the other part of the index you can customize this but I think for now this is working reasonably well cool that covers the first part of the index although there's one thing that I forgot if you run May notp again there should be a whole bunch of of lines separating all of these monsters stuff like this and that part could actually be a fairly interesting exercise or in other words try to draw lines between the monster entries the colors for now don't really matter simply choose something that works what is really important is that you understand the positioning so pause the video now and see how far you get to get started I want to minimize the for Loop and then add another section for the lines first of all we going to need another for Loop let's call it for I in range and this one is going to be self. visible items inside of there we want to go with py game. draw. line for which we're going to need a surface self. display surface and then we are going to need a color which we can get from colors and the one I want to choose is called light gray finally we need a start point and an end point to get those points we essentially need three numbers the Y position the left side and the right side now the left side is going to be really simple self. main re. left and the right side is going to be self. main R do left plus self. list Wii that way we are defining the left and the right side now we just have to figure out the actual y position now this one also isn't terbly difficult self. main re. toop plus self. item height multiplied by I the value we're getting from the for Loop and with that we have the three points that we need so for the start value I need X and Y the start point is always going to be the left side and Y is going to be the value we have just created then for the end point we want to get the right side and keep the same y the line we are going to draw is going to be horizontal so one point here is totally fine let's try all of this and there we go we have a line separating all of the monsters and this one also updates with the movement so this is looking pretty good however there's one thing that is going to mess this one up a bit if we don't have enough monsters to fill the entire list let's say we only have three monsters in total if I now run this again we are drawing way too many lines which is going to look really weird to fix that inside of the for Loop we want to look for the smaller number between the visible items and the length of self. monsters if we are doing that we are only drawing two lines so that is working pretty well now we are still dra drawing the entirety of the Shadow and I think that part is fine I suppose once we have the other elements we can look at this one again but I think it's not going to be an issue anyway with that I can uncomment the other monsters and we have the list part of the index next up we have to work on the monster display so for that one we don't need display list anymore instead I want to Define display underscore Main in there we are going to need Delta time because because we will have a monster animation in just a bit first of all we want to create the main background for that we will need another rectangle which is going to be py game. F rectangle with the usual arguments left top W and height left is going to be self. main w. left plus self. list Wii if this is the entire main rectangle we want to have a list on the side with the list with being defined by the attribute this is the part we already have and what we want to do now is to create or rather cover the entire rest of the main rectangle at the moment we have the left side which is going to be this line or the top we want to have this line and then all of this for the width and all of this for the height should be fairly straightforward top is simply going to be self. main. top the WID is going going to be self. main. wift minus self do list wift and the height is going to be self. main. height now I am running a little bit out of space but this is still doable it's not terribly complicated or at least I hope it isn't let's actually draw this with pam. draw. rectangle where we want to draw on the display surface the color is going to be from color and we want to get the dark color and we want to draw the rectangle after that inside of update self. display main with Delta time let's try main. pi and if I open this we have something that looks not too bad although we are going to need a corner radius up here and down here for that we have to add a few more arguments it's going to be zero 12 0 12 and zero with that inside of main.py we are getting rounded Corners that is looking pretty good next up we can work on the monster display I suppose to give a bit more context I want to separate this area broadly into two bits at the top we want to have one rectangle that displays the monster in the middle that's the part we are going to work on for now after that we have all of the stats down here and at the end we're going to add the abilities in the bottom right for all of this I want to create another rectangle I call this one the top rectangle which once again is going to be py game. F rectangle for this one we have to specify as always left top width and height or to keep this a bit more concise we want to specify a position and a size this is a bit easier because I want to get the rec. top left for the top left of this rectangle if this is the entire main rectangle we are currently working inside of this part that we defined via the rectangle in there we want to create a top rectangle that is covering roughly this area at the moment we have specified the starting position the top left which can be the same as the rectangle after that we need the size which needs to have the same WID as the rectangle and some fraction of the height in other case this has to be a tupal wi for the well width and then for the height I want to get w. height and multiply it with 0.4 this we want to draw right away py game. draw. rect on self. display surface let's say for now with a red color and then we want to get the top rectangle keep a mind mind though we are still going to need the corner radius for that we need 0 0 0 and 12 let's run main pi and then we can see we have a top rectangle and everything else still works just fine that's a good start but we need a bit more information basically for every monster element I want to have an appropriate color in other words if you look at settings there we have for example a color for plant a color for water and the color of fire and this we want to use for the background of the monster for that we first of all need an actual monster and that I want to do all the way at the top of display main let's call this part data all I really care about in here is the monster itself which we are getting from self. monsters and then self. index self. monsters as a reminder is simply going to be this and our index is number in there meaning via this we getting our currently selected monster after we have that we can use the colors and then get monster do element that is the element we have created earlier that is simply going to be fire water or plant which is going to be the same key that we are using in the colors dictionary so this should already be working if I open the thing then we are getting the different elements so that is working pretty well now after that we have to display an actual monster animation which at the moment we cannot do because we have not imported the monster surfaces themselves so inside of the project folder we want to go to graphics and in there we have all of the monsters this is what we want to import and just to open one of them let's go with this one we always have a tile set with eight parts where the top bit is an idle animation with the B one being the attack animation and to import all of that we want to reopen our support. PI file support dop and there we want to create another function let's put it just above the game functions I want to have a monster importer which is going to need the amount of columns the amount of rows and then a path that we are unpacking after that I want to create a monster dictionary that is going to be empty for now for the setup of this dictionary I want to have key value pairs where a key would be a monster the associated value is going to be a dictionary in which we have the tack key along with a list of surfaces and then we also have an idle entry with another list of surfaces that's we want to create although by default this thing should be empty now just as before we want to have four folder path subfolders and image names in walk join and the path unpacked in there we want to look at all of the images I.E for image in image names and for now let's simply print what we get I want to print the image after that inside of main.py when we are importing all of the assets inside of monster frames I want to create another entry for all of the actual monsters for this one we want to have the monster importer the folder path is going to be one folder up then we are going to graphics and in there we have the monsters let's run the entire game and we cannot see anything and I believe the issue is that when we are creating monster importer we have columns rows and then a path but when I'm calling function we are only specifying a path to fix that we have four columns and two rows and then we have the path let's try this again and now we are getting all of the file names and those are all of our monsters that feels much better first of all then we want to have an image uncore name which is simply going to be image dos split we want to split this wherever we have a DOT and then pick the first item that we can use right away inside of the Monster dictionary to create a new key value pair where the key is the image name and the associated value is an empty dictionary after that we need the actual import and we want to separate all of the images which we have already done by using import tile map which means for every single one of the monsters we want to create a new frame dictionary which we get from import tile map where we passing through the columns and the rows along with a file path that we are getting from the path along with the image name and just to make sure that you are still following along I want to print the Monster dictionary and I want to print the frame dictionary if we now run main. Pi nothing crashes good start and then we are getting a whole bunch of data first of all we are always getting the monster along with an empty Di AR that part's easy after that we're getting the return value from import tile map the way this one is going to work is we have a column and a row or X and Y along with a surface for this part which means we simply have to go through all of the keys and then sort all of these surfaces by their rows and as a reminder the first row is going to be the idle animation and the second row is going to be the attack animation or in other words I want for key and row in enumerate or the list idle and attack that way for of the monsters I'm going to get a key along with a row just to make sure you see what we are getting we always getting zero for idle and one for attack once we have that I simply want to get the Monster dictionary then the image name and then create a new key the associated value for this key is going to be a list of values that we getting via list comprehension since we already have the row we have to get the column I.E call for call in range FS that would give us a number from 0 to three or whatever our columns is that we can use with the frame dictionary the one we have just created this one we can Access Wireless comprehension with a tall that has X and Y or column and row to be a bit more specific which are the values we are already getting either via list comprehension or via the for Loop that's basically all we had to do if I now go back to main.py and after we are doing the import I want to print self. monster Rams with the monsters let's run main. pi and after a second of loading we are getting an error that we cannot find a certain key and you can see what what the issue here is at the moment we have a frame dictionary and we try to get one value the value python currently sees is zero and idle which does not exist inside of this dictionary now the issue here is that I simply switched around to these two values the row is what we're getting from enumerate so this one should be zero or one and then the actual name for the dictionary is going to be the key the one that we are getting from the tubal if we are now trying out of this again then it should work and we are getting none that's a very easy thing to fix it simply happens because we are not returning anything from the monster importer meaning we want to return the Monster dictionary and next attempt now we are getting something and once again massive amount of data but first of all we have the monster then we have a dictionary with Idol there we have a bunch of surfaces and then we have an attack animation which once again is another bunch of surfaces that looks pretty good so now we don't need the print statement anymore instead we have to work inside of monster index also we don't need support. Pi anymore next up I want to do the monster animation for this one first of all we're going to need a monster uncore surface for which we have to do a bit more inside of the dunder init method at the moment we only really have the icon frames besides that that I want to have self. monstore frames which we can get from Monster frames although from this thing we only want to get the monsters the key we have specified here after that to get the actual monster surface we want to get monster frames and then pick a key now that key is going to be a name which we have inside of the monster there we have a name which means we want to get our current monster and then a name although at the moment the return value for this one would be another dictionary where we have the attack or the idle frames now in my case I only want to get the idle frames and just for now to test things I want to get the first item that way we have one surface and just to print that this is working let's print the monster surface if I now try m. Pi we have to wait a second and I can run this and I always have one surface printed out next up I want to create a monster rectangle which is simply going to be the monster surface and then get F rectangle where we want to place the center and the target position should be the top W do Center finally all we have to do is self. display surface. blit with the monster surface and the monster rectangle let's try pi and in the menu we can now see all of the monsters that's coming together quite well although it could look better by animating all of this for that first of all we are going to need a frame index I suppose we could put that one all the way at the top self. frame uncore index which by default is going to be zero after that we don't need the dunder nit method anymore we want to increase self. frame index I.E plus equals some kind of Animation speed ideally the one we are getting from settings so plus equal animation speed multiplied with Delta time using this Frame index we then want to pick one of the surfaces from the idle frames I.E in there we want to get integer self. frame index that way we would get different frames although we would run out of frames really quickly to fix that we want to get the modulus the length of self monster frames we want to look at monster. name and then at the idle frames arguably this line is getting a bit long but the ultimate logic isn't too difficult we have seen all of this for the entities already so I hope it's not too confusing but anyway let's try main. pi and we are getting an animation not an amazing one but it definitely makes the entire thing feel much better that means next up we can add some text to all of this first of all I want to display the monster name for which we are going to need a name surface which we get with self. fonts we want to have the Bold font and this we want to render the text we want to display is going to be monster. name antialias should be faults and colors should be colors and the white color then we are going to need name. rectangle which will be the name surface get F rectangle I want to place the top left to the top W top left I we are placing the name all the way in the top left of the top rectangle and for that we are also not going to need a tuple but I do want to add a vector for an offset I want to move the name 10 pixels to the right and 10 pixels down after that self. display surface dolit name surface and name rectangle let's try main note pi and then we getting the name of the monster that's looking pretty good after that we can work on the level for which we can do something fairly similar compared to the name I.E let me copy all of this but I do want to change the name to level like so after that for the font I want to have the regular font and the thing we want to render will be an F string into which we are entering monster. level nlas and colors can stay the same though for the positioning we want to get the bottom left and then place it in the top right dot bottom left plus the vector 10 and 10 if I now run main Pi you can see that we have the level in the bottom left although that is a bit sparse so I think what we could be adding is something like level and then this should be a bit more explanatory that feels nice there's one more really easy thing that we can add for that I want to copy all of this text one more time because I want to display the element and this element should in the bottom right of the top W container once again I want to replace the level in all of these lines with element for the font we can stick with regular for the text that we want to display we simply want to get monster. element color can stay white this one is totally fine after that for the position since we want to be in the bottom right the point that we want to place will be the bottom right then we want to get the top wck and the bottom right and give this thing an offset of vector 10 and 10 let's try all of that and the game doesn't crash and we get the element so with that we are displaying a whole bunch of text but there's one more thing that I want to do for the level and that should be an XP bar or in other words let's do this in the game right away actually if you look at the monsters below the level I want to display a bar that is going to show us how close we are to a level up and this bar should have a white part to show how much we have and then a darker bit to show how much is left meaning we have to figure out how to draw a bar and also this should be reusable because later on for the stats we want to draw a whole bunch of those all of that we can put in a function that I want to keep inside of support. Pi all the way at the bottom I want to have Define draw bar for which we're going to need a whole bunch of parameters first of all we want to have a surface to draw on then we will need a rectangle for the position we want to have a value a max value then we need a color a BG color and finally a radius although for this one we can set a default value of one now for the logic of drawing a bar there's only really one complicated thing and that is via dangle we're going to set the size of this thing so let's say we could have something like this where the width of the rectangle is 100 pixels and the height could be 20 pixels the specific numbers here really do not matter the actual issue is for the value we might have something like 150 so we have to figure out how to put 150 Health points into 100 pixels or in other words if we have 150 we want to fill the entire 100 pixels and if we were at 75 then we would only want to cover 50% of the width something like this to get started with that we first of all need a ratio between the value and the width of the rectangle or in other words rect do width divided by Max value that is going to tell us how much value we get per pixel after that I want to create the BG rectangle which is simply going to be a copy of the rectangle that we are passing in via the argument on top of that we want to create a progress rectangle which is going to be py game. F rectangle with a position and a size the position is super easy we can simply get get re. top left we want this progress rectangle to be in the same position as the background rectangle or the rectangle we are passing in as an argument for the size we're going to need a width and a height the height is super easy we simply want to get the wct and the height of that one although for the width we want to get the value and multiply this with the ratio and that's basically all we need after that we can get pame do draw do rectangle we want to draw on the surface we want to draw with the background color and then BG rectangle we do not want to have any border width but we do want to include the radius the one that we have specified in the parameters as well that we can now duplicate next up I want to draw the progress rectangle I want to draw the progress rectangle with the color and the progress rectangle and that is actually all we need let's use it inside of monster. py first of all we will need from so Port import draw bar and then for the XP bar I want to call draw bar with all of the arguments that we have specified the surface is going to be self. display surface for the rectangle we have to create a whole new rectangle and I believe it would could be a bit cleaner to use named arguments over multiple lines and then for the rectangle we want to create py game do f rect for the top left of this rectangle we want to get the level rectangle do bottom left in other words the bottom left of this level rectangle and for the size we can go with 100 and four numbers that I thought just looked good next up we have the value and for that ideally we want to have something like monster. XP something that doesn't exist at the moment because in Monster we only have the name the level the element and the stats which means we want to add another section let's call it experience and there we will need self. XP which by default can be zero then we want to have self. levore up which is going to be self. level times 150 level up is going to be the amount of XP we need to get to the next level for level one it's going to be 150 for level two it's going to be 300 and then so on meaning with that we have monster. XP for the value and for the max value we want to have monster. levore up after that we are just going to need the colors and in there for the foreground color I want to get colors and white the same color we are using for the text and for the background color I want to have colors and dark also I am happy with a default radius of one so we can get rid of this part and now Run main.py the game doesn't crash and there we go we can see an XP bar that at the moment doesn't really show anything so what we could be doing after we are creating all of the monsters I want to give every single one of them a random amount of XP that we can do inside of monster. Pi by importing from random import Rand in and then XP is going to be a random integer between zero and a th000 for some monsters this is going to look a bit weird but if I now run all of this we can see that we have bars for all of the monsters that actually display something the problem is that some bars have way too much xp these monsters should have leveled up especially this one that is an issue we can fix later on when we have the evolution mechanic I suppose for now what we could be doing inside of the draw bar function we could set a minimum and a maximum value or in other words we want to make sure that this value time ratio never gets wider than this rectangle I want to create another local variable let's call it progress for that first of all we want to make sure that we never go below zero Max zero and then the value we have gotten from value times ratio let me cut it out actually and then fix my typo and then use progress in there for the width of the progress rectangle that way the rectangle can never go in the other direction which would happen if it was to become negative after that we have to set a maxim value which we do via the Min function we want to have either our value time ratio or we want to have the rect do WID re. WID would be the background rectangle and this should be our maximum width so now I can run main not Pi again and now we are never exceeding the bar so I think that looks pretty good this might have been a bad example let's try this again and there we go so this monster has a lot of XP this one as well and this one as well but we never exceed the length of the bar itself so quite happy with that that means we can work inside of the monster index again although there's one more minor change that I want to do at the moment this draw bar is a little bit below the element which I don't think looks good or in other words if I open the menu again if you look at the elements we have fire on this line and then the level is a bit below that ideally I want those to be on the same line it should be a bit high up for that first of all I want to display the level just a little bit higher which we can do by setting the offset to 10 and6 that should already help quite a bit and yeah I think that looks better I suppose you could work with these numbers a bit more to get the perfect value but I I'm going to leave it as it is this is fine so with that we can start on the main part there are a couple of elements that we have to cover so once again this is our entire index and we already covered the list on the left side we are also covering the monster all the way on top after that I want to have a health bar and an energy bar roughly here and Below those I want to have all of the stats and all of the abilities and to go through it step by step let's start with the health and the energy bar now I guess main part isn't ideal in terms of naming let's call this health and energy for that I first of all want to create a dictionary with a few data points I call this one bar data and for this thing we want to get for example the Wii which would be the rectangle so our rectangle for the entire thing the main background I want to get the width of this and then multiply it with 0.45 and I want to have a height which would simply be 30 pixels with those two numbers we get the width and the height of the two bars on top of that I want to get the top for them as well which is going to be the top rectangle dot bottom plus let's say for now 50 pixels one more key value pair that we need for now and that is going to be the left side which will be re. left plus re do wi divided by four so just to contextualize these numbers once again we have the entire index we have the list and we have the top rectangle and at the moment we want to create the health bar for that we will need the width the height we will need a top position and we will need a left position the things that we have covered inside of this dictionary and later on those we want to reuse for the energy bar rectangle but step by step first of all I want to create a health bar rectangle which is going to be pame do F rectangle where we have to specify a position and a size position we're going to change in just a second for now this could be zero and zero for the size we also want to have a tuple with X and Y or rather width and height but same thing and there we want to get bar data with the width and I can copy all of this because for the height we want to have bar data and height to cover the position I want to use move two simply because I want to place the mid pop which is going to get the xy2 position of bar data we want to have the left side for x and we want to have the bar data top for y and just to make sure this is working let's run py game. draw. rectangle self. display surface we can go with a red color and then the health bar rectangle may not pi and there we go we have a health bar although it is quite far down that's not ideal in other words we want to change the top argument and in my case the number that I went with is the top w. bottom plus W do wift multiplied by 0.03 if I now run main. Pi that feels much cleaner and I suppose the important thing for this bar is that we have the same distance to the top and to the left because of that we are multiplying the top offset with the Wii cool with that we have the position and the size of the health bar rectangle which means next up we can call draw bar again and for that we're going to need all of these parameters we want to draw on self. display surface the rectangle will be the health bar rect rectangle after that we will need a value and a max value I suppose for now we can go with 25 and a max value could be a 100 for the main color I want to go to colors and in there we have a red color for the BG color I want to get colors and in there get black for the radius I want to have a corner radius of two let's try that and there we go this is definitely coming together the major thing missing is that we have to get the health and the maximum health of the monster at the moment this doesn't really exist we only have the max Health via the base stats but that doesn't really help us there isn't a good way right now to track the health of the monster to create that for now I want to create another attribute self. Health which is going to be self. Bas stats and then we want to get maxcore health and that we want to multiply with self. level that means by default the health of the monster is the same as the maximum health although for this part we do have to be careful inside of base stats Max Health could be something like let's say 25 and this value really importantly we are not multiplying with self. level at the moment that is because inside of stats we only want to have the base stats of the monster but for health we have to multiply it with the level right away because this value later on can change and we have to make sure we always have the correct amount of HP but that is a problem at the moment because if we simply went back to the monster index and for the value we could get monster. health and for the max value we could get monster. basore stats with maxcore health The Game Wouldn't crash but we would always have the full amount of Health simply because the actual health is way larger number than the max Health to fix this issue I want to create a method inside of the monster that I called get stat for this one we will need self and the stat that we want to get the only thing that this method is going to do it will return self. based stats with the stat we are currently looking at and then it's going to multiply all of this with self do level that way we get the correct amount which means instead of doing all of this I want to run the function monster. getet stat with Max Health now this is still going to look the same inside of the game since at the moment our health and our Max Health are the same value you this isn't going to do very much since inside of the monster the maximum health and the health are the same this is well not going to be particularly useful but what we could be doing is do self. Health minus equal a random amount let's say Rand int between zero and 200 if I now run main. Pi we are getting some health bars so that's looking pretty good now some monsters don't have enough health for this to really work those monsters would have been defeated but once again that's an issue for later for now I just want to have some random numbers although on top of that I also want to draw the HP text on top of this bar for that we will need self. fonts and the regular font and then render the output I want to render the F string that says HP with first of all the integer value of monster. health and then a forward slash after that we want to insert the integer of the maximum health which we have gotten up here I can just copy it and there we go with that we have the text we need to specify anti alas which should be faults and then a text color which in this case is going to be colors and white we are also going to need an HP rectangle which is going to be the HP text. getf rectangle in which we want to place the mid left point which is going to be the health bar rectangle do mid left although I do want to add an offset of vector and 10 pixels and 0er pixels finally we can run self. display surface dolit with the HP text and HP rectangle let's try all of that and there we go we are now getting the proper values and you can see some monsters have negative values that we can fix later on for now it's not too much of an issue righty with that we have the health bar rectangle after that we want to have the energy rectangle which is going to be fairly similar compared to what we have done here so we can reuse a couple of of numbers width height and top can stay the same although for the X position we will need a right side which is going to be re. left plus re do whift multipied with 3 over four that way we are getting 75% of the WID next up I guess we could copy all of this although I do want to change this to the energy bar rectangle we need py game. fct and the size is still good although for the midtop I would have bar data and the right side top can stay the same though next up when we are drawing the bar I want to use the energy bar rectangle and then Monster Health and monster Max Health we can leave for now although for the color I want to use a blue color and also for now we can get rid of the text and let's see if this is working in the first place and that is looking like a pretty solid start now at the moment we are copying the health amount but at the very least we have a bar the issue is we using the same attributes of the monster for both bars which isn't ideal Instead This should be monster. energy and monster gets that Max Energy max energy does exist but energy does not which means inside of the monster we have to create self. energy which is going to work in a very similar way compared to the health I simply want to get the max stat and energy and multiply it with the level also while we are here I want to change the value of self. energy and subtract the value from 0 to let's say 100 after that I can run out of this and now we are getting different bar sizes that is looking pretty solid so after that we can work on the I call this one the energy points text and energy Point rectangle for the text itself we still want to render the regular font although now this should be EP and Monster Energy along with monster get that Max Energy antialiasing and color stay the same next up for the rectangle I want to get energy points text. get rectangle and the mid left should be the energy bar rectangle. mid left that looks good finally I want to display surface split the EP text and EP rectangle after that we are getting proper numbers for all of this so that is looking very good next up I want to work on the monster info I.E in there we have the monster stats and we have the monster abilities for both of those first of all we're going to need a bit of information number one is going to be the left side for either of them which can be a dictionary where we have the left side and we have a right side the left side is simply going to be the health bar rectangle do left and the right side is going to be the energy bar rectangle dot left if this is the energy bar rectangle I basically want to draw a vertical line and then have all of the abilities somewhere here with all of the elements being aligned to the left side on top of that I also want to know what our available height is which I have called info height or in other words I want to know rect do bottom minus health bar rect do bottom that would be the distance between the health bar and the bottom of the entire index or in other words our entire available space next up we can display all of the stats and the way this is going to work we already have a container that starts at the bottom of the health bar and ends at the bottom of the main rectangle the stuff we have to find here we also have a left side that's simply the left side of the health bar bar and then we can Define some kind of WID to get the entire available WID inside of this space we want to display some text this could be attack or defense or speed or stuff like that and then below this text we want to have a bar that shows how good this value actually is for that first of all I want to create a stats rectangle just as before pame do F rectangle with left top width and height left being sides and left the top being the health bar rectangle do bottom Whi would be health bar rectangle do WID and the height would be the info height that way we are getting a rectangle although we want to inflate this thing just a bit or rather we want to deflate it which basically just means that we want to change the size while keeping the center point on the horizontal axis this could be zero on the vertical one it should be60 and just to make sure this is working let's run py game. draw do rectangle with self. display surface a red color and the stats rectangle inside of main. Pi that looks pretty solid so essentially at the the moment we have created a rectangle that covers this entire area and then via the inflate method we have taken out this bit and this bit just to have a bit of padding that we don't want to draw though but I do want to get a stats text surface which is going to be self. fonts and regular that we want to render the word I want to rer is called stats then faults and colors with white this part is just going to be a title that we want to place on top of all of the stats to give a bit more context to place it we want to create a stats text rectangle via stats text surface. getet F rectangle where the bottom left is going to be stats right do top left finally self. display surface. blit stats text surface and stats text rectangle all that this is going to give us is inside of the game we now have stats so that looks a bit better after we have that we can come to actually displaying all of the stats and for that first of all we need a bit of data most importantly we want to get the monster stats which ideally I want to get from a method called monster. getet stats or in other words earlier we created a method to get one of the stat of the monster but now we want to get all of them which means inside of the monster I want to create theine get stats no need for custom parameters for this one and basically all that we want to return is a dictionary with the values that we want to display and for that I want to have quite a bit of control because the text is going to be visible meaning I want to display the health and then self. get stat with maxcore health I hope the system here makes sense when we are organizing the monster we have health and Max health and those two are separate attributes however when we are displaying all of the stats of the monster we only want to display the max health because of that we can rename it to health and the same we can also do to the energy meaning instead of Max do energy I simply want to get the energy the other attributes I want to display there are four more I want to have the attack the defense the speed and the recovery in case you're wondering recovery is how fast the monster regenerates energy points to get those attributes we want to have get that attack defense speed and Recovery that way we have control over what attributes we want to display which by using inside of the index so now we know what we want to display on top of that we also want to know the stat height which would be the available space for every element that we can get with stats w. height IE the entire available space divided by the length of the St St that we have monster stats once we have that we can create a for Loop to draw all of the elements and for that we want to have the data and the index which means we want to have index and data in enumerate monster stats do items just to make sure that this is working let's print index and data running main. pi and opening the index you can see in the bottom with we get the information for all of the monsters it's a bit hard to see but if I extend this you get a pretty good idea that we have the right bits of information available we just have to display them oh and also this we can make a bit more elegant instead of data I want to have a tupal with the stat and the value to get started inside of this for loop I want to create a rectangle for the positioning of every individual stat let's call it single stat rectangle for that we're going to need py game. F rectangle with left top width and height most of these numbers are going to be fairly simple the left side for example is the stats rectangle do left the top gets a bit more complex that we can cover in a second the width is simply going to be this stats W do WID and the height is going to be the stat height now for the top we want to get the stats rectangle. toop that way we would always be on top of this container although from there we want to go down depending on the index that we have IE plus index times stat height this will be fairly comparable to the list we created earlier after we have that there are three elements that we want to display I want to have an icon for every single stat I want to have some text and then I want to have the actual bar the easiest part is going to be the text let's start there for the name I'm going to go with text surface so I don't have to type too much and we want to get self. fonts the regular font that we want to render and the information that we want to render is simply going to be the stat the one that we are getting from the four loop after that we need faults and for the colors we want to get white next up I want to have a text rectangle which we get from text surface get F rectangle where we are placing the mid left to singles that rectangle do mid left just to make sure that all of this is working let's display that self. display surface. blit text surface and text rectangle so inside of main. Pi we are now getting all of the stats this isn't perfect yet but at the very least we can see something we basically have to update the positioning of the text to make all of this look better but for that to work properly we need the icon first of all or in other words in the project folder we have graphics and then UI and there for example we have an attack icon a defense icon and an energy icon and those we want to display next to the stat which means we have to do another import inside of the monster frames I have a key called UI which is just going to import all of the stuff you have just seen which is just going to import all of the UI icons which we can do with import folder dictionary for the path we want to go up a folder then we want to go to to graphics and in there we have the UI folder after that inside of monster index I want to have another attribute self. _ frames monster frames and UI that way we have a bit easier access to it so now when we are drawing all of the stats inside of icons we can draw the appropriate icon for that first of all I want to get the icon surface which we get from self. uif frames and then this stat and just to explain how this is going to work inside of the graphics UI folder the icon we for example want to use is called attack which mirrors the attack stat name that way all of this is going to work fairly seamlessly after that we want to create an icon rectangle via IC can surface. getet f rectangle I want to place the mid left and the target position is going to be the single stat rectangle do midle plus an offset let's say Vector with five and zero or in other words we're moving five pixels to the right to display that we need the usual self. display surface. blit with icon surface and icon rectangle let's try that and we are are getting all of the icons although they are on top of the text at the moment for that when we are placing the text I want to update the rectangle positioning I want to place the top left to Icon w dot top left plus a vector of 30 and 10 let's try this again and that is looking much cleaner cool with that that we can work on the bar for which we first of all going to need a bar rectangle pame do F rectangle one more time with a position and a size the position is going to be for X the text rectangle do left and for y it's going to be text rectangle do bottom plus 2 pixels just for a bit of padding then for the size we want to have a width and a height the height can simply be four pixels and the width is going to be single stat w dot WID multiplied with 0.9 just for a bit of extra padding to the right with that finally we can draw the bar and as always we have to get all of these parameters surface is going to be self. display surface rectangle is going to be the bar rectangle value is going to be the value that we get from the for Loop that we don't have to change then we are also going to need a max value that we are going to ignore for now let's first cover the color this one is easy we simply want to get colors and white for the background color we want to have colors and black and the radius we can simply ignore after that we have to to figure out the max value and that part is going to be a bit more complex simply because from game data and let's UNL at the monsters here we have all of the monsters and for example for Max Health we want to get the highest possible value out of all of the monsters the same thing we want to do for Max Energy attack defense recovery and speed which means inside of the init method of monster index I I want to create another section for Max values which we are going to store in a dictionary self. Max stats by default this one can be empty and later on what I want to happen there is for example the health and then we are getting some amount here let's say 50 by default this one should be empty because these values we want to generate dynamically to get that we first of all need to have all of the monsters which which means for data in monstore dat. values and I don't believe we have monster data available we do not from game data import monster data with these values we are getting all of this or rather all of this and this and this and so on although we only care about the stats which means we want to a for loop with four stat and value in data stats and on this we want to get all of the items and just to make sure that you see what we are getting let's print stat and value if i r main. Pi we are getting things like Max health max energy attack defense recovery and speed or in other words in game data we are getting all of this now since we don't care about the element in fact we actively want to avoid that part we want to run if stat is different from element this we have to do because in just a bit we're going to compare the values which we cannot do for the element because that's not a number but essentially first of all I want to check if stat not in self. Max stats if that is the case we can simply create a new key self. Max stats with the stat is going to be the value that part is easy the next part is a bit more complex so at the moment we are looping through all of the stats of every single Monster and then we are encountering an element that already exists inside of Max stats if that is the case we want to compare the current stat value with the value inside of Max stats and then pick the larger one which means self. Max stats with the stat is going to be value if value is greater than self. Max stats and the stat if that is not the case else we simply want to keep the same thing IE the value we have started with that should actually be all if I now print self. Max stats and run main. Pi we are getting a dictionary that should always have the largest attribute value let's check for example for Max Health this value should be 29 and that I believe is chillo but we have a Max health of 29 and every other value is smaller than that so that looks good let's do another one for attack the largest value is six so there should be no other value larger than that so we have pluma with attack being six and every other value is smaller than that so that seems to be working just fine however there is an issue and let me run m p again when we are using these Max stats which happens in the for Loop down here the stat for Max health and Max Energy is simply called health or energy which means inside of Max stats we have to get rid of Max health and Max Energy or to be a bit more specific we have to remove the max in there now the easiest way to rename a key inside of a dictionary is to get the dictionary and then the new key the value for this one is going to be self. Max stats and then you pop the previous key which in our case is going to be maxcore Health the same thing we want to do for energy so energy is going to be Max Energy after that I can print cell do Max stats run main. pi and there we go now we are getting all of the max values with health and energy having the right name the order changed but that doesn't matter now we don't need the print statement anymore and we can collapse the init method after that all the way down here we can get the max value for every single stat what we want is self. Max stats along with the current stat that we are looking at and really important this we have to multiply with monster. level and that should be all if I now run may not Pi we get a whole bunch of bars and that I think is looking pretty good no complaints although I think we could move the entire thing just a bit further down for that inside of monster index when we are creating this step that's rectangle after inflate we also want to move it zero pixels left and right but 15 pixels down if I now run may not Pi this thing is a bit more centered which looks a lot better with that we have covered the stats after that we will need the abilities or in other words inside of game data we want to display all of these abilities now for some monsters I was a bit lazy and they don't have very many like those but if you go a bit further down for example for this one we have four Tech moves then we have a few more for this one then we have all of those and this is what we want to display for all of that first of all I want to create an ability rectangle which is basically going to be the same size as the stats rectangle so we can copy that one although we do want to move it to a different position or in other words I want to move the left side to sides and right the sides that we have to finded earlier that happens up here on top of that what will also be similar to the stats rectangle is the title which we have done with these lines so I can copy them basically we want to create an ability text surface and text rectangle now for that I do have to rename a few more things like this one and this one although we do have to change a couple of other things but let's go through it step by step first of all self. want. regular. render can stay the same although the text we want to render is ability next up for the rectangle we want to get the text surface and then place the bottom left in the ability rectangle. top left and I think that's going to be it if I now run main. Pi we getting ability to the right off it that looks pretty good which means afterwards we can create another for loop with index and ability in enumerate and then I basically want to get the monster and get uncore ability piece a method that does not exist at the moment to create that one we have to work inside of the monster where we want to create get ability inside of of this method we want to return all of the abilities that are available to The Monster at the moment if you look at game data we can look at let's say synal and in there we have an abilities dictionary the key defines when this ability is available or in other words on level 26 this monster gets the explosion ability so what we want to return is going to be a list with all of the abilities now first of all for all of that below the stats I want to store all of the abilities self. abilties is going to be monster data with the name and then we want to get the abilities I.E we are getting this dictionary and from that dictionary we want to get all of the available moves that part is actually fairly simple we want to get the ability for level and ability in self. abilities. items remember abilities is a dictionary where we have a level and the ability or all of this stuff and we only want to store an ability if self. level is greater or equal to the level required that way let me print the ability and let's have a look at the monsters so the first monster that we have is tramad Dillo and this one is level 30 at the moment inside of game data if we find shamad Dillo we should have all of these abilities but we should not have annihilate let's try if I run may not Pi open the index we can see all of the basic abilities I think they start here we can go up to explosion but we do not get annihilate I think that's looking good to display all of that I want to create a text surface which we do with self do fonts and regular I want to render the ability fs and the color is going to be black oh and there's one thing I did forgot to mention if this is the rectangle for all of the abilities the one we have to finded up here I want to have a two column layout I.E this is one ability then we have another ability then we have another ability and another one here essentially I want to avoid that we always have a list that displays all of the elements in a single Dimension it simply starts to look boring at some point now the way each individual ability will be displayed is we have the text itself with a black color and around that we're going to draw a rectangle for that we're going to need an X and A Y position I suppose for X we can start with ability rectangle do left although that we do have to change in just a bit but the top I want to have a top offset of let's say 20 pixels then I want to add the ability rectangle do top and then add the index multiply it with text surface and get uncore height once we have that we can create a rectangle where we want to get the text surface and call get F rectangle where we are placing the top left at position X and Y finally we can call py game. draw. rectangle on self. display surface what a color I want to have colors and white along with the rectangle let's try all of that if I now run m.p we are getting well we are getting something I suppose what I should be doing is also display the text then all of this is going to make a lot more sense self. dis playay surface do blit the text surface along with the rectangle let's have a look again and there we go we are getting all of the attack moves except this one doesn't look ideal now an easy thing that we could be doing here is wck dot inflate let's say by 10 and 10 pixels then we can set a border width of zero and a corner radius let's try this one and there we go this is already feeling quite a bit nicer although we are wasting a huge amount of space on the right side to fix that I want to move spark to this position roughly here to get those numbers I have to update the x value the way we are getting that is index modulus and two and that value we want to multiply with ability rectangle dot whift divided by two what we're getting from that if we run all of the is we are staggering the entire thing and the main thing that might cause you confusion is this index modulus two and let me actually print what we are getting if I now run all of this and open the thing we are getting a whole bunch of zeros and ones basically we are checking if index is even or odd and then we are getting zero or one returned which we are then multiplying with half of the width of the container that way an item is either on the left side or in the middle which is a good start but we still have the vertical positioning that we also have to update without that we would get this weird offset at the top which I do not like for that I want to work inside of the Y position and then divide index by two and get the integer from the result if I now run main. Pi that is feeling quite a bit better although we do need need a bit more padding between the elements or in other words at the moment our height separation is simply the text surface height this we want to increase by let's say 20 pixels let's try this again and there we go this is feeling much cleaner and with that we basically have the entirety of the index although there's one thing that I don't like and that is when we are displaying the attack we are only showing the name of the attack which is a good start but I also want to display the element of the attack for that we have to look at game data and come to the third dictionary attack data this one gives us all of the available attacks and then a whole bunch of information for example what we can Target the amount of damage or healing the cost of this move then we have the element and we have an animation for now we only care about the element there we have fire plant normal and water so when we are displaying the ability the background color should have the proper element color for that first of all we need to know what element we are working with which we get from a tech data and currently we don't have that one available so we want to import monster data and attack data that way we're getting this dictionary next up then all the way at the bottom attch data we we have the ability along with the element which is going to be this entry in the dictionary let's try all of this and the game doesn't crash so I assume it's going to work after that we have to link this element to a color which we can do via settings because for every element we have an Associated color although with one exception because I forgot to add the normal color which is simply going to to be a pure white color after that when we are drawing the rectangle I do not want to get the white color instead I want to get the element and with that if I now run main. Pi we're getting a whole bunch more color which is feeling significantly better now that was a larger section but we have made a whole bunch of progress so next up we can start working on the battle system while editing this part of the video I realized I have forgotten two things or rather I forgot one thing and I made a mistake inside of the game the first thing that I got wrong is the length of the stat bars all of those because those are too long I basically want them to end with the health bar all of this stuff here should disappear it just doesn't look good besides that the thing that I forgot to add is if we don't have enough monsters let's let's say we only have the first three if we then run the game we can only see part of the index which is going to look really weird and let's start with the background for that inside of monster index we want to go to display list before we are drawing anything I want to have a BG rectangle as always py game. F rectangle with left top WID and height left and top we can put together as position because for this one we want to get self. main. toop left this BG rectangle is going to be the background for the entire list for the width and height we want to have a tall the width is going to be self dot list wi and the height is going to be self. main re. height this PG rectangle we then want to draw with py game. draw. rectangle self. display surface let's say for now a red color and then the BG rectangle inside of main. Pi if I now open the index we are getting an error this should be called pame Draw rectangle and now inside of main. Pi we now have the background although we have to fix two things number one is the background color and number two is the corner radius for the background color I simply want to get the gray color so that's part's fairly easy let's try and that's already looking a lot better border Corner radius we want to go with zero for the Border WID then a general border radius is going to be zero then we have the top left border this one should be 12 next up is the top right border that one is zero then we have the bottom left border this one should be 12 and then we have zero again let's try all of that and there we go I think this is looking pretty good although while doing this I have realized another minor issue and that is we have this line all the way at the top which shouldn't be there it looks a bit weird that part happens because of those lines down here for this one we have to make sure that we do not draw something on index zero or rather that index zero doesn't exist which we can insert by simply adding a one up to what whatever we are getting from all of this let's try that part and now we don't have the weird line all the way at the top anymore the rest still works just fine so we can reenable all the monsters and it's still looking pretty good cool very happy with that and that is making a noticeable difference after that we have to work inside of display Main and more specifically we want to work inside of the four Loop for the stats for the bar rectangles we are getting a single stat rectangle and then 90% of the width which turns out is a bit too far if we change this to 75 so 75% then this is looking a bit better but still not ideal or and other words I want this bar to extend to the length of the health bar something like this I think the best way to think about it is if this is the entire stats rectangle we have an icon then we have some text and then we have the bar and at the moment the bar is a bit too wide so this part we have to remove which means essentially we want the length of the bar to be the width of the entire rectangle minus this part which we can get with the entire rect of the single stat rectangle WID but from that we want the subtract text rectangle. left I.E the left side of the text rectangle minus the single stat rectangle do left that would give us the distance from the left side of the main rectangle to the text so with that we have the properly sized bar and that is making the entire thing feel much better so I am quite happy with that cool with that we have actually finished the index so next up we can work on the battle system righty then the battle system now this thing is going to become fairly complex we have a ton of animations we have lots of timers we have to capture input there are just a bunch of things that we have to do so let's go through it step by step and start by setting up the entire thing first of all we are going to need some opponents which we can create right below the player monsters self Dot let's call it dummy monsters this is going to be a dictionary very similar compared to the player and let me literally copy a couple of entries I want all of those monsters although we do have to fix the indexes this should always be a list that starts from zero and then goes in a sequence also let me change the levels to something that is a bit more noticeable so with that we have a couple of opponents that we could fight which means next up we have to figure out the actual battle system and essentially what we are going to do if I minimize everything and then look at the Run Loop we already have a dialogue tree and an index for the overlays in there I want to add one more if self. battle exists then we want to run self. battle. update with Delta time also let me align all of this that's going to look a fair bit better there we go so basically for the battle system we are just creating a whole bunch of Sprites on top of the entire level while also making sure that the player cannot move that way our transitions are going to be a bit simpler but anyway first of all for all of this we want to create inside of overlays in another attribute self. battle which by default is going to be none meaning if we are running the game now nothing is going to change however what we can do is create a new python file which I want to save as battle do high and then we need the usual stuff from settings import everything on top of that we want to have class B till without any inheritance for the Thunder init method self the player monsters along with the op opponent monsters we are going to need all of the Monster uncore frames I.E all of the graphics and we want to have a BG surface also we want to have a whole bunch of fonts I.E fonts first of all in there then we want to get self. displore surface which we get with py game. display doget uncore surface we want to store self. BG surface as an attribute the same we want to do with self. monster frames because we're going to use them quite a bit also the fonts we need to store so self the fonts is fonts after that I want to have all of the monsters inside of a dictionary I.E monster undor data is going to be a dictionary where we have the player with the player monsters then we have the opponent with the opponent monsters this part is necessary because sometimes we want to update all of the monsters in the battle and having all of them in a single dictionary is going to make that a bit easier so with that we have the setup next up the most important thing in this class is going to be an update method with self and Delta time and for now just to make sure that this is working I want to get self. display surface and then L self. BG surface at position 0 and Z inside of the project folder in graphics we have backgrounds those are the battle backgrounds those we first of all need to import which once again happens inside of main.py in import assets I wasn't really sure where to put them so I have simply created a separate attribute self. BG underscore frames which we get with import folder dictionary aut paath we want to go upper folder then to Graphics in which we have the backgrounds let's run out of this and we are not getting an error so the Imports seem to work just fine so with that we can all the way at the top import from battle the battle class and then when we are initializing the entire game instead of setting battle To None I want to create an instance of the battle class for which we are going to need a whole bunch of arguments let me copy the parameters player monsters is going to be self. player Monsters the opponent monsters are the ones we have just created the dummy monsters for Monster frames we want to have self. monster frames for the BG Sur we want to pick one item from these PG frames I.E if you look at them we at the moment have a dictionary with the keys for Forest Ice and sand so the one that we could be using is self do BG frames with the forest finally the last thing we need is self. fonts for the fonts if I now Run the game we have the background for the battle so so that's looking pretty good now the problem is that well the player behind all of this can still walk around which we cannot really see but if this was the case in the game it might cause some issues or at the very least it would be super weird one thing we could do already about that inside of input we are already checking if we do have a dialog tree or rather if we don't have a dialog tree only then should the player be able to do all of this this system we can extend right away we also want to check and not self. battle that way if we are in a battle we cannot talk to anyone and we cannot open the index although the player can still walk around which isn't ideal and for now it's not really easily fixable simply keep it in mind later on once we have a monster encounter we want to block the player movement like we have done for the dialog system but for now I think this is all right anyway with that we have have a battle system or at the very least we have the background for the battle which means next up I want to run a setup method no need for custom parameters for this one and basically what we want to do for entity and monster in self. Monster data do items IE we are going through this dictionary then we're getting the entity do we have a player or an opponent and then we are getting all of the monsters or rather we get the monster data and that is a really important thing to understand for this battle system we have the monster data which is going to be all the stuff we are getting from the monster this stores the actual monster information but to display the monster we have to create a Sprite this one is actually going to be visible but step by step first of all I want to get the first three monsters from the player and from the opponent or in other words I want to pick these three monsters or these threee monsters that we can get with for index and monster in I want to create a new dictionary via dictionary comprehension where I have a key and a value for K and v in Monster do items and with that we would duplicate the dictionary that we already have for the player or the opponent I.E all of this but this we only want to do if the key is smaller or equal to two and from this new dictionary we want to get all of the items if I print the result we have index and monster and also I want to run self. setup if I run m.p we are get getting 01 and two for the player monsters and 01 and two for the opponent monsters a bit hard to see but you get the idea I suppose what we could be doing at this point which is generally good practice inside of the monster class I want to create another Dunder method Define Dunder repper this is going to Define what we are doing when this class is being printed no need for custom parameters and basically we have to return some kind of string if this one is monster and I run m not Pi again instead of seeing the object in memory we get the string Monster not a bad start but not exactly helpful so instead I want to have a monster with self. name along with let's say the level which is self do level if I now remain. Pi we are getting the index and then the monster along with the level and there you can see we have the first three player monsters along with the first three dummy monsters using that information we want to create a monster or rather we want to create a whole bunch of monsters which I'm going to do inside of a method called create monster which is going to need a bunch of parameters let's create the method right away create monster after self we will need the monster data then we want to have the index on top of that we want to have a position index and finally we need the entity I.E player or opponent and I should explain index is to identify the monster so for example we could have two monsters with the same name and the same level it is totally possible to have something like charma d twice with the same level which would be inconvenient for us because they would be really hard to separate hence we are going to use the index of the monster to make sure that we always have a unique monster ID that is the purpose of this index besides that we have a position index to understand this one you want to look at settings because in there we have the battle positions if this is the window for the left side we have a position roughly here here and here and then for the right side we have another set of positions for here here and here or something like that those positions have indexes I.E top would be zero Center would be one and bottom would be two 0o 1 and two keeping track of these numbers is going to be really important because that way we can ensure that we always have the monster in the right place although for now I simply want to add pass in there because before we can work on this method we have to add all of the arguments monster is simply going to be the monster the index is going to be the index and the position index will also be the index and finally for the entity we want to get the entity all of the stuff we are getting from the four Loops basically also I am using index here twice because the first index is to keep track of the monster the second index is stand for the positioning and for this number I'm expecting number that is either Z one or two which I am getting from these indexes as well I.E the first Monster will always be on the top position or index zero the second monster will be in the middle index one and the third monster will be on index two or the bottom also let me get back the original monster that makes a lot more sense cool with that we can create a monster first of all we want to have the frames for this monster which we get from self. monster frames we want to get the actual monsters from this thing and then we want to pick one of the items which we are getting from monster. name that information we then want to use to create a monster Sprite Which is going to need a whole bunch of arguments we want to have a position we want the frames we want a couple of groups then we want to have the monster for data we want to have the index along with the position index and we need to know What entity it belongs to I.E is it a player or an opponent monster this monster Sprite does not exist at the moment for that we have to look at Sprites which I do not have open right now and also we don't need the monster index at the moment instead I want to have the Sprites we don't need any of the stuff we have already created I want to create the battle Sprites all of those are going to be the Overworld Sprites for the battle Sprites I want to create a class called Monster Sprite the parent is going to be pygame dos sprite. Sprite and then we're going to need a thunder init method for which we're going to need a parameter for all of these arguments on top of that we're going to need self after that I want to call Super with thunder in knit with all of groups along with self. index being the index self. position index is going to be the position index self. entity is going to be the entity and self. monster is going to be the monster that covers the basic data after that we need this bright setup you want to be a bit better with comments actually we can put this super in it in there and this part is going to be data for the Sprite itself we are going to need self. image and self. rectangle at the moment we don't really have a single image we only have a whole bunch of frames which means inside of data we need a few more attributes self. frame index self. frames and I also want to have self. state which is going to be zero Rams and the string idle that information we can then use for the image we are going to get self dot rames with self dot State and then we are going to use indexing one more time with self. frame index that should give us a single surface for the rectangle we want to have self. image. getet F rectangle where we are setting a center to a position that should be a pretty good setup next up then inside of battle we first of all have to from Sprites import the monster Sprite also since we are working with Sprites we have to create a bunch of groups before we are calling the setup method once again I want to have a couple of comments this is groups and this part is general what groups I want to have self do battlecore Sprites which for now can be pame dos sprite. group this I want to duplicate two times because I want to have a Sprite group for the player Sprites and another one for the opponent Sprites and I want to align all of this up so it looks nicer and with that we can finally create a monster Sprite now for that we're going to need a whole bunch of arguments and most of them we already have frames we are getting from what we have just done before groups we can set in just a second and the remaining arguments are coming from the parameters so that's quite simple all we really have to figure out is the position and the groups which means I want to have two more variables position and groups and those are going to change depending on the side which means I want an if statement if entity is equal to the player then I want to create one set of variables and if that is not the case else then I want to do the same thing although for now let's comment it out so we're not getting an error for the position I want to create a list with all the available positions And then use the monster position index to pick one of them in other words inside of settings I want to get this position this position and this position put it in a list and then select one of those via the index for that we will need the battlecore positions that we're getting from settings so this entire dictionary we currently want to look on the left side of this thing because the monster should always be on the left side and from that we want to get all of the values that way we only get the actual position while ignoring the key then for the groups I want to have self. battle Sprites and self. player Sprites and with that we should have a setup which means inside of the update method I need self. battles Sprites do raw on self. display surface if I now run m.p which we are getting an Unbound local error inside of the setup method that happens here and the issue is we are only creating a position if the entity is on the player side if we are on the opponent side we do not have a position so this position doesn't exist when we are trying to create a monster Sprite to avoid that issue for now I want to indent the monster Sprite so we are only creating a Sprite if we are on the player side side for which we always have a position and groups or in other words all of these arguments are available let's try of this again and there we go we have a couple of monsters now this isn't ideal they're not animated they're facing the wrong direction and we do not have the opponents so loads of things to work on that part is going to be an exercise I want you guys to do three things number one flip the player monsters on the horizontal axis so they're facing to the right after that add the opponent monsters and finally animate all of the monsters should be doable but you do have to write a couple of lines of code pause the video now and see how what you get I think the easiest thing to get started with are the opponent monsters meaning I want to uncomment the El statement and then remove one indentation from the monster Sprite next up we have to get the position which is going to work fairly similar compared to what we have done for the player the only difference is that now we want to get the right side for the groups we want to have self. battle Sprites and self. opponent Sprites with that inside of M Pi we are getting a whole bunch more monsters that's already feeling better although we have to flip all of the frames for the player and the thing you really have to understand when you are looking at all of of the monster Sprites all of them are facing to the left which means if one of them is on the left side of the screen we have to flip them to always face to the right or in other words when we have the player entities we want to create frames that are flipped which has to be a new dictionary where we have a state along with a couple of frames and at the moment we can go for state and frame in frames. items that would simply duplicate this list so so far not particularly useful but with that we have access to all of the frames which means in there we can run a list comprehension in which we want to go through all of the frames I.E frame for frame in frames so now we have access to every individual frame and this we want to flip on the horizontal axis which we can do with py game. transform. flip we want to have a frame we want to flip it on the horizontal axis but not on the vertical one if I now run main. Pi we have all of the Monster frames facing in the right direction so that's looking really good finally then inside of monster Sprite we want to animate all of this for that I want to create an animate method with self and Delta time we want to get self. frame index plus equal animation speed multipli it with Delta time and then self. image is going to be self. frames along with self. State and then we can pick the integer of self. frame index with modulus of the length of self. frames with the current self. state this animate method we have to call inside of an update method which needs self and data time there self. animate also don't forget Delta time in there next up inside of battle. Pi before we are drawing all of the battle Sprites we want to call self. battle Sprites do update and pass thata time in there now inside of May Pi we have animations this isn't terrible but also not ideal because at the moment all of the monsters animate at the exact same frame rate which can look a bit weird to make that a bit more interesting I want to create in the dunder init method a self. animation speed which is going to be the animation speed plus a random amount that we getting from uniform which I believe we don't have at the moment we want from random import uniform uniform is basically the float equivalent of random integer I.E we have to set a start and endpoint and then python is going to give us a random floating point value between those two in my case I want to go from 1 to 1 and then let me print a result if I now run may not Pi we get a bit more variation and if you look at the print statements now our animation speed has a bit more diversity not a lot but enough to make the game feel a bit more random and organic righty with that we have the monster but we are also going to need the UI and there are three classes that I want to create we want to have a monster name Sprite we want to have a monster level Sprite and a monster stats Sprite to understand these classes in the right you can see the result monster name Sprite is going to be the name it's going to be a rectangle up there monster level Sprite is right below this one shows the level of the monster and it's not in this image but in the bottom of this Sprite we're going to have the level progress I.E how far we are from the next level up both of these are fairly straightforward the slightly more complex one is the monster stat Sprite that's the stuff at the bottom that shows the health of the monster the energy of the monster and the Readiness of the monster that's the black bar at the bottom that's going to show you how far the monster is away from being able to attack or defend or do basically anything those three classes we have to create and let's do it step by step starting with the monster named Sprite for this class we're going to need a couple of arguments we want to have a position we want to have the monster Sprite we will need the groups and finally we will need a font these numbers we can get fairly easily although before that inside of Sprites we have to create a class first of all I want to have a class monster name Sprite with the parent being pame do sprite. Sprite for this one in the dunder init method we want to have a position the monster uncore Sprite the groups and the font most importantly we have to cause super Thunder init with the groups that part is easy after that we want to have self. image and self. rectangle the rectangle is fairly easy we simply want to get self. image. getet F rectangle where we are placing the midtop to the position the image is going to be a bit more complicated because essentially we want to render some text and this is going to be the size of this Sprite kind of similar compared to what we have done with the dialogue Sprite first of all we want to create a textor surface which is going to be font do render the text that we want to render would be the monster Sprite do monster. name and this brings us to something that we are going to see a lot monster Sprite is going to be the monster class we have created up here inside of that thing we have the actual monster data and only in there do we have the name what you always have to remember is that this monster class contains the actual information the monster Sprite at the moment is basically just there to display a Sprite and animate it that's all it does also I don't want to print the animation speed anymore that's not needed righty for antias we want to set fults and for the text color I want to have the colors and the black one on top of that I want to set some padding of 20 pixels for self. image we can create pame do surface for which we are going to need a width and a height for the whift I want to get the text surface and get underscore whift plus two times the padding one for the left side and one for the right side for the height we are doing basically the same thing I want to have the Tex surface get underscore height don't forget to call this one and to that we want to add two times the padding with that at the very least we should be able to see something although for that first of all inside of battle. Pi we have to import the monster name Sprite then we can create all of this but first of all we will need a position the monster Sprite groups and font font is the easiest part although for that we need to get all of the fonts those we already have and then we want to call Self do fonts the font name that I want to use is going to be regular for the groups we can simply go with self. battles Sprites the monster Sprite is going to be the monster Sprite we have just created to get this one we first of all want to create a local variable monster Sprite that way we can get the monster Sprite in there finally we're going to need a position let's rename this actually to name position to make it a bit more understandable now for that I want to create a local variable with the same name and basically what I want to do is I want to get the monster Sprite then W and then mid left order to that I want to add a a vector of 16 and7 that is going to cover all of the arguments let's try to run main not pi and we are getting something so that's not a bad start the thing is entirely black though that's not ideal and we cannot see the text also for the opponents the Box should be on the right instead of the left let's work on that first of all we only want to get this position if entert is equal to player and if that is not the case so else then I want to get the monster Sprite dot wct do mid right along with a vector offset of40 and 70 and by the way those are numbers I simply got from playing around there's no real science behind it it just looked good cool but that I'm quite happy with after that inside of the Sprites we first of all want to fill the entire surface I.E self. image. fill colors and a white color that is already looking much better although I think the box is a bit large let's change padding to 10 pixels I think that's going to be better yeah that looks much more reasonable finally we have to add the actual name of the monster that currently we have inside of the text surface to display it self. image. blit we want to display the text surface and then we have to get a position which in our case is going to be petting and petting if I now run all of this again we get the name of the monster in the center of the text box so that is looking pretty good now in case you're wondering about these two paddings the way you want to think about it is that this is the entire self. image and on there we have a whole bunch of paddings so it's always 10 pixels there 10 pixels there 10 pixels there and 10 pixels there when we are blitting the text surface we are looking for the top left which in our case is going to be this point here because all of this is what we have gotten from the width and the height of the actual text which means via this top left point we are centering the text perfectly and that is all we need from Monster name Sprite we can now minimize it and create another class with monster level Sprite Which is also going to be a pame Dos sprite. Sprite for this one let me uncomment the class name because now we have to figure out the argument ments I want to get the entity and an anchor I'll explain this one in just a second besides that we want to have the monster Sprite we want to have the groups which we can change right away to self. battle Sprites and finally we want to have self. fonts and the small font to display some text the last three arguments are fairly straightforward I don't think I have to explain them entity is is also fairly simple do we have a monster on the player side or on the opponent's side the only complication is the anchor so what is up with this one if we have a monster on the player side then we want to have the monster named Sprite on the top left roughly here the monster level Sprite I want to be right below here those two should have the same left side and also the level Sprite should be right below the name that way it looks like we have one connected Sprite but we do have to be careful this is only for the player side for the opponent monsters we want to have the entire thing mirrored it should look something like this where we have the name on the top this we already have but on the bottom we want to have the level so now they share the same right side for that we have to Define an anchor that part is slightly more complex so let's create another local variable I want to get either the bottom left or the bottom right of this monster name Sprite which means we need to store this in a variable as well let's call it name Sprite and then the anchor is going to be named. w. bottom left but only if the enter is the layer if that is not the case we want to get name. rec. bottom right that is going to give us all of the arguments next up we have to make sure that we are importing monster level Sprite and then we have to create the class which we start with by creating a thunder init method let me copy in all of the arguments like so self. battle Sprites is going to be the groups and self. font small is going to be the font as always do not forget to cause super Thunder init with the groups and also self. monster Sprite is going to be the monster Sprite we always want to connect this monster level Sprite to the monster Sprite itself because if the monster dies we want to get rid of this Sprite as well and I believe this I haven't done for the monster name Sprite in there we are only using the monster Sprite for the monster name we also want to have a self. monster Sprite attribute which which is going to be the monster Sprite anyway with that we have the monster Sprite next up we will need self. font which is going to be the font after that we're going to need self. image and self. rectangle for this monster level Sprite you do have to be careful because during the fight the level of the monster could update meaning we couldn't simply create the image once with the text and then call it a day we have to create an update method with self and Delta time although Delta time we're not going to use so an underscore instead inside of this update method we are displaying the text that way if the monster level increases during a battle we are still displaying the right information although I suppose for now we can simply get self. image and fill the entire thing with colors and white so now we have to figure out an image and a rectangle now for the image I was a little bit lazy and simply went with pame do surface and then added 60 and 26 we always have a static size for the image and this number simply looked good and fit right in although if you're using a different dimension then this might have to change next up for the rectangle we want to get self. image. getet F rectangle where we are placing the top left to the position but only if the entity is equal to to the player if that is not the case then we want to get self. image. getet F rectangle where we are placing the top right although the position is still going to be the same and just to explain what this line means from the monster name Sprite we are getting a rectangle like this and if we on the player side we want to create the new Sprite right below with the same left side and the bottom of the name is the top of the level however if we are on the other side I.E the opponent then I want this level Sprite to be on the right side so here where we are sharing the right side although the vertical position is still going to be the same anyway let's try all of this if I run m. Pi we are getting an error that name is not defined this happens inside of this line because we are getting name. rec. bottom left this should be name underscore Sprite next attempt and another error we expect five arguments but we are giving six that usually happens because you have forgotten self in the dunder init method like I have just done next attempt and we are getting another name error that the position is not defined and that is because the position is going to be the anchor so instead of position I want to use the anchor although I guess name here would be a better argument but anyway now we are getting the right Sprite that looks pretty good and anchor here really isn't a good name let's call this one the levelor position and then inside of Sprites instead of anchor it's going to be a position for all of them let's try it again and that's much better sorry about now we have to display the level of the monster inside of the update method first of all for that I want to create a text surface local variable with self. font. render an F string with level and then self. Monsters sprite. monster. level I already talked about this but make sure to include the monster only in there do we have the ACT ual monster information after that antialias should be fals and for the colors I want to have the black color next up we need a text rectangle which is going to be the text surface. getf rectangle I want to place the center to the center point of this surface or in other words self. re. wift divided by two and self. re do height divided by two and finally self. image dolit with the text surface and the text rectangle let's try out of that and there we go now we have the level for all of the monsters there's just one more thing that I do want if this is the monster level Sprite at the bottom I want to have a level progress bar that shows us how far away we are from a level up now we already have a way to create a bar inside of support. Pi we have a draw Bar Method this we can reuse let me copy all of the parameters and then inside of Sprites don't forget from support import draw uncore bar inside of monster level Sprite I want to draw a bar with all of these arguments surface is going to be self. image rectangle we can ignore for now that's going to come in a second for the current value we want to get self. moners sprite. monster. XP max value is going to be also from the monster class inside of the monster Sprite although this one will be level uncore up for the main color I want to go with black I.E colors and black and BG color should be a white color so it looks like there's no background I.E background and white and the radius should be zero nearly done the last thing we need to get is the rectangle this I want to create in a separate variable XP rectangle which is going to be a pame f rectangle with left top width and height the height can simply be two pixels the width is going to be self. re. wift the left is going to be zero and top is going to be self. re do height minus 2 and also this XP rectangle we only have to create once I.E we can do it inside of the dunder init method and then call it self. XP rectangle this we can now insert into draw bar and if I run m. Pi again we can see a couple of XP bars now for the third monster Lavia we have a full XP bar this monster should have leveled up that mechanic we do not have at the moment but we can work on that later first of all though I want to display all of the Monster stats that part is more important for now for all of that we want to work inside of Sprites a monster stats Sprite as a parent we need pygame dos sprite. Sprite just as before for this one in the dunder init method we will need a position the monster Sprite the size that we want to use the groups and the font then the usual super Dunder init with the groups and we want to store self do monster Sprite as an attribute monster Sprite after that I want to create self. image and and self. rectangle so we actually have the stuff for the Sprite for self. image I simply want to create a py game surface with the size that we are getting from the parameter once we have that the rec we are getting with self. image. getet f rectangle and I want to place the mid bottom to the position finally while we are here self. font is going to be the font that's a good start with that we can inside of battle create the monster stat Sprite although first of all all the way at the top we need to import the class and also let me minimize things so it's a bit easier to see what's going on so to create an instance of this class we need these arguments the position will be the monster sprite. w. mid bottom I.E the bottom of all of the monsters do that I want to add an offset of zero pixels on the horizontal axis and 20 pixels on the vertical one we are going 20 pixels down the monster Sprite Remains the monster Sprite for the size I want to have a static number I went with 150 and 48 once again a number that simply looked good if you like something else just go with that for the groups I want to have self. battles Sprites and for the font it's going to be self. fonts from which we want to pick this small font with that I can run m not pi and we get a bottom bar below all of the monsters that's looking pretty good doesn't do very much at the moment though for that we have to work inside of monster stats Sprite specifically we will need an update method with self and Delta time although Delta time we're not going to use so I will add an underscore first of all we want to fill the entire image with colors and white after that we basically want to draw three bars one for the health one for the energy and one for the Readiness or in other words if this is the entire image or rectangle I have of those we want to have some health text here and then a health bar below that we want to have the energy text along with the energy G bar and finally all the way at the bottom so this line here I want to have a Readiness bar so how far away the monster is from being ready to attack now two of these attributes we already have all of the monsters have health and energy but there's no attribute to track how ready the monster is for that below the energy I want self dot I call this one the initiate if which by default is going to be zero and later on we will increase this number once it reaches 100 then the monster is ready to attack the speed by which that happens is defined for each Monster by the speed I.E if you look at all of the monsters there we have a speed attribute but that's going to come later for now initiative can always be zero after that inside of the update method we want to look for free attributes which we are going to do via a for loop I want for data in self. moners sprite. Monster and then get the info that I need which is a method that doesn't exist right now which means we have to work inside of the monster and then create a method called get info no need for custom parameters on this one and basically what we want to get and let me return the value right away we want to get a tupal that consists of three other tbls in which we first of all have self. health and then self. get stat with the max Health the next entry is going to be another tupal that is going to be very similar in fact I can copy it we want to have self. energy and self. Max Energy finally for the Readiness or the initiative we want to get self. initiative and the max value for this one is going to be 100 or in other words since we want to display a bar for this info we always need the current value and the max value which is what we are getting from this get info on top of that I want to know what index we are on for which I can use en numerate after which I'm getting an index along with the data the data here we can separate right away into a value and a max value just to keep all of this a bit more readable after that I want to get the color for each of the bars for which first of all I want to create a list where the first entry is colors and red then colors and blue finally colors and gray this is simply going to give us three of the colors that we have to find inside of settings one of those colors from that I want to pick one item via the index now we know from get info the first item that we are getting is going to be the health IE via the color here we getting the first element which is a red color after that I want to have two sep seate pieces of logic for the bars the health bar and the energy bar or in other words the first two bars are going to be drawn with text in the center is of the Sprite which means we first of all want to check if index is smaller than two in which case we would get health and energy but now let's add pass in here and then we can add els for the initiative although this one also gets passed for now inside all of this for the health and energy bar we will need a text surface a text rectangle and a bar rectangle whereas for the initiative we will only need a let's call it the init rectangle and that we can then use to draw a bar using draw bar from support all the way at to the bottom there we want to use draw bar again which means we have to get a few numbers this part could actually be a good exercise I want you guys to display the stats for each monster the end result should look something like this for all of the monsters pause the video now and see if we can figure this one out for the text surface we want to get self. font and then render all of that for the text we want to display I want to have an F string with the integer of the Cur value after which we are getting the max value antialias should be false and for the colors I want colors and black next up we need the rectangle and for that I want the text surface get F rectangle in which I want to place the top left for that I will need a tuper with an X and A Y position for X I basically want the text to be on left side with a bit of padding which in my case I have set to self. re. wift Multiplied with 0.05 I we have 5% of whift to the left side or why I want to get the index and multiply it with self. rect do height divided by two now for the first item where index is zero this value is going to be zero I.E this text rectangle will be in the top left for the second item index is going to be one which would put this number in the middle of the Sprite finally for the bar rectangle I want to have py game. f rect with text rectangle do bottom left plus a vector of Z and minus 2 I.E the top left of this F rectangle starts in the bottom left with a bit of an offset then we need another tupo with the width and the height for the height I simply went with four pixels because it looked good for the Wii I went with self. dowi but I only want to get 0.9 of that I.E 90% after we have all of that we can get self. image. blit with the text surface and the text rectangle also we can draw the bar for which we are going to need a whole bunch of arguments let me copy the parameters surface is going to be self dot image rectangle will be the bar rectangle that we have just created value is going to be the value and so will be the max value also for the color I want to have the color we created up here and for BG color I want to get colors and black for the radio here I want to go with two and that should be all we need although I already spotted one mistake this shouldn't be gray with an E this should be gray with an a other than that if I now run main Pi we are getting a name error that in nit direct is not defined let's have a look we have to comment out this part and then add a pass in there that part we can cover in a second next attempt and there we go we have health along with a bar that is looking pretty good next up then for the ended rectangle we don't need pass anymore and now we have to create the init rectangle which once again is going to be a pame f rectangle for which we have a position and a size the size is actually the easier part let's start there the WID is simply going to be self. Rec do width and height is going to be two pixels I.E we are covering the entire width of the rectangle and then for the height we have a number that looks good for the position then the left side has to be zero and for the top I want to have an offset of two pixels from the bottom of the Sprite in other words self. rec. height minus 2 that is all we need for this part after that we can draw the bar for which we are going to need a whole bunch of arguments once again let me copy them we still want to draw on self. image although the rectangle is not now going to be the a knit rectangle we are still getting a value and a max value along with a color although for the background color I want to have colors and white also for this one the corner radius should be zero so let's try all of that and we cannot see anything that is because inside of monster the initiative is zero but once again we can define a random integer between zero and and 100 and then we can see some amount of Readiness for all of the monsters which is a really good start that means we are nearly done with the setup for the entire thing there's just one more thing that I want to do and for that let me run the game again I want to work a bit more with the drawing order or in other words the Sprite for the name at the level I want to have behind the monsters it just looks better later on this will become very important and generally for a game you always want to have control what is being drawn on top and what is being drawn in the background for that like we have done for the Overworld the main Sprite group at the moment is Battle Sprites and this is just a regular Sprite group that I want to customize so instead of a generic group I want to have a battle Sprites class which we have to create inside of groups we already have all Sprites in there but that we can collapse because next up I want to have a class called battle Sprites which has a parent class of py game. sprite. group we as always will need a Dunder init method with self and that's about it and in there we have to initialize the parent class and then I also want to get self. display surface which we get with py game. display. getor surface that's all we need in there next up I want to have a custom draw method inside of this draw method we will need a for loop with for sprite in self and just to reestablish the basic mechanic we want to get self. display surface. blit with Sprite do image and sprite. wct with that inside of battle. piy we can from groups import battle Sprites after that the game should still work just fine except now when we are calling the draw method we don't need to add in the surface we want to draw on I down here we don't want to display surface anymore after that things should be working and they don't we get the issue that the battle spread object has no attribute display surface that happens inside of group so we do not have this display surface and I see the issue the init method has two many underscores but now there we go everything works just as before that is a good start so now we can work on the drawing logic I.E we can sort all of the Sprites which we are going to do once again by using a sorted method for which we already have a list that can remain self after that we will need a key which is going to be a Lambda function with a Sprite and then for every single Sprite we want to get a sprite. z attribute and Via that we are sorting all of the Sprites now at the moment the Sprites do not have a z attribute that part we do have to add which means at the moment we have four Sprites inside of this class and also inside of settings we have battle layers which is going to work kind of like the world layers in the sense that we're going to give every monster a number and then the higher the number is the later the monster will be rendered IE the fervet is going to be on top you use that inside of Sprites the monster Sprite is going to get self. Z which we get from battlecore layers and monsters should always be on the monster layer after that we can copy the entire line next up inside of monster name Sprite in the dund method I want to put this Sprite on the name layer which is going to be below the monsters next up the monster level Sprite is also going to get a z attribute and we are going to keep this this on the name layer finally for Monster stat Sprites we will need to that attribute again although this one we always want to have on top of the monster I.E on the overlay layer which is going to be on top of everything else that way we can always see the stats of the monster which is probably a good idea so with that if I now run main. Pi we can see that the name and the level are behind the monster also with that we have more control which is going to become important later on but anyway this is some pretty good progress next up we can work on making all of this interactive all right so at this point we have set up the entire thing how can we make it interactive and that is going to involve quite a few different things most importantly for now we have to make sure that the monsters update their initiative and then once they are ready we can select different options there's going to be an attack defense switching a monster or catching a monster and if we select attack or switch then we should get another menu with all of the available attacks or all of the available monsters that's what we are going to work on for now it's going to be quite a bit let's Jump Right In inside of the code we want to look at our monster because in there we have the initiative and this number we have to update Also let's set it to Zero by default to update this number I want to create an update method all the way at the bottom Define update for which we are going to need self and Delta time in there we want to check if not self. I.E later on we want to have control if the monster is updating or not which we're doing via an attribute which does not exist at the moment let's create it in the dunder Ed method self dop is by default going to be false although I guess this pause should be all the way in the top that it's a bit better organized anyway after we have that if the monster is not paused we want to update self. initiative and increase it by self. getet stat and the speed multiplied with Delta time this method we now have to call which is going to happen inside of the Sprite that contains it I.E monster Sprite this thing already has an update method which we can use self. monster. update with Delta time that should already be it to see something in the game and there we go now all of the monsters are getting ready with some getting ready faster than others and Lavia especially takes forever but that's okay with that in place I want to add a comment inside of the battle class let's call this one the actual battle system and the first important part that we have to work on is a method called check underscore active no need for custom parameters and in there we basically want to look at all of the monsters and then check if they are active for that first of all we want to get all of the Monster uncore Sprites which we get from self. player Sprites do Sprites plus self. opponent Sprites do Sprites Sprites you have to add so you can add two of these groups together without that it wouldn't work next up for all of the monsters we want to check if monster sprite. monster. initiative is greater or equal to a 100 if that is the case we want to do something and during that time all of the monsters should be paused for which we first of all want to self. update all monsters and then put them in a pause State this update all monsters doesn't exist at the moment which means Define update all monsters with self and the option that we want to go for this one can only really be pause or resume that's all we are doing in here for that once again I want to get all of the Sprites which I have already done so let me copy the line I want to get the monster Sprite do monster and in there update the PA attribute it will be true if the option is equal to F if that is not the case we only have two option it's going to be false this method we now have to call inside of update and let's organize this method just a bit better I first of all want to do all of the updates and then I'm going to draw things so to add some comments we have the updates and we have the drawing logic after we are updating all of the Sprites we want to self. check active with that if I run main.py we are getting an error that happens inside of check active because this should be monster Sprite next attempt and there we go the first monster has reached the ready state so all of the other monsters are pausing that is looking pretty good that means we don't need update all monsters anymore and next up I want to do a bit more inside of check active first of all monsters sprite. monster. initiative should go back to zero after that I want to do two things first of all I want to get the monster Sprite and then highlight it which I'm doing via a method set uncore highlight and this one should be true on top of that I want to get a self. current uncore monster and set the monster Sprite to it this is going to become important in just a bit because that way we are controlling the current monster for that inside of Thunder init I want to create another section let's call it control in there at the moment we only want to have self. current monster which by default is going to be none but later on once the monster is ready it's going to be inside of this attribute and that way we have a bit more control over it so for example we can get the attack moves from it we can switch it we can kill it things like that that's going to come later for now though we want to highlight the current monster once it gets ready which means we will need a set highlight method that doesn't exist inside of the Sprite right now so we have to create it although it's not a terribly difficult method set underscore highlight with self and a value and ultimately all that we are doing is self do highlight is going to be the value for that we will need self. highlight as an attribute by default it's going to be false let's run main notp to make sure things aren't crashing and that is still looking pretty good but obviously we can't see anything so once the monster is ready I want to give it a white outline to highlight the monster I want to have something like this where we have a white outline for every single one of the monsters once they get active now creating this isn't the easiest thing in the world let's cover the theory first we will start by getting all of the Sprites of the monster and then we are filling every visible pixel with a white color and then finally we are going to move that new Sprite in all eight directions IE if this is the original monster we are moving it by some pixels to the top left and then we are getting a new monster image that is something like this after that we are going going to the top and then we have another monster that is somewhere here and this we're going to do for all of the eight possible directions the end result of that is going to be that we have an expanded Sprite that is going to look something like this I.E for all of the sides we have a few extra pixels which is going to give us this outline if we have the new Sprite behind the monster that's all that we are doing in here to create all of that I want to work in side of import assets specifically in the monster frames and I want to add an entry after we have created all of the Monster frames I.E monster frames and then I want to have the outlines or which we are going to create an outline Creator which is going to need two arguments the frames you want to get and then the width I eat the width of the white line around it the frames are going to be self. monster frames and we want to get all of the monsters for the WID I went with four pixels but that you can customize on your own I want to work on the outline Creator which I have put inside of support all the way at the bottom of the import functions Define outline Creator which has a frame dictionary parameter and then the with just as before we want to start by creating a new dictionary I call this one the outline frame dictionary by default this one is going to be empty and then for monster and the monster uncore frames in frame dictionary do items just to make sure you see what we are getting let me print the monster and the monster frames if I now run all of this we get a pretty substantial dictionary but in there we first of all have the monster itself the associated key is then going to be a dictionary with an idle animation and with an attack animation and basically we want to go through every single one of these surfaces and then fill them with a white color and expand them first of all though I want to get the outline frame dictionary create a new entry with the monster and Associated value is for now going to be an empty dictionary after that we can go with another for Loop for state and frames in Monster frames do items i. we're getting out of the states and the associated frames from the monster frames once we have that we want to get the outline frame dictionary again along with the monster inside of this new dictionary we can create a state key along with an empty list in this list we are going to store all of the frames for that first of all though we have to work with all of the frames which we do with four frame in frames and then we want to create a new Surface which we do with pame DOs surface for this thing we will need a tuple with width and height and essentially we want to have the same size as the frame in the original animation but since we are going to expand it it should be slightly larger as a consequence I want to create a vector of frame. getor size and do not forget to call this one to that number I want to add a vector with WID divided by two that way we are getting the size of the original surface via get size and to all of the sizes we are adding a Whi I.E we have a Whi up there there there and there after that we want to get a white I call this the white frame because we are basically taking all of the frames and then making every visible pixel white which we can do via a mask I.E py game. mask. from uncore surface the surface we want to use is the frame and this we want to straight away convert to a surface Now using a mask in py game is slightly more Advanced and I have made a whole tutorial on it if you want to know all of the details check that one out but essentially a mask is simply going to be a silhouette of a surface I.E if we have a visible pixel we have a white color and if we don't then we're getting a black color most of the time you're using this for Collision detection but you can also turn it back into a surface and then you have a black and white image which is what we have gotten from the white frame although we want to get rid of all of the black pixels which means white frame do setor color key and we want to get rid of all of the black pixels after we have that I want to get the new Surface and then blit the white frame in a certain position the first one would be zero and zero that would be the top left and I really want to draw what we are doing here so we have a new Surface that is a bit larger than the original frame I.E we have something like this and there at the moment we are taking the white frame and pasting it all the way in the top left this would look something like this so if the original Monster was right in the middle then this offset would give us an outline in the top left something like this in fact I believe the best way to demonstrate how this is working is by first of all returning the outline frame dictionary that way we have one part of the outline inside of the monster frames that we can use in the battle class we don't need check active anymore but when we are creating a monster I want to create one more class which is going to contain all of the outlines so right below the monster Sprite I want to create a monster out line Sprite Which is going to need the monster Sprite it will be in self. battle Sprites for the frames I want to have the outline underscore frames that's all we need in there although first of all we will need the outline frames those we are going to get like we have gotten the frames for all of the monsters in the first place I and there I want to have the outline frames which we first of all forget with self. monster frames there we have out lines from which we want to pick monster. name also really important if we are on the monster side we want to flip all of that which means we want to overwrite the outline frames with basically the same thing we have done for the original frames in fact I can copy all of this the only difference is that we now want to look at the outline frames. items so with that we have all of the arguments for the monster outline Sprite that means inside of Sprites right below the monster Sprite I want to have another class monster outline Sprite Which once again is pam. sprite. Sprite for Dunder init method I want to have self a monster Sprite the groups and the frames we want to dis play next up I want to have super Thunder innit with the groups and we're also going to need self. Z which we are getting from the battle layers and this one should be on the outline layer we want to store self. monsters Sprite as Monster Sprite and then self. frames is going to be frames once we have that we can actually create the Sprite we want to have self. image and self. rectangle for the image we want to have self. frames now for the state I want to look at the monster Sprite basically for this monster outline Sprite I always want to have the same state and the same frame index from the monster Sprite that why we are linking the animations which means for frames we will need self. monsters sprite. State and basically we getting this state next up we we will need the frame index and for that we have to change a few more things although that we can do inside of the animation first of all for the indexing I want self. monster sprite. frame index after that for the rectangle self. image. getf rectangle I want to place this Center to wherever self. moners sprite. rec. Center is now we just have to figure out inside of battle. Pi once a monster is ready we want to display the outline that we are going to do inside of the groups basically we want to check for all of the Sprites if sprite. Z is on battlecore layers and the outline I.E we are only looking at the outline layers and if and if it is not the case we are simply drawing all of the Sprites however if that is the case we want to get the Sprite and then look at the monster uncore Sprite remember Sprite is the outline Sprite the one we have just created which we don't really care about we want to know if the monster Sprite is selected if this one is equal to the current monster Sprite then we want to self. display surface. blit with sprite. image and sprite. rectangle now current monster Sprite we do not have available although that we can get via the parameter I.E inside of battle. Pi when we are drawing everything we want to pass in self. current monster after that we should be good to go although I did realize that we are not importing the monster outline Sprite but once we have that inside of main. Pi we are getting list index out of range that happens inside of this line where we are trying to assign a surface to the image to diagnose what's going wrong here let's print self. frames if I now run main. pi and scroll up a bit we can see that we have a dictionary for the frames but there are no surfaces inside of the list that is an issue that happens inside of the outline Creator function to fix that all we have to do is get the outline frame dictionary then the monster along with the state and append the new Surface the one with the outline and the white monster let's try off this again and now there we can see something so this is definitely making progress and also when we are printing the dictionary we are getting a whole bunch of surfaces that is definitely making progress and let me run all of this again once the first monster gets ready we get a whole bunch of black stuff around it that we can get rid of in just a second they really important part for now though is that we have a surface with a minor offset that is what we actually want and I think this part is getting a bit confusing so let me go over it once again we start with an outline Creator in there inside of support we are looking at all of the Monster frames and for all of those we are basically expanding the original surface and filling it with a white color these new surfaces we are then passing into another class monster outline Sprite which in turn is linked to monster Sprite also we don't need to print statement anymore so this monster outline Sprite has basically the same frames as the monster Sprite I.E the frames inside of this class are the same as the monster Sprite except they're white and a bit expanded after that once a monster is ready we are setting it to the current monster and then when we are drawing all of the Sprites inside of groups we are checking if a monster is currently selected and then we are displaying the outline Sprite behind it for for the logic you might have to go over it a couple of times it does get a bit more complex anyway the first thing that I want to do is get rid of the black background that doesn't look good for that inside of the new Surface I want to add another argument pame do SRC ala after that new surface. bill with a tup of 0 0 0 and zero I this new Surface is entirely invisible if I now run main Pi again we only get the white color and that's already looking pretty good we just have to get all of the other sides as well so inside of support I want to duplicate this line and then cover another side which I can for example get with whift and zero if I now remain not P again we are getting two sides and well this we basically want to do for all of the other sides and let me get rid of the comment besides whiff I also want to get wi time 2 that way we getting to the top right next up wi * 2 and wi that would be the center right and after that with * two for both arguments this will be the bottom right Next Step we want to have the bottom this would be whift and whift time 2 after that I want to have zero and wi * 2 and finally zero and Wii this would be the left side those are going to be all of the eight sides so 1 2 3 4 five 6 7even and eight looks good if I now run main. pie and the monster is ready we get a white outline that isn't animated yet so we do have a start but we need just a bit more inside of the monster outline Sprite we want to add an update method so Define update self and Delta time although Delta time we don't actually need let me add an underscore instead after that we want to get self. image which we're getting from self do frames then I want to have self. monsters Sprite do state and you might also be tempted to use self. monster sprite. frame index although for all of that to work we will also have to cover the integer and the modulus I.E let me copy actually all of this and then paste it in there now this we have to update we want to get the frame index from self. monstore sprite. frame index after that let me copy this self dooners sprite. frames and then also self dooners sprite. state with all of that we are already getting a really long line which isn't ideal but inside of main. Pi we are getting an animation so this is kind of working but not exactly something I like because this just feels a bit clunky instead inside of the monster Sprite when we are animating all of that I want to get a frame index that we can use inside of the outline Sprite all we really need in there is self do I call this one the adjusted frame index which is going to be the integer of self. frame index with modulus of the length of self. frames with self. State this is basically the same that we are doing on the next line in fact we can simply pass self. adjusted frame index in there and now that we have that we can get this self. adjusted frame index and pass it into this indexing operation by self. monster Sprite do adjusted frame index the result should be the same and that is looking pretty good and now the logic inside of the monster outline Sprite is also much more readable cool with that we know if a monster is selected however there's one more thing that I do want to do and that's going to happen inside of the monster Sprite you might actually be wondering why did we set set highlight because inside of the group when we are highlighting the monster we are checking if the monster Sprite is the current monster Sprite why don't we just check if the monster is highlighted or not the reason for that is that later on we are going to have quite a few more conditions in there and this is going to be the most efficient way of doing things we are however still going to use the Highlight value although only for a short bit once the monster is selected I want to always display the outline and then make the entire monster flash for a short bit let's say around half a second for that I want to work inside of animate if the monster is highlighted I.E if self. highlight then I want to get a mask again I.E I want to have let's call this one a white surface which we are once again getting from pame mask do from undor surface this surface that we want to convert is self. image and after we have all of that I want to go straight back to surface that way we are getting the silhouette from this silhouette we want to remove all of the black pixels I.E set uncore color key and I want to remove black finally self Dot image is going to be the White surface with that if I now run main. Pi we left the battle and now the selected monster becomes Pure White that is looking decent after we of that inside of the monster Sprite I want to create a bunch of timers timers and in there I want to have self. timers which is going to be a dictionary in which for now we have one timer to remove the Highlight this is going to be a timer that I don't think we have at the moment all the way at the top from timer import timer for a duration let's say half a second for the function we essentially want to call set highlight and then pass in the Boolean false value which we can do via a Lambda function in which want to call self. set highlight with a false value that way we can insert arguments without calling them after that inside of set highlight I want to check if value is truthy I.E if we are activating the Highlight if that is the case I want to get self. timers with the remove highlight timer and then activate all of that also what's really important inside of the update method we have to go for timer in. timers do values and then timer. update with that inside of main.py we are getting a white flash for a short amount of time and this might even be a bit too long let's change the duration to 300 milliseconds and now yeah I think that looks a bit better but once again play around with the numbers and just see what looks good anyway with that we can work inside of the battle class and I want to keep on working inside of check active I want to check if the currently ready monster is one of the players that I can do with if self. layer Sprites in Monster sprite. groups this means we are looking at the monster Sprite the one we getting for from the four Loop and we are checking all of the groups and if the player Sprites are inside of that group then we know that a monster Sprite of the player is currently ready just to test if this is working let's print player monster ready I can run main pi and now we get player monster ready that looks good so inside of this if statement we want to get some kind of option to display a menu which I have done via another ATT rute self. selection uncore mode which I have called General now for that to work we have to work a bit more inside of Dunder in it under control because in there we will need a few attributes the one we have already seen is self. selection mode which by default is going to be none and later on this one could also be attack it could be switching a monster things like that after that I want to have self. selection uncore site which by default is going to be player it could also be opponent if that's the case we can select the opponent monsters should be straightforward and finally I want to create self. index C which is going to be a dictionary with a bunch of values we have General with zero then I can duplicate this a few times because besides that we want to have a monster in index we want to have an aex index along with a switch index and finally a Target index all of this is going to make sense in just a bit but just to explain the outlines imagine for selection mode we have General the one we are setting a bit further down if that is the case we have the monster and then we want to display a couple of icons like so those will be for the attacks defense switching a monster and catching a monster the indexes we are then going to use to select one of these options or in other words if selection mode is general and the general index is zero we want to be up here in fact now that we have that I want to add another section I call this one the UI and there I want to Define draw General only for custom parameters in there we want to draw all of the general options and just for some extra context this is the end result where we have the four icons right next to the active monster for that we want to create a for Loop that covers every individual item and those we are getting from settings because in there we have battle choices we getting the full choice if we are fighting a random mon monster and we're getting a limited choice if we are fighting a trainer the reason for that is if we are fighting a trainer there shouldn't be a catch option that one is only available for random monsters we want to get the battle choices but now let's call this data in battle choices and print what we get although to actually see the output we have to figure out when to call this method and for that I want to have another method Define draw UI basically in there I want to check if self. current monster exists and if that is the case I want to check if self. selection mode is equal to General if that is the case I want to call self. draw General this draw UI method we are then going to call inside of the update method on top of everything else self. draw UI well now if I run the code and the monster gets ready we are getting the different keys inside of the dictionary so at the very least we get something but this isn't ideal I suppose for a bit more detail we could add items and then we get a little bit more information but we have the other dictionary with all of the positions along with an icon at the moment I always want to get the full amount on top of that I want to get the index via enumerate that way I will get the index and then inside of a tupo the option and a data dictionary and just to visualize all of that I have the index I have an option and I have a data dictionary oh and also don't forget after the full dictionary we want to get the items if I now run main. pi we are getting all of the options so in there we have zero fight one defend two switch and three catch along with a position and an icon we want to display that is all the information we need so now we can draw a bunch of surfaces and those surfaces we actually already have because inside of main.py we have imported all of the UI icons if you look at the project folder under graphics and you are we already imported this folder and in there we for example have the hand we have a hand highlight we have a shield a shield highlight and a sword and a sword highlight oh and also the arrows for switching a monster those are the icons that we want to use which means I want to get a Surface and this I get via self. monster frames and then I want to get the UI the key I want to pick is what I'm getting from data dictionary and the icon so if you look at settings there we have a dictionary with a position and an icon after that we can create a rectangle which is going to be surface. getet uncore F rectangle where we are placing this Center and essentially I want to get self. current monster. rec. mid right Plus data dictionary and then the key position the position here might not be the best name it's more of an offset where we getting the right side of the monster and then adding these numbers anyway once we have all of that we can call self. display surface do blit with the surface and the rectangle if I now run main. pi and the monster gets ready we get the options they don't do anything at the moment but at the very least we can see something now before recover the input there are two more things that I want to do number one the currently selected icon should have an outline and then every other icon should be grade out so the player has an idea of what is being selected now this is going to be much easier compared to what we have done with the monsters because if you look at the UI folder there we have for example the shield and then a shield highlight or in other words if the current index is equal to the selected index then we wanton want to display the icon with the outline and then gray out everything else for that we have to work a bit more with the surface for which I want to add an if statement if the index is equal to self. indexes and the general index which at the moment is this one so we're getting a zero I.E the first item should be selected which means this surface should be the data icon this would give us a value like sword or Shield but to that we want to add an underscore I think the easiest way of doing that is to turn all of this into an F string and then select the icon along with underscore highlight and if that is not the case else the surface should be simply the icon for now and then we also are not going to need the F string let's see if this one is working and this is a bit hard to see but now around the sword we have a white outline I suppose we could change the general index to a two and now we are getting a white outline around the switch symbol so that's working pretty well although this value should be Zero by default next up for this surface that is not selected I want to wrap all of this into py game. transform. grayscale that way if I run M notp again any icon that's not selected will be great out that's looking pretty good so now we can draw the general options but they don't do anything for that we will need an input method which I have put a bit further up I want to have Define input and I guess I should add another comment for all of this the first four methods would be the methods for input I want to have self and no other parameters and then we want to get all of the keys as always which we are getting with pygame dokey doget uncore justor press which we can then use with keys and for example py game. Kore down but now let's add pass in here because first of all I want to outline all of the keys that we need there aren't very many we have key down key up and py game. key space these are the only input options and the space key we can ignore for now essentially if the player presses K down then I want to get self. indexes along with self. selection mode I.E at the moment our selection mode is general that means we are working with this number which we want to increase by one if we are pressing up we are doing the same thing except this number should get minus equal 1 although we do have to be careful here if we don't have a selection mode which is the case by default this would give us an error so we want to only check all of this if self. selection mode and just to be sure self. current monster there should only be an input if both of these are true so all of this gets indented one more time and then we have to make sure that we are actually calling the input method let's do it before we are doing anything else self. input if I now run main.py we're getting the options and if I press down or up we are selecting a different icon that works reasonably well but I can go outside of this selection which shouldn't be the case so if you press up too much or down too much nothing is being selected to cover that part we will need a limiter which is going to happen inside of input basically what I want to check is via a match case statement I want to know what our current self. selection mode is if there is the case General then I want to create a limiter which would be the length of battle choices with the full amount so at the moment this number would be a four which is a good sign because I want to limit this number to a four so if we go to a five we want to go back to a one the way we are going to achieve that is we want to assign a new value which is going to be self. indexes and the general index and this we want to increase by one but on all of this we want to use modulus with the limiter this we want to do for down and up except for up it should become a minus one that should actually cover everything although I realize I have a typo there shouldn't be a white space before General let's run my. pi and then I can go down and if I go to index 5 we are starting from the beginning again so that is working really well now the UI is working significantly better once we have that we can check for the space key first of all in there we want to check what kind of selection mode we currently have which we do with if self do selection mode is equal to General if that is the case we can add a few more if statements to check what the current index is for example if self do indexes and general is equal to zero then we want to print a attack if this number is a one then we want to print defense if the number is a two then we want to print switch and finally if the number is a three then we want to print catch let's try that one and if I print space on Z we get attack then defense then switch and catch so we can select one of the options and that works Fairly reliable what we can already work on is the defense so the index being one if that is the case I want to self. update all monsters and then resume things on top of that self. current monster and self. selection mode should be none fin self. indexes and general is going to be zero that way we are resetting everything and now if I run main. Pi I can select defense and the game continues and then we are selecting an opponent that's not ideal for testing purposes that we can change inside of main. Pi for all of the opponent monsters I want to have a lower level let's say we can go with five three three and two that way our monsters should always be faster and then I get the other monster and this can also defend and we get our first Monster again so this part is already working quite well we are making some decent progress so next up we can work on the attack and the switch logic if the player selects the first option we want to set self. selection mode to a attack and then if the player selects number two we want to go with switch although I think the selection mode for attack is actually called attacks the one I have outlined up here so with that we can pick one selection mode which means we have to draw a few more UI elements we want to have Define draw a text with pass for now and we want to have the L raw switch with self and pass as well to select one of those we have to work inside of draw UI if self. selection mode is equal to a text then we want to call self. draw it text and if self. selection mode is equal to switch then we want to call self. draw switch and let's get started with the attacks for that we have to start by getting the abilities in the first place for which we want to get the current monster then monster and get ability the method that we already have inside of the monster we have use that for the index after that I want to set a height for the box which is going to be 200 I want to set the amount of visible attacks which I want to keep at four next up I want to set an item height which is simply going to be the height divided by visible attacks also we are going to need a v offset which for now is going to be zero and by the way the system that we are going to create will be very similar compared to the list that we have made for the index so so first of all we need the data after that I want to create the background for which we are going to need a BG rectangle which is going to be a pame f wct with a position and a size the position we're going to ignore for now so zero and zero for the size I want to have width and height with the height be being the height and I realized I didn't set a Whi let's do it in the data part Wii and height and this should be 150 and 200 that way we can set Whi and height in there right away this rectangle we then want to move to a position the point I want to place is the mid left which is going to be self. current monster. w. mid right plus and offset that I have set to Vector of 20 and zero I.E we are placing the mid left of this option to the right side of the monster plus 20 pixels once we have that we can call py game. draw. rectangle we want to draw on self. display surface the color we are getting from colors and white then we want to draw the BG rectangle we want to have zero for the Border width and then five for Border radius with that if I run main. pi and I select attack we are getting an area that we can use for the attacks very good start next up we want to display the actual attack options for that we will need for index and ability in enumerate ability for this one we want to have a text we want to have have a rectangle and then we want to draw all of this first of all though we want to know if the current item is selected which we are getting via index is equal to self. indexes and attex and for the text I want to have a text color and a text underscore surface for now for the text color let's simply go with colors and the one that I want to choose is called light then for the Tex text surface I want to get self. fonts with the regular font and render it with the ability then fults and the text color that way we are getting some text that we can display next up we will need to position that text which we're doing with text rectangle I want to get the text surface and then get f rectang angle in which I'm placing the center I want to get BG rectangle IE the background rectangle for the entire bit and the midtop of this point plus a vector that goes zero pixels left and right and to that I want to add the item height divided by two plus the index multiplied with the item height also Al to all of this we want to add the V offset although this one is zero at the moment and just to explain the numbers if this is the background rectangle we want to place the attack options let's say one here one here one here and one here and they should distribute the area equally so that we always have the same distance between them the way I have approached that is I first of all set a starting position which is the this distance and then to that we are adding index multiplied by the item height I.E if this is zero we are staying here if this is one we are going there if this is two we are going down here and so on with that we have a text surface and a text rectangle so now we can self. display surface do blit with the text surface and the text rectangle let's try main. pi and if I select the options we can see something although we already have the issue that there's an extra option at the bottom also nothing is selected and if I press down the game crashes because we do not have the limiter variable so let's go through all of this step by step first of all we have to reenable the input at the moment this limiter does not exist because inside of match case we are not checking for attacks that we can fix fairly easily case it attacks the limiter that we want to create create is the length of self. current monster. monster. getet abilities that way if I run main. Pi I can at the very least press up and down although it doesn't do anything at the moment but at least the game doesn't crash anymore inside of draw attacks there are two things that I want to do to highlight the currently selected attack I want to change the Tex's color and then add a background for that we want to check if selected then we want to get a specific color however if that is not the case else then we have the basic text color for more specific color I want to get colors and then use the element of the attack let's store that one in a separate variable element this one we can get from the attack data that's currently not available for that all the way at the top I want from gamecore data import a TCH data we are importing this dictionary that we can use and let me minimize everything inside of draw attacks we have the attack data and then we have the ability from that we want to get the string element and that ele element we can now use inside of the colors to create a textor color or rather a more specific text color for the text surface let's try main. pi and now inside of attack we are getting something but the selection doesn't really work something has gone wrong and I believe I know what the issue is inside of input when we are assigning a new Index this shouldn't be General Instead This should be self. selection mode that way we can use different kinds of selection modes or rather different selection indexes or Draw attacks we are using the attack index so with all of that let's try it again and now I can kind of select all of the attacks there's just one issue and that is the color for the normal attack just doesn't work well that is because the element color for the normal attack is a pure white which I don't really like to fix that I only want to get the element color if the element is different from normal if that is not the case else I want to get colors and black and with that if I now run main. Pi we're getting a black color which feels much better although I also want to have a background color below the text rectangle I want to create a text BG rectangle pame dot f wct for which we will need a position and a size position doesn't really matter so we can go with zero and zero for the size I want to have the width of the entire thing and then the item height after we have all of that I want to call move to to move the center to the text rectangle Center this rectangle we then want to draw which we do with py game. draw. rectangle self. display surface for now let's go with a red color and then text BG rectangle after that we have a bit too much red the issue here is that we are drawing this rectangle for every single element which is incorrect we only want to draw it if selected let's try that one again and now there we go this looks much more noticeable it doesn't look great but well we have something the most notable issue is that the red color just doesn't fit well to get a better one I want to access the colors dictionary I want to use the light color for this one and now inside of main. Pi we are getting a color although I think this one is quite dark so maybe not ideal instead inside of settings I want to add another entry that you are already going to have I call this one dark white with a hex code of F0 F0 and F0 you should already have this entry I simply forgot to add it that's right now and that is looking much better there are two more things that we have to cover number one is this last item at the bottom shouldn't be visible and if we go further down there should be a scroll effect like we have done for the list inside of the index first of all when we are drawing all of the elements we only want to draw things that are inside of the BG rectangle which means I want to check if BG rectangle do Collide point with text rectangle do Center on top of that we want to check and seed inside of this if statement we still want to check if an item is selected and then there we also want to do the blit operation that should already do a bit if I now run this again we cannot see the last element anymore so progress but not ideal to fix all of that we have to work with the V offset this one should only be zero if self. indexes and it Xs is smaller than the visible attacks if that is not the case else it should be negative self. indexes and attacks minus the visible attacks plus one all of that we want to multiply with the item height the very same thing we have done for the index let's try this one and now if I scroll down we are getting all of the elements so that is looking really good perfect the last thing that is a bit weird is the corner radius that we have to fix inside of the drawing when we are drawing the text BG rectangle inside of selected we want to check if text BG rectangle. Collide point with BG rect do top left I we know we are at the top if that is the case we want to draw the entire thing with a border width of zero a general Corner radius of zero as well then five and five for the top left and top right next up we have an L if statement where we are checking if the text PG rectangle collides with the BG rectangled mid bottom although to that I want to add a vector of 0 and 1 if that is the case I want to draw another rectangle we want to have zero for the Border WID the top left and top right should be zero and zero but the bottom border radi should be five and five after we have all of that else we simply want to draw the general text BG rectangle and with that I can run all of this again and that is feeling pretty good so with that we're getting all the attacks and we get the attack type that is making a lot of progress there's just one more thing that I do want to cover and that is that all of these attacks have a cost and we should only display the attacks that are available or in other words if you look at game data they can see that all of the attacks have a cost and if this cost is greater than monster dot energy then this attack should not be displayed to implement that mechanic we want to look at get abilities I want to add another parameter all that by default is going to be true and then if all is the case then I want to return what we are already returning however if that is not the case so else then I want to return all of the abilities that are available for this level but then I'm going to add a second condition and a tagore data something that we currently don't have available so all the way at the top from game data import monster data and attack data we want to check the one ability and then the cost only if that value is below self. energy then we want to return it which means inside of the battle when we are getting all of the abilities that happens all the way down here I want to set all to BS the same thing we have to do inside of input when we are getting the abilities there all should also be false now inside of the game this is going to be a bit hard to see simply because this monster has a huge amount of energy and all of these attacks don't take very much but for example for heal we could increase the amount by a lot so that to heal cost could be 600 more than the monster even has so now if we run main. Pi this one shouldn't be visible and it is not so this one is working and also with that we have finished the draw attacks method it doesn't actually do anything at the moment but that we're going to cover in the next part before that I want to cover draw switch that part is going to be your exercise I want you to create the switch menu you only have to display it like we have done for the attack menu the actual functionality is going to come later and the end result should look something like this so pause the video now and try this one on your own to get started we want to declare some data I want to set a height and a width those numbers can be fairly subjective but I went with 300 and 320 then we want to have the amount of visible monsters which I have set to four after that once again we want to have an item height which is the height of the entire menu divided by the visible monsters next up we will need a v offset that we have done a couple of times by now so I can implement the entire thing straight away zero if self. indexes and now we are working inside of the switch index and we only want to get zero if this number is below the visible not attacks but monsters else we want to get Negative self. indexes and switch minus the visible monsters + one which we want to multiply with the item I after that we can create a BG rectangle which is a pame f rectangle for the position we can as always go with zero and zero and for the size I want to have the width along with the height then I want to move this thing to a certain position which in this case will be the mid left is self. current monster do W do mid right plus a Vector of 20 and zero that is going to give us a BG rectangle let's draw it right away py. draw. rectangle self. display surface the color is going to be colors and white and finally we want to draw the BG rectangle let's try main. pi and now if I select switch we are getting an error because of a typo this should be Pi game. F rectangle next attempt and there we go that looks pretty all right I suppose the one thing that we do want to add is zero for Border width and then five for Corner radius after that we want to get all of the available Monsters the way I have approached that first of all I want to get all of the active monsters inside of a list or in other words I want to have the monster Sprite for Monster Sprite in self. player Sprites although I don't actually care about the Sprite itself that I want to have monster sprite. index and monsters sprite. monster that way we get the index of the monster and the actual monster data basically the same thing that we are getting up here or rather we're getting something like this where we have a monster along with an index to identify it that is really important because later on we want to switch to monsters so we have to know exactly what kind of monster we are working with although if you didn't include it for this part in the exercise don't worry too much about it that wasn't really part of the exercise after that I want to get self. available uncore monsters which has to be an attribute l on inside of the input that will become important we want to create a dictionary with an index and a monster for index monster in self Doge monster data of the layer with that we are copying all of the Monster data but that we only want to do if a certain condition is true and also from the player monsters we want to get the items but we only want to get all of that if the index and the monster are not in active monsters and I suppose also while we are here and monster. health is greater than zero if the monster has been defeated there's no point showing it but that's not too important for now anyway with that we are getting of the available monsters which we can then use inside of a for Loop for index and monster in a numerate self. available monsters. values to get started we want to know what item is selected which we're getting with index equal self do indexes and switch next up we will need an item BG rectangle this is the equivalent of the text PG rectangle of the last part I.E I want to have an F rectangle the position is going to be zero and zero and the size is going to be width and the item height this we want to move to a specific point or in other words I want to place the mid left of this rectangle the X position is always going to be the left side of the background I.E BG rectangle do left for the Y position I want to have the BG rectangle do top plus item height divided by two to set a start point and to that I want to add the index multiplied by the item height and don't forget to all of that we want to add the V of set quite a long line but I hope at this point you understand the logic after that I want to create an icon surface and I can rectangle a text underscore surface and a text uncore rectangle we want to display the icon of the monster and then its name for the icon surface I want to get self. monster frames with the icons the data we have imported earlier and then get monster. name for the icon rectangle I want to get the icon surface get F rectangle and place the mid left point for the Target position I want to have a BG rectangle dot top left plus a vector of 10 for x or why I want to get basically all of the stuff that we have done here except BG re. top so let me copy it in there that way we always getting to the vertical Center for each increment next up we have to text surface that one's a bit easier we simply want to get a font self. fonts and I want to use the regular one and then render an F string with the monster. name and then in parentheses monster. level for antialias we want to have faults and for the color I want to get colors red but only if selected and else it should be colors black or in other words we are simply picking one of two colors depending on the monster being selected or not finally we have a text rectangle which we're getting from the text surface. get F wed we want to place the top left to BG re. left Plus 90 and for the vertical point I can rect dot pop now for the drawing logic I want to have a for loop with surface and rectangle in the Tuple that contains two TS I can Surface and I can rectangle after that we have the text surface and the text rectangle in inside of this for Loop we can then run self. display surface. blit with the surface and the rectangle quite a bit of stuff let's run main.py and let's see what crashes first if I go to switch we can see them monsters but if I press down the limiter doesn't exist so not ideal for that we have to work inside of input and then add another case for switch for the limiter I want to get the length of self. available monsters let's try all of this again if I may now go to switch we can see all of the monsters that are available let's looking pretty good also the selection works just fine quite happy with that I suppose the one minor thing that doesn't look terribly good is when we are getting the monster name X surface I want to have a space between the monster name and the level a super minor point I suppose there are two more major points that I want to cover first of all I want to have a selection background so it's a bit more visible what is being selected for that if selected is the case then I want to check if the item BG rectangle do Collide point with with BG rectangle. toop left or any point at the top to be honest if that is the case I want to run pame do draw. rectangle self. display surface for the color I want to have colors and dark white finally then we want to have the item BG rectangle and there's one dot too much of Z and1 if that is the case I want to draw another rectangle although now zero for top left and zero for top right that way only the bottom has a corner radius finally if neither of those conditions are true then I want to draw the item backround rectangle without any Corner radius let's try all of that and there we go so with that we can see a bit better what item is being selected next up then I first of all want to make sure that we don't see more than four monsters which at the moment isn't really the case because we only have four more monsters and most of them don't have any health I suppose I could add a few more with a high level like so and if I now run all of this again when we are selecting the monsters we can see too much so this isn't great to fix that we want to have another if statement if BG rectangle do Collide Point item BG rectangle Dot Center or in other words only if the center of the BG rectangle is inside of the main rectangle do we want to draw anything with that I can only see the monsters inside of the rectangle so that's working pretty well finally the last thing I want to do in here is I want to display the health rectangle and the energy rectangle for which we're going to need two rectangles Health rectangle and energy rectangle for both of those I want to have a pame do F rectangle for the position of the health rectangle I want to have the text rectangle do bottom left and to that I want to add a vector of0 and four simply to add a bit more padding and then for the size I want to have 100 and four once again numbers that simply look good for the energy rectangle the position is going to be the health rectangle dot bottom left with a vector offset of 0 and two the size of this one is going to be a bit less let's say 8 80 and4 finally we can call draw uncore bar again which I don't think we have at the moment which means I want from support import draw bar and this class is already getting quite massive but anyway for a draw bar we are going to need a whole bunch of arguments so let me do both at the same time we want to draw on self. display surface the rectangle is going to be either the health rectangle or the energy rectangle the two rectangles we have just created for the value we will need monster. health and monster do energy then we will need the max value which is going to be monster. getet stat with the maxcore health for energy we want to get the same thing except it should be Max Energy and then we need to color for the value which is going to be colors with something that we will cover in a second and then the background color for both of those is going to be black now for the health bar rectangle I want to have a red color and for the energy one I want to have a blue color that should be it if I now run main. pi and I select switch we are getting all of the monsters along with the health and their energy so that is looking pretty good quite happy with that we are nearly done the last thing that I want to cover is going to be inside of input the issue that I want to fix is if the player is inside of the attack mode or the switch mode and then wants to go back then well there's no way of doing that to fix that we want to add one more input statement which is to be on this same indentation level as the space key I want to check if keys and py game. kcore escape and in there I want to check if self. selection mode is in a text switch or Target this one we haven't seen yet but it's basically for targeting an opponent or one of your own monsters for healing if this if statement triggers then we want to set self. selection mode back to General so with that I can run the entire thing I can click on attack we still got the same options but if I press Escape we go back to the selection menu and then we can select other things like defend and this still works really well cool with that we are done with this part and for the next bit we can start implementing actual functionality in this section we are going to finish up the the outlines of the battle system I.E we are actually able to attack the opponents the opponents can also attack us we can switch monsters we can catch an opponent monster we can defend and all the basic parts of the battle system so by the end of this part we basically have a game to get started I want to keep on working inside of battle specifically inside of the input method at the moment we can go from the general selection to the attack mode but then inside of attack we can't really do anything which means I want to add another if statement and this one has to come before this if statement for the general mode I'll explain in a second why in there I want to check if self. selection mode is equal to a Tex if that is the case there are three things that we want to do we want to set this selection mode and this we can do right away in code self. selection mode should now be Target I.E we are targeting either an opponent or one of our own monsters besides that we want to have a self. selected this one doesn't exist yet and we want to have self dot selection site this one we have created earlier inside of thunder in it selection site by default this one is player and just to add the one additional attribute self do selected attack by default this one is none so we don't need thunder in it and then we have to figure out the selected attack and the selected side to get this selected attack we want to get self. current monster monster get abilities and for this one we only want to have the available ones I.E all should be false this is going to give us the same list for the tag moves that we have seen in the menu which means if we are using indexing with self. indexes and a tack then we are going to get the same attack let me comment out selection s and simply print self. selected attack if I now run main. Pi the game doesn't crash that's a good start and if I now press space we get scratch and then things disappear and we are getting a limit problem because now we have switched to the selection mode Target let's comment this one out for now actually and run all of this again now I can select different attack moves and they line up with what we are seeing in the menu so this part is working quite well let's try another monster we get scratch fire battlecry and explosion so that is working well with that we can get the selection mode for Target again remove the print statement and then I want to select a selection site I.E are we targeting the opponents or our own monsters that we can get via attack data and then self. selected attack if you look at attack data there we have a Target which can either be opponent or the player and well the only two attacks that we have that Target the player a heal and battlecry everything else targets the opponent either way we want to get the Target and if that selection mode is selected then we don't want to have a UI element we simply want to pick one of the opponent monsters but first of all for that we will need another case for a new limiter the case I want to Target is called well Target and then we need to create a limiter which should be the length of self. opponent Sprites but only if self. selection not mode but side is equal to opponent if that is not the case else we want to get the length of self. player Sprites or in other words we want to know how many opponent monsters there are or how many player monsters there are that is all we need in here there's just one more thing that I do want to cover and that is that we will need this selection mode for attacks before the selection mode for General let's go through this thing step by step first of all we are pressing space while having some kind of index by this index inside of selection mode we know what option we want to pick for example if the index is zero we want to go to attack and let's stick with that case so at the moment once we get to this point we are continuing the code and nothing is going to happen but on the next for Loop of the game we are getting to the attack mode and none of the selection mode General is being triggered however if that was flipped around if we did all of this first and then this part second we would still check for pame dospace along with an index then we would trigger the attack but then we are going straight to the attacks because those come right after and because of that we would trigger an attack right away and having the right order of the if statements is I think the easiest way to solve that you could also work with L if statements but that could cause some other issues down the line anyway for now we want to Target some opponent monsters we don't have to worry about attacks anymore and general we also don't need next up I want to have if self. selection mode is is equal to Target for that first of all we want to know what spreite group we are targeting IE Sprite group should be a local variable that we're going to get from self. opponent Sprites if self. selection site is equal to the opponent if that is not the case else we want to have self. layer rights so now we have a couple of Sprites that we are looking at but then we have to be careful so imagine we have three opponent monsters one two and three and we want to select them via their index so this would be index 0 1 and two at this point you might be tempted to take this Sprite group turn it into a list and then use indexing so if our Target index is zero we get this one if the target index is one we get this one and so on that would not be a good approach simply because later on it is totally possible to defeat one of the monsters so this one wouldn't exist anymore and if we then had an index one we would get really confused so essentially we have to take this Sprite group and then create a custom list from that that has to be dynamic I call this one the Sprites and that is going to be a dictionary where we get Sprite and then the position underscore index as a key and the associated value is the Sprite itself for sprite in Sprite group the thing we have just created after that we can get an actual monster uncore Sprite Which we can get via the Sprites and indexing I want to have the list of Sprites do keys and on that use index in by yourself do indexes along with the Target and just to make sure this is working let me print it and then I will explain it in a bit more detail but let's try main. Pi if I have a monster ready I can attack and if I press space we get a monster another monster and another monster Sprite although we can't really see the difference I suppose what we should rather print is Monster Sprite do monster that's going to make much more sense if I now attack we get monster monster and monster along with the right name so that is looking pretty good that backs the question what happened here especially the last line I think is going to be confusing let's do a few examples the most important thing to understand is this Sprites which is going to be a dictionary where we have the position index and then the monster Sprite for example we could have a dictionary with 0 1 and two for the indexes and then each of those have a monster attached that is essentially what we have at the moment in our game the keys of this dictionary we are then going to turn into a list which means we have a list with zero one and two after that we're going to pick one of those keys via indexes from our Target index let's imagine our Target index is one that way we would get a one if our Target index was two we would get get a two so that way we're not really changing the number however let's do another example where this dictionary is going to have only two values we have one at index zero with a monster and then one at index two with a monster we only have a monster on top and a monster on the bottom the middle monster has been defeated after that once again we are turning the keys into a list so now we have a list with zero and two and now imagine that our index is one I.E we want to pick the second monster via this system this one is now becoming a two while an index of zero for the selection would still be a zero that way we always pick the right monster even if there are gaps among the opponent monsters or amongst the player monsters could also be a case anyway with that we don't need the print statement anymore and next up we have to actually highlight the targeted monster for that part we don't need input anymore and we want to work inside of battles Sprites do raw with the current monster so essentially the monster that we are currently targeting should have a white outline like we have done for the currently active monster to make that work we will first of all need a whole bunch more arguments and let's create the parameters first of all inside of the draw method besides the current monster Sprite I want to have the site I want to have the mode then I want to have a Target uncore index and finally I want to have the player uncore Sprites along with the opponent Sprites after that let me copy all of the parameters and then paste them after self. current monster the side that we are working on we're getting from self. selection site the mode is going to be self. SEL section mode Target index will be self. indexes along with the target after that we will need self. player Sprites and self. opponent Sprites quite a bit of data but that is what we need to highlight the currently targeted monster first of all though we have to do some setup like we have done before I want to get the available positions I want to get this Sprite uncore G Group which is going to be the opponent Sprites if side is equal to opponent and else layer Sprites with that we know what Sprites to Target and then like before we want to create a dictionary with Sprite Doos index and the Sprite for sprite in Sprite group and and finally I want to get the actual monster Sprite that is currently targeted Sprites stand indexing with the list of Sprites do ke along with the target index cool and with that we have a monster Sprite that means inside of this if condition we want to add a second line via or I want to check if the Sprite do monster Sprite and once again as a reminder the Sprite that we are working with here is the monster outline Sprite Which has one attribute that stores the monster Sprite itself which is what we actually care about if this is equal to the monster Sprite that we have gotten up here then we want to create an outline as well let's try that part if I now run all of this and I can select a monster we get an outline for the targeted monster so that is working really well quite happy with that so we are making progress also if I now press Escape we getting back to the attack options let's use the shield because I think this monster has battlecry this one should only target our own monsters that is also working well although for this part I want to disable build the monster highlight for the currently selected monster because without that the selection here looks a bit weird for that inside of groups when we have the first condition we want to disable this part if the player is selecting the player monsters which we can do via an end not I want to check if the mode is equal to Target and site is equal to the player or in other words we only want to highlight the current monster if we are not in Target mode and deci side is the player let's try that part and now we want to get to Chad Dillo and use battlecry and that is working really well now if I press space nothing is going to happen but we have a nice selection system which means next up inside of battle. Pi we want to work in the input method and let me hide all of the if statements that we don't need to make this a bit less confusing we still want to work inside of Target at the moment we are only getting the current monster Sprite that we have to use the player's pressing space and we are in the Target mode after that we getting a monster Sprite to Target and then we want to check if self do selected attack if that is the case we want to attack a monster because remember inside of selection mode attack we have gotten a selected attack later on we can also catch a monster then we have an else statement that for now is going to be pass we have selected a monster Sprite and we have an attack that means we want to attack that monster that unfortunately we cannot do immediately instead I want to get self current monster. activate uncore attack or in other words what we are going to do once we get to this part we want the monster to play an attack animation once that animation is over we actually trigger the attack which means we have to work inside of the monster and give it two arguments we want to have the monster Sprite or in other words the Target and then we want to have self. selected attack I.E the attack that the monster is supposed to execute after that self. selected attack self. current monster and self. selection mode should all be none that way we can continue to the next Monster so inside of the monster Sprite we will need a method called activate attack when Sprites monster Sprite we want to have let's do it right above update Define activate attack with self a Target Sprite and the attack and also let me minimize all the other methods so it's easier to see what's going on if that is the case I want to set self. state of the monster to ATT attack on top of that we want to set the frame index to zero that way we ensure we are always playing the attack animation from the beginning also we want to set self. Target undor Sprite to the Target Sprite that way we can reuse it later on and self. current uncore attack is going to be the attack both of these values we have to reuse in just a bit hence we want to store them inside of an attribute and for that to work properly I want to create them as well inside of the dunder init method which means in there I want to have self. Target Sprite none by default and self. current attack which is also none by default that covers this part and the last thing that I want to do is I want self dot monster. reduce energy depending on what attack we are using I.E once the monster has attacked we want to reduce the energy and that happens inside of the monster remember in here we are storing the actual information and for that we will need another method Define reduce underscore energy with an a attack and also we will need self the only thing that we have to do in here is self do energy minus equal the attack data e attack and then the cost of that attack which has to be a string or in other words inside of game data for the attack data we are subtracting this cost from the energy of the monster and that was quite a bit of code let's try main.py I can still select an attack and I can select opponents if I now Target one of them the energy of the monster should decrease once I execute that and it does we now have a bit less energy and the monster is playing an attack animation so that is working but now the game doesn't do anything anymore small steps I suppose we continue we have to work a bit more inside of the monster Sprite and we have to expand the animate method basically what we have to do if the monster is animating we want to apply the attack after an attack animation which means after we are increasing the frame index I want to check if if self. state is equal to a tag on top of that and self frame index is greater or equal to the length of self. frames and a attack so basically with this if statement we are checking if the monster is playing the attack animation and the animation has finished if that is the case we want to actually apply the attack which we cannot do at the moment but what we can do is set this state back to idle that way we are only playing the attack animation once let's try that part if I now attack a monster with a different attack we get an attack animation exactly once so that part is working so how can we actually apply the attack for that part we have a bit of an issue because we want to apply the attack inside of the battle class and there we have follow of the monsters now I guess inside of Sprites we would have the target Sprite that we are getting from activate attack we would have a Target but we also want to have the animations inside of battle really we should have the actual attack logic in there it also makes a whole bunch more sense for that I want to create another method Define apply underscore attack for which we want to have self a Target bright the attack that we want to choose along with the amount of damage for now let's simply print the target Sprite the attack and the amount of damage now this apply attack we have to get into the monster Sprite Which we're going to do when we are creating the monster there we have a monster Sprite Which is going to get one more argument which is apply attack for that to work inside of this class we will need apply a attack as well that we then want to store as an attribute self. apply attack is apply attack that way once the attack animation is finished we can call self. apply attack with the parameters we have just created Target Sprite attack and amount Target Sprite is going to be self. Target Sprite the attack will be self. current attack and then we need an amount for that we have to look at the monster because in there we have the attack damage let's call itself. monster get base uncore damage and for this part we want to know what attack we have selected I.E self. current attack as an argument and then inside of the monster class I want to have theine get base damage with self and an attack the value that we want to return is going to be self. get stat and attack I.E we're getting the attack damage and this we want to multiply with attack data of the attack and then we want to get the amount of damage or healing it does I.E if you look at game data we have the amount this we're going to multiply with the base damage of the monster or in other words self do gets that and attack is what we're getting from up here where we are getting the base set of the monster and multiplying it with the level this we are then going to multiply with the damage of the attack and then inside of Sprites we are applying that amount which means inside of battle we should get a value let's try and we are getting an error that name apply attack is not defined and that happens when we are creating a monster this should be self. apply attack when we are creating the monster Sprite next attempt and now if I choose scratch we get one attack animation and then we are printing the target Sprite the attack and the amount of damage cost or at least the base damage this doesn't include defense or elements yet but at the very least we have something so now we don't need setup or create monster and we can work inside of a Ply attack to cover what we want to do number one we want to play an animation for the attack then we want to get the correct attack damage amount or in other words we want to include the defense of the monster and the element type for example if a fire attack hits a plant then we should double the damage and if a fire attack hits a water monster then we should have the damage next up we want to update the Monster Health and then we want to resume the game and I guess we can go through this step by step number one we want to play an animation for that I want to create an another a Sprite called attack Sprite this we have to create inside of the Sprites I want to have class attack Sprite for parent class this one is going to get the animated Sprite the one we created ages ago this one here because ultimately all that this attack Sprite is going to be is it will plays an animation but this animation it's only going to play once and then disappear or to visualize all of this a bit better if you look at the graphics folder there we have the attacks which contains a couple of animations those we want to play once after the monster has attacked we also need to import them but that's going to come later first of all Define a knit with self a position frames and groups then Super Thunder init where we are initializing the animated Sprite which means we want to have position frames and groups after that we are also going to need a z layer that we are this time getting from the battle layers and on there we want to get the overlay also when we are creating this animated Sprite we are setting the rectangle position to the top left which I don't want to do anymore instead I want to update self. wct and place the center to the position that way we can place the attack right in the middle of the Target Monster after that we need an animate method with self and Delta time in the original Sprite we are simply playing the animation forever which works in the Overworld but for this monster we want to play the animation once and then destroy the Sprite for that we want to get the frame index and increase it by the animation speed multiplied with dat time after that if self. frame index is is smaller than the length of self. frames if that is the case we want to update self. image which is going to be self. frames with the integer of self. frame index no need for modulus because we are already checking if we are inside of the length of the list if that is not the case else we simply want to destroy the Sprite using the kill method and finally we have to call update with self and Delta time and then call animate in there with Delta time and do not forget self that way we have an attack Sprite it's fundamentally a fairly simple class after that inside of battle dop we have to import it so import attack Sprite Which means to apply the attack Sprite I want to get the target Sprite wrecked do center for the position after that we will need the attack frames which we don't have at the moment but we're going to get them in a bit self Doge monster frames they're going to be in that dictionary and there we have the attacks or in other words in just a bit when we are importing the assets inside of the monster frames we're going to add one more key value pair to pick one animation from that we want to get the attack data along with the current attack and then from this entry we get an animation or in other words if you look at the attack data at the end we have an animation finally we going to need the groups all the way at the end self. battle Sprites so that's going to cover the attack Sprite the one thing that we don't have yet are the frames for the attack for that we want to look at main.py and add an attacks key along with a value and for this one I want to create an attack importer for the file path we want to go up a folder then to graphics and then we have the X so next up we have to create one more import method which is going to be Define a techcore importer for which we are only going to need a path then we are going to create a new dictionary for all of the frames that is empty by default after that for folder path the subfolders we don't care about and the image names in walk join and the path unpacked after that for image in image names and then we get all of the image names inside of this folder first of all in there I want to get the image name which is going to be image. split wherever we have a DOT and then we want to pick the first item that way we get rid of PNG at the end and then we can get the attack dictionary and assign a new key value pair the key is going to be the image name the actual value we are going to get from import tile map because once again if I open this thing we have tile Maps each animation is four frames that we want to isolate which means for import tile map we have four columns one row and the path to this folder is going to be the folder path along with the image name this would return another dictionary with key value pairs where the key would be the column and the row and the value would be the actual surface and in this case we are lucky because because we don't care about the keys at all we only want to get the values and all of that we want to turn into a list that is simply because when you look at all of the animations they always in one row hence the position doesn't actually matter and finally I can return the attack dictionary and that should be it if I now run main. pi and I attack a monster we get an attack animation and that is looking really good that took a while but we got there in the end so with that we can play an attack animation and I suppose we should try this a second time with anothera monster let's try this one and let's go with explosion and that's also working pretty well finally one more attempt is going to be not this monster but the second one because in there we have Battle Cry and let's try to heal this monster and that is working also notice for this one we getting a negative amount that means later on we are going to heal so next up we want to get the correct attack damage for that first of all we will need the attack element which we can get from Attack data the attack and then the element for the Target element we want to get the target Sprite in there we have the monster and the monster has the element after that I want to double the attack if the attack element for example is fire and the target element is equal to B that would be one condition if that is the case we want to get the amount and multiply it by two or in other words the damage we're getting from the monster is now twice as strong and well for this part we have to cover the other conditions as well there are only three in total we want to check if attack element is fire and the target element is plant if the attack element is water and the target element is fire and finally if the the attack element is plant and the target element is water if any of these conditions are met then we are doubling the attack damage and the opposite we can do half attack for that let me simply copy the if statements in which we want to multiply the attack damage with 0.5 so for example if the attack element is fire and the taret element is water then the attack is going to be weaker this could also apply if the attack element is water and the target element is plant or if the attack element is planned and the target is fire so with that we are incorporating all of the elements and this system is only going to work if you have very few elements if you have more than that it's going to cause issues but I think for our purposes this is still totally fine although we do not include the defense of the monster or in other words if you look at the game die and monster data all of the monsters have a defense stat this we also have to include the way I Incorporated that one is I have created a Target uncore defense which I want to be a value between zero and one the higher the defense of the monster is the lower of a multiplier we want to have first of all I'm getting the target Sprite do monster doget underscore stat and I want to look at the defense of the monster just to demonstrate what we are getting let me print the target defense if I now run all of this we are getting an unexpected character I think it just doesn't like this slashy speaking of which The Ore shouldn't be there either next attempt main P the game doesn't crash anymore good start and now if I Target a monster we get getting name element not defined things are going great that happens because the element here should be a string next attempt if I now attack again we are getting something these numbers we are getting from these four print statements where the first one is the target defense for this monster it's 20 or in other words the monster we have is going to be this one at Rox at level two and inside of game data if you find at Rox we have a defense of 10 and this we multiply it by two that way we are getting 20 now this 20 I want to turn into a fraction something like 0.8 or 0.9 that if the monster has a very low defense value we want to get 90 something per of the attack damage for that I want to subtract the value from one that way we would get 19 at the moment to fix that I want to divide this value by 2,000 that way this 20 is going to become a really small number and that we are then subtracting from the one let's try this again and if I attack the monster with the same attack we're getting 0.99 since this monster is super weak the defense shouldn't really matter that much however if if we increase the level of the monster to let's say 15 and run all of this again if I now attack the monster this is 0.925 which I think is pretty good now this 2,000 here you can play around with depending on how strong you want the defense to be but that you can do in your own time in my case I want to get the target defense again because we have to make sure that this number doesn't become negative if that was the case and attack would heal the monster which well would be weird for that I want to use max with zero along with Min just to be sure that we stay between one and the target defense with that we have the proper Target defense amount finally with that we can update the target sprite. monster. Health minus equal the amount multiplied with the target defense that should actually be visible in the game if I now run out of this and I attack this monster the only one with health we are reducing the amount of health and now that we have that inside of the monster we don't need the random amount for health and energy anymore if I now run main Pi again we have the full amount for everything and if I attack this monster we are reducing the amount of health so that is working really well although after that nothing is going to happen and we also don't need a print statement anymore instead what we want is to resume the game which we do with self update all monsters and resume so next attempt and I can still attack and after that the game continues so let's try a different monster this one on and it's a low level so it takes a lot of damage but the game itself is working really well I suppose what we should be doing after we are applying the damage I also want to self. check uncore death that's going to be another method and we don't need apply attack anymore but below that we will need Define check death no need for custom parameters and there we want to look at all of the Sprites for Monster Sprite in self. opponent Sprites do Sprites plus self. layer Sprites do Sprites we know a monster is that if Monster sprite. monster. Health is below zero after that we want to separate the opponent monsters from the player monsters which we can check if self. player Sprites in monsters Sprites dog groups once again player Sprites is the Sprite for all of the player monsters if that is in any of the groups of the currently selected monster Sprite then we know we are on the player side let me at a comment player now this case we want to ignore for now so let me add a pass in here what we care about are the opponent monsters which are going to live inside of the El's statement but now what we can do is simply monster Sprite do kill although that is not going to work perfectly yet but let's try if I attack this monster and attack it a second time okay needs a third attempt there we go now it disappears but well there's lots of stuff missing let's go through it one by one when we are checking death we already know if the monster is below zero in terms of health so we know if the monster is supposed to be dead or not and if that is the case we want to create a new monster that way once we are killing a monster we are replacing it but only if there's a monster so for example for the dummy monsters we can only see these three monsters so if one is selected we should select the next available one but that we can cover later also later on I want to implement an XP mechanic but that we can ignore for now and there's another issue and that is when you look at Sprites once monster Sprite has been defeated we can still see monster name Sprite monster level Sprite and monster stat Sprite Which obviously is not what we want to fix that let's start with monster named Sprite this one is going to need an update method with self and Delta time we can ignore so underscore we basically want to check if this monster Sprite has been killed or not or rather in terms of monster Sprite we want to know if this monster Sprite is still around now what you have to be aware of when we are calling the kill method on a Sprite we don't actually destroy the Sprite instead what we do is we are removing it from all of the groups that way it doesn't really do anything anymore that behavior we can use because inside of update we want to check if not self. moners sprite. groups sprite. groups is going to give you all of the groups inside of a Sprite if the Sprite isn't any groups this will give you an empty list which would trigger this if statement if that is the case we want to call self. kill the same logic we want to apply to all of the other Sprites as well which means inside of monster level Sprite let's do it all the way at the bottom I want to check for death and then finally inside of the update method of the stat Sprite I also want to check for the same condition there we go and make sure you don't accidentally put this if statement inside of this is for Loop cool with that we have the monster stat Sprite the monster level Sprite and the monster name Sprite now we should also put the same thing inside of monster outline Sprite just so we don't have some random Sprites in the game with that I can now run main.py again and if I attack with the splash attack this monster it's fire it should disappear and there we go now we have gotten rid of the monster entirely also if I now select one of the other monsters we are getting the proper selection behavior that is because of the logic we implemented earlier that part is working pretty good cool so next up I want to check if we have a new monster which I will store in a variable new monster data this is going to be a tupal that has a monster it has an index a position index along with a site or rather an entity so player or opponent although for that to work we need to do a bit of groundwork when you're looking at the dummy monsters we have five monsters in total and three are on the battlefield if one of them dies let's say this one goes away we want to replace it with the first available monster in this case jakana with level two in other words the first thing that we need is to isolate these two monsters or in other words words what I actually did when we are running the setup method we are creating all of the monsters but on top of that I want to remove the opponent monster data since the opponent can't really change monsters once a monster is on field that monster will get deleted from the monster data or in other words I want to look at for I in range length and self do opponent Sprites let me print what we get I if I now run M Pi we getting the indexes 0 one and two using those indexes I want to delete self. monster data with the opponent and then using the index as a consequence after we are setting everything up I want to print self. monster data with the opponent and now inside of main. Pi we are only getting monster three and monster 4 and then if one of the Monsters has been defeated we want to pick the first one and store it inside of monster data in other words I want to get self. monster data with the opponent and from that I only care about the values all of that we want to turn into a list and then pick the first one to get the index and the position index I simply want to get the monster unor Sprite that was defeated and then get their index and position index which we are already storing in there finally The Entity since we know that this El statement is only triggering for the opponents this one is always going to be opponent there's one more thing that we have to do all the way at the end we only want to run this entire line if self. monster data and opponent doeses exist if it does not else we should get none for this value or in other words we only want to get a new monster if there are any values left inside of the Dummy monster dictionary or whatever dictionary we have for the opponent now that we have a new monster we also have to make sure that we getting rid of this monster from the monster data dictionary for that I want to check if self. monster data with the opp opponent and if that is the case I want to delete self. monster data of the opponent and I always want to get rid of the lowest key I.E minimum self Doge monster data and the opponent that way we can get a new monster and remove the previous one so with that we have to create a new monster after we have killed the current one but there's one more thing that I want to do I don't want to kill the monster immediately because it looks a bit weird let me run main. Pi again if we kill a monster let's say this one it is a appears way too fast which doesn't look good so instead of killing the monster right away I want to call monster sprite. delayed uncore Hill and then pass in the new monster data also really important this delayed kill is going to apply to the player and the opponent monster hence it shouldn't be inside of this if statement but it should be inside of this if statement to check if the health is below zero so I have to indent it one more time although the XP comment does need to be inside of the El statement like so now we have to figure out a delayed kill method inside of the monster Sprite I want to minimize all of the methods and then create fine delate kill with self and a new monster there are two things we want to do in here first of all self dot let's call this one the next Monster data which is going to be the new monster after that we want to start a timer that we are getting from Thunder in knit that we already have a remove highlight timer besides that I want to have a kill timer which is going to be a timer with a duration that I have set to 600 the function we want to call once it times out is self do destroy inside of delay kill self. timers with kill and activate on top of that I want to make sure that we don't accidentally call this one multiple times which we can do with if not self do timers the kill timer and active I.E we only want to run out of this if the kill timer currently is not active uh after that Define destroy no need for custom parameters all we really want to do in here is to call the kill method and on top of that if self. nextt monster data then we want to self. create a monster which is the method that we have inside of the battle class create monster for this one we're going to need monster index position position index and entity which coincidentally are the same methods that we have inside of the new monster and there we have a monster index position index and the entity which means to create this monster we simply have to unpack self. next Monster data although before that we have to get create monster into the monster Sprite Which we can do via another parameter create monster and don't forget to St it as an attribute self. creat monster is create monster also when you are creating a new monster inside of the monster Sprite we have to add self. create monster that should actually be it if I now run main.py and I kill the second monster it disappears and after a while we're getting a new monster we can defeat that one as well and some point we should run out of enemies oh well we're getting list index out of range but we're getting something now to fix this error we want to look at groups and then work inside of this if statement in which we are checking for the outlines the second part of that if statement this line is causing the issue and to fix it we want to add a bit more sprite. Monster sprite. entity is equal to the site that way we are checking if we are on the player or the opponent side on top of that I want to check if mode exists and if mode is equal to Target that way we have quite a bit more so now let's try to run the game again it doesn't crash and if I get rid of enemies they still disappear and it doesn't seem like we are crashing anymore although now an opponent is active so we can't do anything anymore so that we can work on next now for the monster attacks we want to work inside of the battle class let me collapse everything and then look at check active at the moment we only do something if the player monster is ready however if the opponent monster is ready at the moment we simply stop the game and this we want to extend via an El's statement I want to get self. timers with let's call this one opponent delay and that timer I want to activate if this is the timeline of the battle at some point one of the opponents can attack but that I don't want to happen right away instead I want to highlight this monster for let's say around half a second and only after that I we going to trigger the attack because of that we have a timer that is going to trigger after 600 milliseconds and before that we are highlighting this opponent monster so the player is aware that there is going to be an attack that being said though timer doesn't exist inside of the battle class at the moment or at least I don't think it does no it doesn't let's create it all the way at the top I want to have some timers self. timers it's going to be a dictionary and the timer that we have just created is called opponent delay the associated value will be a timer with a duration of 600 and the function we want to trigger once it times out is self. opponent uncore attack although I think we also have to import from timer the timer class so right at the end of the battle system I want to have Define opponent attack there are three things that we want to do in this method we want to get the ability of the monster then we want to get a random underscore Target and finally we want to get self. current monster and then activate attack with the random Target and the ability and as a reminder activate attack is what we already have inside of of the monster Sprite so somewhere in there we have activate attack that way we are reusing the logic from the player monsters which is quite handy although before we are going to work on that there's one more thing that I do want to do inside of the main section and that is going to be update timers all we are going to do in there is for timer inself do timers do values and then timer. update as a reminder for all of the timers that we have at the moment it's only one but there are going to be more we have to call the update method on every single timer otherwise nothing is going to happen that we can do via a method and that method we have to call inside of the update method let's do it right after the input self. update timers with that we can get the ability and the random Target after that we should have a monster attack from the opponent that part will be your exercise I want you guys to get the opponent monster ability and the target pause the video now and see if you can figure this one out for the ability I want to get self. current monster do monster and then get underscore abilities and from that I want to get a random value which I get via choice that we have to import via from random import choice that would give us the ability and let's simply try for now if this is working at all meaning I want to print the ability and then inside of main.py in the dunder init method the first Monster can get a level of 50 so it gets ready really fast let's try and there we are getting one of the abilities let's try it again we should get a different attack and we do that looks good after that we will need the random Target for this one we do have to be a bit careful because if you look at attack data and let me minimize everything if we get an attack like burn or spark or scratch we now want to Target the player whereas if we have heal or battlecry we want to Target our own team the naming here isn't ideal but I hope you get the idea I want to first of all get the side which we get from Attack data we're using the ability to pick the data and after that we want to get the Target and once we have that we can check if side is equal to layer then we want to get a random Target of our own team meaning random Target will be choice of self. opponent Sprites do Sprites and else we want to get a random Target that will be choice of self. layer Sprites do Sprites that way we're getting a random Target let's print it random Target and run all of this again we are getting a monster Sprite in two Sprites okay that wasn't particularly helpful we could instead print random target. monster that should be better and now we're getting a monster which is friolera level 29 one of our monsters and just to test the other side inside of game data for the monster data when we are looking at atro this one we can change its abilities to only be able to heal that way if I now run m not P again and this thing is running we are getting monster gfin level five so that is also working although this I don't actually want to do with that I can get rid of the print statement and I think five lines for something so simple isn't really necessary so let's reorganize this a bit I want to assign the random Target to the opponent Sprites but only if attack data ability and the target is equal to player if that is not the case else we want to assign a random value from from the player Sprites and if you have a bit more space this is also still readable but well the same logic applies finally we can get self. Corin monster. activate attack with a random Target and an ability let's try that and we're getting attack and something happens and now I can do something as well and things are coming together and with that we getting to the next eror where we don't have a new monster data that happens because when we are checking the death and one of our Monsters has died because when the player monster dies nothing is really specified yet that we do have to work on for that we want to get all of the active monsters which needs to be in a list where we have an index and the monster that we can get via list comprehension I want to get a monster Sprite for monster Sprite in self. player Sprites do Sprites that being said I don't want to get the monster Sprite itself I want to get a tuple with monsters sprite. index and monsters sprite. monster I suppose remember for new monster data we want to get the actual monster and the index and that's what we are getting in here after that we also need to know the available monster ERS which is going to be another list comprehension where we getting a tupal with an index and a monster that we can get quite easily because we can do for index and monster in self. Monster data of the player and from that we want to get all of the items however there are a few conditions that apply here which means if moner do health is greater than zero I.E we don't want to place a dead monster and we want to check if index and monster is not in active monsters or in other words we don't want to pick a monster that's already on the field once we have all of that we can create new monster data for that we can use list comprehension a third time and I want to create a tupo with a monster the index the position index and then the entity I.E the player to get that I want to use for index and monster in available monsters I.E we are looking at all of the available monsters and then we are reorganizing the data monster we can keep index we can also keep although for the position index we want to have have the current monster uncore Sprite and then get the position index from that one now this would give us a list and we only care about the first value I.E index zero however this I only want to do if we have available monsters in the first place I.E if available Monsters has any kind of value then we want to create a new monster data if that is not the case else new monster data is simply going to be none let's try that and if I now Run the game we can get attacked so let me defend and at some point one monster should die and we get another monster that looks pretty good also if I destroy one of the opponent monsters they also get a new one so that is looking pretty good cool with that in place we can work on the XP mechanic meaning if we defeat one of the opponents we're getting some XP for that first of all we have to figure out the XP amount which we can get from the current monster Sprite do monster. level and I simply multiply this with 100 and this value I want to spread equally across all of our player monsters that are currently on the battlefield I.E divide by the length of self. player Sprites and after we have that I can simply do for player Sprite in self. player Sprites layers sprite. monster and then update XP with the XP amount this method does not exist inside of the monster which means in the monster I want to minimize everything and then create a new method Define update XP with self and an amount in the most basic sense all that we want to do in here is self. XP plus equal the amount and I think we already have XP yeah we do so and there at the moment we only have a random value but this one by default should be zero and let's try all of that if I run the game and we defeat one of the opponents all of our monsters get a bit of XP this might be hard to see but if you look at a black bar now we get a very small amount if I defeat another opponent this might be more visible there we go if you look for it you can definitely see it so that part is working and also I want to set the level of at Roos back to something like 10 so the game runs a bit faster after that I want to expand the update XP method to incorporate a level up the way I approach that is I first of all check if self. level up minus self. XP is greater than the amount if that is the case we simply want to add the XP to the amount and nothing else is going to happen we are not going to level up however if that is not the case else then we know via the current XP amount we are going to reach the next level which means self. level plus equal 1 on top of that we have to increase self. level up which is simply going to be self. level multiplied with 150 and finally we want to retain some of the XP self. XP or in other words for a monster to level up let's say we need 200 XP and at the moment the monster is at 150 and then gains 100 additional XP we are going to level up at XP 200 but then we also want to retain the XP that are overshooting which we can get via the amount minus self. LEL up and minus self. XP and that part is going to be a bit difficult to visualize but but let's see how far we get so I want to defeat some opponents and you can see for Lavia at the bottom this should happen fairly soon let's defeat this one and we are nearly at the level up let's defeat this one and there we go Lavia leveled up that's a good start but we don't get any more XP and we get list index out of range so two things that we have to cover number one the XP mechanic for that in side of the monster we have to change XP before we are updating level up that way if I run main. pi and let's kill this one then we can kill this one we are very close to a level up okay bit more I guess we can defeat this one and then and there we go Lavia l up and we retain the extra XP although now if I defeat the other enemy we're getting an error message that we have list index out of range and that happens for two reasons number one inside of the groups we're getting an error because inside of the Sprites the ones that we have created here we have no content or actually there are two possible cases where this could go wrong number one is when there are no more enemy monsters this value is empty so any indexing operation would give us an error that is an issue we can fix right away simply by adding if Sprites and if that is not the case none so in other words we only do all of this if there are any Sprites left whatsoever and that is going to do something but there's still another issue and that is if I only destroy the middle enemy so let me always Target the one in the middle like so at some point Point once we run out of monsters we're going to get an error that is list index out of range in this same line that error happens inside of battle. Pi when we are updating the target index basically the way you have to think about it is that when we have three enemies and we're getting rid of one of them we have to update the index as well otherwise we're getting this eror here where we are trying to get a number too large for the list the way I have approached that inside of input all the way at the bottom after we have gotten the last General I want to set all of the indexes back to zero I.E we are doing let me minimize this we are checking for all of the different inputs and then we are setting self. indexes 2 K and zero 4K inself do indexes so other words we are taking this dictionary we are copying all of the keys and then for the value we always have a zero that way after we have done any kind of input and we go to the next monster we start again from scratch oh also this indexes we only want to trigger when we are pressing space let's try all of that and I'm going to start by always attacking the middle monster cuz that earlier caused the most issues however I also want to has to pay attention to when I'm selecting one of these attacks earlier we always kept the same index if I select the fourth item or the one with index three Ander us it when we selected the next monster we got the same index but now we always start at the top which fits much cleaner so let me oh that was the wrong monster but this seems to be working reasonably well so for the final one disappears and there we go now we can't really do anything anymore and we're getting an error but that doesn't really matter once we get to this case we want to end the battle anyway although that is going to come later first of all though I can minimize the input and the dander in nit method and then work on the next part which actually happens inside of input because in there we currently can attack a monster but we cannot catch one so that we have to account for as well to explain that mechanic let me run the game again and essentially once a monster is ready I want to select the Target Monster and then at the moment we are only printing catch so that doesn't do anything which means inside of battle once we get to catch we want to do more than just print catch I want to set self. selection mode to Target and self. selection s should be the opponent that should already do quite a bit if I now Run the game and I go to catch we can select one of the opponent monsters although if I press space we don't really do anything and for that we're going to need this El statement so basically at the moment we are in selection mode Target but we do not have a selected attack and in there I basically want to check if monster sprite. monster and health is below 10% of the max Health which we can get via monstore sprite. monster and get Stat maxcore Health and that we can multiply with 0.1 or whatever number you think works well if that is the case I want to update self. monster data with the layer and then add add a new index and assign the monster the monster we can get from monster sprite. monster and the index is simply going to be the next number or in other words at the moment we have 11 monsters meaning the next index should be 11 to get that inside of the monster I simply want to get the length of self. monster data of the player on top of that I want to get the monster Sprite and run the delayed kill method with none that way the monster disappears after a few milliseconds and finally we have to self. update all monsters and resume the game if that is not the case else we want to do something else but for now I simply want to print cannot catch monster let's try all of this first and while we are testing things I want to set the catch rate to let's say below 90% that's going to make things much easier to test if I now run main. pi and I attack one of the stronger monsters that should be good and now if I catch this one it disappears and if I switch the monsters all the way at the bottom we should have enough a monster that looks good although if I press space nothing is going to happen at the moment so that we do have to work on but step by step first of all this is working next up though if the player tries to catch a monster with too much health then I want to create a timed Sprite or in other words I want to display a Sprite for a very short amount of time now the image that I want to display is going to be inside of Graphics in UI there we have a cross if the player tries to catch a monster with too much health I want to display this cross over the monster for a short period of time and for that we are going to use the time Sprite in terms of arguments I want to have a center position I want to have a frame or rather a surface since this one isn't animated then we will need a groups and a duration argument none of these are terribly difficult for the center position I want to get the monster sprite. wct do Center this surface I want to use we already have self. battles Sprites in there we have UI Sprites and this one contains a cross this is already imported for the groups I simply want to have self. battles Sprites and the duration could be let's say 1,000 milliseconds or 1 second with that we can create a Time Sprite although before we do that I want to import it right away with that inside side of the Sprites I want to create another class time Sprite and the parent class for this one is going to be a Sprite after that I'm going to call Define thunder in knit with self a position surface groups and duration I want to call this super Dunder init method and as a reminder we are going to initialize this init method which means we need these parameters where we have position already covered surface covered groups covered and the one more thing that we need is the Z parameter for which we are going to use our batt layers and this one should always be on overlay after that we do have to update self. rect do Center which should be the position and that's the same issue we have already seen with the attack Sprite we have done the same thing in there so essentially for the original Sprite and animated Sprite we have a rectangle and via the position we are placing the top left which is not what we want to do for the attack Sprite and the time Sprite we always want to place the center which we achieve via these lines on top of that for the time Sprite we will need a self. Deathcore timer which will be a timer with the duration that we getting from the parameter all the way up there I want to set auto start to true and then the function I want to call once it triggers is going to be self. kill the inbuilt function of any Sprite and after we have that I simply want to call update with self and Delta time although Delta time we don't actually need so an underscore here is totally fine and then self. death timer. update is all we need and that should be it if I now try main. pi and I try to catch a monster with full health we are getting an error because battle Sprites object is not subscriptable let's have a look I think that happened when we are creating the time Sprite so there we have the error and I can see it already we want to get the graphic not from Battle Sprites but from monster frames this one actually contains the graphics next attempt and now if I try to catch a monster we are getting the error symbol message thingy that's working reasonably well that covers catching a monster and I am going to leave it at 0.9 for now although later on this one should be switched back perfect we are making progress so with that we have covered quite a few states there are two more the next one if self do selection mode is equal to switch I.E we are trying to switch the monsters if that is the case I want to get an index and a new monster which I can get from the list self. available monsters. items don't forget to call this one and then use indexing with self. indexes and the switch Also let's print index and new monster just to make sure we have something to look at if I now run main.py and I try to switch a monster let's go with this one we can see the monster we have selected is four and spu we can try another one that still looks pretty good let's this one as well so yep that seems to be working quite well which means at this point we simply want to get the current monster and kill it that way we're getting rid of the Sprite and next up we can create a new monster with the new monster that we have just gotten then we want to have the index and self. corn monster do position index and you might be wondering why can we still access this corn monster even though we have just killed it the reason for that is that killing a Sprite doesn't actually destroy the Sprite it simply removes it from all of the groups that way you can still access all of the attributes which is super handy the last thing we are then going to need is the entity or the site of the monster which is always going to be player for this one after that I want to get self. selection mode and set it to none and then self. update all monsters and resume things that should be all we need in here if I now run main. Pi I can select another monster let's go with this one and we get another monster also if I now try to attack another monster and then try to catch it that part still works and now if I try to switch monsters with the one we have just C that part also works just fine so that is looking pretty good so with that we have covered all of the major States but there's one that we haven't covered yet inside of selection mode General index one this is telling a monster to defend and at the moment this doesn't really do anything to fix that before we are doing anything else inside of the if statement self. current monster do monster and then defending is going to be true that we can then use when we are applying an attack we are already calculating the damage mechanic in quite some detail here and essentially after we are calculating the target defense I want to check if Target Sprite Dot Monster dot defending if that is the case then Target defense is going to be Reduce by 0.2 oh and also we should create this defending attribute inside of the monster in the DED method let's do it under stats we want to have self. defending which by default is going to be false on top of that after the monster gets ready again we want to disable this defending attribute which means when we checking for active and one of the monsters does get ready then we also want to set monster sprite. monster. defending to bols although this part is now very difficult to visualize because we have to wait for the other monsters to attack us let me just always choose defend and let's hope we get the right monster to be attacked and well they always attack the weakest one at the moment and there we go rolera got attacked and the damage is actually really low although that might not mean very much but well basically inside of a Ply attack we know that this number is going to update so play around with it if you want to change the numbers but I am fairly confident that it works reasonably well righty with that we have apply attack which means there's just one more thing that I want to do in this section and that is for the battle system I want to check end of the battle so we know when either the opponent or the player has been defeated for that we donate custom parameters and then we have to check two conditions number one is opponents have been defeated and number two his player has been defeated I suppose we could start with the player because that part is a bit easier all we really want to check is if length of self and player Sprites and if that number is equal to zero and just to test that for now let's print game over after that inside of the update method I want to check self. check and battle and I guess this we should be doing before we are doing anything else that should be a bit safer righty now to test this one inside of main.py when we are creating the monster the player shouldn't have three monsters with level 100 although for the opponent monsters I want to have three monsters with a level of 100 and just so we don't have to wait for too long let me comment out most of the monsters and let's try this again and now we should be losing pretty quickly simply because the opponents are way stronger so there we losing one monster there another monster and we should be gone well this has nearly worked we are getting game over but after that we are getting an error message that we cannot choose from an empty sequence which is okay this line is not going to run anymore but basically what happened is when we are checking the opponent attack we cannot pick a random Target anymore simply because there are no player monsters left but that's okay because we're not going to get to this line so instead we want to run py game. quit and exit and since we are importing py game and sis inside of settings these two lines should work pretty well let's try to run out of this again and we should be defeated pretty quickly cool and the game just ends so we are good to go this covers one part next up we have to work on the opponents which is going to work in a fairly similar fashion I want to check if the length of self. opponent Sprites is equal to zero if that is the case I simply want to print battle one on top of that I want to get for monster in self. Monster data and the layer monsters so dot values and then reset all of the Monster initiatives I.E monster. initiative is going to be zero that way when the next battle starts we don't have some random value already but that should be it if I now go back to main.py and for the opponents I want to have more reasonable levels let's say five six and seven and now we can try this again and if I just defeat them randomly I use the proper attack type but you get the idea and there we go all of the opponents have disappeared and we get Battle one although this we get many many times which might cause an issue down the line to account for that I want to add and not self. battle over and then once this if statement triggers I want to set battle over to through on top of that in the dunder init method I want to create another attribute self. battle over which by default is going to be false that way and let me comment out most of the monsters we should only see battle over once which is going to be much safer and there we go we have won the battle and everything still works just fine perfect so with that we have basically all of the battle logic there's just one minor final thing that I want to cover and that is when a monster gets defeated you can see something like minus 50 Health which is kind of a cool effect and if you want to keep it just skip this part but I want to limit the lowest Health to zero and for that inside of the monster let me minimize everything I want to insert a stat limiter in which we are setting self. health and self. energy and basically for both what we are going to do we're going to make sure that we have a max value of either zero or a Min value of self. health and self. getet Stat with maxcore health or another words we first get the larger value between zero and the smaller value between self. health and self. Max Health that way self. Health can never go beyond the max health or below zero and the same thing we want to do for energy so let me copy all of this the only change that we have to make is this needs to be self. energy and the max value should be Max Energy after that we have to make sure that we are calling the stat limiter that's going to happen inside of the update method you can put it basically wherever you want self. stat limiter and with that if I now run m p again and let me try to hit I have a monster with water attack so we do lots of damage and we always keep it at zero so that looks pretty good perfect and with that we have finished the battle system now later on we have to add some sounds but that's a fairly minor part what is much more important for now is to connect the battle system to the Overworld which will be the next part I'll see you there so with the Overworld and the battle system in place we have to connect the two and that's going to be the last major part that we have to work on although on top of that there are a few more minor things that I also want to cover most importantly in there we have the evolution system so if a monster Hits a certain level we want to switch it to another monster besides that for the characters I want to have a nurse that heals all of the player monsters and finally I want to add all of the sounds that part should be fairly straightforward once we have covered all of that we have the entirety of the game so let's Jump Right In and get started with the easiest part the nurse system so here we are back in the code and I have cleaned up the tabs a bit the python files that we will need are main.py entities. Pi battle. Pi along with support pi and game data although the first three are the most important ones and to get started I want to implement a nurse so that when the player goes to a hospital we can get healed for that when we are creating the characters that happens in there in the setup method I want to add one more argument which is going to be nurse the value for this is going to be a Boolean and basically what I want to check is or bj. properties and then we have a character uncore id if that value is equal to this string nurse then we know we have a nurse now to understand what that means in TI we have to find a nurse in the Overworld we don't have a nurse but if you go to hospital. TMX we have one nurse here and there you can see character id is nurse that is what we we are looking for also this nurse should be a bit further down so the player can actually reach it oh and by the way while we are here inside of world TMX the player shouldn't be in the top left he should rather be further down here with that we know if a character is a nurse or not which means next up we want to work inside of the character class first of all we have to give this one another parameter nurse and then inside of Thunder init turn this into an attribute self do nurse is going to be nurse that's all we need in here next up we want to work inside of main.py more specifically in and dialogue at the moment we are only getting rid of the dialogue tree and then unblocking the player not very much so far and in this section we're going to expand this method quite a bit first of all I want to check if character. nurse and if that happens to be I want to cycle through all of the player monsters I.E for Monster inself dopler monsters. values and then set monster. Health to monster getor stat with the maxcore health that way we are setting Health to the maximum value and the same thing we want to do for the energy except now we want to set it to max energy that way we are healing all of the monsters and only after that is the case do I want to unblock the player and with that we have the nurse now to test this inside of thunder in knit I want to comment out battle but we will need the attribute self. battle although it should be by now keep the instant sync of this battle class we are going to need it in just a second and it's going to save you some writing anyway if I now run main. Pi we are not getting an error and if I go to the hospital I can talk to a nurse and we are getting our monsters have been healed now this isn't really something we can observe right now because our monsters have the full amount of Health but what we can do after we created all of the monsters for Monster inself dopler monsters. values monster. Health multiply equal 0.5 that way if I run the game again we get 50% health for all of the monsters so now if we go to a hospital and get healed all of the monsters have the full amount of health so that is working really well with that we don't need this for Loop anymore and we have covered one part now we have a nurse after that if the character we are talking to is not a nurse so L if and we want to check not character do character data and then we want to check for defeated or in other words when we are finishing a dialogue we want to check if the character we talk to is a trainer that hasn't been defeated if that is the case we want to start a battle although for now let's simply print start battle if I run the code and talk to a character we should be getting start battle in the bottom left and we do that is looking pretty good which means if this is the case we actually want to create one instance of the battle class which we can do by copying the values that we have created earlier and then we don't need thiss after battle anymore we want to create a battle class and I think all of this should happen over multiple lines so it's a bit easier to read we have the player monsters then we have the opponent monsters next up we have the monster underscore frames we are getting a BG surface and finally I think this one is simply called the fonts so with that we are creating one instance of the battle class and there's one thing we already have to change we want to get for the opponent Monsters the actual Monsters of this trainer and I should actually do a reminder if we're looking at the entities and the character there are two data points we are working with at the moment the first one is this character data defeated this can find inside of the character in character data but ultimately what we are referencing is inside of game data there we have the trainer data and this one contains the defeated key value Pair by default all of these values are faults but once the trainer has been defeated we are going to set this to True besides that all of the trainers have some monsters those we have to get into the character which means for the character I want to create another attribute self do monsters which is going to be a dictionary comprehension where we want to have an index and then a monster all of the data is going to come from for I and data in character data and we want to get the monsters and from that we want to get the items if you look at game data monsters is simply a dictionary where we have the index of the monster and then the monster along with the level that we want to convert to an actual index with the monster class for that we want to call the monster class and then pass in the monster name and the monster level that we can make quite explicit because data right now is a tuple with the monster name and the monster level which are the two points of data we want to pass into monster so name and level that should be it for this part although if I run main. pip we are going to get an error that we have a name error monster is not defined that happens because some trainers do not have monsters because they are nurses so if I go down a bit further at some point there should be a nurse and the nurse obviously doesn't have monsters to account for that when we are creating the monsters I want to check that we are only creating this dictionary if there are monsters in the character data if that is not the case else we want to attach none to this value so we now run the entire thing we are getting the same error and I just realized I made a mistake when I talked about this error that monsters is not inside of character data this would have been the next step the actual error that we have gotten is that this monster class doesn't exist inside of this python file at the moment which we can change quite easily from Monster import monster and now if we try off this again there we go now this all works just fine that means next up when we are creating a battle class for the opponent monsters we can get the character and the Monsters besides that we also have to cover the background surface at the moment we are always using the forest but that we can make more flexible by using character do character data and in there if you look at game data we have a biome I want to use that is all we need to get started if we now store this instance in self. battle and Run the game and we are getting to a fight we can also still attack and everything is working just fine so definitely doing some progress but obviously there's no way for us to leave this window which isn't ideal also I want to have a transition from the Overworld to the battle at the moment we are switching a bit too abruptly as a consequence instead of assigning battle to the attribute right away I want to set battle to the transition Target and after we have done that set self. tint mode to H now this is a system we have implemented way earlier when we have switched between different levels so this tint screen is what we're going to work in essentially what we are going to check is if the tint progress is greater than 255 meaning we are covering the entire window after that we want to check if type of self. transition Target if that is equal to the battle class then we know we want to create self. battle and set it to self. transition Target meaning now we are setting battle and getting all of this while we are here we can also set an L if statement self. transition Target is equal to level then self. battle is simply going to be none so this would be the other way around where we are going from a battle to the Overworld which simply means that we want to set battle To None finally if nether of those are the case else then we want to run the setup method to create another level and that's all we need to get started with this part so if I now talk to a trainer again we should have a nicer transition and that is looking much better the rest still works just fine cool so with that we can get from the Overworld to a battle but how can we get back for that we will need another method that I have called endore battle besides self we will need a character parameter in this method I want to get self. transition Target and set it to level then I want to set self. tint mode and tint the screen and and then check if we have a character in which case we want to set character do character data defe and this one should now be true on top of that self. create dialogue with this character or in other words once the battle ends which means inside of the battle class we are going to call check and battle so on there instead of printing battle one we want to call this end battle method and then check if we have a character if that's the case we want to set this character to defeated and then display the defeated dialogue that's all we need for now so next up we have to make sure that this end battle is inside of the battle class or rather when we are creating an instance of this class we have access to this method which we can do via another parameter I want to add endore battle the value is going to be self. endore battle that means inside of battle. Pi we have to add one more parameter _ battle and turn all of that into an attribute self. end battle is going to be end battle on top of that when we go down a bit instead of printing battle one I want to call Self Dot and battle and now we have to get the character in there which we also going to do via a parameter so we want to have a character or a trainer doesn't really matter what you call it for that we have to once again work inside of main. Pi and then add another named argument we want to have a character that part is really easy because we already get the character so that we have to pass in there character and then we are good to go although we do have to store that as an attribute as well self. character is going to be character so quite a bit more data but now when we are checking for the end of the battle we can call self. end battle and pass through self. character which means we are calling this and battle we are setting the transition Target to level then tint mode to tint and we are creating a new dialogue after that we are going to tint screen we are tinting everything so things are going to Black and once we are reaching the full value so 255 we get to this if statement and we know that transition Target is level which means by the end of it battle is going to be none let's try if I now let's talk to this character I think it's a bit easier to defeat so we should netive transition that looks good and now if I defeat the monsters really quick there we go we get a transition we get a dialogue and that is working really well although afterwards we are not able to walk anymore but we are making progress first of all then once the battle is over and we are ending the dialogue we have to unlock the player which we can do via an l statement self. player. unlock that should be all we need next attempt okay we are making progress and I can walk around perfectly fine again and now if I talk to this character again we are always getting the defeated dialogue perfect that is working quite well so next up we need to system that if the player walks in t grass we want to have random monster encounters or in other words there should be a random Tim that if we are in to grass after some random period of time we should be attacked imagine that this is the timeline of the game and our player currently is here meaning a random amount of time has passed this specific number doesn't really matter what we want to check is if the player has touched some grass then we want to create a timer that runs for a short amount of time and if this timer runs out and the player is still in Tall Grass then we want to start a fight which means we have to do two things number one once the player gets into Tall Grass we want to start a timer and after this timer is finished if we are still in Tall Grass then we want to start a battle I have organized all of that via two methods let's put all of that in a separate section monster and counters first of all I have Define check underscore let's Call it Monster no need for custom parameters and we basically want to check if the hitbox of the player is inside of any of the grass patches for that first of all we need to know where all of the Monster grass patches are meaning we have to create another Sprite group self. monstore Sprites a better name here might be grass patch or something like that but I think you get the idea now now we have monster Sprites that means next up when we are creating the entire level we want to check for all of the grass patches those they should be inside of all Sprites and they should be inside of self. monster Sprites that way we always know where all of them are that's a good start so next up when we are checking for the monsters we want to check if the list comprehension Sprite for sprite in. monster Sprites I.E we are getting all of the Monster Sprites but we only want to get the ones that are colliding with the player hitbox I.E sprite. w. cidere with self. player. hitbox on top of that I want to check and not self. battle and self do player. Direction so in other words we are checking three things if the player is colliding with tall grass if there's not currently a battle and if the player is moving I think all of them are fairly straightforward if that is the case I want to start a timer let's call this one self. encounter timer this is what I want to activate also want to make sure this timer is not currently running which we can do with another by if statement if not self. encounter timer. active only if that is not the case do we want to start the timer now this timer doesn't exist at the moment which means inside of Thunder init all the way at the top I want to create the encounter timer which will be a timer with a duration of 2,000 for now and if this thing times out I want to call a function which is going to be self monstore encounter this method does not exist at the moment and we'll create it in just a second first of all though we have to from timer import timer cool next up we can call this timer and besides that we will need Define monster uncore encounter no need for custom parameters and for now let's simply print monster and counter now before we can test all of this there's one more thing that you shouldn't forget and that is we have to update the timer that's going to happen inside of the update method before we are doing anything else self. encounter timer. update on top of that what you shouldn't forget inside of update self. check monster I.E we are calling this method with that if I run everything and we are touching grass after some time we should should get monster encounter at the moment this happens every 2 seconds so that is looking reasonably well that means check monster is working we are not going to need it anymore but we do have to write some logic inside of monster encounter first of all we want to check the collisions again which we are doing via Sprites and another list comprehension Sprite for sprite in self. Monster Sprites but only if sprite. w. collide cor with self. player. hitbox the same thing we have done inside of check monster basically dless comprehension although now we want to check if we have some Sprites and self. player. Direction which means we know that this method is only going to be called once the timer is timed out meaning we know that the player has been moving in grass for 2 seconds after this timer we want to check if the player is still in grass and if the player is moving if that is the case I want to set self. player do block and create a new self. transition Target which will be another instance of the battle class and for the arguments for this one just to get started we can look at the transition Target for the character and paste it in there although we will have to make some changes the two AR arents we have to customize are the monsters and the background to get both we have to look at tiled and specifically we want to look at the monster layer because in there and let me hide everything else we get all of the Monster encounter patches and if you look at one of them we're getting a biome a level and the Monsters notice here that the monsters are simply a string with comma separated values tile doesn't allow you to have a list which is a bit annoying but we can work with it so what we want to do is get all of this into P game and then create custom monsters and access the background surface and for that actually we do have to work inside of the Sprites if you scroll down a bit there we have a monster patch Sprite Which at the moment doesn't do very much and adding all of the details and then creating a battle once we are in tall grass is going to be your exercise there are two two parts to the exercise number one I want you guys to import the tile data into the monster patch Sprite you will need a level a biome and a monster names after that once the play is on top of one of those patches use the data to start a battle should be reasonably doable pause the video now and see how far you get first of all we have to work inside of setup and then work a bit more with the grass Patches at the moment we are looping over the layer of the monsters and then create a monster patch Sprite in there we are actually already passing in the biome which should give you a hint of how we can access the other data you can simply copy obj properties because we also want to have the monsters and then the level once we have that inside of Sprites we will need after biome the monster and the level and for now let's simply print what we get I want to print monsters and I want to print the level let's try out of that we are getting the names of the monsters and the average level so that is looking pretty good although that data we have to organize a bit better which means inside of the Sprites I first off I want to create self. biome which're is a biome we are already getting we want to store to monsters but this should be a list which I can get with monsters do split and then split this string wherever we have a period and finally self. level is simply going to be level just to make sure that all of this is working let's print self do biome self do monsters and self dot levil if I now run main. pi we're not crashing and we are getting a whole bunch of data now you can see I was quite lazy when it comes to the grass patches we basically always have the same monsters and the same level but the data is working that's the important part which means we don't need this print statement anymore and next up we can work inside of main. Pi specifically in the monster encounter because this Sprites is going to contain all of these monster patch Sprites or at the ones the player is colliding with so for example to get the background surface we still want to get all of the BG frames but then for the key we want to get Sprites and the first one and on this we have the biome attribute besides that we need a couple of monsters which we are going to create via dictionary comprehension and just as before we want to have a dictionary with an index and a monster which we can get via a for Loop for index and monster in in numerate Sprites zero and then we have the monsters that means for the key we can get the index and for the monster we want to create one instance of the monster class in which we are going to need the name of the monster that we're getting from the four Loop and then we will need a level which we get from Sprites Z do level and and this I want to randomize just a bit meaning I want to add a random integer that goes from 3 to 3 that way we don't always get the same level although I don't think we have Rand in available at the moment we do not so all the way at the top from random import Rand int that is almost all we need the last thing that we have to change is for the character we want to have none so with all of that let's try the game and let's see if something crashes so at the moment the player simply stops walking but we do not get a battle something has gone wrong and I can see it right away we have to set self. tint mode to tint next attempt if I now walk around in the Tall Grass we're getting to a battle and I can still attack the monsters let me use their weak types and after that we go back to the Overworld and we are not able to move anymore but that is a thing we can fix quite easily we simply have to look at end battle and then check if we don't have a character if that is not the case self. player. unblock next attempt and now should get a battle we can still defeat all of the monsters and and after that we can walk around again also now we are getting some experience that is looking pretty good cool that is looking really good there's just one more thing that I want to do when we are encountering a monster I want to set self. encounter timer and switch up the duration which we're going to do via Rand in again and then get a random value I went with a value between 800 100 and 2,500 so the next encounter could be really fast or quite a bit away that means if I now try all of this again I can walk around and we getting a battle so let's defeat the monsters really quick and then we can walk around again and now we get a battle much faster and our monsters do not update their initiative only after we get attacked so something has G wrong but we are definitely making progress so let's fix this bug really quick basically inside of battle. Pi when we are creating a monster I want to make sure that monster do host is equal to fults that way if I run my not Pi again and let me speed all of this up and now we get another battle and there we go we are getting getting the proper behavior everything else is also working just fine so this is looking pretty good so with that we have the entire transition between the battle system and the Overworld we are making a ton of progress the last major chunk then is going to be the evolution system for which I want to create a new python file so a new file and then let's call it Evolution dot High we will need from settings and import everything also we are going to need a timer meaning from timer import timer once we have that I want to create a class called Evolution and then we will need a Dunder init method with a whole bunch of parameters we will need frames a start monster and end monster a font and then we want to end the evolution to get back to the Overworld in there we will first of all need a display uncore surface that we are getting from py game. display. getor surface then we will need self. start monstore surface and an end monster surface the way the system is going to work we're going to show the first Monster and then slowly f faded out to White and once we have reached the full amount of white we are switching to the evolution so in practice we are simply showing two different surfaces which we can get via the frames and both start and end monster are simply monster names which means those we can use inside of the frames so I want the start monster then get the idle State and the first frame now this is going to be very small and to make this a bit more visual I want to put it inside of py game. transform. scale to X that will make it twice as large the same thing I want to do for the end monster with the only difference being that we want to now use the end monster on top of that I want to create a timer dictionary where we have a start timer which would be a timer with a duration of 800 milliseconds and auto start will be besides that I want to have an end timer which is going to get a duration of 1,800 and the function we are going to call is going to be end Evolution or in other words when we are starting the evolution we will show the monster or the start monster for 800 milliseconds and once the evolution is done we're going to show the end monster for 1.8 seconds with that we can already get started with a basic update method for which we need self and Delta time and first of all there I want for timer in. timers do values and then timer. update that way the timers are going to work next up I want to check if not self. timers and start is active that is going to be the start timer and only after this timer is over do we want to do stuff and the thing that we want to do is self. display surface do blit and then I want to tint the entire window which we're going to do via self. tintore surface at position Z and zero this tint surface doesn't exist at the moment but we can create it quite easily and for that I want to create a section called screen tint we simply want to create pame do surface with the same Dimensions as the display surface so self. display surface and get underscore size this surface we want to make semitransparent I.E self. tint surface setor Alpha and I went with a value of 200 but you can play around with it that was quite a bit of setup but now that we have that inside of main. Pi I want to import From Evolution the Evolution class and now we have to figure out when to display this thing and for that I have created another method Define check uncore Evolution no need for custom parameters and basically we want to check for index and monster in self. player monsters. items we first of all want to check if a monster has an EV ution in the first place for that let's have a look at the monster class so we have quite a few python files at the moment we don't have an evolution value in here so we have to create it self. Evolution this value we are getting from the monster data then self. name and in there we have evolve so if you look at game data and the monster data inside of monster data if you look at the first Monster plumet you can see we have an evolv property with the name of the monster and the level needed to reach that Evolution if a monster has reached the final stage then evolve is going to be none so just to make sure you see what we are getting from self. Evolution let's print the value self. Evolution and if I now run m. Pi we are getting an error because I have to add pass in there but next attempt and now we're getting either none or a tupal with the name of the monster and a level that's looking good if a monster has an evolution we want to check if monster. level is equal to monster. Evolution and we want to get the first index that would be the level so inside of game data we would for example get 15 if we have reached that level we want to the evolution animation for which we want to block the player IE self. player. block and then self. evolution is going to be one instance of the evolution class for that we are going to need all of those parameters frames are going to be self. monster frames and we only really care about the monsters here the start monster will simply be monster. name and the end monster is going to be monster. Evolution with value zero the font that we want to use is going to be self. fonts along with the Bold font end Evolution will become a method that we will create in just a second self. end Evolution that we have to create right away fine and evolution with self following this method we'll set self. Evolution to do none and unblock the player I self. player. unblock finally inside of the run method we want to have one more overlay If self. evolution then self. evolution. update with Delta time and now to test this system if you look at the player monsters there we have Lavia which is level three and inside of game data if I find it really quick there we have Lavia and this one evolves to cleave on level four so we should get this one quite easily which means if I run main. Pi we are getting an error message that there is no attribute Evolution that happened because when we are creating the dunder ined method we don't have an evolution that we can add quite easily at the end self. evolution is going to be none next attempt the game doesn't crash and now if I encounter random monsters I can defeat them really quick and look at laia's level we should be reaching level four and we do and now we do not get anything so something went wrong and well the thing that went wrong is we are not calling this this check Evolution method to fix that we want to look at end battle and instead of an El statement I want to check L if. self do Evolution then I want to unblock the player and self. check Evolution so next attempt and now now we are getting a tinted screen which means that the evolution system does work although at the moment it well doesn't do anything first of all I want to create a rectangle via self. start monster surface and get F rectangle I want to place the center right in the middle of the window which means a tupal with window uncore Wii divided by two and window uncore height divided by two as well after that self. display surface. blit with self. start monster surface and a rectangle and while we are testing all of this to make things a bit easier inside of the dunder init method I want to set the level of Lavia to four right away and also we don't need the dummy monsters anymore and then after we are creating everything else I want to call self. check Evolution that way once the game is starting we are getting the evolution screen right away and at the moment nothing's going to happen but that we can work on at least we can see the Monster also before we continue this print statement is getting a bit annoying in fact I don't think we need the monster class at all anymore next up inside of evolution. Pi we are already displaying a monster but this I want to tint or to be a bit more specific I want to apply a white tint to the surface for that we will need self. start monster surface white quite a long name but basically what we're going to do we're going to get pame dok and then from uncore surface the self start monster surface which we are then going to turn into a surface right away to see what we are getting from that let me blit this start monster surface white right away with that if I now run MP again we are getting something like this a good start but we want to get rid of the black background that is not a problem at all self. start monster surface white then set uncore color key with a black value next attempt and that is looking good now this monster surface should fade in very slowly for which we're going to need two more values self dot tintore amount and self. tintore speed those values I have set to zero and 50 The Tint amount has to start at zero Al do tin speed you can customize after we have that I want to get self. start monster surface white and set the alpha value to self. Tin amount that way it's not going to be visible in the beginning but what we can do when the timer has timed out and we are actually displaying things I want to get self. start monster surface and that would display the monster itself after that I want to get self. tint amount and increase the value by self. tint speed multiplied with Delta time and now that we have that value self. start monster surface white we want to change the alpha of this other surface with self. tint Mount once again or in other words for this white surface we are setting the alpha value in the init method to zero so it's not going to be visible but in the update method we are increasing the tint amount value and then updating the alpha value that way it will slowly fade in that we do have to display bya self. display surface. blit with self. start surface monster white along with the rectangle let's try all of that and the monster is slowly becoming white so Death part is working it might be a bit slow let's change to 50 to and 80 it might be better so now all of this happens quite a bit faster but once again choose whatever value you think looks good in my case I want to go to the next step and that is going to be that we only want to do all of this if a condition is true if self. tint is smaller than 255 if that is not the case else then we want to display the Evolution for which we're going to need another rectangle which we can get via self. end monster surface and get a rectangle where we are placing the center right in the middle of the window for that we can duplicate those values afterwards self. display surface dolit with self do and monster surface and the rectangle next attempt we are getting the monster and after it gets completely white we're getting the evolution that looks really good once we have all of that we can also get self. timers and the end timer and activated remember for this timer once it times out we are calling end Evolution that way we're getting back to the Overworld although this timer I only want to call if it is not currently running meaning if not self. tim. end. active and with that if I now run main. Pi we're getting the evolution after a short amount of time then we are evolving and then we can walk around again although if you look at the monster index nothing has changed that we can work on in a second first of all I want to finish the evolution screen because I also want to have some text in there that's going to happen inside of the dander init method I want to have text specifically I want to have two text surfaces start text surface along with an end text surface both of those we are going to create bya cell do render where we will need some text then fults and then colors with the black color the text for the start surface is going to be an F string with the start monster and is evolving and make sure that all of this is actually a string and pay close attention here start monster is what we're getting from the parameters we are not actually storing this inside of the class we are turning it right away into a surface or into a piece of text for the end surface I want to have another F string with the start monster and evolved into the end monster that way we have two surfaces that we want to display the first one is going to be in the first if statement where we are still displaying the original monster I want to create a textor rectangle with self. start text surface and get F rectangle I want to place the mid top to rect do mid bottom plus a vector for an offset of 0 and 20 pixels after that self. display surface. blit with self. start text surface and the text rect angle also before we are displaying the text I want to have some background which we will create via py game. draw. rectangle I want to draw on the display surface the color is going to be colors and white then I want to get the text rectangle and inflated by 20 pixels and then finally zero for the Border width and five for the Border radius that should be all we need for one part of the text let's try all of that and we get Evolution has no attribute render that happened up here instead of self. render this should be self. font. render the font we're getting from up there and in fact this shouldn't be self at all this should just be font. render next attempt we are still getting the evolution and now we're getting some text as well good start so next up we have to display text in the El statement we can simply copy the original piece of text and paste it in there for the text rectangle I want to get the end text surface although the rest can stay the same then for py game. draw. direct we can keep all of this the same as well and finally we want to display self. end text so surface along with the text rectangle that should be all we need next attempt we get the evolution and after that we get another piece of text and then we can walk around again perfect that nearly finishes the animation for the evolution there's just one more thing that I want to do if you look at the folder for the project in graphics and other we have a star animation this I want to play once we get to the evolution it's not terribly complicated we simply have a whole bunch of stars and that's basically it to play those first of all we will need an import and that happens in the dunder init method under import assets right below the BG frames I want to have self dot star animation underscore frames which we can get via Port underscore folder then we want to go up a folder to Graphics then to other and there we have the star animation let me run the code to make sure this is working and it does that's looking good after that we want to look at check Evolution down there and if a monster is evolving when we are creating one instance of the animation I want to pass in self. Star animation frames that means next up inside of evolution we want to get the star animation frames or I guess we could just call it star frames that's a bit easier for those I want to add another section with this star and in there we want to have self do star frames which is going to be star frames also we will need a self do frame index and before we continue I want to scale up all of the frames inside of this list like we have done for the start and end monster surface which means a list comprehension with pame do transform. scale to X with the frame for frame in Star frames that way the entire thing looks a bit more coherent cool once we have that when we are seeing the final monster I want to run a method called self. display Stars along with Delta time this method doesn't exist right now so we have to create Define display stars with self and Delta time this is just going to be a basic animation I.E self. frame index plus equal some kind of Animation speed I think I went with 20 and multiply it with Delta time and then if self. frame index is smaller than the length of self. star frames we want to get a frame we want to get a rectangle and then self. display so surface with the frame and the rectangle the frame is simply going to be self. star frames with integer of self. frame index the rectangle is going to be frame and get F rectangle that we want to place right in the center of the window which we have already done a couple of times I can copy the line and that should be it if I now run main. Pi we get the evolution and once we are done we're getting an error message this surface is not callable that happens because I forgot to add dot lit so next attempt and that is looking really good everything else also works just fine so I am quite happy with the animation that means we can close evolution. pi and the next important part is that we actually get another monster so we are applying the evolution after the evolution animation I want to get self. player monsters along with the index that we are currently on and with that we are overwriting the current monster which is totally fine because we want to create a new monster with monster dot Evolution and zero I eat the evolution monster and then the monster do level that way if I now run all of this again we get the evolution and at some point we get a new monster if I now open the index we have a whole another monster and to test all of this just a bit more inside of thunder in it I want to set the level of Lavia back to three so now if I am over a grass patch we should still get a battle and I can defeat the enemy quite quickly that part is working and now we get the evolution and then we have another monster and we can continue the game that is working quite well also at this point we shouldn't check Evolution anymore inside of Thunder init and also once we finish fighting a trainer we should check for an evolution which means inside of end dialogue once we have defeated a trainer self. check Evolution don't forget to call it and in the game let's try to find this trainer shouldn't take too long we get some dialogue and afterwards we're getting the evolution this part still works just fine and then and we can once again continue everything cool with that we have the evolution that means we are basically done besides the audio so let's get started with that first of all we have to import a couple of files and that's going to happen inside of import assets at the bottom I want to have self. audio for which I want to have an audio importer with a file path up a folder then we want to go to audio and that's actually it if you look at the project folder inside of audio we have a whole bunch of files that we want to import for that we want to work inside of support. piy and let me minimize everything at the bottom of the Importer functions I want to have an audio importer along with a path and for all of that we have already seen something similar except now I want to have a dictionary with the files then for folder underscore path the subfolders we don't care about so underscore and then we have the file names in walk and join of the path after that we want to look at all of the file names I.E for file name in file names next up we want to create a full path using the join method and then stitch together to fold the path with the file name and once we have that I want to get the file's dictionary and create a new key value pair the key is going to be the file name and this we want to split to get rid of the file ending which means wherever we have a DOT we're going to split it and then pick the first value the value we are going to assign to this key will be py game. mixer. sound along with the full path at the end of all of this I want to return the files dictionary at the end of all of this I can print self. audio run the entire game it doesn't crash and we get a dictionary with a whole bunch of sound files that's a really good start that means we don't need the print statement and we can collapse import Assets Now we have to figure out when to play the sounds and the first sound I want to play is if one of the characters notices the player I want to play the notice sound for that when we are setting up all of the characters down here I want to add a notice uncore sound which is going to be self. audio and notice after that inside of entities. pipe when we are creating the character we need one final parameter notice uncore sound that we want to store all the way at the end self. notice sound is going to be the notice sound after that inside of the raycast once the character sees the player we want to get self. Noti sound. playay and with that if I now run main. Pi we should be able to hear a sound and we do that is working pretty well so that covers the entities we also don't need the Sprites anymore the next important part is going to be the battle there we want to have a whole bunch of sounds that we are going to pass into it when we are creating one instance of the class and this happens in two spots so when we are ending the dialogue we want to have the sounds which we're getting from self. audio this I can copy because next up when we have a monster encounter we want to have the same value and after that we have to make sure that we are storing all of this as an attribute and let's place it all the way at the beginning do sounds is going to be sounds and to make sure you can see what's going on let me print what we are getting self do sounds if I now run main. pi and we are getting into a fight the game doesn't crash and we can see a whole bunch of sounds now for the battle the only sounds that we are going to use are going to be for different attack moves for example we have fire we have ice we have green for healing and then a few more the way this system is going to work if you look at game data and hide everything besides the attack data every attack has an animation for example there we have fire green scratch and so on the name of the animation is also going to be the name of the sound we want to play so if we have the fire animation we also want to play the fire sound fairly straightforward when we are applying an attack that happens down there right below the attack Sprite we also want to get self. sounds and then get the attack data Al with the attack and then we have I call this one the animation that way we get the name of the file we want to play and well this we want to play if I now run main. pi and and we can get into a fight that sound is working and the fire sound is working let's try one more for ice that is also working cool so with that we have all of the sound effects that leaves us only with the background music and that we have to work with inside of the game class so we don't need battles support or game data first of all in the dunder Ed method after we are doing all of the Imports I also want to self. audio and get the Overworld and play that one also for an argument I want to add a negative one to play this one continuously the argument we're specifying here is for the loops if you set this to five You'll Play the audio five times a negative 1 plays it forever cool that is working well so with that we have an overwhel sound that means we don't need Dunder in knit anymore and next up if we are ending a dialogue and then starting a battle we want to do two things number one we want to get self. audio with the Overworld and then stop that track on top of that I can actually duplicate the entire line because we now want to get the battle music and play it once again with negative one so we are playing this continuously also this we have to do for the end dialogue and for Monster encounter meaning before we are starting the battle we want to stop the Overworld Music and start the battle sound let's try all of that okay this works reasonably well but once the battle is over we do not stop the battle music for that we want to look at end battle and then once the battle is over we want to get self. audio battle and stop the music after that that is the case we want to check if we have an evolution then we want to play The Evolution sound if not we want to play the Overworld sound for that we want to look at check Evolution and if there's an evolution we know that we have a value for self. evolution however if we don't have self. Evolution then we simply want to get self. audio the Overworld and play that one on the other hand if we do have an evolution then inside of this if statement I want to get self. Evolution and play that sound finally then inside of end Evolution I.E the evolution has finished we want to get the overwat sound and play that one with negative one this should also happen up here and on top of that we want to get the evolution sound and stop it and I usually put the stop sound before the play sound that just feels a bit better and I think that's it if I now run all of this again all right and that part is working as well so with that we have the entirety of the game and this was a longer tutorial I hope you found it useful and I'll see you around