hello in this tutorial we are going to cover cameras in pygame and i have created six projects that should basically cover any kind of camera you would ever need so let's go through them before i jump into the code number one is a camera that dynamically places elements on top of each other so we have a proper drawing order and this is creating a nice fake 3d effect the next camera is going to be a camera that always centers on the player number three is a camera box so we do not center the player but if the player moves too far to the left to the right up or down we are moving the camera along with the player so the player never leaves the screen number four is quite simple we are controlling the camera with the keyboard and in number five we are using the mouse in the same way and finally number six we are going to give our camera the ability to zoom in and out and all of these cameras also work with each other if you really want to combine them and really quick for the setup we have all of our code inside of one folder that is going to contain all of our files and inside of that folder we have one subfolder called graphics and inside of that we have three different files we have the ground the player and one tree so my case there's not much variety but if you had a proper game obviously you would add a lot more graphics in here so with that let's get started with the project setup i already have a couple of things in the game to save some time and i guess let's have a look at them here we are in the code and we already have 64 lines of code so i do want to go over that but we only have a single python file so all of our code is going to be in this one file we will never create another one we are starting by importing the usual stuff for pygame and randint you will see why we need rent in in just a second after that we have two classes tree and player for now don't worry too much about them i'll go over them in just a second once we have those we are initiating pygame with the display surface and the clock nothing fancy is happening here after that we are creating our camera group this one is later going to become incredibly important but for now it is just a sprite group nothing more after that we are putting the player somewhere inside of this group so the player has a position and a group once that is done we are placing our trees in here so i just have a for loop and we are placing 20 trees i am using rand end to create a random position and then we are placing the trees in this line here so just like the player the trees get a random position and the camera group that's just about it and with that setup we have our game loop our event loop doesn't really do anything right now except for closing the game we are filling the game with a bluish watercolor then we are updating and drawing the screen and we are doing the usual pie game stuff and all of that gets us basically this we have a player and we have a couple of trees and a blue background and right now my player is always behind the trees and the reason why the player is always behind the trees is because the player is created here let's call it number one and all of our trees are created here let's say number two and because of that the trees are always on top which is well not ideal but we are going to fix that and let's have a really quick look at the classes they aren't that complicated the tree class is incredibly simple so we are giving them a position and a group they have an image and the image is always going to be the tree in our folder and then this tree gets position and the position is well wherever we want the tree to be and the player is a tiny bit more complex although not that much for the image we are still importing an image and we are giving it a position and that is the position we get from the parameters the one thing we have for the player as well is a direction and a speed and this speed we are using in the update method down here to move the player itself and how the movement works is from the input we are influencing the direction and then we're adding this to the rectangle center and that way our player is moving and all that the input method really does is we are checking for up down right and left and using that to influence the vector so if you have any idea of pi game this shouldn't be difficult speaking of if none of this made sense check out my introduction to pygame this one is going to explain all of this in quite a bit more detail and if you want to have more information on a topdown game i have made a full zelda game and a simplified zelda game so check out those as well if you're really interested so alright with that we have our setup so let's get started with the first camera and that camera is going to order which elements are supposed to be on top of each other and this kind of camera is called the y sword camera you're gonna see in a second why but let me explain the problem first so what we want to achieve is something like this that the player is dynamically on top of the trees if the player is in front of it but we also want the player to be behind the trees if the player is well behind the trees but we don't really have a concept of behind or in front in our game because we only have a x and a y coordinate we don't have a z coordinate so we have to figure out how to know when the player is supposed to be in front like this one or behind another element like in this one and the solution to figure this one out is actually quite simple and well like the camera name implies we are sorting all of our elements by the y sort position so if this here is the top of the window so y being zero the further down element comes in this the higher it should be drawn so for example for this player here let's say the y position is 10 and for the tree in both cases we have a y position of let's say 50. now because the tree has a higher y value than the player the tree is going to be drawn on top however now for the other player this one down here if this one has a y position of 100 then this y is going to take priority over this one here and that way we make sure that elements overlap in the right way although we do have a problem and the problem is where can we actually implement this kind of logic so where can we control the drawing logic for our game and the answer is quite simple that all of our drawing happens inside of the group in our case this is the camera group and this we are going to customize so we are going to take some parts of the group and change them to make them more useful for us and let's do this straighten code i think that's going to be the easiest way to approach this here we are back in our code and right now my camera group is this pygame.sprite.group and i want to overwrite this group so let's call it camera group to have a specific name and this camera group is still going to be a sprite group just one with more custom functionalities so let me create a new class that i called camera group and in here we have to inherit from pygame.sprite.group and the very first thing we need just like for the player and for the tree we need to create an init method and initialize the parent class so we again need define underscore init it needs self and nothing else and then we need super and dunder init and with that our camera group already has the same functionality as a sprite group so if we had to run the game now nothing should change and let's try and it is indeed working like any other pi game group so this is a good sign now what we can do is to overwrite functionalities in this class and what i essentially want to do is to create a custom draw method and for now this is only going to need self and nothing else and now we kind of have to understand how pie game actually draws something and this is remarkably similar if you have any idea of pie game in the normal draw method what basically happens is we are cycling through all the sprites in self.sprites in this camera group right now we have the player and all of the trees and they are stored in self.sprites and it's really easy to forget the brackets don't make that mistake and then all that pie game really does is it calls the screen then a chord split and then sprite dot image and sprite dot rect or i guess to be a bit more specific this screen here comes from a parameter so let's call it screen in here and this is the screen we have to pass in here and now we can use our custom draw method and use custom draw and if i run this we still get the very same results even though now we have created our own custom draw which is remarkably simple and now let's start to make some changes to this so we can use it a bit more easily the first one i would like to make is i don't really care about creating a parameter here i want to have my display surface available in my camera group immediately and all we have to do for that is create another attribute let's call it display underscore surface and to get the display surface we need pygame dot display dot get underscore surface and now we can use that display surface to draw on and because of that we don't need the parameter anymore and we don't need the argument down here anymore and still if i run out of this same result the game works just fine and with that we can actually already get our sprites sorted all we essentially have to do is when we are drawing all of our sprites here we have to sort them by the y position and this happens with the sorted method that is native to python and sorted takes two arguments it takes the list you want to sort so my case self.sprites and then it needs some kind of key on how to sort these elements so key and in here we have to extract the y position from each of the sprites and for that i'm going to use a lambda function with sprite is what i'm looking at and all i really want to return is sprite.rect.center y which basically means i am telling python to look at this list and sorted by the center y position of each of the sprites if you understand lambda functions this should be fairly straightforward and well that's actually all we needed so let's try this now and now my player is behind the trees but now it's in front and this works for all of the trees so now we have dynamically added the ability for our game to draw stuff on top or behind and this adds some nice fake 3d which i really like it makes the game look significantly better and cool this is working super well now you can actually work with this quite a bit more for example what we also have is a ground and the ground shouldn't be in this list at all the ground should happen before so we want to have the ground here and then let's call it active elements or something like that and to implement this logic we just have to draw elements here before this for loop that's all you need and in my case i have approached this in this way in the init method i have created self.ground underscore surface and this one is just pygame.image.load and we need to import graphics and ground dot png and don't forget to convert that and then we also need self.ground underscore rectangle and we need self.groundsurface.get underscore rect and the top left is going to be a tuple with 0 and 0. and that way we have access to a ground and a rectangle on where to place it and now we can just call self dot display surface dot blit and place in self.groundsurface and self.ground rect and if i draw this now we have a ground but something went wrong with the alpha but at the very least we have a ground that's always well on the ground and otherwise we are still having our player behind or in front of the trees depending on where we are and the one mistake i made is that this convert should be convert alpha so now the stress again that fits better so now this is still working really really well and that is already the first camera that we needed to create some fake 3d and with that we can come to the second camera and that is a playercentered camera so a camera that always follows the player and before we can implement that we have to address another question and that question is how does a moving camera work in the first place so how can we shift stuff around on the screen because our game window always starts at position 0 and then goes up to a certain point in our case 1280 and 720 and this window we cannot move no matter what we do so we have to figure out something else and let me explain how this is working usually when you use pygame you have a rectangle and you place a surface right in the middle of that rectangle so the position of these two elements are identical but they don't have to be you could totally draw the surface somewhere outside of that rectangle and this is what the camera does so essentially we have our rectangle but now when we draw the surface we are adding a vector offset and only then are we drawing the surface so for example if the top left of our rectangle this point here let's say was a hundred and two hundred for x and y respectively and our vector let's say is something like let's say 150 then our surface would be drawn at position 200 for x and 250 for y so even though our original rectangle had this position we are drawing the surface somewhere else in this position here because of the vector offset and the only thing we need now is to get this vector offset from the player position so for example if the player is walking to the right then we want this vector offset to move in the opposite direction because remember for a camera if you're working right you want all the other elements to move to the left so you have a counter movement and that is essentially all we needed so now we can start working on implementing all of this here we are back in the code and let's get to work on all of this now first of all i want to add a bit more comments to have this thing a bit more organized it's getting a bit messy that's looking better now what i really want to get is let's call it camera offset and this is going to be self dot offset and this is going to be a pygame.math.vector2 and for now with position 0 and 0. so we can just leave it empty how we are going to use this offset is when we are drawing these elements here and this ground as well i want to add the vector to the rectangle so this rectangle here and this rectangle here and let's start doing this inside of the for loop and essentially what i'm going to do i'm going to create an offset underscore position it's not an underscore position and we are getting this with sprite dot rect dot top left plus self dot offset and then we're using this offset position to place the surface and the same thing we also have to do for the ground so let's call this one the ground offset and this one is going to be self.ground dot top left i am terrible typing today and plus self dot offset and right now since our offset is zero this should not be changing anything so let's run the code and indeed we can see nothing has changed which is generally a good sign however what i can do now is add numbers to this vector so let's say i want to give it 300 and 100 now what we can see is that our entire window is moved 300 pixels to the right and 100 pixels down although i just realized for the ground offset i actually have to apply it down here so now let's try this again and this is feeling better and let's really emphasize this let's say instead of 300 let's go with 800 and for y we're gonna go with zero now you can see all of our elements are way to the right we can still move the player but well the player starts already outside of the window so what we have to figure out now let me move those back to zero and zero what we have to figure out now is how to center this offset relative to the player and right now i want the player to always be in the center of the window and let me draw out how this is going to work let me minimize this method here so i have a bit more space essentially imagine that this here is our entire game window and inside of this window we have our player roughly here and the really important information i now have to figure out is this point up here because the top left is going to be the reference point where we are going to start and this also is going to be the offset we are going to move by default this is 0 and 0. so essentially we are going to add this vector to it and that way 0 and 0 becomes whatever this offset is going to be and since i always want my player to be in the center of the window i want the player to be half the width of the screen so let's call it w on the xaxis and half the height of the window on the yaxis so let's call it h divided by 2 and with divided by 2. that makes more sense in terms of math then what i essentially want to do i want to get the center of my player and subtract either the width or the height from that and use that to get this position up here and let's implement this and the logic here i feel like can be a bit confusing i would really recommend you to play around with this but let me actually implement this then i think it's going to make sense and first of all let me minimize the tree and reopen the init method the first thing that we are going to need is the width and the height of the window or well half the width and half the height and let me do this below the offset and let's call itself half underscore w and we're getting this with self.display surface and then get underscore size and this returns a tubal with x and y and we only care about x and we want to divide this by two and for the height we can do the same thing with h and we need the first integer of this tuple so now we have half the width and half the height now when we are drawing this custom draw i want to apply this half width and half height to my offset and let's do this in a dedicated method so we can keep the different cameras apart from each other and let's call it the center target camera it needs self and it needs a target in my case it's going to be the player but it could be literally any object in your game and for this one i want to set myself dot offset and the x position and self.offset and y position and now we just have to apply what i just explained so i want to get myself.target.centerx and from that i want to subtract self.half with and for y i want to get myself.target.rect. center y and subtract self dot half ike and that was all we needed almost actually all we have to do now is call self.center target camera and place in a target in my case it's going to be the player right now we don't have the player so i'm going to create a parameter for the player and this player we don't really have accessible right now but we can just put it into a variable so player and then when we call custom draw i can add my player in here and now there's one more thing we have to do but let's just try it and see what happens we are getting an error ah because this shouldn't be self it should just be target because it's a parameter now if i run this our camera moves in exactly the wrong direction which is a very disorienting experience and the reason here is this line that this should be negative because if we are simulating a camera we want to move all of the elements in the opposite direction that our target is moving and if we're not doing that you well saw the results and now if we try this i realized i forgot we have two offsets we have this one and we have this one and if i try this now now it is working properly so i can just walk around and the camera always follows the player and the depth perception still works where our player is drawn behind or in front of the trees which is already a really useful camera cool and with that we have covered our second camera which wasn't actually all that bad so with that we can talk about the next camera the box camera and basically how this is going to work we have our player inside of our screen and we also have the camera box and if our player is moving to the left of that then we want to move this rectangle also to the left that way our player can move inside of this rectangle without moving the rectangle but once we are going too far down let's say then we're moving down the camera so our player basically can never leave this camera box and this is pretty much a 2d platformer kind of camera you also see it in a lot of topdown games as well it's a really popular one and how we are going to implement this is this camera box here is going to become a rectangle that we are then going to move along with the player and remember for our last camera we used the difference between our player and the top left for the offset to move all of the elements what we are now going to do is our player is going to move the rectangle and then the top left of the rectangle is going to influence the offset and that is probably kind of hard to follow let's implement all of this in code that should make more sense here we are back in the code and the first thing i want to do is to add another section to our camera and let's call this the box setup and in here we basically want to create what i called a camera underscore rectangle and this is the red rectangle i just talked about this is going to be moved by the player and determine the offset so this has to become a pie game dot rect but we now need a left a top a width and a height and we don't have that so we have to add a few more lines of code to create this kind of rectangle and the first thing i have is what i called camera borders and in here we have left right top and bottom and this is basically the distance from the border of the screen to the camera side when we should start moving the camera so if this here was our window and from the left we want this distance that's going to be left it will be 200 and just for another example for the top is going to be this distance here 100 pixels and these distances we can now use to create a left a top a width and a height and let's just go through them one by one first of all for the left side i want my camera borders and i just want the left side that one is really easy same with top actually we need self.camera borders and we just want top essentially what we have just done if this is again our window we have figured out the top left of the rectangle with the left and the top what we now have to figure out is the width of this rectangle and the height of this rectangle and this we are getting from the right and from the bottom and let's start with the width we know that the entire rectangle is 1280 pixels wide we also know that this distance here is 100 pixels and this distance here all the way on the right is 200 pixels that's the information we get from right which means all we really have to do is get 1280 minus 100 minus 200 and that way we only get this middle side here and then we can do the same thing for the y position and we are good to go which means all i really want to do is get myself dot display surface and get underscore size and i want to get the weft and from that i want to subtract myself.camera borders left and self.camera borders right and now we can just copy all of this for the height we need integer one to get the height and i want to add the top and the bottom and now we have a camera rectangle and this may still be a bit uncertain what we're actually doing here so let me draw this camera rectangle to illustrate what's going on all the way at the bottom i want to pygame.draw.rect on myself.displaysurface let's make it yellow and self dot camera wrecked and let's give it a border so we don't fill the entire window and now if i run this you can see here we have our camera rectangle and it moves along with the player oh well it doesn't really move along with the player it's just that we don't update the position but at the very least we know it's kind of working what i want to do now is that the top left of this camera rectangle should set self.offset meaning that this self.offset and this self.offset should both be determined by this camera rectangle and again let me comment out our center camera and put all of this in a separate function and i called this box target camera again we need self and target and nothing else at the end of this line i want to set my self.offset and let's separate this in x and self. offset that thing i think that makes it a bit easier and here again let me explain what we have to do we have our window and when we talked about the center camera so this one here we went from the center where the player is all the way to the top left but in this case for the box we have this rectangle and this rectangle in a second will be moved by the player now we want the distance from this top left point to the top left of the window so kind of the same principle except now our starting point is slightly different but essentially i want to get self dot camera rect dot left and from that i want to get myself dot camera borders and left remember here by default this should be zero until we move the rectangle and we can do the same thing for the top and for the top and now let's call self.box target camera and don't forget to call it and now let's try we are getting an error because we don't have a target needs to be player now let's try this and now we can see that well we don't really get anything because we are not updating this rectangle and let's do this straight in the function i think that's going to be the best way to think about it in this function all i really want to do is if my target.rect.left is for example smaller than self.camera rect dot left meaning our player is further to the left than the camera rectangle if that is the case i would set myself.camera rect.left where our target.rect.left is basically meaning here we have our player and we have the box around the player if the player moves outside of this rectangle we want to move the rectangle to the same position so that those two have the same x position and let's try this actually this should be working already now if i move to the left you can see we are moving the rectangle now the drawing here of the rectangle gets a bit confusing but the logic works just this drawing here is a bit strange so let me just get rid of it we don't need it anymore and now let's try it again and there we go this is working really nicely now all we have to do is copy this if statement to cover all the four directions so camera.right and camera.right except now we're checking if this is greater than but other than that we are just switching left to right and let's try this one now my player is moving right my player is moving left and this is working really well cool then next up we can do the same thing for camera rect let me just switch all of them at the same time so top and we have to check for smaller and i guess while we add it let's do also the bottom to have all the four directions so all of the tops here should be bottom and then we again need greater and now we should be done so this is working really well nice and i guess to make the trees a bit less confusing let's change this 0 to 1000 to 1000 to 2000 and now let's try this again now we can't see trees over the water anymore and all the trees are here which is uh significantly more realistic but well you can see that you can place stuff basically wherever you want it still works just fine and all right with that we have our next camera sorted which means we can now work on the next camera and that is a keyboard controlled camera and this one is probably the easiest one of them all once we have the setup we already have because essentially all we have to do is to use our keyboard keys to influence the offset that's literally it we can do this straight in the code this shouldn't take long at all here we are back in our code and i want to create another method and let's call this one keyboard control in itself and nothing else first of all i have to get my keyboard input which happens with pygame dot key and get underscore rest and then i want to check different keys now since i already use up down left and right for my player i am going to use if keys and pygame.k underscore a i am basically going to use wasd for the controls and now we kind of have to make a decision how we want to influence the offset do we ever want to influence the offset immediately or use our camera rect and influence the camera with that let's actually do both and then you can see what i mean so if i press a i want to get myself.offset.x and move it in a certain direction the direction i want let me add another section in here and that could be let's call it camera speed and in here i want self dot keyboard speed we are later going to have a mouse speed as well and i do want to keep them separate and for this one let's go with five now if we are pressing to the left we want to decrease our self dot keyboard speed and well now we just have to duplicate this a couple of times let's say with d and now i want to add my keyboard speed then i want to get my up then we want to move in the y direction and it should also be negative because we are moving up and finally we have s and now we're moving down so this is plus so now i just have to call myself dot keyboard control run the game we are getting an error because this should be pygame dot key now let's try this again there we go so i can still move my player around but now if i use wasd i am moving the actual camera around and i can use those two independently of each other that one works totally fine and all the other elements still work just fine now you do have to be careful if you want to use the box camera as well you might get a problem if you use both the keyboard control and the box camera one way to avoid that is to not use the offset but instead to switch the offset to the camera rect and then at the end we can copy from our box camera these two lines here and paste them in here so now instead of having the player change the camera rectangle we use the keyboard to do all of that and let me clean this up a tiny bit i think if we put the if statements on one line this is a bit easier to read there we go this feels much better now we should have the same outcome and we can still move the rectangle around except now we are controlling the rectangle first and the rectangle influences the offset and that is a bit of a better way i think if you use both the box target and the keyboard control but both approaches are basically fine and if you combine different camera methods i would recommend to play around with this quite a bit it's very easy to get bugs in there but alright with that we have our keyboard control so next up we can work on the mouse control and this one is going to be a bit more complex let me explain what we are going to do first we set up our player and we have our screen and the basic logic is going to be that we still have our camera box we are actually going to reuse the same camera box we had earlier and now we are not going to check the player position at all instead we are going to check the mouse position on every frame of our game and if the mouse position goes outside of this box let's say our mouse is here then we are going to check this distance here then we are going to move the entire rectangle by this position and we are also going to disable our mouse position so it can't move any further to the left which by itself is pretty simple the one thing that makes this whole process a bit tedious is that we can only get the mouse position once per frame which means that we have to do a lot of if statements now we do have a problem with this approach though that we can only check the mouse position once per frame if you do it more than once it just stops working but that is kind of a problem we have this side here this side here this side here and this side here and all of those work by themselves we only have to check our mouse position once but we also have this corner this corner this corner and this corner here where we want to check both the x and the y position and as a consequence we have to write eight if statements in total or at least we have to cover eight different cases which gets a bit tedious but once you understand the logic it shouldn't be too difficult i guess let's implement it and let's see how far we get here we are back in the project and i want to create a new method let's call this one mouse control we need self and nothing else and in here first of all i want to get my mouse position and this we get with pygame.math.get underscore position and since we have to work with this quite a bit in terms of math i want to turn this position into a vector so pygame.math.vector2 actually this shouldn't be math this should be mouse now we are going to need another vector which i called mouse offset vector and right now it's just going to be pygame.math.vector2 with 0 and 0. and what this vector essentially does if this is our entire screen and this one here is our camera rectangle if the mouse goes outside of it then this distance here is going to be stored in the vector and this could either be an x direction it could be a y direction or it could be both which is why we need this as a vector and now we have to figure out the borders of our mouse so at what point does the camera start moving and in my case i am going to use the camera borders i really want to emphasize we are using the camera borders not the camera rectangle and the reason is that our camera rectangle can be moved around in the world but the mouse isn't bound by that the mouse is always relevant to the original game window i hope that makes sense it's a bit confusing when you work with cameras just think about it for a bit i hope it makes sense but anyway since we're going to use those quite a bit i'm going to store all of this in a couple of variables to make it a bit more understandable so we have left border top border right border and a bottom border and the left border is just going to be self dot camera borders and left then we have self dot camera borders and the top and the right border is now going to be self dot display surface dot get underscore size we want to get the width and from that we want to subtract self dot camera borders and right which basically means if this is the entire width of our window we are subtracting the right let's say it's this distance here and then this point in our game is the right side so the rest of the game would be something like this and now we can do the same thing for the bottom border except now we need the height and we need the bottom now we have the borders of where our mouse is not supposed to go beyond what we have to do now is a ton of if statements and let me cover all of this let me minimize this method here so i have a bit more space because there's going to be quite a bit of drawing coming up here we have our entire game window and what i first want to check is if our mouse is inside of these two sides so this is the top and bottom of the left side and the top and bottom of the right side importantly now we are excluding the top so the top and bottom of both of these sides is not included because right now i only want to check the x dimension and not worry about this other position whatsoever and what that means is if the top border is smaller than mouse dot y which is the mouse we get from all the way up here and if that one is smaller than the bottom border then we know we are in this area and now i can check if my mouse dot x is smaller than the left border meaning now we are in this area here if that is the case i want to set my mouse offset vector and x then i want to get my mouse.x and from that i want to subtract my left border essentially what this is going to give us if our mouse is right here now we are getting this distance and storing it in mouse of side vector and once i have this distance i want to get pygame.mouse and set the position of this mouse and in here i have to specify an x and a y position now for the y position i want to put my mouse where my mouse used to be because i don't care about y right now but for the x position i want to place this at the left border this would then be the logic for the left side of the window all we would have to do at the end is set self dot offset and plus equal my mouse offset vector and let's actually try this and see what we get so in my custom draw i want to disable the keyboard and now self. how did i call it mouse control and let's see what we get we are well getting an error because this shouldn't be a double equal sign now let's try this again we're getting another error that self dot display i am losing the ability to type x attempt oh it should be display surface next attempt there we go now if i move my mouse to the left side there we go this is working very nicely all we have to do now is cover all of the other seven sides and we are done now first of all i want to check if my mouse dot x is greater than my right border and if that is the case let me copy all of this then i want to check my mouse x minus my right border and i want to set the right border as the position of the mouse let's try this i can move right i can move left and that is working really nicely all right this is working just fine so now we can also start working on the top and down movement which is going to work very similar compared to this line here so let me just copy it and now i want to check if my left border is smaller than mouse x and if that is smaller than my right border and if i draw all of this and let me clean this up a tiny bit so now we only care about the top line here and the bottom line here and again we are not including the right or the left side you actually gonna see in a second why that is but first of all i have to do a lot of similar logic i have done here so let me just copy the entire thing to save me some writing first of all i want to check if we are on the top of the window so if mouse.y is smaller than our top border and if that is the case i want to get the y position the y position again and this should be the top border and now when i set the position of the mouse i want to keep the same x position but the y position should be the top border and then the same for the bottom so now we are checking if we are greater or if the mouse position is greater than the bottom border and if that is the case i want to get the y position the y position again and from that subtract the bottom border and then again let me actually copy it from here we want to set the x position where the mouse used to be but we want to put the y position of the mouse on the bottom border and there we go now we have four sides covered so now i can move left and right i can move down and up but if i try to move both down and right my mouse just keeps on going outside of the window which is not great and this is the problem that happens in all sides and essentially what happens here is we are first checking the left and the right side and then we are setting the mouse position here once after we are done with that we are doing the same thing for up and down the problem is we can only set the mouse position once per frame so if we trigger both the second one is not working anymore so we basically have to add a couple more if statements and these if statements have to go inside of the first if statement because remember if we are setting the position of the mouse once this one down here doesn't seem to be running anymore so we have to add more if statements here for the edge cases and then if they're running all of this will be ignored so i want to get an else statement in here that else let's say mouse dot y is smaller than the top border and inside of that i want to check if mouse dot x is smaller than the left border and with that i know the mouse is on top and off the left of our borders so now i can get my mouse offsite vector and this one is going to be my mouse position and from that i want to subtract my left and my top border both of them from the x and y position respectively so in my case i turned both into a vector so math vector2 and here we have the left border and the top border meaning now we are setting both of these positions at the same time and then when we are resetting the mouse we are calling pygame.mouse.set underscore position and now we have the left border and the top border and with this setup we are only calling set position once we're not calling it twice and well now we just have to cover all the other cases so if mouse.x is greater than the right border now we're in the top right border which brings us in the top right corner and let me copy all of this so i save a bit of writing now we still get our mouse position but from that we are subtracting the right border but still the top border and then when we are placing the mouse i want the right border and that covers the top left and the top right now i want to copy this entire l if statement and now my mouse dot y is going to be greater than the bottom border so now we cover the bottom corners and in here we are still wanting to check the left side but now we can keep all of it except the top border should be the bottom border or both of these and now we're checking the bottom right so the right border and the bottom border and we are checking the bottom border when we are setting the position and you can kind of tell kind of an elaborate if statement but now if we try it off this oh it should be l if and l if it's been a long recording session there we go now if i move my mouse up down right and left oh you can see a problem already ah you can actually see it really well the problem here is twofold actually if we move the mouse too fast the game moves really really fast which is very bad so i want to give this mouse back to offset a certain kind of speed limiter which basically means i'm going to multiply it with self dot mouse and this self.mouse speed i am setting up here so self dot mouse speed and for me 0.4 felt the best but now we have one more problem that if i move my mouse really fast let's actually try it so if i move really fast my mouse goes outside of the window which well isn't the idea of the game but we can fix that kind of easily all we have to set in here is one line of code although really important before you write this code i do want to warn you after i write this do not run the code straight away you will not be able to close it because you can't press the close button anymore i'm going to fix that right after before i run the game please take care of that now the line we need is pygame dot event dot set underscore grab and this has to be true and this basically makes it so that our mouse cannot leave the screen anymore which is then preventing us from closing the game so we have to find another way to close the game and in my case i'm just going to check for another keyboard input if event dot type is equal to pygame dot down and then if event dot e is equal to pygm dot k underscore escape which basically means we're pressing the escape button and if that is the case i want to run pygm.quit and syste.exit and now you can run this now this is working really well and there's no way for the mouse to leave the screen in any way whatsoever this is working really nicely cool so with that we also have our player control and you can move them together although it gets a bit weird to do and if you press escape the game stops so with that we have our mouse control and with that we can start working on the final part zoom and the zoom is in theory not that difficult essentially what we have to do we are going to place all of our elements on another surface so some kind of internal surface of our camera group and then before we are drawing this surface on the actual game window we are going to scale it so the larger this is the bigger it's going to be the smaller it is the smaller it's going to be that's quite straightforward although we have to add another offset because this internal surface is going to mess with our positions i'm going to explain this when we get to that problem here we are back in our code and before we can do anything we need a way to actually influence our zoom level and this should be possible both with the keyboard and with the mouse and i put those in different methods well you have to use different methods first of all i want the zoom keyboard control here we need self and nothing else and again i want to get keys just like we have done earlier with the keyboard control so pygame dot key dot get underscore pressed and all i want to check now is if my keys are pygame dot a underscore q let's go q like that and then i want to set self dot zoom underscore scale and add 0.1 now this self the zoom scale doesn't exist yet so let's create it i put this all the way at the end of my init method of the class so all the way to top of camera group and all i have to do now is create another if statement that if we are pressing e we are subtracting this and this would be the keyboard input and if you are sure you want to use this in your game and you also want to use this keyboard control you could totally combine the two i just want to emphasize that you can use all of these things independently so let's minimize this and now we have to get the mouse wheel and this has to happen inside of this event loop for some reason i'm not actually sure why but in the pi game documentation there doesn't seem to be anything else unless i missed it what we can do in here is event dot type is equal to pygame dot mouse wheel and this seems to be only available inside of this event loop but once we have that i want to get my camera group and i set the zoom scale again and in here we have to plus add and we want to get event dot y and this is the normal scroll wheel direction there's also x if you have one that can go left and right but i don't care about that and you want to limit this to a certain degree so i'm going to multiply this with 0.03 that way we don't zoom too fast and all right now we have input let me run the code to make sure nothing went wrong something did go wrong oh zoom scale should be one now let's try this again and now i can use my mouse wheel i can press q and e but nothing is happening at the very least we don't get an error right now what we have to do we have to create what i called a self dot internal surface and for this surface we also want a size that we are going to reuse so let's call it self dot internal surface size and in here you want to be a bit careful in two ways number one you do want a pretty large surface because when you zoom out it should not be cutting off at the corners at the same time if you choose a service that's too large you are going to slow down your game so in here you have to experiment with what looks good in my case i'm going with 2500 and 2500 a pretty large surface but now when i create the surface pie game dot surface i want self.internal surface size and important in here you want to set a flag which is pygame dot src alpha and this enables alpha on this surface and that is important because we want stuff that isn't being drawn to be transparent so you can see stuff behind we also want self dot internal underscore rect oh and let me call this serve instead of surface so we keep the naming a bit more consistent and essentially what i want to do in here let me draw this actually and give me a bit more space it is really important to understand the positioning here this one right now is our game window so this is 1280 by 720 the internal surface is going to be something like this and this is then what we are either going to grow or shrink but it is really important here that the center of this surface is in the same center as our display window so those two have to match each other otherwise if you are scaling the center point of the internal surface is going to shift so you're not only scaling you would also move in any of these directions depending on what you do and only if they have the same center this is going to be avoided so for the internal rectangle we want to get self dot internal surface and get underscore rect spelling this properly and we want to set the center and here we already have half the width and half the height and these are the two points we do want to set so self half width and self half height nearly done there's one more thing we need and that is a self internal surface size underscore vector and this right now is just going to be pygame dot math dot vector 2 and in here we are adding self dot internal surface size and let me change the surface to a serve so the naming keeps on being consistent and why do we need this vector i think the best way to show why we need it is to actually implement it so when we are all the way down here in our custom draw method let me add a bit of space i first have to self dot internal surface dot fill the entire thing and i want to fill it with the same color that i've used for my display surface and since we're updating this surface if you didn't fill the background and redrew everything you would always see the last frame so stuff would be looking weird and now when we are drawing the ground and all of the elements we are not putting them on the display surface we are putting them on the internal surface all the way at the end i want to get myself dot display surface and blit self dot internal surface and self dot internal surface rectangle if you run this we well we don't get an error we can still move around but it's not working and we can't move our player but at least we don't get an error i guess that's a good start now what we actually have to do is we have to create a scaled surface and what we are essentially going to do in here is pygame.transform.scale and in here we need two bits of information first of all the surface we want to scale which in my case is self dot internal surface and then we need a new size and this has to be x and y in my case i want to get myself dot internal size vector and multiply this with self dot zoom scale and that is the reason why i needed this internal size as a vector because that way i can just multiply it with the zoom scale and not worry about it anymore the last thing well almost the last thing there's a bit more we need we need a scaled rectangle i just want to get my scaled surface and get wrecked again and now the center is going to be self dot half width half width and self.half height and now i'm not splitting the actual internal surface i am splitting this scaled surface and this scaled rectangle and now let's try this i still can't see the player we're going to fix that in a second but if i now move my mouse we are zooming out and we are zooming in and i can use this also i can't use my keyboard because weak are occurring the method if you zoom out far enough you can see that our game is cutting off but i can still use my mouse to move around so here you mostly just have to be careful to move stuff around in the right way if we leave our zoom level at something like this then the player would never notice that stuff is being cut off afterwards so you basically have to play around with this and well we can still move our player nice and just for completion's sake i also want to call myself dot zoom keyboard control so now if i run this i can press e that was way too fast and i can press q i have to be very careful not to press it too fast so it definitely works and that leaves us with only one more problem and let me explain what the problem right now is here again we have our two surfaces the blue one is our display surface the yellow one is the internal one the issue we have right now is that those two have different origin points our internal surface has the origin point up here and the display surface has the origin up here which means that all of our stuff is basically going to be drawn somewhere here which leads us to have an offset that is this size here and since we know the offset we can just account for that with a second offset so we have a camera offset and an internal surface offset that's kind of all we need i hope it makes sense but essentially since our internal surface has a static size so this size here that one doesn't change we can just keep the same offset for any kind of movement and i want to create an internal offset and by default it is going to be a pi game.math.vector2 with 0 and 0. and this internal vector we are going to add to every single element that we are blitting well in our case it's the ground and it is all of the other sprites but if you had more obviously added towards those as well and now we just have to figure out the right position for them let me reopen the drawing again to see what's going on let's start with self.internal offset dot x i essentially have to get this distance here and that is not a difficult thing to get i basically have to get i basically want to get myself dot internal surface size and the x part of that and divide this by two and then from that i want to subtract self dot off with and i want to do the same thing for y except now we care about the height and we care about the height and that should be all we need let's try this now and there we go now we're starting on the player and if the player runs around i don't have a camera right now right but now we can still zoom in and out okay except you have to be very careful with how big it's going to get but now you can zoom in and out and this is working really well a good idea would be to add a few more if statements in here that if the zoom scale gets too large or too small that you do want to limit it but that's something you can do by yourself i think we are good to go for here so i hope you enjoyed this tutorial and i will see you around