hello there in this tutorial we are going to be creating breakout in pygame and for this project i really wanted to make sure to include graphics updates sounds and all the stuff that makes the game actually look good so we don't just have a boring game that is well just a demo and all of this is going to be part of this tutorial and i guess there really isn't that much else to talk about so let's jump straight into the first part the project setup i already have a couple of things ready in the project so i don't have to type out some boring bits and before we are going to look at our code we have to talk about the folders let's have a look at those i have one folder with three subfolders we have code graphics and sounds and code right now has two files main and settings i will have a look at those in just a second besides that we have sounds and graphics sounds is the easier one we just have a couple of sounds that's basically all it is the graphics folder is a bit more extensive because we do have quite a bit in here so we have blocks other and upgrades now other is quite simple we just have a couple of basic images and besides that upgrades has a couple more images that really isn't anything complicated now the one more complex folder is blocks because what we have in here is a lot more folders for each color and the player and then inside of each of these folders we have a lot of smaller graphics i will explain later what they actually do we basically use them to create a proper surface for each of the blocks in the player this is basically all we are going to need for this entire project and we are going to work in code entirely so in here is where we are going to do everything and with that lets have a look at main and settings and here i have both of these files open and if i run all of this we can see a plain black window that doesn't really do anything right now and i guess before we properly start with this project let's talk through what we already have main.pi is the main file and this is much more important settings.pi right now only has the window width and the window height so that determines the width and height of the window that one should be fairly obvious and this is what we're importing up here now besides that we're importing pygame and sys to make pygame run and time we are going to use for delta time and then we have a fairly simple class and once we are creating this class down here we are creating one instance and then we are calling the run method of this class so let's have a look what happens inside of the class it's not very much right now in the end it method so up here we are essentially just initiating pygame and creating a display surface with the window width and the window height from settings and then in the run method we are using this last.time here along with these two lines to get delta time and then delta time later on is going to be used to update all of the elements in the window and besides that we have our event loop that right now only checks if we are closing the window and all the way at the end we are updating our window so we are drawing whatever we created but right now we haven't created anything so all of this is black and this is our entire setup for now it's really simple and just about the most basic setup for pygame you can have if none of what i have just said made any sense check out my introduction to pygame it is going to explain all of this in quite some detail and i guess for this section let's add a really quick challenge that should be fairly easy so right now if i run this code we can see in the top left we have pygame window and i want to rename this to breakout or to really any kind of custom string i don't really care so much what it is and try to do this yourself and see how far you get in the init method we have to call pygame dot display dot set underscore caption and then here we have to pass in a string in my case breakout and that is going to rename the caption of the game so now we have breakout which looks a little bit better all right so with that we have the first section covered and the first major section i do want to work on is to create the background and this by itself isn't terribly complicated but there's one major issue that we do have to work on that the background image always has to cover the entire window if it didn't do that it would look a bit weird so we have to scale the background image but when we are scaling it we want to make sure we have a constant aspect ratio so we're not squishing the image or making it wider or narrower than it's supposed to be now what does that actually mean in practice and let me illustrate here we right now have our window or a box that has the same size as our window and we have the background and this background we want to stretch and we can stretch this in a couple of different ways we could for example stretch it like this which in this case would work but it would stretch the image a tiny bit which i don't really like instead what i want to do i want to scale this thing with a constant aspect ratio so that it grows in width and height at the same speed and this i feel looks nicer although in our case the background is so abstract it really doesn't matter very much but this is essentially what i want to achieve so let's try to implement all of this and let's see how far we get here i am back in the code and the first thing i want to do is to create another section in the ended method and let's call this one background and all i really want to do in here is create another attribute called self bg and this bg is going to be created in another method that i called create bg and this needs to be self dot create bg so now we have to create this method so define create bg and the only argument we need in here is self because we don't pass anything else in there and now first of all we have to actually import an image that i want to store in bg original and this we get with pygame.image.load and i want to go up a folder i want to go to my graphics folder and there we have a folder called other and in there we have bg.png and don't forget to convert this one for pygame to run a bit better and now what we can do just to get started i want to return this bg original meaning that after we have run this our bg gets this surface and right now all of this is a bit of a pointless setup but we are going to add a bit more in this method in just a second for now i just want to make sure this is working so now essentially what i want to do in my game loop before we are updating the window let's call it draw the frame and in here all i really want to do is self dot display surface dot lit self dot bg at the coordinate zero and zero and let's see what we get and there you can kind of see the issue we just had that our background doesn't cover the entire window which well looks kind of bad and there's one easy thing you could be doing so right now we want to scale our bg original and the result i would like to store in let's call it scaled vg and to scale anything in pi game we need pygame dot transform dot scale and in here we need two arguments we need a surface and we need let's call it a new scale now the surface we already have that's our bg original and the new scale would better be named new size actually because this one is going to be a trooper with a width and a height so for example what we could be doing we could copy the entire width of our window and place those two arguments in here and now if we are returning scaled bg what we get is something that fills our entire window the problem now is that we are squishing our image so this image is more narrow than it's actually supposed to be which in this case isn't too much of a problem but in lots of other games it would look very silly so this is something i want to work on but if you want to leave it like this that's also totally fine and let me explain by illustrating the original image so bg original essentially what i would like to do in here i have the height of this image available this is something pi gain can give me let's call this one h and i want to multiply this one by a certain number let's call it the question mark for now and the result of this multiplication should give us a new surface that has the height of this entire window and let's call this one h w and once we have this number i want to multiply this with the width of this image as well so this entire thing here is also going to be multiplied with this yellow question mark and that way we are scaling both the height and the width by the same number so the aspect ratio of this image is not going to change so the question then is how can we get this question mark and i always feel like plotting in real numbers here is the best way to think about it and the height of the image we have right now is 512 and the height of the entire window is 720 so essentially what we need to figure out is 512 multiplied by what number gets us to 720 and this is the sort of thing that's really easily solvable essentially all we have to do is the question mark is going to be 720 divided by 512 so we just move to 512 to the other side and that way we are going to get the number of our question mark and the number we would be getting here is something like 1.5 so i essentially want to multiply this 512 by 1.4 and i also want to multiply the width of this image by 1.4 and well that is basically all we are going to need now with that in mind let's implement all of this and i would actually recommend you to try to implement this one yourself so now you know the basic theory this shouldn't be too difficult to implement first of all i want to get some kind of scale vector so that's the 1.4 i just got and in here we want to get the window height and divide this by the height of our background and this we get with dot get underscore height so now we can print our scale vector and let's see what we get and what we get is 1.4 and a tiny bit so this is looking really good so now we can create a scaled width and a scaled height and basically what we are going to do in here i want to get my bg original and get the width and multiply this by the scale factor and the same thing i can do with the height so bg original dot get underscore height and i want to multiply this by the scale factor as well and now finally i can uncomment my scaled bg and i don't want to pass in window width and window height instead i want to pass in my scaled width and my scaled height and now return the scaled vg and let's see what we get and this one is looking significantly nicer it's probably kind of hard to see but it does look better and it's one of those many small differences that all combined really makes the game look nicer but alright with that we have our background so that's a pretty good start so now that we have that we can start work on the player at least to a certain extent let me explain what we are going to do what i want the player to be able to do for now is that the player can accept some input the player can use that input to move around the player is going to be constrained to the window and that's kind of all we are going to do later on the player is also going to receive graphics and lasers but i don't want to get ahead of myself let's keep it a bit more focused so let's just work on these three parts for the player and none of them is particularly difficult so let's jump straight back into the code and here we are and what i basically want to do is to create a new python file and this one i am going to save as sprites dot pi because in here we are going to have all of our sprites for the ball the player the blocks basically everything and this one is going to import my game and from settings import star and now i want to create a class i called player and this should be spelled properly and this one has to inherit from pygame.sprite and now we are going to need an init method for this setup and this one for now is only going to need groups so the groups we want to place this sprite in and which group we would like to place it in we get in the dunder for super init method and in here if we add groups as an argument high game is automatically adding this player to whatever group we pass in here which is really handy and now i want to let's call it setup so i want to add self.image and for now this image is just going to be pygame dot surface and now we need a width and a height and both of these sizes should be relative to our window which basically means that i want the width of the player to be ten percent of the window and the height of the player should be five percent of the window height and achieving that is kind of simple because we already know the window width and the window height and basically all i want to do is i want to get my window width and floor divide this by 10 and that way i get 10 of my window height as a nice integer that is a bit easier to work with although you could also just divide this it doesn't matter that much and for the height i want to get my window underscore height i am terrible at spelling that and flow divide this by 20 and that way we get 5 percent of the window height and that is all we needed so now i want to get myself.image and fill this one with a red color now the color here doesn't actually matter that much because we are going to replace all of this later on anyway for now i just want to make sure it's not black which would look a bit boring now we have our image next up let's add a position comment in here and i want to actually place this surface and for that we need self.rect and this we get with self.image.getunderscorerect and in my case i want to place the center of this surface and for this one i need x and y and for the xcoordinate i want this to be straight in the middle of the window so window width and divide this by two i guess to stay consistent let's flow divide this but this one really doesn't matter now for the y position let me draw what i would like to do this here is going to be our entire window and my player i would like to be somewhere here ish with some kind of offset from the bottom and in my case i always want there to be a 20 pixel offset between the bottom of the player and the bottom of the window i guess if the window gets really large or really small this might be an issue but i think this is generally a good number so how can we implement this and well the easiest way is that this center isn't perfect here it should instead be mid bottom meaning now we don't place the center of this rectangle we place the middle of the bottom side and now basically what we can do we can get to window height and from that subtract 20 pixels and that way when we are placing this rectangle there is going to be this distance between the bottom of the player and the bottom of the window so with that we have a very basic sprite for our player let's actually display it in main.pi and see how this looks and this could be a challenge for you try to display this sprite on the window it doesn't have to do anything for now just see if we can actually use a sprite first of all we have to import this sprite so from sprites import player and now to actually use this sprite we have to place it inside of a sprite group so let's call it here group setup and let's be a bit more specific sprite group setup because later on we are going to have quite a few different spread groups but for now what i want to create is self dot all sprites and this one is just going to be pygame.sprite.group and we are going to place every single sprite inside of this group and this group will then draw and update every single sprite and any other group we are going to create later we'll just check which kind of group another sprite belongs to to check what they are supposed to do but none of them are going to update or draw anything and now let's create another comment and let's call it the setup for sprites and basically what i want to do is self dot player is going to be the player class and in here we need one argument that is groups and i only have a single group and that is all sprites so this is what i want to pass in here and if i run this now we can see nothing because we have to draw all sprites so self dot all sprites dot draw and i want to draw this on self dot display underscore surface and now if i run this we can see our player this one is already looking not bad at all so now our player can be seen and to move it first of all we need to get some kind of input so for that i am going to create another method i called input and this one doesn't need any arguments and now i want to get every possible keyboard input so pygame dot key dot get underscore rest and now i want to check if inside of this list we get the right or the left keyboard and if we don't get either of those we are not going to do anything but if the player is pressing right or left i want to give my player a direction and this direction has to be stored in the class itself as an attribute so let's create self.direction and this one i'm going to create as a vector so pygm.math.vector2 and this one by default can be left empty so it's 0 and 0. and now if ease and igame dot k underscore right then self dot direction is going to be 1 and now we can copy all of this turn this into an l if if the player is pressing left and if that is the case x should be negative one and finally if neither of those are the case then self.direction is going to be zero so basically all we are going to do here is if the player is pressing right we have a positive direction if the player is pressing left we have a negative direction and if the player is pressing neither of those two we have no direction at all and now that we have that we have to create an update method not upgrade update and this one itself and importantly we are also going to need delta time because remember we want to move this thing with delta time and we don't have any clock so our game runs as fast as our computer can run it so if we didn't use delta time our game would not be running at a constant speed which would be kind of a problem but this we can account for now in the input method first of all i want to get myself.input and now we have our direction now what you could be doing now is something like self.reg.x plus equal self.direction multiplied by some kind of speed and multiply this by delta time but this wouldn't be a good approach although speed we do want to use let me actually create this one so self.speed by default i have set to 300. so this one we can keep as it is so self.speed is totally fine the problem we have now is that using self.direct.x and adding numbers to it is not a good way to move anything in pygame because rec.x for the position only ever stores integers and this number here is going to be some kind of float so if we were to use this number by itself as the position for the rectangle we would be losing information and the way around this is to create another attribute that i called self.position and this is going to be another vector so pygame.math.vector2 and by default the position of this vector itself.rect.top left so the top left position of this rectangle and let me place the vectors right next to each other and the vector can still floating point information totally fine so essentially what we are going to do is self.pause dot x plus equal all of this and that way we are not going to lose the information after the decimal point and once we have that we are going to set self.direct.x to the rounded version of self.s and this round here is not strictly necessary but it is kind of helpful because when we set rec.x and we pass in a floating point number highgame drops any value after that period so for example if we had 1.9 in self.post.x self.react.x would just turn this into a one and if we are rounding all of this this one becomes a 2 which is the much better number here so alright with that we should be having some kind of movement except there's one thing i forgot we have to in our game loop update the game and all this really means is self dot all sprites dot update and in here we have to pass in delta time and let's see if this is working the game does it for an error and if i press right now we get an error the problem starts in the update method and in here high game has the problem that int object has no attribute x so for some reason it thinks this direction dot x is an integer and the reason for that happens down here that if we don't press left or right we are setting self.direction to zero which isn't what i intended instead we have to set self.direction.x to zero so we want to set one part of the vector to zero we do not want to set the entire vector to the integer zero which would be well pointless and i guess while we are here there's another thing i did forget that this is going to throw an error as well because right now this is going to be an integer this is a vector this is an integer and this is a floating point number the problem is we couldn't really add a vector to an integer pygame just wouldn't know what to do with it and this well has to be self.direction.x and now this should be working so now i can move around and this is working totally fine and it feels very smooth so that's a pretty good start now the problem we have is that our player can move outside of the window which doesn't feel good at all so that's the thing we have to work on now and all of that is just going to be another method that i called screen constraint we need self and nothing else and now we have to figure out the basic logic in here and i think this one could also be a pretty good challenge for you so try to figure out the method here that our player cannot leave the window it shouldn't be too hard if you want to tip basically all you want to do if the player is too far to the right you want to set it to the right of the window and then the counter side for the left if the player is too far left you want to set it to zero it's kind of all you need to do so try to figure out how to implement this one yourself basically all i want to do is if self.rect.write is greater than the window with and if that is the case self.rect.write should be equal to the window width so basically all this means if this here again is our entire window variable drawing and our player is here ish if that is the case essentially what i want to do i want to take this side here and place it on the right side of the window and that way whenever the player gets too far to the right the player is put on the right side of the window so it feels like the player can never leave although there's one more thing that we do need we have to update this position.x as well which just means self.pos.x is going to be self.rect.x and if we didn't do that pi game might get confused where these points are in relation to each other so this position on x needs to be in the top left of the rectangle and well once we have that we have to do the same thing for the other side so self.direct.left is smaller than zero and if that is the case self.rect.left is going to be 0 and self.post.x is going to be self.rect.x so now i just have to call self.screenconstrained and let's see if this is working so now the game still runs and if i get too far to the right i can't go any further and if i go all the way to the left this is also still working cool so this one is working just fine but now that we have that part we can start working on the ball and this one is going to need a couple of things let's talk about them first of all the ball needs to move around this one is fairly easily implemented it's going to be fairly similar compared to the player the more complicated part is the collision that the ball needs to be able to collide with the player and with the edges and later on also with all the blocks we are going to create which means that we are going to need collisions with both static and moving obstacles which is quite a complicated topic as a matter of fact i have just made a whole video about it so for this video i am going to go over the theory in a bit but if you want more detail check out the other video it's going to go over this in much more detail and finally the ball is also going to get an actual image which is well super easy to implement but i did want to mention it and finally the ball also needs to be active and passive now what that basically means is that if the ball is active it's moving around the window and if it is passive it's always stuck to the player and only once the player presses a button then the ball gets active again and that is going to be quite a large section so let's work on implementing all of this here i'm back at main.pi and i want to look at my sprites and right now we only have player but i want to create a second class called ball and this one is also going to be a sprite so pygame dot sprite dot sprite and now for the init method we need self and then we also need to know what groups the ball should be in but on top of that we also need to know where the player is because the ball is supposed to collide with the player so this one is going to be passed in there as well and later on we are going to add the obstacles as well but for now we don't have them and now in here i want my super done there init method and pass in the groups in here as well and now we can let's call it a graphics setup and all this really means is i'm going to set self.image and self.image is going to be pygame.image.load and i'm just going to load from the string that is one fold up graphics other and in there we have ball dot png and let's fix the typo and add convert underscore alpha and that should be all we need and besides that i also want to have a position set up and this one is going to be fairly similar compared to the player let me open it just for the init method so we're going to need a rectangle a direction a position and a speed as a matter of fact let me copy all of them and let me pass them in here i guess you could be working with inheritance but i do want to overwrite most of them anyway so there's not much point to that let's go for them one by one for the rectangle by default basically what i want if this here is my ball i want this ball to be right on top of the player which essentially means that the mid bottom of the ball should be in the exact same position as the top mid of the player that is really easy to implement but we do need to know where the player is let me add another section and let's call this one collision objects and in here all i really am going to do is self.player is going to be player which is the argument we get from up here and now for my rectangle i want to place the mid bottom and the mid bottom should be in the position of player direct dot mid top and i guess the one part of this codec can stay the same is position this one should always be the top left of the rectangle by default the other two arguments direction and speed we do have to change the ball speed i have set to 400 and for the direction i did make some changes and in here we basically need x and y now y is the easy part by default this one should be negative one because the ball once we started should go up if it went down it would be kind of weird but for the x i want to have a random number that is either one or negative one so if the player starts the ball it should go left or right randomly and since we now have random numbers we need from random import in my case i went with choice and all i really want to do in here is choice and into choice we have to pass a tuple with our choices which in my case is one and negative one so our direction when we spawn the ball is going to be negative 1 in the y direction and it is going to be either 1 or negative 1 in the x direction the one final part for the init method is active which really just means self.active and by default this one is going to be false so now we have all we need to get started now to actually move the ball we need again the update method that needs self and delta time just like the player did and in here the first thing i want to do is if self dot active then i want to for now it's going to be pass but this one is going to be quite a bit of stuff later on but if the ball isn't active so else then i just want to set self.rect.mid bottom to self.player.rect.mid top and don't forget self.pause also needs to be updated and this one is just always going to be pygame.math.vector2 and self.direct.top left so basically all we are going to do in the update method for now is that the mid bottom of the ball is always going to be moved wherever the mid top of the player is and that way if we are moving the player the ball is going to be moved along with it and again we always have to update position otherwise we are going to get some weird behavior later on and all right this one is a good start let's actually see if this one is going to work so in my main.pi file besides player i also want to import ball and now in our setup i want to create another attribute called self.ball and this one is going to be ball and in here let me copy the parameters we need groups and we need our player groups is going to be self dot all sprites and player is just going to be self.player and now let's see if this is going to work and this one already looks pretty good and if i move left and right the ball is going to move along with it so this is working just fine cool and now that we have that we can look at our ball and work on what happens when this active is going to be true actually we can do this right now in my main.pi i want to check if the player is pressing the space button and if the player has done that i want to set this self.active to true and this could be a good challenge so try to implement this one yourself that if the player presses space self.active should become true alright what i want to do in main.pi i have my event loop and since i don't really check for that much input i can just add another event type in here so event or type is equal to pygame dot e down so now i am checking if any button was pressed inside of that i want to check for one specific key so if event key is equal to pygame dot k underscore space and if that is the case self dot ball dot active should become true let's try the game is still running i can move around but now if i press space the ball is stuck in mid air while my player keeps on moving the reason for that is this line here for now we are only updating the ball position if self.active is false if it is true we don't do any of that so the ball just remains constant and in here for now what we could be doing is self dot pos plus equal self self.direction multiplied with self.speed and multiplied with delta time and this is going to work but you see in a second why this isn't a good start so now i can move around and if i press space nothing is happening because i forgot one line so right now we are just setting the position we're not actually updating this rectangle which actually places this sprite so we have to check self.rect.top left is going to be round self.post.x and round dot self.pos.y and i guess we can put all of this into one tuple to make it look a bit nicer and now this should be working so i can move around if i now press space the ball is just moving into space so not particularly helpful and the problem we have here is that there's no collision whatsoever and this we are going to address in just a second although before i'm going to do that there's another thing i would like to add and that is that i want to normalize my direction so this direction here now what does that actually mean to normalize a vector so right now our direction is always going to be one or negative one and let's say we have a vector that moves in the direction of one purely upwards so this is one and then we have another vector that just moves to the right by a speed of 1 as well in both of those cases we are going to cover the same distance the problem we have now though is if we move both up and to the right at the same time you would assume we are going to move at a distance of 1. but that isn't actually the case if we get both of these speeds we are actually moving by something like 1.4 so this ball if it moves diagonally would move 40 faster than if it went just up or left which in our case isn't going to be that much of a problem because the ball is always going to move diagonally but it still doesn't feel good to have something like this in there because it might change the speed of the ball without you intending to do so so we do want to address it all we really have to do is self dot direction is going to be self.direction.normalize although this by itself is not going to work because there is a chance that this direction might be zero in our case again not particularly likely but it might be the case and if the direction is zero you cannot normalize it so essentially what we want to do is if self.direction dot magnitude and if that is different from zero then we want to normalize the direction and the magnitude is basically the length of the vector so if the vector has any kind of length we want to normalize that length meaning we always set the length of the vector to 1. and that way when we are running this code the ball is always going to move at the same speed which makes our game significantly more predictable but right now we have to talk about the bigger part and that is the collisions and in my case the ball is going to have two different kinds of collision so let me add two methods here we first of all have the collision by itself and this one for noun itself and nothing else i am just going to add pass in here we will cover this one in a lot of detail in just a bit but the other collision i want to add is window religion so the collision is to make sure that the ball doesn't leave the screen and this one we are going to do right now and in here what i want to do is add another parameter that is called direction and basically what i want to do i first want to check the direction or let's call it horizontal and if direction is going to be vertical not how you spell that then i want to do something else now for this window collisions it's not strictly necessary by itself to separate the axis but later on for the collisions this separation is going to become really important so for the window collision i already want to do the same thing and basically what we want to do is let me give a bit more space i first want to move the ball in the horizontal direction so i'm either going to move it left or right after i have done that i'm going to check the window collisions and the normal collisions so the collisions with the player and with the other obstacles once we have them and only once all of that is done i want to move the ball in the vertical direction and then do the collision and the window collision checks for this axis as well why that is important you will see when we talk about the collisions because this one is going to become a bit more complex but for now what i want to do is that this position shouldn't be x and y it should just be x and then self.direction is going to be self.direction.x and then self.direct.x is going to be round self.x and then we are going to copy all of this and replace all of the x's with y's and that way for now there's not going to be any difference but what i want to do now essentially is called self dot window collision with horizontal and then copy this and move it here and then check for the vertical collisions and later on we are going to do the same thing for the normal collisions and then you will see why the setup is going to make sense now we basically want to check the window collisions and this one should actually be pretty simple in terms of collisions so if you understand the player collisions so the stuff we have done here you should actually have a pretty good idea how to address the window collisions for the ball the only difference now is that we don't set the position to the right side of the window instead we just want to change the direction of the ball and as a consequence this could be a pretty good challenge for you so try to implement the collisions for the ball that it bounces around the window and see how far you get all right basically let's start with the left side so if self.wrecked.left is smaller than zero so our ball is moving outside of the left side of the window if that is the case i want to set myself.right.left to the position of 0. then self.x should become self.rect.x so so far this is the very same thing we have done here the one thing i want to add now is self.direction.x multiply equal with negative one so essentially what we are going to do if the ball is moving too far to the left and is somewhere here we want to place this side here to the left side of the window and then instead of moving the ball further to the left we want to change this direction to the right and that way it looks like the ball is bouncing off the window and now this we have to do for the other side as well so let me copy this if statement and now self.direct.right is greater than the window width and if that is the case self.rect.write should be the window width and then this one can stay the same and this one can also stay the same and now i have to copy all of those and do the same thing for the vertical direction and now self direct dot top is smaller than zero so the ball is leaving the window on the top side and if that is the case self.top is going to be zero and self.x should be self.y and then direction.y should also become negative one and now we have the bottom side of the collisions and this one we don't need at all because if the ball is touching the bottom side of the window it should be failing so we can remove all of this and this should be self.rect.bottom and if this is the case i want to set self dot active to false and now this should be working let's have a look so i can still move around if i press space the ball is moving around except it doesn't collide with the top part let's see one foot wrong and ah the problem here is i made a typo this should be vertical so now let's try this again let me move to one side this collision works and this one works as well and now if the ball hits the bottom part it just disappears ah and there it comes again and let's try this again ah now we have the problem that the ball once we are restarting it still has the downward facing direction so that is something we do have to work on and well all we have to do is if we get to this point here i want to set self dot direction dot y has to be negative one oh and i realize this should be window height not window width and this should now feel a good bit better so now let's try this we have collisions and the ball goes straight to the player this is feeling better and okay this feels quite nice so with that we already have some basic collisions although there's no collision between our ball and our player and to implement that we are going to need a bit of theory so let's talk about collision theory and there are a couple of steps we have to go through the first one is the easiest one and that is if there's an overlap between objects in the first place so in our case right now if the player and if the ball are touching at all and this is easy because pygame has lots of functions to do that for us so we don't really have to worry about it but now we have a problem and let me visualize this so we might have a situation like this where we have the ball so the right shape in here colliding with some kind of obstacle and right now we just know there's an overlap we don't know from which side the ball has come and basically what we want to do is place this ball somewhere on the outside of the obstacle so for example if the ball came from the left side to the right we want to move the right side of the ball so this side here to the left side of the obstacle so that the ball is somewhere here and that way we are resolving the overlap so the ball is well on the outside and it seems like the ball is colliding but to achieve that we have a problem because if we are just looking at this we don't know where the ball has come from so the ball might have come from this side the ball might have come from this side the ball might have come from this side the ball might have come from well literally any side and well the problem is now unless we know where the ball came from we cannot place the ball on the side of the collision because well we don't know where the ball came from and this is something we have to figure out in code which is possibly the most complicated part of this entire tutorial so let's talk about how we are going to achieve that and the very first thing that we can do is to separate our axes in horizontal and the vertical axis and this basically means that on the horizontal axis we only have to check if the collision happened on the left or on the right and then on the vertical we only check if this is on the top or on the bottom and this is going to simplify our math significantly and basically what we are then going to do in the game is we first do all the horizontal movement then we are checking the horizontal collision then we are checking the vertical movement and then we are doing the vertical collisions and we already have the basic part of this in our code so if i switch back to my code really quick we have our ball class and inside of that in the update method we are first doing all of the horizontal movement and then we are doing the vertical movement and let me actually add comments here to illustrate this a bit better so horizontal movement plus religion and then i can copy all of this and change this to vertical movement plus collision and this setup is really helpful to figure out collisions if you didn't do this you would have to add a whole lot more code to make all of this work which is why i included all of this so basically what we are going to do in just a second when we are writing the collision method we are also going to write self dot collision and then here there should also be horizontal and then we are doing the same thing for vertical and let me give the collision another parameter and let's call it direction so now we have to figure out if the collision happened on the left or on the right or on the top or the bottom and now you do have to be a bit careful so let's talk about this here's the case we had just now and if you were to just look at this you might assume that the collision definitely happened on this side here and we would want to move the ball to this edge which may be right but it's also very easy to get this wrong because it might have happened that the ball is moving at a very high speed in this direction and as a consequence of the high speed the ball might have been here on one frame then just about here on the next frame and then the ball jumped almost over the entire obstacle and as a consequence the ball is nearly over the entire thing so just because the ball is quite far on one side of the obstacle doesn't mean the collision happened on that side it's actually a really big problem for collisions that if the ball is moving too fast it might literally jump over entire obstacles which is really bad and this problem is called tunneling and game development it's actually a big problem but in our case we are not going to worry too much about it so then how can we actually resolve this issue and for the horizontal collisions we have to check a left side and a right side and both of these are going to be if statements i am going to only talk about the left side but the right side works in basically the same way except you check different numbers if you want to check collisions on the left side basically what we want to do we want to first check if the right side of the ball so this side here is greater than the left side of the obstacle so this side here and if the right side of the player is greater than the left side of the obstacle we know there's going to be an overlap so that's a really good start but then again the problem is we don't know where the ball came from so in this situation we don't know for sure that the ball came from the left because the ball might have moved really fast from the right side so we will need a second condition to make this work and that second condition is going to be a check on where the ball was on the previous frame so you can see on the screen right now the ball in the previous frame and what we want to check in here is if the right side of the ball is smaller than the left side of the obstacle and if that is the case we know that on the previous frame so this frame here the ball did not collide with the obstacle but the ball was on the left side of the obstacle and then in the current frame so this one here the ball is colliding on the right side and if these two conditions are true we know that there is a collision between these two obstacles on this side here and this sort of logic we can then apply to the right side to the top and to the bottom they all work in basically the same way except we're looking at different sites and well with all of that we have our collision logic so let's actually implement all of this here we are back in our code and i want to work on the collisions and the very first thing we have to do is to find overlapping objects which in our case right now is just a player but we are going to get proper obstacles later on and i want to store all of this in a separate variable let's call this one overlap sprites and for now this is just going to be a list but later on i want to change this to a method that captures all of the blocks the ball can collide with but we don't have any blocks yet so i'm just going to leave this as an empty list but now we also want to check if the ball is colliding with the player and this we get with if self dot dot rect and in here we need self.player.rect so we are essentially checking if the rectangle of the ball is colliding with the rectangle of the player collide here is not the perfect word overlap would be better because we only check an overlap we don't really check a collision although i guess those two are very similar if that is the case i want to get my overlapped sprites and append self dot layer so essentially later on these overlapped sprites are going to be all the blocks the ball is colliding with and if the ball is also colliding with the player we want to add the player to this list as well once we have this method here properly this is going to make much more sense so right now if the ball is colliding with the player we have a list with one sprite inside and now we want to check if overlap sprites exists in the first place so if there's anything inside of this list then we first of all want to check our direction so if our direction is horizontal then we want to do something and if direction is vertical then we want to do something else and let's work on the horizontal side for now basically what we want to do for sprite in overlap sprites we are looking at every single sprite inside of that list and now we have to implement the logic i just talked about so let's start with a collision on the left side of the obstacle basically what we want to do in here is if self.rect.right is greater or equal than sprite.rect.left and this is now our current frame so let me draw this we have our obstacle something like this and we have a ball that might be on this position here right now and what we are checking in this line right now is if the right side of the ball so this side here is greater than the left side of the obstacle so this side here and that is a really good start but this doesn't help us right now because the ball might have come from this side which again we couldn't really account for right now so we have to add a second condition with and and basically what i would like to get in here is self dot old wrecked dot right is smaller or equal and sprite dot alt rect.left and let me draw what this means i guess i can reopen the previous drawing so right now we already covered the first if statement this one just checks if the right side of the ball is greater than the left side of the obstacle which is a good start let me get rid of lines so it's a bit easier to see so now we know that this condition here works out what we now want to check if on the previous frame the ball was something like here so at the right side of the ball it's smaller than the left side of the obstacle which is this if statement here the issue we are facing right now is that we don't have an old rectangle for either the ball or any of the obstacles so we have to create these attributes and that fortunately isn't as difficult as it sounds so basically what we have to do let's start with the ball by itself when i initiate this class i have my rectangle and what i also want to create is self dot alt underscore rect and this one for now is just going to be self.rect.copy so for now we are literally just copying the rectangle so that isn't going to help us very much but it's a start and now what i essentially want to do in my update method before i do any of the movement i want to create old rectangle and all that really means is self dot all direct is going to be self.rect.copy again now what do we actually do and think of it like this when we come down here so in the execution of our code we have our rectangle and it might be let's say in this position here with some x and y position it doesn't really matter which they are and when we come to this line here we are making a copy of this rectangle so now these two rectangles are in the same position but what we now do in all of these lines on the code we are moving this original rectangle so let me draw an arrow so this rectangle here is being moved in any kind of direction we don't really care in which direction that is being moved it just doesn't matter to us but now this rectangle here isn't being moved and as a consequence this rectangle stays on the previous frame whereas this rectangle here moves to the next frame and with that we have a previous and we have a current frame with the old rect being our previous one and that's really all the logic you are going to need in here and now this line we can copy for the player and implement it in there as well so here i have the player and after i've created the rectangle let me just copy it in here i now have an old rectangle and then in the update method we again before we do anything else have to create self.rect and this is going to be self.rect.copy and this should be not wrecked but old wrecked and now before we move anything we are making a copy of the rectangle then we are moving the rectangle so now we have a previous frame and our current frame at the end of all of this so with that we have our current and our previous frame which is all we need for this line here to work and now that we do have that we can implement some logic so basically what i want to do for the ball is self.rect.right is going to be equal to sprite.rect.left and this basically means if this here is our obstacle and our ball collided with something like this we want to move the ball to this side here so that our ball is now here and that way it looks like the ball didn't overlap but just collide and since we now move the rectangle we also have to move the position so self.post.x is going to be self.rect.x and now finally what we have to do is self dot direction dot x multiply equal with negative one because we want to bounce the ball as well and well with that we have the collision for one side all we have to do now is copy this three more times and get the other collisions as well and this i think could be a really good challenge for you so try to implement the collision for the left side to top and the bottom and see how far you get let me start with the other side by just copying this if statement and essentially what i want to check now is if self.direct.left is smaller or equal than sprite direct dot right and if i draw this one i think that's the best way to think about it we have our obstacle here and now we want to check if the ball collision happened on this side here so what we check right now is the left side of the ball against the right side of the obstacle and if the ball is smaller than that we know there happened the collision and besides that we now want to check if the old rectangle of the ball so left side was greater or equal than the right side of the obstacle and then we have to check self.rect.left is going to be sprite dot direct dot right and the other two lines can stay just the same with that we have the horizontal collisions so now i can copy all of this and paste it into the vertical axis as well and in here let's start with the bottom so if the bottom of the ball is greater or equal than the top of the obstacle and then besides that we also want to check if the bottom of the player in the previous frame was above the obstacle and now if that is the case sprite or direct dot bottom should be equal to sprite or direct dot top and the only thing we now have to change in the other two lines is going to be y instead of x and nearly done now we want to check if self.rect.top is smaller equal than sprite dot red dot bottom and we basically just change left to top and right to bottom so this should be top as well and this should be bottom and now again this x should be a y and with that we should be done let's try so now these collisions still work and this is also working nice and now the important part is if there's collision on the left side of a player this one is important so let's try this again the ball may be a little bit slow but okay it's kind of hard to get but i want to get hits the right side okay well the collisions do work and the really important part here why we need specific collision mechanics is that when there's a collision between the ball and the player on the right or the left side in this case it's totally possible that the player is moving to the right and the ball is moving to the left and if we don't have a collision this collision mechanic is still going to work we don't get some weird arrow that the ball is just moving around randomly which is what i really cared about in here but all right now with all of that we have a working collision mechanic which took quite some time let me minimize this method because it is quite massive all right so with that we can come to the next section and that is going to be creating the obstacles and for now there are two things i would like to work on number one is that i want to have some kind of layout that shows me where the blocks are going to be and besides that when we actually create the blocks in the method these blocks should scale automatically to the size of the window so if we don't create blocks that are either massively too small or massively too large if the size of the window changes so when we are creating the blocks from the layout there should be some flexibility in terms of how large the blocks are going to become and for now all of the blocks are going to be a simple color but later on we are going to add proper graphics i just want to focus on specific things for now but all right let's jump straight into the code and let's work on this here we are back in the code and first of all i want to go to my settings and right now there really isn't very much in here but i want to add something else and that is going to be what i called a blog map and this one is essentially a list it contains a couple of strings and that's just about it and basically what this one means here if we have a 1 for example we are creating a block with this type 1 and then this block is going to have a certain amount of health and a certain color as a matter of fact i do have a color legend as well this one looks like this so for example if we have a 1 here we want to look at our color legend pick up the one here and from that we know this color is supposed to be blue and then this number is also going to be the amount of health for this block so this layout basically tells us three bits of information the position of the block the color of the block and the amount of health the block has and you can totally change this kind of layout for example in my case i didn't even add gray blocks so for example i could add 7 and 7 in here and we will get some grey blocks later on you will see in a second how this thing is going to work and now before we can actually place these blocks we need a few more bits of information and i'm going to add these as extra constants the first is the gap size spelled correctly and in my case this is 2 and this gap size refers to the gap between the blocks so if we have a block here and another block here gap size refers to the distance between these two and now that we have that information we can already figure out the block height and we can figure out the block with and there's one thing i did forgot to mention in this block map we have a couple of strings that are just empty or well they're not empty but they have spaces inside and for these i just don't want to have any block in them i think that's fairly obvious okay now for the block height basically what i want to do here i have my entire window and the height for this window we get from the 720 here so i know the height of this window is 720 pixels and i know inside of this window i have a couple of rows because each string inside of this list is supposed to be one row and for simplicity let's say i have 10 strings inside of this block map which means in this window i am going to have 10 rows so 1 2 3 4 and you get the idea and now what we basically want to figure out is how tall does each row need to be and the math here is actually super simple all we really have to do is divide the entire height of the window by the amount of rows that we have so in this case for example we know the height of one of the rows would be 72 although this isn't the final number because from the 72 we would want to subtract the gap size so this 2 in our case essentially what we want to do is the entire height of the window divided by the number of rows minus the gap size which in our case would be 722 which would be 70 pixels and this 70 pixels in this case would then be the height of one individual block once we have that we can do the same logic for the width of the window and that way we will get the width of each individual block and well i think this could become a really interesting challenge so with all of this in mind try to figure out the code for the block height and the block width and see how far you get for the block height basically what we want to do is window height divided by the length of block map and the length of the block map basically tells us how many strings we have in here which is exactly what we need and from that we just have to subtract the gap size and we are good to go this is all we really needed and now for the block width we can do the same thing except now it's going to be width and now for the length we don't just want to look at block map but we know that the length of each of these lists tell us how many columns we have so in this case let's say there are 15 numbers inside of this and since there are 50 numbers in here we know we are supposed to have 15 columns inside of this block map so all we really want to do in here is not look at block map but look at one string inside of block map and let's say the first one so this one here and that is all we needed again so now i can subtract gap size again and we are done so with that we have the gap size the block size for the width and the height now what we have to do next in main.pi we have to create another method and let's call this one stage set up that is not how you spell that and in here we just need self and nothing else and what we now want to do we want to first of all cycle through all rows and columns of log map and once we have that we want to find the x and y position for each individual lock so essentially what that means we want to cycle through this thing we first want to cycle through all of the rows so all of the strings and that will be giving us the y position and then inside of that and then inside of that we want to cycle through every single number inside of the string and that would be giving us the x position and basically what that means i first want to go for row in lock underscore map i think i called it and let's just print row and see what we get obviously don't forget to actually call this method which i have done in the setup method so in here self.stage setup and let's see what we get so now we still get our window but we don't care about it what we instead care about is this here so in here we have all of our strings inside of block map which is a pretty good start but there's one important thing we now need to figure out because right now i don't really care what is inside of the string i instead want to know what the index of this string here is so what i essentially want to know is that this first string here has the index 0 and the second one has index 1 then 2 3 and so on and then what i'm going to do in a second is multiply this number with the block height of each of the blocks and that way the first block is going to start on position 0 on the y axis the one with the index one is going to start on something like 70 pixels the next one multiplied by height is 140 and so on so this index here is going to become really important and that index we can get with the enumerate method so in here enumerate and enumerate is going to return the information so the row but before that it's going to return an index which i want to capture in index row actually i think row index is making more sense so now i can copy this line and let's change the first one to row index and now let's see what we get so let me close the window again now we know on index number zero we get this information on row number one we get this information and so on and actually from that we can already get the y position so basically what i want to do is i want to get the row index and multiply this with the block height and the block height is just what we got down here so this would be a good start and let's actually print what we get so print y now if i run this again we are getting 0 78 156 and so on and this is a reasonable y position but we are missing something really important and that is the gap size so what i basically want to do is this block height is going to get the gap size as well and now if we run this we're getting 0 80 160 and we know the block height is going to be so there's one pixel of a gap between the top and the bottom although there is going to be another problem we have to deal with because this 80 right now let me minimize the game so essentially what we have right now is here we have a couple of rows let me add one on top and the first row is zero the second one is 80 and the third one is 160. this i got from the information down here and we also know that inside of this we have our blocks that should be 78 pixels tall and that is the information we calculated inside of block height now the problem is that if we were to just use this information here we would always place the block in the top part of this row which essentially means that we have no offset on the top and we have two pixels right now offset at the bottom which is the entire size of our gap so what we instead want to do is to place this block in the middle of the row so we have one pixel on the top and one pixel at the bottom always half of the gap size and to achieve that let me clean this one up a tiny bit basically all we want to do is towards this y position i want to add gap underscore size and floor divide this by two and that way we are not adding the top part exactly on the top row instead we are giving it half the gap of size and then at the bottom automatically we are already getting half of the gap size again so i hope this makes sense all right so with that we have the y position to get the x position we essentially have to cycle through each of the individual strings and this is going to happen in a very similar way compared to the y position so really all we have to do is for let's add a call index and a column in enumerate and now importantly we want to enumerate over the row so this one here and inside of this we have to indent our y and now we can also get our x position and for the x position we are basically getting the column index we are going to multiply it with the block width plus the gap size and then towards that we are adding gap size again except in half and with that we have our x and our y position so i guess i can move this one up a tiny bit now this looks better and now that we have that i want to use that information to create a block and this block we don't have yet so we have to create it but there are a few bits of information i would like to pass in here first of all i want to get some type of a block which basically means the type is each of these numbers so a type of a block would be six it could be seven three two one doesn't really matter i also just realized there's no five in here let me add five on these sides so that's the first thing i need next up i need a position and that's going to be the x and the y we created here and let me move the x up so it feels a bit better okay so x and y is going to be our position and then we are going to need some groups and that is at least for now all we are going to need so let me copy all of this comment it out and now in my sprites i want to create another class and this one i called lock and this one again has to be pygame dot sprite dot sprite and in here for the dander init method i want to pass in the arguments i just talked about although don't forget we also need self and usually i avoid type because it might interfere with the inbuilt python method type so let's change this to block underscore type all right now that we have that we as always need a super thunder init method that is going to get our groups besides that i am going to need a self.image and self.rect and self.image is really easy at least i hope it is all we need is pygame dot surface and we know how large each of the blocks needs to be that's the information we have here with block height and block width so let me just copy them lock height and block width and the rectangle is just going to be self dot image dot get underscore rect and top left is going to be the position we are getting from up here and this by itself for now is all we need to get started now let me comment the block the type we are getting from the column so the column is basically going to be each of these numbers so that's what we have to pass in for the type the position is going to be a tuple with x and y and for now for the groups i want this to be in self dot all sprites and now let's try this we're getting an error because i did not import the block so lock and now let's try this again and there we go we are getting something weird and the problem here is that right now we are checking for literally any kind of string so even if the string is empty igame is still going to place a block there which we don't want so i'm going to add all of this inside of an if statement and that is if the column is different from an empty string and only if that's the case i want to place all of these blocks all right and now if we run the code this is looking better although still kind of weird the gap besides each of those blocks is way too large and let's have a look at the sprites i think i know what the issue is ah the issue is here i switched around the height and the width so the first argument for surface is the weft and the second one is the height so now let's try this again and this is looking significantly better so with that we have our blocks and what we are now able to do is to create another sprite group and this one let's call it log underscore sprites and this one again it's just going to be pygame.sprite.group and now when i create this block it's going to be in all sprites and it's also going to be in self dot block sprites and now the ball needs to know where these block sprites are so when we are creating the ball i want to do the stage setup first and then inside of the ball i am going to pass in self dot block sprites and now in my sprites i can get my ball and and add another parameter let's call it the blocks and now self.blocks is going to be blocks so we have an attribute with all of the blocks and now the important bit in these overlap sprites we can use pygame.sprite.sprite collide and in here we need a sprite a group and do kill the sprite is just the sprite we want to look at which in our case is going to be self then we have a group which in our case is going to be all of the blocks so self dot locks i think i called it uh yeah this one here and finally do kill and that's just asking us do we want to destroy the block if it touches the ball which in our case is false and that is all we need for all the collision mechanics so now let's try this and ah now we're getting an error that block does not have an attribute old rectangle so when we run the collisions we are checking for an old rectangle which our blocks don't have right now so we have to give it to them and this one is just self old wrecked is going to be self.rect.copy and now let's try this again and we get some basic collisions although you can see sometimes there's a bit of an issue here where the ball seems to stick around the blocks and this i'm going to work on just a second i just want to show it again i hope it comes up i guess not okay never mind but essentially the problem we have right now is let me open up the collision for the ball the vertical one in particular let me add a bit more space the issue we have right now imagine we have two blocks here and the ball is colliding with both like this so we have a collision here and we have a collision here and the result is that this self.direction is going to be multiplied with negative 1 twice once for this block and once for this block and as a consequence the ball first goes down and then goes up again which means that for a second the ball is hovering around it which really isn't what we want and what i found that solves this issue entirely is instead of spawning the bottom of the player on the top for example or the top of the player at the bottom of the sprite we want to give an offset of one pixel so we want to add plus one here and minus one here and then negative one here and last one here that way after a collision the ball is going to be moved one pixel up or one pixel down so we don't have another collision straight afterwards so now let's try this again there shouldn't be any visible difference except we don't have the bug anymore um okay i am terrible at my own game okay this feels kind of nice okay i am really bad at this game okay i think this is looking pretty good cool now obviously now obviously this game doesn't do anything right now so in our blocks we have to add a bit more code that blocks get destroyed once the ball is touching them or at least they lose some health and for that let me add another section here and that is going to be damage information i guess is the word and first of all i want self.health in here and that is just going to be an integer of the block type because remember the block type is literally just a number so we can totally use it for the health now that we have that i want to give this block a method that i called get underscore damage and in here we need self and we need an amount so how much damage the ball can get and essentially all we want to do in here is self dot health minus equal the amount of damage taken and now obviously we have to update this rectangle so what i basically want to check is if self.health is greater than 0 i want to update the image which we can't do yet so i'm just going to add pass in here but if that is not the case and this should be health if our health is equal to or lower than zero i want to destroy this sprite with the kill method and now all we have to do if the ball is colliding with this block we want to call the get damage method and pass in an amount of damage now in my case the damage is always going to be one but you could totally add another number in here so what we have to do in the ball we are checking for the collisions that is going to happen in here and first of all i have to identify that we have a block because if the ball is colliding with the player there should just be a collision and nothing else and how i can identify the blocks is that blocks have a health attribute so i can use if get utter we're just checking a class which in my case is sprite and then we can pass in one attribute we would like to check which in my case is health and if that sprite doesn't have this attribute i want to just return none so this line basically checks if the sprite we have has the health attribute which in our case is only the blocks and if that is the case sprite dot get damage should be called with a damage of one and now i have to copy all of this or the vertical axis as well and now we should be having a working code let's try so now the block disappears i'm still terrible at this game so now we had two this is working we are definitely making some progress i'm hoping to hit the second row as well eventually there we go now nothing changed but now it did this was actually perfect so the second row has more health than the first one and as a consequence we have to hit them twice instead of once and there we go now you can see it again the logic here is definitely working and so are the collisions this is working very nicely cool so with all of that we have our collision mechanics and our blocks so with that we can start working on the next section and that is going to be about adding proper graphics so in this part we are actually going to make our game look better but we do have a problem here let's talk about what we have to address and let's have a look at one image to understand what's going on so here you can see one individual block and i have brightened up the entire scene so it's a bit easier to see what's going on and right now this block by itself is totally fine now the issue that we have is that this block needs to look good in literally any kind of size so for example it would need to look good like this like this like this like this and in our case right now especially if you squash this a bit more it starts to look really weird it might look okay like this but we can't guarantee it's always looking like this and especially if we have a case like that it starts to look really really bad so the issue that we have is that if we just took an image and scaled it up to whatever we need we might squish it or stretch it in such a way that it might end up looking weird so we need to do something else and what we are going to do instead is this let me return to the darker background this white background is what we want to create and again here the aspect ratio is really important that this thing should be able to scale in any size any proportion that we want within reason i suppose and as a consequence we couldn't just scale a random image so what we are going to do instead is this we are going to just create the edges so each of these corners is going to be a separate background and these cannot stretch they will always have the same size but then we are going to bleed some more surfaces these yellow ones the difference for this one though is that these yellow rectangles can stretch and as a consequence it doesn't really matter how big the surface is going to become because this white surface is going to become wider or shorter depending on how big it needs to be and then in the end we're just going to fill the entire thing with a color and we are basically done with it and all right i think all of that might be slightly difficult to understand so let's try to explain this in a different way here we can see one block that we might actually see in the game and this thing right now might look like one coherent image but in reality it actually isn't i can for example take the top left away i can take the bottom left away i can take the left away it all works just fine and the trick now is let's say i have this block but i want this block to be bigger and now the trick is let's say i want to expand the size of this thing on the horizontal axis so i want let's say the top left to be here and the top right to be here and they do have to be on the same height that is really important basically if i have this now i can take the middle part and this one is supposed to scale in the x axis and if i scale it like this then we have well a properly working setup so the top left and the top right don't scale but the middle part does scale and since the middle part can scale without any loss in quality this system works really well and this is essentially what we are going to implement in our game so i hope that is going to make more sense in our game folder we have blocks and inside of blocks we have a couple of different colors and the player and let me open the blue one so inside of the blue folder we have just a bunch of very small images and this is essentially what we are going to import and then we are going to use these individual images to create the actual surface for the player or for all of the blocks and if we use that system we have blocks that scale in basically any dimension so i think if we implement this all of this is going to make much more sense so let's go straight into the code and let's have a look at this here i am back in my code and what i want to do is to create a new file and this one i am going to save as surface maker dot pi and in here i am going to create a class so class surface maker and this m should be capitalized and what this thing is essentially supposed to do let me add a comment it is supposed to import all the graphics and it is supposed to create one surface with the graphics with any size and finally it is supposed to return that image to the blocks or the layer and that's basically all we want to do in here now for that to work we need a couple of different things first of all we need to import pygame for the obvious reasons and besides that we need from settings import star and just to test that this thing is working i want to for now give it one method that i'm going to call get surface and this one itself we want a block type so we know what color we get and we need a size and now all we are really going to do is image is going to be pygame dot surface and it's going to create a surface with a certain size and for now this image we are going to fill let's say for now with a red color and once we have that we want to return that image now this surface maker i now want to import into my game class so in my main file i need from surface maker import surface maker and now as the first thing in this setup i want to create an instance of this surface maker so self dot surface maker is going to be surface maker and now the player is going to get an instance of this self dot surface maker and when we create a stage so all the way down here each of the blocks is also going to get an instance of self dot surface maker and now you might be asking yourself why don't we just create an instance of the surface maker inside of player and inside of each of the block when we create a class itself why do we import this straight in the game method the reason here is that surface maker in a second is going to import a lot of images so it's going to import each part of each of the blocks and right now we are doing this once but if we were to create a separate instance of this method for each player in each block we would import significantly more images and as a consequence i am going to import it here and make it available to all of my classes that need it alright now in my sprites let's start this with the player now the player first of all is going to need another parameter so surface maker and let's put this straight in the setup part so self dot surface maker is going to be surface maker and now essentially what we can do instead of getting a random surface here i want to do something else i want to do surface maker and then call this get surface method here so surfacemaker.getsurface and in here we are going to need a block type and a size so let me copy the parameters and now for the block type for now we are just going to say player so we know what's going on and for the block type for now we are just going to say a string of player and the size we still have i still have it in my notes for this let me just copy it so the size is just going to be 10 of the window width and 5 of the window height and now our surface maker is going to create a surface for the player and this is what we actually want to do now before we can test this we have to do the same thing for the blocks so now for the blocks they are going to need another parameter called surface maker and before we are creating an image i want to set self dot surface maker is going to be surface maker and then let me copy out block width and block height so i save a bit of writing and in here all i want to do is self dot surface maker dot get underscore surface and in here i want to have my dimensions and for the block type i already have my block type so what we would expect now is that we can see some red rectangles but the size should still work and we are getting an error that i believe i forgot a bracket so now let's try this again and now we can see all of our surfaces are red not exactly helpful right now but something we can work with now we can work inside of this surface maker and actually create the graphics and the first thing we have to do in here is to import all of the surfaces so this is going to happen in the init method and this one itself and nothing else and since we need access to the folder we actually to import another module and this one is from os import walk and all that work really does is it works through a couple of folders in our operating system and i can actually show you what's going to happen so what we can do for example is for info in walk and now we need to path to our graphics folders which in my case is this one here so we go upfront folder to graphics and then to blocks and now if i print this information so print info and now if i run all of this we again can see our game and now in the bottom part we have a ton of data so let's talk through it essentially we get two bits of information so this first list we get here is kind of different from the other lists um let me actually explain essentially what work does it looks inside of a folder and it returns a couple of things the first bit of information we get is the folder path which is what we already have so we don't really care about it then we get all of the subfolders so my case we have blue bronze green gray and so on these are all of the folders inside of that main folder and then we have a third list and this one would contain all of the data besides the folders so any kind of image would be in here now this would be our first list but what work also does is it goes through every single subfolder inside of this folder and then gives us information on that as well for example here is the second list we get and in there we are looking at the blue folder and inside of the blue folder there are no subfolders so this list is empty but we have a ton of images so now we have bottom png bottom left png bottom right png and so on and this is the information i can use to import all of the data that i need although we do have a problem here that the structure of this list is inconsistent meaning that it changes after the first item so the first item here is kind of different from the rest of the list so we have to be very careful when working with this essentially the first thing i want to do is i have to identify the first element inside of the list being returned from walk and the easiest way to do this is to use the enumerate method and with that one we get index and we get info and now what i can do is if index is equal to zero so if we are on the first list what i can do with this information is to create a dictionary and then this dictionary is going to hold all of the data so let me actually implement this i want to call this self.assets and self.assets is going to be a dictionary comprehension so i want to create a color key with another dictionary inside of it and this for color in info and index number one so info 1 is just the name of all of the folders and let me actually print again the information that should make it a bit easier to understand what we are doing here we have all of our data again and right now i am exclusively looking at the first list and in here the graphics part we are just going to ignore but info one is this list here and really all i'm going to do is i'm going to cycle through every single item inside of this list and turn every single color into a key for a dictionary and then this key is going to be associated with another dictionary that for now is going to be empty so if i print self dot assets as well and run all of this again we again get our game that we don't care about we now have after the first item another dictionary that just says blue empty dictionary bronze empty dictionary green empty dictionary and so on and this is now going to be the structure for how we are going to store our data what that means in practice if the index is greater than zero so i can just add an else statement i want to go for image name in info and to so info2 are going to be all of the names of our files and this is what i want to look through and now i want to create a full path so this could for example be the full path to the top left inside of the blue folder or the top part or the right part and for that to work we need a few things first first of all i need to figure out my color type so do we have a blue piece right now do we have a bronze piece or a green piece and this we get with self dot assets dot keys and essentially in here i want to take the index minus one and index minus one is going to because we are essentially skipping index zero and then our first item inside of assets is going to have the index with zero and all of this i want to turn into a list and now that we have that i can just copy my graphics blocks i can add the color type and now we need something else for the color type because this has to be inside of an f string but a simple reason that we do need the slashes if we don't have those the whole thing is not going to work and finally we need image name and now this path here is going to be the full path to every single graphic inside of our graphics folder but let me just print what we actually get if i now run all of this again we are getting an error because the list let me get rid of the error message so we don't want to turn this entire thing into a list we want to turn only the keys into a list so then we can use indexing so now let's try this again there we go essentially what we have created now is let's say inside of this one here we have the player and we get each of the graphics inside of the player folder and this one is just going to be a string and that is what we wanted to import and this is going to happen for all of the folders so we have purple for example we have a red for example and discontinues and let me get rid of the print statements they are getting a bit annoying okay cool so now what we essentially have is a full path to each of the file we care about we can use that information now to just import all of these images and this happens with pygame.image.load we want to get the full path and then don't forget to convert alpha all of this and now we have to attach this surface to the assets dictionary and this is going to happen with self dot assets and in here i want to get the specific color type and this is then going to be another dictionary and inside of this dictionary i want to create another key and this key is going to be image name dot split and what we want to split is add a dot and then we only want to get the first index and then this is going to get the value of our surface now what does this line mean and i think this is best explained if i actually print self. assets and let's see what we get so if i now print all of this we are getting a lot of information but basically let's look at the first one so we have blue here and blue extends all the way to here so let me go to surface maker and we are looking just at the first dictionary and this self.blue we are getting with self.assets and the color type and now inside of this dictionary we get imagename.split add a period and then we get the first part of this index and essentially what that did is that for the first surface here for example the original name was bottom.png and what this imagename.split did is remove the png at the end of this bottom so that we don't have to work with the file extensions we just get the name of the file and once we had that we set the surface to the value of this dictionary and this we have done many many times over so again these lines really not that simple anymore i would recommend to go over them a couple of times if you're confused but this is actually all i needed and with that we have actually already covered the first part that we imported all of the graphics and i guess we also covered the final part that we want to return the final image so the last thing that we do have to do is to create a surface with the graphics that covers basically any size and for that we are going to need a bit of space first of all i do not want to fill the image we already have with a color so let me just remove it for now and now we have to blit essentially nine different things we need the four corners we need the four sides and we need the center color so let's start with one and let's see how far we get and before we can start on the corners we first need to know what color we are working with and this i want to do all the way at the top and for this one i created sites and sites is just going to be self dot assets and then we are going to get the block type so the block type in this case would be blue or green or bronze it really doesn't matter for now what we are going to get and for now we don't really work with this too well so for the image right now we are just getting the block type so let's say for now we're just going to change this to red and for the player i think it already said player yeah so this player already works and now we can actually start using that this section i think is getting really hard i hope it still makes sense but essentially all we want to do now is image.blit and we want to get sides and the side we want to get in here is top left and the position where we want to place it is 0 and 0. and now let's see what's going to happen this is looking much more interesting so now we get the top left for each of the blocks we should also be seeing something for the player let's actually have a look and if i look at my sprites and in the player the problem here is that after i created the image with surface maker i'm filling all of this with a red color so let me get rid of this one and now let's try this again and this one is looking better you can also see the top left of my player and now let's do the top right so image dot blit sides and now i want to get the top right but now i need a position or more specifically i need x and y now y is kind of easy because the top right should be at the top so this one can just be zero the left side is going to be a bit more difficult though so let me draw what i am going to do here is the surface we are going to create and the individual part i want to place right now should be in the top left and now i need an x and a y position now the y position can just be zero because it's supposed to be right on the top part but now for the x essentially what i want to do i want to get the entire width of the main surface let's call this w and from that i want to subtract the width of my smaller part let's call it w 2. so all i really have to do is get my w minus my w 2. and that way i would get to this point here which would be the left side of this part which is exactly what i care about so all i really want is to get size which is what i get up here and in there i want to get the first element which is my entire width and from that i want to subtract this surface here and then dot get underscore with and let me remove all of this so it's a bit easier to read so this is the entire size of our surface of the main surface and this is the width of the corner part so this should be working let's try and there we go now we have the top left and the top right for both the blocks and our player let's now do the top middle part and this one i want to have in the sides and now i don't just want to look at all the four sides let's do this a bit more methodically i just want to look at the top side and then here we need a few bits that are important since we want to scale the top part i need to know how wide this thing has to be so top width once we have that information i want to get something like scaled pop surface and this we get in a second and once we have that i just want to image dot blit then this scaled top surface and now we need an x and a y position now for y we already know this is going to be 0. the x we are going to figure out in just a second but let's start working on the top width and here again i think it's best to draw all of this out so here we have the entire width of our main surface so this is this image here and on that surface i already have a top left and a top right so essentially what i'm trying to find is this distance here and well if you look at it like this this should be fairly simple all we really have to do is get this entire width and from that subtract this size and this size and that way we are left with the part we actually care about and in practice what that means we again want to get size zero so that's the entire width of the window and from that we want to subtract sides and in here we have top left and from that i want to get underscore width and this i want to add two sides and we want to get the top right and this one also needs to get get with and with that we have the width we are going to need so now we have to use that information to scale that surface and this we are going to do with pygame dot transform dot scale and in here we need a surface and then a new width and a new height now the surface is kind of easy because we have sides and top and the width is going to be top width now the height i don't want to change so this one is just going to be sides and top and then get underscore height so with that we have our scaled top surface now all we have to figure out where to place this and if you again look at this graphic it should be fairly simple we essentially want to put this top surface on the right side of the top left so all we really have to do let me copy it from here we need to get the width of the top left and if i paste this in here we should be good to go let's try this and there we go now we have the top part let me remove all the drawings this is not looking bad at all and essentially now we have the basic system to make all of this work the rest of this entire system is just replicating all of this a couple more times so we need two more corners bottom left and bottom right and then we need left right and bottom for the sides and then we also need the center and i think this could be a really interesting challenge so to make sure you understand the system try to implement this yourself and see how far you get i do understand this entire system is quite complex so if you have to go over it a couple of times i would really recommend to do this if you're not sure about what you are doing it is well a bit more advanced so try as far as you can get i guess we can finish the corners first so we already have top left and top right next up we need bottom left and bottom right so image dot blit again i want the sides and now let's go with bot left and here again we are going to need x and y now in this case x is going to be the easier one because the bottom left should be on the left side and now we have to figure out the top part of this side and this we get with size 1 and from that i want to subtract sides bottom left and i just realized i forgot a bracket so sides bottom left and from this one we want to get the height and let's try this one we got an error because probably some kind of bracket didn't work out i think it's this one let's try this one looks better all right so now we have the top left for all of our surfaces now finally we are going to need the bottom right and for that i am just going to copy the bottom left and change this one to bottom right now for this one the top part so the y position already works we just have to figure out the x aspect and this one we kind of already have because this one we essentially did when this line here so size 0 let me paste it in here so size 0 minus sides this one should be bottom right and then get with and then the other side and this one should be all we need let's try this one and there we go now we have all of the corners so that is a really good start next up we need the left side we need the right side and we need the bottom side and this is all going to work very similar compared to what we have done here so i'm just going to copy this one and let's work with it so instead of top width it should be let's call it left height and in here we don't want the width of the entire thing we want the height and from that we want to subtract two things the top left is still fine but now we also want the bottom left and now we don't want to get the width we want to get the height and this should be done for both of them so with that we have the entire height that we need next up i want to get the scaled left surface highgame.transform.scale still works then i want sides this one should be left and now for the scaling i need a new w and a new height the height we just got that is going to be the left height now with is the easier part all we are going to need in here is sides left i think i called it and from that we need to get underscore with and we should be good to go now finally we need this scaled left surface this one should just be left as a matter of fact we want to put this on the left side so this one should be zero and now we have to figure out the top part of this surface and this one we get with sides and this one is going to be top left and now get underscore height and let's try this one and this one is also working just fine cool two more sides and then we are basically done with this one so now we have the right side and for this one we can actually copy the left side and this should be a good bit easier so now we want to get the right height slice.1 still works and now we want the top right get height and this one should be bottom right and get height still works just fine okay then next up we want scaled right surface and for this one program.transform.scale and the surface we want to scale is the right one and now we are going to need a new scaling so a new dimension and in here for the width we just want to keep the width of the original right side and we have a new right height and this one we can just reuse that's the one we get up here and then finally we want to place scaled right surface and now we need an x and the y we already have so this one can stay the same because both the right and the left side should have the same top part although i guess for this one we can go with top right so now what we have to figure out is where to place the left side of this surface and with this one again we need the full size of the entire surface so the full width and from that i want to get sides at the right side and from that i want to get the whiff and with that we should be having our right side and this one is working as well cool almost done with this part now for the bottom side i want to copy my top side because this one is the closest to it and now top width is going to become bottom width we still want to get the full size minus the bottom left dot get with last the bottom right dot get with then we have a scaled bottom surface and then here we want to place the bottom or we want to scale this one and we have the bottom width and sides bottom dot get height and this one should stay the same because we want to keep the same height now we have to scaled bottom surface and now finally we just need to figure out our position and the left side is still totally fine so this one we can just keep now we just have to figure out the top and here again i want to get the full height of the entire surface and from that i want to subtract sides bottom and dot get the height of this one and with that we should be done let's try this one now and this is looking nearly done we have two more issues to work on we have to fill the center and we have to get rid of the black color on the edges i guess the center is the easier part because we have this one right here and for this one we are going to need two attributes we need center height and we are going to need center width and once we have that we can create a scaled center and this one then is just going to be pygame dot transform dot scale and in here we already have besides center and i just want to scale this to center width and center height and once we have that i can just image dot blit scaled center and then i have to figure out an x and a y so let's work through these parameters so let me give a bit more space essentially what we have right now this thing here again is going to be our entire image and what we have so far is a couple of corners so these four corners here and besides that we have the sides so we have the left side we have a top side we have a right side and we have a bottom the only part we don't have yet is this center bit here and the x and the y position we're trying to figure out here is going to be this top left position and the center height and center width is going to be this one for the height and this one for the width so these are the bits of information we are trying to figure out so for the center height i want size 1 so my height of the entire image and from that i want to subtract this bit here and this bit here which in practice means sides and we want the top and then get underscore height and plus sides and bottom and this one is also going to get right so with that we have the height next up we need to center with and this one works in pretty much the same way as a matter of fact let me copy the entire thing so now instead of the height we want to get the width and now sides this should be right and this should be left and now we don't care about the height we care about the with or both of these and this one works by itself already so the last one we have to figure out is the x and the y part and in here essentially what we care about is this point here again and this point is literally just the width and the height of the top left so this is what we can pass in here so i can just get rid of the entire thing and sides and i want to get the top left and get size and now let's try this and there we go now we have a filled center this one feels significantly nice the last thing we have to do is to get rid of the black edges and this one we can do all the way at the top and really all we have to do in here is set a color key so set underscore color key and this essentially tells pygame to get rid of one specific color which in our case is 0 0 and 0. so now the game is looking drastically better and well you could add any other color in here if you ever wanted to get rid of something specific in terms of color and pie game this is how you would do it especially when you are using sprite sheets this one is being used all the time okay and with that we have the entire surface maker that was way more complicated than i thought it would be so ah well done if you could keep up this one really wasn't easy okay now what we have to do next is actually make sure we get the colors right so right now they're all red they're still working but well we only have one color and this is going to happen inside of our sprites so let me minimize everything else and blocks i want to keep open so right now the problem that we have is we always pass red into our surface make and obviously that is not ideal so instead what i want to do is to use this color legend and this one basically converts a number to a color so in my sprites basically what i want to do is get my color legend and in here pass in the block type and now let's try this one and now we have some nice looking colors already a massive upgrade and let's see if i can get to the second row without dying too often okay not going terribly well i'm really bad at this game um okay so now we get this one should disappear yep this is looking good cool now the one problem that we do have is that the health of the blocks does update but the color doesn't change with them which makes the game look kind of weird so when the ball hits one of these blocks i want them to change their color and basically what i want to do if the block gets damaged we want to subtract the health by whatever amount we have and then if our health is greater than zero i want to create a new self dot image and the image we want to create is self dot surface maker dot get underscore surface and then here we need to get what kind of block we want to have and for this one i am again going to use the color legend so let me copy it from up here but now we don't want to look at our block type instead we want to look at our self.health the problem now is that this self.health is an integer so i want to turn this into a string so that it's going to work with this dictionary here just fine and the other thing we need are the dimensions of our block so this is just something we can copy from the initial part and this should be all we need so now let's try this one again these blocks still just disappear this is look fine just takes a second to hit the second row and yeah there we go so now the green blocks turn blue once we hit them and if we i hope i can hit them again so they are disappeared and i guess we can try to go to the third row and see if this one still works and yeah there we go this seems to be working really really well nice so with that i think we have a really basic game so that was a really long section um sorry that got a bit complicated i hope you could follow along we definitely got over the worst part now we can work on the easier bits and the next part i want to work on is adding some hearts so the player can see how many hearts are left and if there are zero left then the game is over this part should be really simple in fact let's jump straight back into the code and let's implement all of this here i'm back in main.pi and in my indian method i would like to add another section and let's call this one hearts and all i really want to do in here is self.hard underscore surface is going to be pygame.image.load and the path towards that is going one fold up then graphics then we have other and then hard dot png and don't forget we want to convert alpha all of this and now i want to run another method or create another method that i called display arts we need self and nothing else and in here let me give a bit more space i want to do something like for i in the amount of health the player has let's say for now it's just going to be free we're going to make this a bit more flexible in just a second and well if that is the case i just want to self dot display surface dot blit and now again i need a surface and a position the surface is very easy it's self dot hard surface now for the position we are going to need x and y now why in my case is really easy i just set this to four so that we have four pixels between the top of our heart and the top of the window now x is going to be a bit more difficult and essentially all i want to achieve let's say we have three hearts or well in my case boxes but doesn't really matter and what we have to place is this left side and essentially what i want to do i want to get this i here and multiply it with the width of each of these hearts so if i is zero this is going to be zero but if i is one then this position here is going to be one times the width of each of these surfaces so if the heart is 40 pixels wide this would be 40. and that way these surfaces would be right next to each other that's really the entire idea here and let's put all of this in a separate variable let's actually call it x i want to get i and multiply this with self dot art surface and get underscore with and in my run method i can just let's put it in draw the frame so self dot display arts and if i run this now we are getting an arrow that oh this shouldn't be free this should be a range object so now let's try this again there we go now we can see hearts although we have another problem now that hearts are overlapping with all of the blocks which isn't ideal right now and what i have done to overcome this is in here i have set a top offset and all this one really is is the window height divided by 30. and now when we run the stage setup so this one we created a while back and we are placing y i want to add the top offset to all of that so we basically just move all of these positions down by a few pixels so now if i run this we have some more space at the top that's really all we did which feels much cleaner and to make this thing a bit more clean i want to add a bit of a gap between each of the hearts which also isn't difficult to add let me minimize these other methods again so basically all i want to do is make this width wider than the actual surface so let's put it in brackets and let's say plus four and now if i run this there is a bit more space between them might even be a bit too much let's put this to two if that fits better yeah it definitely feels better and now to give them a bit of an offset to the left i want to add two to all of this so now let's try this again and now the hearts look really nice the one thing we now need to figure out is that this three right now is entirely static so instead i want to change this to self.player.hearts or lives or whatever you want to put in there it doesn't really matter so then in my player class i have to add another attribute in here that is self dot hearts and by default this is going to be free so now if i run this we shouldn't be seeing any change and we don't but now if i change self.hearts to let's say something like 10 this is looking perfectly fine but let's keep it at free and now all we have to figure out is that if the player misses the ball this self.hearts should be reduced by 1. so let me minimize the player and here we have the ball and in our window collision we have this part here where we check if the board has failed and if that is the case we just want to set self dot player dot hearts minus equal one and now let's try this so there we go we lost one heart if i do this again we're losing another heart i can do this again and now we have zero hearts so this doesn't help us and essentially all we want to do in my run method so let me minimize the display hearts and now what i want to do in my event loop right now i'm checking if event type is pygame.quit and i want to add or self.player.hearts is smaller or equal to zero and now let's try this again and let me deliberately fail this time and now the game should end there we go now the game ended by itself so this is also working well so with that we have some hearts so let me minimize all of these methods the game is getting quite complex so for the next part i want to work on the upgrades basically whenever a block gets destroyed we want to create an upgrade and this is just going to be a simple sprite that falls downwards and if it collides with the player the player gets some kind of upgrade so the player could become wider it could get lasers it could get faster and it could get an extra life i think those are the four upgrades i have and that's basically it so let's go straight to it and let's implement all of this here i am back in main.pi and the first thing i want to do is in sprites.pi because in here i want to create another class and this one will be called upgrade and again this is going to be pygame dot sprite dot sprite and it's not going to be a complicated class all we really are going to do is give this an init method we need self we need a position we need to upgrade type and we need what groups this thing is supposed to be part of and now in here we again need our super dunder init method and pass the groups in here and now first of all self.upgradetype we want to turn into an attribute so upgrade type next up we have to create a self.image and self.rect and for the image i just need pygame.image.load and for the path here i want to create an f string for the simple reason that my path is one fold up graphics upgrades and inside of upgrades i have my upgrade type and let me illustrate what that means so here's the folder we have graphics we have upgrades and in upgrades we have heart laser size and speed and when i have my upgrade type they are going to be named in the same fashion and that way all of this is working and don't forget we need to convert alpha this as well and now for the rectangle all we need is self.image.getrekt and in here the mid top should be the position we place in there and now since we are going to move this we also need self.pos which is going to be pygame.math with self.wrecked.top left and then we need self.speed which i have set to 300 and this thing also is going to need an update method that needs self and delta time and this part is going to be super simple we just want to move it downwards so self dot pos dot y plus equal self.speed multiplied by delta time and for this one we don't need any kind of direction because well we only move in one direction and now we also have to set self.rect.y is going to be round self.y and there's one more important thing that if self.direct.top is greater than window height let's say plus a hundred and if that is the case we want to destroy this sprite just so that we are making sure that we don't end up with too many upgrades that we can't get rid of anymore so this is a totally fine upgrade class now we just have to figure out when to spawn them so we need some kind of information in our block because the block knows when the block is being destroyed the problem is that the player also needs access to these upgrades so i want to keep the upgrades a bit more accessible so what i'm going to do i am going to import the upgrades to my main.pi file and in here i am going to create another method and this one i'm going to call create up great and this one itself and nothing else and in here first of all i want to create an upgrade type which should just be a random item from a list so we need choice again which we don't have right now so from random import choice but now what kind of list do we have in this list i want to keep in my settings so in here i have another entry i want to add and this one just looks like this so i have my upgrades i have speed laser heart and size and those are the same items i have in the folder so now i can just copy upgrades and pass it in here and with that i am going to get a random upgrade now next up i want to actually create the upgrade class or one instance of that and now let me copy all of the parameters we need we need position upgrade type and groups now position i want to get from the parameters how that works you're going to see in just a second upgrade type is going to be upgrade type this one we already have now next up this one always has to be in all sprites besides that i want to create another group that i called upgrade sprites and this we need to create in our sprite group setup so self dot upgrade sprites is going to be pygame.sprite.group so all we have to figure out now is when to call this method here and this i want to call from the blocks so in my stage setup when i am creating a block they should have this create upgrade so i'm going to pass this function in there as an argument so make sure here to not call this method i just want to pass the function itself or the method itself and this should be self.create upgrade so now let me minimize everything else in the block we need another argument and that is create upgrade and let me add another section down here so self. create upgrade is going to be create upgrade and before we are destroying the sprite i want to self dot create and upgrade and the position i want to pass in here is self.rect.center and that should be all we needed so let's try now and we are getting an error and that is that we cannot find the file graphics upgrades and speed and the problem here is quite simple so in my upgrade class igame is unable to find this file here and the reason for that is that this one needs dot png at the end so now let's try this again now we have another error this vector 2 should be capitalized and next attempt there we go now we have a couple of upgrades i hope we get some more different ones yep this is looking good we get a lot of speed once i don't actually know why i think it's just random okay um random module is very strange today yeah okay this one's looking better okay um yeah this one i think is getting better cool so it's definitely working except something is wrong with the random module today that we don't seem to get proper randomness um all right this is working just fine now the problem is that we don't want to spawn an upgrade every single time a block dies so we only want to randomly call this method here in like 20 or 30 of the cases and in my case for that i used randint so we have to import that one as well and all i really have done in here is if randint between 0 and 10 is smaller than 3 and only then i am going to create an upgrade so let's try this one now we don't get an upgrade now we should be getting one very soon let's hope it's still working there we go okay uh yeah the numbers might be a bit very low but they are working for the purpose of this tutorial i can change this to smaller than nine so we can see something and there we definitely get more of them okay so it is definitely working now next up what we have to figure out is the collision between the player and the upgrades and that is just going to be another method inside of our main game so in here let's call it upgrade collision this one itself and nothing else and in here again we have to create overlap sprites and this could actually be a good challenge that i want you guys to check the collision or well the overlap between the player and the upgrades and if that is the case i want you guys to write another method inside of the player and call it from this method here by passing in the sprite type of the upgrade and see how far you get now first of all i need pygame dot sprite dot sprite polite and i need self dot layer i need self dot upgrade sprites for the group and then do kill has to be true and now for sprite in overlap sprites i want in my player to run some kind of upgrade method and there is going to be one argument and that's going to be sprite dot upgrade type so in my sprites let's minimize every single thing in here they always have an upgrade type and this is what i want to place inside of that method so now inside of our player we need to create another method let me minimize everything else in here so define up rate we need self and we need an upgrade type and for now let's just say we want to print the upgrade type and let's see if this is working oh actually right now it cannot work because we are not calling this method and this i want to do when i update the game so self dot upgrade collision and there were no arguments so let's try this now and we get size we get new upgrade we get speed and i am surprisingly bad at this we get size again and we get hard in laser oh and the game ended because i ran out of hearts but it's definitely working so now in here we just have to figure out what to do with these upgrades and well let's go through them one by one so the first one is if upgrade type is equal to speed and if that is the case self dot speed i want to set to plus equal 50. and if upgrade type i call this one heart i want to set self dot parts plus equal one and let's see if those two are working let's hope i can get a heart and there we got a heart and we lost the heart but i hope you saw it um okay let's try this one again speech this one uh okay i do have to try to get a heart without losing your heart straight away but uh okay seems more difficult than it looks there we go laser last try okay but i think you get the idea i don't want to stretch this out too much yeah we can get a heart ah there we go now we have four hearts so this is working nice next up we have if upgrade type is equal to size and in this case we want to increase or create a new width and this we get with self.direct.width and multiply this with 1.1 so our new width is going to be 10 wider than the old width and this i want to use to create a new self.image and this again i am going to use my surface maker for with get underscore surface we have to pass in layer and now we need our new weft and for the height i just want to get self.rect.height so this way we are going to get a new image and now i also have to update the position so self.wrecked is going to be self dot image dot get underscore rect and the center is going to be self.rect.center so where the old center used to be and now since we updated the rectangle self.pause.x has to be self.direct.x so this one doesn't get confused and now before we are going to try this let me in the create upgrade method comment this one out and let's change the upgrade type to size so now we should only get size upgrades and this should make it easier to visualize what's going on this seems to be working just fine we are definitely rowing quite well yeah this is definitely working and in here again we need the surface maker to keep this surface looking good if we didn't do it this would stretch out more and more and look increasingly weird okay but this one is certainly working all right nice so now i can set this one back to normal and finally we have to work on the lasers so if upgrade type is equal to laser and all i want to do inside of this method is self dot laser amount plus equal one and for that to work we first of all need a laser so let me add another section here laser and self dot laser amount by default is going to be zero and since we want to display an extra graphic if there is a laser we have to import another surface let's call this one laser surface and in here we need pygame.image.load as always and the path is going to be one fold up graphics other laser dot png and as always convert alpha and another thing i do want to do is self dot laser underscore rects and by default it's going to be an empty list you're going to see in a second how that is going to work now the upgrade method we are done with and what i want to do is self dot let's call it display lasers in itself and nothing else and in here i want to check if self dodge laser amount is greater than zero so if that is true we know there is going to be a laser and now what i'm trying to do this is the size of our player and i want to place lasers there dynamically now i know the bottom of the laser it's going to be here and now i just have to figure out where on the xcoordinate i have to place my lasers so here here and here and so on so how can i figure that one out and essentially what i did i am always dividing the entire width of this surface by the amount of lasers plus one so if we have one laser we are going to divide the player by one over two if we have two lasers we are going to divide the player into three bits and then this distance here we are going to use from the left to place the laser so if we only have let me use a different color if we only have a single laser we're going to go from this point on the left half weight of the size of the player and place the center of the laser here and if we have two lasers so this part here we are going to go one third so roughly here and then we are going to go another third so roughly here and place a laser here and here and then the more lasers we get the smaller this distance is going to get and first of all i want to get what i called a divider length and this one is just going to be self.rect.width divided by self dot laser amount plus one and now for i in range self dot laser amount i want to create a new rectangle let's call it laser rect and this laser rectangle is going to be self dot laser underscore surf dot get underscore rect and i want to place the mid bottom of this rectangle and this one is going to be needing an x and a y position now the y position is easy it's just self.rect.top so the top of the player x again is going to be a bit more complex so let me place this one in a separate variable and essentially all i really want to do in here is self.direct.left plus divider length and i want to multiply this with i however the problem now is that this i by default is going to be 0. so i want to take this i and add plus 1 to it and now we are very nearly done once we have this list i can just loop over for laser wrecked in self dodge laser rects and in their self.display surface which i think the player has no the player actually doesn't have so we have to import the display surface in here as well and let's do it straight in the setup so self dot display surface is going to be pygame dodge display dot get underscore surface and this is going to get us the display surface and this i now want to use down here and then blitz our self torch laser surface and then the laser wrecked i want the one thing i forgot is self dot laser rects dot append laser rect so the problem we have right now if we left the code like this we would keep on adding more and more lasers so at the beginning of this method i'm going to set self.laser rects to an empty list that way we are creating all of this from scratch every single time and all right the only thing we have to do now is to actually call all of this so all the way at the bottom of my laser self.display lasers and let's see if this is working so we now get an error so far and if i know if in laser we can't see anything now the reason for that is this we are basically drawing our lasers inside of this method here so when we update the sprite we are calling display lasers the issue is then we are drawing the background after that so if i were to move my background on top of all of this then we should be able to see lasers so now let's try this and there we can see a laser it doesn't do anything right now but it definitely works and even if we have two lasers let me try a few more times maybe i find a few more now the important thing here is that this laser mechanic also works with multiple lasers and even if the player gets wider this system still works so okay we get faster but this seems to be working just fine and somehow pygame really likes the speed upgrade for some reason okay let's try this one again and right now you can see because we have too many upgrades it looks a bit silly but it definitely works so i guess we can just draw the background here and this one still works just fine cool so now we can see the lasers so let me minimize this one and let me minimize this one as well this one as well now we have to figure out the projectors for the laser and i guess let me minimize all of this stuff here so it's a bit easier to see what's going on now for the projectile this is just going to be another sprite that this one just moves upwards so i want to add another part in here and let's call it the projectile and this one is just going to be self.projectile underscore surface and for this one we need pygame dot image load and in here the path is going to be one folder up graphics then other and then project tiles.png and don't forget to convert alpha all of this again so now we have an image of a projectile let me minimize the init method again and now i want to create another method and this is going to be create projectile needs self and nothing else and all i need to do here is for projectile in self.player.laser underscore rects so the rectangle list we just created and if that is the case i want to create a projectile instance of a class that does not exist yet so we have to create this one as well and this happens again in sprites so let's do it all the way at the top and class project tile and again this is just going to be pygame.sprite.sprite and this one is just about to be the easiest class you can have so this one needs an image and a rectangle and then also a position and a speed so we can move it upwards and this could be a good challenge for you so try to create this entire class it should only be about 10 lines of code in total and you will need a position you have the surface from main.pi and you will need the groups to place it in all sprites so see how far you get first of all i again need a dunder init method and this one is going to need self a position a surface and groups and now in here i again need a super under init method that is going to get groups as an argument then i need self.image is going to be the surface we get from the parameters and self.rect is going to be self dot image dot get underscore rect and we want to place the mid bottom where we have our position now besides that we again need self.position and this is pygame.math.vector2 and here a self.wrecked dot left and finally self.speed in my case it's just 300 it's basically random choose whatever you like now once we have that i need an update method with self and delta time and in here all we are going to do is self.pause dot y minus equals self dot speed multiplied with delta time and then self.rect.y is going to be rounded self dot pos dot y and finally we again want to check if self.rect.bottom is smaller or equal to negative 100. so now since the laser is moving upwards we want to check if the bottom of the laser is on top of the window and if that is the case we want to destroy that sprite again here if we don't need a sprite on the window we shouldn't keep it around it might hamper our performance but alright this is all we need for our projectile so now back in my main.pi actually before i do that let me copy all of the parameters and place them in here and let me fix the typo on player first of all we are going to need a position and in here i want to go with projectile dot mid top and remember projectile in this case refers to a laser rectangle but i don't want this thing to spawn right on top of it i want to give it an offset so i want to subtract pygame.math.vector2 0 in x and let's say 30 in the y direction and you have to use a vector here because midtop is essentially a tuple okay next up surface this one is the easiest all we need in here is self.projectile surface and let me put all of these arguments on separate lines so all of this is easier to read okay now finally for the groups as with all the other sprites this one has to be in all sprites but i also want another group with self dot projectile sprites and this again has to be in the init method we need self.projectile sprites is going to be pygame.sprite.group and now the last thing we need is to actually run this method whenever the player presses space and this in my case is going to happen in the run method in this event loop so if the player is pressing space i want to run self.create projectile and let's see if this is working and we are getting an error that there is no file called projectiles and i think the reason is i call this one projectile not projectiles so in the init method this should be just projectile now let's try this again it does seem to work oh yeah we have no lasers right now so just to keep the game running when the game is starting i want my player to already have two lasers so now if i press we get some kind of laser the issue we have now is if i press really fast we have more and more lasers which is a bit too easy for all of this so i want that to be some kind of timer that makes sure that the player cannot fire continuously and for that i want to create self dot let's call it can underscore shoot and by default this one is going to be true and besides that we need self dot shoot time by default is just going to be zero it doesn't really matter what it is and now in the event loop we only want to be able to create a projectile if self dot can shoot and once we have done that self dot can shoot is going to be false so now if we run this we should be able to shoot once but not again which seems to be the case so this one works perfectly well right now so what we have to create now is another method that works as a timer to reactivate can shoot and this one just another self dot let's call it laser timer we need self and nothing else in here and basically what i want to do let me create a timeline so this is the timeline of our game and essentially what i want to do if the player shot a laser at this time here let's say this is one second from this point i want to check our time so i check the time here and let's say at some point we get to the second second and as a consequence i know that this difference here is going to be one second and if this distance is greater than one second i want to reactivate the laser now in practice it should be less than one second one second really is quite long i think for mine half a second felt perfectly fine but the idea is quite simple now first of all i need to figure out the time when the player has shot the laser and this also happens down here when we actually shoot the laser all i need is self.shoot time the other attribute i just created and self.edu time it's just going to be pygm.time.get underscore ticks and now in my laser timer i can run if pygame.time.getticks so this is always going to be our current time and from that i want to subtract self shoot time and if that number is greater than let's say 500 milliseconds i want to set dot can shoot back to true and that is all we needed for a timer so now when we are updating our game self.laser timer and let's run this still works i can keep on pressing space but now we only shoot in half a second intervals which i think is looking kind of okay so let me minimize the run method as a matter of fact i want to minimize all methods so it looks a bit cleaner okay now there's one more method that we are going to need so let's create another method and let's call this one projectile block collision we need self and nothing else in here and now we basically have to write one simple method so i want to check for projectile in self.projectile sprites and in here i again want to get my overlap sprites and this is just going to be pygame dot sprite dot sprite for light and i want to check one sprite which is going to be my projectile then i want to check myself dot log sprites and finally should be false because we do not want to destroy the sprite and now in here i want to check if there are overlapping sprites in the first place and if there is an overlapping sprite i want to check for sprite in overlap sprites and if that is the case i just want to call sprite dot get underscore damage do one amount of damage so this get damage we have already created let me have a look so in the block class we have get damage and this one we created for the ball but we can reuse it for the projectiles so get damage one and now what is really important we also have to destroy the projectile so if there's an overlap i want to call projectile.kill and if we didn't do this line of code we would get more and more overlaps here and the lasers would basically destroy all of the blocks in one go and all right now all we have to do is to actually call this method so self.project lock collision and let's try this one and this seems to be working just fine obviously it's really really strong so you do want to be careful in using it but by itself this is working very very well and does make the game significantly more fun and also a lot easier okay but definitely some progress and now we are nearly done there are two more things that i would like to cover and that is crt styling and sounds now sounds is incredibly easy we just have to import a couple of sounds and play them at certain points in our game so that's not a part i'm really concerned about the more important bit is the crt styling and this one well it's not particularly complicated but essentially what we are going to do we are going to create another surface on top of our game and on this new surface we are going to create some black lines and a vignette and this one is going to simulate this old crt style and then we are going to alternate the opacity of this between some random values and that way we are getting the illusion of flickering here we are back in main.pi and inside of this file i would like to create another class and this one i called crt there is no inheritance but we do need an init method and this one itself and nothing else and in here we first of all want to import the vignette and this one is just going to be an image so we can just import it as vignette and to import it we need pygame.image.load and the path that we need is one fold up graphics other and in there i have a file called tv.png and in here make sure to convert alpha all of this the problem we have right now is that this vignette is not scaled up properly but this we can change let's call this one self dot scaled vignette and in this case we want this vignette to have the exact same size as our window otherwise it would look kind of weird that we have one part of the shadow going outside of the window so all i really want to do is pygame.transform.scale i want to pass in my vignette in here and now i need a width and a height and what i really means is the window width and the window height so now i have a vignette and now there's one more thing that we are going to need and that is self dot display surface and this again we are getting with pygame dot display dot get underscore surface and now that we have all of that we can actually test this method or this class and essentially all i want to do is create a draw method that needs only self and for now i just want to get self dot display surface dot blit and i want to blit myself dot scaled vignette at position zero and zero and this method i would like to run in game.run after we have drawn all of the other elements and this could be a challenge for you so try to call this drum fit to draw this vignette on top of all of the other elements first of all in my game init method i have to create an instance of crt so let's call it crt and self.crt is going to be crt and now let me minimize all of the methods so it's a bit easier to see what's going on in the run method now after we have drawn all of the other elements i want to add let's call it crt styling and all i really have to do in here is self.crt.draw and now let's see what we get this is then already looking a bit better so now we have some vignette that doesn't look half bad the problem is that this vignette is too dark right now so especially in the top left and top right we can hardly see the blocks which isn't ideal so we want to lower the opacity of this surface here and while we are doing that i want to set this to a random opacity on every single frame and essentially what that means i want to get myself dot scaled vignette and set the alpha to one value and you could set for example 60 in here and if we run this now this is looking much less pronounced oh and now we can see the hearts again as well that one was missing before as well and in here 255 would be the maximum and 0 would be well nothing so if we have 60 we are at about a quarter something like that but in my case i don't want to keep this at 60 instead i want to get a random integer which i don't have yet so i have to import it so import rent in from random and now i want to have an alpha value let's say between 70 and 90. and since this updates every single frame we should be getting some very light flickering may even be a little bit too strong but you can play around with this let's say we can set this to 75 and yeah i think this feels good so with that we already have our vignette now besides that what we also want to do is create another method and let's call this one create crt lines and this is to simulate the lines that all tvs used to have and then here we need self and nothing else and basically all we are going to do now is we are going to take this scaled vignette and we are going to draw a couple of lines on top of it so if i'm drawing all of this here we have our entire window and right now on another surface we have the vignette that covers something like this area here so all of this yellow bit is our vignette and on the same surface where we have the vignette i want to create a couple of lines quite a few and this one is going to simulate these old tv lines so we are basically going to take the scaled vignette surface and paste something on them and to get this started we first of all need a couple of parameters the first one is the line height which in my case i've set to four so that's the distance between each line and then once we have that we need a line amount and essentially what we are going to do in here is window height lower divided by the line height so if our window height is 720 and we have a line height for four we should be getting about 180 lines i think and once we have that all we have to do is for line in range line amount and now basically all i want to do is pygame dot draw dot line i need a surface so self dot scaled vignette then i'm going to need a color which in my case will be black and then i will need a start position and an end position and i would recommend for you to try to figure out the start and the end position for each individual line here so see if you can figure this out yourself now the first thing that we are going to need is that both the start and the end position is an x and a y position or rather a value and we know for the start position since the line is always starting on the left side x is always going to be zero and we know on the end point of that line it's always on the right side of the window so this one can just be window width the actually interesting part is the y position and this i want to store in a separate variable and in here well all we really have to do is get our line so this number here and this would be a number between 0 and 180 right now and this i want to multiply with my line height meaning the first line would be on position 0 the second on position 4 then position 8 and this would then go all the way up to 720 and this is now giving us y and now finally all we need to do is define a line width which in my case i'm going to go with one and now all we have to do in the init method all self.create crt lines and this should be working and there we go now we have some crt lines i guess the effect might be a little bit too strong so we might want to work with the opacity a tiny bit more but other than that i think this is looking pretty good and let's change the opacity to 60 to 75 yeah i guess this one's working i guess another thing that you could be doing is change this black to a slightly brighter value so let's say 20 20 and 20. and that makes the lines less visible as well but well play around with this and see what you think looks best but i'm quite happy with this and all right with that we have our crt so now all we have to do is to add the sound and we are done with it and we have a couple of different sounds so we have fail impact laser laser hit music and power up which basically play when the ball is failing when the ball hits a block when the laser is being shot when the laser hits the background music and when the player gets the power up so these are all the sounds you want to play under certain circumstances and this should be one of the easiest parts of this tutorial so let's go through them one by one and this really shouldn't be too hard in fact i would recommend you to try to implement all of the sounds yourself if you've gotten this far this really shouldn't be much of a challenge i guess i can start with the ball this one is going to have quite a few different sounds and in here let me minimize all of the methods in the init method i want to add some sounds and the first sound i get is self dot impact sound and to import sound we need pygame dot mixer dot sound and in here we need to go one fold up and sounds and then impact.wav and now what i also want to do is self dot impact sound dot set underscore volume and i've set this to 0.1 so 10 of the original volume it did get quite loud and besides that i want to have self.fail sound and this one is pygame.mixer.sound we need the same folder so one folder up sounds and then we have bail dot wav and now self dot fail sound dot set volume this one should also be 10 and now in the window collision down here if the ball is failing we want to play self dot fail sound dot play and that's all we needed besides that in the other collisions if there's any collision in here or in here we want to play that sound i want to call this inside of each individual if statement so in here self dot impact sound dot play and this i can now just copy around for each of the if statements and there we go and all right with that we should be having some sounds and we're getting an error message that sounds.fail doesn't exist that's easy to fix all i have to do is change the dot to a slash and now let's try this again we should be having some impact sounds and some fail sounds this is working quite well cool so with that we have the sounds for the ball it wasn't all that hard actually i guess next up we can work in main and in the game class because in here we are going to have a few more sounds just to save me some writing let me just copy all of this this should speed things up a good bit and what i want to get are these sounds so we have the laser sound we have a power up sound and we have laser hit sound and all of them are set to 10 except for the laser hit sound this one is even less loud because um i don't know this felt better there wasn't really a specific reason and now all we have to figure out is when to play these sounds and since we have dedicated functions or well methods for each of them we can just work with that so create upgrade we can ignore create bg we can ignore stage setup we don't need display hearts we don't need upgrade collisions that's the first one we need because in here if there's a collision self power up sound dodge lay and then in create projectile if we are creating a projectile i want to play that sound and this shouldn't be in the projectile because if we play the same sound multiple times it might sound weird so i just want to play this one sound once so self dodge laser sound dot play and now finally we have projectile block collision and in here for every overlap we want to play the sound so self dot laser hit sound i think i called it dot play and let's try all of this and this feels a lot more arcadey and yeah this really changes the feel of the game substantially cool quite happy with that add now back in the init method let me minimize everything again and i just want to look at the init method there's one more thing that we do need and that is self.music and this one we get with pygame.mixer.sound and in here basically the same path we want to get to sounds and in the app we have music.w and for this one we want self.music.set volume to 0.1 and this one we want to play straight away so self.music.org and in here we need one argument and that is loops which should be negative one so we play this continuously and now we should be done okay cool that was it that tutorial ended up a good bit longer than i expected but i hope you enjoyed it and i'll see you around