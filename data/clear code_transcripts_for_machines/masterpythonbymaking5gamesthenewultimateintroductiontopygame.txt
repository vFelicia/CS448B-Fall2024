in this video you will learn how to create five games in Python and while doing it we will touch on all the major parts of the language we will cover classes and inheritance dund statements working with lots of files storing permanent data will even cover decorators and multiple inheritance on top of that you will also learn how to organize and manage larger projects via that you will go very quickly from a beginner to a more confident and advanced coder and you get to do all of it while shooting at skeletons in terms of requirements I do expect you to know the basics of python like using functions and different data types and you should have at least once created a class yourself if you don't know what any of that means check out my introduction to Python and if you want to take your knowledge to the next level check out this video sponsor brilliant.org they offer courses on a broad range of subjects like math data science and software development for every subject you can start from scratch or jump straight into a course either way you will will get to a competent level fast that is because all lessons are highly interactive and engage you in a HandsOn way from the start not only is this a fun way to learn it's also great at getting you to develop problem solving skills and understanding underlying principles you can access brilliant from your computer or via an app it's super accessible so instead of wasting your time on Tik Tok or Twitter you can build a powerful habit that will make you a more competent person brilliant also keeps on adding new content just recently they added a section on Python and expanded their AI courses so check it out at brilliant.org Clear code you will get a 20% discount and the first 30 days are free so not much to lose all right to get started with game development we need to go over some Basics and don't worry this won't take long in the most basic sense video games function like movies you simply draw one image after another and then you play some sound the only difference is that video games dynamically generate each image so while a movie like the first load of the Rings has 260,000 frames that never change a game like Super Mario can generate infinite frames and draw each individual one dynamically depending on things like player input and enemy movement but that's basically it usually games run at 60 frames per second and on each frame the game first checks some basic things like player input timers enemy movement or item interactions once it has that information it calculates where things need to be and once that is done it draws a frame doing this over and over again will get you a video game to implement all of that we will use py game Python's default game framework although pygame doesn't actually do that much primarily it allows you to draw images and play sounds get user input and then get and set the positions of objects there are a few more things that pame does beyond that but those are just addons to make your life a bit easier the advantage of that approach is that pame is really easy to learn we will cover all of the basics in the first game the downside is that you cannot rely on premade tools that you would expect in the game engine like gdo or Unity those are fancy parts like physics engines or network management although this isn't necessarily A downside since you are forced to build your own components you get much more practice at problem solving than a game engine user and if you want to do something else like data science or AI you can switch much more easily and those fields have better celeries and nicer work environments you really want to keep your options open because of that especially when you are getting started I would always recommend to start with a really basic tool like pame and then switch to a proper engine later on that being said if you want to jump straight into a game engine check out my introduction to good 4 anyway let's let's go a bit deeper into P game the two most important Concepts that you need to learn are surfaces and rectangles or rects in short surfaces are just images it could be an imported file or some text although it could also be an entire window basically for every pyam project you create a special surface that serves as the window this is called the display surface and on that you place other surfaces the other concept is a wct and that one is supposed to wrap around a surface and then place it in a specific position via those rectangles you also get collisions if you then add some basic input you already close to a game the one last thing that we need is to keep on drawing new frames for that we are using a simple while true Loop inside of it we get the user input and calculate where game objects need to be and from out of that we are drawing a new frame this we do over and over again until the player gets defeated or wants to quit and that is all you need for the basic Theory just two more things before we get started number one you need to install py game however if you look online you can find two versions of pame pame itself and pame C short for Community Edition the version that you want to use is pame C this one is more modern has more features and is more efficient it is also the only version that is actively worked on on the original pame is basically abandoned at this point you shouldn't use it anymore that being said pame c is backwards compatible with py game if you have that one installed and you find an old py game project you can run it just fine to install it on Windows you either open the Powershell or The Terminal and then type pip install pygame dce on Mac OS you open the terminal and type pip 3 install py game CE that brings us to the second part you will have to download some resources if you look at the video description you can find a link to a GU page with all of the project resources download those to get the graphics and the audio files there's also a Google Drive Link in which you can find the code for each chapter and the final games with that we are ready to go and the first game will be the space shooter VI that we're going to cover all the basic concepts you can find all the files in the folder space shooter and the first thing that we have to cover is how to create a basic window this part isn't going to be terribly exciting but it is going to be the starting point for basically everything else so we are going to create a window we're going to give it a custom title and we are going to fill it with a background color after we have that we can work on the finer details but first of all we have to cover some basic groundwork and there are two concepts you have to understand to get started the first one is the display surface this is the main canvas that we are going to be drawing on or in other words this will be the window for the game and inside of this window we will display everything else also we can only ever have a single display surface besides that we are going to need an event Loop which is going to check all of the events these events could be keyboard mouse or controller input or could be timers on top of that it could also be UI interactions for example if you want to press X to close a window this would also be an event so we have to capture that if we want to be able to close our game something that is really fundamental so we have to cover it right away in fact what I would recommend before you are even starting to code is to open the documentation if you go to the pame C website you can go to documentation and there you see a link to every important topic of P game along with a quick start guide and a few more tutorials being able to read this website is incredibly important to understand py game so ideally have this thing open on the site while you code along also what you can see is a quick start guide we are going to create something fairly similar in this section although it's going to be a bit simpler here I am in the code editor and inside of the project you can see the folders I talked about earlier we have a couple of images we have a couple of audio files and inside of the code folder there's nothing at the moment now for this project I only want to have a single python file that I am going to call main.py later on we will work with multiple python files but that's not an issue for now now the first thing that you have to do to use pame is to import it which you do with import pame and after you have written this line run the code and you should be seeing your pame version your sdl version and your python version if you are getting an error message at this point something went wrong with the import so check that after we have that you want to do a general setup which first of all means that we have to run pygame do init this initializes pame and is really important for everything to run properly then being said you don't have to worry about the find details that much just make sure that you are always including it after we have that we want to create a display surface that we also want to store inside of a variable now for the name very often you are seeing screen although I prefer to call it display surface because that's a bit more descriptive but both are totally fine we will need py game. display. setor mode along with a tel that defines the width and the height of this window these two numbers you usually create inside of separate variables to access them later on in my case I want to create a window whift and a window height variable I want to go with 1280 by 720 and then copy those two numbers and paste them into the tupal and with that we are creating a window if I now run the code we can see a window for a very short amount of time and that is the intended experience what is happening now is that we are importing pame we are initializing it and then we are creating a window but after that the code is ending hence everything disappears including the window because of that we can only see the window for a fraction of a second to fix that we have to make sure that this code runs for ever or at least until we want to close it intentionally which we are going to do via a while loop and for now I'm going to set this to while true that way if I add the pass in there and run the code again we can see the window forever however if I now try to close it nothing is going to happen or well the game crashes so I want to close all of this and then add just a bit more code inside of this while true Loop we have to do two things number one is the event Loop once we have that we can actually close the game besides that I want to draw the game I don't think I have to explain this part first of all though for the event Loop we can get all of the events with py game. event. getet and to access all of them we will use a for Loop for event in py game. event .g get in there we can check for keyboard input for Mouse input for timers and for UI interactions or in other words we can check if the user wants to close the game which we can check via the type of the event if event. type is equal to pame do all in uppercase letters quit that is a constant that stands for closing the game which we're going to do via another variable called called Running which by default is going to be true and then for this while loop we're going to set this to while running and if the if statement triggers we will set running to false if I now run all of this again I can close the game and we are closing everything there's no more error message so this looks pretty good although there's one thing you should always do after this while loop and that is py game. quit this method is essentially the opposite of py game. init meaning it un initializes everything so we are making sure we are closing the game properly most of the time if you forget this one it's not going to be causing too many issues but sometimes it can cause a bug or at least weird Behavior so make sure to include it and this would be the most common way for a very basic pame setup which means after that we want to draw the elements of the game and for that we always have to call one method which is called pame do display. update or flip both methods do the same thing they take all of the elements that we have run in the while loop before and then draw them on the display surface the difference between them is that update updates the entire window while for flip you can specify that you only want to update a part of the window which in most case you don't really want to do so I usually use update by default that one is a bit simpler but both are totally fine so then what can we do to draw the game and for now let's say I want to fill the window with a red color how can we do that for that you want to look at the documentation so far we only really worked inside of pame so in there we have called py game. init py game. quit besides that we have looked at py game. display and in there we had set mode which does a whole bunch of things the return value of this is going to be a surface and if you go all the way to the top there we have another section called surface so if you click on that you can see all of the methods available for surface and the one that we care about at the moment is pygame Dos surface. fill click on that and then you can call fill along with a color you could specify a few more arguments but we don't really care about that which means back inside of py game I can get rid of the comment and then get the display surface along with the fil method in there we will need a color value and the easiest way to get colors in P game is the name of a color for example Red If You Now run the code this be s a bit intense but we are getting a red color so that is working really well you could also use blue in there there are a whole bunch of colors you could be going with to get all of the available colors inside of the pame documentation you want to go to color and there if you scroll down just a bit you can see the name colors so click on that and then you get a pretty long list of all of the colors you could be using here this list is quite extensive but anyway with that we have a pretty good starting point for p game and to finish off this part Let's do an exercise I want you guys to read the documentation and change the title of the window and as a reminder here's a link to the documentation pause the video now and try to figure this one out on your own if I run the code again and if you look in the top left you can see that our window title is pame window at the moment and we also have the icon of pame the icon I am going to keep but the title we do want to change how could we do that for that you want to look at the documentation and this part is under display there we have already used set mode and if you scroll down a bit we also have set caption this one set the current window caption the user all you really have to do is call py game. display. set caption and then insert some kind of string which means back inside of the code after we are creating the display surface I want to call py game. display and then set caption for this one we are going to need some kind of string let's call this one the space shooter if I now run all of this again in the top left you can see that our title has changed to space shooter perfect so with that we have finished the first part of py game although you might have a question if you look at the documentation how could you know that changing the title of the window was inside of display and well sometimes in documentation you simply have to look around to find the right answer High game ultimately doesn't have that many components so if you know a little bit you should usually have a good idea of where stuff is that being said you can use Google quite easily for example if you look to how to change py game window title then you find a whole bunch of answers so if you click on the first one they get py game. display. set caption along with a string so should be fairly straightforward alternatively you could also use Chad GPT if you look for how to change py game window title you should be getting a pretty decent answer there you go this worked pretty well although for a bit of caution when you're using an AI tool the answers can be wrong or at least incomplete so don't expect anything great from it but for very simple questions it can be really good anyway with that we have a basic window so now we can start drawing our game the next important part is displaying graphics and by the end of this section we will display an imported image and a generic plane Rec rectangle on top of that we will also be able to move things in a very basic way although that for now will be fairly experimental now there are two ways to display graphics in pame number one you could show an image or a text via a surface and number two you could draw pixels straight away using a surface is the most common way and this is what I am going to focus on this section although later on we are also going to draw pixels straight away but for now the topic that we have to focus on is a Surface which can display an image or a text usually a surface in py game is just an image so a PNG or jpeg there are lots of supported file formats a plain area or some render text or in other words if you want to create a surface you can either create a plain surface with py game. surface and then you specify a width and a height inside of a tub besides that you can import a Sur this happens with py game. image. load and then you specify a file path to some kind of jpeg or PNG file finally if you want to have a text surface you would need a font and then you render that font if you want to antialias the text and the color that you want for the text the text for now isn't too important I'll cover that later but we will create a plane surface and import an image and create a surface that way before that though we have seen a display surface and now we are covering a regular surface and those two are called very similar for a reason because they are well very similar the important difference between them is that the display surface is the main surface that we are going to draw on it's basically the main window of the game there can only be one and it will always be visible a normal surface on the other hand is an image of some kind you can have as many as you want but they will only be visible if they are attached to the display surface and this is an another step that you have to go through but other than that the two share quite a few attributes and methods for example you can fill both with a color via the fill method the one that we have already seen to fill the background color anyway with that we have covered all of the theory let's do some coding back inside of the code editor let me run the entire thing we have a window with a blue background now I think the blue background is a bit strong let's go with dark gray instead that one looks lot better after that I want to create a surface which we can store in a variable I usually called this one surf to create a basic surface without any kind of import you want to run pygame do surface which you have to call and then insert one argument which is a tuper with a width and the height of the surface that you want to create let's say I want to create a surface with a width of 100 pixels and a height of of 200 pixels if I now run the code nothing is going to change and that is intended because this surface while it does exist needs to be attached to the display surface only then will it be visible and for that we have another method that we have to call inside of our game Loop we first of all need to Target surface which in our case is the display surface and then the method blit which stands for Block image transfer it's a fancy way of saying that you want to put one surface on another surface this method wants to have two arguments the first one is a surface that you want to put on this other surface which in our case is the surface the one we have just created and then we need a Target position this can be one of two things it can be a tuple with an X and A Y position it could also be a rectangle that we're going to cover in the next section well now though we have to specify two numbers let's go with 100 and 150 if I run the code now we can see a black rectangle inside of the window so that is definitely progress however I want you guys to think about one important thing and that is why this rectangle is in this position or in other words how do we we go from this number to this position that's a really important thing to understand for that we have to cover just a bit more Theory so here is our display surface this has a width and a height now in my case the width is 1280 and the height is 720 although you might have different numbers the specific here really don't matter though combined those two numbers are going to give us a coordinate system and the really important thing about this coordinate system is that the origin point is in the top left now if you're only familiar with high school math you probably have seen coordinate systems that look something like this where the origin point is in the bottom left so if you increase X you go to the right and if you increase y you're going up we are doing something fairly similar except that we are inverting the entire thing on the vertical axis which means if you increase X you are still going to the right however if you increase y then you are going down now this system initially can be really confusing and it does feel somewhat counterintuitive that being said most game engines work with this coordinate systems and you do get used to it quite fast so it's not too bad but anyway the one thing that you really want to remember is that the origin point is in the top left and that means that moving to the right means you are increasing X X and moving down means increasing y or if you want to go up you want to decrease Y and inside of the game we have placed a surface something like this now in this case I believe that we have moved 100 pixels to the right and then we moved 150 pixels down and then we have placed the top left of the surface at least for now we are always placing the top left of the surface but that is basically it if you understand that system you can place surfaces on the display surface so inside of the code if I run all of this again we have started from the top left this is our origin point then we moved 100 pixels to the right and then 150 pixels down and then placed this point along with the rest of this surface you can also change these numbers for example the 100 could become a 300 and if I then run the code the surface is a bit further to the right if I make this number much larger let's say 1,100 then we are going all the way to the right the same thing we can do on the vertical axis although here we do need to be a bit careful the larger this number gets the further down we go or in other words if I set this to 400 and run all of this again the surface is going down whereas if I said this to a zero then we are all the way at the top and also by the way you can make these numbers negative if I set this value to150 then the Surface starts to disappear but let's not do that this is much better also what you can do like we have done for the display surface down here you can fill the surface surface dot Bill and then you can specify a color let's say a color we have haven't used yet is orange if I run the entire thing again we get a Surface with another color and that would be the most fundamental way to display a graphic inside of P game and what we can also do at this point is to create a very basic animation the way that is going to work is at the moment we are always displaying this surface in this one particular position but that number we could change for example I could set an X position which by default is a 100 and if I then change the X position to the X variable and run out of this again we cannot see a difference however if I increase X by a certain amount and let's say by 0.1 and run all of this again now our rectangle is moving to the right not at a constant speed and this doesn't look great but at the very least we have a start and to understand what is going on here we have to go back what I talked about in the beginning to create any kind of video game you basically draw a whole bunch of frames which we are doing with a while loop this thing is being run multiple times per second and every time we are drawing it we are filling the background color with this surface and then we are drawing the surface in a certain position and since we are changing that position we are basically creating an animation by placing it in a different position on every single frame that's in the most basic sense what a video game really is and if you want to have a really interesting effect if you don't fill in the background color and run all of this again you can see that we are getting well something different what happened here is that pygame does not remove the previous image we are simply drawing on top of it so if you don't fill in the entirety of the display surface you can see the last frame which sometimes can be an interesting effect but basically always you want to avoid it it can lead to some funky Behavior so let's keep on filling the display surface and if I run out of this again we get a very basic animation with that we have a basic surface and let's rename this section to a plain surface because next up I want to create a Surface by importing an image whenever you are importing an image you are converting it right away to a surface and for now I want to go to images and then import player.png or this file and all of this we want to store in another variable let's call this one player uncore surface to import a surface we will need py game. image. load along with a file path we want to go to images and in there we have player. pnb here's our image folder and in there we have player.png now for this file path to work you need to be inside of the project folder or in other words this is the folder you need to have open inside of vs code if you only had the code folder open or you're using something like Sublime code you have to specify the file path from main.py in which case you would have to go up a folder first I'll talk about this in just a second but use every one of those two if you're getting an error in my case if I run the code now we are not getting an error message so the import has worked if you do get an error you probably have to add this bit to it anyway with that we have another surface which means when we are drawing the game we can blit the player surface instead of the surface we have seen earlier and if I now run all of this we get the players ship so that is looking really good with that we have a really basic import and there are other images you could be importing for example we have meteor PNG and we have laser. PNG although in my case I want to use player.png there are three important things you want to keep in mind when you're doing any kind of input in pame the first one is that depending on your code editor you might need a different relative path so when your code editor tries to find a file vs code always starts from the main Parent Directory which in my case is the entire project folder but Sublime a nav code editor would start from the python file itself meaning in there you have to specify that you want to go to the parent folder first and then from there you want to go to images and then to player.png let me actually demonstrate here we are back in the code and at the moment we are going to images and then to player.png and let's do all of that in the project folder right away so the file path we have specified is we are going to images and then to player.png and this is what we are importing that is working because currently inside of vs code we have this project folder open and this is our starting point however if I change this and only open the code folder so now I only have main.py and this is our starting point if I now run the code we are getting an error because there's no file player. PNG in images to actually get that we want to go uper folder and then we should be finding the file and now all of this works again so always be really careful when you are importing something via your code editor you should be aware of where the starting point is for the directory and that being said what you could also do is go to your file and then copy the absolute path that would also work but I tend to prefer relative ones just to be a bit clearer anyway in my case I always want to have the project folder open so I'm going to select this one then don't save so we are keeping open images and then player.png which is going to work just fine the next issue that we have to work on is that depending on your operating system you might need a different slash in the file path or in other words if you look at this path and this path one has a forward slash and the other has a backward slash when you go to Windows or Mac OS or Linux or some other operating system they all have some kind of preference now usually they are quite intelligent and would accept both but not all the time and you do want to be careful here so ideally all of this should be dynamic which we can do via another inbuild python method that one is called join and you want to import it all the way at the top via from os. paath import join all that this one is going to do is it takes a couple of folders or files and then joins them together with the appropriate file path for your operating system the way you would use it let me create a path via the join method in there you want to insert a couple of arguments that Define the file path so in my case I want to go to images and then to player.png and if I print that path you can see quite well what's going to happen we don't need the window and from this print path we getting images and then player.png and there you can actually see that on Windows the default slash is this one while I have used this one so ultimately my operating system is happy with either but it would be better to use this one just to be a bit more consistent so instead of using this hardcoded path you want to use the join method along with the file path if you run out of that you're getting the same outcome and your code is just a bit more robust finally there's one more thing that we want to cover and that is when you're importing an image you want to convert it to a format that pame can work with more easily that is going to increase our frame rate by quite a bit and converting is actually really easy you only really have two options after you have imported an image if the image has no transparent pixels then you want to call do convert on the surface if it does have transparent pixels then you want to call convert Alpha and then you done it's super easy to do or in other words back in the code after we have imported an image I want to call convert on it that way pyam can process this surface much more easily so we get better performance but if I run all of this we now get black stuff around the ship that is because the ship has Alpha values which means instead of convert we want to use convert Alpha if I now run out of this again we get the ship again and this looks pretty good so whenever you are importing surfaces into P game you either want to call convert or convert Alpha and then you are improving your performance substantially although if you don't do it usually it's not going to cause an error you just get a lower frame rate but anyway with that we have covered surfaces so at this point you can import a surface or you can generate a surface from scratch and and then place it on the display surface you can also move it around although this we have to refine later on which means we can finish up this part by doing an exercise I want you guys to import the star.png image and then Place 20 Stars randomly on the display surface using rent in for that should be the best way pause the video now and see how far you get I want to create a starcore surface which we can import via py game. image. and the thing that we want to import is start.png a fairly simple image to create a file path we want to use join then go to images and in there we have star.png which we also want to convert Alpha right away if I now run the code we are not getting an error message so this part has worked fairly well which means now we have to place all of these star surfaces on the display surface using a blit method now we want to place 20 of them but for now let's simply place a single one I want to call display surface dolit with the star surface and the position let's go with 300 and 500 if I now run all of this we can see a star so that's a pretty good start but I want to place 20 stars in a random position for that all the way at the top I want from random import Rand int and then use a for Loop or I in range 20 and then display surface. blit with the star surface and then I need a random X and a random y position both of which I'm going to create via random integer for the X position I want to go from zero all the way to the window Wii and for the Y position random integer from zero to the window height and with that we are getting a lot of stars in a random position but not in the way that's intended although it's a good error to talk about because what went wrong here is that we are getting a new random X and Y value on every frame of the game that way the stars are moving around at random which is looking really really bad one way around that would be after we have imported the star surface I also want to get starcore positions which we can create via a list comprehension I want to create a tupo with an X and A Y position for I in range 20 and then both X and Y are basically going to be what we have created down here so I can cut out this part and then add it here with that we are getting 20 star positions and those we are then going to use inside of this for Loop which means for position inside of the star positions and then display surface. lit with star surface and the position once we have that we are getting all of the stars always in the same position so that is looking much better we are nearly done there's just one more thing that I do want to cover and that is that the drawing order really matters at the moment we are always displaying the background color then we are drawing the ship and then we are drawing all of the stars because of that the Stars will be on top of the player which itself is on top of the dark gray background or in other words if I run display surface. fill after the ship and after the stars then we can only see the background and that should make sense we are first drawing the ship then we are drawing the stars and then we are filling the entire surface with a color as a consequence we can only see the color itself now in our case I first want to display the background then I want to display the Stars via the four Loop and then I want to show the ship so with that if I run things again now you can see the ship is on top of the Stars which looks much better and all right with that we have surfaces in this section we are going to cover placing surfaces via rectangles and rectangles in P game are incredibly important because they allow you to do a whole bunch of useful things most importantly they let you place surfaces much more elegantly besides that they can also detect collisions and they can be drawn those two things are really important but for now we are going to focus on placing surfaces and for that at the moment placing a surface kind of sucks since we are always placing the top left we don't really have much control over the placement itself or at the very least if we wanted to place it in a certain position we would have to do some math for example if this is is the display surface and we want to have a regular surface in the bottom right with pading to the right and to the bottom of 10 pixels each now for this part we could place the top left then get the entire right side subtract the width of the surface and then plus the padding that would be possible but also very annoying also sometimes we just want to place the center or the right side of the surface and be really deliberate about this positioning all of that is something that rectangles can do really well the way they are going to work is that rectangles are just well rectangles with a size and a position we could have something like this any width and height is totally fine and you can place them in literally any position now on these rectangles we have a lot of points first of all we have a whole bunch of them with an X and A Y position for example we could measure where the top left is where the top right is where the center is where the M bottom is and so on on top of that we also have X and Y positions those for example could be the left side of the rectangle the top of the rectangle the bottom we also have Center X and Center y there's also width height and size of the rectangle so we can measure how wide or tall this rectangle is what is also really important is that you can measure and change each point this makes it very easy to check if a rectangle has gone too far to the right or if you have crossed a certain point and on top of that these points always stay relative to each other meaning if you're moving one of them you're moving all of them or in other words if you're moving the bottom left point in this direction you would also move the mid left point the midtop point the top right point in this direction now before we do actual coding there are two more minor things that I want to cover number one there are two kinds of rectangles rectangles and F rectangles or floating Point rectangles those two are nearly identical the only difference is that F rectangles store data as floating Point values while rectangles use integers for example with a rectangle or to be a bit more specific an F rectangle the left side could have a value of something like 100.45 while the rectangle would truncate these values to 100 as a consequence F rectangles are a lot more precise and because of that they are used much more often in fact rectangles are basically just there for backwards compatibility nowadays for pretty much any kind of project you want to use f rectangles when we are coming to movement later on this will become especially important and truncating position values with a rectangle is actually really bad and can cause a ton of problems so we always want to use f rectangles but in older examples you do see rectangles fairly often so be aware of that besides that you can create rects in basically two different ways the first one is that you can create a rectangle entirely from scratch this would I look like this or like this depending if you have a rectangle or an F rectangle in either case you have to specify a position and a size for that you could either use two tups or four values in sequence both would be working just fine just check the documentation although this you don't actually see that often what is much more common is that you create a rectangle from a surface and then the rectangle would have the same size as that surface this you do with get wrecked or get fcked and then you can specify a point with a position that way once again you're getting a position and a size for a rectangle and this second approach is going to become really important later on because when you detect collisions you want to have a rectangle with the size of the surface but anyway with that we have all of the theory so let's do some actual coding here we are back in the project and I first of all want to stop the animation so this X Plus equal 0.1 we should get rid of and then run all of this again and there we can see we have the spaceship along with the rest of the game and that works reasonably well however imagine you wanted to place the ship in a specific position at the moment we have a random top left point I think there was 100 pixels from the left and then 150 pixels down but what if you want to place the ship right in the middle of the window or you want to place it in the bottom right with petting on each side if you always place the top left this can get a bit tricky to calculate and rectangles make all of this significantly easier so after we have imported the player surface I want to create a player uncore rectangle which we do first of all with the surface in this case player surface and then get underscore F rectangle and in there we want to specify one of the points of the rectangle that we want to place and then the actual position for example I want to place the center point of the rectangle at position 0 and zero this zero and zero would be the position on the display surface or in other words it would be in the top left with that we have a rectangle and this rectangle we can use inside of the blit method so in there instead of a tuple we can use the player rectangle if I now run the code the center of the ship is all the way in the top left alternatively I could also place the top left point and that way the top left of the ship would be in the origin point of the display surface and that example isn't terribly useful so what I actually want to do is get this center of the rectangle and then place it right in the center of the window which we can do by using window Wii and window height or in other words I want to get the window WID and divide it by two and then the window height and divide it by two as well if I now run the code disip sh is right in the middle of the window and just for one more example imagine I want to place the ship in the bottom right with padding to the right into to the bottom for that I could place the bottom right of the ship the Tuple for that is going to be window width minus 10 and then window height minus 10 as well if I now run all of this we can see the ship is in the bottom right or in other words with this system we can place the ship super easily in a lot of positions although let's start by placing the ship in the center of the window I think that's a bit better like so now what you can also do is update individual points of this rectangle that way you would update all of them for example what we could do is to move this ship again we could pick the player rectangle and then the left side and remember what I talked about earlier inside of a rectangle we have two PS and integers or well for an F rectangle those would be floating Point values but when I place the top left or the center or the bottom right I always have to specify an X and A Y position but when I'm specifying the left side or the right side I only ever have to specify a single position because those only represent a single value like we are doing inside of player right left we could for example set to 100 that way our ship is now going to be much further to the left if I change this value to 150 we're going a bit further to the right and once again I can make all of this Dynamic and increase this value by 0.1 if I now run all of this the ship is moving to the right and this is also the part where floating Point rectangles become incredibly important because if you have a normal rectangle so at the moment we using get F rectangle to create a floating Point rectangle if we used get rectangle and run out of this again the ship isn't going to move at all that happens because the rectangle around the ship at the moment looks something like this and the left side has a value of let's say 600 and really important this is an integer meaning anything after the dot will simply be ignored and well what we are doing at the moment is adding plus 0.1 to it which means after one frame we are getting to 600.1 but since this rectangle always trunk gets the position value this point one will be removed entirely hence we are not moving that being said if you change this value to one then we should be seeing some movement and we do but this isn't what I actually want to do so let's keep this at 0.1 and then use a floating Point rectangle for basically any project nowadays I am using floating Point rectangles they are simply better although I guess we could make this just a bit faster but anyway this is basically what you need to get started with rectangles they don't really get that much more complicated I suppose one more thing that we could be doing is that at the moment we have used the rectangle and its values to move a surface what you can also do is measure these points but for example what you could be doing is print layer rectangle do right that way if I run all of this again you can see the right side of the player which by itself isn't terribly useful but for example you could be using this if I cut it out inside of an if statement that I only want to move the player to the right if player rec. right is smaller than the window Wii if I now run all of this again then we are moving to the right but at some point we are stopping so this is working really well and those are the two ways you're using rectangles to move stuff in P game you either measure a point or you move a point and after you have that you're using the blit method with a surface and a rectangle and then you are getting some movement remember in a video game any kind of movement is simply drawing a graphic in a different position and that you slowly update over time that's all you ever do which means we just have to do an exercise and then we are done with this part I want you guys to do three things number one import the meteor and place it in the center of the window and obviously for that use a rectangle besides that import a laser graphic and place it in the bottom left with 20 pixels of padding to the left and to the bottom and finally make the player graphic Bounce from the left to the right continuously that should be quite a bit so pause the video now now and see how far you get number one I want to import a meteor graphic and place it right in the center of the window for that first of all we have to import meteor PNG that we can do under importing an image and I guess by now this should simply be called Imports in there I want to create a meteor uncore surface which we do with pame do image. load then using the join method I want to go to images and then import metor PNG also really important never forget convert Alpha after we have that I want to create a meteor underscore rectangle where we have the meteor surface and then use get F rectangle where I want to place the center the position for this has to be a tupal with an X and A Y value X is going to be window not height but width divided by two and Y is going to be window height divided by two that is going to give us a surface and a rectangle so now inside of the game Loop let's do it on top of the ship I want to call display surface. blit again with the meteor surface and the meteor rectangle let's run all of this and we have a meteor right in the middle of the window so that is looking pretty good although I suppose we should draw all of this before the player I think it's better if the player always on top of everything else next up we want to place the laser in the bottom left with 20 pixels of padding for that we will need a laser unor surface with pame do image. load using the join method I want to go to images and then import laser. PNG and just a double check we are importing this laser. PNG and also as always convert Alpha after we have that we want to create a laser rectangle with the laser surface and then get F rectangle and since I want to place this one in the bottom left I want to place the bottom left point and for that I will need an X and A Y position and now let's think about it with we have the entire window looking something like this and we want to place the laser in this bottom left point which means from the left side we want to have an offset of 20 pixels oh and also we are placing this point which means for X we only want to go 20 pixels to the right but then for y we want to go all the way down to the bottom of the window and subtract 20 pixels from that that way we are getting to this point and if I could draw a straight line this would be much better visually but you get the idea so for X we want to have 20 and for y we want to get the window height and subtract 20 from that now running all of this again we don't see anything because we are not calling the blit method once again let's do it before the player display surface dot lit with the laser surface and the laser rectangle next attempt and there we go in the bottom left we now have a laser that is making some progress and I think at this point you might become a little bit uncomfortable because we are importing a surface four times and we basically copy the same method four times which really isn't efficient also when we are displaying all of the graphics we using the same line three times with different arguments which also isn't great and don't worry later on we're going to make Auto of this much more efficient so that we can import hundreds of graphics with just one function we wouldn't have to write every single line by hand because that's just not a convenient way of working also later on we are going to learn about better ways of displaying multiple Graphics so with all of that there's just one more thing to do and that is move the player left and right and for that let's organize all of this a bit better so we are moving the player with these two lines move them a bit down and then at comment we have the player movement and essentially how we are going to approach this when we are creating the player we can add a player uncore Direction which by default is going to be one and then when we are moving the player we are getting the player rectangle and then use one of the points we could go with X here that's simply the left side those two values are identical and then increase this by the player Direction multiply it with the speed which in our case is going to be 0 point let's say four and then we don't need this if statement for bit if I now run all of this again the player is moving to the right however if I set this value to a negative one and run the entire thing again the player is moving left so that is working really well which means inside of this if statement we want to check if the player is outside of the window which means player. rec. right is greater than the window wift or player w. left is smaller than zero or the left side of the window if either of those conditions are met then we want to change player Direction and multiply it with 1 if I now run all of this again we are bouncing left and right that is working really well so very happy with that and at this point we have covered the basics of rectangles now I guess there's one thing that I haven't covered and that is you can create rectangles from scratch entirely so for another comment a rectangle if you want to create a plain rectangle you simply would call py game. F rectangle this could also be py. rectangle if you want to have a normal rectangle Ang Le which we basically never want to do and inside of there you have to specify two two builds one for the position and another for the size this would be one way alternatively you could also specify the left the top the WID and the he both approaches are totally fine and at the end you are getting a rectangle that being said for our purposes at the moment this isn't particularly useful because we have no reason to create a rectangle like this but for now don't worry too much about it and for the last bit before we finish if you look at the documentation there you have rectangles and this is going to give you a long list of methods that you could apply to a rectangle if you go a bit further down you can see all of the points that I have talked about earlier the two that I haven't mentioned are X and Y which are simply left and top so if you want to know more about them just keep on reading all of this I will talk about it later as well and we are going to use rectangles a lot so this part of the documentation is going to be something you definitely want to be familiar with for example in there we have all of the Collision methods which are going to be super useful for a game just one more minor thing before we are finishing all of this when we are placing a surface via a rectangle what we actually do is placing the top left of the surface in the top left of the rectangle or in other words it doesn't matter if you use player rectangle or player rectangle dot top left the end result is going to be the same also while we are here the size of the rectangle does not need to match with the size of the surface for example what we could be doing the loaded player I can create another plain rectangle and then aign py game. F wrecked with a position of let's say and2 200 and then for the width and height I can use entirely random values let's say 200 and 620 if I now use this rectangle to position the player with the blit method and the rectangle we can still place the player in a certain position even though the rectangle is going to be much larger so while the player would occupy this space the rectangle would I think be something like this but as far as blit is concerned this doesn't matter because we are always placing wrecked dot top left although obviously this isn't what I want to do and generally it is a good idea to have a rectangle and a surface with the same size especially when it comes to collisions this will become really important although you don't necessarily have to do it but anyway I want to get rid of the rectangle and then we are done with this part with surfaces and rectangles covered we can work on moving stuff in much more detail we already have some movement but it's fairly crude and we can refine things a lot although for all of that we are going to need some Theory the general idea of how movement Works in literally any video game is that you are blitting a surface in a different position on every single frame so for example we can slowly draw the players ship further to the right and if these changes are gradual enough and we have a high enough range frame rate then your brain will think this is movement that is literally it so in pame when you are blitting a surface you can either change the XY tupal or the rectangle position that is literally it although fundamentally we are still just drawing a surface in a different position and that I can visualize quite well back inside of main. Pi we still have the ship moving left and right with a couple of other elements and what I want to do is add one more thing in the general setup I want to add a clock and the value for this is going to be py game. time. clock a clock object in pame is incredibly useful for two reasons number one it can control the frame rate at the moment our frame rate is simply this while loop or in other words if your computer can run this while loop 10,000 time a second then your frame rate is going to be 10,000 time a second depending on your computer this might be faster or slower and we do want to have some control over this which we can do via the clock object the way you would do that is inside this wire Loop doesn't really matter where you put it I prefer to do it right in the beginning you can call clock dot pick and then enter an integer which is going to give you the frame rate of the game if you leave it empty you are going to get the maximum possible frame rate whatever words the speed of your computer determines the frame rate which is generally what you want that way you get the most amount of frames but if you change this to a 60 and run all of this again now our ship is moving significantly slower and you can also see that the movement is quite a bit more choppy although this might be difficult to see on YouTube to make all of this more visible let me change the frame rate to one that way we're getting one frame per second and also while we doing this when we are moving the player I want to increase this number by a lot let's say 100 if I now run all of this again you can see how movement actually works we have the player and we are simply drawing it in a different position and that is literally it if you lower the frame rate far enough then movement is going to look very very static and you can already tell if I change the frame rate back to something very small let's say four then we are getting something that looks a lot more like movement and if I change it to 24 is usually the lowest frame rate that we perceive as motion although still not looking great but I hope you get the idea the fundamental thing that you have to understand for movement is that we are drawing a frame and on every single frame we are changing the player position a little bit and then for some reason the human brain doesn't see a lot of images the human brain sees movement that is fundamentally all we are doing that being said we can refine all of this in two important ways number one we want to use vectors to store a direction that way we can control the movement much better on top of that we want to include Delta time to make the movement frame rate independent so two important words here that we have to cover we are going to learn about vectors and we're going to learn about delta type let me talk about why those two are important first of all inside of the game via these three lines of code we are moving the player left and right which I don't actually want to do anymore so let me get rid of the if statement and also change this part I only want to move the player in One Direction let's say to the right by 100 pixels on every single frame if I do that the player moves a little bit too fast let's say I want to change this to 20 and then the frame rate so clock. tick should be 10 if we note all of this again you can see the player is moving to the right however what if I wanted to move the player to the right and up at the same time for that we would need two lines of code player. r.x + 20 and player w.y minus equal let's say 10 if I now run all of this again we get the player is moving up and right so that part is working but it's also kind of annoying because for a very simple thing we need two lines of code ideally what I would prefer is player wct Dot Center plus equal 20 and 10 that would be much easier and by the way what is happening here is that we are grabbing one of the twole points inside of the rectangle Center has an X and A Y position and we want to update both of them at the same time that however we cannot do at the moment if I run the code we are getting an error message that we have an invalid wrecked assignment on this line you simply cannot add a tuple or a list to a tuple position inside of a rectangle for that you are going to need a vector that's the first thing we are going to work on the second issue is going to to be frame rate Independence and you have already kind of seen the issue at the moment our frame rate is 10 and that is going to give us one kind of speed so our player moves at this speed but if I change the frame rate to 100 then our player moves significantly faster which is fine if we have a stable frame rate but later on we want to have a flexible frame rate meaning the game could run faster or slower on different computers and this we have to account for in the movement so that a player with a faster computer doesn't get much faster movement but anyway let's start with the movement I want to make sure that we can control the player Direction much better and for that we're going to look at vectors A Vector in P game and well basically anywhere else is a list with two values they are always going to be X and Y and you can only ever have two values at least in a 2d Vector there are also 3D and 4D vectors but in our case we are only ever working in a 2d space so our vectors will only ever have an X and A Y value those values you can read and change for example what you could be doing is create a vector with X being one and Y being five you could read the first part so x with indexing although nobody really does that what you rather see is that use vector. x and Vector doy and Via those you can get the value and you can update the value so with that we basically have a list that is constrained to two values so far this isn't exactly useful however via vectors we can do Vector math which is incredibly powerful if you multiply a vector by a number then you multiply both numbers inside of that Vector if you were to do all of that to a list you would simply duplicate all of the values so the difference here is quite noticeable we're going to do this in practice in just a second also you can add two vectors to together and then you get the sum of the individual numbers and finally what is really important to us is that you can add a vector to the Tuple position of a rectangle that way we can change both X and Y at the same time that was quite a bit so let's write some actual code first of all inside of the player Direction at the moment we only have netive 1 but I want to create a pame do math. Vector 2 and notice here there's also a vector three this one would have three values X Y and Z but this we don't really need so in our case we have a vector 2 with X and Y if you leave these values empty you're going to get a vector with 0 and zero which means if I leave it like this and then print the player direction we are getting an output of 0 and 0 although in my case I want to have 24x and 10 for y we also don't need the print statement anymore and now if we go to these lines at the moment we are updating X and Y of the player rectangle individually but that we don't need anymore instead I want to get player W do Center plus equal the player Direction and now this is going to work although it's a bit fast let's change the frame rate back to p so we can see what's going on and now the player is moving to the top right and later on we can refine all of this to make it even more useful but this is something that you see really often that you take the two pit position of a rectangle and then add a vector to it to update it also what you could be doing so by default the values of the vector are 20 and 10 however we could print layer Direction multiply it by two and then run the entire thing now as an output we're getting 40 and 20 the way you would be using this in an actual game is for the player direction we want to have fairly low values because that way we can define a player underscore speed which for now could be let's say 10 and then when we are updating the movement we are increasing the value by the player Direction multiplied with the player speed the result is going to be what we had before via this system you can separate the player Direction and the player speed so for example the player direction we can get simply via player input something we haven't done yet but that's going to be the next section actually oh and just for reference if you wanted to multiply a list let's say we have a list with 1 two and three and we are multiplying all of this with two if I run the code our output is going to be a list where every single value was duplicated or in other words math for vectors and math for a list is completely different those two just aren't comparable but anyway with that we have vectors something that you definitely want to use in P game they are super useful so the next issue that we have to work on is frame rate Independence and ultimately the issue we have here is that depending on the computer that the game is run on you might get wildly different frame rates and since we update the position on every new frame of the game the faster the game runs the faster the movement is going to be which isn't ideal you want a movement to always be the same regardless of the computer which we have to guarantee imagine you have two players one with a really fast computer and one with a really slow one the one with the better computer might run the game 10 times as fast If this means that all the movement in the game is 10 times as fast it just wouldn't be controllable anymore and let me visualize all of this a bit better using math so we have a table with three columns the first one is going to be the movement and we always try to move by 10 pixels this value doesn't change and also let me do all of this in the game right away for our player Direction I want a player to only move to the right so X is going to be one and Y is going to be zero hence we're not moving up or down and then the player speed is going to be 10 the value you have just seen in the table if we now go to this line the player should only move to the right let's try and there we go the player is moving to the right but depending on the frame rate this value might change so if we have a frame rate of 30 we're moving a bit faster if we're getting to a value of 60 we're moving quite a bit faster and if we get to 120 we're moving a lot faster and those numbers we have in the table the frames that we are setting in clock. tick is this frames per second it could be 30 it could be 60 it could be 120 it could also be something like a thousand since we only make 2D games the frame rate can actually become quite large something you definitely want to control for and finally the really big issue is this final column in which we are calculating the actual movement which is simply the movement multiplied by the frame rate and from that you can tell that we are getting wildly different movement speeds these numbers have to remain the same because inside of the code we are specifying the same speed so getting from this to a very different actual speed in the game simply isn't acceptable and to fix all of that we will need Delta time which is the time it taks your computer to render one frame for example if our frame rate is 60 frames per second then we can divide 1 second by 60 so it takes our computer 0.017 seconds to render one frame that value we can actually get from this clock object it's simply the return value so in there we can get DT short for Delta time and after that I can print Delta time and run the code and now you get in the bottom we have a Delta time of 8 or 9 that is because our frame rate is 120 or in other words the values we getting down here are 1 / 120 and this number can fluctuate a bit hence we're getting either eight or n but if you do the actual Cal calculation the value would be 0.83 and I should mention that this calculation is in seconds but the return value from clock. tick is in milliseconds hence we're getting 809 here and 0.008 in here if we change this value to a 30 and run all of this again then we're getting 33 or 34 and I guess from the slides the value we have used was 60 frames per second and if I run this we're getting 16 or 17 milliseconds also if I leave this value empty and we let the game run as fast as possible in that case our Delta time is going to be zero or one which indicates that we're getting a frame rate of about a th000 frames per second or even more that's something we can actually measure after clock. tick we can get clock and then get FPS and don't forget to call this one if I now Run the game we can see our frame rate and if we don't limit it in my case the frame rate is somewhere between 1,000 and 1,250 although keep in mind in your case these numbers might be different and that is totally fine what is really important to understand for now is that Delta time for every computer can be different and we are simply measuring the difference in time between the current frame and the last frame or other words how long it takes your computer to render one frame and that information is incredibly useful to understand why let's have a look at another table the first three columns is what we have seen already in there we have a movement we have a frame rate and then we get the actual movement and these numbers being different is the actual problem so what we want is that all of these values are the same and for that we can use Delta time which is the time it takes to render one frame so for example if our frame rate is 120 our Delta time would be 0.08 if it's 60 we get 17 milliseconds if it's 30 we get 33 milliseconds if it was a th000 we would do 1 over a th000 so this value would be 0.001 and that information is incredibly useful because that way we can do this calculation where we have the ual movement the frame rate and then Delta time if you add all of them together you are getting always the same movement regardless of the frame rate and the logic here should actually make a ton of sense all that we are doing is we are multiplying the frame rate with Delta time which essentially cancel each other out the value of these two combined is basically always one or in other words simply look at the frame rate and deltae time for example for 60 frames per second we get 60 and we are multiplying it with 1 over 60 the number we are getting here and those two numbers simply cancel each other out the end result is going to be one as a consequence the only thing that's really left is the actual movement that we care about and with that we can control for the frame rate let's implement it inside of the code we are already getting Delta time but this this at the moment is in milliseconds which is a bit awkward to use so I want to convert it to seconds which we can do by dividing it by a th and after that all that we really have to do to move the player is we want to get the player Direction multiply it with the player speed and then multiply it with Delta time if I run all of this we get some kind of movement at the moment this is really slow so let's change the player speed to let's say 100 that way this feels a lot better actually this could be 300 let's try this again and yeah that feels better cool so with that we have the player speed and we get some kind of movement what is really important now is that this is independent of the frame rate which means if I change this value to a 10 and run all of this again we are getting the same speed although a lot fewer frames but that's expected because our frame rate is much lower although and this is the important part the actual speed of the ship has not changed we simply draw it less often and that is it with that we have covered Delta time and most importantly we have this line which is the standard to move anything in pi game where you have the two bit position of a rectangle and to it you add the direction via a vector multiply it with a speed and multiply all of this with Delta time via all of this we can move things very easily and we can move it independently of the frame rate finally then before we are finishing this section let's do another exercise I want you guys to make the players ship bounce around the window like an old DVD logo the end result should look something like this also in case you don't know what the DVD is here's a Wikipedia entry I have away pause the video now and see how far you get back in the game I want to start with the player Direction I think by default this one should be one and one that way if I run out of this again the player moves to the bottom right also the frame rate should be unlimited so the movement looks a bit nicer that feels better so now once the player touches this point we want to move the player in this direction for that before we are doing the actual player movement I want to check if ler rectangle dot bottom is greater than the window he if that is the case I want to get the player Direction and then change the Y part and all I really want to do is multiply it with 1 that way if we run the entire thing again we are bouncing up besides that we also want to check if player rectangle do right is greater than the window width if that is the case we want to get the player Direction Al now we want to get player Direction dox and then multiply it with negative1 and now we are bouncing and then disappearing at the top so that part is looking pretty good next up once the play hits the top of the window we want to bounce down again that we can do inside of this if statement we simply want to add another part if player re top is smaller than zero if that is the case let's try this part we are bouncing down and at the bottom we are bouncing up again so only one more site to cover and that is going to be the second condition for the second if statement if layer w. left is smaller than zero and with that we are bouncing around quite well so with that we have movement that is much more robust next up we can work on the input I've made a mistake and you might have already noticed so sometimes we have the ship and the ship bounces around this screen something like this but some of the time the ship gets stuck on one of the walls so for example if we have a bottom Collision then the ship gets stuck here and Wobbles back and forth if we increase the speed of the ship to let's say 1,000 if we now Run the game there you could already see some weird Behavior it doesn't happen all the time but it could be an issue so essentially What's Happening Here is we have a ship moving like this and then once we hit a wall we are bouncing off these few lines here however there is a potential for a buck for example if the right side of the ship goes too far to the right so much further than the window whift let's say we are here we are still trying to move in this direction however when we are checking all of this again the ship is still too far to the right and as a consequence the direction of the ship will go this way and this is going to continue forever then we are basically stuck to this wall until we get lucky on the ship accidentally gets a bit further to the left now one way to start working on this is to add greater than or equal to this point or smaller than or equal to that would do a bit but it wouldn't fix the issue entirely now for this part since we are going to change these lines later on anyway I am not going to worry too much about it but what you would have to do if you're bothered by it you would need a separate if statement for each side for example if player wrecked do bottom is greater or equal than the window height if that is the case we want to set the player wck do bottom to the window height and then we also want to set the player Direction doy to 1 that way we are making sure that the player never exceeds the bottom of the window and later on when it comes to the pong game we are going to implement that logic although for now I'm not going to worry too much about it anyway this is going to cover the movement so let's work on the input although one more quick thing before we get to that if you look at the documentation there is no Vector entry instead what you would have to do is go to py game. math and in there we have a vector 2 and a vector 3 along with a whole bunch of additional information essentially when you are creating a vector in pame you can either write py game. math. Vector 2 or use the short hand with py game. Vector 2 both would get you the exact same result the last really major thing that we are going to need for a game is getting user input and for this part we're going to cover Mouse input and keyboard input by the end of the section we will be able to move the player around freely on the window either with the mouse or with the keyboard now getting input in pame can be done via two ways and one we have already seen that is the event Loop we already use this one to close the game and in there we could also get keyboard input and mouse input the one limitation here is that we can only ever have a single event Loop so if you have a complex game this part is going to get really messy the alternative to it would be pame dokey and py game. mouse those can also get the keyboard and the mouse in put and they are quite a bit more flexible they can be called anywhere in the code which makes them super useful to use in classes but other than that those two are fairly similar they both let you capture user input but there are some minor differences and I'll talk about them later now you might be wondering which one should you choose for input and well in my case I basically always use py game. key or py game. Mouse for a couple of reasons most importantly they are much easier to integrate with classes something that we are going to talk about in the next section but since you can call them anywhere in the code it makes them really easy to use and on top of that they can check if a button is being pressed continuously and I'm going to demonstrate this in the code in just a second but when you're using the event Loop you are checking the action of a button being pressed you are not checking if a button is being pressed so on practice if you you're holding down a button and then use the event Loop to capture the input you are only getting a single input whereas if you use py game. key and you check for the button press you would get continuous input if you want to move something around on the screen the second part is just better however it is totally valid to get input via the event Loop and sometimes that part is even necessary for example if you want to get touch input or the mouse wheel then you will have to use the event Loop and generally there's nothing wrong with using it just keep in mind that you would have to structure your game around it but other than that this part shouldn't be too difficult let's Jump Right In once again here we are in the code and the part that captures input already is this event loop at the moment we are checking if the event type is py game. quit I.E we are closing the window but you could check for quite a few more things and you would always use event. type for example in there we have pygame do e down if that is the case I can for example print key down if I now run the code I can press any button on the keyboard and we are getting key down so that part is working but it's not terribly useful to get a bit more information we can get event. key with that we are getting a value associated with every single key on the keyboard now this is always going to be an integer so at the moment this isn't particularly useful that being said for all of these values pyam has a constant to check what key we actually have the way you would use that is you would check if the event key is equal to pame and then Kore whatever key you are looking for there are quite a few options for example we could start with K1 order number one on your keyboard if I run the code now and I press any key we always get false but if I press one we are getting true so I know I am pressing this key or in other words what you could be doing is let me cut this part out and then we want to check if there's a key down event and if the event key is equal to py game. K1 if that is the case we want to print one so now I can run this again and if I press one we're getting one if I press anything else nothing is going to happen and that is the basics on how you can get keyboard input inside of the event Loop let's have a look at the documentation you want to look at event if you click on that you can get all of the event methods the one that we have already used is py game. event. get and that is by far the most most important one if you scroll down a bit you can see all of the main events that you could be looking for in there we have already used quit and we have used key down there's also key up there's Mouse motion Mouse button up and mouse button down those five are the ones that you are probably going to use the most and if you then look on the right you can see a few more parts that you could be using for example what key we are pressing and if there's a modifier or when it comes to Mouse motion we have the position and the buttons and that's basically all that you need to know about it but let's do all of this in code at the moment we only have keyboard input I also want to get mouse input for that I want to check if the event. type is equal to pame dot let's start with mouse motion this is going to trigger as soon as we have any kind of mouse movement so basically all the time let's for now print Mouse is moving for this part let me show my mouse and if I now Run the game I can move the mouse and we get mouse is moving as soon as I am moving the mouse once again this isn't terribly useful but what you could be doing here is print event. position that way we always get the position of this event which has to be the mouse position let's try and now you can see my mouse position in real time if we go all the way to the top left we are getting 0 and zero and all the way in the bottom right we getting nearly 1280 by 720 and that is working pretty well and while we have that we can also get rid of this player Movement we also don't need to comment anymore and then do something like as soon as we have Mouse input I want to get the player rectangle and place the center to the event position I can now run the entire thing again and the ship is following the mouse that part is super easy and that is basically it with that we have keyboard and mouse input via the event Loop a pretty solid start but I wouldn't recommend using it hence I'm going to comment out all of this instead before we are drawing all of the game I want to do something else and that is going to be the input outside of the event Loop and that we can do via pame dokey or py game. mouse let's start with the mouse one this one is a bit easier to use so this mouse is an object and on there we can get the cursor get Focus get position get pressed get relative and so on the one I care about right now is get the position if you're calling this one you are getting the most position wherever you are calling this method so let's print it run the game and now I can once again track my mouse position and this has worked just as before so quite happy besides that we can also get rest which is going to give you the mouse buttons that are being pressed if I run this one we're getting a tuple with three values and if I press the left Mouse button we're getting true false false if I press the right Mouse button we get false false true and if I press the middle Mouse button so the mouse wheel we're getting faults through faults if I press all three at the same time we're getting three True Values and that's kind of it we basically have continuous input and then we are checking which buttons are being pressed if they are being pressed they are returning true to get one individual value you can simply use indexing for example if you want to check the left most button this would be index zero if I run this again I can check if the mouse button is pressed or not pressed the last Mouse input that you see fairly often is get relative this is giving you the relative Mouse speed and to explain how this one is going to work let's run the game right now once the game is running we're getting an output of zero and zero and this is effectively the mouse speed if I move the mouse around we're getting some values in here but if I stop moving this value goes back to zero and zero so effectively this is checking if the mouse is moving and how fast it is moving but that's basically all you need for the mouse input let me comment it out so we're not pring too much and next up we can work with pame do key dot get focused get just pressed get just released and get pressed those are the really important ones and get pressed is the one you basically always want to use that being said if I print the output we're getting way too much so in the game you are getting a giant list with all of the potential Keys being pressed like with the mouse buttons being pressed we're getting a list with all of the potential keys that could be pressed and if they're not pressed we're getting false if they are pressed we're getting true the problem for the keyboard is that we have a lot of value use so this isn't exactly feasible now the way you are supposed to use this is you should be storing the return value inside of a variable let's call it Keys you can use indexing on this and then use the Constance that you have seen inside of the event Loop for example I could use in here pame and kore1 if that is the case I want to print one and also this should be an if statement if I now run all of this again I can press one and we're getting an output of one if I press anything else nothing is going to happen so that is basically how you would get input via the keyboard outside of the event Loop and now I can talk about one important difference between the input from the event Loop and the input from the other methods when we getting the one being pressed from this part we're getting an output of one continuously as long as I'm holding down the key to demonstrate let me run all of this again I can press one hold it down and we get an infinite number of ones however if I comment out all of this and then uncomment this if statement I can run all of this again and now if I press one and hold it down we are only ever getting a single output or in other words the event Loop is checking the action of a button being pressed whereas P game. key. get pressed checks if a button is being pressed or not the difference is quite minor but really important to understand although if you do understand it then it should be fairly easy to use keyboard input so let me comment out the if statement inside of the event Loop and then move the player rectangle via keyboard input for that we already have a player Direction which by default should be zero and zero and since those are the default values I can leave this value empty entirely also the speed should be let's say 300 now the way we are going to use input is by changing the player direction or in other words I want to check for the keys and then check for kcore right for example and once I have that it's going to be player direction dox will be one and then to apply all of this we want to get the player rectangle Dot Center plus equal player Direction multiplied with player speed multiplied with Delta time if I now run all of this and I press right the player is moving to the right although he never stops moving moving to the right and that should make sense once we are pressing right once we always have this direction there's no way to return to a play Direction X being zero although for that we could add an else statement in which we are setting the player Direction dox back to zero that way I can move the player to the right only if I have actual input so that is working really well but we have a whole bunch of lines for something that should be really simple Le though this is kind of Overkill what is a much more elegant way of solving this is we can set the player direction dox to an integer of keys and pame do right the output would be exactly the same so I can run all of this and the player is still going to move to the right now the reason why this is working is because we have a Boolean value which can either be true or false and if we then use the in method true is going to become one and false is going to become zero and this is the value we actually add to player direction. X and what you can also do is copy all of this and then subtract pame do Kore left if I now Run the game again I can move left and right totally fine and I hope the logic for this one makes sense I guess it would be a good idea here to do some examples imagine K right is being pressed and K left is not being pressed as an output we would then get a value of one from right and zero from left and 1 minus 0 is going to be 1 meaning we're moving to the right if we have K right not being pressed and K left being pressed then we're getting an output of 0 and 1 and 0 1 is 1 hence we are going left finally if both are being pressed then we are getting one minus one which is going to be zero so no movement at all and well with that we have very basic player input this line I want to duplicate and then get player Direction dot y for this we can check pame dok down minus pame do K up if I now run all of this I can move the player around in every possible Direction so this is working really well perfect we are nearly done there's just one more thing that I really have to cover and that is at the moment the speed of the player is inconsistent which you might find weird because we only have a single player speed the one that we are setting up here however if you run the game and if you only move left or right and up or down you're getting one speed but if you move diagonally all of a sudden you are moving quite a bit faster and this I can actually demonstrate a bit better I want to print the player Direction multiplied with the player speed this value is going to be a vector and on every single Vector we can get a magnitude which is the length of the vector which in this case would be the distance the player is moving on every single frame and in theory this number should always be the same but if we are trying this I can move left right up or down and we're getting 300 but if I move diagonally all of a sudden we're getting 424 or a much faster speed and if you think about it for a second it should make sense if we only move in one direction we're getting one of these inputs I.E we are moving 300 pixels to the right to the left up or down however if we get two inputs at the same time then we are moving to the right by 300 pixels and we're moving up by 300 pixels which means the actual distance being traveled is this line which is going to be much more than 300 in our case it's going to be 424 so this number we have to account for and to way you would do that is by changing the player Direction this one can only have a value of zero and one for example if we are only moving to the right then the value for this one would be one and zero however if we moved to the right and down then this value would be one and one for x and y and because of these two ones we are getting a much greater movement so what we have to figure out is that when we're moving to the right we have a direction of one or rather the length of player Direction when we only moving to the right is going to be one if we moving to the right and down I.E we have this and this then the length of the vector will be greater than one and to fix that we have to change the length of this line and this line so that the actual distance traveled is also going to be a one and that part is actually really easy because there is an inbuilt method for that this process of converting the length of a vector to a one is called normalizing a vector and basically all that's happening is you are changing these numbers so that the overall length of the vector is one with the number staying proportional the way you would do that before we are actually moving the player I want to update player Direction and set it to player direction do normal now if you're running the code at the moment this is going to give us an error that we cannot normalize a vector of length zero we are trying to change the length of a vector to one while keeping X and Y proportional but if both X and Y of a vector are zero then this isn't possible High game simply doesn't know in which direction we want to go hence it cannot normalize the length of the vector to one and this is exactly the error we are getting here fortunately the way around that is fairly simple we only want to do that if layer direction is different from zero and inside of an if statement any Vector on P game is going to be faly if the values are zero and zero if you have any other value then it's going to be truthy which means else we simply want to keep the player Direction and with that I can run all of this again and now no matter and what direction I am going in the speed of the player is always going to be 300 I guess unless I stop moving but you get the idea and to actually see what happened let me only print the player Direction with that we are getting an X and A Y value and if I move left or right this is going to be one or negative 1 or 1 or negative 1 for X and Y however if I move diagonally we are getting 0.7 and 0.7 those numbers are changed because of normalization and with these two numbers the length of the direction is going to be one so I hope that part wasn't too complicated basically if you want to have very simple keyboard input you would use these three lines and then actually move a rectangle via this fourth line now before we continue let's have another look at the documentation and there we have py game. key and py game. mouse inside of key you can get all of the methods and there are quite a few the one we have used so far is get pressed there's also get just pressed and get just released you could get a few more but they aren't too important and besides that inside of mouse we have get pressed get position get relative you could also set the position you can make the mouse invisible or get if the mouse is visible and so on the most important methods in here are get position and get pressed and to practice all of that let's do an exercise I want you guys to capture the input for the space bar if this one is pressed print fire laser on top of that use the keyboard input to trigger it only once and for that do not use the event Loop you should figure this one out via py game. key meaning you will have to read the documentation at least a little bit pause the video now and see how far you get back inside of the code I want to check let's do it after the player movement if keys and high game. Kore space if that is the case I want to print fire or fire laser I think I called it doesn't really matter what you do in here if I can I run the code I can press space and we're getting fire laser the issue is we're getting this fire laser on every single frame of the game which at the moment is a th times per second which really really isn't ideal I want to make sure if the player is pressing this button we are only triggering fire laser once and for that let's have a look at the documentation I want to look at pygame dokey and in there first of all the one list you should be familiar with is this one here it contains all of the keyboard constants besides that we have get pressed and get just pressed the difference between these two is that get pressed checks for buttons constantly whereas get just pressed is only getting the most recent key presses other than that they work in basically the same way which means I can get the recent key Keys via pame dokey. getet just rest and if I then use all of those keys with the same constant I can run this again and if I now press space and hold it we are only getting fire laser once although I can press it again and once again we are only getting it once on every press of the key so that is looking pretty good and the other input is still working just fine so that is all working pretty well that being said this logic still isn't ideal because if I run the game again and I press space really quickly we are still getting a lot of fire laser so in an actual game the player would be able to shoot way too many lasers and for that we are going to implement a timer later on I think for now it's not too important the actually important part for now is that you can get keyboard input Mouse input either via dedicated methods or via the event Loop if you can do that you can get keyboard input in P game in this part we are going to cover Sprites which are not going to change the game so by the end of the section the game is still going to look like this however we're going to organize everything significantly better and that is all that Sprites are doing it doesn't sound like a lot but once the game becomes even a bit more complex you basically cannot do it without Sprites let's talk about it basically for any project you want to be using classes and by the way if you don't have that much experience with them check out my introduction to python this one covers classes in a lot more detail at this point I will assume that you know classes at least reasonably well now in our case the code is already becoming messy for the player we have a surface a rectangle some code for the movement and some code for firing so quite a few lines even though the player doesn't actually do that much it simply moves around and then PR Sprints when we are pressing fire if the player was able to do more and we had other objects the code would become incredibly messy really fast so we have to organize all of this a lot better using classes and for that we can use a Sprite Which is the best way to use classes in pame not the only one though but it's essentially the default basically a pame Sprite is an inbuilt class that always contains a surface and a rectangle and that is literally it it's just a class with a surface and a rectangle and then you can add anything else that you need or in other words for sprite we have a pygame class called py game. sprite. Sprite and from this class we are going to inherit after we doing that we have to overwrite self. image which contains the surface and self. rectangle which contains the rectangle only then is the class going to work properly let's try off this in practice here we we are back in the code and I want to create a class all the way in the top this one is going to be the player and for inheritance we need parentheses and then pygame dos sprite. Sprite after that we will need a thunder init method which is going to run as soon as we are creating one instance of this class and in this thunder in method we always need self and after we have this method we have to do three things the first one is like with any other inheritance we have to call Super Dunder init to initialize the parent class after that for a pame Sprite we will need self. image and self. rectangle the image is going to contain the surface that we want to display or in our case we want py game. image. load and player.png along with convert Alpha for the rectangle we want to do basically what we have done down here so let me copy it we want to get the player surface and then get F rectangle and place the player in the middle of the window the only difference now is that we don't have a player surface inside of this method what we have is self. image this one actually stores the surface and with that we have a very simple pame Sprite that contains a surface and the rectangle although if I am running the code now nothing is going to change we can still see the player but that happens because we get all of this stuff which I don't want anymore so I'm going to comment it out and then we are doing all of this which I also don't want anymore and I also don't want to display the player using the blit method if I now run the code again we can only see the meteor the background and the laser so to use the pame Sprite class first of all we have to create one instance of this class let's do it where we used to have the player I want to create a player variable and then one instance of the player class after we have that at the end of the game loop I want to call display surface. blit and we could get player. image and player. rectangle if I now run all of this again you can see we have a players ship although at the moment it doesn't do anything because we do not capture any kind of input which we are going to reintroduce in just a second first of all though this is not the proper way to display a Sprite let me remove it right away instead let's talk about it in a bit more detail to display a Sprite you could use surface. blit with Sprite out image and Sprite out rectangle although that is not a good approach approach what is much better is to use a pame group and for that we are going to need a bit of theory so for a spread group we have the basic issue that in a proper game we want to display dozens if not hundreds of Sprites and pame Sprite groups are designed around that they can do three things they can draw all of the Sprites they can update all of the Sprites and they can organize the Sprites for drawing we simply get the group and then draw on a surface and this is going to draw all of the Sprites on that surface this would work with hundreds if not thousands of Sprites which is much easier to use than calling surface. blit a thousand times besides that we have group. update and we could pass in any amount of arguments in there this would call an update method on every Sprite inside of that group with those arguments and finally you can also Loop over Sprites to use them in other methods so for example in just a bit when we are creating the meteors we are going to place each meteor Sprite into two groups one to display them and one to organize them that way we always know when we have a meteor Sprite although first of all let's create a single one for the player before we are creating any Sprite I want to create a Sprite group that I call all Sprites because we're going to place every single Sprite in there to create a group we need p .s sprite. group and then when we are actually running the game so in the while loop we want to get that group all Sprites and then we have a draw method and an update method that can accept any amount of arguments but now let's simply work with the draw method and we want to draw on the display surface that is a start but if I run the game we still cannot see the player here that is because when we are creating the player we are not attaching it to the spreite group and to fix that we can go in one of two ways number one after we have created one instance of the player class we can get all Sprites and then use the add method and add the player to it if I now run all of this we can see the player however this isn't usually what you see because it's well an unnecessary line what is much more common when you are creating a Sprite you are passing in the groups that you want this Sprite to be attached to after that when you're coing super Dunder in it you can pass the groups in there that way this Sprite will be added to this group automatically when we are creating the Sprite as a consequence we don't need this add method anymore but we do have to add all Sprites to the player class when we are creating one instance of it with that I can run all of this again and we can still see the player besides that what we can do before we are calling the draw method in fact before we are drawing anything inside of the game I want to call all Sprites do update for now without any arguments and also this recent Keys should be commented out by the way I am fully aware that the code is starting to get a bit messy we will clean this one up in just a bit first of all though before you're drawing anything call all Sprites do update this is going to call an update method on all of the Sprites inside of this group now in our case the player doesn't have an update method which means if we are running the code nothing is going to happen however if I am adding an update method to the player for now only with self then I can print ship is being updated and if I now run all of this again we are getting ship is being updated which means this update method is running just fine and in turn that means we can recreate all of this logic that part is actually going to be your exercise I want you guys to recreate the player movement logic inside of the player class and for all of this the code shouldn't really change all that much you just have to adapted to use it inside of object oriented programming pause the video now and see how far you get I suppose we should start by cleaning things up just a bit first of all we don't need this comment down here anymore and also we don't need the input inside of the event event Loop and after that I want to cut out all of the stuff we have commented out and then paste it below the player class with that inside of the update method we first of all want to get all of the keys after we are getting that we want to update the player Direction although at the moment player Direction doesn't exist inside of this class to fix that I want to create another attribute self. Direction which by default is simply going to be a pame do Vector 2 without any values after we have that I can copy those two lines paste them in there and clean all of this up the only change that we have to make is that this should now be self. Direction dox and self. direction. Y instead of player direction also at this point we have to make sure that we are normalizing the Vector that is going to happen in just the same way instead of play direction we want to have self. direction. normalize if we have a self. direction if that is not the case we want to keep self. Direction and then finally I want to get the actual movement for the player which is player. rec. Center plus equal direction speed and Delta time most of this doesn't exist anymore but let's go through it step by step the player rectangle now is self. rectangle. Center then we are getting self. direction and that we want to multiply with self. speed this self. speeed doesn't exist at the moment so we can create it inside of the dunder ined method self. speed is going to be I believe it was 300 yeah 300 that's a really good start and also at this point we do have Delta time because Delta time is in the global scope so we can use it inside of the class which means at this point if I run the game we can move the player around and this is looking really good now that being said you shouldn't have stuff in the global scope it's just not good practice so what is a much better way of handling all of this is when we are calling the update method we are passing Delta time in there and then inside of the update method we have to add one parameter to capture it which we can also call Delta time the end result though is going to look exactly the same besides that we also have to recreate this logic I think at this point this shouldn't be too hard anymore we simply want to get all of the recent keys and then check if recent Keys py game. Cas space is pressed and if that is the case we want to print fire laser with that we don't need the comments anymore and Run the game if I press space we're getting fire laser so that is working just fine and with that we have a player Sprite that is getting quite a bit more complex if I now minimize it and we don't need this stuff for the player anymore if you now look at the actual game Loop to display and update the player we simply have to call all Sprites do update with Delta time then all Sprites do draw on the target surface later on we are also going to create meteors and lasers dynamically which means at this point we can remove those two lines which is cleaning up things quite a bit more and finally when we are creating the Stars at the moment we are importing a star surface and then we are getting 20 random positions after that we are using another for Loop to displaying all of them in the actual game that we can also simplify by using a Sprite which means I want to create another class let's call this one star which also needs to inherit from pygame dos sprite. Sprite and by the way this part could be your exercise as well I want you guys to create 20 star Sprites and display them on the screen in random positions so the end result will be the same but the code should be much more organized pause the video now and see how far you get with this one first of all we want to call a Dunder init method where we have self and we have the groups like we have done for the player so there we also had Dunder in it with self and groups after that what you should always remember is to call Super Thunder init with the groups besides that we will need self. image and self. rectangle for the image I want to have the star surface let me cut it out actually and then we will need a rectangle and this is going to be a bit different compared to what we have done in the original when we created the star positions we use this comprehensions to create 20 X and Y T builds using Rand int that was necessary because we had to create all of the positions before we are running the game if we created all of the random values inside of the game they would update on every frame of the game which wasn't ideal but now we don't have to do that anymore because we going to create All of the Stars before the game is running anyway so for self. rectangle we can simply get self. image. getet F rectangle and then set the center to an xyle and those values we can copy for X I want to have random integer from zero to the window Wii and for y I want to have a random integer that goes from zero to the window height after that we don't need these two lines anymore also that's basically it for the class now we have an image and a rectangle and now to actually create the Stars I want to use another for Loop for I in range 20 and and then create one instance of the star class with the groups in our case we only have a single one all Sprites once we have that we don't need the for Loop inside of the game anymore and that's basically it the stars are still going to be drawn via the draw method of the group so I can run the game and we are still getting stars and the ship is moving although there are two things we have to refine the first one is that now the ship is below all of the stars that is happening because we are creating All of the Stars after the player and inside of a group all of the Sprites are being sorted by the time of their creation the later a Sprite is being created the later it will be drawn or in other words if we are creating the player after the Stars I can run the game again and now the player is on top of the Stars which looks a bit better better on top of that we can optimize the entire thing because when we are creating one star we are always importing a surface and since we are creating 20 Stars we are doing 20 Imports but well we are importing the same surface 20 times which is not efficient at all so what would be much better here is to import the surface before we are creating the star let's call it starcore surface and then we are only importing it once after that when we are creating this star I want to pass this surface in there this should be the star surface after that when we are creating the star inside of Thunder init I want to have a surface and this surface will be assigned to self. image that way we are only doing a single import then using the same surface 20 times which is significantly more efficient generally importing anything is quite Hardware intensive so you ideally want to do all of that in the beginning of the game and then reuse the surfaces although now if I run the game we getting the same output so in practice since our game is really small this isn't going to make a difference and with that we have a player class and a star class and inside of the actual game you can see this is becoming significantly more organized we have one part where we are updating all of the game and then another part where we are drawing everything besides that we have Delta time and the event Loop but that's basically it via a Sprite you can organize your game significantly better and as soon as you have even slightly more complex projects this will become a necessity and going forward I will be using a lot more Sprites so if you struggle with classes more generally definitely check out some kind of introduction to them it's going to be really important the next important part is going to be working with Time by those we can create meteors and control the laser spawn time let's talk about it in our case we want to use time in two ways number one we want to create a timer that triggers every x amount of seconds and number two we want to have a cool down timer for the laser ultimately those need two different approaches for the first timer we want it to run continuously and then trigger within a certain interval although for the laser we want to have a timer that starts whenever we want and then runs for a certain amount of time to create these two timers first of all the Interval Timer or a timer that triggers every x amount of seconds this we can create with an inbuilt pame tool we basically create a custom event and then set a timer for that event once we have that we can capture that event in the event Loop like any other user input for the custom timer we would have to rely on a pyam method that captures the time or more specifically the time since the game has started and that we can use to create a custom timer basically all that we are going to do is we are capturing a starting point and then measure the time that has passed since that starting point if the difference between these two numbers is large enough then we want to run some code and then we have a custom timer none of this should be terribly difficult so let's Jump Right In I want to start by creating another section we can do this one all the way at the bottom before the while running Loop in there I want to create custom events or to be a bit more specific I want to create a meteor event so a timer that triggers twice a second and every time it triggers it creates a meteor for that first of all we will need a custom event that I want to store in a variable called meteor event and to create this one we want pame event and then custom type this is going to create a custom event and once we have that we can use py game. time. settimer for this one we will need two arguments number one is an event that we want to trigger which in my case is going to be the meteor event after that we will need a duration in milliseconds if you add 500 in here you would have a duration of half a second and with that we have created created a timer the way we are going to use that is inside of the event Loop we have to check for if event. type is equal to a meteor event if that is the case I want to print create meteor let's run all of this and in the bottom of the window we can see create meteor every half second and that runs continuously so it's looking pretty good perfect and well that's basically all you need to know to create an Interval Timer it it doesn't get any more complex so that would be the first kind of timer besides that inside of the player at the moment we are printing fire laser every time the player presses a button or in other words if I comment out this line and Run the game every time I press space we are printing fire laser and this happens as fast as I can press the button which shouldn't be the case there should be some kind of delay between different laser shots so we have to create a timer inside of the player class and essentially what we want to check if this is the time of the entire game where we start on this point and this is basically Infinity we want to check if the player has shot at this point in time let's say after 1 second then we want to wait for let's say 0.4 seconds only after that point has passed can we shoot again to implement that logic we will need a couple of attributes so let me create a timer or rather a cool down section we want to have first of all self. cancore shoot which by default is going to be true besides that I want to have a self. laser uncore shoot uncore time which by default is going to be zero and finally self. cool down duration which is the length of the cool down in my case 400 milliseconds and the way we are going to use that first of all if the player presses the space button we want to add a second condition and self. can shoot by default can shoot is true so this one is not going to make a difference however once we are running this if statement I want to set self dot can shoot to false with that if I run all of this again I can press space and we can only ever a shoot a single laser for the obvious reason once we have shot a laser can shoot is false so this if statement is never going to trigger to account for that I want to create another method let's call it the laser timer no need for custom parameters and in there we basically want to check first of all if not self do can shoot we only want to run any code in here if the player currently cannot shoot and then we want to get the current time which we can get via py game. time.get kcks this will get you the amount of time that has passed since the start of the game in milliseconds or to be a bit more specific the time since we have called pame do init just to demonstrate if I print that current time and then also we have to make sure that we are calling self. laser timer if I now run all of this I can press space and we're getting the time and it's increasing so that is working pretty well so with that we can get the time continuously besides that we will have to know when the player shot the laser which happens inside of this if statement and to get that we want to get self. laser shoot time and use py game. time.get ticks again now at this point you really have to understand that this if statement is only triggered once whenever the player shoots a laser however this Define laser timer or more specifically this this current time is being run continuously because of that we can check one point in time and after that check how much time has passed combined all that we really want to do is if current time minus self do laser shoot time is greater or equal to self. cooldown duration if that is the case we want to set self. can shoot back to true and that should be all if I now Run the game I can press space and even if I press it really fast we only get it every 400 milliseconds to test all of this a bit better let's change the cool down duration to 2,000 or 2 seconds I can now press space as fast as I want but we only get fire laser every 2 seconds and let me go over the logic really quickly this is the timeline of the game where we start with py game. init this would be .0 and then the game could run as long as we need it to run if the player presses space then this if statement is going to trigger and we are capturing one point in time let's say in here and this could be 1,200 milliseconds since the start of the game and this point we are only capturing once after that we are calling Define Laser Time continuously which means this current time increases it would first be here then it would be here here here here and so on this number keeps on growing after we have that we are checking this line where the current time minus the laser shoot time is greater than the cool down duration or in other words our coolon duration would be 2 seconds we would be roughly at this line and Via this if statement we simply check if we are exceeding this point or not which at some point is going to be the case and that is it with that you can create a custom timer and also disc covers the two approaches to time and py game if you understand them you can create basically any kind of timer and later on in this video we're going to use this kind of logic to create a much more powerful timer but that's going to be a topic for later for now I want to use the timers meaning I want to create a laser and then a me and let's start with the laser although both of these classes are going to be fairly similar I want to create a class laser which has to be a pygame Dos sprite. Sprite in there as always we want to have a under init method with self we want to have a surface a position and then the groups we will need groups to assign it to a spreite group the position to place the laser in the right position which is going to be in front of the player and then the surface we want to import first of all and then reuse every time we are creating a laser you do not want to import every time the player shoots fortunately we already imported a laser surface so that part is quite easy although we don't need the laser rectangle anymore after we have that inside of the dund in method I want to call Super dot init and pass the groups in there after that we will need self. image which is going to get this surface and finally self. rectangle will be self. image and get F rectangle where we want to place the mid bottom this one is going to get the position the way you want to think about this one is that this will be our player and we want to create a laser right in front of it which means from the point of view of the player the laser should be in the mid top but from the Laser's perspective we should be placing the mid bottom anyway with that we have a laser class so now every time the player presses space we don't want to print laser anymore instead we want to create one instance of a laser for which we will need a surface that would be the laser surface then we will need a position which is going to be self. wct do mid top and finally for the groups we only have a single one all Sprites I can now Run the game and every time I press space we can create a laser now at the moment the cool down for the laser is really really large so we are only creating a laser every two seconds let's change that part right away this should be 400 if I now run out of this again we can create a laser at a much more reasonable Pace cool that covers creating the laser besides that though we also want to make sure that the laser is moving for which we will need an update method with self and Delta time basically all that we want to do is self. rec. Center minus equal some kind of speed for now let's say 400 and this we want to multiply with Delta time also this should be Center y we only want to move one point I can now run all of this and and we have a laser that is moving so that is looking really good with that we basically have a laser wasn't actually that difficult now at this point though you do want to be careful if the game runs long enough we will have a huge amount of laser Sprites they are not going to be visible but they will still exist hence they take up some processing time which could become very inefficient well this game it's not going to make a difference because the game as well really simple but for more complex game this could actually be an issue so what we want to do if this is the window of the game and we have the player somewhere in there if the player is shooting a laser and the laser passes the top of the window I.E we are exiting this point then we want to destroy the laser Sprite that we can do with if self. w. bottom is smaller than zero then we know the laser is above the window so it's not visible anymore if that is the case we can destroy the Sprite using the kill method now in the game this is not going to be visible although I guess I could demonstrate this we want to check if self. rec. bottom is smaller than 200 if that is the case the laser is simply going to disappear at this position so you can tell it is working in my case though this one should be zero and with that we have a proper laser class next up we want to create a meteor which is also going to be pygame dos sprite. Sprite and this part is going to be your exercise I want you guys to create a meteor on every meteor event on top of that I want you guys to destroy the meteor Sprite after 2 seconds or in other words create a timer inside of the meteor and start a timer once the meteor has been created first of all we will need a thunder init method where we have self a surface a position along with the groups next up super don't forget to call this one and then thunder in it where we pass the groups to the parent class and then we will need self. image and self. rectangle the image we're going to get from the surface I.E the parameter and then the rectangle is going to be self. image. getet F rectangle where we are placing this Center in the position that we are getting from the parameters and just as a reminder we are already importing a meteor surface although at this point we don't need the meteor rectangle anymore and looking at all of this I think we can organize things just a bit better we are not using the plain surface anymore this one can go entirely instead of that I want to have an import section where we are importing the star surface the meteor surface and the laser Surface after that we are creating a whole bunch of Sprites and then we have to custom event and before that we are doing the general setup which I think overall feels much cleaner all right now we have a meteor but this is not going to be visible in the game so we have to make a few more changes most importantly every time the meteor event triggers I want to uncomment all of that then we want to create one instance of the meteor class which means meteor and we have to pass in a surface which is going to be the meteor surface then we will need a position and for now let's simply say 400 and 500 two entirely random numbers we will change them in just a second besides that for the groups all Sprites if I now Run the game we are getting a meteor and since this one is always in the same position we are not going to see much of a change but at the very least it's working so we need to customize these numbers or in other words we want to have an X and A Y number both of those should be random for X I want to have a random integer between zero and the window wi for y for now I want to have a random integer that goes from zero to the window height or in other words at the moment we are spawning a meteor somewhere on the window let's try that and there we are getting meteors all over the window that part is working really well at this point we can also make the meteors move which we are doing via an update method Define update with self and Delta time all that we want to do in there is self. rec. Center Y and to this we want to add some kind of speed let's say 400 multiplied with Delta time I can now run all of this and we're getting meteors that are moving down so that's a pretty good start the reason why this is looking weird is because we are creating the meteor right in the middle of the window so the player can see when a meteor is being created to avoid that when we are setting the Y position we want to be on top of the window or in other words we want to be in a position randomly between 200 and 100 let's try off this again and now this is looking quite a bit nicer the game is definitely coming together although that being said we can customize the meteor class just a bit more there are two things I want to do in there actually number one and this was part of the exercise so let's start with it we want to destroy every meteor Sprite after 2 seconds or in other words we want to have self. startor time which is going to be py game. time.get tick that way we know when the timer is supposed to start we can also set a self. lifetime which is going to be 2,000 milliseconds or 2 seconds after that inside of the update method we want to check if py game. time.get 6 minus self. star time is greater or equal to self. Lifetime and if that is the case we want to kill the Sprite let's try out of that and I think the meteors shouldn't reach the bottom and there you can see they disappear slightly before which was intentional so you can see it's working for the actual game we probably want to go with 3,000 so the player cannot see immed disappearing and that part is looking pretty good so I am quite happy with that now you might be wondering why aren't we using the laser logic where we are simply checking if a laser is above or below a certain position and then we destroy it for example for the meteors we can check if a meteor is below the bottom of the window and well you could do that it would actually be more efficient I simply wanted you guys to practice timers a bit more this approach is actually better although you should be familiar with both of them anyway with that we are destroying a Sprite after a certain amount of time besides that at the moment the meteors are always going in a straight line which isn't ideal I want to give each meteor a direction which is going to be a p game and Vector 2 for which we will need X and Y now why is always going to be one we always want to go down at the same speed however for X I want to have a random value and that should be a floating point value because we want to stay below one for which we are going to need another part from random this one is called uniform and uniform Works quite easily we want to specify two floating Point values we want to start attive 0.5 and then go to 0.5 after we have that when we are updating the position of the meteor we want to get a tet position center is totally fine and then get self. direction multiplied with self. speed multiplied with Delta time now self. speeed doesn't exist let's create it self. speed and this could also be a random integer let's say between 400 and 500 with that the game is going to feel much more organic and this is looking pretty good so very happy with that later on we are also going to rotate the meteors which is going to make things look even better but for now I think we have made some pretty solid progress to actually create a game we will need collisions so by the end of this section we can check if a meteor hits the player or if the player hits a meteor via a laser once we have all of that we basically have a game now collisions and py game you can do broadly into two ways number one you can use rectangle collisions a rectangle can check for collisions via a single point another rectangle or a list of rectangles besides that we also have Sprite collisions mostly what you're doing in there is you are checking the collisions between a single Sprite and Sprites inside of a group although there are quite a few variations for all of that you want to look at the documentation here we are and to get started you want to look at rectangles if you scroll down just a bit you can see all of the Collision methods I guess we can start up here the first one would be contain this one checks if a rectangle is inside of another rectangle then there's Collide point and this one checks if a point is inside of a rectangle after that we have Collide rect a really common method this one checks if there's an overlap between two rectangles and just just in case you're wondering contains means that a rectangle has to be entirely inside of another rectangle for this to trigger whereas Collide rectangle simply needs a simple overlap and well then we have a few more methods but I think they're all fairly straightforward so if you click on one of them let's say Collide wrecked you can see what pyam is expecting we need a rectangle and then we are calling Collide wrecked and pass in another rectangle the return value is going to be Boolean so I true or false and they basically all work in more or less the same way anyway besides that we can look at the Sprites which I haven't shown yet but they live in this section under Sprite and there you can create a pam. sprite. Sprite and if you go just a bit further down we can see all of the Collide methods by far the most common one is Sprite Collide besides that though we have Collide wrecked collide cor ratio Collide circle and a few more later on we are also going to use Collide mask but this one we haven't covered yet for now I only care about Sprite Collide this one at a minimum wants to have three arguments a single Sprite a group of Sprites and then do kill we basically check all of the Sprites inside of a group and if any of those Sprites collide with the single Sprite then we are storing those inside of a Sprite list that's the return value and do kill means that we are going to run the kill method on a Sprite that is colliding with the single Sprite and well that is basically it here we are and I want to start by creating some rectangle collisions although for real game you want to use Sprite collisions simply because you are going to work a lot with Sprites but you should be able to handle both anyway at the moment we have a player and in there we have a rectangle that is what I'm going to use for now which means inside of while running I can check and let's add another section here test Collision I want to get player. rectangle and then use Collide any of those methods and for now Collide point this one is checking if the rectangle is colliding with any point meaning we have to specify an X and A Y point for example in there we could add a 100 and 200 and that I want to print let's try off that and by default we are getting faults but if I move to one point up here we are getting true so this part is working quite well although I suppose it's very hard to see something that you could also do is use py game. mouse. getet position that way I I can show my mouse and by default we getting false because the mouse is not colliding with the spaceship however if I have a over it we're getting true so this is also working just fine another method that you do see very often is Collide rectangle for this one though we are going to need another rectangle let's create one before we are running the game I want to have a test rectangle which we are going to create via py game. f rect and by the way frre or normal rectangle doesn't matter for rectangle collisions they all work in the same way for this one we want to have a left top width and height let's say the left could be zero the top could also be zero and then the width will be 300 and the height will be 600 that means if this is our window the test rectangle is going to be roughly capturing this size and that we can check for inside of the game I want to check for player rec. cidere with the test rectangle if I now Run the game we get false by default but if I go to the top right we're getting true and then I can go outside of this area and we're getting false again so that is working pretty well and that is basically all you have to do for rectangle collisions they don't really get that much more complex although there's one important thing you should keep in mind when when we're talking about collisions in pame we don't really talk about collisions instead pame only really checks overlaps I.E if one rectangle overlaps with another rectangle but that is never going to change the position of either of those rectangles meaning if you want to have a game and the player is constrained by a wall or a house this would require extra Logic on your part something we are going to work on in the next game it's not terribly hard to do but but you do have to make it yourself just keep that in mind anyway with that we have rectangle collisions meaning we don't need this test collisions anymore and we can also get rid of this test rectangle next up we can work on Sprite collisions which are going to be much more useful and for now I want to check if a meteor is colliding with the player for that though we have a problem because at the moment all of our Sprites are in in a single Sprite Group which makes it really hard to separate all of them for that I want to create another Sprite group let's call it meor unor Sprites which is going to be pygame dos sprite. group the same thing we have done before and then when we are creating a single meteor instead of adding a single group we want to have two groups all Sprites and meteor Sprites and this is totally fine to do we are going to have all Sprites for the update and the display part and then the meteor Sprites are going to be used to classify all of the meteors or other words when we are working with a Sprite we know what we are working with besides that we also have the player inside of a separate variable that way we can always identify the player and by the way so far I haven't really talked about it but when you are creating a Sprite you're getting a return value of that Sprite so you can reference it via a variable but you don't really have to do that for example when we are creating a meteor we're not storing it inside of a variable we are simply attaching it to a group and then call it a day both approaches are totally fine to do now attaching a Sprite to a variable is something you only really want to do when you want to reuse that Sprite a lot or rather when you want to get very easy access to it which we do want to do for the player but for the meteor we don't really need it anyway after we have that before we are drawing the game still inside of update we want to check for collisions which we can do with pame DOs sprite. Sprite Collide this is the most important Sprite Collision method and in there we have to specify three arguments at a minimum the first one is a single Sprite Which in my case is going to be the player besides that we want to check a group of Sprites which is going to be our meteor Sprites and finally we have do kill or in other words if any of the Sprites inside of metor Sprites is colliding with the player do we want to destroy that Sprite that has collided for now let's say this one should be false and after we have that I can print the return value if I now try all of this by default we have an empty list but once there is an overlap we get a value inside of that list so that part is working pretty well now now so far we only ever get a single value but if I managed to overlap with two meteors we would have two values I suppose what we could be doing for the meteor event I want to change this to 50 that way we're getting a whole bunch more meteors and now you can see this list can contain many more values as many Sprites as we are colliding with or if you look at this if the game isn't running we're getting a collision with one meteor here and if I scroll up a bit and at some point we should have multiple collisions there for example we have a collision with two Sprites and if we set do kill to true then we are getting rid of any meteor that is colliding with the player so that is also working quite well and keep in mind what can sometimes be a bit confusing if you set do kill to true you are destroying the Sprite however the return value is still going to give you access ACC to that Sprite for one frame or if I scroll up a bit sometimes we do get the value and this sort of logic can be really helpful so after you have destroyed a Sprite you might want to do something else for example what you do see very often is that you don't want to print all of the collisions instead you want to use an if statement to check if you have any kind of collision if that is the case let's say print collision and this is still going to work even if we are killing the meteor on collision and this can only work if you have access to the Collision Sprite or in other words the return value of this cannot be an empty list once we have a collision in fact what you see even more often is that you assign the return value to a variable let's call it Collision Sprites you are checking if Collision Sprites is truthy and once you have that you can get Collision Sprites and get the first item to get the collided Sprite so if I try out of that we are getting the Sprite that we are colliding with so that part is working reasonably well that is basically it for sprite collisions the really important thing that you have to understand is that you can get access to a couple of methods via py game. Sprite and then the name of the method check the documentation for more details and after that you have to make sure that you have access to all of the Sprites which usually happens via either a group or by assigning a Sprite to a variable collisions or rather overlaps in py game aren't really that hard to get which means we can do an exercise I want you guys to check for collisions between the lasers and the meteors and then destroy both once there is a collision for that you would have to do a bit of creative thinking see how far you get and don't worry too much about it if you can't do it this one is getting slightly more advanced I have way pause the video now and see how far you get to check for the collision between the lasers and the meteors we first of all need to get access to all of the lasers and for that when we are creating a laser that happens on this line we want to assign a laser to all Sprites to display and draw it and then we also want to have another group called laser Sprites this one doesn't exist at the moment but we can create it quite easily below the meteor Sprites I want to have a laser Sprites Group which is going to be pame dos sprite. group with that we have access to all of the lasers so that's the first step next up we want to check if any Sprite inside of the lasers collides with any Sprites inside of the meteors and there we kind of have a problem if you look at the documentation for Sprites you don't really have a method for the that I suppose we do have group collides but this one simply checks if we have group one and group two we want to have a bit more detail we want to check for every single laser we don't want to check for the entire laser group so we can't really use this method however what we can do is to Loop over every single Sprite inside of this group and then Calla Sprite Collide or in other words inside of the game Loop we are currently checking if the player collides with a meteor besides that I want to do four laser in laser Sprites that way I get access to every individual laser Sprite and once I have that I can call pame Dos sprite. sprite light wave the individual laser and the metor Sprites and do kill should be true if I now run all of this and I press space the laser is going to destroy all of the meteors that part is working well but it's not ideal yet the laser simply destroys all of the meteor Sprites but that shouldn't happen once there's a collision the laser should also be destroyed for that I want to get the collided Sprites as a list and store all of the collisions if that exists I.E if collided Sprites then I I also want to get the laser and kill it if I now run all of this again I can shoot a laser and both the meteor and the laser disappear although that's a bit hard to see let's change the meteor spawn timer back to 500 and that way I can shoot at individual meteors and they disappear so that part is working quite well that being said we should keep this game Loop a bit more organized so what I think would be a more elegant is to put all of this into a separate function which means below the classes I want to Define collisions no need for custom parameters and we basically want to cut out all of this and then call cisions after that inside of collisions we have all of the code although we would need to organize things a bit better if I now run all of this everything should still work just fine and that is looking pretty good and yeah I get an overlap I can destroy the meteors quite happy the last thing that I want to cover is that once a player is being hit by a meteor we want to end the game which in practice means we want to set running to fals unfortunately this we cannot do right away so we couldn't simply set running to vaults because we would simply create a local variable inside of this function or in other case if you run the game The Meteors do disappear but the game doesn't end as far as python is concerned we have a running variable inside of this function and then a global running variable and those have nothing to do with each other to fix that we want to set Global running that way those two connect and then if the player collides with meteor the game is simply over although that being said this approach isn't ideal because you want to avoid having global variables for now I think it's fine because we are just getting started but for the next game we are going to approach this slightly differently but anyway with that we have collisions at this point we basically have a game that being said we can make all of this look significantly nicer and for that we are going to display a few more things and also we're going to work on the color so by the end of this section we have a much nicer looking game there are two major things that I want to cover in this bit number one is displaying text which is actually fairly straightforward you first of all have to create a font object which means you have to define a font style and a size for the font after you have that you can simply use this font to render some text and then you get a Surface and that surface you can use like literally any other surface the only difference is that this surface has some text instead of an image but that's literally it besides that we can draw things and for that pame has a draw a module which lets you for example draw rectangles circles lines and pretty much any kind of shape so those are going to be the two major topics that we are going to cover let's start with some text back inside of the game we have to first of all let's do it under import create a font and this we do with pame . font. font make sure that you are spelling the second font with a capital f we will need a font and a font size for the font size we could go with 20 and by default a font can also be none then we are using a default font that looks pretty bad but it gets the job done so with that we have a font after that we can use font. render to create a surface and this we need three arguments the first one is some kind of string with a bit of text whatever you want to render then we have antialias for which we will need a Boolean value anti Ling means that we are smoing out the edges of a surface most of the time you want this value to be true or in other words you want to smooth out the edges of any kind of surface just a bit to make them look better the only exception is pixel art fonts if you antias those they are going to look really weird finally we will need a color and we will talk about colors in just a bit as well for now though I simply want to have a red and this is going to give us a text surface or just a surface that happens to have some text and well that is basically it once we have that inside of the game Loop we could run display surface do blit with the text surface and a position let's say 0 and zero and then in the top left you can see some text that part is working pretty well that is literally all you need for this part although if you want to have a custom font which you basically always want to have you would have to import a font file that fortunately we do have because if you look under images there's a file called oxenium bold.ttf ttf is a font file and that we want to import which we are going to do via the join method I want to go to images and then import oxium Das bold.ttf if I now run all of this again and you look at the text it is looking quite a bit nicer which is a good start but the color doesn't really fit now you could go with white here for example and that would help but ideally we want to have more control over our colors and that we can do in P game although I haven't covered it yet so let's do it now to create colors in py game you can basically follow three approaches the first one are the inbuilt color names like a string green red blue yellow so on you do have quite a few inbuilt ones but those are still fairly crude if you want to have more detail you want to have either an RGB tupal or a hexad deal value to start with RGB tbls those are simply a t with three value the first one for red the second one for green and the final one for blue and all of these values have to be between 0 and 255 we have zero being the absence of the color and 255 being the full amount of that color for example if we have 255 0 and Z then we are getting a pure red because we have no green or blue if you have 0255 and 255 you're getting a light blue or in other words you are mixing a full amount of green and a full amount of blue finally if you have 200 for each you're getting a grayish color and that's basically it besides that you have hexadecimal values which always starts with the hashtag symbol then you have two characters for red two characters for green and two characters for blue now the slightly confusing thing about those is that for each value we can specify a value from zero to F or in other words we go from 0 to 9 and then we continue with a b c d e and and F so for example we could have values that look like this where to get the full amount of red we would have F and F this might look weird but in practice it means with a single value you can express a much greater range and that's why we are using this and well that's basically it all you have to understand about hex values is that we are using two values for each color and we always go with red green and blue although in practice you wouldn't do this by hand anyway you would use some kind of computer system to give you values that you need and you simply select the color that you like all you have to do for that is go to Google and then look for a Color Picker Google even has an inbuilt one and there you can select any color that you like and then you're getting a hexa decimal value and an RGB value now there are a few more ways to express a color but we don't really care about those hex values and RGB values is all we really need which means inside of the code inside of white I could specify a tuple with red green and blue for example a value here could be 200 50 and 100 and we would get a purpleish color not ideal yet but we can work on it alternatively what you could be doing instead of a tupo you can specify a string that starts with a hashtag symbol then specify two values for red two values for green and then two values for blue let's say five five that way you'll be getting another color that looks somewhat similar those are the three ways to express color in P game or at least the ways you would be using most of the time besides that if you look at the documentation there is a whole color module and this one gives you a lot more control over the color now this could be incredibly useful but in practice I basically never use it you simply don't need that much control over the color but in some very specific projects this might be useful now in our case I want to change the background color which we are setting here at the moment this is dark gray and this really doesn't feel right instead the color that I want to go for is a hexadecimal value with 3 a for Red 2 e for green and three f for blue if I run all of this now we get something much better looking and everything else still works just fine and for the text I guess instead of this random color we could go with 255 255 and 255 which arguably is a pure white color so not that much gained I suppose just to have something a bit more customized we can set this to 240 so we're not getting a perfect white which usually feels a bit too strong but anyway play around with this at this point you have all the tools to create your own colors what I want to do instead is to display a score via text or in other words this text surface shouldn't display a static word text it should display the time since the start of the game meaning all of this needs to be dynamic and this I want to have in a separate function let's call it Define display under score score no need for custom arguments and in there first of all we want to create a text surface I can cut it out from where we used it earlier and paste it in there antias and the color can stay the same but for the actual text information we want to have a separate value let's call this one the current time and we have already seen how to create this one we simply want py game. time.get X now this is going to return a number but font. render always wants to have a string and if you pass anything else in there you are going to get an error which means in our case we want to use S Str to create a string and then pass the current time in there and well that's basically it now we have a surface so next up we can create a text rectangle via text surface and get F rectangle we want to place the mid bottom for that we will need X and Y X is going to be the window WID divided by two and Y is going to be the window height minus 50 pixels that way we are in the bottom center of the window finally I want to get the display surface and then blit the text surface along with the text rectangle and with that we have the entire logic inside of a single function which feels nice and clean so after we have that in the bottom of the game after we are drawing everything else I don't want to display the text surface instead I want to call display score without any arguments if I now run out of this you can see we have a score in the bottom now I guess the text is a bit small so what we can do about that is increase the font size instead of 20 let's go with 40 and that feels much nicer also what you can do you can display the score before or after all of the Sprites if you do it before the player can be on top of the score which I guess is a decent effect I don't know it's fairly subjective just choose whatever you like and if you feel like that the score is increasing too fast you could Flo low divide this for example by 100 then it doesn't feel that strong anymore once again this is fairly subjective just choose what you think looks good there isn't a universal answer for any of this anyway with that we have a score next up then we can work on drawing things and for that we have to look at py game. draw if you look at the documentation there we have draw and there you can for example py. draw. rectangle polygon Circle ellipse Arc line lines AA lines and that's basically it in case you're wondering the difference between line and AA line is that we are antialiasing the line which means an AA line is going to look a little bit less pixelated than a regular line and to use all of that let's do a couple of experiments so after we are drawing everything else I want to have a draw test for that we can use pame do draw and for now let's start with line for which we will need a couple of arguments the first one is the surface to draw on in my case this will be the display surface then we will need a color since this point doesn't matter too much let's go with red then we will need a start position and an end position for the start position for now let's go with zero and zero and the end position could be 500 and 600 after that you can also set the line WID let's go with 10 and now if I run out of this we have a random line on top of the game that's kind of all we have to do in here and you can see this thing is quite pixelated might be hard to see on YouTube but if you run this on your own you can definitely see it if you don't like that look you can change this to a a line that way you would be getting rid of the pixels although a a line doesn't have a line withd so this we would have to get rid of if I now run this again you get a line that is looking a bit less pixelated but since you can Define the WID it's not terribly useful anyway what is much more interesting and let's go with line so we can set a line wi of 10 instead of having a static point you could also use py game. mouse. getet and this should be get PA actually if I now run this again and I can show my mouse you can see that we can move both the ship and this line works just fine I suppose what we could also do is layer do rect do Center and now we get a line to the center of the ship that's kind of all you need for the draw method besides line two things that you see all the time are pam. draw. rectangle and pam. draw. ellipse both work basically in the same way actually let's start with the rectangle for this one we will always need a Target surface which in our case will always be the display surface then we need a color let's keep on going with red and then we need a rectangle in this case we can use player. rectangle if you simply run it like this you are drawing a rectangle on top of the player so this part is working fairly well and if you change rectangle to ellipse then pame is going to draw an ellipse in this rectangular area so those two methods are basically working in the same way although for now I do want to work with a rectangle just a bit more because you can specify a few more arguments actually quite a few the first one is the whift by default it's zero but if you set it to anything higher let's say 10 then you are only drawing the border and you don't fill it anymore also if you specify another argument you would set a border radius let's go with 10 for this one as well and then you have rounded Corners I think you get the idea drawing a p game really isn't that complicated which means we don't need this draw test anymore and instead we can do an exercise I would you guys to draw a box around the score text also make sure that you adding rounded corners and for an extra challenge add padding between a text and the rectangle for that you would have to look at the documentation this one is a bit beyond what we have done so far so don't worry if you can't do this extra part but anyway pause the video now and see how far you get back in the code I want to work inside of display score and there we already have a text rectangle this is what we want to draw via py game. draw. rectangle we want to draw on the display surface or the color we want to go with the same color as the text so 240 240 and 240 after that we will need a rectangle which is going to be our text rectangle then we will need some kind of Border width let's go with five for now and we will need a border radius I guess 10 could be going okay let's try out of that and we are getting well we getting something this doesn't look ideal but at the very least we have a border around the score but this we have to refine so how can we add padding between a text and the border and unfortunately this we cannot do inside of the draw method however what we can do is mess with the rectangle for that I want to look at the documentation and then the rectangle in there you have a move method and you have an inflate method inflate simply grows or shrinks a rectangle and you can specify an X and A Y value although a better name here would be horizontal and vertical size changes or in other words if this is our rectangle the inflate method would keep the same center point but then expand it in the horizontal or the vertical axis and if you had negative numbers you are shrinking the rectangle that's all you really do which means when we are drawing the rectangle we don't want to have the text rectangle itself we want to have text rectangle do inflate and for the numbers let's say 20 and 30 if I now run this this is already looking quite a bit nicer so definitely an improvement the issue is though we have some text that has a bounding box like this with the actual text being roughly here the reason why we have this bottom stuff is because some letters go quite a bit further down like a p for example but for numbers this isn't really going to be an issue which means in our case we want to move the entire rectangle up by just a bit and that we can also do so essentially what's happening at this point we have a text rectangle and then we are calling inflate and this is going to return another rectangle on which we can call another method which is the move method which is going to return another rectangle that has been moved by an X and A Y amount now X in our case is going to be zero we only want to move up by a little bit let's say 10 if I run this again and that is definitely looking better I think this value should be a bit lower and the inflate for y should also only be 20 and that is looking much nicer I think the vertical inflate could still be smaller let's say 16 let's try it again and well we are heading in the right direction but this is something you have to play around with I think 10 is actually best yeah that looks like a pretty reasonable amount once again the numbers here are fairly subjective so play around with this and choose whatever you think looks best with that we can draw text we can choose custom colors and we can draw random shapes things that are really important to make our game look better all right in this part we're going to finish up the space shooter and there are a couple of things I want to work on the easiest one is going to be sound I don't think I have to explain this one besides that we also want to transform the meteor surfaces and make them rotate after that we're going to add better collisions by using a mask which is a slightly more advanced Topic in P game and finally we're going to add an explosion animation if you add all of these things you are making the game look quite a bit nicer and let's go through the topics one by one the first one that I want to start with is using a mask first question here is what is a mask and well it's basically an object that checks which pixels of a surface are visible invisible pixels will be black and visible pixels will become white or in other words our player surface would become something like this which in itself doesn't seem terribly impressive but via this system you can do two things number one you can get Pixel Perfect collisions because now we know which pixels have actual content and besides that you can create silhouettes which is super useful to make the play a flash for example or you could add an outline to a surface and for more detail on all of this you want to look at the documentation under a mask in there you can get all of the methods in quite a bit more detail and the most important method that you have to be aware of in the beginning is py game. M.R surface that way you are creating a mask from a surface this is what you're using most of the time to create a mask although it's not the only way to experiment with all of this let's have a look at our player class at the moment we have a single surface in here and that is self. image which is something that we can use and let me add a section at the bottom for the mask I want to create a mask which I can do bya py game. mask. from underscore surface and in there we have to add a surface which in this case will be self. image and that by itself doesn't do anything if I run the game nothing is going to change however I can visualize this mask by turning it back into a surface let's call this one the mask surface and this we get with mask and then dot to surface that way we have turned a mask back into a surface and that we can use to overwrite self. image I want to set this to the mask surface and if I now run of this you can see what's going on we have turned all visible pixels white and all invisible ones black and that is what a Mas does and the way you are using this system most of the time is with collisions because right now our Collision object is a rectangle meaning if this is the outline of the ship very roughly then the actual Collision shape would look like this that is the rectangle that we have created and on top of that if we have a meteor while the meteor itself is round the Collision shape of the meteor is also a rectangle which means if you have a meteor in this position we still get a collision even though visually to the player there was no Collision whatsoever which for a game can be very frustrating so this is something we want to avoid to avoid that we want to know which pixels of a surface are visible and that we do via a mask that is the most common way of using a mask besides that what you could also do on this mask surface if you were to hide the black pixels then you would have a flash effect and you can hide pixels of one color on the surface quite easily for that you want to get the surface in this case M surface and then set a color key setting a color key means that you're making all of the pixels of one color invisible in our case this should be the black pixels and if I now run all of this again we have the ship in perfect white this could be useful if you want to make an object flash after it got hit which is something I am going to cover later but for now we don't really care about it instead what we want to do is to get rid of all of the surfaces and then turn the mask into an attribute meaning this should be self. mask and this self do mask is another part of a Sprite class but if you add it you can Implement mask Collision fairly easily although for that to work we have to add a mask for all of the Sprites which ultimately is fairly easy you will always need the same line let me copy it actually for the star we don't need that because they're not supposed to collide with anything but for the laser we will need self. mask and for the meteors we will need another self. mask and that way all of the collidable objects have a mask so how can we use it inside of the collisions for that let's have a look at the documentation we want to look at the Sprites if you scroll down there a bit we have once again all of the Collision methods the one that we are already using is called Sprite Collide and if you look a bit further down we also have Collide mask and you could use both of them although I would recommend and Sprite Collide if you click on that so far we have used Sprite group and do kill but there is a fourth argument cided it basically means that we can specify in a bit more detail what kind of collision we want and in there we can look for collide mask you could also look for example for Circle or some kind of ratio but those aren't too common besides that if you go a bit further down we have Collide mask and in there we're calling pame dos sprite. CID mask and then add in two Sprites the return value is going to be an X and A Y position which you can read more about here although this method we don't actually need because back in the code we can simply expand Sprite Collide by just a bit for that I want to add a fourth argument pygame dos sprite. cite mask and that is literally it if I now run the code and this is going to be quite hard to demonstrate but for example there you can see I can dodge the meteors much better and if we collide with them it is a Pixel Perfect collision and the same thing you could also do for the lasers although for them I don't think it's very necessary because lasers are essentially rectangular so not much Point adding a mask and one thing that you generally want to keep in mind is that using a mask is very very Hardware intensive if you do it for every Collision you are going to than your performance pretty hard and actually while I'm recording this I realized that when we are calling py game. sprite. CID mask we don't actually have to create a mask attribute inside of the class because if you read the documentation then you can see that if a Sprite has a mask attribute we are going to use that one otherwise we are going to create a mask from the image automatically and since we want to use the image anyway we don't need this line for any of the Sprite class sorry about that fairly minor mistake although I'm going to leave it in there for the player just so that you can copy it anyway with that we have a mask something slightly more advanced in pame and if you want to know more about it check out this dedicated video in there I cover masks in a lot more detail next up I want to transform surfaces or in other words I want to use pame do transform to change surfaces this is just another module in pame and this one can for for example scale flip rotate blur gray scale invert and quite a few more things to a surface once again in the documentation if you look at transform you can find all of the options a really simple one would be rotate in there we have to call py. transform. rotate pass in a surface and an angle and then the return value is going to be another surface and the same logic applies to basically all of them you pretty much always call py game. transform and a method and pass in a surface with a couple of extra Arguments for that for example when we are creating the player we can once again mess with the image and let me add another section transform test we could simply overwrite self. image via pygame do transform Dot and then one of these methods the one I've already talked about is rotate and in there we first of all need a surface which in this case is going to be self. image and then we need an angle let's go of 90 and now if I run all of this the ship is rotated 90 besides that another common method would be scale or scale to X scale tox is the simpler one and there we simply want to have a surface self. image and with that we have the player being twice as large if you read up on the other methods you can do basically anything I guess what you can also do is use grayscale that way our ship is going to be black and white pam. transform doesn't fundamentally get that complicated there's just one thing that you really want to keep in mind transforming a surface can reduce the quality this doesn't apply to all of the transform methods for example if you use grayscale this doesn't really have an effect but if you rotate something too often then you are going to notice a loss in quality but let's go through it step by step if you rotate a surface once you are going to lose a very minor amount of quality this is so minor that it's never going to be visible however if you rotate a surface a thousand times per second then the quality is going to Decay very fast and very noticeably and let's do an example for that let's say I want to rotate the player surface continuously or in other words inside of the update method I want to add another section continuous row rotation I want to get self. image and then assign py game. transform. rotate then get self. image and then a rotation number for that under transform test I want to have self. rotation which by default is going to be zero but before we are applying the rotation I want to increase self. Rotation by a small amount let's say 10 and don't forget to multiply it with Delta time if I now insert self. rotation into py. rotate and Run the game you can see that the game gets really weird and in fact the frame rate crashes as well so this isn't ideal if I change the rotation speed to one you can see a bit better what's going on so there you can see the ship simply disappeared and the basic issue is for all of this if this is the full rotation where we start at zero and then go in 360 at the moment we are always jumping by a very small amount and then use the new Surface to jump again for another rotation and we keep on doing that forever until the game crashes which admittedly isn't too long that is because every time we are doing this kind of rotation we are lowering the quality and we are changing the surface a bit and if you're doing this too often you are getting some really weird Behavior which you absolutely want to avoid and the way to avoid this is to only rotate a surface once which kind of sounds weird but basically what we are going to do we are going to always keep the original surface and from there Jump by a certain amount and then display this new Surface however on the next frame we are once again starting on on the original surface and then simply rotate a little bit further and then use the new Surface since we always start from the original surface we only ever have a single rotation which is not going to affect the quality or at least not in a noticeable way to achieve something like that we want to store self. image in some other attribute let's call itself. original surface this is going to be pame image. load the thing we have already done and then for the image I want to have self. original Surface after we have that when we are assigning a new image we are not using the image itself instead we are using self. original surface on top of that let me change the rotation speed to something like 20 if I now run the code you can see that we have a rotation and we are getting some loss in quality so it is definitely visible especially on this surface now depending on what kind of art you have this will be more or less visible this also depends on the speed if I change this to 100 then it's already looking quite a bit better although this still isn't amazing you can see way too many pixels and to fix all of that we have to look at the documentation in there I want to look at transform and then have a look at the rotation methods there are two that we can use use pam. transform. rotate is what we have already used this one rotates an image besides that we have pam. transform. Roto Zoom this one does two things it scales and rotates an image at the same time on top of that it applies a filter when it's doing that which effectively means it Smooths out the entire thing and gets rid of pixels which for most Graphics is what you want to do it looks much better most of the time which means back inside of pame I want to py game. transform. Roto Zoom still use the original surface and the rotation but then for the scale we have to add a one in here to keep this value constant if I now run all of this the ship is looking significantly better so this is what you would want to use most of the time but it's not a universal thing very often rotate is what you actually want this depends very much on your game and you should experiment to see what works best there simply isn't the universal answer but for the ship I don't actually want a rotation so let me get rid of all of this stuff we don't want to have any transform and also we want to keep the original image with the surface that way that is looking pretty good what we actually want to do is to rotate the meteors that part is going to be your your exercise I want you to make the meteors rotate and also give them a random rotation speed pause the video now and see how far you get when we are adding this surface we want to store it under self. original surface and this can get the surface and you don't even have to change self. image since we're getting the same surface for both of them other than that I want to have self. rotation under score speed which can be a random integer let's say for now between 20 and 50 after that when we are updating all of this I want to overwrite self. image with high game do transform dot rotate or Roto zoom and for this one I want to use Roto Zoom to have a bit better quality for the surface we want to have self. original surface and then we going to need an angle which at the moment we don't have for that I want to have self. rotation which by default is going to be zero and then before we are updating self. image self. rotation plus equal self. rotation speed multiplied with Delta time then we can pass self. rotation in there put a scale we want to keep one if I now run all of this this we have the meteors rotating so that's not looking terrible I guess what we could be doing is increase the speed this could maybe be 40 to 80 let's try it again and yeah that is looking a bit better but we're getting some weird wobbly Behavior if you keep on looking at the meteors they do move a bit weird that is because we are changing the image but the rectangle always stays the same which shouldn't be the case because for this image we now have New Dimensions we want to also overwrite self. rectangle and assign it to self. image. getet F rectangle and set the center to self. re. Center or in other words we are creating a new rectangle with the same Center position as the last rectangle that way I can run out of this again the meteors are moving much more naturally which feels quite a bit nicer perfect with that we have the meteor rotation and that we can improve even more with an animated explosion for that we have to go through a couple of steps first of all we need to import a whole bunch of explosion images after that we have to create an explosion class and whenever a laser hits a meteor we want to create one instance of that class this is then going to play an animation and after the animation is done the class disappears or rather the instance of the class disappears if you want to try this on your own it could also be a really good exercise although it's getting a bit more advanced what I want to do is to create a new class animated explosion which is also going to be a pame Dos sprite. Sprite for that we going to need a thunder init method and for that we want to have a list of surfaces I usually call that frames I think that name makes the most sense but it's basically a list of surfaces besides that we want to have a position and we will need the groups super do Dunder init with the groups and then we will need self. image and self. rectangle now the rectangle is going to be fairly simple self. image doget F rectangle and we want to place this Center at the position but then we have to assign a surface to self. image and for that basically we want to get frames and pick the first item and I think I am jumping ahead just a bit so let's have a look at the project folder there we have images and in there we have explosion which is simply a folder full of images we want to import all of them and then play them in sequence after the sequence is done we are going to destroy the animated explosion class for that though we have to import all of these frames and that's going to happen in our import section I want to store all of the explosion uncore frames in a single list and that we can do via list comprehension or in other words when you're looking at the folder we know the file name starts at zero and then goes all the way to 20 and we always working with a PNG file meaning we can do for I in r 21 that way we going up to 21 but not including it and this should be I for I in range 20 if I do this so far and print the explosion frames then we're getting a list with the integers from 0 to 20 that is a good start but not exactly what I want because what I actually want is to use the join method we're going to images then we're going to explosion and in there we want to have all of the f names or in other words images explosion and then an F string where we are using I do PNG if I now run all of this again we are getting a list with a whole bunch of paths and that we can use inside of P game. image. load and also don't forget to call convertor Alpha the line is getting a bit longer ER but I think it's still manageable fundamentally we are not really doing anything complicated we are simply running this py game. image. load inside of a for Loop let's try off this again and we are getting a list of surfaces that is perfect so with that we can get one image which is going to be the first item inside of frames next up when we have a collision between the lasers and the meteors besides killing the laser I also want to create one instance of the animated explosion for which we are going to need the explosion frames the position is going to be the top of the laser I.E laser. w. midtop and then groups is simply going to be all Sprites if I now run all of this and I can shoot at a meteor we're getting the first frame of the explosion doesn't do anything at the moment but we are getting there so to create an animation we basically want to change self. image and always assign a different index from self. frames and that needs to run inside of the update method and there we will need self and data time just as before we basically want to do something like self. image is going to be the frames and then some kind of index and this index has to increase over time for that first of all we have to store all of the frames inside of an attribute that way we can access them in the update method besides that I also want to have self. frame index which by default is going to be zero when we assigning self. image I want to get self. frames although you could also just use frames in there and then self. frame Index this we want to do when we are creating one instance of the class and in the update method but then before we are doing that inside of update we want to increase self. frame index by a certain amount let's say five and also this needs to be multiplied with Delta time now this is not going to work for two reasons number one is that when we are using indexing we always need an integer which by default is going to be the case but remember Delta time is something like 0.0 something if we multiply that with the speed we are going to get a floating point value which is not going to work with indexing which means when we are assigning the frame index we want to convert this number to an integer and that should actually work already at least for a bit if I now shoot at a meteor you are getting an explosion but then the game Should Crash the issue we have is that the list index is out of range or in other words this Frame index continues indefinitely but we only have a finite number of surfaces inside of self. frames to fix that you want to use the modulus operator along with the length of self. frams also I want to increase the animation speed to make this look a bit better if I now shoot at a meteor you can see we have the animation playing forever now in case you don't know what modulus does it basically gives you the remainder of any division operation if you had 10 modulus 3 you would get a one because the next clean division that you could be doing is 9 / 3 this one would get you a three but then we have a remainder of one now in our case the length of self. frames is 20 and self. frame index can grow indefinitely and if you did 10 modulus 20 you would get 10 however if you did something like 25 modulus 20 you would have a remainder of five and that is exactly what we want because we have gotten to 25 and this would not be in the original frames anymore instead what we want is the fifth frame or more specifically we simply want to get rid of the 20 in the beginning and keep the five understanding modulus and python is incredibly important so if you don't understand the logic here definitely do some research that being said we don't actually want to use it because if I run the game again having the animation playing forever would look a bit weird instead I want to check if self. frame index is smaller than the length of self. rames only if that is the case do I want to assign a new self. image and for that we don't need modulus anymore if that is not the case else meaning frame index is greater than the length of the frames or in other words the animation has finished then we want to discard the Sprite with that I can shoot at a meteor let's hope there's going to be one nearby and we get one animation and then the explosion disappears perfect and with that you have a basic animation logic that's all there is to it all you need for a basic animation is that you are going to overwrite self. image you could either play it once or continuously and that's really all there is to animations in P game with that we can cover the final part playing sounds this is actually fairly simple we have to first of all create a sound object that we do with py game. mixer. sound along with a file path after we have that we can play stop rewind set volume and so on anything that you would want to do with a music file and by the way if you look at the pame documentation there we have music and we have mixer although this is a bit deceptive if you click on music you are also getting to a subpart of mixer so ultimately just go to mixer right away then you have the main module and in there if you go down just a bit we should be getting to pame mixer. sound that is the main module that you are using for sound and you can create it in a whole bunch of different ways but basically you always either insert a file name or some kind of data to get a sound file and then you can use sound. playay sound. stop Fade Out set volume and so on which means back inside of the code we first of all have to import a couple of files and for that if you look at the folder we have four files that we want to import let's start with the laser sound that we want to store in a variable for that I need py game. mixer. sound then use the join method to go to audio and then I want to import laser. wav and that is it we now have a laser sound to play it we want to go to the place where we are creating one instance of a laser that happens in here I want to get the laser sound and then play it if I now play the game I can shoot the laser and we're getting a laser sound if you find this laser sound too loud when you are importing it you can get the laser sound and then the method set volume where we have to add a floating point value which goes from 0 to 1 with one being the full amount if you add a 0.5 in there and run this again the laser is now 50% as loud and that is basically it for sounds so to finish the game we simply have to import a few more sound files for that I want to copy the laser sound and get first of all the explosion sound which we getting from explosion. wav then I can duplicate this line one more time and we want to have a damage sound which is going to be damage do OG finally we have a game uncore music for which we will need py game. mixer. sound one more time the file is called gamore music. wav with that we have all of the sound files we just have to figure out when to play them the explosion sound I want to play when we have a collision between a laser and a meteor in here explosion sound. playay let's try and there we go this is working pretty well now alternatively you could also run explosion sound when we are creating an animated explosion inside of the thunder in it method and there we would get the same result just choose whatever you think is better it doesn't really matter both work just fine besides that we have the damage sound that we want to play whenever the player gets hit which happens in here although for this game once the player is hit the game is over anyway so we don't actually need a damage sound let's remove it finally we have game music this is the background music which we want to play right away I guess we can do it right after game music. although before we are doing that I think for the game music we want to set the volume to something lower let's say 0.4 let's try cool that is working reasonably well now before we are finishing the one last thing that I do want want to cover is when you are playing a music file you can specify the amount of Loops if you add a five in here you playing the music file five times and if you had a negative one in there you are playing it indefinitely which is what we want for the game music we have finished our first game and at this point you are aware of all of the main concepts of P game although there are quite a few more specific Concepts that we are going to cover for example for the next game we're going to add a camera and actual collisions along with a few more extra things that actually make a game all righty the second game in the series is going to be a vampire Survivor style topown shooter this project is going to be much closer to an actual game and there are a couple of key Concepts that I want to cover most importantly we have collisions and a camera those are essential parts that you basically always need besides that we will also cover creating levels in an editor in which we can move things around super easily that is going to make it much easier to build actual games finally we are going to work on proper animation control or in other words we going to take the basic animation logic and make it more sophisticated that way for example we can animate the player moving in different direction directions you will see later what I am talking about first of all though we have to set up the basics for that let's start with the project folder here we go there are four subfolders inside of the project folder audio is super simple this one is just a couple of audio files then we have the code folder and in there we have main.py and settings.py they don't do very much and we will have a look at them in just a second besides that we have data and images and those two folders are quite a bit more extensive inside of images for example we have the gun we have the enemies and those are always animations meaning we have multiple images that we have to import and also inside of the player we have the different states and then inside of each stage we have an animation of the player walking in that direction besides that we have a data folder and this one you don't really have to understand at the moment but in there we have Graphics maps and a tile set the map or world. TMX is what actually contains the level I will talk about that in much more detail later for now we have to create a basic game and what I want to have is a very basic setup in which the player can move around or in other words I want to have a spread class with one image for the player this one can be static for now and then the ability to move around which we're doing via input and a move method and at at this point this shouldn't be impossible meaning this could be an exercise right away I want you guys to set up the basic game which means I want you guys to create a player class with an imported player image that can walk around and this should be a Sprite also for the overall logic of the game contain all of this inside of a game class that way we can avoid Global variables also all of this should be inside of main.py I should actually demonstrate here we are in the code and there is main. pi doesn't do anything at the moment and inside of settings.py we are importing pame and we have a window whift and a window height use all of that inside of main.py to create the basic game setup pause the video now and see how far you get I want to start by creating a class called game no need for inheritance but we will need a thunder init method although without any parameters in there we want to run py game.it to initialize the entire thing and then create self dot display uncore surface which is going to be py game. display. set uncore mode that why we are creating the display surface inside of a class for the dimensions I want to have window WID and window height from settings. PI I suppose while we are here we can can also change the window title with py game. display. set caption I am going to call it survivor but choose whatever you like besides that we also want to have self. clock for the frame rate which we get with py game. time. clock and that is all we need to get started besides that I want to have a run method in there we are going to have a well true Loop or rather I want to have while self. running and this is what I forgot inside of the dunder init method self. running should by default be true and once we have that we will need Delta time we want to have the event Loop we want to update the game and finally we want to draw stuff first of all Delta time we're getting with self. clock. tick without any argument and divide it by a thousand that way we get Delta time in milliseconds for the event loop I want for event in py game. event. get at the moment I only want to check if the event. type is equal to P game do quit all in uppercase letters if that is the case self. running should be false that way we can close down the game and what is really important after we are finishing the while loop gr we also want to run py game. quit or the opposite of py game.it just to have a clean exit that was fairly easy and update for now we can simply ignore because we don't have anything to update inside of dwo we want to call pame do display do update or do flip both would be acceptable since we used update in the last game I'm going to keep on using that but you could use ior that is it now we have a game class and this we have to call I want to create one instance of the game class and then game. run if I now run everything we are getting a basic pame window so that is working really well yeah just one more thing that I do want to do over the course of this game we are going to create multiple files and I want to make sure that I only ever run this main.py file for that we can check if Thunder name is equal to this string Thunder main that way we are checking if the file is the current main file and only if that is the case do we want to run the code if I run all of this again this is not going to make a change and if you forget it it probably also won't be the end of the world but it's a neat Safeguard to avoid some potential problems we now have a basic game class after that we want to create the player and this I want to do in a separate python file which means inside of the code folder I want to create a new python file let's call it player dop in there I'm going to create the player class although first of all we will need from settings and import everything then class layer this has to be a Sprite this needs to be a Sprite or in other words we want to inherit from py game. sprite. Sprite after that we will need a Dunder init method with self I want to have a position and I want to have the groups next up we have to call super. Dunder init along with the groups once we have that self. image and self. rectangle for the image for now we can simply call pygame do image. load along with the join method for the path we want to go to images then we want to go to the player and I guess we can start with down zero. PNG so once again we want to go to images then we want to go to the player then we want to go to the downstate and finally 0.png also do not forget to convert Alpha all of this that way we have our player surface for the rectangle I want to get self. image. getet F rectangle and place this Center the position for this is what we're getting from the parameter also I realized there is a typo this should be pygame dos sprite. Sprite so with that that we have a player class this I want to use inside of main.py for that we first of all have to import it from player import the player class next up I want to create one instance of this player class and store it inside of self. player for that we will need player along with a position and a groups to start with the position I simply go with 400 and 300 entirely random positions this we're going to change later on anyway after that we will need a group which we don't have at the moment but I'm going to create one in just a second and call it all Sprites let's do it right away actually I want to have a bunch of groups later on although for now I simply want to have self. all Sprites with pygame DOs sprite. group and just to keep things a bit more organized I want to have groups Sprites and I also want to have a let's call it setup with that we have a couple of basic things after that before we are calling py game. display. update I want to get self. all Sprites and draw on self. display surface and I suppose while we are here we can also call self. all Sprites do update with Delta time I can now run the code and we can see the player it doesn't do anything at the moment but we have something so next up we have to work on two important things we want to get the input for now let me add pass in here and we want to have a move method with self and Delta time both of which are going to be called inside of the update method in there we're also getting Delta time I want to call self. input and self. move I am going to start with the move method just so we have something to look at I want to get self. re. Center plus equals self. Direction multiplied with self. speed multiplied with Delta time we do have Delta time but we don't have direction or speed those we have to create under m movement section self. direction is going to be py game. Vector 2 but now with a direction of one and zero that way we are going to the right self. speed is going to be 500 if I run main. Pi we have some movement although we can see the last frame to fix that before we are drawing all of the Sprites I want to get self. display surface do fill with a black color let's TR off this again and we get proper movement after we have that for the direction we should have Zer and zero by default which are the default values so I'm going to leave it empty and then I want to check for the input which is going to be a local variable pame do key dot get pressed don't forget to call this one and then we want to update self. Direction dox and self. Direction doy for X I want to get the integer value of these and py game. Kore right from that I want to subtract the integer value of py game. K under score left let's start by trying this one so self. direction. Y is going to be commented out inside of my Pi I can now move left and right so that part is working pretty well just as a reminder at this point P.K right and py game. K left are Boolean values they can never be true or false and in our case via integer we are turning true into a one and false into a zero if we then subtract one from the other we can check for both at the same time this is the exact same logic that we have inside of the space shooter and for self. direction. y we want to do basically the same thing so let me copy all of this and check for pame dok down minus py game. Kore up with that I can run main. pi and move in all four directions that's a really good start however if I move left and right we have one speed the same move up and down but if I go diagonally all of a sudden we are moving quite a bit faster that happens because we are not normalizing self. Direction which we can do fairly easily self. direction is going to be self. direction. normalize but this we can only do if the vector has a direction I.E we want to check if self. Direction has any value that's not zero and zero if that is not the case else we simply want to keep self. Direction and with that inside of main. Pi the movement is now constant or rather the movement speed is constant and that covers the exercise so by the end of it I have written 40 and 20 lines so in about 60 lines we have created a reasonable starting point for our game and I hope you could follow along I did speed things up quite a bit but for the mentally all of this is very similar compared to what we have done in the space shooter so if you get stuck on any of these topics definitely play around with them in your own time in this section we going to cover collisions which means by the end of it you can stop the player movement using some kind of object we are not really going to use proper Graphics just to keep it simple later on we can add all of that fairly easily first of all though we have to cover some basic theory about collisions and to most fundamental issue is that rectangles can only check overlaps meaning we know if there's a collision but we don't know what to do with it instead what we want for an actual Collision is that if there's an overlap I.E a collision then we also want to update the position of the player or in other words if we have the player overlapping with an obstacle then we want to move the player a bit further to the left so we are stopping at that obstacle since we can move all the sides of a rectangle this this shouldn't be too difficult however there is a bit of a complication the problem is that we do not know on which side the Collision happened for example if we have something like this we could have a collision on the right side of the player that seems to be the most obvious case however we could also have a collision on the bottom of the player on the top of the player or on the left side of the player all of those are equally possible for example for the left side case it could be that this player is moving really fast to the left and then within a single frame we are moving all the way over there which is entirely possible and simply looking at a single frame with a collision can be really deceptive which means first of all we have to get the Collision side that process is going to involve two steps first of all we're going to separate the dimensions we are moving and checking the collisions only on the hor izontal axis and then on the vertical one you could also do this the other way around the order here doesn't matter too much what matters is that we are only checking a single axis that way we only have to figure out if the player is to the left or to the right of the obstacle so if we have something like this at the moment we only want to know if the Collision happened on the left side or on the right side of the obstacle and the easiest way to figure this one out is to look at the direction of the player for example if the player moves to the right then we know the Collision must have happened on the left side of the obstacle or in other words if there's an overlap and the player is moving to the right then the Collision must have happened on the left side of the obstacle at least as long as the obstacle itself is not moving which we are going to assume for now and that's the basic logic we are simply checking if there's an overlap between two objects and on the moving object we're going to check the direction which is a very easy thing to implement but it's not without its problems the most important issue is that this approach only works if a single object is moving for example in this game the player can only collide with trees rocks and the hills all of which are static the player cannot collide with any of the enemies since those are moving the Collision logic would break for collisions between two moving objects we would need some more logic which we are going to implement in the next game that is going to be a pong game and in there we have a player padal and a ball both of which can move meaning in there we have to check collisions between two moving objects which isn't that much more difficult to implement but you do want to have some groundwork first anyway with that we have all of the theory out of the way let's do some coding although first of all back inside of the code we have a problem we only have the player and the the player cannot collide with anything to fix that inside of the code folder I want to create another python file Sprites dop I want from settings and import everything and then create a class let's call it Collision Sprite this also needs to be a pyam Dos sprite. Sprite for which once again we will need a thunder init method for which we are going to need a position size and groups super. Dunder init with the groups and then we will need self. image and self. rectangle the image is going to be pygame do surface and then we pass the size right through to make sure that we can see self. image I want to fill it with a blue color after that for the rectangle self. image. getet F rectangle in which we are placing the center with the position that would be a very basic Collision Sprite that we are going to use inside of main.py first of all from Sprites I want to import everything later on we're going to add a few more classes in there after that inside of thunder in it I want to create a random amount of instances of this class which we can do with a 4 I in Range Loop let's say I want to create six Collision objects and then I want to have a collision Sprite for which I'm going to need a random position and a random size let's call it position size and for groups we want to have self. all Sprites now to get random values I want from random import Rand in for the position I want to have an X and A Y local variable which we both get via Rand int for x is going to be zero all the way to the window Whi and for y it's going to be a Rand int from zero to the window he those numbers we can then pass into the position I want to have a tuple with X and Y after that I want to have a width and a height for this surface which I'm also going to create via random integer I guess the numbers here could go from 60 to 100 for width and for the height also random integer that side those from 50 to 100 entirely random numbers and later on when we actually import objects those are not going to be relevant anyway for the size I want to have width and height if I now run all of this we get a bunch of random objects somewhere on the window so that's a really good start although before we continue we we have to make sure that we have easy access to all of these Sprites for that I want to create another group self. Collision Sprites which is simply going to be pygame dos sprite. group every time I am creating a collision Sprite I want this Sprite to be in all Sprites and self. collision Sprites on top of that the player needs to know where all of these Collision Sprites are which means I'm going to pass self. Collision Sprites in there as an argument but now you have to be careful because those two lines do something fundamentally different inside of the Collision Sprite we adding the Sprite to two groups all Sprites and collision Sprites however for the player we are only adding the Sprite to self. all Sprites but on top of that we are giving player one more argument self. Collision Sprites but the player itself is not in this group it only has access to it and that should make sense we don't want the player to collide with itself that would just give us some weird Behavior so next up inside of the player we are going to need one more parameter Collision underscore Sprites that we also want to store under movement as an attribute itself do Collision Sprites is going to be Collision Sprites with that setup we can keep the Collision logic inside of the player or in other words inside of the player I can create another method let's call it Collision for which we will need self and we will need the direction or the axis that we want to work in this could either be horizontal or vertical although for now we are simply going to add pass in there because before we are going to write anything inside of collision we have to work inside of the move method at the moment we are updating both of the axes at the same time simply because we are updating the center via a Direction but this I want to split into horizontal and vertical movement which fortunately is very easily done I want to duplicate this line and then increase self. re. X and self. re doy self. r.x is simply the left side of the rectangle and self. directy is the top side of it to that I want to add self. direction dox for the horizontal movement and for the vertical One self. Direction doy if I now run all of this we are still getting the same kind of movement so at the very least we didn't break anything once we have that after we have done all of the horizontal movement I want to call self. Collision on the horizontal axis next up then we are going to do all of the vertical movement and then we are checking the vertical Collision that means we are first going to move on the horizontal axis the player either left or right after which we are going to check for a collision for example if this is our player we might have a collision here we now have to figure out if the player is to the left of the obstacle or to the right if the the player was on the left side of the obstacle and we have an overlap something like this then we want to resolve this collision by moving the player a bit further to the left to the left side of the obstacle but first of all for that we have to get all of the obstacles which we can do via a for Loop for sprite in self. Collision Sprites in there first of all we want to check if Sprite Dot wct . Collide rect along with self. rectangle if that is the case for now let's simply print overlap if I now run main. pi and I overlap with any of the obstacles we are getting overlap so that part is working pretty well but this is something we have already seen a couple of times so this isn't particularly special however what we can do instead of printing overlap I want to check if direction is equal to let's start with horizontal meaning we only want to check left or right collisions and in there I can check if the player is to the left or the right of an obstacle via self. Direction dox and if that one is greater than zero then I know the player is moving to the right which means for the Collision I want to get self. rec. right and set it to sprite. rec. left I can now run main. pi and if I am only moving to the right and do nothing else and I hit an obstacle the player stops so that part is indeed working the issue is if I do anything else or any other site nothing is going to work and if we are overlapping and moving to the right we are teleporting on top of that you might be wondering why is there such a big gap between the player and an obstacle so all of this that happens because the player image is quite large if you look at the project folder under images the player and we have down you can see there's a ton of white space to the left and to the right of the player that is necessary because when the player is moving left we are using some of that space for the lags and don't worry we are going to count for that in just a bit first of all though I want to finish up the Collision logic and also you don't have to write this if statement on one line it could also be something like this although since we are only doing a single thing I prefer to keep the if statement on a single line besides that we also want to check if self. direction dox is smaller than zero I.E we are moving to the left if that is the case self. rec. left should be sprite. w. right let's try that one I can now move to the left and if I collide with an obstacle the player stops the right side Collision also works just fine so I am quite happy with that definitely making progress and just to go over the entire logic one more time at the moment we are moving the player only left and right if this is our player at the moment we are only moving to the right after that we are checking for collisions meaning we are looping through all of the Sprites and then we're using a w Collision if that one triggers we could have something like this if that is the case we are checking one of two if statements one of those two in our case we know that self. direction dox is greater than zero because the player is moving to the right if that is the case we are setting the right side of the player to the left side of the obstacle or in other words we getting this side and setting it to this position I.E we are moving the player a bit to the left and that is literally all we do with this system we have basic collisions and well the same thing we can do in an El statement for the vertical movement I simply need to check if self. Direction doy is smaller than zero if that is the case we're moving up and if there's a collision self. re. toop should be sprite. re. bottom then we can duplicate all of this because next up I want to check if self. Direction doy is greater than zero in other words we are moving down and if there's a collision I'm going to set self. re. bottom to sprite. re. toop and that is all we need for the collisions on all four sides if I now run main. Pi we're getting a collision on all of the sides and this works super reliably so very happy with that this would also work with two collisions at the same time let me try this again so there you can see we have two obstacles at the same time I cannot move to the right and I cannot move up so this part is working perfectly fine great with that we have basic collisions however we are not done yet because at the moment our player has a shape that's roughly like this or in other words those are the visible pixels but the entire surface is this large as a consequence we do have a bit too much white space to the left and to the right of the player this I don't like and want to remove which we can actually do fairly easily at the moment our collisions are done via the rectangle which is going to have the same size as the image which is not what I want I want to create self. hitbox uncore rectangle which is going to be self. wct do inflate at the moment we only want to change the Wii let's say by minus 40 for now the height we can keep so this one is going to get a zero with that we have a hitbox rectangle this is what I actually want to use for the collisions and to use it we have to update the move method and the Collision method or in other words we first of all want to move the hitbox rectangle both on the horizontal and on the vertical axis after that we want to set the center of the rectangle to the center of the hitbox those two always have to keep the same Center positions besides that for the collisions we want to check with the hitbox of the player instead of the rectangle of the player and all of this is going to be your exercise so what I want you guys to do is to implement the hitbox logic for the collisions pause the video now and see how far you get back in the code first of all we have to update the movement because we only want to move self. hitbox rectangle on the horizontal and on the vertical AES now this code wouldn't crash but now we do not get movement anymore simply because the Sprite is drawing the image wherever the rectangle is and we are not moving the rectangle anymore to fix that I want to set self doir do Center to self. hitbox rectangle do Center since we are not checking for collisions with the hitbox rectangle inside of main. Pi the player can simply walk through all of the obstacles to account for that inside of collision we want to check if sprite. rec. cidere and self. hitbox rectangle on top of that if there is a collision so for example on this line we don't want to update self. rectangle instead we want to update self. hitbox rectangle that we want to do for all of the rectangles if I now run may not p again I get proper Collision logic again and now the player gets much closer to these obstacles especially when we are comparing this to the original it looks much better although there's still a little bit of a gap that we can now fix with this inflate method let's go with 50 and we are getting closer but there's still a bit of space between them maybe 60 is the right number number and there you can see now we have a Pixel Perfect Collision or well not exactly Pixel Perfect because we're not using a mask but it looks good to the player and that's really all we need so with that we have basic Collision logic something really important for any kind of game and fundamentally we are really not doing anything too complicated so the entire Collision logic took maybe 10ish lines to right we are simply getting the player rectangle and then setting it to to one of the sides of the obstacle and to know which side we are working with we are checking the direction the player is moving in and that is literally it it is time to import the level data by the end of this section we have some actual stuff in the game that is nice to look at although for the full effect we are also going to need a camera which we don't have yet that is going to be the next section anyway to create a preper level we are going to need an editor that will be can place images and see the result right away and there are quite a few different level editors but one of the really popular ones is called tiled that you can get at map editor. org I have used this one for a whole bunch of projects it's entirely free and really nice to use and the files you create in tile can also be imported into pame super easily that being said for this video I will only cover how to import tile Maps I will not cover how to create them if you are interested in that check out my dedicated video in there I cover all of the details of tiled including how to create a map anyway if you go to map editor. org you can see tiled if you go down a bit you can also see a couple of games that have been using it I guess the really famous one is Shovel Knight there's also axom Verge and Carion all really good games in our case though we simply want to download on itch.io there you can click on download now and you could set a price but you don't have to you can simply go to no thans take me to downloads and then you can download the version that works for your operating system in my case I'm working on Windows but if you have Mac or Linux go with the other ones then you have a download after that part is done you want to open the file and simply click on next and agree to everything and then you should be done afterwards you can launch tiled if I click on finish then we are getting getting to something like this this is the titled editor in there you could create a new map or a new tile set what those words mean you are going to see in just a second in fact I think the best way to approach this is to look at the project folder so in there we have a data folder which contains Graphics maps and tile sets the main thing that you want to work on is a map and there you can see we have a tiled symbol that should also work for you if you click on that one you can see a tille map so the main thing you see on the window is the map that we have created and this is going to be our actual level on the right side this bottom area this contains the tile sets and at the moment I have two a world tile set and on there if you hold control and use the scroll wheel you can zoom in and out one tile set is going to be all of the graphics the other tile set objects simply contains a whole bunch of objects like trees and pillars and rocks and besides that we have a whole bunch of layers the bottom one is ground then we have entities collisions and objects so how does all of this work for that let's have a look at the project folder we have three main components Graphics maps and tile sets the way those are going to work is that we are importing all of the graphics into tiled if you open this one you can for example see on the tile sets we have the world tile set the one you have just seen Under World tile set on top of that what tiled is doing it is separating this graphic into individual tiles one would be this one the next one would be this one then we have another one here and so on we are simply separating the graphic into smaller bits and these smaller bits are effectively a tile set or in other words if I go back to data we are importing the graphics and storing them as a tile set that way we can pick one part of the graphic and then this tile set is going to be used inside of a map to create a new kind of graphic or in other words if I had back to tiled and I have the ground layer selected if I now select one of these tiles I can go to the map and zoom in and simply place them as I like I can also select multiple and place them in there and that is how you create the entire map for this entire thing I spent about half an hour laying out all of these parts and that way we have created a tile map which is what we actually want to import into P game and in the most basic sense that's all you have to understand about tiled although I guess there's one more thing that you want to keep in mind there are two kinds of layers that you could be working with inside of tiled what I have covered so far is a tile layer and this you can see via this grit symbol that means we have a tile layer besides that we can also have an object layer those have these pink speech bubbly kind of looking things those work in a very similar way but there are some key differences for example if we are looking at the objects those would be all of the trees the pillars and the Rocks the main way those differ from the tile set is that they can be placed freely anywhere on the map while a tile set always has to conform to a grid so I can only ever select one of these grid positions I cannot go outside of it also when we importing all of them into pame they do work just a little bit differently ultimately for all of these objects the way you want to approach them is that if I go to the top left we have a whole bunch of ground tiles all of those they're all grass then we have an object that one is simply a tree or rather a couple of trees and those for now we want to import which means inside of py game we want to get the ground layer and the objects layer collisions and entities we are going to ignore for now and for all of these objects if you look on the left there here we have properties for example if I am clicking on the tree we have an X and A Y position so if I'm moving this tree you can see this position is updating we also getting a width and a height and all of these numbers we can use inside of py game and for the ground let me hide all of the other stuff for all of the tiles for example for this top tile we have three major attributes that we care about we have an X position a y position and a surface the surface for basically all of those would be a plain grass tile but for example for this one here we have mostly grass but then also a corner for the stone besides that we have a position but the position is on a GD meaning for this top tile the position would be zero and zero and if you go one tile further to the right the position would be 1 and zero really important to understand here is that we are not working with pixel positions or in other words when we are importing all of this into pame we have to convert a grid position into a pixel position which arguably is fairly simple all righty but with that we have another question how can we import all of this into py game that topic you could approach in two ways number one you could export all of this as a CSV file here's also Json or good scene and Via that you could import them into other programs while that's possible it's also quite a hassle so not something I would recommend what is a much better way is to use a python module that does all the work for us for that you want to open the terminal and then type pip install P TMX then python is going to load something for a second and then you have py TMX a module that can import TMX files super easily and with that finally we can start working inside of pame first of all we have to import the PMX module although we don't want all of it we simply want from PMX do util uncore py game and then import load py game via this method we can import a TMX map and then use it inside of the code and I suppose for all of that we can create a separate setup method without any custom parameters and first of all I want to import the map which we are doing via load pame after that for the path we want to go to data then to maps and then to world. TMX or in other words we want to use the join method then go to data after that we have maps and finally we have world. TMX once we have that let's print the map and after we have covered all of the groups I want to call Self do setup if I now run all of this we getting the game although we don't care about that at the moment and then we are getting a tiled map if you get anything else something has gone wrong so double check your steps now on this map we want to access all of the individual layers for example we want to get the ground layer or the objects layer and later on also the collisions and the entities layers for that we want to get the map and then get layer by name that is the most common way to access one of the layers after that we're going to need a name and for now I want to look at the objects layer the layer inside of tiled that contains all of the trees all of the rocks and the pillars and stuff like that inside of this layer we have a whole bunch of indiv ual objects all of which we can access via a for Loop for obj in map. getet layup by object name and inside of this thing you can now print obj dox obj doy and obj do image to get the X position to Y position and the surface which means if I run all of this now we are getting a whole bunch of data and that is looking pretty good all we have to figure out now is how to turn this data into a Sprite Which we can do easily because under Sprites we already have a collision object this we simply have to modify a bit we want to keep a position but instead of a size we want to have a surface and then when we are creating self. image we want to use that surface we don't want to fill the image anymore but we want to keep self. image. getet F rectangle after that we don't need this for I in range six for Loop anymore let me get rid of it entirely instead inside of the for Loop forget layer by name I want to create a collision Sprite for the position we will need obj dox and obj doy both of those have to be inside of a tubow after that we are going to need a surface which is obj do image finally for the groups self. all Sprites and self. collision Sprites and with that if I run all of this you can see we have a whole bunch of trees and since the player collided on a collision object we get some weird Behavior but that's totally fine that we can fix by changing the starting position of the player to 500 if I now run all of this again we can see that the player can move around and we have a whole bunch of trees so that is working really well we are also not needing the print statements anymore and that covers the first part besides that I also want to import the ground layers or in other words I want to only look at the ground layer at the moment and this is working a bit different because remember now we are working with a tiled layer whereas objects was an object layer now to use a tiled layer we we are still going to use map. getet layer by name and the layer we now want to get is called ground but after this one we want to add dot tiles that way we are returning the tiles and make them a bit more accessible or in other words when we are using the for Loop we can use 4 x y and let's call it image in map. getet layer by name and after that I can print X I can print Y and finally I can print the image if I now run all of this we are getting a huge amount of data we're getting for example 51 and 49 this is the X and Y position on the grid it is not a pixel position and then we're getting a surface and that's really all we need that being said for the ground we want to have another kind of sprite because those Sprites should not be collidable or in other words inside of Sprites dop I want to create another class called Sprite this one is also going to be pygame dos sprite. Sprite and then Define Thunder init for which we are going to need self a position a surface and the groups and Well for now this Sprite class is going to be basically identical compared to the Collision Sprites so I can simply copy paste the lines and then we are good to go then inside of main. Pi we want to create one Sprite for now with the X and Y position after that for the surface we want to use the image and for the groups we want to use self. all Sprites that should be all we need to get something and well if you now look in the top left there we do have some weird thing that is because we use the X and Y position from the grid meaning all of the numbers are way too small to fix that we have to multiply all of these numbers with the tile size the top left Tile For example would have a grid position of 0o and zero and we know that the width of this tile and also the height is both 64 but then for the next tile this one here we have a grid position of 1 and zero the top position is simply going to to be zero however for the left side this one here we want to have 1 * 64 that way we are getting all the way to this point and by the way the tile size you can set when you are creating a map but this you want to plan out so when I got the graphics I checked what kind of tile size we had this is really important to know before you are starting although in our case under settings we have a tile size this we can simply use or in other words when we are getting the position for the Sprites I want to get X and Y and then multiply it with the tile size if I now run all of this we can see that we have the proper level although all of the objects disappeared but we still have collisions so what happened well this is an issue we had earlier when we are drawing all of the Sprites we are sorting these Sprites by the time of their creation and and since we are creating all of the Sprites after the Collision objects they are being drawn on top that is a very easy thing to fix we simply want to create all of these objects after the Sprites if I now run all of this again you can see that we have something much better looking and the collisions also work reasonably well so I am mostly happy with that that being said if you compare this image at the moment with what we have inside of tiled the objects don't line up exactly I guess a really good way to illustrate is if you look at this tree how it relates to these rocks the top of the tree is basically right around this corner but inside of the game this is looking different so what happened the answer to that is fairly simple when we are placing a collision Sprite the position that we are placing is the top left if I now run m.p again this is looking looking much better although it's not perfect yet if we are comparing all of this to tiled and pay close attention to the top of the tree and the corners of the stones if I run the game again you can see quite well that this isn't what we are getting that is because when we are placing all of the background Sprites we are placing the center but when we are placing the objects or in other words the Collision Sprite we are placing the top left position in other words we are placing a different position now generally when you're getting anything from tiled you want to place the top left position if you do that and run all of this again now this is looking exactly like what we have en tiled but anyway at this point you should be confident to import tiled layers or object layers from tiled Let's do an exercise I want you guys to import the Collision layer from tiled and then create invisible Collision objects from the rectangle on that layer or in other words here we are back in tiled and I want to look at the Collision layer if I make this one visible you can see that we have a whole bunch of rectangles those basically Define the environment or the collision with the environment I want you guys to import all of those and then create a collision object that the player cannot see simply because we already have the Graphics from the tiled layer and a minor tip for this one when you're importing objects in py game you can get the Whi and the height quite easily you also get with wift and do height and also in the code you can reuse the Collision Sprite for all of that pause the video now and see how far you get I want to have or obj in map. getet layer by name and and I want to look at the collisions layer since this one isn't visible it doesn't really matter where you put it it could be before or after the other four Loops it's entirely up to you in there we want to create a collision Sprite for which we are going to need a position a surface and the groups the position is super easy we simply want to have obj dox and obj doy for the surface we kind of have a problem because because when we imported all of the objects we got obj do image but this we cannot use for this for Loop simply because we are importing rectangles or in other words if I comment out this line for now and then print obj do image and run the code we are simply getting a whole bunch of none which means obj do image isn't a good way to approach this however what we can do is create pame do surface and then create a surface with the size of these rectangles that is possible because we can get the width and the height of all of them via obj do width and obj do height finally then we want to create the groups and in my case I only want to get self. Collision Sprites that way the player can collide with them but they are not visible if I run all of this now I can try to go down but I am not able to go to the cliff also if I go to this Stony Hill thing like so the player has a collision and this is working really well although for this part I was a bit lazy because when you look at these Collision layers you can see they don't really line up with the cliff graphic that is because later on we will spawn the player inside of this Center area and then the area around it is sealed off meaning this area around here is never going to be reachable by the player so it doesn't really matter how large these rectangles are on the left side of the cliff at least on this side unfortunately we cannot place the player in there yet because we don't have a camera so there wouldn't be any point to it that we can work on next but for now we have made some pretty solid progress and now we are able to import stuff from til now that we have a level we can work on a camera by the end of this part we have a proper level that the player can explore makes the entire game feel significantly better for that though we have kind of a problem at the moment that is that we can only see things that are on the display surface or other words if this is our display surface and so far our window at least in my case was always 1280 by 720 on there we have a player and we have a bunch of objects however ever what happens when we have an object outside of it what do we do then or in other words at the moment we can only see things that are between the positions Z and zero so the origin point and the bottom right or the window width and window height for example in our case the top left position of this object might be 1400 and 100 for X and Y this at the moment would not be visible how can we change that and first of all for that we have one major limitation and that is that the display surface cannot be changed it always starts at zero and zero and then continues to the display Dimensions I suppose you could resize the window But ultimately that doesn't help you very much instead to create a camera we have to change where all of the elements are drawn and to understand how this is working let's look at the display surface again and one more time we have a whole bunch of objects and one object outside of it now what we cannot do is move the entire display surface to the right to make it visible that is simply not possible but what we can do is the opposite we can move all of the other objects in the opposite direction and when I say move I am a bit incorrect here because we are not moving anything what is really important to understand is that the position of the Sprite or rather direct inside of it does not change the only thing that changes is that we are drawing things in a different position if we change the position of the rectangles our Collision logic would stop working so this is not something that we can do so the question then is how can we draw stuff in a different position and for that we can customize a Sprite group or more specifically the drawing logic of a Sprite Group which actually is quite simple because because all that is happening inside of group. draw is a for Loop that blits all of the Sprites on the surface or in other words we are looking at all of the Sprites inside of the group and then we're doing surface. blit with sprite. image and sprite. rectangle that's all that's happening in there so let's play around with that once again here we are in the code and at the moment we are drawing all of the Sprites via self. all Sprites or in other words inside of the run method we calling self. all Sprites DOD draw with a Target surface which in our case is the display surface this we want to change and for that I want to create a new python file which means inside of the code folder I want to create let's call it groups. Pi first of all we're going to need from settings and import everything after that I want to create a class called all Sprites which has to en it from pygame dos sprite. group and for now all that we are going to do in here is Define Dunder init with self and nothing else and then call Super do Thunder init that way we have a copy of a Sprite Group which we can use inside of main.py I want from groups import all Sprites and that I can use to replace this py. sprite. group if I add all Sprites in here and run the code we are getting the very same outcome which should make sense we are basically just wrapping the basic pyam group inside of another class although with the setup we can customize things but first of all let's recreate the original functionality of this group for that we will need Define draw with self and some kind of surface that we want to draw on if I add pass in here for now we are not going to see anything because we are now overwriting this draw method and since we are not doing anything we cannot see any surfaces to get that functionality back we want for sprite in self that way we can access all of the Sprites inside of this group and then we want to get a Surface and call the blit method with sprite. image and sprite. rectangle after we doing that we can see the game again and it works just as before that part was actually fairly simple I suppose one thing that we could be doing to simplify this code just a bit is that we always want to draw on the display surface so adding this argument here doesn't really make sense instead inside of Thunder AIT of all Sprites I want to get self. display uncore surface and then get the display surface which we can get via py game. display. getor surface that way you are getting the display surface from anywhere inside of the code and that we can use inside of the for Loop self. display surface. blit because of that the parameter surface is not needed anymore and inside of main. Pi we don't need the argument but we can run the game and everything works just as before we have now created a customized drawing method and this we can push much further because what you have to understand is that when we are calling the blit method we are placing this surface in the position of this rectangle and as a reminder we are basically always placing the top left position of the rectangle so if I run m. Pi again once again the same result but what we can do now to the top left position of the rectangle we can add and offset via a vector 2 for example in there I could add 500 and 100 inside of the game now we are drawing every single element at an offset or in other words from the top left we are 500 pixels to the right and 100 pixels down and really important this is just where elements are drawn the actual position of the rectangles has not changed which means if I move around the collisions work just as before and let me get to a better position there you can see I have a collision with a tree and this works perfectly fine so the main thing you have to understand is that inside of this logic when we are drawing the rectangle we are simply adding a vector two and to create a camera we simply have to customize these numbers for that I want to turn the vector into an attribute self. offset which is going to be pame do Vector 2 by default with zero and zero and this offset I want to use inside of the blit method self. offset on top of that when we are drawing everything I want to have a Target uncore position which we are getting inside of draw from self. player. re. Center this is the position we want to follow or in other words the camera should follow the player once we have that we want to get self. offset dox and later self. offsety as well but for now let's only do one dimension I suppose for now let's simply start with Target position and zero if I now run the code you can see that we get some movement and the issue here is that well the camera movement and the player movement go in the opposite directions if the player moves to the right the entire entire thing is drawn further to the left to flip that around we simply want to have a negative number if I now run main. Pi we are getting something so now the player is always on the left side of the window so essentially what is happening now is that we are getting the origin point from the offset of the player and then from that we are adding the top left of the rectangle that way if the player gets f to the right we are drawing everything at that offset but we don't want the player to be constantly on the left border and for that we want to add another value which is going to be window wift / two to get that we want to subtract window wift divided by two and also we want to apply the negative value to the entire thing if I now run main. Pi we have the player in the center and we have a camera so that is working really well although we are not covering the vertical axis which fortunately is fairly simple we simply have to duplicate this line and then change self. offset doy to Target position one and then minus window uncore height with that we have a camera and I can explore the level although the Collision is a bit wonky but we're going to fix that later on as well other than that though the player can explore the level and we are nearly there we're going to cover the starting position of the player in just a second but for now this is all you need for a basic player camera where you place the top left of the rectangle and then you add an offset the offset you're getting from the position of some kind of Target this is almost always going to be the player so next up we have to work on the starting position for that inside of til we we have another layer called entities on there we have a whole bunch of markers and let me hide all the other stuff there you can see on entities we simply have a whole bunch of markers that's all we do in here and if you look at one of those this one for example we have an X and A Y position and that is about it however if we look at this marker we have a name and that is player which means that this marker is supposed to be the starting position position of the player and all of the other positions are going to be starting positions for the opponents that we cover later first of all though back inside of main.py in the setup method I want to add one more for Loop and I think generally a bit more white space in here would be quite nice I want for obj and this could also be marker markers are just other objects the name here doesn't really matter so much and I want to keep it consistent so for obj and in map. getet layer by name we want to look at the entity layer and for now let's simply print the object that we are getting if I run the game we are getting a whole bunch of tiled objects some of those are called none others are called enemy and then we have a player all the way in the beginning or in other words if you look at til this one was the starting position for the player then we have add a non value here and here and none just means we have no value for the name but if I click on this one we have enemy and the issue why we have some nonv values is because I forgot to add a name but that is quite easily fixable if you go to objects there you can see all of the objects on that layer and I simply forgot a couple of those and that you can fix quite easily by selecting all of them and then change the name to enemy after that we have a much better system where we have a marker with enemy or a marker with player and that name we can access I want to get obj do name I can run this again and now we are getting lots of enemies and one player at the moment we only care about the player because that we can use via if objname is equal to player and if that is the case we want to create one instance of the player that we have so far done inside of Thunder init and then create that one in there because of that we can use obj dox and obj doy for the position once we have that we are getting an error that game object has no attribute player the reason for that is that this if statement never triggers because the name of this object is player with a capital P if I now run this again we have the player in the proper starting position and now we can can actually move around properly and we have something that looks much much nicer this is getting very close to an actual game so quite happy with that however there is another issue and that issue is called wise sorting you might have already spotted that in the game basically if there are overlaps between Sprites you want to make sure that the right one is on top for example what we could be having is the player being behind a tree which does look right but you could also have something like this where the player is below a tree and this doesn't look right anymore instead we want to have something like this and in our game it needs to be possible for the player to be behind a tree and in front of a tree and more generally if I run the game and you look for overlaps for example there you can already see one where we have the pillar thing being on top of the tree that just doesn't look good also we have another tree here that has the shadow on the other tree the reason why all of this is happening at the moment is because we are sorting all of these Sprites by the time of their creation this does work for the background Sprites because those are always supposed to be in the background but for the actual objects like the trees and the rocks and the pillars we can't rely on that logic anymore or in other words in our case the player since we are creating this one last is always going to be on top of everything else but sometimes we want the player to be behind other things and to make all of this a bit more visible when we are creating the player at the moment the hitbox covers the entire width of the surface this is not what we actually want we do want to have some vertical overlaps to get those let's change the inflate method for the height to 30 if I now run main. Pi I can let's try this one I can move on top of a tree or I can do something like this where the player is slightly in front of that palm tree this is still not that much of an effect so let's go with 60 here as well if I now run this again and let's get the proper effect that we want if I'm in front of a pillar you can see that the player's overlapping so it looks like the player is actually in front of it which is the effect that we want however if we are behind it then the effect bre breaks really really fast so how can we get that effect and basically you want to sort all of the Sprites by the center white position which means for the tree we always have one Center position roughly here and then if a Sprite has a lower Center y position for example for this player let's put some values on it this could be a center y of 100 while the tree has a center white position of 150 since 100 is the smaller value the player should be drawn behind however then for these other Sprites we're getting a center y value of 200 and since that value is greater than 150 the player should be drawn on top with that system we are avoiding this situation and implementing all of this is actually really simple you are simply going to need a sord method and I think you could figure this one out on your own so I want you guys to implement the Y sort system or in other words use the sort method to sort all of the Sprites when they are drawn by their Center White position pause the video now and see how far you get and don't worry if you can't figure this one out on your own it does get a bit more advanced back in the code I want to look at the groups because we are drawing all of the Sprites inside of this four Sprite in self a loop and we want to sort all of the Sprites which means this self needs to be inside of sorted but this at the moment is not going to run because we cannot compare different Sprites they are simply too complex to get around that we have to set a custom key and for that key we will need a Lambda function with one parameter which I usually call Sprite after that we simply need Sprite do Rec do Center y if I now run M note Pi we are getting something really really strange the issue now is that we are sorting all of the Sprites via the center wi position and don't worry I'm going to explain this line in just a second first of all though let me hide the background Sprites I can simply comment them out and now this is working a bit better and if I look at this pillar now the player is in front of it and if the player is behind it the player is actually behind it and all that is happening now is that we are always comparing the center position of the player with the center position of the Sprite whichever is greater will be drawn later and this is dynamic at the moment the center wi position of the player is below the Sprite and now it's on top hence the player will be drawn on top this system works for all of the Sprites so if we're going to this pillar you can see it is now behind the tree which does look a lot better if we we add all of the Sprites they mess this thing up quite a bit because they are also included in the system or in other words we have to make sure that we are excluding the ground Sprites from the Sorting logic first of all though let's talk about the sorted method basically what it does is it looks at some kind of list in our case that is self or a list of all of the Sprites inside of this group and then it goes through every single one individually and it wants to sort all of these values from the lowest to the highest value but that's not possible at the moment because if you have five different Sprites it doesn't know how to sort them and for that we have the key essentially sorted puts every single Sprite inside of this Lambda function and then via this Lambda function we are extracting one value from the Sprites which is returned automatically and that way we are getting a value that can be sorted the center wi position of all of the Sprites if you worked a little bit with a sorted method it should be fairly straightforward although if you haven't this might be a bit confusing so definitely experiment with this just a bit anyway to make the system work properly we have to exclude all of these Sprites for that I'm going to give them another attribute self. ground and this one is going to be true after that when we are drawing everything I want to get the ground Sprites and then let's call it the object uncore Sprites to get the ground Sprites I want to use list comprehension with Sprite for sprite in self but I only want to get a Sprite if they have the grounds attribute which means if has attribute I want to look at the Sprite and the attribute ground for the object Sprites I simply want to get all of the other Sprites which means if not has attribute and then Sprite and ground after that we want to go through both of these lists which we can do with another for Loop or layer in the list round Sprites and object Sprites and the order here is really important inside of a for Loop you always start with the first item then you go to the second one and so on and in our case we always want to start with the ground Sprites after we have that I want to do the for Loop for the actual Sprite drawing and then instead of self I want to get the layer if I now run main. Pi again we have the background always in the background and the logic for the Sorting still works just fine so the player can be behind a tree and in front of a tree this would also work on a pillar so there we have both sides and everything else still works just fine so I am very happy with that although I feel like inside of the player we could subtract an even larger number let's say minus 990 if I now run this again we should be getting a much greater overlap and we do this is actually much much nicer so quite happy with that now the game is feeling much more threedimensional and on top of that we have a proper camera so with that we have another really important part of the game next up we have to work on the proper animations of the player with that it looks like the player is actually walking around now we have already seen basic animations and we are going to keep the basic logic or in other words we're going to import images and then update self. image inside of a Sprite however we need to add State Management for example if if the player is moving to the right then we want to play the right animation frames on top of that if the player stops moving then we want to stop the animation and I think looking at the project folder is going to help a bit here if we go to images and the player there we have the four different states for example if I click on right we have four frames with the player walking to the right and in practice for self. frames we're going to have a dictionary where we have a state and then the value is a list of surfaces the states could be left right up and down after we have that inside of animate we have to get the state first and then we updating self. image with the surfaces first of all for that though we have to do a couple of imports and for that we have an issue because for the player we have to import quite a few things so for each folder we have four different surfaces and that we want to import all at once and want to avoid importing all of this manually back in the code I want to work inside of player. piy and let me minimize everything there we go to get started we want to import all of the surfaces for the player and that I want to do in a separate method let's call it load images no need for custom parameters and in there we want to create self. frames which is going to be a dictionary with four key value pairs we have the left State and the associated value for now is going to be an empty list this we want to duplicate three times because the other states are right then we have up and we have down really important at this point the names of these Keys have to match the folders inside of the player because in just a second we are going to use them for the path essentially we want to look at the player folder and then go over all of the sub folders for that we will need another python method that so far we haven't seen yet or rather you have seen it but I didn't talk about it if you go to settings there we have from OS import Walk and Walk is allowing you to well walk through a folder the way you're using walk is you call Walk and then you have to insert a file path which we are also going to do via the join method I want to go to images and then to the player after we have that I want to print the result although for that to work we have to call the load images method which we need to do before we are creating an image self. load images and now let's run main.py and we are getting a generator object not particularly useful but what we can do is to wrap all of this inside of a list function that way we can see the content let's try it again and there you get a list with a whole bunch of information I think to see all of this a bit better inside of player let's put all of this into a for Loop or in other words I want to cut out the walk method and then do for info in walk inside of that we are going to print info if I now run m.p we are getting something much more readable we are getting five tbil returned and the first value that we are getting returned is just a little bit different compared to the other values although generally you always getting three values returned the first one is the folder path you are currently in the second value is all of the sub folders and the final value are the file names so basically what is happening here is the first entry that we are getting is the parent folder or images and player in there we have to sub folders down left right and up and no other actual files like pgs for example after we have that we are going through all of the subfolders which means we have down left right and up in all of those folders we don't have any subfolder which means the second value is an empty list however the third value is going to be all of the PNG files in this folder although I should be specific here we are not getting an actual file we are simply getting the name of one so how can we use that to actually import all of the data and first of all we know that we are always getting three values returned we are getting the folder PA we are getting the subfolders and finally we're getting the file uncore names and in our case we only want to look at the folders with actual file names which means if file names that way we are ignoring the parent folder or in other words we are looking at down left right and up if that is the case I want to look at all of the individual file names for file uncore name in file names if I print that file name and run main.py you can see that we are getting zero PNG one PNG and so on those are all of the file names and if you combine that with the file path you can get the full underscore path for which we can use the join method once again I want to combine the folder path with the file name the return value if we approve printing full path inside of main.py is going to be the proper path to all of these files and that we can use to import a surface all we need is py game. image. load along with the full path and then convertor Alpha that would be giving us a surface but so far this isn't useful because we have to get the surface into the appropriate list so how can we combine this dictionary with this this for Loop and well we simply need another for Loop for state in self. rams. keys and as a reminder the keys of the dictionary are going to be the states of the player left for example is the left Running Animation after we have that I can indent the inner for Loop and then update the join method we want to go to images player and then get this state the one that we getting from the dictionary once we have that we can get self. frames along with the state and then aend the surface to the list at the end of all of this I can print self. frames and if I run the game we are getting a dictionary where we have a state for example left and then the associated value is a list with a whole bunch of surfaces that is all we need for the import although sometimes you do want to be a bit careful here when you are going through the file names you are not guaranteed to have them sorted which is really important for an animation or in other words when you're looking at these animations let's say for right again we always want to start on zero then go to one then two then three and then so on you really want to make sure that these are sorted from the lowest to the highest value if that isn't the case you're going to get some really weird Behavior fortunately in our case we know how to sort things so when we getting these file names we want to sort them for which once again we are going to need a key because remember inside of file name we getting something like the string z.png and we want to extract the Zero from that which means for the key we want to have a Lambda function with a name and on this name we want to split it wherever we have a DOT that way we are separating the actual file name from the file ending and we only care about the name so index zero all of this we want to convert to an integer that way the string one or string two would become an actual number that can be sorted now the result in my case is not going to be visible but it is a good Safeguard so I would always recommend to include it anyway with that we have covered the import next up then we can actually create an image for that though we will need self. State and we will need self. frame uncore index the state for now can simply be down and the frame index is going to be zero finally then we can create let's do it right before the update method Define animate with self and Delta time there are two things we have to do in here number one we have to get this state number two is the actual animation and let's start with the basic animation I want self. frame index plus equal some kind of Animation speed let's say five multipli with Delta time after that self. image is going to be self. frames then we will need self. State and on that we can call integer self. frame index with modulus of length and self do rames with the same self do state that should give us a very basic animation although we have to make sure that we are actually calling self. animate with Delta time if I now run may. Pi we're getting a down walking animation all we have to do now is update self. state to get a different kind of animation for example if I set the starting state to right and run this again now the player is walking to the right for that we have to cover this state the way you want to think about it is how do we know if the player is walking to the right and in my case I know that from the direction so if self. direction dox is greater than zero we know the player is walking to the right or rather the way I am approaching this is if self. direction dox is different from zero then I want to get self. State and set it to right if self. direction dox is greater than zero if that is not the case else it should be left with that I can go right I can go left and we get the proper animation that is looking pretty good the same thing we can also do for the vertical movement I simply want to duplicate those lines and then check for self. direction doy and self. state is going to be down if self. Direction doy is greater than zero if that is not the case we are going up let's TR this again and now I can go in all all four directions that being said there's one limitation at the moment that is that the player never stops walking so even without any keyboard input the player is walking to the right and if I go around and stop moving the player keeps on walking and fixing that is going to be your exercise I want you guys to only display the first animation frame if the player doesn't move really important here keep the current Direction so if the player has has moving to the right and then stops the player should still face to the right but not animate anymore pause the video now and see if you can figure this one out on your own all righty let's try together now and the way I started is that we know we only want to update the animation if the player is moving or in other words frame index should only change if we have a direction which means instead of adding some animation speed and Delta time I want to get self. frame index plus 5 * Delta time so far no change but then we can add an if statement that we only want to do all of that if self. direction is the case if that is not the case else frame index should always be zero that is actually all we needed I can now walk around and if I stop moving the player doesn't animate anymore and this works pretty well and by now our player is actually becoming a fairly complex class so we have 65 lines of code and we are doing quite a few different things but fundamentally for example for animate there isn't really anything too complex in here we are simply checking if the player's walking left or right then we are looking at the frame index and updating it if the player is moving or setting it to zero if he is not finally we are updating the image with the frame frames the state and then the frame index I hope none of this is too complicated I suppose the one slightly challenging part is going to be the import so I hope it still made sense if you're massively confused let me know in the comments next up we have to add the gun and fundamentally this isn't going to be too difficult we simply have to float a Sprite around the player and then rotate it that's kind of the basic idea but the details can get a bit more difficult let's go through it one by one in the most basic sense the gun is just another Sprite that rotates around the player the only really difficult part is to get the angle or in other words we want to get the angle between the player and the mouse however the mouse position is always going to be on the display surface so in our case between Z and zero and the display width and height the player on the other hand isn't linked to those Dimensions anymore because of the camera as a consequence we would need to do one of two things we could either get the offset of the camera and include that in the calculations which would be possible but kind of a headache instead what is much easier is to use the fact that the player will always be in the center of the window because of that if this is our display surface we know that the player is always right in the center so all we need to know is what is the relationship to the mouse to this point are we up here are we here are we we here are we here and we always want to know what's the angle to the center of the window that is actually all we need to know for all of that I want to work inside of the Sprites minimize the other classes and then create another class called gun which also needs to be a pame Dos sprite. Sprite we will also need a thunder init method with self the play player and the groups I suppose to get started we want to have the player connection for that we want to store self. player which is going to get the player then we will need a distance to the player which I have set to 140 next I want to have another attribute called player uncore Direction which is going to be a vector 2 with a default direction of one and zero this value we going to update later it's basically going to be the direction from the gun to the player this will be super important to rotate the gun but first of all we have to set up the Sprite so Sprite set up and in there super under init with the groups besides that we want to have self. image and self. rectangle although truth be told since we want to rotate this image later on we also want to store a self. let's call it Gore surface this we get with py game. image. load I want to use the join method and then go to images there we have the gun and in that folder we have gun.png or in other words if I go to images there we have gun and there we have gun.png in the same folder we also have the bullet that one we are going to use later also as always do not forget convert Alpha then for self. image we simply want to get self. gun surface finally for the rectangle I want self. image. getet F rectangle in which we want to place the center of the gun for the position imagine that this is the player and the player Center is here from this point we want to go in the player Direction by the distance and that's place the center of the gun or in other words at the moment we want to go to the right by 100 and 40 pixels and then place the center of the gun the math for that is actually fairly simple we first of all want to get self. player. rec. Center plus self. player Direction multiplied with self do distance with that we have the gun right next to the player that that means inside of main.py I am already importing the gun from the Sprites so that we don't have to do anymore besides that in the setup method after we have the player I also want to create one instance of the gun and store it in an attribute self. gun is going to be gun with two arguments self. player and for the groups self do all Sprites if I now Run the game we have a gun right next to the player that being said if the player runs around the gun doesn't update with it that we can fix quite easily because inside of the gun I want to have an update method with self and Delta time that being said though for this class we don't need Delta time to indicate that I'm going to add an underscore for now all that we want to do in here is self. re. Center is equal to self. player. re. Center plus self. player Direction multiplied with self. distance the very same thing that we have done just a second ago and I hope the logic here makes sense initially when we are getting the position for the gun we are placing it right next to the player but then we also have to check if the player position updates and then we are always placing the gun relative to the player that way later on WE simply have to change the player Direction and then we get a different position position although first of all let's try all of this if I now run around the gun follows the player on top of that what I can do inside of the gun for the direction let's go with zero and one with that the gun should be below the player so that is working pretty well that means next up I want to self get underscore direction that is going to be just another method get direction without any custom parameters most importantly in there we will need the mouse position and we will need the player position both of those are going to be Vector twos that will make the math a lot easier the mouse position we can get very easily pame do mouse doget position don't forget to call this one and this will return a tupo with an X and Y position which we can pass right into a pame vector 2 and then we have a vector for the player position you might be tempted to go with something like pame do Vector 2 and then self. player. rec. Center the same thing we have done earlier this would not work simply because inside of the display surface we have a top left position of 0 and zero and we can only go as far is the window width and window height and the mouse position cannot leave this area the smallest mouse position is going to be zero and Zer and the largest one in my case is going to be 1,279 and 719 or one pixel short of the display width or height that is because we start counting from zero but the same logic does not apply to the player since we have a camera the player could actually be somewhere down here with an X and by position of let's say 600 and 4,000 way below the display surface and we can only see the player because we are offsetting all of the graphics and this does work for the game but it would not work to get the angle between the mouse position and the actual player position and that we have to account for which in our case is fairly simple because we know that the player is always in the center of the window or in other words we have window width divided by two and window height divided two that is all we need to get the player position relative to the mouse and after we have that we simply want to get self. player Direction and set it to the mouse position minus the player position in this Vector we want to normalize and that is actually all we need I I'm not going to talk too much about Vector math but essentially what we're doing here if this is the display surface we have the origin point in the top left then we have the player in the center and let's say our Mouse could be here what we want to get with the player direction is this new Vector that goes from the player to the mouse position and to get that you want to get the end point and subtract the start point this is a common operation and very basic Vector math anyway though for now let's simply print self. player Direction with that inside of the game I can move my mouse around and this is working pretty well also you can see in the bottom left if I move the window just a bit to the side if my mouse is all the way on top of the player like this the mouse is perfectly on top of the player and then we get zero and negative 1 if I go a bit to the right eventually we would get one and zero below we would get zero and one and then negative 1 and zero at least roughly it's a bit hard to get the exact point but you get the idea that being said we also want to rotate the gun surface for that I want to have another method rotate uncore gun no need for custom arguments we simply want to create rotate gun ultimately what we want to do in here is self do image and then get high game. transform. road to zoom with self. gun surface really important at this point do not use self. image we always want to start the rotation from the original surface after that we will need some kind of angle and for the scale we want to stick to one so then how can we get the angle that is going to be a local variable and for that we want to use a ton 2 which we have to import all the way at the top I want from math import a ton 2 also the greas all right so question what is Aon 2 and well imagine you have a right angled triangle and what aon2 wants is a width and a height once it has those it is going to give you the angle of the triangle which is exactly what we want although it's going to return all of that in radians that we have to convert to degrees and for that we are importing degrees from the math module and by the way all of this is trigonometry which is another really important part in game development you at the very least want to know what sign cosine and tangents do this topic isn't too difficult and I guess let me know if you want a separate tutor tutorial on that anyway what we want is to call Aon 2 and then we have to insert the two sites with self. player Direction dox and self. player Direction doy all of this is going to return an angle but this angle is in radians while we need degrees for that we can use degrees the thing we have just imported to convert all of this and with that I can run main. pi and with we are getting something let me show my mouse actually you can see that the gun is rotating but it's not rotating in the right way to fix that we have to subtract 90 from the angle if I run that we have the gun rotating properly that is much better the issue here is that the starting point of these angles is simply different which we can account for very easily although there's one more issue let me actually show main. pi if my mouse is on the right side of the player this is working perfectly fine but if we are on the left side then the gun should be flipped around otherwise it's going to look a bit funny we simply want to check if self. player direction dox is greater than zero that means we are on the right side of the player if that is the case self. image should do this however if that is not the case else meaning the mouse is on the left side of the player then I still want to get a rotated image but on top of that self. image should also be py game. transform and we want to flip the entire thing for that we want to get self. image and rotate it not on the horizontal axis but on the vertical one so false and true I can now try all of this again and it's it's not going to work just yet the right side is working and on the left side we are getting some funky Behavior to understand this issue let's print the angle that we are getting and run main. Pi again if we now go to the left side you can now see that we are getting a negative value from 90 all the way to 270 and those values being negative is the entire issue because of that the gun is rotating in the wrong way which we can fix very easily we simply need the absolute value let's try of this again and now the gun is behaving just in the right way so this is looking really good that means we don't need the print statement anymore and we have the gun rotation although for the proper gun we are going to need a bullet that part is going to be your exercise what I want you guys to do is when the player presses the left Mouse button then launch a bullet in the direction of the gun on top of that the bullet should start at the end of the gun so it looks like the gun is actually firing all of the bullets should be reasonably straightforward pause the video now and see how far you get first of all we have to figure out where to capture the input for the mouse button and that we can do either in the game class or inside of the player I'm going to go with the game class because in here we also want to create the bullets in just a bit that means I want to create Define input with self and then check if py game. Mouse doget uncore pressed don't forget to call this one and Via this method we are going to get all of the mouse buttons although we only care about the left one which is the index zero if that is the case I want to print shoot for now after we have that inside of the run method before we are updating everything else I want to get self. input let's try and this is working reasonably well the issue is that we are checking this input on every single frame of the game which would give us way too many bullets so we have to moderate things quite a bit which we have already seen I I want to add another condition and self. cancore shoot if the if statement then triggers self. cancore shoot should be balse and we want to get self. shoot uncore time which we get via pame do time and get Pi now for that to work inside of Dunder in it we don't need the Sprites anymore but I do want to have a gun timer for which we have can shoot this one should be true by default and self. shoot time the default value for this one will be zero besides that I want to have a self. gun pool down which I have set to 100 milliseconds or in other words in the game we can shoot 10 bullets per second perfect once we have that we will also need another method with the Gore timer for which we want to check if not self do can shoot if that is the case we basically want to get the current time via pame DOT time.get ticks and then check if the current time minus self. shoot time greater or equal to self. gun cool down if that is the case self do can shoot is going to be R and finally inside of the run method we can do that before we are capturing the input self. gun timer with that inside of the game if I hold down the mouse button we are still getting a lot of input but a lot less than before and if I change the gun cool down to something like 600 it it should be much more visible there you can see we get one shoot printing every 600 milliseconds so that was the first part next up we have to figure out whenever we are getting this input we want to create a bullet or in other words I want to create an instance of a bullet class for which I'm going to need a surface of a bullet a starting position a Direction and then the groups for all of that I want to go to Sprites and then create all the way at the end another class called bullet once again we are creating a pygame Dos sprite. Sprite then we will need a Dunder init method with self the surface the position a direction and the groups next up we will need to call Super Dunder in it as the group groups in there and then we have to create self. image and self. rectangle those two actually fairly simple because we already get a Surface via the parameters and self. rectangle is simply going to be self do image do get F rectangle in which we are placing this Center and once again we are getting the value via the parameters so now we have to figure out all of the arguments the surface is the easier part because if you look at images there we have gun and the bullet this is what we want to import for that I want to create another method called load images for now in there we are only going to create a self. bullet surface which we can get via py game. image. load and then via the join method we go to images gun and bullet.png also we want to convert Alpha all of this once again and that's all we need inside of this method for now although in the next section we're going to reuse this to import all of the enemy images as well but for now that's not really an issue that being said though we do have to call it inside of the setup method I want self. load images with that we have a surface self do bullet surface next up we will need a position and for that I want to create a separate local variable now for the starting position we obviously want to start on the bullet itself which means self. gun. w. Center and then add a bit of an offset in the direction that we are currently facing which means plus self. gun. player Direction multiply it with some value depending on how much distance you want in my case I went with 50 on top of that for the direction of the bullet we simply want to reuse the gun direction or rather the gun player Direction finally for the groups I want to have a tuple with self. all Sprites and self. bullet Sprites a group that does not exist at the moment but inside of thunder in it I can duplicate the Collision Sprites and then create bullet uncore Sprites that should actually be it for the bullet if I now run all of this and let me show my mouse if I press a button we are getting a bullet we can also walk around and this is working pretty well that being said while testing this game game I realized that the input is a bit clunky because we are using the mouse input and then inside of the player for the input we are checking for the arrow keys which makes it kind of awkward on the keyboard to fix that what we can do is check either keys py game. kri or the keys along with pame do Kore D that would be the D key on the keyboard the same thing we have to do for the other side so on there we want to check for the a key then for self. direction doy when we are checking down I want to check for Kore s if we're going down or Kore W if we are going up and that should be it if I now run main.py I can walk around with W ASD or with the arrow keys we are getting the same result besides that the bullets also work perfectly fine I can even hold down the mouse button and we keep on creating bullets they do not move but that we can fix right now actually all we have to do inside of the bullet we first of all need a few more attributes I want to have self. Direction which we're getting from the direction parameter then self. speed I set this one to 1 1,200 and then we can create an update method with self and Delta time all that we really want to do in here is self. rec. Center plus equal self. direction multiplied with self. speed multiplied with Delta time with that if I shoot a bullet the bullet actually moves in the right direction so this is looking pretty good however at this point we do have to be careful because these bullets never disappear and if we can create 10 bullets per second we very quickly end up with way too many bullets so there should be some way to get rid of these bullets you could either delete them when they collide with an obstacle or you could add a timer I'm going to go with a timer which means I want to get self dot let's call it spawn time which is going to be py game. time. get ticks on top of that I want to have self. life time I want these bullets to live for one second after that inside of the update method if py game. time. get ticks minus self. spawn time is greater or equal to self. Lifetime then we want to kill the Sprite to make sure that this is working inside of the run method we can do this one all the way at the end I want to print self. bullet Sprites if you simply print a group you get the number of Sprites inside of it or if I run all of this I can press space and we are getting the number of Sprites and there you can see the bullets work just as before but we at the most get two Sprites so that part is actually working pretty well although I really ized the reason why we are getting so few bullets is because the gun cool down is 600 this should only be 100 let's rise again and now we're getting a whole bunch more bullets but only 10 at the most which is a really good thing for performance but anyway with that we have the bullet mechanic which gets us very close to a complete game the only major thing that we now have to add are the enemies that's going to be the next section we are nearly done with the game the last major part that we have to cover is how to add the enemies for that we have to go through a couple of steps first of all we will need a timer that triggers twice per second and every time it triggers we want to create one instance of the enemy and that enemy needs to do a couple of things it always needs to walk towards the player and it needs to be able to collide with objects on top of that it should always play a walking animation and for that we will also need to import the animation frames I think at this point all of this is reasonably straightforward as a consequence all of this could be an exercise so try to figure this one out on your own and see how far you get back inside of the game I want to work inside of Sprites and create another class called enemy which as before is going to be pygame dos sprite. Sprite then for the dunder init method I want to get a starting position a bunch of frames the groups the player and the Collision uncore Sprites after we have that super Dunder init with the groups also I want to store the player as an attribute I.E self. player is the player that player by the way we need to get the proper direction of this enemy also I can see an issue right away I have a typo inside of pame after we have that we want to create the image for that at the moment we have an issue because we don't have a single surface or rather later on we are not going to have a single surface instead we have a whole bunch of frames the walking animations we are importing if you look at the images folder there we have enemies and for example for the bat we have 012 and 3.png which are all one part of the walking animation or I guess for the bad the flying animation to account for that I want to create self. frames and self. frame uncore index which is going to get frames and zero after that we can create self. images which is going to be self. frames and then we use self. frame index for the indexing also what we could be setting in here is self. animation uncore speed I went with six for this one next up we have to figure out the rectangle which ultimately is going to be self. rectangle self. image. getorf rectangle we want to place the center and the value will be the position from the parameters on top of that I want to create self. hitbox rectangle which we get via self. re. inflate and I want to reduce the size of this by 20 and ne40 besides that I also want to store all of the Collision Sprites as an attribute meaning self. Collision Sprites is Collision Sprites nearly done besides that we also want to have self. Direction which is simply a pame do Vector 2 without any values and I want to have self do speed for which I want to go with 350 that is quite a bit next up inside of the game class I want to create a timer which we can do right below the gun timer we also want to have an enemy timer for this timer I want to use the event Loop which means I want to have an enemy event and then create py game. event. custom type after that p game. time. settimer with self. enemy event and 300 also I want to create one more attribute which is going to be the spawn underscore positions by default this will be an empty list the reason why we are going to need this one if you look at tiled we have on the entities layer all of the markers and at the moment we are only using the player one this one here but we also want to use all of these other enemy markers for a random starting position which basically means we want to place the position of all of these markers inside of this list that way we can very easily pick one of them to get that we want to look at the setup method because in there we are already getting all of the Markus although at the moment we only look at the player if that is not the case l I want to get self. spawn positions and then append obj dox and obj doy after we have that we can work inside of the event Loop because now we can check if event. type is equal to self. enemy event if that is the case I want to print spawn enemy if I now run all of this we are getting an attribute error that game object has no attribute spawn positions and I think I know what the issue here is inside of the init method we are running the setup method here but only afterwards we are creating the spawn positions which means when we are trying to append a value to the spawn positions this attribute doesn't exist at the moment fixing that is super easy we simply have to move the setup method all the way to the bottom and I guess while we are here I think it's also going to be a good idea to move load images right before with that we can create a more General setup section which feels a bit cleaner also before we are trying all of this I realized that I am printing the bullet Sprites inside of the game Loop if I now try all of this we're getting spawn enemy every few milliseconds every 300 milliseconds to be a bit more specific now that we have that whenever this event occurs we want to create an enemy for which we are going to need first of all a position that part is quite easy we want to get choice and self. spawn positions now choice we have to import all the way at the top from random import Rand in and choice next up we have to get a whole bunch of frames which we can't really do at the moment let's leave this one empty for now for the groups I want to have a tupo with self. all Sprites and self. enemy Sprites this one does not exist at the moment so I want to duplicate the bullet Sprites and rename this to self. enemy Sprites next up we need a player that is simply self. player and for the Collision Sprites we want to have self do Collision Sprites nearly done we are just going to need all of the frames and for that I want to work inside of load images because in there we want to do all of the Imports this is going to be quite similar compared to what we have done inside of the player there we have load images and we have used the walk method to walk through this folder something similar I do want to do although first of all I want to get all of the available folders which for the player I have kind of done in a janky way I simply created a dictionary with all of the folder names but this isn't particularly elegant because ideally I want to get these values dynamically generated which we can get via the walk method I can simply get join then go to images and the enemies and then turn all of this into a list on this list I want to get index zero or the first item if I print that folders and and run all of this we are getting name frames not defined that's okay for now but we are also getting this value here where we have the name of the folder and then a list of all of the subfolders this is what I actually want which means I going to have index one that way I'm getting all of the folder names after we have that I want to create self. enemy uncore frames which is going to be an empty dictionary and then for folder in folders in there I'm going to get a folder path I would be getting the subfolders next but those I don't care about so an underscore and then the file underscore names all of this in walk join we want to go to images then we want to go to the enemies and then we want to get the folder once we have that we can create self. enemy frames and create a key value pair the key should be the name of the folder and the associated value is simply an empty list after that for file underscore name in file names first of all we will need a full underscore path that we can create via the join method we simply want to combine the folder path with the file name and then we can create a surface or rather we can import a surface bya pame image. load with default path and convert Alpha finally I want to get self. enemy frames with the folder key and then a pend the surface nearly done the last thing that I want to do is to sort the file names so sorted method and then we want to use a key which is going to be a Lambda value with a name par parameter this name at the moment is something like 0.png and we want to extract the zero and convert it to an integer for which we need name do split we want to split this thing wherever we have a DOT and then pick index zero after that we want to turn all of this into an integer and with that we're getting all of the frames after this method I want to print self. enemy frames and run all of this now we are going to get a name error again because we are not using frames inside of the enemies but before that we have a larger dictionary where the key would be an enemy and then we have the walking animation that is actually all we need so we don't want the print statement anymore instead when we are creating one enemy I want to use the choice method to pick one of the en enemy animation frames which I can do via self. enemy frames and then get the values although this wouldn't work immediately because Choice cannot work with values directly what we need to do instead is to turn all of this into a list if I now run all of this we getting an attribute error that nontype object has no attribute get F rectangle let's have a look for that inside of the player I simply have a typo this should be self. image not self. images with that let's R off this again and the game doesn't crash anymore and we can see a whole bunch of enemies in random positions so that is working pretty well for these enemies now we have to do two things both of which are going to happen inside of the update method I want every single enemy to move along with Delta time and to self. animate also with with Delta time move we can do later because this one is getting a bit more complex but for animate we simply have to call self. animate with Delta time once again then we want to increase self. frame index or in other words plus equal self. animation speed multiplied with Delta time after that self. image is going to be self. frames with integer of self. frame index modulus length of self. frames that should give us an animation let's try and there we go this is looking pretty good if I find a skeleton those also work fine perfect that looks pretty good next up then we have to work on the Move method for that we need to do two things Define move with self and Delta time in there we need to do broadly two things we first of all want to get a direction and after that update the wrecked position really important for the wed position we also want to include the Collision logic but step by step first of all we want to get the direction for which we are going to need the player position and the enemy position or the position of this class I am using enemy position here to keep things a bit more understandable also both of these values should be Vector twos I.E P game Vector 2 and for the player position we simply want self. player. rec. center for the position of the enemy we also want to have a pame vector 2 with self. re. center and for self. direction we simply want to get the target position I.E the player position minus the enemy position the same thing we have done for the gun and all of this we want to normalize which means I want to add normalize at the end of all of this that way when we are doing the movement we can simply multiply the Direction with a speed and we always get a consistent result speaking of which for the basic movement all we want to do is self. do Center plus equal self. direction multipied with self do speed multiplied with Delta time with that if I run main. Pi all of the enemies are moving towards the player that is working pretty well but without collisions this is going to look just a bit silly which means we also want to add a Define collisions with self and then the direction now for that I am going to go to the player and then simply copy the Collision method and then we can update the movement although I do have to mention this is not elegant ideally you would use inheritance to create a parent class for the enemies and the player that has the Collision method that way both of them can inherit the same method so we don't have to copy paste things we are going to do something like that later on although for now I want to keep things simple anyway I first of all want to split the movement into horror izontal and vertical Parts which means we want to update self. rec. Center X by self. Direction dox multiplied with self. speed and Delta time then for the vertical Movement self. Center y plus self. direction. y multiply it with speed and Delta time now you could also go and this is what we have done for the player you could go with X and Y I suppose we could actually do that self. r.x and self. r.y that just feels a bit cleaner also we are not using the hitbox yet but that's going to come in a second now after we doing the horizontal movement I want to call self. Collision with the horizontal collisions this I can then duplicate because after we're doing the vertical Movement we want to check the vertical collisions if I now try to run main. Pi this is not working and I think I know why in inside of collisions we are using the hitbox rectangle but when we are doing the movement we are using the rectangle which isn't ideal so instead of the rectangle I want to use the hitbox rectangle although for that to work then at the end of The Movement we have to set self. re. Center to self. hitbox rect do center with that we should get the hitboxes and the proper collisions let's go up here and and we should be able to see that monsters are also constrained by the environment so that is working really well and with that we have the enemies we are nearly done with the second game we just have to add some minor bits to finish up the entire project there are two major things that I want to work on number one are the collisions so so that if an enemy gets hit it disappears and if the player gets hit the game ends on top of that we need to add some audio which should be fairly straightforward in fact this could be an exercise right away I want you guys to add the collisions between the bullets and the Monsters if a bullet hits a monster then kill that monster Sprite on top of that add all of the sounds I want to add another method let's do it right before the run method Define bullet uncore Collision no need for custom parameters and in there we need to check if we have bullets in the first place for that inside of thunder in it we know that we have a bullet Sprites group that we can use simply by checking if self. bullet Sprites if we don't have bullets there's no reason to check any of these collisions if however we do have some then we want to check for bullet in. bullet Sprites next up we want to check the Collision uncore Sprites which we get via pame dos sprite. Sprite Collide in which we need a single Sprite a group of Sprites and then do kill for now the single Sprite is going to be the bullet the group is going to be self. enemy Sprites and to kill is going to be true although this we are going to change later on after that inside of the run method when we are updating the game I want to call self. bullet Collision I can now run all of this and if a bullet hits an enemy the enemy disappears so that is looking pretty good that is looking quite nice so now we can refine all of this first of all what we can do is use a Mas for the Collision via pame dos sprite. light mask that way we are using a mask for the collisions meaning we have a lot more Precision that being said most of the objects that we are working with for example the bullet or the bats are fairly rectangular so this isn't going to make a massive change what is going to be much more noticeable is that I want to have a delay between the bullet hit and the Sprite death for that I want to set do kill to false and after that check if we have Collision Sprites if that is the case I want to go through all of them I.E for sprite in Collision Sprites and then call a method sprite. destroy this destroy method does not exist at the moment but we can create it inside of Sprites the enemy class I want to have a method called destroy inside of this method there are fundamentally two things that I want to do number one I want to start a timer once this timer runs out we are actually destroying the Sprite besides that I want to change the image once its Sprite has been hit we want to change the entire thing to a white surface that's the part we can work on right away actually for that I want to create a new Surface via py game. mask. from surface and then use self. frames and zero in other words the first frame of the walking animation this I want to turn right away back to a surface that way if we are overwriting self. image with the surface we can see the mask or in other words we can see a silhouette that is black and white at the moment this is only going to run for a single frame so it wouldn't be particularly visible but what we can also do is set self. deore time to py game. time.get Pi and to use this attribute I want to work inside of the dander init method and add a timer section with self. death time this one can be Zero by default and then self. deore duration I said this one to 400 milliseconds once we have that inside of the update method I only want the enemy to move and animate if self. death time is equal to zero that can only be the case if the enemy has not been hit by a bullet once it has been hit however we are overwriting this surface that way if I run main. pi and we hit an enemy the enemy stops moving and we get this silhouette so that part is working pretty well that being said though I only want to get the white part which we can get via surface and setor color key that we are going to use to remove all of the black pixels via that I can shoot the enemies and we only get the white outline that works pretty well next up then I to create a deore timer that is going to check if High game. time. get Pi or in other words the current time from that we want to subtract self do death time and if the resulting value is greater or equal to self dode duration then we want to kill this Sprite and to call this death timer we want to check if the death time is different from zero or in other words else self do death timer inside of the game I can now hit the enemies and they do disappear after a short amount of time so that looks pretty good on top of that the last thing that we need for this Collision is once a bullet hits an enemy the bullet should also disappear which we can do very easily if there are Collision Sprites I want to kill the bullet let's try this one and if I had a bat or any of the enemies the bullet also disappears a bit hard to see but you get the idea anyway with that we have the bullet Collision besides that I want to have another method with layer uncore Collision all we want to check in there is py game. Sprite do Sprite cite with self. player self do enemy Sprites and for du kill I want to go with fals although this value doesn't really matter all that we want to do is check if there's any return value and if that is the case self. running should be false finally to make all of this work besides the bullet Collision we also want to have self. layer Collision now truth be told you could combine these two Collision methods since for both of them we are not doing very much but I think it's a bit better organized if you have them separately anyway let's try and if I now collide with an enemy the game simply ends I suppose what we should also be doing is use a mask with pame do sprite. Collide mask this part is actually really important because remember the surface of the player is actually really large which means that the Collision would actually be really easily triggered but if we do include it you can see that we have to hit an enemy straight away now for the balancing of the game I didn't spend too much time on it so it is very very easy to die and you might want to include a health mechanic but that you can do in your own time the last thing that I want to add are the sounds and then we are done with this project for the that I want to work inside of Dunder innit and add an audio section we don't really have that many audio files if you look at the audio folder we have an impact sound a music sound and a shoot sound to import all of those we want to have self. shotor sound which we get with pame do mixer do sound then we will use the join method to go to audio and then shoot. wav for which I also want to set the volume right away shoot sound. set volume with 0.4 besides that we have self. impactor sound which we can get with the same method that we have used for the shoot sound the only thing that we have to change is that this is impact. OGG finally we want to have self. music one more time we will need py game. mixer. sound go to audio and then import music. wav and I realized there's a typo this should be OG cool that covers all of the Imports if I now Run the game it doesn't crash so that looks pretty good meaning we just have to figure out when to play these sounds and then we are good to go both for the shoot sound I want to check the input because in here we are creating a bullet which means I can get self do shoot sound and play the entire thing that sounds pretty good cool after that we have the impact sound and this we check when we have a bullet collision between the enemies and the bullets or in other words if there are Collision Sprite we want self. impact sound. playay that should be all we need if I now hit an enemy we're getting a sound finally we will need the background music and that part is the easiest because the music we want to play right away self. music. playay and for Loops we want to have negative 1 so this one plays forever and I think for the background music we do want to set the volume a bit lower self. music. set volume to 0 let's say 0.3 and with that that is working pretty well now this game isn't terribly well balanced so what you could be doing for example when you are in the Sprites you could update the enemy movement speed the lower this one is the easier the game will become you could also work on the timer if enemies spawn less often then they are easier to handle on top of that you could also add a health mechanic for the player so that we could be hit multiple times without dying but in my case I'm going to call it a day at this point for the next project we are going to make pong now the overall game isn't going to be too different difficult but there are three major things that I want to focus on the most important one are collisions between moving objects we have already seen some basic logic for that and we are going to refine this quite a bit and for the collisions between the ball and the pedal this kind of logic is fundamental besides that I want to use a lot more inheritance for example the player and the opponent are very very similar so we can use inheritance to make our code much more efficient and elegant finally I want to add a saving mechanic so that when we are restarting the game the score is sticking around however before we can work on any of these topics we have to start with the setup and this can be an exercise right away I want you guys to do a whole bunch of things number one create a basic game Loop and the player then get the player input and then move it up and down while constraining it to the screen also create a ball that bounces around the window without any collisions yet and finally for all of this use the info from settings.py speaking of which here is the project folder and we only have two subfolders code and data data actually at the moment is entirely empty and inside of the code we have main.py and settings.py let's have a look at those two here we are and inside of main.py we are simply importing everything from settings in settings we have a bit more we are importing py game and then we are importing the join method besides that we have window width and window height and then finally we have a bunch of dictionaries for example in there we have the size of the padal this can be both the player and the opponent and the ball besides that we have various speeds and we have a whole bunch of colors with that system we can customize the game from inside of the settings which is generally a good idea you want to have all of the really important stuff in one place so you can make changes really quickly and that is what I want you guys to use to create the basic outline the end result should look something like this I suppose I should also mention we are not importing any images instead when you're creating the player and the ball create a surface from scratch for now all of those can be perfect rectangles anyway pause the video now and see how far you get I want to get started by creating a class called game no need for inheritance but we will need a Dunder init method in there first of all we want to call py game. init and create a display surface attribute which we get with py game. display. setor mode in which we want to add a tupal with the window width and the window height I can copy all of that from settings and then we are good to go besides that we can also change the window title with py game. display. setor caption and pong finally I want to create self. clock via py game. time. that should be the basic setup although I forgot one thing self. running for the while loop and by default this one should be true after that we want to have a run method without any custom parameter and then wild self. running in there we first of all want to get Delta time for which we need self. clock do pick don't forget to call it and then divide it by 1,000 that way we're getting Delta time in milliseconds afterwards for event in py game. event. get at the moment we only want to check if the event. type is equal to pyam do quit if that is the case self. running is going to be false next up we have the actual game logic in there later on we want to have an update part and a drawing part at the end of the drawing part we have to call pygame do display. update or flip also after the while loop we have to call pygame do quit cool with that we have the basic game class back in the global scope of main. Pi I want to check if Dunder name is equal to Dunder main if that is the case I want to create one instance of the game class and then call game. run let's try all of this and we are getting a black window that looks really good next up from settings.py I want to start using the colors and we already have a background color which means I can copy the key from colors and then inside of the drawing method self. display surface. fill with colors and BG let's try that and we getting a much nicer background color that looks good with that covered we can start working on the Sprites first of all for that we will need self. all Sprites which is going to be pame dos sprite. group on top of that I also want to have self. pedor Sprites which also is pygame Dos sprite. group padal Sprites is just going to be used to have collisions between the ball and the padal they are not going to do anything else self. all Sprites however we want to update I.E self. all Sprites do update with Delta time and after we are filling this screen self. all Sprites do draw on self. display surface that's a good setup next up inside of the code I want to add another python file let's call it Sprites DOI we will need from settings and import everything and then we have to create at the moment two classes one is going to be the player and the other will be the ball although for now let's focus on the player this one will be a pygame Dos sprite. Sprite then we will need a Dunder in it method with self then we will need the groups and an xcore position don't forget afterwards we have to call Super Dunder in it and pass in the groups finally then for the Sprite to work properly we will need an image we will need a rectangle and I guess along with that we also want to cover the movement for the image if you look at files we don't have a folder with images so there's no point in trying to import anything instead what we're going to do for self. image we want to have pame do surface for which we are going to use settings.py in there we have the size of the pedal or in other words size and pedal that's all we need for now for the image besides that I want to have self. rectangle which we get with self image. getet F rectangle in which we want to place this Center this one requires a tupal with X and Y X is going to be set via X position what we going to get in just a bit from the xos parameter for why we simply want to be in the middle of the window I.E window height / by two I suppose with that we have a very basic player Sprite class that we can use right away which means inside of main.py I want from Sprites import everything and then after we have the groups self. player is going to be the player for which we're going to need the groups first of all self. all Sprites and self. pedal Sprites and then we need an X position for this one I went with window with minus 50 I suppose you could also set this this value inside of the settings it's entirely up to you and while looking at this I feel like this value should be inside of settings. pi as well so what we can do under size we can also have a position for which we have a player key and the value for this one is going to be a tuple with window width minus 50 and then window height div by two on top of that I want to have one for the opponent which is simply going to be 50 and window iight divide it by two with that set up we don't need this argument at all also inside of Sprites we don't need an exposition for the center we simply want to have B and then get the player key that does feel a lot cleaner and with that if I now run the code on the right side side you can see the player doesn't do very much and it's also not looking great but at least we have something first of all what we can do to make all of this look a bit better is self. image. Bill with colors and I believe the color for this one is called pedal that way we're getting some more colors now we are going to refine the image in just a bit but for now I think this is good enough what is much more important is the movement for which we are going to need a direction and since the player can only move up and down this doesn't have to be a vector it can simply be an integer and by default I want to go with zero and to move this thing I want to have a move method with self and Delta time for now let's add pass in here and then I want to have a defined get underscore Direction which is going to cover the input now you might be wondering why am I not calling this input and the reason is later on we going to have two get direction methods one for the player that takes keyboard input the other is going to be for the opponent and this one is going to check the ball position since I want to call both of them at the same time they are going to have the same name for now don't worry too much about it when we get to it I will explain it in much more detail anyway for now for get direction we simply want to get the keys with pame dokey and get rest and then set self. direction to the integer of keys and P game. Kore down minus integer of keys and py game. Kore up with that we are getting a Direction so next up for move I simply want to get self. rec. Center y plus equal self. direction multiplied with self. speed this one doesn't exist yet and multiply it with Delta time to make this work we will need self. speed which we are also getting from settings. PI there we have the speed this I want to turn into an attribute of this class in other words speed and layer finally we have to create a update method it with self and Delta time and then call self. get direction and self. move that way inside of main. Pi I can move up and down that's looking pretty good the one limitation is that the player can leave the screen that's no good although fairly fixable we want to check self. rect dotop and set it to zero if self. re. toop is smaller than zero if that is not the case else we simply want to keep self. rec. toop then I can duplicate all of this and set self. rec. bottom this one should be the window height if self. re. bottom is greater than the window he if that is not the case we simply want to keep self. re. bottom or in other words we don't want to make any changes and that is actually all we need I can now try to run the game and the player cannot leave the screen anymore the same with the bottom side so that is working pretty well and all right with that we have a basic player class next up we can work on the ball class which is also going to be a pame Dos sprite. Sprite and we don't need the player anymore we are going to need a thunder init method with self the groups the pedal underscore Sprites and that's it for now although later on there's going to be a bit more first of all as always super Thunder init with the groups then we need an image and the wrecked and movement section for the image at the moment the paddle is simply going to be a rectangle I.E self. image will be pame do surface with the dimensions of the ball size and ball on top of that self. image. fill with colors and I believe this one is called ball or in other words we are grabbing this key value pair for the rectangle we want to get self. rect which will be self. image. getet F rectangle we want to place the center straight in the middle of the window or in other words window wi divided by two and window height divided by two once again we have a basic outline of a Sprite that we want to use to create self dot ball which will be one instance of the ball class for which first of all we will need the groups we only want to ball to be in all Sprites and then make sure that the ball class has access to the padal Sprite group what I really want to mention at this point is that the ball itself is not inside of pedal Sprites it simply has access to them a really important difference let's try all of this and we can see something that looks like a ball in the center of the window to make this ball move we first of all need self do Direction which has to be a py game. vector 2 we need a value for x and y both of those should be random for that we will need from random import choice and uniform for the x value we simply want to get either one or1 or in other words we're going left or right that we can get by putting them into a tupal and then putting the tupal into the choice method as an argument now for why I want to have a random value between two two floating Point values that we can get via uniform it works like random integer except for this one we're getting random floating Point values I want to get a value between 0.7 and 0.8 both of those are positive which isn't ideal if we didn't make any updates to it the ball would always go down because we always have a positive y value to fix that I'm going to multiply this with choice and 1 and one that way we get a direction that can be randomly up or down I hope this part isn't too complicated we are basically just creating two random values for X and Y next up to actually get some movement we want to have a move method with self and data time and all we want to do is self. re do Center plus equal self. direction multiplied with with the speed of the ball which we get from settings in there we have speed and ball and finally we will need Delta time after that to make sure we are calling the move method update self Delta time and self. move with data time let's try off this and the ball is moving in random directions let's try this a couple of times and that is looking pretty good cool we are nearly done with the basic setup the one other thing that I want for now is that the ball should be able to bounce around the screen for which we will need another method let's call it wall Collision no need for custom parameters all we really want to do in here is for example if self. re. toop is smaller or equal to zero then self. re. toop is going to to be zero and self. Direction doy we want to multiply with 1 or in other words if this is the top of the window and the ball crosses it then we are going to set the top of the ball to the top of the window and move the ball in the opposite direction at least on the vertical axis the same thing we want to do on the bottom side for that I can copy all of this and then check self. re do bottom is greater or equal to the window height if that is the case self. rec. bottom is going to be equal to the window height and self. Direction doy is going to be multiplied with 1 that would cover the top and the bottom those two parts we're going to keep in the final game although for now for testing purposes I also want to have a bounce on the left and right side of the window that is going to make it much easier to test collisions in just a bit for that I want to basically duplicate all of this two more times because now we want to check self. re. right is greater or equal to the window wi if that is the case self. re. right will be equal to the window wi and self. direction dox we are multiplying with negative one finally I want to copy the first if statement and then self. re. left is smaller or equal to zero if that is the case self. re. left is going to be zero and self. direction dox we are multiplying with 1 with that we have bouncing we just have to call self. Wall collision and then run main. pi and we have some bouncing Behavior no collisions yet but that we are going to work on in the next part other than that this is working pretty good good and I hope at this point this kind of setup isn't too difficult you should be able to create basic Sprites and make their move via a vector on top of that you should also be reasonably comfortable at this point to get player input we have covered this kind of logic twice already so I hope it's not too difficult now before we finish up this part there's one more thing that I would like to do at the moment we only have perfect rectangles which doesn't look great I want to have for the ball a proper Circle and for the player I want to have rounded Corners let's start with the ball and for that I still want to keep the surface but I'm going to add another argument which is called a flag and for this I want to get py game. SRC Alpha with that value we enable Alpha values on this image if I don't fill the entire thing with a color and run main. Pi we cannot see the ball anymore but the ball does exist it's simply not visible that is actually super useful because now we can get py game. draw. Circle so basically what we are going to do we're going to make the original surface invisible and then draw a circle on top of it with that set up we cannot see the background the only thing visible in the game will be the ball itself for this I want to draw on self. image and then get a color value which we already already have colors and ball finally we will need a position and now you have to be careful because so far whenever we use py game. draw we drew on the display surface but this we are not doing anymore we are drawing on self. image which is a surface that is much smaller this self. image is a Surface like this that is 30X 30 pixels and when we are getting the position for the circle we want to get the center of this thing which will be relative to the top left or in other words we want to go 15 pixels to the right and 15 pixels down and those values we want to get from settings as well I want to have a t ball with X and Y for X I want to get the size then I want to get the ball size on there I want to get index zero and then divide all of this by two for the Y value I want to do basically the same thing except now it's going to be index one and finally we're going to need a radius which is going to be one of these values let's simply go with size ball 0 / by 2 if I now run m not Pi again we are getting a circle so that is working pretty well now looking at this line it does get a bit more complex especially the position and the radius years all that we are really doing in here we have a surface that is 30X 30 pixels those values we're getting from size and ball after that when we are drawing the circle we want to get the center of this surface and for that we are getting the width of the ball and divide it by two that way we are going from the top left and going halfway after that for the Y position we are once again starting from the top left and we're getting half of the height of the surface combined we are defining this Center Point finally then for the radius we simply go from the center and then get a radius that touches the outer border of the surface once we have thought of that we can draw a circle around that point that is basically it we don't need the image fill part anymore and after that we can work on the player for which we first of all have to set a flag with py game and SRC Alpha after that I want to use pam. draw. rectangle I want to draw on self. image the color is going to be colors and padal and finally I need to get a pame do F rectangle that I want to use for the drawing and for this one once again it's really important to understand that we are not drawing on the display surface we are drawing on self. image which at the moment I believe is a surface that is 40 pixels wide and 100 pixels tall the rectangle that we want to create should start in the top left and then have the same width and the same height compared to the surface which means when we are defining the position we want to have zero and zero that way we are in the top left of the surface and those I want to have inside of a tupal or in other words when I'm defining this rectangle I want to have a tuple for the position and a tuple for the size for the position I want to have zero and zero and for the size I can simply reuse the size of the padal the same thing we have used inside of pame surface once we have that we have a rectangle but when we are drawing all of this we can Define more Arguments for the WID I want to have a value of zero and then for the Border radius I want to go with let's say 10 then we don't need self. image. fill anymore and if I run main. Pi we have rounded corners for the player pedal so that is working really well although I think they are a bit strong let's go with four instead and I think that is looking a bit better but once again play around with these numbers and just see what looks good anyway with that we have a pretty good start next up we can work on collisions with the basic setup out of the way we can work on collisions and really important for this project we have collisions between two moving objects or in other words both the pedal and the ball are moving which is not something we can account for with the Collision logic we have used so far but let's go through it step by step and start with a recap at the moment we have covered collisions between a moving and a static object we first of all separate the dimensions and then we check for overlaps via the rectangles for example we could have the player and an obstacle after that we use the direction of the moving object to determine the Collision side or in other words if we have to play on the obstacle again if the player is moving to the right then we know the Collision must have happened on the right side of the player or in other words if you have only a single moving object and this object is moving to the right then we can only really have a collision on the right side of that moving object once we have that we have to update the position of the moving object or in other words we are setting the right side of the player to the left side of the obstacle that would be one side if we cover the three others we have a proper Collision system however there is a major weakness and that is once the other object starts to move then all of this is falling apart and the key issue is once both of these objects are moving we cannot reliably tell on which side of collision happened for example if this is the player and the obstacle and the player is moving to the right we would assume that the Collision happened on the right side of the player however what happens if the obstacle is moving to the right at a much greater speed so that for example in the last frame the player was roughly here and the obstacle was somewhere here if that is the case we should have a collision like this where the right side of the obstacle is colliding with the left side of the player to account for all of that we have to make some updates to our Collision logic that being said we are going to keep some parts we are still going to separate the dimensions and we are checking for overlaps Via rectangle this part doesn't change after that however we are going to check the current and the previous position of both objects or in other words if this is the obstacle and the player only on the horizontal axis for example this would be the center of the player this will be the left side of the player and this will be the right side of the player and we can tell at the moment we have a collision on this point or rather an overlap to be a bit more specific and this happened on the current frame in the game but on top of that we also want to store what happened on the last frame and then let's say the player was here and the obstacle was here which means we know that the obstacle was further to the left than the player and is simply moving really fast to the right and this we have to include in our Collision calculation for example to check for the right Collision of the player we still want to check if the player right is greater than the obstacle left this this is what we have done here we know that the player right is greater than the obstacle left this is giving us one overlap but on top of that we are checking this second condition where the right side of the player needs to be below the left side of the obstacle with that we know that on the previous frame the player was on the left side of that obstacle which in this case is not going to be the case overall we know there was no Collision on the right side of the player however if we are doing all of this from the other side the obstacle then we do get a collision and let's go through it one more time we have the first Collision where we are checking if the right side of the obstacle this point is greater than the left side of the player which in this case very much is the case the right side of the obstacle is a much greater value than the left side of the player on top of that we want to check if the right side of the obstacle on the last frame was below the left side of the player on the last frame as well which is also the case meaning this condition triggers as well which means overall we know that the obstacle should have collided on the left side of the player and this logic we can apply to all of the other sides as well once we have all of that we have a proper Collision mechanic for all of that I want to work inside of the ball class and add a right below move Define collision for which we will need self and the direction we are working in first of all in there we want to check for sprite in self. pedal uncore Sprites which is something that I should have created inside of the dunder init method and there we need self. pedal Sprites which is the value we are getting from the parameter up here at the moment this one simply contains the player Sprite and later on the opponent will also be in there once we have that we want to check if sprite. rec. collide rect with self. rectangle we are checking if there's an overlap between the player and the ball something we have also done before after that I want to check if the direction is equal to horizontal and now we want to check check for two conditions if self. re. right is greater than sprite. re. left on top of that we want to have a second condition where self dot let's call it the old uncore rectangle. right is smaller or at least equal to sprite. Old re do left these two old rectangles don't exist at the moment we are going to create them in just a second though if that is the case we simply want to set self. re. WR to sprite. rec. left and this is the logic I have just talked about where we are checking a moving object and then first of all check if we have an overlap at all on the horizontal axis and then we check if the old rectangle was to the right of the left side of the Sprite on the previous frame the question now is how can we get this old rectangle or in other words how can we start a rectangle position on the last frame that part is actually fairly simple inside of Thunder init when we are creating the rectangle I also want to have self. _ rectangle and for now I simply want to get self. rect and then copy the rectangle that way we getting a new rectangle with the same position and the same size after that inside of the the update method before we are applying any kind of movement I want toose self. old rect and then get self. rectangle once again and copy it by our that system on every single frame we are storing the position of the rectangle and then updating the position of that rectangle we have the last frame and the current frame and that is all we need although the same thing we also have to do to the player in there or the player below the rectangle we will also need self. old rect which is going to be self. re. copy and this we want to do before we are doing anything else inside of the update method nearly done the last thing that we have to do is to call this Collision method and this is going to happen inside of the move method in there I first of all want to separate the dimensions for the movement we want to move self. r.x and self. doy for h plus self. Direction dox and self. Direction doy multiplied with speed and Delta time after the horizontal movement I want self. collision and horizontal after the vertical movement self do collision and vertical this part doesn't exist at the moment but that we can work on later first of all inside of main. Pi if the ball now collide with the player we are getting a collision this isn't too amazing yet because the ball simply keeps the direction to account for that we can simply set self. Direction dox multiply equal with1 that way we're getting a proper bounce so let's try this one and there we go this part is working and it would also work while the player is moving although truth be told this part isn't too impressive yet what is going to be much more interesting is the vertical Collision let's say I want to check if self. rec. bottom is greater or equal to sprite. rec. toop and self. olds w. bottom is smaller or equal to Sprite dot old score w. toop if that is the case I want to set self. w. bottom to sprite. w. toop or in other words we are checking if the bottom of the ball is colliding with the top of the player and besides that we are checking if on the previous frame the bottom of the ball was on top of the player as well now testing this is going to be a bit of a challenge and I think to test all of this a bit better let's set the ball speed to something much lower 50 if we now test all of this and it's going to be really slow let me speed this one up just a bit okay you can now see we have a collision between the pedal and the ball and this is also the basic logic for collisions between two moving objects all you really have to add is the overlap and then the position position of the rectangles on the last frame now in our case I always want the ball to bounce if there's a padal collision which means self. Direction doy multiply equal 1 if we have a vertical Collision I suppose what we could be doing is set the ball speed back to 450 and let's try this and there we are getting a proper Collision that looks good with that we are nearly done we just have to add two more sides to our Collision logic that part is going to be your exercise I want you to add the last two sides of the Collision logic pause the video now and see how far you get at the moment we are checking the right side of the ball and the left side of the player the alternative would be if self. w. left is smaller or equal to sprite. wct do right and I think it's generally a good idea to use greater than or equal to for all of these comparison operators although in practice it's not going to make much of a difference besides that and self. old. left is greater than or equal to Sprite do altore rectangle. right if that happens to be the case self. rec. left is going to be Sprite . rec. right and also in our case self. Direction dox multiply equal 1 and besides that for the vertical Collision we want to check self. rec. toop is smaller than or equal to sprite. rec. bottom and self. old rectangle. top is greater than or equal to Sprite do _ rectangle do bottom and then self. re. toop is equal to sprite. re. bottom and self. Direction doy multiply equal with 1 that is all we need I can now try main. pi and we have a collision on the top of the player and we can try this one again again there we could see a pretty good collision and you can play around with this quite a bit more but fundamentally it looks pretty good and I hope overall the logic here isn't too complicated the major thing that you have to understand is that we are always checking the current overlap and the previous overlap that's literally it since overall we are checking for ton of conditions this can get a bit complex but I think it's still manageable once you have been using this a couple of times it becomes fairly straightforward the next really important part that I want to cover is going to be inheritance by that system we are going to create the opponent with only a couple of lines of code the way it's going to work is that for now you have to understand that both the player and the opponent paddles are really similar they are going to have the same setup and move code so we can share quite a few things between them the only real difference between them is how the move direction is updated for the player we getting keyboard input while for the opponent we are checking the ball position because of that we can create a pedal parent Sprite that cover setup and move and then the player and the opponent both are going to inherit from that with that system it's going to be much easier to write reusable code so let's have a look inside of Sprites we have the player class and for the opponent we want to have the same dund init method and the same move method also we want to keep the update method as well as a consequence all of this should go into another class called padal this one needs to be a pygame Dos sprite. Sprite and for the dunder init method of this class we want to use the one we have created for the player we can simply cut it out and paste it in there and now we are creating a very basic Sprite unfortunately now the player class is not going to work anymore but what we can do is make the player class inherit from the pedal that way all of this will become available all we need to do is call a Dunder in it method inside of the player and for that we will need the groups but now if we are calling super Thunder init inside of it we are calling this thunder init method and only inside of this thunder init method of the pedal class are we creating the actual Sprite although the pedal itself doesn't really care all that we need to pass through are the groups and then we are done which means inside of main. Pi we are getting the very same result so that is looking really good the only change that we want to make is that we want to have a custom speed for the player and for the opponent later on which means we want to have self. speed inside of the player on top of that what we can also do is move the move method into the paddle class like so and the same thing we can do to the update method since those are going to be useful for the opponent as well we do want to have them inside of the parent class which means all that's really left inside of the player is get direction and a very basic Dunder init method however inside of Main Pi we still have the same functionality so now finally we can create the opponent which is going to be a child of the pedal class all that we need inside of this one is a thunder init method and we will need a get direction method and creating those is going to be your exercise I want you guys to create the proper opponent pedal the class should be paddle This is what we already have and then to get the direction you basically want to do something like if the vertical center of the opponent is smaller than the vertical center of the ball then the opponent should move down that's all you need for the direction this can be done in a single line of code so pause the video now and see how how you get first of all we will need thunder in it with self the groups and we are also going to need access to the ball after that super Thunder innit with the groups and that way we are calling all of this which means we already have a Sprite and for now I am going to comment out get direction because what we can already do inside of main.py I can create an opponent class for the groups we need self. all Sprites and self do pedal Sprites for the ball I want self. ball if I now run all of this we are getting an attribute error that opponent object has no attribute get direction that happened because inside of Sprites we have a very basic setup meaning we get all of this but then because of the inheritance we are also getting this update method which is trying to get the old rectangle but then it wants to get the direction which can do for the player but we cannot do it for the opponent because we do not have get direction inside of it if we uncomment all of this and then for now add self and pass in there then this problem should be solved we can now get a direction afterwards we are trying to call self. move which does exist inside of the parent class meaning it should be working however if we are trying main. Pi we're getting another attribute error that there's no speed in inside of the opponent which should be obvious because inside of this thunder in it there's no speed for the player we are creating a speed separately which is also what we want to do for the opponent inside of the dunder init method I want to have speed and opponent the key value pair that we are getting in here if I now run main. Pi if I move the player you can see that we have an opponent although the issue is that the opponent is on the wrong side so this is no good this happens because when we are creating the parent we are setting self. rectangle to this position how can we fix that and well when we are creating the opponent we can simply overwrite self. rectangle or to be a bit more elegant we can update self. re. Center to PA and the opponent the value that we are getting from this dictionary and now inside of m.p we have the opponent in the right position that is working really well all we need at this point is the get direction method first of all for that we need to know where the ball is inside of the game and we are already passing the ball as an argument into this class which we want to store as an attribute self. ball is ball and then basically we want to get self. direction which as a reminder is simply an integer it can be one or negative 1 in my case I want this to be one if self. ball. Rec do Center Y is greater than self. rect do Center y if that's not the case else it should be 1 imagine that this is the opponent and we have the ball somewhere here in this case we have the center of the opponent here let's say this is a 100 while the center of the ball is something like 100 50 with those numbers this if statement is going to trigger as a consequence the direction of the opponent will be one or in other words we are moving down and that's the basic logic if I now run main. Pi we are already calling get direction so this method is running already and it's looking pretty good now the opponent is following the ball and this is working forever and at some point the opponent does miss the ball which which is perfect so with that we have the opponent and we didn't have to write very much code to set all of this up and the same for the player the actual logic inside of this one is very very simple the actual work happens inside of the padal and this is going to be reusable which also means that you can make updates in here very easily and for a more complex project this is basically always something that you want to do it makes your code much more easily manageable to finish up this game I want to add a score and a saving mechanic that way the game becomes much more interesting and we also cover a really important game mechanic after this we are also going to add some more minor bits but those aren't too important first of all saving in a game simply means that we want to store some data permanently in our case when we are closing the game we are going to create some kind of text file with the score and when the game is starting again we are loading that text file that's all that's really happening in here the only thing that we really have to worry about is the file format and I want to use something that is called Json or JavaScript object notation this is a really common format to pass data around online and python can use it really really well although truth be told you could also just create a text file or an Excel file or if you really want it you could store the data in a JPEG file it is entirely up to you but Jason usually is the default and just for an example this is what ad Jason fire looks like it is fairly similar to a python dictionary although you do have to be careful here Json is not python it's an entirely separate file format it just happens to look very similar now to implement all of this first of all I want to have a score section in my Dunder ined method of the game where we are creating a score dictionary for which we have a player key with zero and we have an opponent key as well so this dictionary is going to keep track of the score and that we want to display I.E Define display underscore score no need for custom parameters and in there we want to display the player score and the opponent score for both we are going to need some text or in other words we want to create a player surface and for that we want to do something like self. font. render a font we don't have at the moment right below the score self. font is going to be py game. font. font for the font style I will go with the default one none for the font size I want to have something fairly large 160 with that we have a font that means we can get self. score and the player that being said inside of the random method we always need a string so we have to convert this right away using the string method afterwards we have antialias which should be true and then we will need a color which we are getting from colors and in there is BG detail I think I called it the final entry BG detail that is going to give us a player surface next up we need a player rectangle or in other words where we want to display this surface I want to get the player surface and then get F rectangle I want to place the center and for X I want to have window Wii / 2 plus a 100 or Y I simply want to get window height divided by two finally self. display surface do blit with the player surface and the player rectangle to make sure we are testing all of this inside of the run method before we are drawing all of the Sprites but after we are drawing the background I want self. display score let's try and there we can see the player score it doesn't do anything at the moment but at least we have something after that I can copy all of this and then rename player to opponent for all of those I want to have the opponent also for the score we want to have the opponent and then for the position we don't want to go 100 pixels to the right we want to go 100 pixels to the left let's try all of that and there we have two scores that looks good finally I want to add a line separator here which simply is going to be pam. draw doline on self. display surface with the BG detail color then we will need a start position and an end position along with a line width for the start position I want to get 4X window width divided by two and zero we are in the midtop of the window then for the end position window wi divided by two and and window height and for the line WID I went with 10 if I now run all of this again we have a line separating the two sides of the field that looks good I suppose you could argue that the line width is just a bit large maybe six is a bit better just choose whatever you like the most in here there really isn't a universal answer anyway with that we are displaying the score which means whenever we are updating the score we are actually showing the result now to get those values I want to create an update score method with self and the side that we want to update inside of this method self. score and then by default pick the layer but only if side is equal to layer if that is not the case else I want to get the opponent that way I am getting one of the value vales and I want to increase this value by one and that's all we need to update the score for one of the sides and this method is going to be called from inside of the ball class which means in there we want to have self. update score after that when we are working with the ball we will need one more parameter update uncore score and this we want to turn into an attribute right away self. up underscore score is going to be update score that's a good start next up when we have a wall Collision for the left and the right side instead of making the ball bounce we want to update the score which means we don't need those two if statements anymore and we can replace them with if self. re. write is greater or equal than the window Wii or self. wct do left is smaller or equal to zero if that is the case we want to self. update score for the argument we will either need player or the opponent by default I want the player but only if self. Rec do X is smaller than the window wift divided by two or in other words if the ball is on the left side of the field then I want to insert player if that is not the case else we're going to insert opponent Let's test all of this and let me miss the ball and the score should update and it does although the issue is we are not resetting the ball so this method keeps on triggering to fix that I want to run self. reset which is a method that does not exist at the moment to fix that Define reset with self and no other parameter all that we need in here is first of all self. rec. Center we want to place the ball right in the middle of the window which means window width divided by two and window height ided by two on top of that I want to randomize the direction again the same thing that we have done up here in fact we could simply copy the line and paste it in there if I now try all of this again the ball is resetting in the middle of the window and that's already feeling quite a bit better that's a really good start now we can start working on saving the score at the moment the score is not permanent whenever we restart the game this is the score that we are starting with to fix that we need to do two things number one when we are quitting the game we want to create adjacent file that stores the score data and then when we are starting the game again we want to load that file and and overwrite self. score for all of that first of all we will need another python module which is called Json and this one comes with python so you should already have it after that when we are exiting the game I want to create a file which we are doing with open and then we have to specify a file path which we are once again doing via the join method I want to go to the data folder and then create a score. txt file and in case you're wondering in our file path we have the code folder and then we have data which at this point is entirely empty this would be the first argument inside of open the second one has to be a w short for writing on other boards we are indicating that we want to write this file and then inside of python we have to store all of this data as a variable I'm going to call it score uncore file inside of this whiff statement we want to call Json and then dump in there we want to pass in self. score so the data we want to save and then the score file the file that we actually want to write in and with that we are done if I now Run the game and let me get a different score than zero and zero if I now exit the game we didn't get an error but if I'm looking at our folders inside of data we have score. txt and in there we have the player score and the opponent score that was literally it with that we can create external files next up then when we are starting the game we want to load that file which we're doing in a similar way once again I want to use with open and then the join method in which which I go to data and then score. EXT important now we do not want to add a second argument like we have done down here because we only want to read this file we do not want to write any kind of data in there at this point and this we want to store as the score file we want to get Json load and the score file this is going to load all of the Json data and return a dictionary in our case this is going to be self. score and well that is basically it I can now comment out the original Self do score if I now Run the game we have the score from the last game so this is working really well and if I am getting another score let me try to defeat the opponent at least once and that is working and if I am getting another few points in there if I I now open score. txt we have once again updated the score this is working really well that means we are nearly done there's just one more thing that we want to be conscious of if the game starts for the first time and score. txt does not exist so let me simply delete this file if we are now trying to run the code the issue is that we do not have score. txt that is something we can fix fairly easily we want to indent this if statement one more time and then add try which is telling python to try this line of code and if we are getting an error and if we are getting an error then we want to do an accept statement or an other words if we have this Json file we want to create a score from that data but if we don't so accept then we want to create a new self. score dictionary I can run the game and by default we have no score but once we are getting something I can close the game and we are getting score. txt and that is all you need for a very basic saving mechanic wasn't actually so bad that also nearly finishes the game there are just two more things that I want to do both of those are going to be your exercise number one I want to have a delay when the ball resets that way the player has a bit of time to to adjust and besides that I want to add Shadows to the pedals and the ball a fairly Minor Detail but it's going to make the game look much better by the end of it you should have something like this so pause the video now and see how far you get righty let's get started with the ball reset or which I want to create a timer inside of the dander ined method of the ball we will need self. startor time which is going to be py game. time.get uncore tix on top of that I want to have self. duration I put this one at 1,200 once we have that I want to create below reset a timer method which is going to check if py game. time.get ticks so the current time minus self. start time is greater or equal than self. duration if that is the case we want the ball to start moving which in my case I'm going to do via self. speed modifier if this timer times out this value is going to be one if it doesn't self. speed modifier is going to be zero and then inside of the move method we are multiplying the actual movement with self. speed modifier so if this value is zero we do not get any movement for all of that we have to under movement at self. speeed modifier and set it to zero also we have to call the timer before we are doing any movement self. timer with that if I run m. Pi after about 1 second we're getting some movement so so that is looking pretty good after that inside of the reset method I want to update self. start time with py game. time.get X that way inside of the game once we are getting an update to the score we have to wait a second and then the ball starts moving again so that is working pretty well let's try it one more time and that is working perfect that covers the first part next up I want to work on the shadows for that first of all I want to give all of the entities another surface let's do it right below the image I want to have a shadow surface for which we will need self. shadowcore surface which is going to be a surface with the same size as the image or words self. image. copy on this new Surface we also want to draw a circle in fact I can duplicate this entire line although we want to draw on self. Shadow surface for the colors I want to get the ball Shadow although the position and the radios should stay identical so with that we have a shadow surface how can we display it for that I want to create a custom Sprite Group which means inside of the code folder I want to add groups. I first of all in there from settings import everything and then class all Sprites with pygame DOs sprite. Group after that we will need a thunder init method with self and nothing else and we need Super do Dunder in it also I want to get self. display surface via py game. display. getet Surface after that I want to create a custom draw method for this one first of all we have to get the default Behavior which we get via for sprite in and then self. display surface. blit with sprite. image and Sprite right do rectangle after that inside of main. Pi I want from groups import all Sprites this all Sprites is then going to be our all Sprites group and when we are running the game and drawing all of this we do not need an argument anymore other than that though everything else is still working just fine so that's a really good start what we now need for the Shadows before we are drawing the actual Sprites we want to have another for Loop which is also going to be for sprite in self except that now we are calling self. displays surface. blit with sprite. shadowcore surface and for the position we want to have sprite. rec. toop left plus some offset let's say pame do Vector 2 with five and five now this at the moment is not going to work because the pedals do not have a shadow surface that we can fix quite easily because both pedals have the same parent class in there below the image we can add a shadow surface which for now is going to be Shadow surface with self. image. copy after that if I'm trying to run all of this we are getting an attribute error that all Sprites has no Shadow surface surf that is because this should be Sprite do Shadow surface instead of self let's try this again and now we can see some sort of Shadow so it's working reasonably well to refine all of this inside of the padal I want to draw another rectangle like we have done in the original except now this should have a pedal Shadow color the one that we getting from the settings or so we want to draw on the shadow surface let's try out of that and definitely getting better the one thing I don't like about this one at the moment is let me draw this actually if this is the padal our shadow at the moment would look something like this where you can very much see that we have two separate surfaces one here and one here and I want to have them connect a bit better in other words I want to have a proper line like this which would look much more like a shadow to get something like this I want to add another four Loop for I in range let's say five and then when we are drawing the Shadow the vector offset is going to be set by the I argument that we getting from the four Loop that way we are drawing multiple Shadows at an offset which is going to make all of this look much better the rest of the game though still works just fine perfect so with that we have a proper Shadow although this isn't a perfect setup because we are drawing five extra surfaces on every single frame what would be much better is to create all of these surfaces in the dunder init method and then blit them at once but for our purposes I don't think performance is ever going to be an issue so I would say at this point we are basically done that covers another game for Game number four we are going to create a basic platformer game in there you can jump around and shoot at things it's fairly straightforward and most of the logic we already know there are just three things that are going to be somewhat new the most important one is going to be the platform of logic besides that I want to have more organized Imports and I want to create better timers two things that are incredibly helpful for any even slightly more advanced project although before we get to any of this we have to start with the platformer setup by the end of this part we will have something like this this part is also going to be an exercise I want you guys to set up the level and for that load the level data from the titled map then create a player Sprite that can move and Collide and for this one the easier collisions are fine although you could also use the more advanced ones but they're not really necessary for this project and finally add a camera that follows the player and if you open the project folder you can see that we already have a couple of things inside of main.py we have a game class and this one initializes is the basic stuff and then creates two groups then we have a run method where we are doing the usual stuff all of that is giving us a basic window with a background color inside of settings.py we have a few more basic things but none of them are too complicated also if you look at the project folder besides the code folder with Graphics maps and title sets we have a whole bunch of images those you don't have to worry about at this point and we have a bunch of audio files those also don't matter too much at this point what you want to primarily work in is code and data and Via those try to finish the exercise see how far you get inside of the game class I want to create a setup method and for now I want to load the TMX map or in other words I want to create a local variable let's call it TMX map this I get via load pame where I want to go to data and Maps if I show this in the file explorer we want to go to data maps and there we have world. TMX this is the file we want to load world. TMX if you open that file by the way you are going to get something like this where we have three layers main decorations and entities on the main layer we have the actual level on decorations we have a whole bunch of well decorations and finally for entities we have the player start position this one up here and then we have a couple of areas all of those are for the warm enemies not too important for now so don't worry about it all that we care about at this point is decoration and Main to set up the level which means to get started I want for x y and the image in GMX map and get layer by name the layer that we want to load is called main since this one is a tile layer I want to add Tiles at the end that why I am getting XY and image decoded right away I want to create a very simple Sprite class in which we can add an X and Y position then the image and then the groups the groups we actually already have all Sprites and collision Sprites those we want to add in there right away s a tuple self. all Sprites and self. Collision Sprites also remember X and Y inside of tiled is a grid coordinate but we want to have all of this as a pixel position for that from settings we want to get the tile size and multiply it with both of those values with that we can create a basic Sprite for which I want to create a new python file Sprites dop in there we want from settings and import everything and then create a class called Sprite wave pygame dos sprite. Sprite then we will need a Dunder init method with self a position a surface and the groups afterwards we can call Super Thunder init and pass the groups right through self. image is going to be the surface and self. will be self. image doget F rectangle in which we are going to place the top left wherever the position is that covers the basic spread class back inside of main.py I want from Sprites import everything that way this Sprite should be working all that we have to do is let me add another section load game in which we want to call self. setup and with that we get one part of the level that looks really good while we are here we can also duplicate those two lines because besides main we also have decoration which should only be in self. all Sprites there should be no collisions with those tiles but other than that this is all we had to do for this part after that I want for obj in TMX map and get layer by name entities that is an object layer on which we have the player starting position which we can identify via the name player or in other words I want to check if obj do name is equal to player and if that is the case I want to create a player class for now in there I want to have the position objx and obj doy then I will need self. all Sprites for the groups and self. collision Sprites for the collisions later we are going to add a bit more but that's not an issue for now I first of all want to create another class called layer and important for this one I want to inherit from Sprite the class that we have just created we will always need a thunder in it method and we need what we have specified here a position groups and collision Sprites self position groups and collision uncore Sprites then we will need Super thunder in nit and important now we are calling this thunder init method for which we will need a position a surface and the groups now we do have a position and a groups via the parameters that part is fine but we don't have a surface at the moment which is totally fine we can simply create a surface via pame do surface for now the dimensions are going to be let's say 40 and 20 also while we are here I want to create an attribute self. Collision unor Sprites is going to be Collision Sprites with that if I'm running main. Pi we can see a very basic player thingy although I think it should be quite a bit taller instead of 20 let's go with 80 that feels much more realistic that would be the basic player I want to call an update method with self and Delta time for which we are going to need self. move and this move method is going to consist of two parts the move method itself with self and data time and then we will need Define collision with self and E direction to get started with moving we want to get self. w.x plus equal self. direction which doesn't exist at the moment and for that we can actually create a movement and collision section which is going to contain Direction P game. Vector 2 that is a part we have seen a couple of times by now and also in this bit I want to have self. speeed for for this one I went with 400 with that we have self. Direction multiplied with self. speed multiplied with Delta time this I can duplicate because the next line should be self. re doy and I realized for X we want self. Direction dox and for y self. direction. y that way we have the horizontal and the vertical movement afterwards we have to call self. Collision with horizontal and vertical that would cover the basic movement to test all of this I want to have an input method in which we are getting the keys and then py game. key doget uncore rest at least for now I want to update self. Direction dox and set it to the integer of keys and py game. Kore right minus let me copy all of this and change K right to K left then we can duplicate all of this and then K down minus K up also we want to get self. direction and set it to self. direction. normalize if self. direction if that is not the case we simply want to get self. direction also before we are moving I want to call self. input with that if I run main. Pi the player can move around just fine that is looking pretty good for the collisions I want to check for sprite in self. Collision Sprites if sprite. rec. cide wed with self. rectangle and by the way for this project you could be using hitboxes but you don't really need to if you want to add it do it in your own time afterwards if Direction is equal to horizontal then we want to check if self. direction dox is greater than zero then we know self. re. write should be equal to sprite. do left then we can duplicate all of this and check if the direction is smaller than zero in which case self. re. left should be sprite. re. right next up I want to duplicate all of this and then check the vertical collisions in which we want to check self. direction. y if this one is greater or smaller than zero if it is greater than zero we are moving down and want to check the bottom of the player if this one collides with the Sprite we want to set the bottom to the top of the Sprite and vice versa if the player is moving up and we have a collision then self. rec. Toop should be sprite. w. bottom if I now run around we're getting collisions with the level finally then we are going to need a camera for that inside of the code folder I want to add groups dop as always we will need from settings and import everything then class all Sprites which is going to be a child of pygame Dos sprite. group a Dunder init method is always needed although this one without custom parameters and we want to call Super Dunder init also self. displore surface is going to be py game. display and get surface that's the easy part besides that we want to have a custom draw method with self and a Target uncore position via this target position we want to influence uence self. offset on X and Y and at this point I realized I have forgotten to create self. offset this one is simply a pame vector 2 self. offset dox is going to be the negative value of Target position zero or the horizontal position of the player and from that we are subtracting window Wii divided by two a very similar thing we want to do for self. offset doy except for this one we want to get the vertical position and subtract window height divided by two that way we are getting the offset for the camera that we can use with force sprite in itself and self. display surface. blit with sprite. image and sprite. rec. toop left plus self. offset with that back inside of main.py when we are calling all Sprites do draw we do not want to have the argument anymore and also when we are creating all Sprites this should be all Sprites and for that to work we have to add from groups import all Sprites nearly done the last thing that we have to do is when we are calling the draw method we have to get the player position for which we want to store the player in an attribute self. player is going to be the player Sprite and then self. player. re. Center let's try and we have a camera that is looking pretty good with that we have a basic setup via a few classes so I hope at this point this exercise wasn't impossible and if you could follow along you already know pame pretty well we have to Basics out of the way we can work on the platformer logic which is going to give us an actual platformer game and quite honestly we don't really have to make that many changes for the platformer movement the player is still going to control left and right movement however for up and down the player doesn't have control anymore instead we are using gravity and jumping or in other words we have to increase Direction doy by increasingly large number numbers that way it looks like the player is affected by gravity and when the player jumps we are setting Direction y to some static negative value and we'll talk about this in just a second in a lot more detail that being said though including Delta time with the full speed does include a bit more math which I want to avoid so we're going to set the frame rate to 60 frames per second although if you want to have the full platform experience check out this video in there I create a proper super nintend Nintendo style platformer including an Overworld if you have gotten so far you can follow along with this tutorial just fine back in the code first of all I want to update the frame rate and this I have actually already done because when we are calling the take method we are passing in the frame rate that we getting from settings. PI there we have a frame rate of 60 we already limited our frame rate which for a platformer can be a good idea it makes your math just a bit easier after we have that inside of the move method I want to add a comment with the horizontal movement this is the part we're not going to touch but we do have to make some changes to the vertical bit for now what I want to do if this is the player we should have a downward movement that is getting larger and larger the longer we fall just like real world gravity for that in the dunder init method of the player I want to add another attribute self. gravity which I have set to 50 before we are updating self. r.y I want to update self. Direction doy and increase this value by self. gravity multiplied with Delta time afterwards on the next line self. rec. Y is going to be increased by self. Direction although for this we don't need speed and Delta time anymore and what is happening now on the first line when then we are increasing self. Direction doy we are making this value larger and larger on every single frame because we keep on adding to the existing value on top of that this self. direction we are adding to the vertical position of the player that way we are falling at an increasingly large speed although if I run main. Pi we are well we are falling and we have collisions but if I keep on falling we are falling at a constant rate rate what is the issue here and well if you look at the player in the input method we are normalizing the direction Vector because of that all of these values are normalized or in other words the entire length of the vector never exceeds one fortunately that is very easily fixable we simply have to remove those two lines and then if I run main. Pi we are getting proper gravity although it's still not ideal let me run all of this again so we have some basic gravity but if I fall again we are falling really fast the issue for all of this is imagine that we have the player standing on a platform and also because of those two lines we keep on increasing the gravity on the first frame the player move down by this amount and then be constrained by the platform which is totally fine a few frames later we go a bit further down because of the gravity and we are still constrained by the platform however after some more time the gravity puts the player so far down that we are skipping the platform entirely as a consequence the player teleports right through and all of the collisions stop working we are simply moving too fast for them to fix that we want to work inside of the collisions specifically when the the rectangle bottom of the player collides with the top of an obstacle if that is the case then we also want to set self. Direction doy to0 with that if we are on the floor the gravity doesn't keep on increasing which means we get proper gravity and if I fall down again we get a much nicer gravity Behavior now other than that we can't really do very much but at least this part is working next up then I want to implement a jump mechanic for which inside of input I want to check if keys and py game. Kore space I want to set self. Direction doy to 20 with that inside of the game I can now jump around and this is giving us a very basic platformer that's looking really good but it's not ideal yet because the player can jump the entire time even if we are not on the floor so essentially we are flying which could be a nice effect but not what I want for this game we only want to allow a jump if the player is on the floor for that I want to add another attribute self. onore floor which by default let's set this one to fults and only allow a jump if we are pressing space and self dot on floor so how can we tell if the player is on the floor that part is going to be your exercise I want you guys to find a way to detect if the player is on the floor or not try to figure this one out on your own I want to work inside of the Collision method and effectively if we have a vertical Collision where the player is moving down then we are already setting Direction doy to0 that means we must be on the floor in other words self. on floor is going to be true although you also need to be careful here because at the moment we are only ever enabling on floor we are never disabling it or in other words if I now run main not Pi the player can still jump around in the air to fix that at some point we have to set self. on floor to false and this I want to do inside of the vertical movement before we are doing anything else in there self dot on floor should be false so that basically on every single frame of the game we are first setting on floor to false then we are doing all of this and inside of the collisions if the player collides with the floor then we are setting on floor to True once we have that inside of main Pi I can only jump if the player is on the floor so I keep on pressing space but we only ever get a single jump that being said I am not the biggest fan of this approach ideally before we getting the input I would want to self. check uncore floor and put all of this into a separate method which we can Al do fairly easily for that I want to have a check uncore floor method without any custom parameters also self. on floor inside of collisions and inside of move should disappear instead what I want to do inside of check floor I want to create a bottom rectangle which we're going to do via py game. F rectangle in which we first of all need a position this this can be 0 and zero we will change that in a second anyway and the width of this rectangle is going to be self. rect do width and a height of two imagine this is the player and we want to check if this player is on the floor what I want to do for that is create another rectangle right below the player and check if this rectangle collides with any of the floor tiles and that rectangle is going to be the bottom rectangle although at the moment the position of this rectangle is off I want this always to be at the bottom of the player and for that we can add in another method move to because in there you can specify a specific point that we can place in my case this is going to be the mid top the position of this point should be self. rec. mid bottom so one of the limitations of py game. re or py game. F re is that we are always placing the top left so whatever Point you're specifying in here is always going to be the top left which very often isn't what you want and using move two is a really handy way to get around that so next up we want to check if this rectangle is colliding with any of the Collision Sprites for that you could write a for Loop but I prefer another approach the way I approach this I am first of all going to create a level rects list I want to use list comprehension and then get sprite. Rec for sprite in self. Collision Sprites that way I am getting a list of rectangles that Define the level and then I want to get the bottom rectangle and check Collide list with the level recks that we have just created and just to demonstrate what is happening here let me print the return value and then run main. Pi we are now getting 34 35 51 59 60 and seemingly a random integer what does it mean and also really important if we don't have a bottom Collision then we getting ne1 essentially Collide list is going to look at the collisions between the bottom rectangle and the level rectangles and it's going to return an integer of the index of the rectangle that we are colliding with and if there's no Collision we getting negative one or in other words if we have a negative one then we know there's no Collision which means we can do something like self dot on floor is going to be true if we have a bottom wck with Collide list and this value needs to be greater or at least equal to zero if that is not the case else this value should be false once we have that the player can only jump if we are on the floor also we can refine all of this by simply passing the list comprehension straight into Collide list that way we are saving one line and the code feels a bit more elegant and if you want to have a more advanced platformer being able to detect collisions with the floor or the walls is really important so with this logic you could also very easily detect a collision with the left or the right side of the player but anyway there's just one more thing that I want to do back inside of the game there's one issue right now if I jump and we have a top Collision the player hovers in the air for just a bit which is a very strange effect if I find another area you can see it even better here if once again this is the player and the player is moving up because we are jumping and then we have some kind of top Collision we are stopping the player at the bottom side of this Collision but the player direction is still pointing up and it takes a while for Gravity to pull it down again that way it looks like the player is hovering in the air and this we can fix quite easily by setting self. Direction doy to Z if we have a top or bottom Collision that way inside of main. Pi I can collide with the top and to player fults down immediately and this is feeling a lot better and once again all of this can be organized just a bit better I want to remove the indent and cut out self. Direction and for self. direction being smaller than zero this should also not be indented anymore and all we really want to do is set self. direction if we have the vertical direction that way back inside of main. Pi we should be getting the same result let's try it here that is looking really good so this seems to be working pretty well perfect and also our code is feeling a lot more organized quite honestly there really wasn't that much of a change compared to a top down game although for the animations we do have to include a few more bits that's going to be the next section for the next part we are going to cover Imports and animations by the end of it we have a basic player animation and we also have the very basic enemies at this point the enemies don't do very much but that we can work on later and there isn't going to be that much new stuff for this section we are going to use basically the same animation logic that we have already seen the only change is that we have to update the state management for the player who account for the platform of logic that being said when we are doing the input ports I want to centralize them quite a bit more or in other words I want to have one method that loads all of the files and then we don't have to worry about it anymore inside of the game class I want to create a method called load uncore assets no need for custom parameters and in there I want to load all of the graphics and all of the sounds for example in there I want to have self. player frame which should be a list with the animation frames of the player or in other words to visualize all of this inside of images we have a very basic player animation it really doesn't do very much all of this we want to import for that I want to create a separate function import uncore folder in which we can specify the file path I want to go to images and in there we have the player this I want to import which which doesn't exist at the moment for which we want to create another python file let's call it support. Pi in there as always we will need from settings and import everything and then I want to start by creating an import image function this is not going to import an entire folder so we couldn't use it for the player import but what we could be using it for let me comment out the player stuff and instead I want to import self. bullet surface or in other words what we want to start importing is inside of images we have gun and there's bullet and fire I want to import the bullet for now via a more convenient method or in other words I want to run import uncore image with a file path we want to go to images then we want to go to gun and finally we want to go to Bullet notice here I am not specifying the file type we do not addpng at the end and that is intentional also what we are going to need is from support import everything that way we have this import image and first of all what I want in there is to unpack all of the arguments which are going to be the path so all of this stuff we want to have straight away and just so you can see what we are getting via this unpacking parameter I want to print the path and then call load assets which we have to do before we are calling the setup method self. load assets and now if I run all of this we getting a tupo with the three arguments we have specified and because of this unpacking parameter we can specify as many arguments as we want we are always going to get a tupal with all of them which we can actually use to create a full path right away using the join method we simply have to add the path in here although for that we want to unpack the path one more time that way we are splitting up this tupal into three values and then we can use it inside of the join method the end result is going to be if I print the full path we getting the full path to this file images gun and bullet that is looking really good although we are also going to need the file format this I want to be able to specify inside of the parameters in there I want to have a format and since we are almost always working with a PNG file this should be the default or in other words if we don't specify anything we should be getting a PNG file and to add that to theault path I simply want to add an F string with Dot and then the format that way I can run main.py again and we are getting images gun and bullet.png that is working really well that we can now use to import a surface via py game. image. load with the full path and now we have to decide do we want to convert all of this or convert Alpha all of this which depends on the image having Alpha values or not which we cannot really detect meaning this has to be another parameter I want to know if there are alpha values inside of this image and by default I am going to assume that there are some because that's usually what you see and then run convert Alpha if Alpha is true and if that is not the case we want to run all of this once again except now only convert without Alpha and that is basically it at the end of all of this we want to return the surface and then we are getting the surface inside of this parameter I can print self. bullet surface run all of this and we are getting a surface we are still doing a basic import via py game. image. load but we are now adding a few more extra things to make all of this quite a bit more convenient not a major change but if you have to import hundreds of images this can be a massive difference and by the way all of this can be made quite a bit more elegant right away we don't actually need a surf variable we can return the surface from py game. image. load right away the result would be identical so with that we can import a single image much more elegantly besides that I also want to be able to import a folder for which once again we want to specify a path and unpack it right away via that we are going to import all of the player frames we are already calling import folder and getting images and player notice here this is a path to a folder not to an image so what we want to do is import all of the images inside of this folder I first of all want to create a local variable called frames and this has an empty list by default afterwards we want to do for folder uncore path and then subfolders and finally file uncore names in walk join and then unpack the path this is the logic we have already seen a couple of times we are basically using the walk method to walk through a folder and get the folder path the subfolders and the file names in there I want to have for file uncore name in file names and then create a full underscore path which we're doing via the join method where we are getting the full folder path and then the file name via this we can create a surface with py game. image. load the full path and for this we basically always want to convert Alpha now you could make this a bit more flexible like we have done in import image and add a custom parameter although I don't think this is really necessary after that I want to get the frames and then append the Surface by the end of it I want to return the r with that back inside of main. Pi I can print self. player frames run all of this and we are getting a list of surfaces that is all we need for the player animation frames or rather the import of the player animation frames now this I want to change in two ways the first one is easy once again we don't really need this local surface variable we can simply append High game. image. load to frames straight away also since we're not using subfolders there should be an underscore besides that this slightly more important change is that I want to sorted the file names just to make sure that they are being imported in order for that we will need a key with a Lambda function where we have a name parameter and once again as a reminder what we're getting with the file name is something like 0.png and we want to isolate the zero and turn it into an integer that way we can sort all of these values which means I want to create an integer get the name and split it wherever we have a DOT and then pick the first value the end result is going to be the same but in some cases it might prevent a bug but anyway with that we have the basic graphic Imports what we can now do besides the bullet surface we also want to have a fire uncore surface that we are getting via import image and we want to get images gun and fire next up I want to have self. bore frames which we're getting from import folder I want to go to images there we have the enemies and in there we have the b or in other words if you look at the images folder there we have enemies and the B frames there are only two images in there besides that we have the worm and this one looks really similar or in other words I can duplicate this line and then get the worm frames with images enemies and worm and that that is covering all of the Imports for the graphics now we have to figure out how to use them for that I want to work inside of the Sprites for a basic animation I want to have a class animated Sprite Which is going to inherit from the Sprite class that we have created so let me open it this is going to be the parent class which means when we are calling thunder in it I want to specify besid self the frames a position and the groups after that when we are calling super thunder in nit we are calling this thunder init method for which we do have a position that we don't have a surface but then once again we have a group's parameter so we have to figure out this surface for that we need just a bit more information I want to have three attributes self. frames self. frame uncore index and self. animation uncore speed the values for all of them are going to be the frames parameter the value zero and for the animation speed I went with 10 once we have that inside of super Dunder init we can get the surface via self. frames and self. frame index that's basically it besides that I also want to have an animate method wave self and Delta time in there self. frame index plus equals self do animation speed multiplied with Delta time and self. image is going to be self do frames with an integer of self. frame index then modulus with length of self. frames that would be a really basic animated Sprite class and I hope you can see at this point why inheritance is quite useful for this class we never specify the image or the rectangle all of that is handled via the parent class and that system we're going to expand on quite a bit because animated Sprite is never going to be used inside of the game the only way that we are going to use it is as the parent class for the player and there we want to have the animated Sprite for that to work we have to make a few changes most importantly when we are creating one instance of the player I want to have a bunch of frames and also we don't want to have a surface anymore instead I want to pass the frames through to the parent class because now when we are calling this Stander init method we are effectively running all of this for which we are going to need frames positions and groups and I really realiz the order here is a bit messed up the first argument needs to be frames then we have the position and then we have the groups once we have that inside of main. Pi when we are creating the player instance we have to add one more argument self. player frames and now if I run all of this we have a very basic player image which isn't animated yet because we we are not calling the animate method that is a very easy thing to fix inside of update self. animate with Delta time after that we are getting the animation that is looking pretty good and once again notice here we didn't write any logic inside of the player for the animation all of that happens inside of the parent class which makes it much easier for us to organize all of this although truth be told we do have to override the animate method I want to have inside of the player Define animate with self and Delta time or in other words at this point from animated Sprite this method is not going to work anymore that is necessary because for the player we have to account for the different states for example if the player is not moving then we shouldn't have an animation but step by step first of all let's recreate the very basic logic I want to have self. image is going to be self. frames and then via the integer we are doing self. frame index modulus with the length of self. frames also we're going to need self. frame index plus equal self do animation speed multiplied with Delta time although this we only want to do if a certain condition is true in my case if self. direction dox is different from zero or in other words we only want to update the animation if the player is moving left or right with that back inside of main. Pi if I'm not moving we have no animation however once I'm going left or right the player is animating that is working quite well also if the player stops moving else then I want to set self. frame index to zero that way we are going back to the starting position let's try and I can move around if I'm moving we get the walking animation but if I stop moving the player is Idle the one major thing that is missing at this point is that the player is always facing to the right to fix that I want to inside of the dander init method add another attribute self. flip and by default this one is going to be faults next up after we have gotten the part from the animation I want to add another thing to self. image or in other words I want to run py game. transform. flip with self. image self. flip this is for the horizontal flip and for the vertical flip this one should always be false that why by default we are not going to get any change however if we are setting self. flip to through then the player is always going to be flipped with the animation still working just fine which means we just have to update this value in real time which we're doing inside of this if statement if we have movement or in other words if self. direction dox is different from zero then we want to set self. flip to self. Direction dox being smaller than zero this is going to return a Boolean value if if we are moving right it's going to be true if we moving left it's going to be false and this is then going to influence the flip method I can move to the right and to the left and we always get the proper facing Direction so this is working quite well the last thing that I don't like is that if the player is jumping we still are playing The Walking animation which looks really weird to fix that before we are doing anything in the image I want to check if not self. onf floor or in other words this if statement is checking if we are in the air and if that is the case self. frame index should be zero let's try now and if I'm on the floor we have the walking animation but if I am jumping we are getting the first frame so this is kind of working the issue is we don't want to have the frame with the index zero we want to have the index one that is going to look much better now it looks like the player is jumping which I like much better and this we can make just a bit more elegant I want to set self. frame index to one if the player is not on the floor if that is not the case else then we want to keep self. frame index and then we also don't need the other stuff anymore and that feels a bit nicer the end result though is still going to be just the same perfect and with that we have a very basic player animation which is getting us very close to a proper platformer to finish up all of this let's do an exercise I want you guys to do two things number one create a class for the be and to worm later on those two are going to behave differently so we will need two classes although both should animate from animated Sprite then create one instance of each in the level and really important for this one both of these enemies should be animated besides that write a function to import all of the audio files you don't have to play them at this point I simply want to have all of the files inside of the game that should be quite a bit of work pause the video now and see how far you get righty to get started with the enemies I want to create another class called e and this one for the parent is going to have an animated Sprite Which which means when we have the dunder init method we want to have a bunch of frames a position and the groups and then I want to call Super Thunder init in which we are calling this thunder init method for that we already have all of the arguments we need the frames the position and the groups and that is all we need to get started so inside of main.py when we are calling the setup method I want to create one instance of a b somewhere on the level for that we will need self. B frames the input for that we have done earlier this value here for the position let's go with 500 and 600 to entirely random values finally for the groups I want to have self. all Sprites for now after that if I run the game you can see we have one B inside of the level doesn't do anything at the moment but at the very least we have something and to animate this B you could simply write an update method inside of the class don't forget Delta time and then call self. animate with Delta time if you do that we have an animated B so this is all we needed for this part next up I want to copy all of this and then create a warm class which for now at least is going to stay identical to the b class which means inside of main. Pi I want to create a warm and for that we will need self. warm frames for the position let's go with 700 and 600 and then self. all Sprites I can run the game now and we are getting a warm somewhere in the air not perfect yet but that we can work on in the next bit before for that we want to import all of the sounds for which we could do something like import image or in other words we could wrap py game. mixer. sound in some other stuff to make it more efficient but I want to go a bit further I want to have self. audio and this is going to be a dictionary that will be created via audio importer the file path for this one is simply going to be audio this function doesn't exist at the moment so in inside of support. Pi I want to have audio uncore importer for which we need a path parameter that we are unpacking right away in there first of all I want to create an audio dictionary which doesn't have any values by default then once again I will need for folder uncore PA we don't care about subfolders so underscore and then file underscore names in walk join and unpacking the path in there we want to check for file uncore name in file names and now we don't have to sort the file names because we don't care about the order of the sound files this one simply doesn't matter I want to create a full underscore path via the join method I want to combine the folder path with the file name once we have that I can get the audio dictionary and then create create a key which should be the name of the audio file and I should actually explain so at the moment we don't need code data or images I want to look at the audio folder in there we have impact. OG music. wav and shoot. wav for this audio dictionary the key should be the name of the file without the file ending which I can get via the file name and then use the split method once again to split all of this wherever we have a DOT and then pick the first value that way we're getting the name of the file without the file ending and the associated value should be py game. mixer. sound with the full uncore path and that is literally it at the end of all of this we can return the audio dictionary and that we are capturing inside of self. audio in other words if I print self. audio and run the entire game we are getting a dictionary with three sound files or rather three key value pairs the name of the file and then the sound object and to use that all we would really need to do for example to play the background music is self. audio and then the music with play inside of the game we are getting some music although this isn't something that I want to do because it would be really distracting anyway with that we have a whole bunch of imports and we have the player animations for the next section we are going to add proper timers which are going to do quite a bit inside of the game for example we have a cool down for the bullets and every time the player shoots a bullet we have a short fire animation both of those things are going to be heavily influenced by the timers on top of that we have a repeated timer that creates a b enemy and all of this we want to have as flexible as possible or more generally games rely heavily on timers for example for this game whenever the player shoots a bullet we have a cool down we spawn a b every X seconds we have a fire sprite animation for a bit that gets destroyed after a few milliseconds and all of the enemies will die after 0.2 seconds after being shot for all of these things we will need a timer or other words ideally we want to have a reusable timer that can do number one be easily called anywhere it should also call a function on timeout and it should be repeatable and for all of this we have already seen the most fundamental Logic for a timer we are simply getting the current time subtract the start time and if the resulting value is greater than some duration we are doing something this is some very basic logic but this I want to expand upon and also at this point I do not want to use the build python events anymore because those just aren't that flexible and the system that we are going to create will be much better for all of that back inside of the code I want to create another python file timer. Pi first of all we will need from settings and import everything afterwards we have a timer class without any inheritance I want to have a Dunder init method with quite a few parameters the most important one will be the duration besides that we have a function with a default value of none then we have a repeat value also with a default value of none and we have an auto start parameter that by default is going to be false after that I want to set self. duration to the duration I want to set self. start time to Z and finally self. active is going to be false by are those three values we can create an update method in which we are fundamentally going to check if the current time minus self. start time is greater or equal to self. duration and if that is the case we want to do something now this is not going to work at the moment because we do not have the current time for that we would need py game. time.get Pi next up if this if statement does happen to be the case we want to run self. deactivate and while we are here I also want to create an activate method without any custom parameters so we want to have activate and deactivate for both of those methods for self. activate we want to have self. active being through and self. start time is going to be py. time.get uncore tick for deactivate we are going to do basically the opposite self. active will be BS and self. start time we can set back to zero and that is all you need for a basic timer to go over it really quickly by default we have the dander in it method and to activate the timer we are calling activate in there we're getting the start time which we are using inside of the update method and there we are checking the current time and subtracting the start time if the resulting value is greater than self. duration then we are calling self. deactivate which is going to set self. active to false and to start time to zero so with that via self. active we can check if this timer is active or not and the way you would be using that let's start inside of the player we don't need any of the other classes I want to work inside of the dunder init method and create a timer section for the player we only want to have a shoot uncore timer which is going to be the timer class we have just created and for that we have to import from timer import timer for now we can only set a duration 500 or half a second we working in milliseconds here next up when we are calling the input method I also want to check if keys and high game. Kore s that is the S key on the keyboard that I want to use for firing a bullet if that is the case shoot bullet if we run this without anything else I can press s and we're getting shoot bullet on every single frame of the game or in other words we will be shooting a bullet 60 times times per second which obviously would be way too many bullets so we are going to need a cooldown timer which we get via the shoot time or in other words we want to check two conditions if the player is pressing a button and self. shoot timer. active and also this should be self. shoot timer inside of thunder in it also also we want to check if this shoot timer is currently not active or in other words after the player shoots one bullet we want to get self do shoot timer and activate it so while the timer is running the player is not able to shoot a bullet just one more thing before we can use all of this the timer is only going to work if we are calling the update method which at the moment we are not doing for this self do shoot timer so nothing would happen to fix that inside of the update method before we are doing anything else self do shoot timer do update that way inside of the game if I hold down s we are only getting one bullet every 500 milliseconds and if I increase the duration to let's say 1,500 I can try all of this again and now we are getting much fewer bullets looking pretty good besides that inside of the timer I want to have three more things we want to call a function once this if statement triggers then we want to make the timer repeatable and be able to auto start all of this and auto start just to explain it basically activates the timer when we are creating it so we don't have to call activate on it to get started with the function I first of all want to store this as an attribute self. Funk is going to be Funk before we are deactivating the timer I want to check if self. Funk exists and if that is the case I want to call it although before we continue there's one more thing that I want to add self. start time is different from zero when we are getting started the start time is going to be zero and there is a chance that py game.get tick is also going to return zero which means all of this would be running and then we would trigger this one as well and Via this second condition we are avoiding all of that a fairly minor point but it can be a bit annoying anyway to test all of this inside of thunder in it of the game class I want to have a timer as well let's call this one the bore timer for which we will need a timer class that we don't have yet from timer import timer the duration of this one is going to be 200 and then we want to call a function self. creatore B this one doesn't exist at the moment so we have to create it Define create underscore B without any custom parameters inside of this method I simply want to create a b which we have already done so in there we have a b and once again don't forget we have to call before we are doing anything else self. B timer and I realized once again I have forgotten the self anyway after that self. b timer. update now this is still not going to work because this timer does not start by default what we would have to do is call Self dob timer. activate and let's add a slightly larger value so let's say after 2 seconds we want to call this method which would create one instance of a b if I run the game and and after 2 seconds we get a B this has worked really well with that we can do an exercise I want you guys to add the repeat and the auto start functionality to the timer pause the video now and see how far you get Auto starts is the easier part actually all we have to check for this one is if auto start is true then we want to call self. activate right away with that inside of main Hood pi we don't need this activate anymore instead when we are creating one instance of the timer I want to add auto start and set this one to true if I now run all of this we should still be getting a b and we do perfect besides that we have to work on repeat that should be an attribute self. repeat is going to be repeat and basically all that we have to do once all of this is running out and we are calling deactivate we want to check if self. repeat is the case self do activate that way inside of main.py for the B timer I want to set repeat to R and I guess to make all of this a bit more visible I want to have random values from random import Rand int and then for the B position for now I want to have a Rand ROM integer between 300 and 600 and the same I want to have for the Y position also for the timer I want to have a duration of 500 and now let's try all of this and we should be getting a whole bunch of bees that is looking really good perfect and I hope from looking at this thing you can tell that this is much better than the inbuilt python events we don't have to create a custom event or work in the event Loop we are simply creating a timer and then call a function whenever it times out and that's basically it nearly done there's just one more thing that I want to do because in actual larger projects what I ended up doing a lot is checking for self. shoot timer. active and this active you can get rid of you would need let's do it right below Dunder in nich we want to have Define Thunder pool this is is what's being called if you put this timer inside of an if statement the default functionality for this one is that you are always returning true which is not what we want to do in our case we want to return self. active that way inside of the player we can simply check and not self. shoot timer and the return value would be this timer being active or not active or in other words if I run main. pi and I press s and hold it down we are only getting shoot bullet every 1.5 seconds I believe whatever we specified inside of the timer and well with that we have a really powerful timer that we can now use to add a whole bunch of things to our game right below the Sprites I want to create a class called bullet which for the parent is going to have a Sprite after that we will need Thunder a knit with self a surface a position a direction and the groups after that we have to call super. Thunder init in which we are calling this thunder init method for which we will need a position a surface and the groups besides that I want to have some extra stuff for the movement self. Direction needs to be an attribute and then we have self do speed which I have set to 850 besides that we will need an update method with self and Delta time and then call self. rect dox plus equals self. Direction multiplied with self. speed multiplied with Delta time so with that we have a very basic bullet that we now want to create whenever the player presses the S button and the timer isn't active also the bullet we want to have inside of another Sprite group self. bullet unor Sprites pame dos sprite. group this is the part we have seen plenty of times by now to create a bullet below create B I want to have create underscore bullet for the parameters we will need a position and a direction both of those we are going to get from the player although for now I simply want to create a bullet where we already have a surface self. bullet surface we imported this inside of load assets not too long ago for the position and the direction we are simply going to use the parameters finally for the groups I want to have a tupal with self do all Sprites and self. bullet Sprites this create bullet we now have to add to the player I want to have self. create bullet inside of the player for that to work back inside of the Sprites the player is going to need one more parameter create uncore bullet I suppose we can store that one as an attribute right at the top create underscore bullet it's going to be create bullet and this create bullet we want to call instead of the print statement create bullet and then we are going to need a position and a direction for the position at the moment I simply want to get self. rec. Center and for the direction this one should be 1 if self do flip and if it is not the case else it should be one or in other words if the player is facing to the left then we are returning 1 and if not not then we are facing to the right so the Bullet should have a direction of one let's try all of this and if I press s we are getting a bullet not too many because the timer cool down is really large but at least we're getting something I suppose for that we can change the cool down to 500 milliseconds that way all of this is going to feel quite a bit better next up the main issue we have at the moment is that the bullet is always facing to the right because we are not making any updates to the surface for that I want to have an adjustment section where we are updating self. image all we need in here is py game. transform. flip with self. image and then for flip X the only thing that we really care about we want to get direction and check if this value is equal to1 or in other words this is only going to be true if the bullet is going to the left or flip y we want to have fults if I now run main. pi and I look to the right we get a bullet facing to the right and if I face left the bullet is also facing left although if you look at the player the starting position of the bullet just isn't ideal or in other words the way you have the issue happens because if this is our player the starting position is always the center and the point we are placing for the bullet is the top left we would always get something like this which really is not ideal to fix that I want to work inside of create bullet and create a custom x value I always want to get the original player Center position or position zero to that I want to add the direction and multiply it with a value that I think is large enough after some testing I landed on 34 but this we only want to do if direction is equal to one or in other words we are going to the right if that is not the case else we still want to do all of this but then we also want to account for the top left position in other words sell dot bullet surface and then get whiffed after we have that instead of the position I want to have a tupal with X and position one just to test all of this inside of Sprites I want to set the bullet speed to zero if I now run main. pi and I look to the right I can create a bullet it's right in front of the player and on the left side we are also right in front of the player player that means we can set the bullet speed back to 850 and we get bullets that look significantly better cool now to understand this line we have a player with a center position that is what we're getting from the position parameter if the player is facing to the right then we want to do all of this meaning we are going from this point a bit further to the right by 34 pixels and then we are placing the top left of the bullet I think that part is fairly straightforward however if we are moving to the left then we are doing all of this we still start from the center of the player and then we are going to the left by 34 pixels that covers this bit but then you have to remember that we are placing the top left of the bullet meaning the bullet would be roughly here which obviously is wrong what we want to place is the right side of the bullet in other words we want to move the entire thing by its own width and this we're doing with this last line and that is basically it with that we have the bullets that covers all we need for this class besides that I also want to have a fire class which is also going to inherit from the Sprite class now for this one we first of all want to have a thunder init method with self a surface a position groups and we also need the player basically for this one every time the player fires a bullet we also want to have a fire animation or well fire animation might overstate things just a bit if you look at images scun there we have a fire image this we want to show for a very short amount of time if the player fires a bullet and then via a timer destroy it right after and for that we're going to need the player so this fire animation moves with the player it would look really weird if it didn't do that for that we will need a super Dunder init method with the surface the position and the groups that way we are getting all of this on top of that I want to store self. player as an attribute and also I want to know when we are creating all of this if the player is flipped or not which means self. flip will be player. flip on top of that I want to create self. timer which is going to be a timer that has a duration of 100 and it's also going to auto start and once this thing times out we want to call a function which is going to be self. kill we want to call the inbuilt kill method of the Sprite which we can totally do let's try all of this inside of main.py besides creating a bullet I also want to create a fire instance for the surface I want to have a fire surface for the position for now let's stick with the position of the player groups is simply going to be self. all Sprites and the player will be self. player if I now run all of this we are getting an error that Tuple object has no attribute get F rectangle and I think that usually means we are adding some wrong arguments somewhere you probably saw it already the order of the arguments are wrong we first of all need a position then we need a surface and then we need the groups if we now run out of this we are getting a fire Sprite that is pointing mostly in the wrong direction and the position is also not great but at least we have something oh and on top of that it also doesn't disappear that happens because the timer is not being updated which means we need an update method with self and Delta time although Delta time we don't care about and then self. timer. update if I now run all of this I can shoot a bullet and we get a very short fire animation that's a good start but we also have to update the position for that since we have to player available we can do all of that fairly easily if self. player. flip then I want to set self. re. midr to self. player. re. mid left on top of that since we are now facing to the left we want to flip the entire fire image or in other words self. image is going to be py game. transform. flip with self. image true and false if that is not the case else then we simply want to set self. do midle to self. player. re. Mid right that is a good start but on top of that I want to copy all of this and then inside of the update method do all of this except updating the image that way this fire animation goes along with the player which is quite important if I now fire all of this you can see that we have a basic fire animation although the position is a bit off this thing has to move down just a little bit that is quite easily done inside of Thunder init I want to have self. let's call it y off set which is going to be a pame do Vector 2 with zero and let's say eight pixels after we have that whenever we are updating the position of the rectangle we always want to add the Y offset that way if I shoot the bullet we get the proper nozzle fire animation and that is looking pretty good and I think now I can also demonstrate why you need this part if I comment it out and run main dop again and shoot a bullet sometimes you can see if the player is moving the fire animation doesn't move along with the player which is kind of a weird effect meaning we really want to include this part nearly done there's just one more part I do want to work on let me move away from the bees and if I shoot a bullet and turn right away we getting a slightly weird effect when we are creating the fire animation and the player is facing to the right and if we are then turning around the entire thing falls apart to avoid that if the player turns around while we have a fire animation we want to Simply destroy the entire thing or in other words if self. flip is different from self. player do flip if that is the case self. kill that way if I run main. Pi I can move a bit further to the right and as soon as as I shoot and turn around the fire disappears and with that we have the fire animation that covers another really important part with that covered we just have to figure out the enemy logic and the bullet collisions to finish up the game I want to work on the enemy Logic for the B we want to have a Sprite that is slowly moving to the left we have some vertical movement as as well and for the worm we are going to move this thing in a predefined area on top of that we will also add the collisions between the bullets and the enemies and the enemies and the player finally we can add some audio files and then we have the entire project done shouldn't be too difficult for all of this back inside of the code I want to work inside of the Sprites and looking at all of this we don't need the timer. piy groups. piy or support. Pi file anymore instead we want to look at the worm and the bee those two classes are identical at this point on top of that they are going to share a bit more code in just a bit to account for all of that I want to create another class called enemy which is going to have an animated Sprite as the parent for this we going to need a thunder init method with self braams position and groups in there we are going to need Super and thunder in knit which means we are calling animated Sprite thunder in it and then pass through all of the arguments which means for the B the parent class should be the enemy class and the same for the worm that already means inside of the enemy class we can call update with self and Delta time and then self. animate also with Delta time because of that we don't need this update method anymore and we are already simplifying the code inside of m.p the animations should still work and they do cool for both of these classes I want to create a move method which is also going to need Delta time and for now we're going to add pass in there for both of them this move method we are going to call inside of the parent class cell do move now we have to figure out the actual movement for the B this is fairly simple we want to have self. rect dox minus some amount for that value I want to create self. speed which is going to be random and this we want to multiply with Delta time for that to work we will need self. speed which is going to be set by a parameter speed with that back inside of main. Pi when we are creating a b we will need one more argument also to organize all of this just a bit better I want to use named arguments we have frames we have a position and then we have the groups besides that we will need speed which is going to be a random integer between 300 and 500 if I now run all of this we have pce that are moving to the right so this is already working quite well perfect although now the starting position doesn't really work anymore what I want to have if this is the entire level the bees should be spawning on the right of it for that first of all when we are setting up the level we need to know how wide this TMX map is we need TMX map and then do whift if I now run all of this we are getting the number 45 to understand this value you want to go to the tile map and then map and map properties that is going to give you this dialogue on the left and all the way at the top you can see the width which is 45 in my case or in other words our map has 45 columns that's literally all that this means which we can use I want to define a self. levore for whift which is going to be TMX map. wift multiply it with the tile size once we have that back inside of create B for X we want to have self. LEL wift plus some kind of offset let's go with the window whift just to be sure and since the player cannot see this value anymore we don't need Randomness meaning Rand in and disappear that is looking pretty good if I now run all of this and I move all the way to the right at some point there should be some bees coming our way and that is working pretty well next up we also want to cover the entire height of the map meaning we have to do basically the same thing we have done before besides a level Whi I want to have self. levore height which is going to be TMX map. height multiplied with the tile size after that for this value we do need Randomness we want to have a value between zero so all the way at the top and self. level height once we have that I can run the game and at some point we could be seeing bees covering the entire height and that is working pretty well although for the movement of the bees I want to add a bit more randomness and for that I want from math import sin this is giving us a signed function and what that is doing if you put this on a graph we need some kind of x value and along this value the sign function is going to look something like this we basically get a wave that fluctuates between 1 and 1 and in our case the x value is going to be the time and just to demonstrate what we are going to do inside of the player I want to in the update method print the sign function with pame do time.get ticks if I now run all of this you can see that we getting a whole bunch of output and this output is always between nearly one and then nearly 1 and it goes between those two values really really quickly that is all that we are doing in here now in the player we don't need it but inside of each instance of the B we want to use all of that to influence self. doy to that value we want to add the sign value of py game. time.get six don't forget to call it and this value will now be between 0 and 1 which is not going to do very much for the vertical position but we can multiply it with some sort of amplitude and also don't forget whenever we have Movement we have to multiply things with Delta time now amplitude doesn't exist at the moment although we can create it self. amplitude is going to be a random integer that we have to import from random import Rand in I want to have a random value between 500 and 600 with that if I run all of this again and we have to wait for the Beast for just a second we should be getting something and well this is kind of working but it's not ideal yet that is because the frequency is way too high to fix that I want to have self. frequeny which is also going to be a random integer in my case between 300 and 600 and this value we want to use to divide get. tick or in other words divide by self do frequency with that we should be getting a proper outcome if I now Run the game and we could be seeing bees moving in a much more organic way this is much nicer perfect that covers the movement of the be next up I also want to have a constraint because once again we keep on creating bees and we have to make sure that we are getting rid of them at some point as well now in this case this is fairly simple we simply want to check if self. re. right is smaller or equal to zero if that is the case we want to kill the Sprite and also this constraint method we want to call inside of the parent class self. constraint to make sure that the game doesn't crash we also have to add the same method to the worm class meaning in here con straint without without any custom parameters and this one is going to get pass for now with that we have to be enemy next up we have to work on the worm inside of til we have an object layer called entities this one contains the player that's the part we have already seen besides that we have a whole bunch of rectangular areas and the way those are going to work I want to spawn a worm roughly here and then make it move to the right if the worm goes too far to the right let's say we are ending up here then the direction of this enemy should be reversed the same thing we want to do on the left side and I think you know where this is going this is going to be your exercise I want you guys to create the worm movement logic pause the video now and see how far you get first of all we have to import all of the areas that is going to happen inside of setup after we are creating the player now we already are creating one instance of the worm that we want to keep however first of all we want to check if obj do name is equal to worm and just to make sure if you go back to tiled and you click on one of these areas you can see name worm if that is the case we want to create one instance of the worm and then add a couple of arguments the frames can stay as they are and at least for now we can also keep the groups but we have to update the position this one simply doesn't work anymore and what I want to do instead is create a pame f rectangle with the size of the rectangle inside of til that we can get via obj dox obj do y obj do width and obj do height with that we have a rectangle that defines the area that the worm can move in although to use that inside of the worm we need to update the parameters instead of a position we now have a rectangle to turn that into a position at least for the super under init method we want to get wreck. top left and that should already do something if I now Run the game we're getting multiple worms and they are in the area position at least roughly now obviously the worm should always be on the ground for that I want to update self. w. bottom left and set it to rect dot bottom left that way the worms are always going to be on the floor which is already feeling a lot better I also want to keep the rectangle let's call it maincore rectangle this is just going to be the rectangle from the parameter after than that we want to have self. speed which can be a random integer between 160 and 200 also we will need self. direction which can be one by default afterwards for the move method I want to get self. rect dox plus equal self. direction multiplied with self do speed multiplied with Delta time with that since we are already calling the move method all of the worms are moving to the right which is a good start but not ideal yet because they are supposed to turn around for that we will need the constraint method and the basic logic just to reiterate if this is the area the worm is starting in the bottom left and also moves to the right if we are then outside of this area we want to go the other way now for that you could check if the right side of the worm is greater than the right side of the area and do the same thing for the left side although that would be a bit of an Overkill because what we can do instead is to check if not self do main rectangle do contains with self. rectangle this way we are checking if the rectangle is not entirely contained by the main rectangle anymore which can only happen if we are too far to the left or too far to the right if that is the case self. Direction multiply equal minus one with that we should be getting the proper constraint this is looking really good just one more change that we have to make whenever we are doing this we also want to invert all of the frames so that it looks like the worm is moving in the right direction all we have to do for that is overwrite self. frames which we can do via py game. transform. flip and in there we want to get a Surface and then true and false this we're doing for every surface in self. frames once we have that we're getting the proper animation and that is looking pretty good now once again this could be optimized just a little bit more because now inside of the game every time the worm is hitting a specific point we are transforming two surfaces what you could do instead inside of load aets load the worm frames and then invert them right inside of this method afterwards you can simply load the right frames depending on what you have inside of the worm that would also work but for this game it's not too much of an issue and I think at this point if you want to implement it you can do it on your own anyway with that we have both of the enemies which means now we can work on the Collision methods Define collision and those are going to be the collision between the bullet and the enemies and the enemies and the player first of all I want to have the collision between the bullets and the enemies for bullet in self. bullet Sprites and then get all of the Sprite collisions which we're getting via pame dos sprite. Sprite cite in there we want to get one bullet and then self. enmore Sprites this one doesn't exist yet we will change that in just a second finally we will need to kill which should be false now before we can continue we want to work inside of the dunder init method and then create the enemy sprite's group this we want to use both for the worm and for the bees meaning those should be in self. all Sprites and self. enemy Sprites the be we are creating inside of the create B method and in there for the groups I want to have all Sprites and self. enemy Sprites with that this line should be working and I suppose while we are here we can also add py game. sprite. polite mask right away next up we want to check if Sprite Collision then we want to get the bullet and kill it and for Sprite in Sprite Collision we want to call sprite. destroy once again this method does not exist but that we can change because inside of the enemy class we can have Define destroy which for now is simply going to call self. kill all we have to do now is after we recording all Sprites update self. Collision let's try all of this now and if I shoot at one of the worms they disappear this should also work a second time perfect and once I hit a b there we go this is also working although this I want to refine a bit by using a mask inside of the enemy or in other words first of all I want to create self. Deathcore timer which is going to be a timer with a duration of 200 milliseconds and the function self. kill as soon as we are calling the destroy method we are starting this timer self. death timer. activate besides that I also want to set self. animation speed to zero and then self. image should be pame do mask. from surface with self. image and that we want to turn to a surface straight away also self. image and set color key with a black color that way once the Sprite is being destroyed we don't have an animation anymore and the entire image is going to be a white silhouette on top of that I want to stop the movement of the enemy which we can do inside of the update method I only want to call move and animate if not self. death timer as soon as a death timer is running we don't want to call move or animate anymore you could also put a constraint in there it doesn't really matter once we have that if I now shoot at a worm we're getting a white silhouette for a short time and this doesn't change that happens because self. death timer. update was not called let's try this again and I can shoot at the worm and it disappears perfect this happens a second time as well very good and now I have to hit a b let's hope I get one there we go this is also working which means with that we have the proper enemy logic that was basically it and I hope from the logic here you can see how inheritance can be incredibly powerful inside of the B and the worm class we are not actually doing very much we are simply initializing a couple of basic values then we have a very simple move method and then a fairly simple constraint method that's pretty much it a lot more of the logic happens inside of the parent enemy class the animations are covered inside of animated Sprite and the very basic setup happens inside of the Sprite class that way the entire thing is much more manageable and for a larger project we would be writing a lot less code the last thing that we really have to work on is the collision between the enemies and the player all we need for this part is if pygame dos sprite. Sprite collide with self. player self. enemy Sprites and the DU kill argument doesn't really matter let's go with folds and then we want to have pygame DOS sprite. Collide underscore mask if that returns anything then we want to set self. running to bals let's try that part and now as soon as I get hit by a worm the game should be over and it is perfect that means the last thing that we have to implement is the audio that means inside of Thunder init after we are loading all of the assets we are running the setup I guess in there we can start the music all the way at the bottom I want to get self. audio and then get music remember for this part the name of each of the files is the file name without the file end this file we want to play with loops being1 let's try cool that part is working and just why we're testing the other audio files I want to comment out this part so next up we have to work on the shooting mechanic that means whenever we are creating a bullet we also want to self. audio shoot and play and now every time I'm shooting a bullet we are getting another sound whenever we are hitting an enemy that happens inside of collision we want to play self. audio this one is called impact and then play it with that we are getting a sound every time we're hitting an enemy me and with that we are done this is the entire game the last thing I suppose that we have to do is uncomment the background music this covers another pretty fancy game so I hope this was useful and at this point you should have a really good understanding of P game which means there's just one more game to go and for that we're going to work a lot more with user interfaces there is just one more game that is left to make and that is the Pokmon inspired one the major Focus here is going to be on the UI system essentially we are going to create a menu and the player can select different options generally Pokemon games aren't terribly sophisticated you essentially have a database and you access all of that via a UI system although the details can become a bit more advanced now if you want to make a really fancy RPG in this kind of style check out my dedicated video for all of that I am also Al using py Game meaning if you could follow along so far you will feel right at home anyway for now we want to set up the basic Sprites so that we have the player monster and the opponent let's Jump Right In we already have a couple of things ready most importantly inside of main.py we have a game class with all of the basic setup and then we have a game Loop if you run all of this you getting a basic window doesn't do anything at the moment but that we can work on later besides that we have support. Pi in there we have a folder importer and it stores the data as a dictionary which means the file name is going to become the key and the associated value will become a surface besides that we have an audio importer function which is going to work in a very similar way we have an audio dictionary and in there we are creating key value pairs with the file name becoming the key and to mix a sound file becoming the value besides that we have a timer that we have already seen in the last game and then we have settings in which we have pame the join and the walk method then we are defining a window width and the window height and then we have four dictionaries colors is a very simple one in there we are simply defining a couple of colors then we have monster data and this one gets a bit more complex we always start with a key and this is the name of a monster the associated value is then going to be another dictionary with the monster element and the amount of health and that is all we have for the monsters there are no levels or attack points we simply have the element and the health besides that we have the abilities this is going to be another dictionary where we have the name of the attack and then a damage an element along with an animation finally we have the element data which is going to tell us how well an element works against another element for example if we have fire and we attack a plant then we are doing twice as much damage for now this data isn't too important but later on we are going to rely quite heavily on it anyway before we continue here is the project folder and so far we only looked at the code files besides that we have a couple of audio files and then inside of images we do have quite a bit more for now the most important files are inside of back there we have the back sides of the mon monsters and then we have the front of the monsters as well there are a few more things for example inside of simple we have each monster in a much smaller graphic then we have the other folder in there we have the background and the floor for each monster this folder is fairly simple but then we have attacks and inside of attacks we have something that we haven't seen yet where we have multiple graphics on a single PNG file later on we will have to break up those into individual parts Parts but once again this isn't something we have to worry about at the moment below the groups I want to create a data section where first of all we are defining all of the player monsters and this is going to be a list of names for example in there I want to have the individual strings of the monsters let's go with three examples for now we want to have spu C and jaana and by the way to get all of the monster names you want to look at Monster data and in there you can find all of them for now I want to have some static data so it's a bit easier to go along but later on this will be randomized once we have that I want to create self. player monsters for which we want to create another list and in there we have a monster class that doesn't exist at the moment we will work on that in just a second first of all though for name in player monster list for each monster we want to have a name and a surface the name we are getting from the list comprehension the surface we have to import for that I want to create another method define import uncore assets without any custom parameters and for now I want to have all of of the back uncore surfaces for which I can use support. Pi I simply want to folder import and then go to a specific folder which in my case is going to be images and then back in there we have a whole bunch of images that we want to import and then store inside of a dictionary images and back and also I want to print self. back surfaces after we have that inside of the dunder init method self. import assets if I now run all of this we getting name error Monster not defined because this class doesn't exist that is totally fine first of all though what is much more important if you scroll up we have a dictionary with the monster name and the monster graphic so next up for the surface inside of the monster class we want to get self. back surfaces and then pick one of the surfaces via the monster name and for that it's really important that the monster names you define inside of the player monster list aligns with the file names that you are importing in back surfaces if that doesn't work you are going to get an error anyway once we have that inside of the code folder I want to create a new python file monster. piy in which we want from settings import everything and 10 class monster with pame do sprite. Sprite then we will need a thunder in it method with self a name and a surface at this point you might be wondering don't we also need the groups and well this is what we have done so far but for this particular game I don't want to do it which means inside of the Stander init method I simply want to call Super Thunder init without any arguments which is totally fine to do the reason for that is when I am creating all of the monsters I only want one of the monsters to be visible and only that one individual monster that is visible should be inside of all Sprites we'll cover that later first of all though we will need self. image and self. rectangle the image is really simple we simply get this surface for the rectangle I want to have self. image and get F rectangle in which we are placing the bottom left for the position I want to have 100 and the window he if this is the main window we want the player monster to be here in other words we want to place the bottom left in the bottom of the window with a bit of padding to the left finally I want to store the name as an attribute which means selfo name is name once we have that inside of main.py I want from Monster import monster once we have that inside of the game we still cannot see anything but at the very least the game doesn't crash anymore after we have to play a monsters I want to get a single Monster and stored in an attribute self. monster is going to be self. player monsters with index zero and this one monster I want to add to all Sprites which I'm doing via self. all Sprites and add self monster with that we can see one of the monsters in the bottom left and to make all of this look a bit better I want to import all of the background surfaces inside of import assets self. BG surfaces is going to be the Importer we want to go to images and in there we have other if you look at images there we have other which contains bg.png and floor.png once we have that before we are drawing anything else I want to get self. BG surfaces and then BG this we want to blit on the display surface self. display surface. blit with the surface and the position is going to be a tuple with Zer and zero I can now run all of this and this is already looking a lot better next up then inside of the monsters I want to create another class called opponent which is also going to be a pygame Dos sprite. Sprite for which we will need a thunder in it method with self name surface and this one is going to get groups since we are only ever going to create a single opponent we can add those to the groups which means super thunder in knit with the groups then we will need self dot image which is going to be the surface and self. rectangle which is going to be self. image and get F rectangle in which I want to place the mid bottom at the position window WID minus 250 and 300 I hope at this point you get some intuition where these points are but just to go over it really quickly we are placing the mid bottom at position window wh minus 250 going from the right 250 pixels from the top we are going 300 pixels so we'll be on this point which is going to define the bottom of the monsters so so we're getting something like this to see all of that inside of main.py I want to import monster and opponent afterwards inside of the data section I want to create self do opponent via the opponent class and for that I will need a monster uncore name I will need a surface and self. all Sprites getting the once the name and the surface is going to be your exercise or in other words I want you guys to import the front surfaces and then use them to create one opponent this opponent by the way should be random try to figure this one out first of all inside of import assets we will need the front surfaces which we're getting via folder importer there we want to go to images and then and just to test things I want to have an opponent uncore name which for now let's go with atro then this opponent I want to use for the name and for the surface I want self. front surfaces and then pick one entry via the opponent name I can now run all of this and we are getting the opponent this is working for another example let's go with synl should also work just fine and it does this is looking good which means we just have to get a random name for which we will need from random import Choice and then use the choice method for which we are going to need a list which in our case is the monster data and we want to get the keys I can now run all of this again and we are always going to get a random opponent next up inside of the monster I want to add some data to get started I want to get the element of the monster and stored as self. element this we get via monster data the monster name and then the element or in other words we are going to monster data pick this dictionary and then get the element also while we are here I want to create self. health and self. maxcore health which we are also getting from the same dictionary which means I want to have monster data name and not the element but health and by default when we are creating the monster health and Max Health should be the same which means we can do something like this where self. health is the same as Max health is the same as Monster data name and health by that system we can easily create two identical values nearly done the last thing I want to get is self. abilities for which I basically want to get four random values from the abilities data that we can do via another subm module of random the one we want to import is called sample what this one is going to do if you call it you have to add some kind of list which in my case once again is going to be the abilities data and I want to get the keys and then I have to specify a second argument which just the number of values that I want to get in my case four that way we are getting four random values from this dictionary and just to make sure all of this is working I want to print self. name self. element self. abilities and finally self. Health if I now run main.py we getting a monster name the monster element the monster abilities and the Monster Health now all of this we also want to do for the opponent ideally we want to create another class called creature which would give us all of this stuff the issue is when we are creating the rectangle we are placing different points the bottom left for the player and the mid bottom for the opponent getting both of those into one parent class would be kind of a hassle to get around that I am going to create a class without thunder in it I simply want to have a method get uncore data in which we have to enter as an argument self and in name once we have that I want to get all of this and paste it in there that way we are setting self. element self. health and self. abilities simply by having the name that means we don't need all of this inside of the monster anymore we only want to call self. getor data with the name and to get access to this method I want to use multiple inheritance the Sprite should inherit from py game. sprite. Sprite and the creature since the creature doesn't have a Dunder ined method we can keep the super Dunder in it method the end result is going to be the very same we are still getting all of our monsters on top of that what we can also do for the opponent is ADD creature and then call self. getet data for which we will need the name also for the opponent we will need self. name which we are also doing inside of the monster so this we can put in there as well that way all of this looks a lot more organized if I now run main.py we are getting one additional output this monster is called pouch and the data for him we're getting down here once again we're getting a monster name a monster type a list with the attacks and the health amount that is a really good start next up I can get rid of the print statement and we have created a basic setup for the game I suppose there's one more thing that I would like to do to make the monster stand out a bit more there should be a floor below them which we can get via floor.png this I want to display below all of the monsters now for that you could create a custom Sprite group but since we don't really want to do anything in there I think it's a bit Overkill what is a bit more straightforward is another method draw monster floor no need for custom parameters all that we want to do in here is for sprite in self. all Sprites and then create a floor uncore rectangle which we are getting via self. BG surfaces with the floor image on this thing we want to call get F rectangle and then place this Center to sprite. rec. Mid bottom and for some offset I want to add py game. Vector 2 with Zer and 10 once we have that self. display surface. blit with self BG surfaces and the floor along with the floor rectangle this we now have to call before we are drawing all Sprites but after the background self. draw monster floor and now we can see a floor below the opponent and below our own monster which I think looks much better anyway with that we have the very basic setup next up we can work on the UI now that we have the basic setup we can work on the UI for now we are only going to cover the general menu and the attack menu which work basically in the same way and for all of that the theory is actually really simple a menu is just some text surfaces placed together for example if you want to create a menu like this all you really need is some kind of background this could be a surface and then a few text options that's basically it usually you create those via some kind of for Loop that way you can access all of the options via the index this would be zero one and two that is basically all that we are going to do for all of that back inside of the code I want to create a new file UI DOI once again we will need from setting settings and import everything then I want to have a class called UI in there we will need a thunder in it method with for now self and a monster this thing is first of all going to need the display uncore surface via py game. display and get surface and we are also going to need a font for which we are going to use the inbuilt one py game. font. font with none and 30 besides that I want to set a left side and a top side of the menu for which I'm going to get the window Wii divided by two and then subtract 100 pixels for the top side I am going to get the window height divid it by two and add 50 pixels we basically want the top left of the menu to be roughly in the center of the window with just a bit of an offset once we have that I want to create a draw method and all we really want to do in here is for example draw the general menu which is just going to be another method General at the moment I simply want to add print and General in there because to test all of this inside of main.py we will need from UI import UI after that in the game Stander ined method we want to have a UI section with self. UI and UI this one wants to have one argument which is going to be a monster that we have been storing inside of self. monster with that we can go back to the UI class although there's one thing I forgot we want to store self. monster as an attribute self. monster is Monster after we have that inside of the game class in the run me fit under draw after we are drawing all of the Sprites self. ui. draw I can now run all of this and we getting a general output that is looking really good that means inside of this General method we can start working on a basic menu first of all I want to define a rectangle that defines the size of the entire thing which is simply going to be a pame f rectangle with a left a top a width and a height the width is going to be 400 pixels and the height will be 200 for the left side I want to have self do left and add 40 pixels for the top side self do top plus 60 pixels and just to make sure we can see what's going on py game. draw. rectangle on self. display surface for the color I want to go to colors and then get the white color in other words inside of settings there we have the colors and I want to pick the white one next up we need the rectangle to draw the one we have just created the Border width will be zero and the corner radius will be four then I want to duplicate all of this and choose the color gray we are still going to draw the rectangle but now I want to have a border width of four that way we are getting a gray rectangle around this area or in other words inside of main. Pi we are getting an area for the menu that is looking pretty good with that we have the background next up we want to have the actual menu part of this menu for which we will need the amount of columns and the amount of rows which in my case are both going to be two after we have that I want for call in columns and for Row in rows that way I am getting either zero and one for the columns and zero and one for the rows and the general way that you want to think about it if this is the menu we have just created this bit here we want to separate this thing into two columns and two rows inside of each cell we then want to display some text and for that we using this for Loop Loop effectively we want to get a center position for each of those or in other words inside of the inner for loop I want to get an X position and a y position the X position is simply going to be rect do left plus rect do wift divided by 4 plus re do WID / 2 multipied with column a bit more logic but I hope it's not too complicated let's go through it step by step we first of all starting on the left side of the rectangle this line here then we're adding rec. width divided by four that way we getting from the left side to the first horizontal Center this side here finally rec. width divided by two multiplied with the column and remember the column we're getting from the four Loop this one could either be zero or one if it is zero then this entire value will become zero so we are staying on this line if it is one however then this value will become one and we are adding half the width of the rectangle which would bring us to this horizontal Center and with that we have two Center points that is basically all we need a very similar logic we want to apply for the vertical points we want to go rect do top last plus rect do height / 4 plus rect do height / 2 multiply it with the row once we have that we can create a text surface and a text rectangle the text surface is going to be self. font. render and for now the text is simply going to be option antas should be true and for the color I want to go with black these values by the way we are going to change in just a second so whatever you put in there isn't too important at the moment for the rectangle I want to get the text surface and then get F rectangle in which we want to place the center and Position will be X and Y finally self. display surface. blit with the text surface and the text rectangle with that we are nearly done the last thing that I have forgotten is that the columns and the rows need to be inside of a range function that way we can use them for a four Loop if I now try all of this we getting four options that cover the entire size of the background that is looking pretty good next up I want to customize what I am displaying I don't always want to display option for that inside of thunder in knit I want to have let's call this a control section in which we are setting the general options which is going to be a list with a attch then we have heal next up we have switch and finally we have Escape those are the four options that we want to display which means inside of the text surface I don't want options for the string I want to get self and general options and then pick one index for that we will need this index I suppose for now to test if this is working let me add a zero in there if I now run main I we're getting the first value so this is working which means we just need to customize this for that once again we have the entire menu with two columns and two rows in there for the indexes I want to have 0 1 2 and three the formula to get these values is column + 2 * Row for example if column is zero and row is zero then the overall output is going to be zero as well which would bring us in this top left part however if column is zero and row is one then the overall result will be two which will bring us down here and that's basically all you need if I now run main. pi we getting the four General options that's basically all you need although there's one thing that's missing and that is input for that I want to have another method Define input I want to get all of the keys in there and then pame do key and get just pressed the adjust part here is really important we only ever want to get a single button press we do not want to check for button being pressed down Contin L now we have to figure out how to connect the input to the general menu and for that inside of thunder in it I want to create one more attribute self dogen index which is going to be a dictionary in which we have the column which by default has a value of zero and a row with the same default value once we have that inside of input I want to get self do General index and update the Row first of all I essentially want to increase this value by the integer of keys and high game. Kore down and from that I want to subtract basically the same value except this is going to be Kore up and this should look somewhat familiar it's basically a top down movement system I also want to duplicate all of this because besides the rows we want to update the column in which we are getting K right minus Kore left that covers the very basic input we just have to call the method which I want to do inside of an update method self do input and then inside of main.py self. ui. update I can now run this and nothing is going to happen that is because we are not doing anything in terms of output to fix that I want to print self. General index if I now run all of this we're getting column 0o and row zero if I press to the right we're getting column 1 column 2 column 3 and so on and if I go to the left then we're getting negative numbers the same also works for the row this is a pretty good start next up we have to figure out how to use the general index inside of the method to highlight one bit of text for that highlight I want to set a custom color If an item is selected I want to get colors and then get the gray color and to figure out if we are selected I want to check if the column the one that we're getting from the for Loop is equal to self dogen index index and the column on top of that I also want to check if the row is equal to self. General index and the row if both of these conditions are met then we know the current item is selected if that is not the case else we simply want to get colors and black once we have that instead of always drawing a black color we want to get the color we have just defined which means now inside of main Pi I can select one of these four options that is a really good start however if I go further and further to the right at some point the menu doesn't work anymore if you try this on your own it's going to be a bit more visible but basically if you go too far to the right you are selecting index 5 or 10 which we don't have anymore our menu only goes to two and two so we want to limit those values inside of the input for that I want to remove the plus equal and then get the starting value and to that I want to add what we have already added so so far we are doing the same thing but all of this I now want to put into a tball and then I can use the modulus operator and limit all of this to two rows the same thing I want to do for the columns so I can simply copy all of this then put the entire thing into a dupal and finally modulus 2 that way inside of main. Pi if I only press down we are still always getting the right value this also works with left and right and now we are always staying inside of the menu next up I want to check if keys and py game. Kore space if that the case I want to print the currently selected item which I can get via self. General options and then indexing and the formula we have already seen to get the value we want to have the column plus 2 * the row which in this case means self dogen index and the column plus self. general index and row multiplied by two if I press space we're getting attack this also works for heal escape and switch so with that we have a very basic menu so next up if the player is selecting a tack then we want to display a different menu the one for the attacks to get that system rolling I want to add one more attribute self. state which by default is going to be gen and inside of the draw method I only want to call the General method if self. state is general which we can check via a match case statement match self. State and we want to check the case General if we have that we want to call Self dogen finally instead of printing the output from the value I want to update self. State and it should be the return value that we are getting meaning if we click on attack then the state should also be attack with that inside of main.py if I click on a tack the menu disappears simply because we are not doing anything anymore inside of the draw method after that we have to implement the attack menu which is going to be your exercise I want you guys to modify UI General to also display abilities on top of that you can make this method a bit more flexible to account for any number of rows and columns at the moment we're setting rows and columns as a local variable but inside of the for Loop we always assume that we have two rows and two columns which isn't particularly elegant so try to make this more flexible pause the video now and see how far you get first of all I want to rename General to quad SEL since we are going to use this method for attacks in general we should have a name that reflects all of that that also means inside of draw self. quad select next up we have to make this thing a bit more flexible so that we can display any kind of list at the moment we are displaying the general options besides that from the monster we also want to be able to display the ability which I think we're inside of creature the abilities is a list with four values and this we also want to be able to display which we can actually do fairly easily because we have the monster available or in other words instead of General options we could get self. monster do abilities and since that is a list as well inside of main. Pi we're getting the four attacks of this monster to get those values dynamically inside of the parameter I want to specify an index and I want to specify the options then for the color I don't want to have the general index I simply want to get the index same thing for the row and with that we are using the index besides that for the text surface I don't want to have the abilities I want to have the options oh and also this shouldn't be self. Index this should just be the index we we are using the parameter value with that next up if the case is General I want to have quad select the index is going to be self dogen index while the options are going to be self dogen options let's try all of this and it's still working good sign after that if the case is the string attack then self. what select with self dot let's call this one the attack which does not exist at the moment after that self. monster. abilities just one more thing that we need inside of the control section I want to have a self. attack index after that inside of main. Pi I can click on attack and we are are getting the different attack options although at the moment we cannot do any kind of input that is because inside of the input method we are only updating the general index that we only want to do if self. state is equal to General if that is not the case or in other words if self. state is equal to to a tag then we want to do all of this so for now we can duplicate it all and update self. tack index for both the row and the column the values for that is going to be basically the same thing we have done before and for now I simply want to print what we are getting instead of General options I want to have self. monster. abilities and then self. attack index for the row and the column all of this we want to print and then I can still select the different options on attack I can click on one attack and we're getting the output that covers the basic exercise next up I want to clean all of this up and make it a bit more flexible we are specifying that we have two rows and two columns but when we getting X and Y we always assume that we have two values or in other words these numbers shouldn't be static they should be dynamic depending on what we are specifying in the rows and the columns also when we getting the input we getting modulus 2 which should also be relative to what we are specifying in the rows and columns for that in the control section I want to set self. rows and self do columns which are still going to be two and two that way we don't need those rows and columns anymore and instead I'm going to use self. columns and self. rows this isn't going to change anything because we are still using the same values but with that system for example in the input when we are getting the row we don't want to have modulus 2 instead we want to have self. rows the same thing for the columns this should be self do columns the same thing we want to do for attack self. rows and self. columns the end result should still be the same that is looking fairly good perfect so next up we can account for a greater number of options and just to demonstrate what I'm talking about here if we had six options in total or in other words we had two two rows and three columns and then for the general options let's say I also want to have items and catch if I now run all of this we are getting something but we should be inside of the available area so how can we organize this better for that inside of UI I first of all want to update rec. wift divided by four this should be divided by self. columns multiplied by two that way we are getting the proper start position and then when we are adding the value we don't want to get wed with divided by two this should be wed with divided by self do columns with that inside of main. Pi we are getting everything inside of one menu the same thing we want to do for the vertical position self do rows multiplied by two and then Rec do height divided myself do rows that means when we are specifying the rows and the columns I can flip this one around to three and two we are still getting six values overall but now we have two columns and three rows that is looking really good although not actually what I want to do I don't want to have items or catch and we should only have two rows and two columns but now all of this is much more flexible if you want to have a larger menu this is how you would do it now you could also streamline the input method a bit but later on I want to add more stuff in here so I'm not going to do it also I think at this point this part has gotten quite long so let's finish it for now with the first part of the menu covered we can start with the second part in which we are going to switch between different monsters or rather we're going to get the menu to switch between different Monsters the actual functionality is going to come later and fundamentally the system for all of this is going to be similar compared to what we have already done in some ways it's even going to be easier because we only working in one dimension but there are some other parts that are going to be a bit more complex so let's Jump Right In and do all of this straight away I want to keep on working inside of ui. Pi and then add another case inside of draw the case is going to be so switch if it is the case I want to call self. switch which does not exist at the moment so Define switch no need for custom parameters on this one and once again first of all we want to create a rectangle for the entire area which is going to be py game. F rectangle for the left side I want self. left plus 40 the same thing we have seen inside of the Quad select rectangle in fact we can copy most of the arguments the left side and Wii should be the same although for the top I want to keep self. top but then subtract a 100 pixels from it for the height I want to have 400 pixels to test all of this I want to call pam. draw. rectangle like we have done before in Quad select in fact I can copy all of this and paste it in there since we are setting the state to what we're getting from General options and general options include switch this should already work which means inside of self. Pi I can click on switch and we are good to go this menu looks all right that means once again we have covered the background so next up we want to cover the menu part of this menu for which we have to create one more attribute self. visible monsters which I have set to four but this is going to be flexible basically for this menu we want to go through every single Monster that the player has which we're getting from main.py in there we have a list with the player Monsters the issue now is though that we don't have this available inside of UI which means we have to create one more parameter the player uncore monsters which we also want to store as an attribute self. player uncore monsters is going to be player monsters that means inside of main notp when we are creating the UI I also want to add self. player monsters after we have that I can add a four loop with four I in range of the length of self. layer monsters via that that I want to get an X position and a y position the X position is simply going to be re. Center X while the Y position is going to be re. top plus rect do height divided by self Dov visible monsters multiplied by two and to that we want to add rect do height divided by self. visible monsters multiplied with I this is the same formula that we have used inside of quad select this one or this one or in other words this is the entire menu and we want to create vertical cells like this for all of that we always want to get the center which will be the center of the rectangle that part is super easy and for why we want to start at the top of this rectangle then we get rec. height divided by self. visible monsters time to that would get us to this Original Point finally we want to add the vertical movement to get to the next Center like this like this and so on once we have that I want to get the name of the monster which we have via self. player monsters which as a reminder is simply going to be a list which means we can use indexing via I this would give us one moner moner from which we want to get the name or in other words we are getting one of those monsters and each monster has a name via that we can create a text surface with self. font. render with the name of the monster anti LS should be true and for the color I want to go with black next up I want to have a text rectangle which is going to be the text surface and get F rectangle in which for now I want to place this center with the position X and Y finally self. display surface. blit with the text surface and the text rectangle let's try if I now click on switch we're getting three monsters that's looking pretty good although we should have a few more monsters to test all of this let's say never monster could be dolphin then we have pouch and let's say Laria just to make sure of this is working this is looking good and inside of switch we can see four of the monsters but in the code we have six Monsters the reason why you can't see them is because the last two monsters are outside of the window or in other words if I from self. toop subtract something like 300 pixels and go to switch then you can see all all of the monster names although this part isn't ideal yet but we can work on it for now I'm going to keep this position but later on we will change it first of all though we only want to display elements that are inside of this rectangle which we can do with if rect do Collide point and text rectangle do Center only if that is the case do we want to display the text if I run all of this again we can only see some of the monsters that is looking pretty good next up I want to work on the input in there we will need another L if statement L if self. state is equal to switch if that is the case I want to update self. switch uncore index which does not exist at the moment that we can fix inside of the dunder init statement self. switch index is going to be zero and then self. switch index is going to be pretty much what we have seen up there with the rows for attacko General except now we want to have this switch index and this one is an integer so no indexing needed to that we want to add the integer of keys k down minus K up and limit all of this with modulus and self. visible monsters next up to select anything inside of switch we want to select a custom color which is going to be another local variable which should be colors and gray if I is equal to self. switch index if that is not the case else it should be colors and black and that color we want to use when we are rendering the text which means instead of black I want to have the color let's try this one and inside of switch I can select different options that's looking pretty good however that is not the system that I actually want if this is our menu at the moment we can display play four elements 1 2 3 and four if we go beyond that we are simply going back to one but that's incorrect because what you cannot see is that below we have two more monsters those are not visible because of this if statement if I temporarily comment it out and fix the indent and run main. Pi again inside of switch you can see that we are are entirely ignoring the last two monsters which obviously isn't ideal what I would rather want is that if we go with the index below four then I want to move up all of the elements for that I want to first of all reimplement the if statement and then before the for Loop add a vertical offset which by default is going to be zero and this V offset we are going to add add to the Y position at the moment this is not going to do anything however if I change this to let's say 150 pixels then we are drawing everything a bit further down and if I make this number negative then you can see that we can see a couple of other elements we cannot select them because of the modulus but that's something we can work on but now though the default value for the offset should be zero also inside of input something better would be the length of self. player monsters that is going to cover an important part next up I want to work more on V of set because this should only be zero if self. switch index is smaller than self. visible monsters if we are between zero and four and this value should not do anything however if that is not the case then we want to move up all of the items so we can see the monsters a bit further down we just have to figure out by how much we want to move up and my case this is going to be self. switch index minus self. visible monsters this number should be negative that way if switch index is five and visible monsters are four then we know from this calculation that we have to go up by one entry and this we want to multiply with w dot height divided by self. visible monsters that way we get the height of one of the cells with that if I run main. pi and go to switch I can go down and if I keep on going down at some point the entire menu moves up although there's an offset of one element that we can fix quite easily by simply adding plus one if you now try all of this again we are getting a menu that shows all of the monsters which is feeling significantly better and that is going to give us the vertical offset although there's a problem if I run main.py again and I click on switch you can see that the first Monster we can select is the current active monster they are both called spu this we want to avoid and while we add it we want to add a few more restrictions so at the moment we simply get all of the player monsters but later on we do not want to be able to select the monster that's currently on the field on top of that we do not want to select a monster that doesn't have any health for that I want to create another attribute available monster which we are going to get via list comprehension I want Monster for monster in self. player monsters but only if the monster from this for Loop is different from self. monster that why we are excluding the currently active monster and I want to check if monster. health is greater than zero and as a reminder once again inside of monster we getting the health for the monster which is later going to change although for now this part isn't going to do very much with that we have available monsters those we want to use inside of input we want to check modulus and then self. available monsters on top of that inside of switch we want to use for I in range length self dot available monsters when we are getting the name there should be available monsters as well via that if I run main.py again inside of switch we have gotten rid of the first Monster but other than that we still have five the ones that we have defined earlier looking pretty good besides that if you look at a project folder there we have images and then we have a folder called Simple in there we have the simple monster images those I want to display next to the name inside of the switch menu which means we first of all have to import all of this and then display them next to the name that part is going to be an exercise I want you guys to display the simple images next to the name and for that you can choose a position that you like the specifics here don't really matter I want to work inside of main.py and specifically in import assets I want to create a number attribute self. simple underscore surfaces which we are getting via the folder importer I want to go to images and in there we have SIMPLE so in the folder images and simple those simple surfaces we have to get into the UI which we can do fairly easily via another argument self. simple surfaces next up in the UI I want to have another parameter simple underscore surfaces we can store that right at the top self. simple uncore surface is going to be simple surfaces that covers that part next up inside of switch we already have the monster name from that we can select a surface I am going to call this one the simple underscore surface for which I will need the simple surfaces and then use indexing to get a key value pair the key will be the name of the monster after that I want to have a simple rectangle which is going to be simple surface and get F rectangle for which I want to place this Center at position x 100 and Y let's display all of that right below where we display the text I also want display surface do blit with the simple surface and the simple rectangle also I realized this should be self. simple surfaces if I now run all of this again and I go to switch we can see all of the monsters that's looking pretty good another thing that I would like to add for the text position I want to place the mid left that way the text is aligned to the left side which I think looks just a bit better but anyway with that we have a pretty functional menu although at the moment if I press space nothing is going to happen to fix that I want to work inside of input and then check in the L if statement for switch if the space key is pressed which we have already done a couple of times this should be straight forward for now I simply want to print the current selected monster which we can get from self. available monsters and then indexing with self. switch index let's try and in switch I can select this monster this monster and well you can see a Sprite so this doesn't do very much but on this Sprite we have one attribute which is going to be the name then we can get the name so that is looking pretty good although this we can make a bit more elegant instead of printing one attribute inside of the monster I want to set a method that returns a value whenever we are printing this class the D method we need for that is called repper in which we can return a value whenever we are printing this class in my case I want to have an F string with self do name and I suppose then we can add self. Health divided by self. Max Health with that if I now select a monster we getting the name of the monster along with the Monster Health this is working pretty well one last minor thing while we are here if the player goes to the attack menu or the switch menu there's no way to go back to implement that I want to add if keys and P game. Kore Escape then I want to set self. State back to General and then also I want to reset all of the indexes the general index the attack index those I want to set back to zero and zero for everything and also I want to get the switch index and this one should also be zero that way we are starting back from scratch let's try this one I can select attack press escape and we are back in the main menu if I go to switch I can also reset and that's looking pretty good finally for this switch menu the top side should be self the top minus 100 although minus 140 I think is going to look a bit better let's TR off this now and we have the monster menu we can go back and that's working pretty well perfect that covers another really important part now that we have the basic menus in place I want to make the entire game interactive meaning we can attack the opponents and the opponents can attack us the logic for all of that isn't going to be too difficult let's Jump Right In back in the code first of all in the game class I want to have another method that I called getor input this one doesn't really get direct user input instead we're going to pass this get input into UI and then via that whenever we are getting input in UI we are returning values to main. Pi you will see in a second how that works but for now for the parameters I want to have this state and some data although the default value for that is going to be none and I suppose for now we can simply print the state and the data after that when we are creating the UI I want to insert self. getet input and important here we are passing around the method we are not calling it that way inside of UI we can capture get input and stored as an attribute let's do at the top getor input is going to be get input what that means inside of the input method for example when we are selecting an attack I can call self. getet input and then insert this state so self. state in my case and some data for that at the moment we are only printing the data but I want to store it as a local variable called a tech and this attack we are passing into get input I can run all of this and inside of attack we getting the attack State and the attack this also works with the other attacks so a pretty good start after that when we are switching I want to call self. getet input once again with self. state and the monster that we have selected this doesn't need to be in a separate variable although you could do that as well next attempt just to make sure everything is working I can select a monster and I get switch and a monster perfect while we are here I can also add two more L if statements L if self. state is equal to heal and if that is the case I want to call self. get input with heal no need for extra arguments heal doesn't do very much also after the player selected heal I want to set self. State back to General which in fact is something I want to do whenever the player presses space or in other words if the player is switching between monsters and selects one then we want to go back to the main menu that was quite a bit let's try if I now go to attack and select one we get the output and we are going back to the main menu the same for switch that's looking pretty good and if I click on heal we're getting heal and not much else happening finally then for escape I want to add one final L if statement if self. state is equal to escape if that is the case self. get input with escape and if that is the case inside of main. Pi what we can already do is if state is equal to escape then self. running should be false that way I can escape and the game's over that way we can get data from the UI now we have to figure out how to actually use it inside of the game or all of that let me minimize everything actually I want to work inside of get input because in there we have to check for a couple of different possibilities and I suppose we can organize this a bit better I want to check if state is equal to a tack if that is the case we want to call the method apply underscore a attack a method that does not exist exist at the moment but in there we want to Target self. opponent and then use an attack which we are getting via the data the check for the Escape state is going to be an L if statement also we don't need the print statements anymore that looks a bit cleaner next up I want to have toine apply underscore a attack with self a Target and the attack for now in there I simply want to get the Target and update the health of that Target I suppose for now to keep things simple I want to reduce that amount by 20 just to make sure that this is working inside of the run method all the way at the end I want to print self. opponent. Health if I now run all of this I can attack the opponent and we're lowering the health of that opponent that's a good sign although not exactly the system that I have in mind what I want instead after the player get the input we are switching over to the opponent then the opponent does something and then it's our turn again for that inside of thunder in it I want to have the attribute player uncore active which by default is going to be true also inside of the run method we are only updating the UI if self. player active next up after we have gotten input from the UI I want to set self. player active to false that way at the moment we should only be able to attack once after that we cannot update the menu anymore that's looking good after that I want your opponent to do something but there should be a delay between the player turn and the opponent turn if you don't include that the entire thing is going to feel much too fast fortunately for all of that we have timers that we are already importing and those timers we have created in the last game to use them inside of Thunder init I want to have a timers section which is going to be self. timers and there we are going to have two key value pairs first one is player end that is going to be a timer with a duration of 1,000 and if it times out I want to call the function self. opponent uncore turn while we are here I want to create a second key value pair that one is going to be the opponent end if that is the case we are going to call ler turn for all of that not to crash we have to create two more methods opponent underscore turn and we will need layer underscore turn both of those get passed for now and then after we have gotten the input I want to get self. timers with the player end and then activate it also never forget you have to call the update method on all of these timers which I also want to do in a separate method Define update uncore timers with self and all we have to do in here is for timer in. timers do values and then timer. update that way we are updating all of the timers inside of this dictionary then we have to call the method inside of the run method before we are updating anything else self. update timers with that we have the basic setup to make sure that this is working when we are calling opponent turn which happens after the player input when the timer times out then I want to print opponent turn let's try I can attack the opponent and after a second we getting opponent turn that's looking good we first of all want to get a random attack which we can get via the choice method which we are already importing the list we want to pick from is self. opponent do abilities once we have that self. apply attack the method we have already created this one and then we want to Target self. Monster and the attack to make sure that this is working inside of apply attack I also want to print the attack that we are getting let's try this one I can now attack the opponent with let's say scratch then we're getting scratch and a second later we're getting Splash and that's all we can do we are not updating the menu anymore that we can fix right away actually after the opponent turn we want to call self. timers with the opponent end timer and activate this one once this time it times out we are calling player turn in which for now we simply want to set self do player active back to true that way I can attack with nuke we're getting another attack and then after a second I can use the menu again let's say I want to use another attack spiral and then after a second we are getting another attack and do we always get the same attack no we don't that was coincidence perfect Randomness can be a bit tricky next up I want to properly calculate the damage that we are getting for that if you look at settings we have two dictionaries that we have to work with the first one is abilities data there we're getting all of the attacks and then the base damage along with the element this dictionary we can access via the attack besides that we have element data which is telling us how good an element is versus the target this I can use to calculate the proper damage amount and getting that value is going to be your exercise I want you to calculate the proper damage amount pause the video now and see how far you get first of all I want to get the attack data for which we want to get the abilities data dictionary and then pick the one key value pair that we're getting from aack via that I can print a tack data and let's see what we are getting if I attack with spark we're getting damage element and animation and damage here is the base damage which we can already use we have the base damage that we are getting from Attack data and damage next up we want to calculate the element multiplier we will need the target uncore element which we can get from the Target and that is going to be a monster which has an element or in other words we can simply get target. element for the attack underscore element we simply want to get attack data and in there we have an element we are simply picking this key value pair once we have that we can get an attack underscore multi player for which we want to use this final dictionary for this one we want to pick the element of the attack and then the element of the target which means I want to get the element data then the attack element and finally I want to get the target element and just to make sure that this is working let's print all of this via an F string I want to print the attack element then I want to have the target element I want to have the base damage and finally I want to have the attack multiplier let's try all of this and if I attack with spark which is a fire attack we are getting fire PL 35 and two that's looking pretty good also we got a second entry for fire fire 35 and one which means we attacking fire with fire so our damage multiplier is going to be one this is working quite well with all of that we can calculate the full damage amount it's simply going to be base damage multiplied with the attack multiplier and all of this we can clean up quite a bit we don't need this many lines of code for example the base damage we are only using once so we can use it directly in there for the attack multiplier we are also accessing another dictionary so in there we can get the target element straight away and we can get the attack data element that way we are doing all of this in three lines of code which I think is also much more readable finally to make sure everything is working I want to print an F string with target. health and then target. maxcore Health if I now run all of them this I can attack a plant monster with a fire attack let's go spark and that does quite a bit of damage just to double check we have done 70 damage with this one attack and we have used the spark attack which we can check inside of ability St we have spark which has a base damage of 35 which we have multiplied by two because we have attacked a plant monster with a fire attack whereas the opponent attacked us and only did 20 damage that could have been for example because the opponent use scratch which does 20 damage and the attack element is normal which has no multiplier for anything I suppose we should be a bit more careful I also want to print the attack that we are getting so one final test I can attack a fire monster with a normal attack and we are doing 20 damage whereas the opponent has used luk which is doing 50 damage and the multiplier is one because we are attacking fire with fire back in the game I want to attack now with a splash attack which is doing 60 damage overall we went from 100 to 40 that is because splash does 30 damage and we are attacking with water and our Target is fire I think this is working pretty well so with that we have made the game interactive although this isn't terribly visible yet because we have no attack animations and no Health to display that we're going to do in the next section so for the next section we want to make the entire thing much more visual which means we have a health bar and attack animations the health bars are going to take a bit of math but it's not too bad the attack animations are also going to be a fairly basic animation the one difficulty might be if you open the project folder under images we have the attacks and for each attack we have one PNG file which contains multiple Graphics those we have to separate inside of pame which we can do but it will take just a bit more logic and start inside of the UI in there I want to add one more thing Define I call this one stats as always first of all I want to have a background which is going to be a rectangle via py game. F rectangle in which I want to have self do left self. top and for the dimensions I want 250 along with 80 for width and height after that I can copy from switch the py game. draw for the background and the Border like so to see the results inside of the draw method I want to call self. stats let's try main. pi and there you can see one additional box although if we calling switch this one is looking a bit weird to fix that inside of UI I only want to call this method if self. state is different from switch let's try this again and if I select switch we cannot see the name of the monster anymore that's working pretty well after that once we have the background I want to get the actual data which means I most importantly want to have a name surface self. font. render with self. monster. name for nlus I want this to be true and for the colors I want colors and black then we need a name underscore rectangle which is the name surface get F rectangle in which I want to place the top left for which I want to have the wct dot top left plus pame do Vector 2 for just a bit of an offset for X I want to have rect dot Wii multiplied with 0.05 which means when we getting this background rectangle we have 5% of the width as padding to the left side or the top I simply want to have 12 pixels also I can see at typo this should be monster. name finally self. display surface do blit with the name surface and the name rectangle let's try this one and we are getting the monster name perfect after that I want to have the health bar for which first of all I want to define a health rectangle pame do F rectangle and now I have to figure out some numbers that Define the size and the position of the health bar I want the left side to be aligned with the monster name which means name rectangle do left for the top I want to have name rectangle do bottom plus a bit of petting let's say 10 for the Wii I want to have W do WID multiplied with 0.9 or 90% of the width of the entire background for the height finally I want to have 20 pixels just to make sure we can see what's going on py game. draw do rectangle wave self. display surface then I want to have colors and gray and finally the health rectangle if I now run main. Pi we can see a rectangle for the health of the player doesn't do anything at the moment but that's going to be the next part I want to have self. draw uncore bar for which I want to use a couple of arguments the first one is the health rectangle for the size and the position besides that I want to have self. monster. health or the current amount and finally self. monster. maxcore Health this method doesn't exist at the moment so we have to create it draw bar we have self a rectangle a value and a max value and now we have to talk about the basic problem in here at the moment via the rectangle we are getting some area that we want to use for the health bar let's say for Simplicity this thing has a w of 100 pixels and let me add pixel in there just to be clear the issue we now have for the player monster let's say the current health is going to be 60 and the max health is going to be a 100 how can we get the width of the bar from these two numbers and for that first of all inside of the health bar we have to know how many pixels do we get from one Health Point that is a value we can calculate fairly easily I'm going to call this ratio I want to get w. WID and divided by the max value that way in our example if the width of the rectangle is 100 pixels and Max health is also 100 then each pixel represents one Health Point and all of that we are storing in the ratio variable via that value we can create I call this the progress rectangle which is going to be another py game. F rectangle in which we want to get a top left position and a size via two tballs the top left is simply going to be wrecked dot top left for the size I want to have a width and a height the height is easy we simply want to get rect do height or in other words the height we're getting from the rectangle that we are passing in there as an argument for the wi though we want to get the value and multiply it with the ratio and that is basically it I can now call py game. draw. rectangle on self. display surface with colors and red and finally the progress rectangle if I now run main. Pi we are getting some health and if I attack the opponent the opponent attacks us we are losing health I can do this multiple times and we keep on losing Health that's looking pretty good next up below the UI for the player I want to have another class that I have called opponent UI and there I want to duplicate what I have done inside of stats meaning I want to display the opponent monster name and give them a health bar this part is going to be your exercise so create a UI for the opponent with the name and the health bar pause the video now and see how far you get to get started I want to define a thunder init method with self and a monster then we will need self. displore surface with py game. display doget surface afterwards I want to have self. monster as the monster and we will need self. font which will be py game. font. font with none and 30 after that I want to have a draw method in which we are defining a background via a rectangle py game. fere and for the position I will go with zero and zero for now you will see in just a second why for the dimensions I want to have 250 and 80 the same thing we have used for the player although we don't need the player UI anymore after we have that I want to on this rectangle use move two that way we can place the mid left right away I want this value to be 500 for x and for y I want to have self. monster. re. Center y after that we can do the usual I want to copy py game. draw for the background and for the Border after we have that inside of main. Pi under UI I want to create self dot opponent UI and the value is going to be opponent UI with self. opponent opponent UI is not available at the moment that we can change by changing from UI import everything with that we getting the opponent UI to display it inside of the run method I want to call self. opponent UI and then draw with that we're getting an area for the opponent and if I run this a couple of times we getting a different position for this box every time because it updates along with the opponent that's looking good you could make all of this static as well it's entirely up to you that part isn't really important for me what I want to work on is a name surface which we are getting via self. font. render with self. monster. name through for antialias and then colors and black next up I want to have a name uncore rectangle with the name surface get F rectangle in which I want to to place the top left and this is going to be very similar compared to what we have done for the player rect do top left plus pame do Vector 2 with rect do wift multiplied with 0.05 and 12 finally self. display surface. blit with the name surface and the name rectangle let's try this one and we are getting the opponent name that's a good signed next up I want to work on the health once again we want to create a health rectangle which is going to be py game. F rectangle with name w. left name W do bottom + 10 wct do WID multipied with 0.9 and 20 the very same numbers we have used for the player monster after that I want to calculate the ratio to figure out how much health is one pixel or in other words I want to get the health rectangle do WID and divided by self do monster. maxcore Health once we have that I can calculate the progress uncore rectangle which will be a pame f rectangle once again with health rectangle top left for the position and for the size I want to have self. monster. health multiplied with the ratio that would be the width and the height is going to be Health rectangle do height and that is all we need we can now draw a couple of things pam. draw. rectangle with self. display surface then colors gray and a health rectangle for the background then duplicate all of this we want to have a red color with the progress rectangle that's all we need in here and now I can attack the opponent and the opponent loses Health the same happens to us and this we can do multiple times looking pretty good to make all of this more visible I want to create an attack animation for that inside of the code I want to create attack dop this is going to be a very simple sprite from settings import everything and then create a Class A attack Animation Sprite Which is going to be a pygame Dos sprite. Sprite defined under a knit with self a Target rames and groups next up we want to have super thunder in it with the groups and self. Frames self. frame uncore index with the arguments frames and zero once we have that we can create self. image which is going to be self. frames and then self. frame index self. rectangle is going to be self. image and getorf rectangle in which I want to place the center at target. re. Center we are simply creating an animated Sprite this we have seen a couple of times by now after that I want to have an update method with self and Delta time in there I want to have self. frame index plus equal 5 * Delta time and for this animation I want to check if self. frame index is smaller than length of self. frames if that is the case I want to update self. image and set it to self. frames index integer of self. frame index and else if that is not the case we want to call the kill method to discard this Sprite that would be a very basic attack Animation Sprite now we have to figure out how to use it for that inside of main.py I suppose we can start by importing it R Tech Import for attack Animation Sprite after that every time we are applying an attack I don't want to print anything anymore instead I want to create one instance of the attack Animation Sprite for which we will need a Target that we already have after that we will need some frames this part we don't have at the moment the groups though we do have self. allore Sprites so how can we get the frames and basically for that inside of import assets I want to create self. attack frames which I want to import via a tile uncore importer in which we have to specify the amount of columns which in our case is going to be four and then the folder path images and a Texs this tym portter doesn't exist at the moment we will work on that in just a second first of all though inside of attack Animation Sprite I want to get self. attack frames and then pick one frame via the name of the attack that would be all we need for this attack Animation Sprite so now we have to figure out the tile importer method this I want to create inside of support. Pi Define tile importer with the amount of columns and then unpacked the path to get started in here here we will do a couple of familiar things I want to have a dictionary called attack frames no values at this point then for folder underscore path underscore and file names in walk join and the path this is something we have seen multiple times at this point after that for file uncore name in file names then I want to create a foldcore path via the join method folder path and file name via that we can create a surface P game. image. load with the full path and convertor Alpha but this we do not want to attach right away to the attack frames inste what I want to do inside of attack frames I want to create a key value pair the key is going to be file name do split wherever we have a DOT and then pick the first entry or in other words we get the file name without the file ending the associated value for now is going to be an empty list and what I want to do if I open all of the attack animations let's have a look at scratch all of this is one image which isn't ideal for me I want to set separate this thing into four separate parts and then attach every individual bit to the attack frames list the one we have just created for that first of all we will need to know how wide the cutout width needs to be and for that I want to get the full width of the surface so Surf and get with this we want to divide by the amount of columns that we have so by default pame doesn't know how many images we have on this one PNG file this we have to specify ourselves and in my case it's always going to be four which is why I added four in there after that I want four column in cols and this CS needs to be inside of a range function what we want to do in here is essentially create a cutout surface which is going to be a very simple pame do surface with the cutout WID for the Whi and then surface get underscore he and don't forget to call this one on this cutout surface I want to blit the part that we have cut out from the original the trick for that is we want to get the original surface and then position zero and zero and finally we can specify another argument which is going to be the area that we want to blit which needs to be a rectangle or in other words I want to get a cutout rectangle which does not exist at the moment to create it cut out underscore rectangle I want to have pame do f wck with the left side the top side the width and the height the width and height are the really easy part we want to have the cut out width and for the height we simply want to get what we have already used surface and get height for the top this part is even easier it's always going to be zero finally for the left side I want to get the cutout WID and multiply it with the column if this is the entire surface that we have imported this one here and we have four columns this value would give us first of all this side and this would happen on the first four Loop then on the next Loop we are going here then we are going here then we are going here and then we are done and with that we have a cutout rectangle this we then want to attach to the list we have created earlier for that I can copy the name of the key that we want to use and then aend the cutout surface nearly done with all of this we simply want to return the attack frames and then inside of main Pi we should not be getting an error message anymore on top of that if I now attack the opponent we are getting an error and the key error is spiral that means when we are picking from the attack frames there's no spiral file in there which you can double check inside of the attacks there's no spiral in there that is because there's one thing I forgot if you look at settings there we have the abilities and each ability has an animation this is the actual name of the file that we want to import or other words we are already getting the attack data from this we want to get the animation if I now run all of this and I attack we are getting animations this also works with different ones so that is looking pretty good although obviously we have to get rid of the black stuff around them all we need for that when we are creating the cutout surface on this line we want to set a custom flag P game. SRC Alpha that way all of this is looking significantly better and we are getting our attack animations nearly done with this part there's just one more thing I forgot in the last part when the player is getting input from the UI at the moment we only have attack and Escape besides that though another simple thing is L if state is equal to health or rather this should be heal if that is the case I want to get self. monster. health and increase it by 50 besides that I want to create an attack Animation Sprite on self. Monster or the frames I want to have the attack frames with the key green you could make this more flexible but for the healing effect I always want to use the same animation so this can stay constant finally for the groups self do all Sprites with that I can heal and the monster well we are definitely healing but this is kind of strange to fix that part we can do something fancy inside of the monster when we are updating the health I always want to make sure that we are never exceeding the maximum health and for that we can use a property getter and a property Setter the way that is going to work first of all I want to turn Health into a private attribute which we can do by adding a single underscore and afterwards I want to have a decorator called property below which we're going to create a health method with self and nothing else and this is simply going to return Self doore Health with that system we are storing the actual information inside of underscore Health but whenever from outside of the class we want to read Health we are calling this method instead that way by default the game is still going to work just fine although if I try to attack then we get property health of opponent object has no Setter that we can fix inside of the monster by adding a property setter this we get via health. Setter and then once again create a health method with self and this one is going to need a value basically now whenever we are trying to update Health we are calling this method and adding the new value inside there as an argument which means we are capturing the new value via the value parameter and then when we updating Self doore Health I want to limit this to never go below zero and never exceed the max Health which we can do first of all I had a Min function which always picks the lower of two values in there I want to get the max health and I want to get the value so if I now run all of this again I can heal the monster does heal but we never go beyond the maximum health looking pretty good besides that when we are setting the value I want to wrap this inside of a Max function which is going to pick the larger of two values and in my case I want to get zero and the value that way this value can never become negative and that is basically it with that we have a property getter and a property setter that ensures that the health of the monster never exceeds the maximum health which is a really nice functionality so for example when you're calling something like Monster Health Plus 50 you don't want to have to worry about the maximum or the minimum Health this part should be abstracted away which is something you see very often with this kind of system we are nearly done with the game there are just a few more minor bits that we have to add most importantly we need to be able to switch monsters and to defeat monsters then we can add some sound files and then we are pretty much good to go to get started with switching the monster I want to work inside of get input and then check if L if state is equal to switch that is only going to be the case if we are getting UI and input switch in there we are passing in self. state along with the available monster if that is the case I want to call self. monster and kill it after that self. monster is going to be data or in other words whatever we are getting from the UI which is also going to be a monster next up self. Sprites do add self. monster after that we have to update the UI which means self. ui. monster is going to be self. monster that is basically all we need if I now switch to let's say jakana we're getting jakana and we have another monster although if I go back to switch we still have jakana inside of the switch menu this shouldn't be the case to fix that inside of UI I want to work in the update method and then keep on updating the available monsters vi list comprehension Monster for monster in self. player monsters if monster is different from self. Monster and monster. health is greater than zero that way we account for the currently active monster and for Monsters being defeated let's try all of this again and I can now switch to let's say gfin that looks good and if if I switch again we're getting spu that's perfect now you could make D functionality just a bit more elegant for example by updating the available monsters every time Monster Health changes or with switching a monster if your frame rate dips too lad this is something you might want to do but in our case performance isn't that much of an issue so I'm not going to worry too much after that inside of main.py I want to detect if a monster has been defeated I for that we can start inside of the opponent turn every time it's the opponent turn I want to check if self. opponent. health is smaller or equal to zero if that is the case I want to do something but pass for now if that is not the case else I want to do the stuff we have already done if the monster is however defeated then I want to set self. player active to R besides that self. opponent. kill and then I want to get a new monster which I want to store as Monster uncore name and get that via Choice list monster data and keys that way we're getting a random monster name via that I want to create a new opponent with the monster name then we will need surfaces which we can can get via self. front serves and the monster name once again finally for the groups self. all Sprites after all of that self. opponent UI do monster is going to be self. opponent that's basically all we need if I now run all of this I can attack this monster with a fire attack it disappears and we're getting another monster although if you paid close attention you have seen something else let me pick another attack and pay close attention to what's happening on the screen we're getting a shadow right below the attack and something else went wrong as well step by step first of all when we are drawing all of the floors that happens inside of draw monster floor in there we are drawing a floor below all of the Sprites which worked so far but now we also have aack Sprite which shouldn't have a floor to account for that I want to add another instance if is instance I want to check the Sprite and then check if it is from Monster a creature so in there I want to have creature which I believe we have to import from Monster I want to import everything only if that is the case do we want to draw a floor let's try off this again and now if I attack we can only see a floor below the monsters that's looking pretty good so next up after we are defeating an opponent once it disappears and that's looking pretty good although the UI doesn't update something is going wrong here the issue is we are creating a new opponent but we are not overwriting self. opponent once we are doing that things should be working if I now attack the opponent with a fire attack it disappears and we are getting another opponent if I defeat this one with Splash we are getting yet another opponent and this I can keep on doing forever that's looking pretty good and there's one thing I so far haven't covered the kill method doesn't actually destroy the Sprite instead it simply removes it from any group which in practice means you cannot see it anymore and it won't be updated but the Sprite is still there which sometimes can be a bit confusing but once you understand how it works it's quite manageable anyway with that we have the opponent turn next up the player turn if the monster is defeated so if defeated then we want to have the next Monster or in other words if spu is defeated then we want to get the next monster with health which might be cleave and then if no monsters we end the game implementing this part will be your exercise so change monsters if the current one is defeated and end the game if all monsters are defeated I want to check if self. monster. health is smaller or equal to zero if that is the case I want to get all of the available monsters for which I can use list comprehension once again Monster for monster inself dopler monsters but only if monster. health is greater or equal to zero then I want to check if there are available monsters in the first place if that is the case I want to kill the current monster self. monster. kill and then create a new monster with the first item from the available ones after that self. Sprites do add with self. monster finally we have to update the UI and there I want to get the monster with self. monster let's try all of this and I want to attack the opponent with spiral that's not going to do very much damage and the monster gets defeated and nothing is happening and that is because this if statement should only check if health is greater than zero if I now try out off this again and let me just attack the monsters and hope I don't kill them too fast we got defeated and now we have another monster perfect you might be wondering at this point why for this list comprehension don't we have to check if we have the current monster like we have done in UI for the available monsters and there we are checking if the monster is equal to the current monster this we don't need because this is only going to run if the current monster has been defeated meaning it's going to disappear anyway besides that if we don't have any more available monsters then we simply want to set self. running to bals that covers everything so next up for the player I only want to have two monsters let's try all of this now and let's hope I don't defeat the opponents too fast that was a good attack that was too strong that one doesn't do any damage okay that's one monster gone and next up I could choose weaker attacks this one doesn't do any damage and now the game is over perfect although there's one issue I did realize if we only have a single Monster so let's hope I get defeated quickly there we go if I only have a single Monster and I go to switch we are getting integer modulo by zero which happens inside of the input inside of switch we are doing modulus and then the length of the available monsters which is a value that can become zero and doing modulus zero is going to get you well something really strange to avoid that case we simply want to check if self. available monsters only if that is the case do we want to allow any input in there with that I can only have a single Monster Run the game and inside of switch nothing is going to happen and with that we have basically the entire game the last thing that we have to add are the sound effects which we can already import quite easily under import assets I want to add self. audio for which we have inside of support audio importer this I want to use audio importer and then go to AUD the yo the same folder that we have already seen a couple of times in there we have a whole bunch of attack sounds and background music that's all we need to play those I want to look at apply attack and then get self. audio and then we need the file name if you look at those files you can see that we have the same name that we are getting from the animation from each of the attack for example we have scratch fire explosion which means inside of audio I simply want to get the attack data and then once again the animation and this I want to play we should be getting sound effects that is working quite well perfect the last thing then we have to start playing the music which I suppose we can do inside of thunder in knit after we importing all the assets I want self. audio with music and play the entire thing as an argument in there I want to have negative one so this one plays forever perfect that is working really well just one more thing that I forgot when the player gets healed we are also getting getting the attack animation which means in there I also want to get self. audio with the green animation sound and play that one with that inside of the game we are getting a sound effect perfect and that finishes up the entire game so I hope all of this was useful and thanks for watching