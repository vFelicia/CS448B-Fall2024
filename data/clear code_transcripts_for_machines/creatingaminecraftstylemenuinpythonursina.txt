hello there in this tutorial we are going to be creating a minecraft style menu into cena game engine it's going to look like this and it's a pretty straightforward project takes about an hour and there isn't really anything too difficult to do so if you're beginning on a scene out this should be a pretty useful project to understand the entire engine that being said if you have no idea about it i would recommend to check out this other tutorial i made first it's going to be quite helpful to understand the basics but yeah besides that should be pretty straightforward now another thing to give some credit i didn't start entirely from scratch for this project instead i have taken some of the official examples and modified it quite a bit to make it more understandable so if you want to know where i came from check out this github page it's the official example for this same kind of project although with some slight modification and i think a bit more difficulty built in but uh yeah with that being covered let's jump into it and i hope you enjoy all right so before we get into the actual code let's first talk about the theory here and there are a couple of bits that are a little bit more complicated so let's talk about all the important concepts we need to understand to make all of this work number one we need an item that we can drag around that's like the main point of this whole project and luckily ucena makes doing this really easy because there's an object called the draggable and it's called the draggable because you can drag it around the name makes sense here so this part is incredibly easy and we are going to implement this in just a bit now the second part is slightly more complicated because when we drag around items we don't just want to drag them in random places instead we want to drag and drop them into specific parts so they snap into the cell and this unfortunately is going to be slightly more complicated because there's no inbuilt methodologina that makes all of this work by default now that being said it's not that hard to do because we can still access the position of every draggable item and when we use a little bit of math here we can place them in very specific positions that would correspond to the grid really all we are doing is we are taking a position we are rounding it in a certain way to turn a 0.25 into a 0.2 for example that's really all we are doing here and that's basically it for all the really important concepts we are going to need obviously there are going to be a couple of smaller bits but i guess i can explain them as we go along so with that being said let's actually jump into the project and to get this started i just want to create a basic window that has a background for the menu so right now we are literally going to just create a window with a background image that's all that's going to happen here so here i have an entirely empty sheet of code and this sheet of code is saved in the same folder as a couple of images that we are going to use in just a bit for example there's the background image for the menu there are a couple of textures for the items and also the cell image and whatever you want to call it so make sure these are all saved in the same folder or at least the same project if you use something like pycharm now with that we can actually get started by creating our basic window and a background for the menu so the first thing i want to do is from usina import star so we are importing literally everything from mussina and don't have to write to cena at the beginning now next up we have to create our app for c now and this happens by just calling usina itself and then we have to run this app ideally spell it correctly and if you do that and you run the code you can see a basic window it doesn't redo anything right now but that is going to come in just a second so this is the very basic setup you need for cena now the first thing i want to add is a background image for the menu and this is literally just going to be an image nothing else so a very very simple setup and this is going to happen in a class that i'm going to call it bg and this one has to inherit from entity and in here we have to define our inet method call self on it and then here we have to create our super init method and in here we are going to need four different attributes the first one is we have to define the parent and this basically means that we are going to attach it to the world and there are two different options here number one you can attach something to a scene or to the world and this means you are going to place it into a 3d world but that's not what we want we want to have this 2d image right at the screen and to achieve that we need the other way which is called camera.ui and this basically means that we are gluing something on the screen that the player is looking through so it's right in a 2d space in the center of the view so next up we have to define the shape and this happens with model and for model i want to go with quad so we have a basic square and this would already be a basic start if we are going to create an instance of this class so let me call it bg and create an instance of it and now if i run this we can see a big white square well grayish square so that's a start i suppose but that doesn't really look like a background for menu so i want to add one more thing for now and that's going to be the scale and all we have to do in here is to define an x and a y scale and both of these have to between 0 and 1 with 1 being the full width oh well you could make it larger than one but then you would make it larger than the original size in my case i want to go with 0.56 and 0.86 and now if i run this you can see something that looks a lot more like the menu we are going to create in the end and now you might be wondering why did i choose those specific numbers and keep the thought in mind it's a really good thought i'll come back to it in just a bit but for now there's one thing missing because if i run this entire code again we don't just want a plain grayish background we want to have a texture on it and for that we have to load a texture which is really just an image and all we need in here is to call load texture and attach a string of the file we want to add in my case this is called bg.png and now if we run this we can see a much more minecrafty looking background color cool so this one is already working quite well now obviously right now this doesn't really look like much because we just have a static image that doesn't do anything so we want to add a draggable item to it and that is actually super easy because usina has a draggable object and this one is literally just an entity that you can drag around and in addition to that it has two methods that are being called automatically and they're called drag and drop and well they're named kind of appropriately whenever you drag the draggable the direct method is called and whenever you drop the draggable the drop method is called that should make sense i think and along with that you can also call the position of all of this there are a couple of ways of doing this actually but yeah let's actually implement this and then i am going to explain how all of this works so here we are back in the code and i want to add another class and i called this one item and this one has to inherit from draggable but besides that we still need to call an indeed method and we also still need our super method to initiate the thing fully that's just a part of usina and now in here we have to specify a couple of things first up again we need a parent and for now this is going to be camera.ui although we are going to change this later on i'll explain it then now same thing for the shape we want a model and this one should be a quad because we want squares next up i want to give this a color just to see what's going to happen and for this we need color and color dot let's go with red for now so we can see what's happening and this is actually already all we need so let me create an instance of this item so item is going to be item don't forget to call it and now let's run this and we have a giant red square in the middle but the really important part here is if i direct this with my mouse i can drag it around so this is already working quite well now obviously this red square is way too big so let's scale it down ever so slightly and for that again i need scale and let's go with 0.1 and 0.1 just for now and now with a much more reasonably sized square so this we can already move around quite a bit and this is already starting to shape up to look halfway decent so that's a really good start now along with that we can make this thing quite a bit more powerful and this is by adding the drag and drop method and uh let's start with the drag one so it's just a method of the class it needs a self as well and then here let's for now just print uh let's call it drop drag that would make more sense and then we can also define a drop method in just the same way and here we want to print drop so now let's try the entire thing again and have a look at the bottom left of the screen where you can see the console and now if i drag it you can see drag if i drop it you can see drop so this is super useful and the reason it is super useful is because we can print a ton of attributes of this class in here for example we could print self.x or when we drop it we could print self.y and now let's try this so if i drag it we get an x position if i drop it a y position so we can tell the specific position of wherever we put this object so this is that what we are going to use later to position it in this specific kind of grid and that's going to come back but this is super important and i guess for now we can change this ever so slightly let's turn this into an f string so you can actually tell what's going on and let me just do this for both coordinates so we can have a much clearer understanding of what's going to happen and uh yeah let's just do this for drop so i don't show too many things at once so now let's run this again and now whenever i drop this square we can tell an x in the y position and in here there's something that's kind of particular about ucena that we don't really get an x in the y position like in pi game instead we get like a 0.01 float value um we can still use it perfectly fine although it's i don't find it particularly nice to work with but usina was designed for 3d space and for that this kind of makes sense but yeah it's not a problem it's just annoying so nothing to worry about so with that we have the ability to drag and drop the item and to run some code whenever that happens which is something we are going to use extensively later on but first of all let's create the actual grid so we can see what we are going to do and this is going to be the next step where we are going to create the grids that we are going to place stuff on and for that using has quite a few methods that we can use the most important one is called texture scale and let me explain what happens here usually when you apply a texture to an entity you just stretch the texture across the entire thing so the texture covers the object entirely but sometimes you want to repeat a texture certain times even the x on the y axis so maybe you have some roof tiles and you want to have multiple shingles and in that case you just want to repeat a certain texture multiple times and this is super easily done in c now and this is done with the texture scale because for this you can specify an x and a y value and then a texture is being repeated and that is something we can use for the grid quite well and this is also something we can use later on to place items into the grid um i guess i come back to that later on but um yeah let's actually implement this and let's see how it's going to look so here i'm back in the code and let's create another class and this i think i called grid but the name again really doesn't matter and this one just needs to inherit from entity and then here we need the usual we have to define an init method it needs self then we have to create a super it and in here we need the couple of usual parameters and let me just copy them from the item because i'm lazy so parent is camera ui model squad um the usual now in here now we want to have something else as well we want to have a texture first of all and the texture is just going to be the box of one of the cells in the grid you'll see in a second what i mean and to load a texture we need load texture naming is really a strong suit of usina and how i call this is box.png and now let me actually create an instance of this class let's call it let's call it menu grid and this one needs grid and now let's run all of this and here you can see what i meant now we have a kind of boxy thing around our entire background right now it's way too big so the first thing we need to do to fix this is to apply a texture scale and in here we need a tuple with an x and a y number in my case i went with five and eight and let me just run the code to show what this is going to do and there we go so now instead of having one texture across the entire thing we are replicating a texture multiple times to create a grid so this one is looking much better obviously right now it's way too big so let's scale it down which happens with the scale property and in here i went with 0.5 and 0.8 and now let's run this again and there we go now we have a much better looking grid two really important things here that these numbers here and these numbers here look similar for a specific reason that to get squares these numbers have to correspond with each other so that when you divide one by the other you always get 0.1 and that way each of the cells is exactly 0.1 units high or white so that's quite important and also what i mentioned earlier these numbers here i have chosen or rather i have chosen these numbers here because they are ever so slightly larger than these numbers here and essentially these numbers up here for the background are just a tiny bit larger to create a grid between the cells and the outside of the menu that's literally all it's for so you could have made these numbers a little bit smaller but then you wouldn't really have a padding around the menu cells so this i think looks quite nice so now the important question becomes how can we actually connect these two concepts did we have a draggable and we have a grid but right now they don't work together at all so this is going to be the next step where we are going to create a connection between the grid and the items now to make all of this work we are going to need a couple of concepts and i guess the best way to achieve this is to go through them step by step so let's start with the simplest one that i want to establish a specific connection between the items and the grid so that the grid is essentially the parent class for all the items so we can access all of the items from the grid which is going to be quite important and most of the time in python if you had a task like this you would just create another attribute in the class and then add children to it so we'd have like self.items and then a list of all of the items in the grid class but in usina that's not quite how it works instead what we have to do is to change the attribute of the parent attribute and that way we can create a parent class automatically and it's perfectly fine to use a class that we created ourselves in here as a parent it's actually really powerful and let's actually demonstrate this so here we are back in the code and let me actually minimize bg so we know what's going to happen so whenever this item is going to be created i want this to be a child of this grid class and now just to explain what i just said in the intro if you are doing this in any other python module you probably go something like self.items is going to be a list of item and then you just add multiple items depending on how many you need in usina that doesn't work like that instead what you want to do is change this camera.ui and this one needs to get some kind of let's call it container now what is this container going to be is going to be whatever we pass into the item when we create the instance of it and let me just get rid of this item here because we are not going to need it anymore instead i only want to create items within this grid class so let me actually create a whole new method for that let's call it um at new and this one is just going to need self nothing else and in here literally all we have to do is to create an item and this item is going to need one parameter the parent or the container and the container is just going to be the class itself so literally all we have to do is to pass self in here and well that's literally all you have to do you don't really have to add the item to any kind of list usina does all of that for you so as long as you created a parent for this class and the parent is specified to be this grid you have already attached it so now when we run init on this class let's call self add new item and let's see what happens and here we go now we still have our draggable item but now it has picked up the scale from the parent container which is 0.5 and 0.8 so this thing now has a weird scaling something we can fix in just a bit now obviously this still doesn't help us all that much but it is a really important step that we can use later on because now what we could for example do is in the grid we can call print self.children and let's run that and now at the bottom you can see this one here we have a grid item as a child of it if we added more to it we would have more of that and later on we can cycle through them and get their information for example their position which is very very powerful but all right let me get rid of this part for now and now the first thing i want to do is to fix the scaling of this item and for that we first have to get rid of the scale property at all because we don't need it anymore and instead i want to specifically target this scale x and scale y because the code here is going to be slightly longer and fortunately we can do that all right scale x and and also scale y and now in here we want to figure out a specific thing we want to know from this information how we have to scale this item here because this is going to tell us how big it needs to be and fortunately we can access this information from the child all we really need for that is to get the container so the information we passed in here in this case the grid and from this container we can access the texture scale and this is going to be a tuple the tuber we have specified in here so five and eight and for x i want the one with number zero so the x scale so this one right now would be giving us a five so not great yet but what we can do is we can separate this by one and really all this means is that the entire width of this thing is going to be one and it's going to be separated into five different parts so when we have the width of each individual item it needs to be one divided by five exactly what we have done here so now if i copy this and change it to a one and now let's run the code we can see now we have a perfectly sized rectangle because we are literally using the scale from the parent to define its size but there's one thing i don't really like that this thing is exactly on the borders of it so i want to make this draggable item ever so slightly smaller and this we can also achieve quite easily all we need to do is to make this number here ever so slightly larger so you can really just put it into brackets and then multiply it by 1.2 and do the same thing for the number below obviously change it to 1. and now if you run all of this again you have a draggable that fits much more nicely into each of the cells obviously it still doesn't snap but that we are going to come to in just a bit so with that we have a basic setup to connect the two obviously that still doesn't help us to actually place the item and this is going to be the next part that i really want to work on that whenever we drop the item it is going to snap into specific position and for that we really have to think about two coordinate systems that we have for this setup and right now we only have one coordinate system and that's the actual grid itself and its x and y position and just to be clear here this thing right now is a square that has a coordinate system that goes from 0 to 1 and from 0 to 1 and yaxis and these positions we can measure very easily i'm going to demonstrate that in just a second and now all we really have to do to place items in a specific position on top of that is to imagine a grid on top of this thing and we don't actually create any specific method to create this grid instead we are just going to round the numbers in a specific way so for example if a number is 0.25 and 0.1 we're going to round these numbers in such a way that they're going to snap in a specific position so the logic here i think once i actually implement it is going to make much more sense um let's go through it but this might be a part you want to watch twice it's slightly more complex but let's go back into the code and let's have a look at this so here i'm back in the code and we still print x and y whenever we drop the draggable so let's run this code and let's see how this looks so whenever i drop this right now we get x being 0.0 something and y being 0.06 now if i go to the top left we get x being negative 0.4 and y being 0.4 and just to explain these coordinates all the cells we can see right now have a coordinate system that goes from 0 to 1 and from 0 to negative 1. so if i move this draggable to the top left we can see something like negative 0.5 and 0.5 so we're moving 0.5 to the left and 0.5 up and the really important thing here is that the origin of this system is right in the middle of this grid so from this position we move negative 5 to the left and 0.5 up and again in using remember if you go up the y number increases this is the exact inverse from pygame for example so this is already giving us a certain kind of coordinate system that we could be working with although i really want to make one change that right now the origin point is right in the middle of the swing which is kind of a pain to work with instead i want to have my coordinate system start right in the top left this is going to make our math significantly easier so let's start with that then i want to take this grid and change the coordinate system to the top left and for that all we have to do is to get the origin and give it an attribute of negative 0.5 and 0.5 and now if we run this you can see that now we have moved the coordinate system right into the middle of this thing which um well it's a start but not great yet so now to adjust for this change in origin we have to move this entire thing to the left and up which we can do very easily so all we have to get is the position of the thing and then here it's going to be 0.25 and 0.4 which is exactly going to be half of the scale so now if i run this again now we're back to our normal grid but the really important thing here is you can already tell actually here that our draggable item if i now leave it roughly at the top left we can see numbers that are basically 0 and 0. and this is really important because now if i go all the way to the right we get x being 1 and y being roughly 0. if i go all the way to the bottom you can see zero and y being minus one so these are some numbers we can use very easily to place the item in a specific spot because all we really want let's say this is grid zero and zero then we can place it at position 0 and 0 and just round these numbers a tiny bit same with if we put this in the second spot now we need something like x being 0.2 in the top left which is going to make our math significantly easier and well let's do this actually so whenever this item is being dropped i don't just want to print a position i want to put it into a specific position that is defined by the parent and now in here we have to do a little bit of math and i think it's best to illustrate by printing exactly what we are doing and let me comment out the other two bits so they're not going to be annoying so first of all let's start with self.x the number we already have so if i run this and i drop this thing here we get 0.1 if i put into the second cell we got 0.3 and so on 0.5 and all the way to the right we get 0.9 so we can get an x position now really all we have to do is to round this number in such a way that we get very clean predictable numbers so for example at this first one here instead of 0.1 with a ton of numbers just becomes 0.1 and actually just to make the math a little bit easier here as well let's change the origin point of this draggable item as well so let me close this and let's change the origin point here as well that's going to make our life a good bit easier and here i want the origin to be changed and in here you might be tempted to go again with negative 0.5 and 0.5 but that wouldn't exactly work let me actually demonstrate why so right now we already start in cell 0 and 0. but our cell is glued to the top left but we want to have a little bit of an offset something like this and the problem here is that we multiplied the scale of this cell by 1.2 so it's slightly smaller than the actual cell and we have to encounter this for the origin so i want to have the origin slightly outside of the actual item and well all we have to do is to divide this by 2 and then we have the right number and 1.2 divided by 2 is 0.6 so now there you can already tell our grid is starting to enclose the item so now if i just drag and drop it we get a specific number i have no idea what is 0.5 came from i'm really sorry that seemed to have been a bug no idea but usually this works really well so we get 0 we get 0.2 we get 0.4 we get 0.6 and we get 0.8 so all we have to do now is to round these numbers in such a way that they're always identical so we don't get 0.196 and so on instead we get 0.2 that's all we really want and for that unfortunately we have to do a tiny bit of math so let's go through it one by one first of all this number here i want to turn for now into an integer and what do you want to do that well i want to have this number clean and rounded so right now i want to have this integer between 0 and 4 because that way we can just divide it by 5 or the number of x cells that we have and then we would always get a clean number so let me print this this should kind of almost work so we get zero and zero we still get zero and zero but if we get too further to the right we get zero point two and so on eventually we get a larger number so right now this doesn't exactly work but you can kind of see the principle i think but this number obviously is way too small so we have to get this number to be a little bit larger and a simple thing you can start by doing is to multiply this number by five so let's say if this number is here is 0.2 we multiply it by five then this entire thing would become one and we then divide this by five then we will get 0.2 so now let's try this again this should already get us quite a bit closer to it so we get 0 and 0 0 and 0 still now 0.2 0.6 and 0.8 so this almost worked we're getting much closer and well here is the slightly dodgy part of this project because the next step on how to make this work safe.x i put never brackets and i have added self dot scale x divided by 2. so we are always adding half of the items with and well now we run this and we get 0.0 0.2 0.4 0.86 and 0.8 so this is actually working really well now um well i got to be honest here i have no idea why this works um when you actually run these two numbers you get really unclear numbers and i think if we get to really high numbers this might start to break down but we're talking really high numbers like if you have hundreds of cells but i guess in our case this is still working although not great ideally try to understand what the code is doing but well it is also working so that's a good start so now instead of printing this number here i just want to set self.x to be this number and well now whenever i drop this so even if i print it right in the middle it snaps back to the specific thing because we are rounding it in such a way that whenever we drop it it drops back to it obviously right now just in the x axis but this is working quite well so now we can just do the same thing for the y axis change self.x to self.y and all of these axes to a y and obviously this year from a 5 has to be an 8. ah and one more really important part since the y axis if you go down what is negative this shouldn't be plus it should be minus so now let's try this again and now i can just place stuff and now it always snaps towards the specific grid that we are going to work with um yeah this is actually working super well so um nice and uh yeah so this bit here is a little bit of tricky math and basically when i figured this out it was just trial and error and i still don't fully understand it so later on if you make this your own project and you make this much larger be aware you might want to work on these numbers here but yeah i guess at least for now it at least works so that's a pretty good start now there's one more problem that i really want to address and that is right now we can drag this item anywhere on the screen which not great it's a bit weird so i want to give it some kind of constraint and to fix it i want to add another method and let's call it menu constraint and when we define constraint needs itself and here the logic is actually super easy because we know in our menu grid we have specific coordinates that the thing starts at 0 and goes to 1 on the x axis and goes from 0 to 1 on the yaxis so all we have to do is that if we go outside of these numbers so self.x is smaller than 0 or self dot x is greater than one or self dot y is greater than zero or self dot y is smaller than minus one so if any of these are true then let's say for now we want to print outside and let's see if this is going to work so i can still move my item around but now if it places outside we get outside so we know whenever it is outside which is well at least a step in the right direction cool but now i don't just want to print something instead i want to return the item to its original position so whenever we drag it outside of the menu it just goes back to where it started from so the first thing we have to do is to uncomment the direct part because whenever we drag the item we want to get the position where it started from so let me get rid of those two and all i want to have in this method is that whenever i start dragging i want to get the position so for that i'm going to define a new attribute let's call it xy pos and all this one is is self.x and self.y so whenever we start dragging this item we get the position and store it somewhere so we can use it later and well then down here if we are outside of this position we are going to place the item back into the position where it came from so self dot x is going to be self dot x y pause the first one and then for self dot y is going to be self dot x y pos and one and well that's it let's run it now so i can still move it inside but if i go now outside it snaps back but i can still move it inside of the grid so um that's literally it now we have the ability to place this item inside of this grid and that's working really well cool all right and with that we have the really complicated part of this project out of the way i guess the next step is we can make all of this look a little bit nicer and what i mean by that is that when we have our item i don't just want to have a red item i want to have an actual texture so let's work on that and the logic here is going to be quite simple when i create a grid class i'm going to import a couple of textures and each item is going to get a random texture that's basically going to be it so here we are back in the code i have minimized everything to make it a bit more readable and i want to work in the grid and specifically what i want to do here is to create a new method let's call it import textures itself and nothing else and in here i want to do two things number one i want to import a couple of textures and number two i want to import all of these textures to a list so we can actually use them in the grid itself but let's go step by step first of all i want to import a texture let's start with the grass one so the grass one i need load texture again and this one i have called grass dot png and well now we have to do the same thing for all of the different textures we have for example there is a brick one this one needs load texture with brick dot png then we have stone i think i called it i'm terrible at typing load texture this is stone dot png oh actually perfect naming this is called rock let's call it brock and the final one i call dirt and for this one we need load texture and dirt.png so in total we have four different textures but right now we have imported them but we don't really do anything with them so to fix that i want to create in class that i call textures and in there i just want to add all of these different textures so rock and dirt obviously you could have just loaded all of these textures straight into it would have been the same outcome but i guess this one is a little bit more readable now all i want to do is when we initiate this class i want to run this method so import textures and well that's all we really had to do to import all of the textures so now inside of this class we can use this self.textures to get one of the textures so we can close this one and now whenever i instantiate one of these item i want to add random texture to it so i have to open the texture and give it an actual texture so let's put it right below color so texture and let's call this type can't think of a better name and this has to be given to the class when we initiate it so this for now is all we need and now when i create an item let's just start with just the first one so i want self.textures and number zero so now when i run this we can see okay this kind of works you can see some grassish looking thing and the problem here is that this red color and this texture they're working together to create the color so we're basically tinting the entire texture in red when we do this to fix that all we have to do is to turn this into white and now let's run this again now we can see it now this is looking much better cool so now we have a grass texture but i don't just want to always have the grass texture or the one with the index 0 instead i want to have a random one so to do that we need random numbers so i have to from random import rent and actually choice so that we can pick a random item from a list and that literally is in here we need choice put this in there and now whenever i run this okay same thing now we get a brick texture we get a grass texture again grass texture i'm being very unlucky with this oh yeah now we get a stone texture so now we get a random texture every single time we run this um cool so this i think already makes the entire thing look quite a bit nicer and yeah you can play around with the looks of this forever i'm going to keep it simple so with this we have made the entire thing look substantially better there's still one big thing missing that we only have one item and we can't add anything else to it so let's work on this bit and in here again we are going to need a couple of different concepts working together number one is we have to look for keyboard input number two is we have to be able to use that keyboard input to add an item and number three the actually important bit is that we have to find a free cell to add the item to and that we are going to take care of in just a second but let's go for this step by step so here i'm back in the code and the first thing i want to do is to check for keyboard input and this can be done very easily in oceana all we need is define an input function and this takes one argument the key and this is being called automatically by oceana so we don't have to call it ourselves we just have to specify what we are looking for and i want to look for a specific key in my case i went with the key a but you can basically add anything in here and whenever this is pressed i want to get my menu grid and call the add new item method so this thing here and once we have that we are well we have a new item so let's run this let me move this thing to the side and now i press a we got another one and now we can just add more and more items to this and the random method really isn't very random okay that gets better cool so now we have random items the problem here now is that when i keep on pressing this it always adds new item on top of this thing so this is something we do have to work on also i can add one thing on top of another and this is also something we are going to address in a bit but for now i want to make sure that whenever i add a new item this grid first finds an empty cell and only then adds a new item and to make that work when we create a new item we have to give it a position so i want to add another argument into this that's going to be the position and that means also when we create this thing this also needs a position and now we have to integrate this position into our grid which well fortunately is very easy because all i have to do is to get so i imagine this to be a tuple of an x and a y portion so right now we take the x value and now all we have to do is to multiply this thing by one over the texture scale and this number here would always going to be 0.2 because the texture scale for the x is going to be 5. so any number we have in here we are going to multiply by 0.2 so if this is 0 it's going to be 0 anyway if this is 1 this entire thing is going to be 0.2 if this is going to be 2 this entire thing is going to be 0.4 and that way we basically do the same thing as we're doing here we are just going to create specific numbers that don't really change and then we have to do the same thing for the y portion so let me copy the entire thing and just change this to a one and now we get this same thing we have done for the y so i hope that makes sense and now let's test the entire thing so when i call the position i'm going to define pause to be let's start with zero and zero and let's run this and we are in the top left and if i add a larger number let's say two and uh minus four we get 2 from the left and 4 from the top so this one is working pretty well cool now the obvious problem is we are always going to add a cell to this position here which we don't want instead i want to find a cell that isn't occupied yet and this is something we can do but it does rely on a couple of different parts so let's go through them one by one essentially all i'm going to do to make this work i'm going to create a grid of all the cells that are possible in our grid and that's going to be one list i call this all cells now then i have created another list and this is called taking cells and this is literally just a list of all the cells that are already occupied and all i do then is i compare both lists and see which field is empty yet and then i am going to use that cell and i have an empty cell so that's literally the entire logic so let's actually go for this step by step so here we're back in the code and instead of a specific position i want to create a new method let's call itself a find free cell and let's put this right below define find free cell does not need any arguments besides self and we have to start with a list of all the possible cells that we can have so this is literally just all the different cells that are possible and for that i'm going to use list comprehension and for this i have used a vector 2 so a 2 dimensional vector with an x and a y which i think makes sense and now i just want to get all the possible y and all the possible x positions so for y in range from 0 all the way to 0.8 and we want to go in the negative direction and for all of this also for x in range zero and five that is literally all we needed let me actually illustrate what's happening here so let me comment out add new item and instead i want to return all cells and then print pause so um what we're doing right now is whenever we run this method we're going to create all the possible cells in here and return it so it's being stored inside of position and then we are printing it i hope that makes sense so now if i run this we can't see any item but now i've pressed a and you can see a ton of different vectors let's start from 0 and 0 and go all the way to 4 and negative 7. so these would be all the possible sets that we can use but obviously we don't just want to print them we do want to use them so this will be the first step we have all the possible cells so next up i want to find my taken cells and this one is actually also going to be fairly simple essentially i want to first look at all of the children so all the items we have created earlier and i want to cycle through this thing so for child in self.children and now i have to find a method to get the position of this child or the specific grid position so we need a vector like we have done above and for that i'm going to create a specific method inside of the child class so let's call it child get cell pause so really all that's happening here is we're cycling through all of the children and we're calling the get cell position and this one is going to give us a vector with the x and the y position so all we have to do now is to actually create that so i want to get cell position and it doesn't need any arguments and in here i want to figure out what the cell position of this thing is going to be and for that we're going to need an x and a y position and at the end of it we want to return a vector to with x and y so now let's define these two variables and this is going to be actually quite simple all we need is self.x and multiply this by self dot parent dot texture scale in the appropriate axis so 0 for x and this one would then give us the specific point it's on in the grid obviously this then has to be turned into an integer because we want to have clean numbers but that is essentially it now i can just copy this thing for y and change the x to y as well and with that one we just get a specific position so with that we have all the taking cells and all the cells possible and now with that all we have to do is to compare these two different cells and well this just means for cell in all cells if cell not in taking cells then we want to return that cell so the logic here i think makes sense we look at each cell in all the possible cells and we check if this cell does not exist in any of these taking cells and if that is the case we're going to return the cell that is not in any of these cells and then the code is going to end and we are good to go so let me get rid of this and now this should actually work let's try so i run the code we already get one because we're calling it once but now let me try it again and this did not work because we're still adding it on the same position and you might have already spotted the mistake here i do not call the get cell position i just named it so this one obviously would never get a proper position so now let's try this again and here we go whenever i press a i'm going to add a new item to it and here's something slightly weird about you see now if i had more of these grids at some point we get a weird texture error i don't know why this is happening if you start to drag this around you get a slightly different thing you can still drag them you just can't see them honestly i have no idea why this is happening might be a bug so but if you keep on adding it it still works it's just a bit weird um oh yeah and if we have too many of these the entire thing crashes as well so not great don't worry too much about it but the one thing we do have to worry about is some kind of fail safe if we have too many different cells and all i did for this is if the length of the taken cells is greater or equal to the length of all cells then i want to return false and now when we add a new item i just want to check if this thing exists at all and if that's the case only then do i want to create a new item so if we return faults this thing is not going to evaluate and we're not going to add anything new here so um should still work and there we go this is still looking good cool so now we can also add new items and things are still looking quite well cool so let me close all of these again because we only have one more thing to add and that is let me add a few more that whenever these two overlap i want them to switch positions so when i drag this brick on top of the grass and drop it here i want the grass to go to where the brick used to be and let's implement that that's also actually not too much of a difficult thing to add so let's talk about that part all we really have to check in here is that whenever we drop one of these items then we want to check all the children in the grid and if two of them are overlapping we know that we dropped one item on another so then on this other item that we dropped it on we want to move this to where the other item used to be i hope that makes sense and yeah that's actually all for the logic here let's actually go on to the code and let's have a look at this so here i am back in the code and i want to have a look at my items and okay this is also getting quite extensive let me minimize a few things so it's not getting overwhelming so i want to look at the drop so whenever we drop an item i also want to check if it's overlapping with something else because then we know we have dropped the item on another item so let's call this an overlap check and let's put it right below so we can see how they work together so def overlap check it needs self as usual and in here we have to think about a couple of different things number one whenever we drop this we want to check all the children inside of the grid which we can do very easily we want to go for child in self.parent.children so essentially from this item we go to the grid and we look at all of its children and now in here we have to check if one child is overlapping with another child so if child dot x is equal to self self.x and child.y is equal dot is equal to self.y so this logic here might be slightly confusing i think effectively we have a child and we have ourself both are items but when we cycle through all the children we look for all the possible existing items whereas for self we look for this item itself that we currently have selected so the one that we have dropped so that way we can distinguish between the child that already existed and our own item that we just dropped once we have that all we have to check is if child is equal to self then we just want to continue however if that is not the case i want child x to be where the self used to be and this we already have we have x y plus and this is going to be zero and then we have to do the same thing for y except with 1. and let me explain what happens here we first cycle through all the children in the parent so all the possible items and then there we check if any of the children is overlapping with the item we just dropped now if the item we just dropped is ourself we just don't do anything if that is not the case we're going to put the child where our item used to be now this line here is actually really important because if we didn't include it using i would always add both the child and our self to this original position so we have to find some code to ignore the child itself so this one here is quite important and let me put it on the line before i think this looks a bit cleaner but um okay let's try this let me add a few more this still works that's a good sign and let's move this brick to this dirt sign and there we go we can move the two around and um yeah there we go we have a properly working menu system thingy and we can just move stuff around and we are good to go um yeah that was pretty much it i hope you enjoyed this tutorial