hello there in this tutorial we are going to be creating this snake game and python with the pygame module and this is intended for absolute beginners so you don't have to know anything about the pygame module although you do have to know the basics of python programming in general at least a little bit and i will go for these steps to create the entire game and if you already know the basics of pygame skip ahead to this step then you go straight to the snake game but for everybody else just continue watching and we're gonna talk about how games work in general that is going to be really useful to understand what we are doing a little bit later on in this video so let's talk about how games work and i think this is best done by using an example so here's an image from the first level of super mario world and this image is composed of several elements we start with the background then we add a floor and some bushes then mario himself and finally some indicators at the top and each of these elements is just a picture that you could even download and use yourself and the important thing to note here is that this image is not just drawn once instead it is drawn multiple times per second in what is called a game loop and then to turn this into a game we have to add two more things number one is player input so that you have to know what the player wants to do and number two is that on each cycle you also reposition where elements are supposed to be drawn so in total there are three steps we check for player input we position elements on the screen and then we draw all of these elements and if that happens often enough you get a video game so let's look how this would work in practice so we first want to check for the player input and let's say the player is pressing the button to the right and as a consequence we want to move mario 5 pixels to the right and after that we draw the entire image with mario being 5 pixels further to the right and all of this would happen in one cycle of the game loop and on the next cycle we do the same thing again so if the player keeps on pressing right we still keep on moving mario to the right and redraw the entire thing again and then we keep on redoing this about 60 times per second and as a consequence the player is perceiving all of this as an interactive medium and in an actual game much more is happening than just moving a player to the right so for example for mario if he is moving to the right we also want to play a walking animation which further adds to the illusion that mario is walking instead of just being repositioned on the screen but we could also move around enemies or we could give the player power ups or we could add some coins or timers or really anything that would constitute parts of a game and if you understand that logic you can make a game in basically anything as long as you can get these free elements and this could even be a game in microsoft excel this would also be possible but in our case we will use pygame so let's have a look at that but pygame is an external module so you do have to install it from an external source but that is quite easy if you use pip either under powershell or on a terminal in both cases all you have to do is type pip install pygame and you should be good to go although there's one minor complication that if you have pygame 3.9 so the latest version that came out a couple of weeks ago the main version of pygame right now does not work because it wasn't updated yet but that isn't really a problem because there's a newer version of pygame that isn't fully released yet but for our purposes it is perfectly sufficient so if you have the very latest version of pygame all you have to do is type pip install pygame equals equals 2.0.0.dev22 and then you should be good to go there's no other change you have to make and with that let's start writing some code here we are in an empty sheet of code but for now the very first thing we have to do is to import pygame which should make sense that if you want to use pygame you have to import it and in here if i execute the code if you are getting this message then the input worked well and along with that we get a hello from the pygame community message along with the link to the website but nothing that's really relevant here so let me close all of that so now we have imported pygame and we can use it but by itself nothing happened yet and to make something happen we have to add a couple more things the very first spring is pygame dot init and this line is quite simple but really important it effectively starts the entirety of pygame so pygm consists of several modules let's say one module for the sound another module for the graphics and all of these have to be started and much later in this tutorial we are going to work a little bit more with pygame.net but for now this is the one line we need to start pygame but if we run the code now we still can't see anything except the welcome message and to actually see something we have to create what's called a display surface and the display surface is basically what the player sees in the end so you might call this the main game window and this also has to be stored in a variable and this is usually called screen and how we create a display service is with pygame dot display dot set mode a slightly weird name but well it is what it is and in here we have the tuple with our width and the height of the window we want to get and let's say in my case i want to go with 400 times 500 so our window is going to be 400 pixels wide and 500 pixels high and if i run this code you are going to see something really briefly so let me run it and there we could see a window for a very short period of time and this is by design so right now pygame knows that it's supposed to display a window but it doesn't know for how long to maintain this window and because of that it creates the window and then closes it immediately afterwards and to keep it open we have to create our main game loop and this is just a plain while loop and this while loop we are going to close from the inside so this can just be set to wild true so this while loop by itself unless we stop it from the inside is never going to stop and now in this while loop we need to have one line that is called pygame dot display dot update and what this basically does and let me add a bit of white space is that let's say in this while loop we're going to draw all our elements so for example for snake we're going to draw our background we're going to draw the snake we're going to draw a couple of fruits all of this is going to be drawn in here and then what pygame.display does is that it takes all of this information and displays it on the main display surface so that the player can see it so this is the very minimum you need to display anything and if i run the code now this would be working but i would not recommend to run it right now for the simple reason that we wouldn't be able to close it because we didn't implement this functionality just yet and to implement that we need what is called an event loop and an event loop is well it's a loop that looks for different events and each event could be something different but most of the time an event is some kind of user input so this could for example be you pressing a button like left or right up or down on your keyboard it could also be a mouse movement or us closing the window by pressing the little x on the top right it could also be something else like a timer for example we are actually going to see this later on but let's go for this step by step and the very first thing i want to check is if we are going to press the little x at the top of the window so i have to create a very basic event loop and this is just a for loop so i want to check for event in pygame.event.get so at the start of every loop of our game we are going to check for every possible event and then we can do something with these events and what we have to look for is event dot type and this is going to tell us what kind of event we have and this has to be an if statement so if a certain event type is equal to something we want to do something else and the thing we want to look for right now is pygame.quit and this event type is closing the window by pressing the x button and if that is the case i want pygame dot quit and this for all practical purposes is the opposite of pygame.init but by itself sometimes this can cause some complications that some other parts of the program might still be running so this usually is not enough we want another line of code and what we want is cis dot exit and this is another python module so we have to import it so at the top of our code i import pygame and cis and this is a fairly straightforward module it gives you access to lots of system functionality and what sys.exit does is it basically ends any kind of code that it's being run on so in our case if we run sister exit we make sure our code is definitely closed so with these two lines we make very much sure that our game is going to be closed with that being covered let's try to run our code now and let's see what happens and there we go we have a window that is 400 pixels wide and 500 pixels high and right now it's all black for the simple reason that we haven't drawn anything yet but that we're going to cover in just a second but for now we are able to create a basic pie game window so that's a good start but there's one more thing that's important for the basic setup and let me explain what this is right now our game loop so our wild true loop is going to run as fast as our computer allows it to run so for a really slow computer it might run 10 times per second but for a really fast computer it might run 10 000 times per second and this could be a problem because on different computers the game's speed might be completely different because of this difference so we have to make sure that our game runs at least somewhat consistently and even on the same computer it might run differently depending on how busy our scene is going to be so we want to make sure that our game doesn't run faster than a certain maximum frame rate and for that we have to create a clock object and all the clock object does is that it limits how fast our wire loop is going to run and it's ultimately quite a simple thing to achieve so let's go right back into our code and let's implement this so below our screen variable i am going to create a new variable that i call clock and this is going to create a clock object by typing pygame dot time dot spelling it properly and here do make sure the first letter is capitalized that is important but besides that this is all we have to do so this is a clock object that can help us influence time and pie game but all i want to do is right at the end of our game loop i want clock dot tick and in here we effectively have to pass in the frame rate so how many times this while loop can run per second and in my case i am going to go with 60 which is usually a good middle ground for games but you could make this a much larger number if you really wanted to and with this our game is never going to run faster than 60 frames per second or in other words this while loop is never going to execute more than 60 times per second which makes our game quite a bit more consistent now there's still the other possibility that our game might run too slow and this is something we don't have a simple solution for this is basically game design that you have to make sure that your game never runs too slow and you are doing that by not having too many elements on the screen for example but in our case since our game is so incredibly simple this is not going to be an issue but alright with that covered we have a very basic window that runs at a maximum of 60 frames per second so this is a pretty good start and now let's talk about how to add basic visuals to this to really understand pygame you have to understand two basic elements they are called surfaces and rectangles and let's start with surfaces and here's something slightly confusing earlier in this tutorial we created a display surface and this is different to a regular surface although not that much and let me explain it like this our display surface is the big canvas that our entire game is going to run on and there can only be a single display surface and the display surface is also displayed by default for the simple reason that if we didn't have it we wouldn't have a game now a regular surface does the same thing it is still a layer that we can put stuff on but we can have as many surfaces as we like and each surface is only displayed if we write code for that so you could have quite a few different surfaces if you didn't write code to display them they would be invisible so if you want to use a surface you need to follow two steps you first have to create a surface and then you have to put the surface on the screen and creating a surface can be done in three basic ways if you import an image you are going to create a new surface with the image on it the same is going to happen with text so if you create any kind of text the text is always going to be on a new surface and number three is that you could just create an empty surface that doesn't have anything on it so it would just be black by default although you could also fill it with any color you want and for the second step you have to take the surface and put it on the target surface where you want it to be in our case this is always going to be our display surface although you could also put one surface on any other surface as well but that's quite a bit of talk let's actually play around with this so here i'm back in my code and for now i just want to create a basic test surface and this is going to be just an empty surface and how to create this is pygame dot surface and this kind of like set mode is going to need a tuple with a width and a height and let's make this let's say 100 pixels by 200 pixels and that is all we needed so now we have another surface but if we run the code now we wouldn't be able to see it because we didn't put it on the display surface and this we have to do in our while loop and what i want to do is to put our test surface on our screen display surface and for that we first have to type screen to get our display surface and then blit which stands for block image transfer and then here we need the surface and a tuple with the x and the y position so our surface is going to be our test surface and for x let's go with 200 and for y let's go with 250. so hypothetically we should see something right now so let's try it and our code is running but we still can't see it oh well technically we can but it doesn't help us too much for the simple reason that both our screen and our test surface are both black so technically while they are both visible we can't see them because they have the exact same color so we have to figure out how to add color to each of them and the easiest way to give them color is to use the fill command and let's do this actually on the screen itself so let me add another line of code and i want to fill the screen with a greenish color and for that we need screen dot fill and in here we need some kind of color argument and there are two ways of achieving this in pi game number one is an rgb tuple and number two is a color object the color object is easier to explain you just type pygame.color and insert the string of a name of a color and then pygame picks a specific color that was predefined so for example i could type in here pygame.color and let's go with gold and now if i run this we should see a golden background color and there we go and now we can also see our test surface and here think about the starting position this one is going to become a bit more important in a second but for now we have a basic color but in my case i don't want a predefined color instead i want to define my own color to keep the entire thing consistent in tone and to create a custom color we need what is called an rgb tuple so let me explain what that is rgb stands for red green and blue it's literally that simple and what we basically do is we determine the amount of color for each of these values so for example we could have a hundred percent red zero percent green and zero percent blue and if we then put these colors together we have a red color and that's really all it is the only thing you really have to remember is that the lowest value you can give for each color is zero and the highest 255 with 255 being 100 of this color so in my case i'm going to go with an rgb tuple of 175 215 and 70. so our color is going to have quite a bit of green a bit less red and very little blue and this combined is going to give us a greenish color so let's actually implement this so here i'm back in my code and let me get rid of the color object and i want to create an rgb tuple so i create another list and then here i type 175 215 and 70. and now let's try this and there we go now we have a greenish background and if you want to challenge yourself and code along here is going to be a short exercise try to get this test surface and fill it with a blue color and if you want to do it pause the video now and try to do it yourself so this could be done before the while loop and i just want to get test surface dot fill and in here to get a blue color we could either go pygame dot color and in here type blue and if we run the code now our test surface is going to be blue alternatively i could just add an rgb tuple that has 0 red 0 green and 255 of blue and if i run this code we have the exact same outcome and with that we have already covered the very basic colors but here's one thing i really want you guys to pay attention to that our test surface we have placed on position 200 and 250 and this point is exactly half way of our display so the point we placed it on is right in the middle of the screen but our test surface is very much not in the middle of the screen so what's the problem here and it's not really a problem it's just how pie game works when we specify this point we specify the top left of this surface so of our rectangle the top left point is going to be at position 200 and 250 and we are going to get more control over this in just a bit but before that i do want to cover an animation just to cover it on a basic level right now it looks like our surface is being static and well it kind of is but the main principle here is that this image is being redrawn every time this while loop is running and the reason it is static is because the position we put it on is always the same but we could totally change it so let me close it and let's say i want to move the x position so this one and for that i can just add a variable in here and create the variable early on so let's call this xpos and by default it is 200 so exactly what we had so far so let me run it and we get the exact same result but what we can do now is just to add x plus plus equal one and now let's run the code again and see what happens and there you can see our surface is going to move slightly to the right and this looks like an animation but basically what happens is that every time this wallop is running it is going to put the surface on this x position but this exposition gets slightly larger every time we call it and because this happens at such small increments and so often that to us it looks like a fluid movement so we consider this an animation and we could also do it the other way so with and now let's try it again now our surface is moving the other way so it's going to the left and with that we have really basic animations but there's one thing that is important to keep track of and let me change this back to 200 and now i want to move the y position and let me just put an x position in here not great naming but it really doesn't matter and now i want you guys to make a guess is this surface going to move upwards or downwards and what we basically do is make the x position smaller so this one starts at 200 then becomes 199 then 198 and so on and let's actually run this and see what happens and here you can see even though our x is getting smaller our surface is moving upwards which can be quite confusing but let me explain what this means the origin of our display surface is in the top left so if you want to go to the right you have to increase x and if you want to go to the left you have to decrease x this part should feel quite natural however if you want to go downwards you have to increase y and if you want to go up you have to decrease y which is the part that can get quite confusing although this is also the part that is really common in video game development and this is going to take you some time to get used to but ultimately it's not that bad and let me close this and let's do the opposite so i want to increase y and and now our test surface is moving downwards so this is one thing that can get quite confusing but all right let me get rid of these variables because we don't want to go for animations anymore so i just want to place this thing back at position 200 and 250. and let me write again and this is still working and now here's one thing that i talked a tiny bit about earlier that we don't really have all that much control about how to place this surface so for example if we wanted to place the center of the surface we couldn't really do it or let's say if we wanted to place the bottom right we just couldn't really do it and to fix that pie game has another concept that is called a rectangle or wrecked in short and let's talk about those and incidentally they are also the second part on how to draw something in pie game and well a rack is just a rectangle that you can either put around something else or use for drawing and this rectangle has lots of different points that we can influence and you can see all of them on the screen right now and these points are super useful not just for moving something but also to measure if two objects are overlapping for example or if something is moved outside of the screen or you could also measure how large an object is and there are two ways to create a rectangle you could either create one by itself or you could take an existing surface and create a rectangle around it and then once you have a rectangle you can do quite a few different things with them but let's actually play around with this in code so here we are back in our code and the very first thing i want to do is to create a new rectangle let's call this test rectangle and this is just going to be pygame dot rect and in here we have to pass in four different pieces of information we need an x position a y position a width and a height and let's put this thing at position 100 let's say 200 and let's give it a width and a height of let's say 100 each and here again this x and y is still going to be the top left but we are going to get more flexible in this in just a second so now we have a rectangle but if we run the code we are not going to be able to see it so this isn't going to do all that much but what i could be doing now is use pygame.draw.rect draw this rectangle and in here i have to pass in three pieces of information i need the surface to draw on i need a color and i need a rectangle so our rectangle is going to be our test rect our surface is going to be our screen and for the color let's go with pygame dot color and i want to go with we haven't used red yet let's go with that and now let's try this and there we go we have another rectangle and this one is not a new surface it's a different kind of object and later on when we create our snake we are going to be drawing lots of different rectangles that we are going to each put on the screen and you might be asking yourself what's the really big difference between creating a new surface and putting that on screen or creating a rectangle and drawing that and well it depends on what kind of job you want to do usually drawing a rectangle is a much simpler task so it takes less code and less processing power and most of the time for surface you don't just fill the surface you add something else to it so that just filling a surface and putting on the screen doesn't really happen if you want to do that you would just use a rectangle and there are quite a few different things we could draw this could also for example be an ellipse and now if we run this we get a circle and there are quite a few different shapes you could be drawing but i don't want to draw anything just yet and i also don't want to create a surface like that just yet instead what i want to do is to get this test surface and use that to create a rectangle and for that we need test surface dot get wrecked and what this one is doing is it gets this surface and it puts a rectangle around it but the really useful thing now is that in the parenthesis we can specify on what point we want to place it on so for example i could type center and now in here add an x and a y position so for example now if i add in here 200 and 250 this rectangle would be placed right in the center of the screen and then when i use blit or original test surface i could use this rectangle to actually place the surface so let me remove those two points and insert test wrecked and now if we run this we get our surface right in the middle of the screen and there is quite a few different things going on right now so let me go through them one by one in terms of what i have just done i have first created a new surface called test surface and this surface is 100 pixels wide and 200 pixels high then i have drawn a rectangle around the surface and i have placed this rectangle right in the middle of our screen and then i have used this rectangle to actually place the test surface on the screen and we could also use another point for example i could use top right and then we'd be placing the top right so now the top right corner is in the center of the screen and this way you get a ton of control over how you place elements on the screen and let's actually try to move this rectangle to move our surface so i want to get our test rectangle and i want to move the right position and just add plus equals let's say one and let's try this now and now again we can see our surface moving to the right and the important point here is that if we move any point on the rectangle we are going to move all the points on the rectangle so we could for example also move the left of the rectangle and we'll have the exact same result so this one doesn't really matter and all right with that we have covered the absolute basics of pygame that was quite a bit of material so if you feel overwhelmed don't worry too much because i will go very slowly through all of this while i actually create the game so let me get rid of all of this material besides this green dot fill color so now we are back to a very basic setup that's just a green background color and doesn't do anything else and on that we are going to create our snake game but before we come to the actual code for the game let's first talk about the logic on what we are going to do and there are two main concepts you have to understand for the snake game to work number one is that we are effectively creating a grid on our display but we are not really creating a grid we are just simulating it and instead what we are going to do is that every time we are moving we can only move in certain increments so let's say every time you move you have to move by the amount of 40 pixels and since you can only move by that amount you are effectively moving in a grid although it's not really a grid it just looks like one and into this grid we are going to put our snake and that's going to be the second major concept and effectively our snack is going to be a list with different positions and each of these positions is a block and all we are going to do to move the snake is to update each of the block in a certain direction and then we are drawing the block and that gives us a snake ultimately it's actually a really simple logic but i think there was a ton of material covered let's actually start talking about the snake now that we have covered the basic logic of pygame and also logic to make the snake game work we can actually start making our game and i'm going to start setting up our board and placing one piece of fruit in there and the reason for that is that the fruit works in almost the same way that the snake does so the fruit is a really nice way to start with the board and see how we can place elements in there here we are in the code that we have set up earlier and the first thing i want to do is to change the size of our window so these two coordinates because right now they are fixed but i want them to be a bit more flexible and essentially what i want to achieve is that we have one variable with the number of cells and another variable with the size of each cell and then those two numbers combined create the size of our screen so if we always fill the entire screen regardless of how big the cells are or how many cells we have and for that i'm going to create two new variables the first one is going to be cell size and i've set this to 40 and then we need a cell number and this one i've set to 20 and at least for now you could change these numbers to whatever you want it doesn't really matter until we add graphics to the entire game but now for the dimension of the screen i want the cell number multiplied by the cell size both for the x and for the y so now when i run the screen we are getting a screen that is 800 by 800 pixels wide or 40 times 20. so this seems to work quite well and that's really all we need to set up the basics of our game so with that covered we can start creating our fruit and this is going to be a class or well it's going to be an object but we have to create a class for that it doesn't need to inherit anything and when i initiate it i own itself and now i want to achieve a couple of things with this class so let me just write it in the comments number one is that i want to create an x and y position so we can actually place it somewhere on the grid and besides that i also want to draw a square so whatever this position is i want to draw a square which is going to be the fruit and later on we are going to add graphics to this but for now this isn't going to matter so i want to create self.x and let's say for now this is going to be 5 and then i want self dot y and let's go with 4. so right now these are fixed numbers i am going to change them just a bit and having these two numbers along with a cell size would actually be enough to already draw a rectangle however i'm going to put one step in between but i'm going to store these two values inside of a vector 2d and let me explain why throughout this entire tutorial we are going to work very extensively with twodimensional data so we want to have a really efficient way to work and store twodimensional data so that we can change an x in the ycoordinate really easily and vectors are perfect for that and to explain why let me illustrate a difference compared to a list with two values you can see a vector that has an x coordinate of 5 and a y coordinate of 4 and at a normal python list with 5 and 4. and right now both of these express the exact same information and the first advantage of vectors is that accessing the x into y is a bit clearer compared to a list so if you want to access the x or the y for a vector we can just take the vector place x afterwards and then we get the x and the same for y and for a list we would have to use indexing and just add square brackets into 0 or 1. and while this is quite a minor advantage it does make our code considerably more readable if we have more code so this is a nice thing to have but the really important thing that really helps us with vectors is vector math and here's what this means let's say we have our list and we want to move this cell to the right and moving something to the right just means increasing the x by the amount of one so in the list we would use indexing to get the x value and then just add one to it and this would be a fairly straightforward operation and don't get me wrong we could use lists for the entire game it would be doable but also kind of annoying to work in because in vectors doing this kind of thing is much easier because when we have a vector we can just create another vector that has a value of 1 and 0. so this would be a movement to the right and then we can just add this vector to the original vector and if you add two vectors together you get the sum of both of the x values and both the y values so if you wanted to move the vector to the right we could just add a plus right vector and then we have moved it we would not need to identify any specifics of the vector we could just go straight ahead and especially for the snake later on this is going to be so much better to work with but alright i hope that makes sense and now let's actually implement it so here we are back in our code and i want to add these two values inside of a vector so i create a new attribute with self dot let's call it position and to create a vector 2d in pi game we need pygame dot math dot and in here we have to create an x and a y value which we already have we just created them and this is terrible spelling self and self so we just place these two values inside of this vector and then we have a twodimensional vector and there's one more change i do want to make that i don't want to type pygame.math every single time i just want to type vector2 so in the import i'm going to type from pygame.math import vector2 and that way i can just type vector2 which is going to save me so much writing and with that we have a really efficient way to store twodimensional data that we later can use to draw a square so that's quite nice and with that covered i want to create a new method that i call draw fruit so this one is well it draws the fruit and let me get rid of these two comments all right so what i want to do in here is first create a rectangle in the right position and then i want to draw the rectangle so let's work through them the first one is to create a rectangle and let's call this one fruit rect and this one is just going to be a pie game wrecked object and this one is going to need an xcoordinate a ycoordinate then we need a width and a height so we need four different pieces of information and two of them are super easy to get because width and height are just going to be our cell size so i can literally just copy cell size and paste it in there and then we are already halfway there and then we have to figure out the x and the y and well this is going to be for now this position so what i want to get is self dot pause this would be the entire vector but i only want to get the x position so in this case this would be 5 and then i want to do the same thing for our y position so self.y which will get us this value which is 4. and that is literally all we need to create a basic rectangle and now we can get to drawing it and really all we have to do is type pygame.draw.rect which draws a rectangle and in here we need three different pieces of information we need a surface to drawn a color and then a rectangle that we want to draw and we already have most of this information so our rectangle is just going to be the fruit rectangle we just created and the surface we want to draw on is this green surface so our main display surface so that is already getting us quite far ahead now we need to work on the color and this is going to be an rgb tuple and for that the amount of red is going to be 126 the amount of green is 166 and the amount of blue is 114 and for now this is just going to be a plain darkish green it doesn't look particularly good but later on we are going to replace it anyway so it doesn't really matter and all right this is actually almost all we need so let's actually create a basic fruit just to see how this would look like on our game so i'm going to create a new object with the fruit class and then in our main game loop after screen.fill i type fruit dot draw our fruit so that we can actually see it on the game and let's run this and see what happens so now we can't see our green rectangle but there are two problems number one is that the rectangle is way too far in the top left so something went wrong when we placed it and number two if you look at the bottom of the screen is that python is giving us a warning about implicit conversion to integrals using int and both of these we can fix quite easy because they happen in the same line in this line here so let's work for them step by step and the first one is the actual placing of this rectangle so right now for example this self.post.x is five so when pygame places it it literally places it 5 pixels from the left but we don't want to place it 5 pixels instead we want to place it 5 times the cell size and same for position.y right now it's placed 4 pixels from the top but instead we want to place it four pixels multiplied by the cell size so literally all we have to do in here is to multiply this by cell size and this is what i explained earlier that we don't really create a grid instead we move each object by one pixel and then multiply it by the cell size and this creates the illusion of a grid and this is really all we need and let's try this so this is looking so much better and just to test let me change both of these to zero so we can tell if they are in the top left and there we go now we have our square in the top left and just to make one more test let's put it to 10 so now it should be on the left and roughly in the middle of the screen and there we go this seems to be working now so now we actually have a basic grid that we can use to place elements on and with that we can also work on the second problem that way of an implicit conversion to integers and what this basically means is that pygame.rec wants to have integers for all of its values but getting values from a vector is always going to be a float even if we pass integers into it so right now python converts both of these into integers by itself but this might be removed in a future version of python so to make sure our code is going to work in the future we have to do this manually which is super easy to do all we have to do is to put the end method around it and we're good to go so let me do it for both of them and now if we run it we don't get an error message anymore and all seems to be good cool and really all the integer method does is it takes a value and turns it into an integer that's really all that happens here and before we finish this part there's one more change i do want to make that right now both of these values are fixed but we want them to be random and to do that we have to import another module the random module which can generate random numbers and what we want is random.rand int which generates a random integer from one value to another and we always want to start at zero and we want to go all the way to our cell number so cell number however there's one more thing we do have to do that rent in goes from this number all the way to this number and it also includes this number so this could be a number from 0 to 20. and whenever we draw a rectangle this position is going to be the top left so there's a very small chance that the top left might be something like 0 and 800 and this would be outside of our window so we have to subtract 1 from this and this ensures that we are always on screen and since we have a square we can just copy the entire thing for our y position and with that done let's try it a couple of times so we have a random square here let me close it and let's try it again we have a different position and one more time we have another different position cool and for now this is all we needed for the fruit so i can close it and we are going to make one more change later on to it but for now it's working as intended and alright now that we have covered the basics of the grid we can actually start creating our snake and the snake is going to work in a really similar way compared to the fruit the only difference being that now we don't just draw one block on the screen we draw multiple but we are still going to use vectors so effectively what we are going to do is we have a list with all the blocks now a snake and we cycle through this list and draw all of these blocks so let's start with that and once we have that we can talk about moving the snake so here we're back in our code and i want to create a new class that i call snake and i'm going to initiate it as always there's nothing special we need here and for now i only want to have a single attribute that is going to be the body of our snake and this is going to store all the vector 2s that create our snake and in here we are going to place all the blocks that constitute our snake and let me actually add some just to visualize this so i want vector 2 and let's go with 5 and 10. so this is roughly in the middle then i want to have another vector and one more let's start with three and are going to be six and seven so this is just going to be three blocks right next to each other and this is also what the player is going to see when the game is being started so this would always be the starting position but you could change it as much as you want but all right now i need a method that draws our snake does not need any parameters and all i want to do in here is for block in self.body so i'm going to cycle through all of these vectors and i want to do something with each of them and in here very similar compared to our draw fruit i want to create a rectangle from the position and then draw the rectangle so this is going to be incredibly similar to our draw fruit method actually so let's go through it step by step and this could actually be an exercise if you want to challenge yourself try to cycle through this list and draw all of these vectors and this should look incredibly similar compared to these two lines so pause the video now if you want to go along and try this yourself so the very first thing i want to do is to create a new rectangle i call this one block and what we need again is pie game.rect and here we need an x a y a width and a height and again the width and the height are super easy it's again the cell size so all i want is the cell size for the width and the cell size for the height now for the x i want the block so this block here which right now let's say for the first element would be the vector of 5 and 10. and since we're looking at the x this is going to be x so this is literally the same thing we have done here and from there we have to multiply this by our cell size and then to avoid the warning by python again we have to put all of this into an integer statement and that's basically it so now i can copy the entire thing and place it in for the y and then change block dot y and here what you could be doing to make all of this a bit more readable is to create all of this on a few separate lines so our x position would be all of this and then i can copy it and create our y position and then in here i could just write x position y position so this would have the exact same outcome although i guess this one is quite a bit easier to read but it's ultimately up to you but okay now we have a rectangle we just have to draw it so again i want pygame.draw.rect and in here i still want our screen surface to draw on and now i'm going to need a new color and i went with 133 191 and 122 and then for the rectangle we just want our block rectangle and with that we have drawn all of these vectors so now all we have to do is to create an object from this class and then in our game loop just called snake dot draw snake and let's see if this is going to work and there we go we have our basic snake although i think right now the color is a bit hard to see so let me close it and go all the way back to our snake and let's change the green value to 111 this is going to turn the entire thing quite a bit more red and let's try it now and there we go this is quite a bit easier to see but ultimately it doesn't matter all that much because we are going to replace all of this with proper graphics later on but i think for now this is a bit nicer to work with but okay now we have drawn all the basic things we need to make the game workable but our snake doesn't move and let's work on that okay so let's talk about how to move the snake so here's a snake and let's say we want to move this snake one field further to the right to achieve that we take the hat and move it one block further to the right then we take the block before the head and move it to where the head used to be and then we go through the entire snake and do this to every block so that the position of every single block takes the position of the block that came before it and that way every single block follows the head of our snake and this is how we are going to move the snake so we are not actually moving the snake instead we are taking each of the block and putting them in different positions and this simulates the illusion of movement and here's how we are going to simulate this in our code besides our self.bodylist we are going to add a self.direction and this gives us the direction that the snakehead is going to take in the next turn and then in our game at certain intervals we take the first element of our self.body list which is the head and move it by the direction and this way we're moving the head of the snake and then we're going to create a new list that copies our entire self.body except for the last element and to this new list we are going to add our head and that way we have moved every single item inside of the list one step further and we also added a new item at the front for our head so that's quite a bit of logic so let's actually implement it and there are two more things that we really need to make this work number one is that we need some player input so that we can control the snake and number two is that we have to create a basic timer and then we only want to move our snake whenever this timer triggers and in my case this is about every 150 milliseconds so quite a few things to cover and let's just start very simple and we only want to move our snake to the right so here we are back in our code and i'm still working in my snake class and what i want to do is to create a new method that i call move snake it doesn't need any parameters and in here we are going to move our snake and the first thing i want to do is to create a copy of our body and this i can just do with self.body and then using slicing so right now this would copy our entire list but we don't want to copy the entire thing we only want to have the first two elements so we are going to go from the first element to the one element before the last so this list right now would only give us these two elements so this element here at the end would just disappear which is exactly what we want because we want to move the snake forward and then to this list i want to insert another element right at the beginning and this is going to be our head that we are moving so this has to be at index 0 so it's right at the start of the list and the value it is going to have is the previously first item of our list plus a direction and this direction we are going to create from player input but for now it is just going to be a vector 2 that points to the right and let me just type it properly vector 2. let's say for now it's going to be 1 and 0 so it moves to the right so this is self.direction and this is really all we need for the basics of our snake movement so we copied the entire self the body list but removed the last item and then for the hat we're adding one more element right at the front that is going to be the first element of the previous list last the direction we want to go in and that way the entire snake is moving forward now for the last bit all we have to do is self.body is our body copy so that we are returning the entire list back to our body because this is the one we are going to draw and i don't want to change this entire thing again and really this is all we needed to move our snack in the most basic way but here's the problem now i don't want to execute this method all the time i only want to execute it at certain intervals in my case every 150 milliseconds so we need to create a timer and timers in pygame work within the event loop so this part here because this event loop can look for different things right now we only look for one specific event that we are closing the game but there could be lots of other events and in a bit we are going to add more events for player input but we could also add another event that is just a timer that triggers every few milliseconds and this we are doing in two lines of code the first one i am going to call screen update and this is going to be a variable that we don't want to change and this one is a pygame dot user event and let me just type it properly so this would be a custom event that we could trigger and how we triggered is by creating a timer and to create a timer we need pygame dot time dot set timer and in here we need our event so screen update and then how often we want to trigger it so my case 150 and this is in milliseconds so this event is going to be triggered every 150 milliseconds and then in the event loop we can capture it so if event dot type is equal to screen update then we want to do something and what i want to do is to get our snake and i called the method move snake so snake dot move snake and this is all we needed so let's try this now and there we go we have a moving snake that moves to the right obviously right now we can't control it so it's not particularly useful but it is working so with that covered let's actually work on keyboard input and this still happens in the event loop so we can just keep on working in here so again if event dot type and this time we look for pygame dot key down so this is going to be triggered whenever we press any button on the keyboard but we want to check for specific keys so we have to look for if event dot key is equal to let's say in this case pygame dot k up and this pygame dot k up would be the up key on your keyboard so when we press this then we want to do something and what we want to do is to get our snack again and what i want to change is the direction so right now our direction is going to be one and zero so we're moving to the right but if i press up this should be back door two and we don't want to move to the right and we move up so minus one so now if we run the game we are still moving to the right but if i press up we start to move upwards so this is working quite well and now all we have to do is to copy this line a couple of times for each direction we want to go in and this could actually be a really good exercise for you to understand vectors so if you want to code the long pause the video now and try to add three more if statements go left down and right let's do it together now so i want to take this entire thing and just copy it a couple of times and the first one let's go with right this one is going to be one and zero then let's go now with down and down it's just y equals one and then finally we wanna go to the left and left is going to be minus one and zero and that is pretty much it so let's try the entire thing now and let's see how this works so we can still run around and this is working really well obviously right now i can go over our fruit and nothing is going to happen but this we are going to cover in the next part which is going to come now actually so now we have a snack that can be moved around and we have a fruit on the field now let's try to bring them together and for that i'm going to create a third class that i called main and this one is going to actually contain the logic of our code which is going to make it much easier to maintain where things are going to be and i think this is best explained by implementing it straight away so let's jump right into our code and let's implement it so here we're back in our code and let me minimize the snake and the fruit so we have a bit more space and i want to create another class that i called main and when we initiate it i want this main to have our snake and this is literally creating the snake object and then also the same for our fruit so that whenever we are creating an object from this class we are also creating two more objects from these two classes here so that the entire game can happen inside of this one class and then this main class is going to have a couple of methods to maintain the game the first one i called update and what's going to happen in here is that we are moving the snake so i copy this one from the event loop and place it in here and i can also get rid of these two objects because we don't need them anymore and instead for all of this i'm going to create our main game and this is going to get main and then in the event update i call main game dot update so we don't actually change our game but now whenever we call screen at update so this event here we are calling maingame.update and maingame.update moves the snake and there's one more change we have to make this has to be self.snake so we are targeting this one so the snake itself remains unchanged just how we trigger it is going to be slightly different and then i'm also going to do the same for raw elements so all the stuff that we want to draw is going to happen inside of this method so right now we draw our snake and our fruit in the main game loop but i want both of these to be in here so that all of this happens inside of our main class so in our actual game loop we can just call maingame dot draw elements and this is quite a good practice that you want to keep this main game loop as clean as possible okay let's actually try to see if this still works and it does not because name our snack is not defined when we are calling our directions because we have to change this one here to main game dot snake and then it should be working so let me copy all of these and let's try it again now and there we go nothing much changed so far and you don't necessarily have to do this kind of step but it is going to make it much easier to organize your game okay so all of this is still working and a really nice advantage we have right now is that both of the snake and the fruit are in the same class so we can check where they are in relation to each other so for example if the head of our snake is on top of the fruit we want to do something with the fruit and with the snake and let's actually do that so i'm going to create a new method that i called check collision it's not actually a collision they just happen to be on the same spot and what i want to check in here is if self dot fruit dot position so this vector here if that is identical to self.snare dot body and the first element so this is going to be the head of our snake and this is our fruit position and if they are in the same position our snake is eating the fruit so then we want to do certain thing and for now let's just test if this is working so i want to print snack and let's try to run the code and nothing is happening because i forgot to call this method so in our update method i want to call self dot check collision and now let's try this and there we go we can go over the fruit and we print a statement so we know this if statement is working so that's quite nice and there are two things i want to do when our snake is colliding with the fruit number one is i want to reposition the fruit so that it's ending up in a new position and then besides that i want to add another block to the snake which is the main point of the game that you make the snake as long as possible and let's start with the fruit that one's the easier part so i want to target our self.fruit and then i want to add a new method that i call the randomize so let's create this one so let me close the main one for now and all the randomized method has to do is to create new random numbers in here so pretty much literally the same lines of code so i can just copy all of them create a new method that i call random mice and just copy these three lines of code because they create a random position and place the element there and i can just call self.randomize and that's all we needed to move the fruit so let's try this so it's still working and we get a new position for our fruit and let's try it again and there we go this works really well last one there we go cool so this is the first part that we want to reposition our fruit so this one's done now we come to the second part adding another block to our snake and this one is also actually super easy so again we want to target our snake and i want to add a new method that is called add block so let's create this method so let me close mine again and open snake and now let's create add block and now we have to think about what we are going to do because doing this is actually super easy but you do have to think about what you are going to do and ultimately it goes back to these three lines of code and specifically this line here that right now we copy our self.body list and take every element except the last one so that we are moving the entire snake forwards but if we want to add a block to the snake all we have to do is to remove this one and take the entire body and we are still going to add a new position at the front so we are extending the snake but this is really all we have to do for the change so let me revert this back and how i implemented this is i created a new attribute that is called self dot new block and by default it is false and what add block does is it changes self dot new block to true and if self taught new block is true so in our move snake if self dot add block is true so let's just type it in full then i want to copy the entire block and not delete anything and if that is not the case i just want to move the entire snake without adding anything towards it and that is pretty much it so let's try it and there's one more thing i do have to add so oh i realized there's a typo this is an app lock this is new block if this one is true so now let's try it and now when we pick up something our snake is going to extend for all eternity which i guess is a little bit funny but not the intended thing we want to achieve and the reason why this happens is because this log through stays true so once we are colliding with the fruit it is always going to extend which we don't want but we can fix it super easily by changing self.new block to false and now let's try it again so now our snake every time we collect the fruit is going to get a tiny bit longer and this seems to be working really well so this already is a really basic snake game and well takes no time at all to create it and with that we have our basic logic but the problem right now is that our snake cannot die so let's work on that and there are two conditions that could lead our player to fail number one is that the snake hits itself or that the snake hits any of the screen walls so effectively we have to add two if statements so let's start working on it so here i'm back in my code and i want to work in our main class function and i want to create a new method that i call check bail doesn't need any parameters and in here we want to check if snake is outside of the screen and check if snake hits itself and let's start with the first one that we want to check if the snake is outside of the screen and this is actually going to be super easy to check effectively all i want to do is if the snake is between 0 and the number of our cells so in this case 20 and if that is not the case then we want to go to the game over screen and we only have to check this for the head of our snake because the rest of the body always follows the head so only the head really matters when we check for game over but let's implement this so i want to check if not 0 is smaller or equal then our self dot snake dot body zero and this is smaller or equal than cell number so there's quite a few things going on right now so let me talk through it self.snack.body is the body of our snake and 0 is going to be our head so let me open it right now this would be this element here at position 5 and 10. and we want to check if this is outside of the field so if it is not between zero and the number of cells and there's one thing i forgot this one here is a vector and we can't compare vector to one single number so we have to check this for x so that we only check left and right and we are going to add the top and the bottom in just a second but for now if that is the case we want to do something so let me create a new method that i call dot game over so def dot game over and at least for now if our game is over i just want to quit the entire thing so i copied these two lines and paste them in here but we are going to change this later on in our update method we actually have to call it so self dot check fail so in theory right now if our snake is too far to the left or too far to the right it should fail so let's try and let's just go to the right and the game is over cool but there's one bug right now that this cell number at the highest point would be 20 but our cell furthest to the right is cell 19 so we could in theory go one field outside of the game which i don't want so i just removed the is equal to and we have to be smaller than this number so now if i try this again our snake or game fails whenever we hit the right wall so that's perfect but now the problem is that this is only going to work for left and right so we have to improve this if condition to also check for the top and the bottom of the screen and this could again be your challenge so pause the video now and try to do this yourself so really all we have to do is to add an or statement and copy the entire thing and then change it to y so we are going to check if the head of our snake is not too far to the left or to the right or if it's not too far up or down and this is really all we have to do so let's try all of this now and let me try to go game over from the top of the screen and this is working cool so now we have the condition to check if the snake has hit any of the walls so with that covered we can check if it hit itself and really what this means is we want to check if the head of the snake has collided with any other part of the snake so i'm going to start by cycling for every single block of the snake except for the head so for block in self.snake and i only want to go from the element with the index 0 all the way to the end so we don't take the entire snake we only take all the elements that come after the head and in here i want to have an if statement that if any of these blocks is equal to self.snake0 and if that is the case we go back to game over and this would be the proper logic although i did just realize i made a typo this should be snake.body and same for this one snake.body because snake is the actual object we created and body is the actual part that contains all of the blocks and while we add it i also realized i made another mistake and let me go all the way to the top to explain what i did wrong so when we are creating our snake it is moving to the right so the vector is one and zero however the problem now is that our snake is actually facing to the left not to the right as i initially intended it and you can see this quite easily that the very first item is this point here at position 5 and 10. so in theory this should be the point furthest to the right but it's not because the second and the third item have greater x values so this one is to the right of this one and this one is to the right of both of these which basically means that the head of our snake is to the left of the body of the snake and since we are moving the head of the snake to the right it is going to move inside of itself so we do have to fix this and sorry about that but there are two ways of fixing this it's really easy to do number one you could either move the head by default to negative one so that we are moving the head of the snake to the left and all would be good but i don't really like that because it's too close to the wall and instead what we can do is change these two vectors to four and three on the x positions so that they are to the left of the head and with that covered let me go back down to our check fail logic and let's try this and the snake is still going to move that seems to be working quite well and let me pick up a couple of items so i can actually move them to myself and yeah it seems to work so cool now we know this is going to work and this is the basic check fail logic however there's one problem right now and let me run the game again now the snake is moving to the right and i could just destroy myself by clicking to the left and the problem here is all of this code here that we could always change direction let's say going up even if we are going down so that we have to add some code here that our snake cannot reverse itself because then we would instantly destroy ourselves and this can very easily be done with just adding another if statement so right now we check if event key is the up key and now i want to check if maingame dot snake dot direction dot y is different than one and only if that is the case we want to execute this line of code and let me explain what this means so when we're pressing the up key we want to go up however if we are moving downwards this is not supposed to work because then we would fail immediately so we want to check if our current direction in the y direction so this part here is anything but one because if it's one we're moving downwards so only if it's different from one then we can actually do this line of code here and this line of code we just have to copy a couple of times and change it for the different directions so for right it would be x and 1 so that if we are going to the right we cannot currently go left that just wouldn't make sense we would just reverse immediately then for down we would again look at y but it would have to be minus one minus one and then finally to go left then we again have to look at x and we can only go to the left if our snake currently is not going in the right direction and all right this is basically all we need so let's try it now and now i'm moving to the left and i can't reverse direction you can't really see it but it does work and we can still pick up all the other elements so all of this is working so nice and i can still get game over from moving into a wall so with that we have created a really basic snake game so this one is going really well but it really doesn't look all that good and also we can't tell a score so this is the stuff we are going to start working on now that we are going to start making this game a lot prettier and this is going to involve quite a bit more code but ultimately it's a really good practice to learn how to use if statements and the enumerate method but let's start with really simple one that i just want to display a proper fruit instead of just a rectangle and let's jump right into the code i think that's going to be the easiest way to approach this topic so here we are back in our code and the very first thing i want to do is to actually import an image of our apple and i'm going to do this where i initiated all the other elements and i want to import an apple and to import an image we need igame.image.load and then the file direction and this has to be a string and in my case i have a folder called graphics and in this folder there's an image called apple.png and here again this is only going to work if your code is in the same folder as this graphics folder so make sure you have them in the right place and then also i want to convert alpha this image so pygame can work with it easier so all that this method does is it takes this image here and it converts it to a format that pygame can work with easier so our game can run better but okay this is all we needed for the apple so now when we have our fruit class we can instead of drawing a rectangle we can draw an apple so let me comment this line out because we don't need it anymore but we are still going to need the rectangle so keep that one and really all we have to do is to use screen dot blit and now we need a surface and a rectangle our surface is going to be this apple here that whenever we import an image into pygame it is going to be on its own surface so we can just add apple in here and after that we need a rectangle or at least some kind of position and we also have that it's just this fruit rectangle so i just type in through direct and this is literally all we needed it's surprisingly simple so let's try it off this now and see if it works and yeah it does we have an apple and it still works with randomizing and all of this works super well and there we go so this already covers our entire fruit class now i can close it and we never need to open it again and with that part covered we can actually put the graphics on for our snake and this is going to be the most complex part of this entire tutorial but in general terms here's what we are going to do we are going to go for every single block in our self.snackdoll body and look at how each block relates to the block before and after itself and from this relation we can tell what kind of block to put in this place so effectively we are going to create a really long if statement that checks a huge range of different factors and i think this is really best explained while actually doing it so here we are back in our code and the very first thing i have to do is to actually import all the images we need for the snake and this is going to look very similar compared to this apple import except now we are going to import quite a few more and since we only jump for the snack itself i'm going to do this in the snake class when we are initiating it and in here i already have all of the lines ready and let me paste them in so this is quite a few different graphics that are being imported we have all the possible head positions all the possible tail positions then a vertical and a horizontal body and finally all the curved body parts so in total 14 different images and these are all the possible graphics that could be used for our snake and now that we have all the graphics we just have to figure out where to put them in our game and this is going to happen in our draw snake function so let me close everything else and let me give some space so we can focus on this part and first of all this part that we used to have we don't need any more so i'm just going to comment it out actually let me get rid of it entirely so we need all the space we can get and here let me go through it really slowly the first thing we want to do is we want to look at all the blocks in our snake body so we want to look at for block in self dot body but this by itself would not be enough because we want to look at more things we don't just want to look at the block itself we also want to look at the blocked accounts before and the block that comes after and for that we are going to need the enumerate method and what enumerate does is that it gives us an index on what object we are inside of our list so we have to type in index and then block so index is the index we're on and block is the actual object that we are going to look at so for example in our body right now we will get an index of 0 and then vector 2 would be our block and for the second entry this would be index 1 and the block would be the vector and this would allow us to access quite a few more blocks that are not the block itself so this one is really useful and in here we have to do lots of different things now and let me just write them out so number one is we still need a rect for the positioning so maybe i shouldn't have deleted the earlier one but we can just write it again so it doesn't matter too much and once we have that just to get started we want to figure out what direction is the face heading so in what ways are snake looking and this is going to be quite a bit larger so let's code until that point so let me start by creating direct again and this again is the same thing we have seen earlier where we literally just take the x and the y position from our block and from that we create a pygame direct object and it has an x position a y position and then we have cell size and cell size for the x and the y size so this is the same thing we have done earlier and this we still need this is what we use to actually place the image and get the position so this was the easy part now we have to think about how can we identify different parts of the snake so for example how can we tell which part is a hat and which part is a tail and for that the index is incredibly valuable because all we have to do is if index is equal to zero because index zero is always going to be the first element and our hat is always going to be our first element so this is all we needed so if that is the case we want just like for the fruit screen dot blit and in here we have to enter a surface and a rectangle we do have the rectangle that's our block rect and just to pick one of the hats so we have four different heads for each direction let's start with head right and if that is not the case so else at least for now we just want to do the same thing we have done earlier so pygame.draw.rect and i want screen and i forgot the color we had so let's just go with 150 100 and and then log rect so effectively what we are going to do is that we create a rectangle at the position where we need it and if this rectangle is the first no self.body list we are going to place the right facing head of our snake there and if that's not the case we just draw a plane rectangle and let's actually try this and i made a typo it's enumerate and now it gets blue so this looks much better so now let's try it again and there we go we have an incredibly weird looking graphic but we do have a graphic of a snake hat that kinda works so at least we're making some progress cool let's step in the right direction so this line here is kind of working but the problem we have right now that let's put in number three the snake head direction is not updating so what i want to achieve is that if we are moving upwards the snakehead is also looking upwards and we do have all the graphics to make this work but we do have to figure out how to select the right image and how i solve this is by putting all of the logic for this into its own method so i have self update head graphics and this is going to create a new self hat attribute and this is what we are going to use in the end so this method here effectively picks one of these four whichever is appropriate for the direction we are going so let's create that one so i go to def update add graphics and in itself and here's how this is going to work we are going to take the head of our snake so the first element in self.body and subtract it from the item that comes right before it and that way we get the relationship between the two or in more mathematical terms we are going to subtract one vector from the other and from the result we are going to get how they relate with each other so if one vector is above or below or to a left or to the right of the other and here again vectors are incredibly useful because we can just subtract from each other and understand how they relate to each other but okay i created a new variable that i called had relation terrible name but i could not think of something better and what i want to do is i want to go to self.body and get the second item so the one with the index one and let me just type it properly and from that i subtract our head so self.body zero so this is going to result in a new vector that could point in one of four directions and from this direction we're able to tell how the head relates to the block that comes before it and really all we have to do is if had relation is equal to vector 2 and let's start with the first one 1 and 0. so this would mean that those two combined end up with one and zero which means that our head is to the left of the next block so if that is the case self dot head is going to be self dot head left and since we have quite a few if statements i am going to keep them on the same line just to make it a bit more readable and now all we have to do is copy this thing a couple of times change this to l if statements and now update the different vectors so the easiest part would be changing this to minus one so then this one would be at dot right then if this is zero and this is one so this would mean there's a block below the head of our snake so our snake is looking up and then for the final one by the process of elimination the snake has to be looking down and that's basically it so let's see if i get this right and let's try it now and yeah there we go our snakehead is updating quite nicely so this is quite a good start okay so this would cover the head of our snake so i can close this method and not look at it again and now we come back to our if statement and let me get rid of this part here because we fixed that bit so now we have the head of our snake now the next easy bit or easyish bit is to get the tail end so the last block that we want to cover and this we can also address really easily because this part is always going to be the last one so we can use l if index is equal to last item in self.body so we have to figure out some code to get the last item in this self.body list and well all we need is the length of our self.body so this is all the items in there and then 1 because we start counting from zero and with that we always get the last item so if we have that we can do the same thing we have done for the head so screen dot blit and this time it's self.tail and we still need our block rect and self.tail does not exist yet but we do have if i open our knit method again we have all the different directions for the tail so i am effectively going to copy the method we used for the head this one and create the same one for the tail so let me close all of this and create self dot update tail graphics and again if you want to code along this could be a nice exercise so look at the update head graphic and try to figure out the logic for the tail but okay pause the video now if you want to go to long and i'm going to continue myself in a couple of seconds okay welcome back let's try to do it together now so i want to create a new method dev update tail graphics and just to save me some writing i'm going to copy the entire line for the head and just paste it in here and now it's going to be tail relation and now we don't want to look at the second and the first element instead we want to look at the last element and the element that comes before the last one so we know our last one is minus one and then the one before is minus two so this one is quite easy to start and then i have to change all of the tail relation l if statements and also change all of this to tail might have benefited from naming my variables better but never mind okay here we go so this would actually almost work so let me try and i forgot one equal sign let's try it again now there we go and there we go we have a nicely functioning tail cool so that was surprisingly easy actually so the same logic that we used for the hat we can use for the tail so now we have covered the tail with that we can start working on the actual body or the rest of the body and this is all going to end up in an else statement and in here it is starting to become important to figure out what is the next and the previous block so i want to know what is my previous block and what is my next lock and we know the block we're on right now that's just block so in here the index again is going to be incredibly useful because all we have to do is self dot body and then index plus one minus log and then for the next block we have to do the same thing except we subtract index minus one so just to explain what happens here we are indexing from self.body and index is going to be our current element and then we either add one or subtract one to get the next or the previous block which i think is quite straightforward and then from that we are going to subtract our current block to get the relation between the two and this is going to result in a new vector that again can point in one of four directions and from that we can tell what kind of block we need and now we can start with the horizontal or vertical body parts so these are going to be body parts that either are entirely horizontal or entirely vertical so i don't go around the corner at all and this is really easy to get because all we have to check is if previous block and next block have the same x or ycoordinates because if that is the case the block between these two blocks has to be either horizontal or vertical depending on if we look at x or y so let's implement this with another if statement and what i want to know is if previous block dot x is equal to next block dot x and if both of these have the same x coordinate we know it's going to be a vertical block so we can use screen dot blit and this is going to be self dot vertical and then block rect and let's try this oh right as a typo i have to get rid of yeah let's get rid of it entirely because it's just going to cause errors otherwise so now some parts of our snake we don't draw but i think that illustrates it even better what is missing so now we can see our snake is working when we're going up and down but if we're going left or right or around the corner things are missing but otherwise our snake is still working quite nicely so we are making quite decent progress looks actually quite funny but okay now i want to copy this entire if statement and now i just have to check the y parts and if those are identical we know our block is horizontal and i want to make this an alif statement so let's try this one now and we can see we have horizontal and a vertical body part for our snake we don't have any corners but that's going to come next besides that everything seems to be working quite nicely so we are making some decent progress so now we come to the most complicated part where we have to look at the corners of our snake and all of this is going to be inside of another else statement and let me explain the logic here to get this done and i think the best way to explain this is by using an example so let's say we want to create a corner where we go left and then up or we go down and right it's going to be the same corner and really all we have to do is to check the x and the y position of our previous and next block and we have the information to achieve all of this but you probably have to look over this a couple of times it is a little bit confusing but okay here we are back in our code and what i want to do is screen dot blit and i want to blend self dot body tl so this is top left so the corner is going up and left and again we need our block rect so we are now so we now have to figure out when to trigger this corner so all of this goes inside of an if statement a pretty long if statement actually so we want to check if previous block dot x is equal to 1 and next block dot y is also equal to 1 or we could start from the other way where our previous block dot y is equal to 1 and next block dot x is equal to minus one and let's try this one so top left there you can see it we have one corner and we can also go bottom right and this would still be working bottom left i mean sorry and there we go we have our first corner and now all we have to do is to copy this if statement a couple of times and change our attributes and of course the image we're actually blitting so i would have bottom left i would have top right and then the remaining one would be bottom right and the coordinates would be previous block x minus one and next block should be one and then previous block would be one for y and the x would be minus one then we have four top right the previous block x would be one and next block y would be minus one or alternatively we would have the y part would be minus one and next block would just be one and for the final one we would have one and one and same for the other way around as well okay and those are all the bits let's actually try this together and this looks pretty good okay cool so this is actually drawing graphics quite efficiently and works even if we go really close to each other and looks quite clean okay and all of this is probably quite confusing and honestly when i figured this out i went by trial and error thinking about all of this gave me a headache so if this doesn't make full sense don't worry about it it really is kind of annoying to think about but really all we are doing is we look at our previous block and our next block and how they relate to our current block and from that we can tell what kind of corner we need but granted it does get quite confusing but okay with all of that one done i can get rid of the comments and we have our basic snake and we created an el if statement that covers basically an entire page cool always feels good so now i can close drawing snake and not worry about this for a while and for the next part i want to update the grass so it starts to look a little bit nicer and let's actually jump right in i think that's going to be the easiest way to approach this so here we are back in our code and in our class main i want to create a new method that i call define raw grass and this one well it draws the grass so we have a checkerboard style grass pattern on our field to make it look a bit more interesting and to achieve this kind of effect all we really have to do is cycle through each of the line and draw a slightly darker green rectangle if we have an odd or an even number so to start this off i'm going to create just to save me some writing later on a grass color variable and this is just going to be an rgb tuple with 167 209 and 61. so this is a dark greenish color and now we have to cycle through every single cell on our field and either draw a darker rectangle or not draw a darker rectangle and to start this one off simple let me just start with the first line this one is going to make it quite a bit easier so i want to start with for column in range cell number so this would cover the horizontal axis of our entire field and for each of those i want to create a new grass rectangle and this is just going to be a pie game wrecked object and here we need an x a y a width and a height just as we have always used and with and hive again is just going to be cell size the one we have always used i almost regret not naming this with a shorter name but okay now we need two more pieces of information the first one is y and for now this is just going to be zero because we want to work with the first row but we are going to change this later on so now we are going to need our x coordinate and we could just start with this call so our column multiplied by cell size so this would give us a rectangle and now we can just draw it with pygame.draw.direct and i think by now you should know it so this is screen the service want to draw on then the color it's already predefined and then our grass rect so this right now would cover the entire first line of our field and let's actually illustrate this so when we come to draw elements below all the other elements i want self dot draw press and let's try this and you can see the very first line of our field is slightly darker so we do manage to draw at least a little bit but well it's not great yet so we have to make some more changes and the first change i want to do is that i only want to draw every second field not every field and you could approach this in two different ways you could either draw all the fields that start with an even number or all the fields that start with an odd number which one you go for it doesn't really matter but really all this is is if call mod 2 gets us a 0 only then do we want to draw all of this and let's try this and now we can see we have only every second field working for this so this is already working quite nicely so now we have to do this thing for every second line in our field so what i want to do is to go for row in range cell number so we go for every single row in our field and now we are going to do this operation again except for the row not for the column so we want to only draw this kind of row if the row starts on an even number so if rho divided by two is equal to zero and if i run this oh forgot the if statement so if row and i have to indent everything as well try now ah and this doesn't work right now because we are still starting at position zero so we have to make an update to this one so right now we are drawing this multiple times but we always start at position zero so they're all drawn on top of each other but all we have to replace it with is our row multiplied by our cell size and let's try this one now and there we go this is starting to look much nicer and now we have at least every second row working properly and everything still works okay so now all we have to do is if this is not the case so we go for an else statement then we want to do this entire thing again and let me copy it properly except now we want to check all the odd fields and this is working so this is looking at least a bit more interesting and there really isn't all that much left to go for for a proper game the two more things i want to add is a score and a sound effect and let's start with the score and to get a score we need some text and text and pie game needs a couple of steps to work so let's talk through them ultimately there are three steps we have to be aware of number one is that we have to create a font object and this one is going to determine what our text looks like and how large it is then we have to use this font to render some text and this is actually creating some text so for all practical purposes we are writing something and this text is going to end up on a new surface exactly like the pictures we have imported so far and then for the final step we have to blit the image on our actual game screen and that is pretty much it so let's start creating the basic score and once we have that we can make it look nicer so here we are back in the game code and the first thing i want to do in our main setup part i want to create a new font and i call this game font and to create a font we need pygame dot font dot bond and to make sure the second font has to start with an uppercase letter this one is important and in here we need two pieces of information the first one is the font we want to use and then font size font size is the easier part this one is just an integer i went with 25 and for the font we could just go with none and then we get a default font for pygame but i want to import a font and for that i need to give the name of the font i want to use and this has to be a ttf file that i downloaded earlier and you can get a ttf file really easily from websites like daffon.com for example and there are plenty of free ones just check it out but in my case the file is located in the folder called font and the name of the file is poets 1 dash regular dot etf and with that we have imported a font so our text is going to look like whatever this one looks like and the size is going to be 25 so these are the two basic things we have to start with and now in our main class i want to create a new method and let me minimize all the other methods i have so far just to make it a bit easier to see what's going on there really is quite a bit of stuff going on by now i want to create a new method that is called draw score does not need any parameters and in here we have to create our score and there are quite a few bits of information we first need to draw all of this the first one is the actual score text so we have to figure out what is our actual score and put this into a text and the basic logic i went with is that the length of our self.snake.body is going to be our score so the longer our snake is the higher of a score we get so this will be the basic part that determines our score but we are starting with three blocks inside of our snake so i have to reduce this by three so that we start with zero but then all of this has to be a string so that we can display it easier so i put it in the str method that works very similar compared to the end method except now it turns any kind of value inside of this into a string instead of an integer and with that we are getting our basic score so this is a good way to start and with that i can create the actual score and this would be a score surface so let me write it properly and to create this we first need our game font so what we created down here and we want to render it and in here we need three pieces of information the first one is the text then if you want to end the alias it and then we need a color and let me talk for them step by step the first one for our text is just going to be our score text so what we created up here and for the color i am just going to go with an rgb tuple again which this time is 56 74 and 12 which is a fairly dark color that has slightly more green than the other values finally we need the antialias text and this one either has to be true or false and antialiasing just means we make the text a bit smoother and unless you're working with pixel art or you work on a really slow computer this is usually best left for true and it makes our text look a bit nicer but ultimately this really isn't going to make that much of a difference especially for a simple game like ours so i just leave it with true alright now we have a text surface that we just have to put on the screen so this is going to go with screen dot blit and now we do have a score surface but now we need to get a position of this text and here we have to determine where we want to put it on our screen and i want to put it in the bottom right ish of our game and to get it there i'm going to add a few more variables just to make it easier to read so i create a scorex variable that is again going to be an integer of cell size times cell number so this would be the right end of the screen and from that i want to remove a couple of pixels so i removed 60 from there meaning that we go all the way to the right of the screen and then go a bit further to the left so we are in the right end of the screen and then i'm going to do the same thing for y that again i want to go all the way down to the bottom of the screen but now i want to go a bit up again so let's make this a bit less 240 and from these two bits of information we can create a score rectangle and here i want to get our score surface and get the rectangle around it so when we create this score surface with some text it has some dimensions and with get rekt we can access all of them and even better we can immediately place this rectangle somewhere on the screen and right now i'm placing the center and what we pass in here is an x and a y position where we want to place it and for this we can use these two bits of information so this would be our score x and score y and now that we have a rectangle we can just place this into the position for our screen dot blit and this is pretty much all we need for the score so now when we come to draw elements i want also to draw a score so self dot draw score and let's see if this is working and it is not because i made a typo this should be poet sen 1 so now let's try this again and there we go in the bottom right of our screen we can see a number and every time we pick up an apple this one goes up and let's try one more and this seems to be working quite well cool so with this bit of code we get our score but by itself the score looks a bit bland so i want to add two things to it number one i want to add an apple to the left of it and number two below the score i want to add a plain rectangle so that it stands out a bit more from the background and both of these are quite easy to get so let's add them now so what we ultimately want to achieve is screen dot blit again and this time we want to use our apple again the one we imported down here and then again we need a position for the apple so we have to write some code for this position and the position is supposed to be at this apple is slightly to the left of our score so we have to use our current existing score and place the apple to the right of it which fortunately we can do quite easily and i think to make our code a bit easier i'm gonna put the two screened up blitz together and then all the setup part goes into one big chunk of code that should make it a bit easier to see okay what i want to do is apple rect to get the position and this is going to be our apple and get wrecked again and for this rectangle we don't want to place the center instead we want to place the mid right and where the midright is supposed to be is on the left of this apple here so for the x i want score correct dot left and for the y i want scorect dot center y and that's basically all we needed so now when we blit the apple we need apple and apple rect and let's try and there we go we have an apple next to our score and let me explain what happens here so on the score we place the center of our rectangle on these positions that are roughly in the bottom right of the screen but when we create our apple rectangle we take the mid right point of this rectangle we place it on the left of our score rectangle and the y position is going to be the middle of the score rack so what we effectively do is that we place the upper right on the same height as the score rack and the x position is going to be slightly to the left and with that we have the two basic points the only thing left to do is to create a slight background so that both of these stand out a bit more although i think by itself you could even leave it like that but um it's up to you doesn't look too bad right now so i want to create a bg rectangle for the background and this is going to be a pie game dot wrecked object and in here we need an x position a y position a width and a height so let's go through all of these step by step so our rectangle is supposed to start at the top left of our apple and these are points we can get very easily so i want apple rect dot left and for the y apple wrecked dot top so that our background starts at the top left of our apple and the height is the next easiest part because all we want is the upper rect dot height so our rectangle starts at the top left of the apple and takes the entire height of the apple for the simple reason that the apple is larger than the text so if we cover the entire apple we also cover the text as well so now we need the width and for the width we want to cover both the apple and the text so this is going to be our apple right dot with plus score rect dot with and this should cover the entire rectangle so once we have that i want to use pygame.draw.rect draw on the screen the color i want to go with is 164 209 and 61 so the dark grass color and i want to draw our bg rectangle and let's try this so if you look very closely you can see it especially if i go below it there you can definitely see it so this is working but it's very hard to see so what i am going to do is to draw a frame around this box and drawing a frame around the box is very easy to do in pie game so let me copy the first rectangle and all we have to do to draw a frame around it is to add another argument so in my case this would be two but the problem here right now would be that we have a rectangle with one color and the frame around it has the same color so we couldn't really see the frame and to fix that i'm just going to copy the text color and let's try this now so now this looks much better and now you can see that the box is a little bit too narrow so that the number is too far to the right and it touches the frame which doesn't look good so we have to make it slightly larger this is the width argument and all i want to do is to make this slightly larger so i'm going to add plus let's try six and let's try now and yeah this looks much better now it's roughly in the middle and there we go this is working pretty well so with that part covered we have a score and now we can work on adding some sounds to our game and adding sound in pie game is actually super easy but there's one thing you do have to be aware of that is a little bit annoying but i think it's best to jump right into our code and let's add the sound and then we can talk about the problems with sound and pygame and i only want to add a single sound that when our snake collides with fruit then we want to play a crunchy sound and we could add more sounds like a background music or game over sound but if you can get one sound you can get all of them and i don't want to over complicate things so we are just going to stick with a single sound and let's do all of this so here we are back in our code and i want to import our sound to our snake because that's the only place where we actually going to need it so right in the indent method that gets really extensive by now i want to add a new attribute that i call crunch sound and to import a sound we need pygame dot mixer dot sound and here again this sound has to start with an uppercase letter otherwise it's not going to work and now we need the file name and in my case i have a folder called sound and in there there's a file called crunch.wav and with that we have imported a sound so that's the first step we need and then for the snake i want to create a new method and let me minimize all of the other methods so this is a bit easier to see what we are doing okay so all the way down in this method i want to create a new method that's called play brunch sound and this only needs a single line of code we want self.crunch sound dot play and so now whenever we execute this method we are going to play the crunch sound and let me close the entire thing again and now in our main class when we get to check collision we also want to play this sound so self dot snake dot lay crunch sound and let's actually try this so this seems to be working but the problem we have right now is that the sound has a slight delay so that it doesn't play right when we eat the fruit instead it plays about half a second later which can be really weird the reason is that pie game first buffers a sound before it plays it and this creates a short delay between the chord being triggered and the sound playing but we can fix that quite easily so let me close our main class and what we have to do is work with pygame.init at least a tiny bit and in pygame.init there's a method called mixer and mixer is responsible for all the sounds and what we want to do is pygame.mixer.3 init and in here there are quite a few arguments you could pass into it and it can get quite technical but i have found four numbers that work really well so these four give you a good sound and play the sound immediately but if you want to know more about sound in pi game there's the documentation that gives you a lot more detail so i would just copy the numbers and don't worry too much about it but let's try it with these numbers and we are getting a sound immediately so this is now working and with that we are nearly done there's one more thing i do want to cover though that i forgot to check earlier that let me go back to our main when we check collisions and we create a new fruit on the field there is a very small chance that our fruit lands on the body of our snake which would be very confusing so we have to add a little bit of extra code here that if the fruit is on the rest of the body of the snake we want to randomize it again so really all that we want to do is for block in self.snake.body and here we don't want to check for the hat so this would be from one all the way to the end with index 0 being the head and everything else being the body and this is what we want to check and really what we want to check is if block is equal to self dot fruit dot pause and if that is the case we just want self dot root dot mice so really odd it is happening here is that we are checking every single block of our self that's negative body and check if it happens to be on the same position as the fruit and if that happens we want to put the fruit in a different place and that way we ensure that our fruit is never on top of the snake body and this is quite difficult to show because well it depends on a lot of random chance and ideally it's something we want to avoid happening but with all of that covered we have created a pretty nice snake game and there's one final thing i do want to change that whenever we die the game just ends which isn't ideal and really all i want to do is that if our player fails i want to put the snake back in the default position so we don't really have a game over menu instead we just restart the game immediately but you could be adding all the menus you wanted but i think in this case it doesn't really make sense but let's actually implement this so we have to go to our game over and see what happens in here right now we are just ending the game which well isn't great instead i want to get self.snake.reset so this method doesn't exist right now so we have to create it and let's close our main class and go back to the snake and here we really start to have quite a bit of stuff in there but let's add one more it's going to be the final one and i called this reset and what is supposed to happen here is that we take our initial self.body and just recreate the basic points so really we just take ourselves the body where we started and that is literally all we are to do and we don't even have to update the score because the score just checks how long this list is so we don't really have to do anything so let me try this now and our game still starts the score also works and now let me fail and we move back to the starting position so this is quite well let's try it again and yep it works quite well so most of the game is done there's one last thing that is a little bit annoying and let me illustrate this so right now our direction is downwards and we start again our snake goes downwards again so when we restart the game we also have to change the starting direction so all we have to do is go back all the way to the top and change this value and actually all we have to do is to change this to zero and zero and then let me copy the entire line and further down for the reset method i also want to set the direction back to 0 and 0 when we reset the snake and let's try this so if i don't press anything the snake isn't moving if i press something we are starting to move and i can pick up a couple of apples the score is working if i go game over our snake isn't moving again and only if i start pressing the button it is starting to work so all of this is working really well and well that is it for the entire game