in this tutorial we talk about objects and classes and well more specifically i will talk about what objects and classes are i will cover how to create and use them we will cover dunder methods and also simple and complex inheritance and finally i will cover how to use classes in practice and well let's get started by talking about what objects are in the first place and well an object is just a container for variables and function for example we could make a video game with lots of monsters and i think video games are really good way to explain objects so i will stick with that for this entire video but basically for the monster we are going to create we want to have variables and functions and in this case i want a monster to have some health some energy stamina and damage and you could add whatever else you want in here it's really up to you and then besides that the monster should also be able to attack to move to animate and again you could add whatever else you want in here and what you have to understand here is that these variables and functions only exist inside of this monster object it's very similar compared to the local scope of a function if we tried to get this health outside of the container it wouldn't exist because this health exists only inside of monster object although in terms of naming there's one minor complication and that is special names all that really means is that variables inside of an object are called attributes and functions in an object are called methods and that is more or less the only difference the only reason why this exists is so that we are a bit more specific with our language for example when you talk about health with somebody else for your game you really want to emphasize that you don't talk about a global variable you talk about the specific attribute of one object and one more thing methods should actually be familiar to you because you are using methods very very often in python anyway for example when you call the upper method on any kind of string you are turning every letter inside of that string to an uppercase letter and that is also a method and that is the same kind of method we are seeing here essentially a string in python is just another object with functions inside of it or methods to be more specific this also applies to integers floating point numbers booleans all of that stuff is basically just other kinds of objects that python creates but that's something we don't have to worry about for now now another thing that is really important to understand is that it is possible to have multiple objects for example i could create three different monsters and each of these monsters could have customized attributes these red pieces of text here so my first monster has 90 health 20 energy the next monster has 60 and 40 and the final monster has 40 and 10. so when you create an object you can give it custom attributes however this does not apply to methods and as you can see here monster 1 monster 2 and monster 3 all have the same methods and these can be customized to an extent but not nearly as much as the attributes that's something you do want to keep in mind but still each object has its own attributes and methods meaning that this attack here and this attack are not the same function or well the same method they always apply to their respective object and what you can also do is have objects interact with each other for example if monster3 attacks one stat 2 we could run some code to reduce the health of monster 2 from 60 to let's say 20. and that actually brings us to a really important topic and that is object oriented programming or oop in short and all that really means is that you are organizing your code via different objects and then you make these objects interact with each other and this approach is basically how almost all large projects are made in any programming language or at the very least any modern programming language meaning if you don't understand classes you will be very much lost and well you will have no idea what you see when you look at larger examples of code here we have a couple more objects we still have monster 1 and monster 2 but now we also have a player we have an obstacle and we have a menu and all of these have slightly different attributes and slightly different methods and just to talk about how these different objects can interact with each other the one we have already seen is that monster 2 could for example attack monster 1 and then monster 1's health be reduced from 90 to 60. and if monster 2 is attacking it might reduce its own energy from 40 to 20. so attacking isn't free for the monster what we can also do is have an object without any methods like the obstacle here and all the obstacle is is well an object with a position and a size and this we could use for example with the move method of any of the other classes so the player and the monsters all have a move method and this could interact with the obstacle and let me clean this up something even more interesting if you look at the player this one here and the menu those two do look very much connected because the player has one method called menu and what this one would do is to create or at the very least open a menu and then when we create the menu we are passing in the player itself so this player here is going to be passed in as one attribute of the menu object and this is totally fine to do you can totally add a function or an object inside of another object as an attribute and then this select could for example change the weapon of the player and we could close the menu as well and i hope this makes sense the main thing you have to understand is that objects can interact with each other and this is how you want to organize code it makes it very easy to work with and especially for larger bits of code this approach is essentially mandatory or at the very least it's the easiest way to organize it and let's actually do a practical example here is a zeldalike game that i made a while ago and basically everything you see on the screen is an object for example right in the middle we have the player and that's one object then we also have this raccoon here and this spirit and each of those are one object and beyond that each of these flames here is its own object and these are only created when the player is attacking with some magic and finally in the top left the bottom left and the bottom right you can see some ui elements and they are all part of the same object and this object is very much related to the player so those two work together very closely and besides that each of these pillars and trees and rocks and statues they are all objects that i created just for this game so i hope that illustrates how useful objects are that make it really easy to group together code chunks that should belong together and for a bit more detail the raccoon for example has three attributes health speed and damage and the methods attack and move and all the other objects would have similar attributes and methods and with that we have objects now the next question is what are classes and this is fairly easy to explain as well the class is basically a blueprint for an object meaning whenever we create an object we first have to create a class and a class can also accept arguments to customize the object we are creating for example this would be a class we have a class and this class has two attributes health and energy and right now the value for both of these is not being set this we do when we actually use this class to create an object but this class also has two methods attack and move and those do not change and basically what we're doing is use this class to create the object and in the process we are giving it the specific values for health and energy so in this case the monster is going to have 90 health and 20 energy and this process we could do as many times as we want for example earlier you have seen monster 1 we had monster 2 monster 3 and we could continue with monster 4 5 up to an unlimited number of monsters and that is essentially the main idea all you really have to understand is that we always need a class to create an object now what we can also do with classes is that one class can inherit from another class and the resulting objects will have attributes and methods from both classes for example let's say we want to create a shark class and this one right now only has speed for the attribute and byte for the method and this class will be fairly limited because we well don't have any attribute for health or for energy and we also don't have any kind of method for move or attack but we don't need to because what we can do is have this shark class inherit from the monster class and this means this shark is going to get the health and the energy from the monster parent class and that is also going to get the attack and the move from this class as well meaning when we actually use the shark class to create a shark object we are going to get health energy and speed for the attributes and attack move and byte for the methods and i think i should use better colors here in the shark class health and energy are coming from the monster class same with attack and move those two are coming from the monster class and then speed and byte are from the shark class and this would allow us to reuse code quite extensively for example we could have a lot of different monsters we could have a shark some flying enemies some armored enemies lots more and they all inherit from this one monster class and with this approach we would save a ton of writing in terms of code and on top of that if we change the move method for example it would affect every single other class as well which is very useful if you want to make some changes and make it affect every single other class and especially with larger projects this is just about the only way to manage them and let's do an example again here is the screenshot from earlier and we have a monster class we have another monster class and those two have the same attributes and methods although with different values and besides that we also have the player and what is really important to understand here is that all of these inherit from the entity parent class and this for example contains the method for movement because all of the monsters and the player move in the same way so they could share this method quite easily and just to emphasize it i do want to go over the advantages of classes and objects and the first point here is that classes and objects help you organize complex code and the second point is related classes and objects also help you to create a reusable code and just from these two points i hope it becomes obvious that if you want to create some really large projects let's say a really good looking game you need objects and classes without them it's still possible but significantly more difficult besides that classes are also used everywhere meaning if you don't understand them you will be very much lost as a matter of fact in python there are quite a few modules that require you to use classes for example pygame tkinter and matplotlib respectively the module you use for games for gui's and for data analysis they all work with classes primarily so if you don't know how to use it you pretty much cannot use these modules or at least you could only use a very small part of them and there's one more point that i haven't mentioned yet and that is that classes make it much easier to work with scope i will talk about this in more detail later but if you struggled so far with getting information in and outside of functions you will really like classes that make it very easy to work with different levels of scope so these are the arguments where you would want to use classes and objects however you can write code without using objects at all and this is very common especially for beginners and let me illustrate the problem here the yellow line is the need for classes and especially when you start writing code let's say you are somewhere here and your average program is something like 50 lines of code in this case there really isn't any need for classes because well your code is very simple and there isn't any need to organize complexity however the longer and more complex your code is becoming the more you will need classes and this ramps up really really fast but as long as you are in this area here it well it's very tempting to never use a class and ignore them entirely and this especially as a beginner you really want to avoid so even though when you are here i would really recommend you to use classes even though it's not strictly necessary in your example just to practice for more complex code because when you are an actual software developer you are never going to write just 50 lines of code most of the programs you are going to work are somewhere here with a few thousand lines of code let's say 2000 and if you are up here and you don't use classes you are going to be in a lot of trouble all right with that we have the theory of objects and classes and for the next part we are actually going to create and use objects so let's have a look at some code here i have a completely empty sheet of code and the first way i want to do is to create a class and this you do with class and then the name of the class in my case i want to go with monster and here already we have to cover something important and that is the naming scheme so far in python what you probably have written is something like monster and generally you always used the snake case styling for any kind of text so why is this different here and well in python by convention last names are always written in the camel case so camelcase looks like this where you don't have any spaces between words or well any underscores but any word starts with an uppercase letter and this is different from normal python where variables are written in snake case where everything is lowercase and a space is an underscore and this isn't strictly necessary you can call a class monster with a lowercase m just fine this is purely convention but all the other python requirements for naming still apply for example a class couldn't start with a number and we also couldn't have a space in between so we don't have to learn any new naming scheme now next up what you have to do is a colon and now in here we can work on the attributes and methods of our class and for now i just want to create some basic attributes let's say i want to give this monster some health and for now i want to have specific numbers let's say 90 i want to have energy and this one should be 40. so now we have a class and what we have to do now is turn this class into an object and this we do by typing the name of the class and then calling it by using brackets again very similar compared to functions and this is going to return the object so we have to capture that in a variable and this very often is written like this and here i hope you can see why we have the different naming schemes to python this name here and this name here are two completely different things because one starts with a lowercase the other with an upper case although to us as the programmer we can tell that those two are related because they basically have the same name and for that reason we are usually writing class names in camel case and variable names in snake case it makes it very easy to connect these two and clearly indicate that they are connected although you don't have to do any of this you could totally call this i don't know hamster and this could be lowercase it's totally fine all of this is just convention although you should follow conventions they are there for a reason but i can run the code now and i am not getting an error that's a good sign and now what i can do i can use print and monster dot let's say health and now if i run this we are getting 90. and this knight here is coming from this health and the same would also work for energy in just the same way so we get 90 and 40. now just to emphasize that both this health and this energy only exist inside of this class let me print health by itself that is horrible spelling health and if i run this python is going to give me an error and we have name health is not defined meaning python cannot find this health anywhere in the global scope which makes sense because there is no health in the global scope we only have health in the scope of this monster class and let me add some comments here to make this a bit more readable we have attributes and besides that i also want to create methods and those work kind of like functions we again need the define keyword or def and now we need a name for our function and for that we have the exact same naming scheme for normal functions for example attack would be a perfectly fine name and after that you need a colon and then let's say for this attack method i want to keep it simple and just print the monster has attacked and now i can call monster.attack and don't forget the brackets and now if i run this we are getting an error and this error says that monster.attack takes zero position arguments but one was given and this is probably very confusing because when we called this method here we didn't pass anything inside of it and the method itself doesn't have any parameters so why is python being so weird here now the reason why this is happening is that whenever we call a method so a function inside of a class what is going to happen is that python automatically passes a reference to the class as the first argument into this function or this method to be more specific in this first argument we always have to capture with some kind of parameter meaning a method always needs at very least one parameter and that parameter is a reference to the class itself for example i could just write monster in here and if i run this now we get the monster has attacked and let me just print what we actually get so i want to print the monster we get as an argument in here and what we get is main monster object at somewhere in our memory and well in my case i don't really care about this monster so let me remove the print statement but i do have to keep this first parameter however once we have the first parameter i can add as many custom parameters as i want for example i could add the amount of damage here and i could let's say print the amount with an f string and i want to say the amount of damage was dealt and now when i call this method down here i can pass in any number i want and i get the monster as attacked 40 of damage was dealt that does not make sense in terms of grammar let's try this again but the damage was stilled that feels much better so the one thing you want to remember is that for any kind of method you always need a reference to the actual class as the first parameter but after that you don't have to worry about it anymore and you just use it like any other function however you could also use this reference to the class what you could be doing for example is print and let me just print monster.energy if i now print this i get 40 again meaning this monster energy here is looking at the first argument it gets and this is a reference to the class itself so from there we can get this energy and also this health if you really wanted to and what you could also do is increase this amount so monster.energy minus equal 20 and if i print it now we get 20. and i hope you can tell how useful this can be because if you imagine that this monster here is the global scope and these attributes are global variables if this attack was just a normal function then this would not work because you would be creating a local variable that wouldn't work with the global ones but because of this first argument that the method always gets we can influence variables or well attributes outside of this function which is incredibly useful so i hope this kind of method here makes sense as a matter of fact let's practice this one i want you guys to create another method for this monster and this one should be called move and it should accept one arguments besides the reference to the class itself and that is the speed of the movement and then inside of the method you should just print that the monster has moved at a certain speed it doesn't really matter what you put in here as long as it is working so try to figure this one out yourself all right let's try together now i want to create a method called move and in here i want to have speed as a parameter however what we have learned from the attack method is that we always need a reference to the class itself as the first parameter meaning the first parameter here should be something for the monster and it really doesn't matter what you call it so i could even write something in here it would still work and now in here i can print monster has moved and let me add another line with an f string that says it has a speed of and then the speed and let me fix the typo and now i can call monster dot move and add let's say a 10 in here and let me comment out monster.attack and let's see what we get the monster has moved it has a speed of 10. so all of this seems to be working just fine so all of this seems to be working very nicely now obviously calling this first parameter something is a bit confusing and as a consequence in python there is a convention that this first parameter is always called self and this applies to all of the methods meaning this is what you are going to see most of the time and what i am going to use as well you don't have to do it but i think it makes the most sense although i do want to emphasize that this parameter here and this parameter here have no relation whatsoever they are entirely separate although that being said they both reference this monster class here but it is totally fine to call self here and self here the names are not in conflict with each other and all right with that we have the very basics of using classes and objects although right now we do have a problem that our monster always has the same health and the same energy so even if we created multiple monsters so what i could be doing is monster 1 monster 2 monster 3 and let me get rid of this one here all of these monsters would have the same amount of health and the same amount of energy and they all have the same attack and move method which is fine to an extent but i do want them to have different amounts of health and different amounts of energy and to implement that we need another concept and that is called dunder methods so let's talk about that one let's talk about dunder methods and the dunder here just stands for double underscore meaning we are talking about a double underscore at the beginning and at the end of the method but it's important here we are still talking just about methods so essentially we are calling a specific kind of function and let's talk about why it's special a dunder method is just another method the thing that makes it special is that it is not called by the user instead it is called by python when something else is happening for example there is the dunder edit method and this one is called when the object is being created another example is the lan method and this one is called when the object is passed into the len function and besides that we also have done the apps and this one is called when we are passing the object into the apps function and that is really the entire idea it honestly isn't that complicated the most important dunder method you have to understand is done their init this one you are going to be calling all the time but let's actually do all of this in code that should make the most sense all right here we have the class i created earlier and what we have seen earlier as well i can create monster 1 and that is just going to be the monster and i can also have monster 2 and if i now print monster 1 dot health and monster 2 dot health we get the same number because we always set health to 90. there's no way to customize it and basically what i want to do is as soon as the class is being created then i want to create these different attributes and instead what i want to do is when this class is being created i want to create this health and this energy with custom values and for that to work we need to define a dunder method and the one we need is called dunder init and this is just going to be another method like attack and move we are just calling a method meaning the first parameter here has to be a reference to the class itself and for now let me just print the monster was created and do pay attention i am never calling the init method myself but if i run this we get the monster was created the monster was created and then 90 and 90. and what that means if i minimize this a bit every time we are creating a monster so first here and then here then we are calling this dunder method and this standard method we can also give some parameters for example we could specify in here the amount of health and the amount of energy we want and well i hope you can see where this is going basically what we can do now is we can set self.health to whatever health parameter we pass in and we can do the same thing for energy and the names here might be a bit confusing so let me add a bit of white space and explain this self.health here is referring to this self.health of the monster class whereas this health here refers to this parameter and the important point here is self because this one specifies where health belongs to i hope this makes sense this is something you see fairly often let me remove the white space again and now when i am calling the monster i can either pass in arguments or named arguments let's say for the first monster i want health 10 and energy 20 and for the second monster i could specify health being 50 and energy being 100. now if i run all of this we get monster 1 health is 10 and monster 2 health is 50. and this 10 here refers to this 10 and this 50 is referring to this 50 here meaning now we can have custom attributes and what is even better since this self is a reference to the class itself we can just create the attribute in here which means we don't need those lines at all it would still work without them if i run this now this is still working just fine and this is what you see most of the time where the class by itself doesn't have any attributes we only create attributes when we are creating the class with the init method or the done there in it method and then instead of the other methods we are calling self all the time to refer to the class and i just realized this should be self instead of monster so we're capturing this self here and what you are going to notice is that you are going to write self all the time it is a little bit annoying but well it is manageable and well with that we have the first init method but there are quite a few more although those you wouldn't use that often and just to keep things simple let me get rid of monster 2 and i don't want to print anything at all another danda method i talked about in the introduction is len and this one needs self and no other parameters and in here we just want to return something let me return the number five and what this one is going to do is if i call len and pass in monster one in there and this len just as a quick recap if i pass in any kind of string into len let's say test and if i print the result i get 4 or the number of characters inside of the string i guess i could also pass a list in here that might make a bit more sense so i have a list with five entries and the length of it is five but what i can do now if my monster has a len method i can pass monster 1 in here and it would return 5 as well and any number that is being returned here is going to be passed into the length function and i guess for something slightly more relevant instead of returning a number i could return self.health and now if i run this i'm getting 10 or the amount of health my character has which is 10 right now and another example we have seen in the introduction that works in the same way is abs and we need dunder on both sides and in here self and again i have to return something so return and for this case let's say self.energy and if i copy this and pass it into absolute i get 20. now usually absolute is if you have a negative number and you want to make sure it's always positive that's what it does but well you could theoretically do whatever you want with it now what you can also do is one specific function in python and that is called dir short for directory i think or directory listing or something like that basically what it does you pass in an object and then you want to print the result and what you get from that is all of the dunder methods and at the end the attributes and the normal methods and in here you can see a lot of stuff actually and what you have to understand here is every time we are creating an object python already gives it some dunder methods for example here we can see the dir method and this one is necessary for the ear function to work it kind of works like the len method the one we have created ourselves or the abs function and i guess the one we have just created is the init method this is the really important one and most of those you really don't want to worry about because well they're just there to make the class work but we don't really have to worry about them although some dunder methods in here can be very useful for example dunder digt is well it's kind of a dictionary but not in the way you would expect basically how you would use that one let me print it right after the monster i want to print monster 1 and then dot dander dict and in here this is the one exception where this is not a method this is just an attribute so no brackets afterwards and this one gives us all of the attributes of the method inside of one dictionary can be quite useful sometimes although you wouldn't be using it too often now another way to get to this dict here is to let me duplicate the entire line you can call the varus function and pass in monster1 and this one is giving us the very same thing although i have hardly ever used either of these most of the time you just don't need them with that you should understand dunder methods reasonably well now there are quite a few dunder methods that get a bit more advanced i only covered the really fundamental one some other examples of thunder methods is for example dunder call and in here we only need one parameter self and in here we can return something else again and let me distribute dunder on both sides let's say the monster was called and what this dunder call does is it essentially turns our object into a function meaning i can call monster 1 and then add brackets afterwards and if i do that we are not getting anything because i would have to print what i get so i have to put brackets around it and call print and now the monster was called i guess a cleaner way of doing this is to return nothing and just print this string so now if i call monster1 we get the monster was called and nothing is being returned and when you create a function in python it basically behind the scenes creates an object with this standard method here and this we can just create ourselves it really isn't that complicated and what we can also do is to add and subtract numbers and this you would for example do with dunder at and in here you need two parameters first of all self as always and then you need some other number and what you can do in here is return something let's say i want to self.health and then plus whatever other number i get and now that i have that i can print monster 1 last pen and if i run it i get 20 which is if i find it so the health of my monster is 10 and i add 10 towards it so i get 20. and i guess to make this a bit more understandable let's add 55 in here and i get 65 which is 10 plus 55 and well that is a couple more dunder methods they can be incredibly useful although most of the time you are only going to use thunder init this is the one you absolutely have to understand but i guess they don't really get that much more complicated so it shouldn't be too hard alright now for the challenge for this part i want you guys to do some research because there's another dunder method that is called str and i want you guys to look up online what it does and how to use it in code all right here we are in the official python documentation and there you can see dunder string or dunder str and basically what it does it's called by the str object built in function format and print to compute the informal or nicely printable string presentation of the object basically what it means is that this object is going to return some text so let's have a look at it here we are back in the code and i only need one parameter and that is self and now i have to return some kind of string and the string i want for this one let's say a monster and what i can do with that let me get rid of this print statement and instead i want to print str or monster1 and this is going to return a monster and we don't even need this str because print is trying to find a string so let me duplicate this line and remove the str and just have monster one if i call this now i still get a monster and this can be a really nice way to look at your objects and see what they are doing because if we didn't have this done their method let me comment it out and run this again all we get is a monster object which really isn't that useful and obviously this str can return a lot more than just a simple string for example we could have an f string with health that says self dot health and energy that says self dot energy and now if i run this we get quite a bit of information by just passing the monster or the object into the print statement so this sdr can be really really useful and with that we have covered quite a few dunder methods if you look online you can find even more but well most of the time you're not going to need them this is very often a fairly advanced topic except thunder init this is the one you are going to use a lot all right with that we have dunder init methods covered and if you understand all of this so far you can actually understand python itself quite a bit more let's talk about this one in the next part and the one thing i think that confuses beginners quite a bit is that every single thing in python is an object meaning every time you see a string or integers you are going to see an object just like the objects that we have created so our monster and this even includes functions which are just objects with the call dunder method and i'm going to show you some examples in just a second but most of what i will cover here isn't really important i just want you guys to understand how it works so you don't get confused later on and there's another thing that i believe is very often confusing and that is the difference between a function and a method and the reason why this is confusing is both just execute a block of code so in terms of functionality they basically do the same thing however the difference is that a method always belongs to an object it doesn't matter if the object was created by us or by python and a good example here would be using a string so if we have a function this would be len for example and we can pass a string into it this will return 4. and a method would be something with dot and then upper for example for string returns uppercase letters for this string and that really is the entire difference that's the main thing you have to understand and it doesn't matter if we create the method ourselves or the function ourselves or if it's created by python and the reason why these are different for example is that the lan method could work for lots of other things as well for example you could pass in a list in here you could pass in a dictionary or a tuple it would still work with different data types whereas upper only works for strings you couldn't add a list with upper that one would not work so it makes sense in this case that upper only exists as a method for strings whereas the ln should be a function so you can pass in different kinds of objects in here and they would all work you could perfectly find create some kind of len method for test and it would work just fine although then you would also have to create a lan method for lists for dictionaries for tuples for all of that stuff and it would be quite labor intensive so all we're doing here is to keep things more efficient but all right let's have a look at some code and let's have a small deep dive into python here i have a completely empty sheet of code and what i want to create for now is create a test variable and this one should have a string let's call it a doesn't really matter what it is and what i can do now i can call my print bir and pass in my test in here and if i run this now i am getting a bunch of dunder methods and after they are over starting from here i get a couple of methods and attributes now the dir method doesn't separate between methods and attributes so we just get one big list but well basically what we get here is an object and anything in here you could just call like upper or title or strip all of these are very simple methods and along with that we have the len dunder method and this is what's being called when we are passing this string into the len function and besides that what you can also do let me get rid of this test and instead create define test and then here i let me just add pass so this is a function with the name test and i'm still printing dir test so if i run this i am getting another object and this object is special because it has a call dunder method meaning when we're adding brackets afterwards it is being executed and that's basically what a function is in python it's just an object with the dunder call method it really isn't much more than that although we do have a couple extra things that make this a bit more special but that's the main idea and if you really wanted to you could even store this function inside of a variable and this works because the function is an object so this is just going to be an object meaning if i now print a we are getting the same outcome although what we can even do now let's call it another attribute that is not how you spell that and this could just be 10. and now if i run this our function has another attribute and again this is working because functions are just objects although in practice you wouldn't really do this there's no reason for it but what is much more common is that you are passing functions or methods into other objects so what is much more common let's say for example a simple add function and this one takes a and b and is going to return a plus b obviously this still isn't particularly useful but i just want to illustrate what it does and now i can create a class and let's call it test and in here for the dunder init method i want to have self and i want to add an add function and now inside of this dunder init add function i can set an attribute self dot add function and this should be the argument we get from the parameter add function and now when i create this test i have to pass in one function and i want to have this add function here so i'm going to add it in here and let me use a named argument so it's a bit easier to see what's happening and in here it is really important that you don't add brackets because we don't want to call this function we want to get the function itself so the object of the function not what's being returned and if i run this now this is working just fine and even better what i can do i can call test dot add function and i can pass in let's say one and two and this is not doing anything because we're not printing anything we're just returning something so if i put all of this into a print statement now we are getting free and i hope all of this is making sense this is a really important thing to understand right now this here is creating an object of a function and this object we can pass around for example we could pass it inside of a class and this would work just fine and then inside of the class we can store it inside of an attribute and then call it from outside of the function this is working just fine there's no limitations on this and this is something you really want to practice because passing around functions is a really important thing to understand and i guess since this is really important we should practice this with a slightly larger exercise and let me add some comments that should help quite a bit first of all i want you guys to create a monster class with a parameter called func and this func should be stored as a parameter that's the first step after that i want you guys to create another class and this one is called attacks and this has four methods we have let me put it on another line we have byte strike slash and kick and for each method you just print some text basically whatever you want i would recommend to print kick slash strike and byte but it really doesn't matter and let me add proper white space here and then for the final step i want you guys to create a monster object and give it one of the attack methods from the attack class and remember here that methods are basically just functions the only difference is that they are part of an object so this should work kind of similar compared to what you have seen here but well it's going to be slightly different so experiment with this and see how far you get all right let's try together now first of all i want to create a monster class and this i do with class monster and in here i want a dunder init method that needs self and a funk and this funk i want to turn into an attribute so self dot func and i want to capture the parameter or the argument we get here in there and this is covering all of this next up we have to create another class so class and this one is called attacks and in here we don't need a dunder indeed method instead i want to create define let's start with byte and we need self as always and in here i just want to print byte and since we need four attack methods let me copy this a few more times and now besides byte i also want strike then i want slash and finally i want kick and i think you can already tell why this might be useful it's a very neat way to organize all of your different functions if you have a really large game with hundreds of different attack methods this may actually be really nice to organize all of this all right now finally i want to create an object of my monster so monster in lower case and then here i want to have my monster and now we have to define a function now this you could approach in a couple of different ways although there's one way that is definitely wrong and it's very tempting to go this way you could write something like attacks and then dot byte and if i run this code we get a 3 and this 3 comes from up here so let me comment out all of this and if i run this again now we can't see any difference but if i run monster.funk we are getting that attack.byte is missing one required positional argument and that is self and this is a reasonably common error the reason is that this here is not returning an actual object it's returning a class and this is confusing python now an easy way around this is to actually turn this class into an object by calling it so adding brackets afterwards and now if we run this we are getting byte and basically what is happening here think of this in terms of return statements when we are calling this attacks it's returning an object and then inside of this object we are getting the byte method which is this byte method here and if you don't like how this looks what you could also do is create a separate object let's call it attacks and in here i could add this attacks and then call attacks.byte and we will get the same result and this is something we are going to explore quite a bit more that you pass different things around different classes so that in this example we are taking the byte method and passing it into another object and this is getting incredibly powerful and really important to understand if you want to understand more complex code because a key part of objectoriented programming is that you work with different objects and make them interact with each other and this example here so this part down here is one example to make classes interact with each other and i would really recommend you to practice this in your own time it's really going to be helpful but all right with that we have covered a really basic deep dive into python although i do want to practice this a bit more and there's one important topic i do want to cover and that is going to be scope in terms of objects and classes let's talk about that one in the next section all right so let's talk about classes and scope and this is one of the really powerful parts of objects that make it really easy to work with this scope but let's talk about it basically every method so every function inside of a class has a reference to that class and because of that it's really easy to get and change class attributes and because of that methods are much easier to work with than normal functions meaning they rely much less on parameters the global keyword and return statements although you can still use them if you really want to and sometimes that does make sense but you are going to do this much less often and what is even better objects can be influenced from outside of the object itself and even from the local scope of a function basically objects you can change wherever you want there is no limitation on the scope for them which makes it even easier to work with them but i guess let's have a look at all of this in code that should illustrate this the best here i have a completely empty sheet of code and first of all i want to illustrate the problem so let's talk about scope again let me add a comment scope problem and let's say i have a game and i have some kind of health that right now is 10. and for this health i want to have a function let's call it update health and this one takes an amount and all it really does is it adds that amount to the health a super simple function just about the simplest function you could write now what i want to do let me say i want to print health then i want to update my health with 20 and then i want to print my health again and if i were to run this what do you think is going to happen just think about it and well if i print it we are getting an error and what python is unhappy about is that we have a local variable health referenced before assignment and what is happening here is that this health to python is a local variable let me remove the error messages they are getting a bit annoying that's easier to work with essentially this health only exists in the scope of this function here or in other words this health here and this health here to python are two completely separate things and then when we are trying to update this health with some amount i even cannot find any starting amount for this health as a consequence we are getting an error and there are a couple of ways to get around this for example we could use global health that's probably the easiest one and now this would work although you could also use return statements but it really isn't the cleanest way to work with this so this is not great so let me comment it all out and let's do the same thing with classes so let me create a class monster again and in here i want to create a dander init method that needs self health and energy and then as always i want to set self.health equal to health and self.energy is going to be energy and now let me create an object from this class and let's give it a health of 100 and energy 50. it doesn't really matter what values you put in here so now i can print monster.health and we are getting a hundred so this one works just as expected and now what we can do we can just get monster.health and add let's say 20 to it and if i now print monster.health again we are getting 120 ie the sum of 120. and what is even more powerful let me uncomment this function up here and now instead of the health i want to get my monster.health and update the amount and this would still work if you are using an object so let me get rid of these two lines here and instead call the function update health and let's say i want to raise this by 20 again and now if i print monster.health after calling this function i get 120 meaning even inside of the local scope of a function you can still update anything inside of an object but the simple reason that here python is very clear about what kind of object you're talking about this monster is not going to become a variable in the local scope and this monster could be updated anywhere it could be in the global scope it could be the local scope of a function it could be in the scope of another method it could even be inside of the object itself so this monster python just doesn't care which makes it really easy to work with so i guess one thing you do see fairly often is inside of a class you have something like let's call this one update energy and then here we need self and let's add an amount in here as well and all i really have to do to update this self.energy would be to first target the attribute itself so self dot energy and then plus equal amount and now i could just run monster dot update energy pass in anything i want in here and then print monster.energy and we are getting 70. and again here this is a very easy way to work with scope you don't have to worry about return statements you don't have to worry about global all you do is target the attribute and then you set it to a new value or update whatever you want that's it it's super easy to work with although if you wanted to you could use a return statement as well for example if i wanted to set energy and in here i want self and energy and let's say for this one i want to create a new local variable that i call new energy and this is going to be energy times two and then i want to return this new energy and now in my init method instead of setting energy straight as the attribute i want to call self.set energy and pass in the energy and now let me comment out this line down here to update the energy and just get the energy now we're getting 100 which is this 50 here this 50 we are passing inside of this energy here from that energy we are passing it inside of another method inside of the monster class and this method is down here we are getting one parameter and this we are doubling and assigning it to new local variable inside of this method and after that we are returning the new energy and this new energy is going to become the attribute self.energy kind of a roundabout way of doing it but it is possible to do all i really want you to understand is that you can still use return and parameters just like with any other function although most of the time you don't really need it a better way for this one would be to remove this part entirely just call set energy and then self dot energy is going to be new energy this would work in exactly the same way although it is much cleaner to read so if i run this we are still getting a hundred and i hope you understand why self is really really powerful it essentially bypasses all of the scope issues very efficiently all right let me get rid of all of this because i don't really care about it and instead i want to set self.energy back to energy all right now with that let's do an exercise to practice this and what i want you guys to do first of all create a hero class with two parameters one is damage and the second one is a monster which is going to be this object here so this object you want to pass into another class as an argument and second of all the monster class should have a method that lowers the health and i guess you can call it get damage and this one should take an amount and then this amount you would reduce from the health of the monster and finally the hero class should have an attack method that calls the get damage method from the monster and let me put this on the second line and the amount of damage is hero dot damage which is going to be the damage you specified up here which should be an attribute so i hope all of this makes sense try to implement this yourself and see how far you get alright let's try it together now first of all i want to create a new class and this is going to be hero and the hero needs a dunder init method and here we need self and besides that i want damage and i want a monster and let me add a bit more white space there we go now i want self.damage to be damaged and i want self.monster to be monster and let me spell this correctly there we go and this would then be step number one and for step number two let me move it up a bit so it's easier to see what's going on the monster class should have a method that lowers the health and this i want to call get damage so define get underscore damage and then here i need self and i need the amount and all i really want to do in here is self dot health minus equal whatever amount we specify and this get damage i want to call from inside of the hero and this brings us to step number three and this right now we are still inside of the hero class which you can see by the indentation i probably should have actually mentioned that for the class we always define something by one level of indentation in here i want to now create let's call it an attack method and this one itself and nothing else and all i really want to do in here is get myself.monster and this self.monster is the monster we specified up here and on this monster we want to call get damage and all we really have to do for that is call get underscored damage and now we have to specify how much damage we want to cause to the monster and for that i want to get the damage of the hero and all we need for that is specify self dot damage and we are done and if you just read through this i hope this really illustrates why this makes a ton of sense it's basically a normal sentence we want to get the monster we want to cause the monster some damage and the amount of damage we want is selfdot damage so the damage of the hero and now with that all we have to do is to actually create the object of the hero meaning i want to create a hero object and this is going to be hero and then here we need damage let's say damage for the hero is 15 and then we need a monster and the monster is going to be the monster object we created just a second ago this one here and this we're just passing in here and now let me print monster.health and if i run this we are getting a hundred which is this 100 here but now if i call hero dot attack and this one doesn't need any arguments and afterwards i can print monster.health again and now if i run this we get 85 which is 100 minus 15. this is how this 85 comes about and to get to this point to lower the health of the monster we just had to call one method and that's it all we are really doing in here is we are passing different objects around and make them interact with each other and since we don't really have to worry about scope this is very easy to implement and again this is something you really want to practice on your own and try to work on this more to make sure you understand it but right with that we have covered scope and i guess for the next part let's talk about inheritance and inheritance really just means that one class gets the attributes and methods from another class or multiple classes and i have already shown an example earlier and that was we had a monster that we have already seen multiple times with health and energy and this right now is called a parent class and the reason why it is called the parent class is because there's a child class and this one was the shark and this shark by itself only has a speed and a byte method and what i want to happen is that the health and the energy of the monster parent class comes into the child class and the same for the method so attack and move should also be available inside of the shark class so that when i actually use this to create an object the shark object has health energy and speed for the attributes and attack move and bite meaning we are combining the monster and the shark class to create the actual shark object and the reason why we are doing this is this makes it very easy to reuse code let's say this monster here could be the parent class to every monster in our game and if we have this we never have to set the attributes health for energy for any other monster they are always available for every single class because they all inherit from this monster and obviously this is still a very simple example in an actual game the monster class might have a few hundred if not thousands of lines of code and then it really makes sense to reuse code as much as we can because then we don't have to create new classes all the time with all of these methods that we have to type over and over again and then on top of that if we wanted to make changes to how things move in the game so this method here if we didn't use inheritance and we want to make change how things move in the game we would have to change possibly hundreds of different move methods for every single monster but if we use inheritance we don't have to if we change one move method we are changing how every monster in the game moves so i hope that makes sense and one important concept here is that the class can inherit from an unlimited number of other classes this could look like this in here we could have a parent class 1 a parent class 2 and a parent class 3 and then the child class would have the attributes and methods of all of these parent classes and you can also turn this around where you have a parent class and this parent class is being inherited from by an unlimited number of other classes and this would look something like this you have one parent class and you have one child class a second child class and a third child class and all three of those would have the methods and attributes of the parent class and this here for example could be the monster class and then this one here maybe the shark class and let's say this one here could be i don't know like a bird class or something now there's one thing you do want to be aware of though and that is that inheritance can get very very complex up to a point where it really doesn't become fun to work with them and this is also the part where beginners really start to struggle because well i'm going to show you an example later on but this can get very very complex and really hard to work with fortunately this is fairly rare most of the time you just need simple inheritance and this one is really easy to implement and this one might be something like this the example we have already seen and this one should be very easy to follow so for this section i just want to focus on implementing this part here and i guess let's actually implement this one in code and let's see how this is going to look like alrighty so here once again we can see our monster class and from this monster class i want to get a shark class and this one should get the health the energy the attack method and the move method of this monster class we want to put all of this inside of the shark now passing in the methods is very simple but the health and the energy are going to be a bit more complicated so for now let me simplify things a tiny bit by commenting out the dander indeed method and instead setting health to something constant let's say 50 and energy to 100. the reason being that init is a bit more complicated for inheritance so i'm going to ignore this part for now just to keep things simple but we will implement this in just a bit all right now for this shark i want to create an init method by itself and this one needs self and in here i want to set this speed and now what i want to do is self.speed is going to be speed and this way we are getting our attribute and besides that i also want one method and that method i have called byte and in here we just need self and let me print the shark has bitten or whatever you want to put in here and this by itself would be a functioning class but also a very limited class because it only has a single attribute and one method it doesn't really do all that much so how can i get all of the monster attributes and methods inside of the shark and to get inheritance what we have to do is add brackets after the shark or the name of the shark class and then here we have to pass in what class we want to inherit from in my case this is monster and for start this is all you need meaning now i can create my shark by calling shark and i have to pass in a speed for the shark and let me just say i don't know 120. and now if i print my shark all of this works just fine and we are getting an object but what i can do now is get my shark dot health and this is the 50 we have set all the way at the top here i can also get my shark speed this is the 120 we set for the shark in here and besides that i can also call shark dot byte we get the shark as bitten and besides that i can also set shark dot attack and this one needs an amount so let's say 20 and this is the attack method we have gotten from here so the parent class and if i run this we get the monster has attacked and well with that we already have super simple inheritance just by adding this brackets monster we are getting all of these attributes and these methods here so that's a pretty good start now what you can also do let's say let me remove some white space here let's say for the shark this move method here doesn't really work because for the shark i want something else i want the shark to swim and for the speed i want to set since i have a speed i want to use self.speed meaning i want to overwrite this speed from the parent class and to achieve that all you have to do is define a method with the same name in the child class so in here i want self.move and now i can add a print statement in here the shark has moved and let's say print again the speed of the shark is and then self dot speed and this should be an f string and now if i call shark dot move and we don't need any arguments if i call this the shark has moved the speed of the shark is 120. and what happens in here is we are first getting the inheritance from the monster and then this move here is being overwritten by this move here which means you can overwrite what you get from the parent class very easily and this you could also do with attributes although we actually have to talk about attributes let's do it right now the problem we are facing right now is that the monster has an init method let me remove this health and energy and uncomment the init method essentially the problem we have right now to give the monster the attributes this self.health and self.energy we have to first call the init method and if we don't call the init method we don't get these attributes so what we have to figure out inside of the init method how to call the parent init method so this would have to happen in here and for that we have two ways one that is a bit outdated but still works and one you actually want to use and let's cover both but you don't really need the first one anymore but just in case you see it let's cover it now what you can do you can call the parent class so monster and then call the dunder init method and now in here you have to pass all of the arguments so these ones here that you want for the parent class so we need self health and energy and these we have to get from arguments so when i initiate the shark besides speed i also want to get health for the shark and energy for the shark meaning when i actually create the object of the shark besides speed i want to set health to 100 and energy to 80. now what i get let's go over this actually the first step happens down here i am calling the shark class and i'm passing in three arguments i have the speed i have the health and i have the energy and these three arguments are being covered in speed health and energy and inside of this init method we are calling the parent init method and into this init method we have to pass in three arguments self health and energy and self originally for the parent class was the class itself so this self here which refers to this monster however now the self is going to refer to this self here which is the shark meaning when we are setting self.health and self.energy we don't talk about the monster we are talking about the shark class and this is why the self here is important and then besides the self we also need health and energy and these are just going to be arguments we have to pass in here so this health and this energy and these two we get from these two parameters here which is health and energy and those are being passed in here and with the left move method i don't care about this one instead let me print shark dot let's start with speed let's actually print all of them so besides speed i want health and i want energy if i run this we get 120 180 the numbers we have specified here and well this can get a bit complicated but look at the init method here and the init method here and if you didn't understand what i talked about in the last part practice this yourself and then go over this a couple of times if you get used to this it's eventually going to become fairly easy although i suppose in the beginning this can be a bit overwhelming the one really important thing you have to understand is that we are calling the init method and we are passing in the arguments that we want to set in this case speed health and energy and then inside of this init method we are right now calling the parent init method and then passing health and energy so these two in there as arguments so for example we first set the health here when we are creating the object this health goes into this health for the parameter and then this parameter goes into the init method of the parent and then the init method sets self dot health or the actual class and that way you can connect the init methods of different classes now this is how python used to work and this still works but there are some downsides to using it this way so this isn't really used anymore instead what we use is called super and this is a function and this super all it really does is it gets the parent class so if we have that we can just call the init method on it as well and in here we don't need self all we have to do is pass in health and energy and then we are done if i run this now we are getting the very same outcome meaning those two approaches here are functionally identical at least up to this point when we get to multiple inheritance or let's say more complex inheritance super is the much better method and this is why we don't use this initial approach anymore and i guess this one is also a bit easier to read it kinda is up to you but this is the one you do want to use and super you can actually use for a lot of other things as well for example i could call super and then call the move method of the parent and in here i have to pass in a speed let's say 10 so now when i run the code i get the monster is moved at a speed of 10 meaning when we are calling the init method of the shark class we are also calling the move method of the parent and this way even if you overwrite a method from the parent class you can still call it with super if you really want to which adds even more flexibility to all of this and this is simple inheritance which is something you definitely want to practice this is the one kind of inheritance you are going to use fairly often and the one you have to understand let's practice this one and let me add comments one more time let's do an exercise i want you guys to create a scorpion class that inherits from the monster and it should get health and energy from the parent and then besides that there should also be a poison damage attribute and i want you guys to overwrite the damage method to show poison damage kinda like what we have done for the move method for the shark pause the video now and try to implement this one yourself and see how far you get i want to start by creating a class called scorpion that is not used for scorpion there we go and this one should inherit from monster and now in here i want to create a dunder init method and this one itself and besides that i want poison mitch and now inside of the scorpion i want to set self poison damage as poison damage so we are getting an attribute and then besides that i want to define or well overwrite the attack method let me minimize the shark class so we can see the code a bit easier and i want to overwrite this attack method here and in my guess what i want i just want self because i already have the poison damage and all i want to do in here is print the scorpion has attacked and print it has dealt and then we want self dot poison damage and poison damage and this should be an f string alright so far this should have been fairly easy what i can do now let me delete all of this and let's delete a shark as well we don't need him for now and what i want to do is to create an instance or an object from my scorpion i am really bad at typing scorpion and here i bought my scorpion and right now we have a poison damage i don't know of 50. and now if i type scorpion dot attack this is working the scorpion has attacked it has dealt 50 poison damage this shouldn't have an underscore there we go it has dealt 50 poison damage this looks much better meaning what we have so far we have a scorpion with poison damage and we have overwritten the attack method and since we are inheriting from monster we are also getting this move method here meaning my scorpion can also move at a certain speed let's say 5 if i run this and let's make this a bit larger we have the attack method for the scorpion and we have the move method but what we don't have let me get rid of those two we don't have scorpion.health for example this attribute doesn't exist right now because monster only gets these two attributes once we are running the init method so what we have to do in the scorpion called the init method of the parent class which we get with super and then dunder init in here and if i scroll up the monster class for the init method needs two arguments health and energy so let me comment those two and in the unit method i want to pass in health and energy now these numbers have to come from somewhere although they don't necessarily have to i could for example just set static numbers in here let's say 50 and 10. if i run this now we get 50 for health because all we are doing here is calling a function that is done there init and we are just giving it different arguments although this lacks a lot of flexibility so i don't want to do it but we could if we wanted to instead i want to get this health and this energy from the init method of the scorpion class and in here just to be specific about what we are doing let me name this scorpion health and scorpion energy and somehow my brain always wants to add a tea to scorpion i have no idea why and now when i call the init method for the monster my health should be my scorpion health and my energy should be my scorpion energy when i am creating the actual object i want to have let me use named arguments that makes it a bit easier to read my poison damage should be 50 my scorpion health should be 20 and my scorpion energy should be 10. and now if i run this we get 20 for the health of the scorpion because remember we are only calling scorpion health the parameter so this is scorpion health here we don't actually set this parameter as an attribute instead what we do we are using the health attribute of the parent class and this gets the value of the scorpion health so our scorpion doesn't have scorpion health as an attribute it just has health and along those lines we also have energy if i run this we get 10. and i hope this starts to make a bit more sense this is definitely something you want to practice if you only partially followed along this is a really important concept to understand and definitely something you are going to see all the time and this you can actually make quite a bit more complex with well more complex inheritance so let's talk about that one and basically what that means so far we always had one parent class and then a child class so a pretty immediate connection something slightly more complex is you have a child class and two parent classes this is something we are going to build in this section but if you really wanted to you could do something like this and it would still work now maintaining something like this is going to be a ton of work although once you have it this child class is incredibly powerful because it gets information from a lot of parent classes so especially if you create something really large this is something you do want to be able to understand but for now especially if you're a beginner and this is the first time you've really engaged with objects i wouldn't recommend to worry about this too much because it gets overwhelming very fast instead make sure to understand this scheme if you understand that one you should be able to follow along with this one as well but for now just practice objects in the first place and once you have a better grasp of objects engage in this one so let's talk about how we could create something like this and this i think is best done in actual code so let's have a look how we can work with this now here i have some code already i have the monster class we have seen quite often by now this one i hope is familiar at this point besides that i also have a fish class now and this one is a very simple class all we have is an init method and this one sets a speed and has scales and besides that we have a swim method and this one just prints swimming at the speed of whatever the speed of the object is going to be and what i want to do i want to create my shark again but this time the shark is not just going to be inheriting from monster it is also going to be inheriting from fish so the first thing for multiple or complex inheritance is that all the objects you want to inherit from should be here in the brackets after the name of the class and in here you could add as many other classes you want there could be class 3 class 4 class 5 as many as you want there isn't really a limit and now inside of this shark i want to set a dunder init method and in here we always need self this one should make sense by now and besides that for the shark let's say i want to set a byte strength and then inside of this init method i want to self dot byte strength is going to be byte strength this one should still make sense it's quite straightforward but the more complex one is if i now want to call super and then dunder init now we have a problem because i have no idea what to put in here and the question here is what arguments should go into this inhibit method should i add the arguments for the monster class or for the fish class or both how would this work and there are a couple of things you have to understand to solve this problem the first one is called the mro or the method resolution order and what this really means is let me add a comment here mro or method resolution order what this basically means is in what order the parent init methods are being called and this you can get by just printing and i want to get the shark class not the object the class itself and call mro on it and this is still going to work and if i call this we are getting invalid syntax because the question mark here is not something python likes so let me comment it out for now and now let's run this again and now we can see the mro or the resolution order and basically what it means is in what order python is going to go through the classes we start with the shark itself this one should make sense this is the class that we actually work in so this is where we want to start next up we are looking at the monster class then we look at the fish and finally we look at a generic object and this generic object you don't have to worry about because this is something inbuilt into python it's the thing that makes all of the objects work you don't have to worry about it so what we have to worry about is the shark the monster and the fish and how this order comes about is from the order of these arguments here and basically how this works is that the leftmost item monster in this case is always going to be the first in line with the class itself being the very first item so shark is going to be zero monster is one fish is two and then every subsequent item is going to be next meaning what i could be doing is turn these two around and call fish first and then monster if i run this now we are still starting on our shark but now fish is the first item of inheritance then we have monster and we still have object finally but in my case i do want to keep monster as the first item so the first thing you do have to understand is if we are calling the super dunder init method we are looking at the first item inside of these arguments here so in this case monster meaning for now i can minimize the fish class and just look at the monster and let me minimize these methods as well so it's a bit easier to see and basically what i can do now let me comment out the mro and i actually want to create a shark object from my shark and this is something you should be familiar with from simple inheritance right now we only have the byte strength so byte strength and this we can set to whatever we want let's say 50. but now for this superintendent method i need the arguments for the init method of the parent class in this case health and energy these two i want to pass in here now for these two i again i am going to need some numbers so for the init method of the shark class i also want health and energy meaning when i create the object i also want health and energy and let's set those to i don't know 200 and energy could be 55 and with that we are essentially back to simple inheritance i first call the class itself and the first one we do after calling the class we are calling the init method and inside of the init method python knows that the first item of inheritance is the monster class and then after that python knows we have one parameter for byte strength and this we're just setting as a parameter and then we are done with it so this is as far as this one goes besides that we also have health and energy and these two we want to pass into the init method of the first parent class so the monster and those we are getting up here but now we have another problem and that problem is what happens to the fish let me run the code and let's see what happens we are not getting an error that's a pretty good sign now if i run shark and the methods we have here could for example be attack and for attack we need an amount let's say 10. the monster is attacked 10 damage was stealth so this attack method works just fine besides that i can also print shark.health and let me print this this one is working 200 we also get shark dot energy with 55 and we are also getting the byte strength so far we have the shark itself and the monster what we don't have is the fish let me minimize the monster class and open the fish in here we have speed and has scales and this our class doesn't have right now so if i type shark and speed and run the code we are getting that the shark object has no attribute speed which means that the inheritance from the fish is not working right now and let me reopen the monster and hide the monster methods so we can see all of the classes quite easily basically what is happening the mro is important here again this one here essentially how you have to think about it we first of all call the shark and then we call the init method of the shark and then python knows the first item of inheritance is the monster and since we are calling super.init we are calling this init method up here and passing the arguments in there the consequence is that we have health and energy for the monster and the normal inheritance still works so we also have attack and move but now the problem is that the init method of the fish is never called and as a consequence speed and has scales doesn't exist inside of the shark and what we have to figure out is how to call this init method and since we still have to worry about the mro we have to figure out how to call this init method with the arguments from inside of the init method of the monster and for that purpose we are still going to need this super and then the dunder init method and this function is very smart because it follows the inheritance that we have set by the shark to begin with meaning if we call the monster from the shark it knows it has to look at the fish next in line however if we call the monster by itself this init method wouldn't really do anything so this is a very intelligent function in the simplest terms basically what this init method has to do is to set the speed and hash scales of the other class which is the fish again let me set some static numbers for the speed let's go with 75 and for scales this should be false and now if i run all of this again i get for speed let's try this again now for speed i get 75 and for hash scales i get false the arguments we have set in here and this is especially if you are starting with objects probably going to be really confusing but the one thing that makes all of this work is the order of the indent methods we are first calling this one here this is number one then we are looking at the monster which is this one here this init method is number two then and then finally we are looking at the second item in the inheritance which is the fish this for shear so this init method is called third and we always need the super init method to go to the next item and what we would want to add in here as well is a super and then dander init method for the fish as well so if there's going to be another item in the list of inheritance or in the mro we would also call that one and for that reason you very often see super init in most classes because it enables inheritance to work across multiple classes and well i hope you can still follow along this is getting quite complicated and it is just going to get worse because right now we do have one problem and that is that this speed here and the hair scales are constant right now but i want to be able to set them dynamically when i am creating the shark meaning what i want to do when i create a shark i want to set this speed let's set it to 120 and i want to set has scales to false and this would then be all the stuff i have for the shark and i think it makes sense to put all of this on separate lines to make it a bit easier to read all right but now if i run this we are getting an error that shark init got unexpected keyword argument speed basically what pipeline is complaining about that this speed and this has scales don't exist in the parameters for the init method of the shark class we can fix that by adding a speed and has scales in here if i run this now this is going to work but we're not doing anything with either the speed or the hass scales we are still up here setting the speed and has scales as constant numbers and now we kind of have a problem because if i try to in this superintendent method at this speed and has scales then let me fix the typo first if i run this now we are getting the other problem that monster.init down here is the error we're getting right now monster.init takes three positional arguments but three were given meaning python in the monster class wants three arguments self health and energy and those we do get let minimize the fish for now so we can see what's going on we are getting health and energy and this is what this init method wants but besides that now we are also adding speed and has scales and for this the init method doesn't have any parameters so python is very unhappy because it gets too many arguments and it doesn't know what to do with them but this is a problem for us because we need those two arguments to pass into the init method for the fish but the init method of the monster doesn't have as many parameters so we have a problem here and to overcome this we need one special concept and that in python is called keyword unpacking and basically what it means is in my monster class after i have added all of the parameters i definitely know i need i want to add star star and then keyword arguments and that way any argument i get after the parameters i am going to store those in a separate dictionary let me actually print what we get so i want to print my keyword arguments without the stars for now and for these double stars python is expecting keyword arguments so all of the arguments for the init method here need to be keyword arguments meaning health.health energy is energy speed is speed and has underscore scales is has scales and now if i run this we are getting a dictionary with speed and has scales and this faults here we are getting from printing shark has scales let me remove that and try this again now so now we can focus on just a dictionary and that is something really useful because this we could use in here now and essentially what you have to do is call the unpacking operator again and passing in the keyword arguments and now if i run this again we are still getting the same dictionary so we are getting speed and we are getting hash scales but what happens now if we are calling this star again it turns each key value pair inside of this dictionary into a named argument meaning this speed under 20 is going to become a named argument and then this we are passing into the init method of the next class in the method resolution order and with that if i now print shark dot speed and actually display what we get i now get 120 the one we have specified in here and this is how you would work with this now for an actual example you would add a lot more quarks to all of these classes for example the fish would also have double star and keyword arguments and then you would pass this into the init method as well so in here quarks as well now in this case the keyword arguments is going to be empty if i print it keyword arguments and run this we're getting an empty dictionary because we don't have any additional named arguments that we have to worry about so this dictionary here is going to be empty well this dictionary actually but if we had more named arguments they would all go in there and this is then how you would deal with multiple inheritance and if again you are just starting with inheritance this really isn't something you want to worry about too much probably if you're watching this for the first time and you're still struggling with objects in general this is going to be way too much i would recommend just practice objects and simple inheritance for now and once you are more comfortable with them come back to this this sort of inheritance is only really something you are going to see once you get much more advanced especially for making games or for making gui's you probably don't need any of this whatsoever all of the games i have made so far have never used multiple inheritance they all use simple inheritance and they worked just fine but well at this point we have covered all the main parts of classes i guess at this point there is some more smaller things i do want to cover but they're all going to be fairly simple so let's talk about them in the next section alright for this part i want to talk about some extra parts for classes and those are things i couldn't really fit in in any of the other sections but they're all fairly simple but they can be quite useful and well let's do all of this straight in code i think that's going to be the easiest alright once more we have the monster class and this is just something i want to use to illustrate what we are going to do and let me create an instance of this monster with monster and for the health i want 20 for the energy i want 10. it really doesn't matter what number we go with here and now there are three things i want to cover the first one is private attributes the second one is has utter and set utter and the third one is going to be the dog string and once we have those we are basically done with classes and the first one is going to be private attributes which is just going to be an attribute inside of a class that cannot be influenced from outside of the class which may be something like an id number that you really want to make sure of cannot be changed from outside of the class to be sure that it doesn't mess with some other code and this actually isn't possible in python we are always able to change the attribute of a class so python developers came up with something else and this let me copy this comment here and in the init method of the monster class i want to create a private attribute and how you would do this is first add an underscore and then the name of the attribute let's say in this case i want to have an id and the number i want here could be 5 but it could be anything it really doesn't matter and now this id by convention is not supposed to be changed but this is just a convention basically what you do with this format is you tell other developers that this attribute should not be worked on but you totally could work on it for example what i can do i can print monster and then underscore id and i get 5. meaning you can work with it but there's a very clear indicator that you shouldn't so if you ever work with somebody else and they added something like this you probably should not change it and well that is all you need to know about private attributes you could do the same thing for methods you are essentially following a naming scheme so this works with both attributes and methods all right next up we have has utter and set utter and what those two are doing is they allow us to check if a class has an attribute and we can also use it to set an attribute and the first one is going to be has utter and that is just going to be a normal python function and this one wants two arguments it first of all wants to have an object and besides that it wants a string with an attribute name and let's try this one i want to look at my monster and for my monster i want to check if the monster has health and this is then going to return a boolean that either says true or false meaning i can print all of this and i get true so this monster has the attribute health if i check for something that doesn't exist let's say a weapon i get false because the monster doesn't have a weapon and this you could then use an if statement for example if has utter monster health and if it has health i want to print the monster has and i guess then we can use an f string monster dot health and that is terrible spelling and let's turn this into an f string and add health at the end and now if i run this the monster has 20 health and that is what we have set here and this is has utter it's a really useful way to check if a certain class has an attribute you are going to use this fairly often actually it's a really useful function and besides that set utter works in kind of the same way so let me call it set utter and in here we need three arguments first of all we need an object then we need a string of an attribute name let's call it attribute again and then we have to set a new value and this could be a string it could be a number it's really up to you i guess let's say again i want to look at my monster the attribute i want to set is a weapon and for the value let's give the monster a sword and now i can print monster.web pin and i get sword and this set utter is basically the same thing as calling monster dot weapon and setting this to sword these two things essentially do the same thing and now you might be wondering why do we have this kind of redundancy that this is kind of pointless at least similarly that we have this entire function that does something very obvious but the reason for it that this allows us to very efficiently create new attributes for example what we could be doing let me comment those two out and i could run a for loop and let me add a let's call it new tributes and this is going to be a tuple with lists i want to have for example a weapon and there i can have an x besides that i want to have another list with let's say armor and the armor could be a shield and finally i want to have one more list and this could be potion i could set something like mana or whatever you want to go for and now i can use that as a for loop so for attribute and value in new attributes i can call set utter i can pass in my monster in here and then i want my attribute and my value and if i run this we are not getting an error which is a good sign and now i can print my vars for the monster and i get the new weapon the new armor and the new potion and this way you can set a lot of new attributes and values for class by using this if you just used monster.weapon this one here this would not be possible and this is why set utter exists although you probably would want to create all of these attributes when you actually create the object itself so this isn't something you want to do too often although in some situations it can be really useful alright with that we have set utter and has utter and finally we have doc and doc is just there to explain what your object does that's really just about it you are getting doc or the doc's string to be more specific by calling monster and then dunder dock and in this case if i run this we get none for the simple reason that we have to create a dock string for our object and this you do first thing in the object and all you do in here is you set a triple quotation mark like this and then in there you are setting what you want for the monster for example i could write in here a monster that has some attributes and i am really bad at spelling monster for some reason and now if i run this print again and now i get a monster that has some attributes and this you could make significantly longer depending on what kind of class you have but this is usually what you want to set to explain your code to other people and especially if you work in a team with much larger projects it's really helpful to set something like this because well somebody else might have no idea what you're talking about what you can also do is let me comment out this print statement here and instead call help and i want to look at my monster if i run this i am getting a long list of different things and in here i can see lots of useful things for example i can see monster and its parameters i can see the dog string and i can see all of the methods inside of it and if you just find a new object you don't really know much about the help function is really useful as a matter of fact you can also pass normal python code in here for example what i could pass in here is just str for string and now python gives me the help function for strings and if i go all the way to the top there you can see basically that we have another object and the object takes one argument which is going to be a string then we have the dot string and this one explains what this object does and afterwards we have all of the methods and there are quite a few because strings are very complex objects and with that we have covered objects and classes i hope that wasn't too difficult but this is definitely something you do want to practice so hope that was helpful and i will see you around