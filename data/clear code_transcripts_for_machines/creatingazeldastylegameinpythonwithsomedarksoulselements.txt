in this tutorial we will be creating a zelda style rpg and it is going to involve a lot of components like sophisticated animations and graphics rpg mechanics and we are going to use tiled for the level creation and we are even going to create enemy ai speaking of ai i would like to give a shout out to the sponsor of this video ai camp if you want to learn more about artificial intelligence and build some seriously cool projects they have something for you ai camp offers either oneonone guidance or a summer camp during which students create real world ai projects like face mask detectors sign language identifiers currency exchange automation and much more student testimonials from past summer camps are very positive and many students received either partial or even full scholarships to attend by visiting my partner link in the description you can apply for a unique scholarship opportunity to fund your time at ai camp and best of all it only takes 10 minutes and even more upon successful completion the top aicam students are hired to work for ai camp or for other silicon valley startups if you want to study ai or computer science at university or work in the field professionally this is a great experience to get started ai camp is currently looking for people to join their summer camp and i would strongly recommend you to check it out if you are interested now before i jump into the project a quick note on this setup we have one folder with four subfolders although we will only make changes to the one that contains the code and since the tutorial is quite long you can find the game files for each stage on github there are 15 in total there are also placement files to get started and to copy code it takes a bit longer to type and well that's basically it i hope you enjoy it so here we are in the code and right now i have three different files open we have main we have settings and we have debug and all three of those are python files and if i run the main file that's the really important one we are getting this window here plain lag doesn't do anything right now but at the very least we have a window that is all we are going to need for now and i guess before we get into the proper code let's go through this to have a solid basis now we are starting all the way up here with importing pygame and says that's the usual stuff the more important stuff comes right below where we are importing everything from settings and settings looks like this we basically have two sections in here the first one contains the main game variables most importantly here we have width and height of our game window and those would be flexible so if the game window is too large for your window you can make these smaller i guess you could also make them larger if you wanted to and then besides that we have the fps and the tile size and i would recommend to keep those two numbers static now besides that we have our world map and the world map is for now going to be the layout of our game in this world map we have our player that's the p then besides that we have axis and that is going to be a rock on obstacle same thing and then besides that we have a ton of empty space and that is going to be space the player can walk on so then if i go back to our main file we have a game class let's talk about this in a second but what we are doing with the class comes down here we first check if this is our main file then we are creating an instance of this game class and then we call the method run of this class so let's look at our game class and in here not much is actually happening we have our init method and in here we are initiating pi game we are creating a display surface and we are creating a clock so this is the basic setup you always need for pi game then more importantly we have our run method and in here two things essentially happen the first one is going to be this bit here and that is going to be our event loop and right now we are just checking if we are closing the game now besides that down here we are filling the screen with a black color we are updating the screen and we are controlling the frame rate so none of this should be difficult if you have any experience with pygame however if you have no idea what any of this means check out my introduction to pygame it explains all of this in quite some detail but alright so this is going to be our basic setup now there's one more file that we have to talk about and that is debug and debug isn't actually going to influence our game instead it's as the name suggests a debug tool so it's really just there to give us information about whatever is going on in the game but it's not actually going to influence the game so you could ignore it entirely if you don't care about it and i am going to use it just to illustrate in a bit more detail what's going on in the game and let me actually demonstrate what it does so if i go to my main file in here i can from debug import debug and then in my game loop i can run debug and print any kind of information that i think is important so let's say hello and let's see what we get now in the top left of our window we get the word hello and obviously right now not particularly helpful but later on this could be a game variable that we want to illustrate so this is very helpful all right but right now i don't want it so let me get rid of all of that now with that we have our basic setup although there's one more thing i would like to add in here and that is that right now let me actually demonstrate in the top left of our window it says play game window and i would rather that this says zelda or something more customized and this would be a challenge for you that i want you guys to change this text to something more custom in my case it's going to be zelda but you could write whatever you want alright let's try together let me close this and we only really need one line when we are initiating all of pi game so it happens right here after i create a display surface and the line we need is pygame spelled correctly dot display dot set underscore caption and then here we have to pass in a string and in my case it's going to be zelda and now if i run this we can see zelda in the top left it really isn't going to make much of a difference but well it looks a bit nicer so with that we have our basic setup and now we can talk about the actual level and our level class is going to become incredibly important it's essentially the central part of the entire game so effectively it's going to be the container that contains all the essential game elements like the player all the enemies the level map all of the obstacles and so on it is really important and that is actually bringing us to the core concept the level class has to manage and that is that we have to take all of our sprites for the game put them in different groups and somehow manage all of this efficiently and the key concept to make that work is to use different groups to give different functionality to different sprites so let me give an example for start we are going to create two groups in our level class one is called visible sprites the other is called obstacle sprites and literally any sprite that is going to be visible will be in the visible sprites class so this is the only group that we will draw on the screen at the end of this project it will contain the player the map all the enemies all the obstacles and so on so if a sprite is not inside of this class it will not be drawn and for the obstacle group well anything that is going to be in here will be able to collide with the player and anything that isn't in here will not be able to collide that's fairly straightforward and how this will become useful later on is that for example for our level boundary so the coastline effectively i have basically placed sprites there that will interact with the player via collisions but they are not drawn because they're not in the visible sprites group you will see how that is going to work later on but the main thing you should understand is this that you can put sprites into different group and the sprite can be in multiple groups at the same time and depending on what group it is in it should be interacting with its environment slightly differently and that is going to become a key concept to make this entire project work but let's actually jump into our code and let's implement all of this so here i'm back in the code and i want to create a new file and i will save this one as level dot pi and in here as always we have to import pi game nothing else for now though and now we have to create a class level there's no inheritance but we do need an init method that needs self and nothing else and i guess now we can go straight to creating the two sprite groups that i just talked about so let me add a comment here and let's call this sprite group set up and in here i want to create self dot visible underscore sprites and this is just going to become pygame dot sprite dot group and now i can copy all of this and i want to create obstacle sprites so these two groups will become really important and essentially what i want to do later on in my level class is i want to give it another method that i'm going to call run doesn't need any argument besides self and in here i want to essentially update and draw the game but for now i'm just going to add pass because it's not doing anything and now that i have my level i can go back to my main i can import so from level import level and what i can do now is create self dot level is going to be the level and then in the game i can call self dot level dot run so we are essentially creating an instance of our level class this one here in our main game and then we are running all of this inside of our loop so really all we're doing is we are calling this method here and let me just run all of this to see if it's working and yeah it's still looking good we still can't see anything but that comes later so now we have a basic level now next up there's one more thing i will need in the init method and that is the display surface because at the end of the game we want to draw all of our game on this self.screen so we can approach this in two different ways we could either take this self.screen and pass it in this level this would be perfectly fine although in my case in my level i am let's do it right at the top we can use a function to just get the display surface from anywhere in our code and the code for that let's call this one self dot display underscore surface all we need is pygame dot display dot get underscore surface and this is going to get us the display surface from anywhere in our code which is quite handy as a matter of fact in the debug method we are using the very same line if you're interested but that doesn't matter too much so now we have our basic level class it still doesn't do all that much because we're not drawing anything and to draw something we essentially have to go through this world.map and draw either a rook wherever there's an x nothing if there's an empty space or the player if there's a p and the problem we have right now is that we neither have an x nor a player so let's create both of these in a very simple way and then we're going to cycle through this entire map to place them on the screen so back in my level well actually this should be a new file and let me save this one as tile dot pi and for now this is going to be a class that will always going to be a rock but later on we are going to make it slightly more flexible so it goes to become a tree or statue or basically any kind of object import pie game as always that was terrible spelling and from settings import everything and now i want to have a class called tile and this one is going to be a sprite so pygame dot sprite dot sprite for inheritance that is really important and now i want to create a dunder init method that needs self and now this one is going to do a couple of things most importantly we are going to need a position so we know where to place it besides that i am also going to give it an argument called groups and this is going to be the spread group it should be part of how that is going to work you see in just a second but there's a very handy feature to assign a sprite to a group via the arguments you see in a second what i mean actually we can do this right now so these are the two arguments i need and the first thing you always eat in a sprite that's very easy to forget is super dot init and then brackets so we initiate this class here essentially and what you can do that is super handy is if you pass the groups in here so the argument we have just declared now we are going to need two things the first one is always self.image and we need self.rect the two main things you always need for any kind of sprite and direct is the easier part we need self dot image dot get underscore rect and the top left is just going to be the position so this is the position that we get up here that we will give this tile when we create it now for the image i want to import a file so pygame dot door and in here we first have to get outside of our folder so right now we are in the code folder so dot dot then we have to go into the graphics folder and inside of the graphics folder there's a folder called test and inside of test we have a player and a rock and for this one i want to use rock.png and really important do not forget to convert alpha this rock with that we have our basic rock or well a basic tile that's a pretty good start and i guess what we can also do is let me copy all of this and now i want to create a new file and this one is going to become our player so let me save it as player dot pi and now i can paste all of this and change the class name from tile to player and now instead of the rock i want to have the player and the rest can stay the same although this player class later on we are going to massively change so there's no point using inheritance between these two classes with that we have a player and a tile or rock so now in our level we can actually set some basic stuff up so we can finally actually see something but first of all let's see if things are still working and they do that's they're looking pretty good and i guess let me really quickly explain what we are going to do so the really important part in our settings is this world map and let's go through this thing really quickly just to explain what it is and how it's going to work so essentially world map is a list here's the start and here's the end and this list contains a ton of individual lists and inside of each list we have one string there could either be an x a space or a p and this we are going to translate into specific positions for example this top left x should have the top left position so this point here should be position 0 and 0. for the simple reason that it's right in the top left now the x right next to it so this one here should have the top left position let me add a small arrow to make it a bit easier to see this should have an x position of 64 because our tile size is 64 but then the y position should still be zero because it's right at the top and now for another example let's say if we want to place the player i still want to place the top left and now i have to figure out the x and the y position and this could actually be a really good exercise for you try to figure out what the coordinates of the player are supposed to be i know the player is in the column with the index two so we have zero we have one and we have two so the x position of this point here should be 2 times 64. and let me add x here and that is going to be 128 and now for the y position that's one we haven't done so far we can use the list themselves so we know this is list number zero this is list number one and this is list number two so our player is in the list with index number two so for y we also have to place the player at 2 times 64 which is still going to be 100 so the top left of the player should be a position 128 and 128 and this sort of logic we are going to do for every single item in this entire list so i want to go back to my level and in here i am going to create a new method let's call it create underscore map it doesn't need any arguments besides self and in here essentially i have to nest a couple of for loops and let me build this up slowly first of all i need 4 row in world underscore map and now let's print what we get so print row and i guess when we set up the class we can call this method so in here let me add another section and let's call it sprite set up and what i want to do is self dot create map so we're just calling this method here and now if we run out of this we are getting an error that world map is not defined for the simple reason that i didn't import the settings so from settings import star now this should be working there we go so now we still can't see anything but now we have printed essentially the entire map that we can see in the settings so the same map we can see here pretty good start although not particularly helpful because there's a really important thing i need to get here that for each row i need to know the index because that is going to be the number i will multiply with the tile size to get the y position so besides the row information i also need to know what index it's on and this is information i am getting with the enumerate method so enumerate and we need row index and row so now i can let me copy this i can print the row index and the row so now if i run this and close the window we can see that we have index zero then the first row index one and then the second row about the first row the row of the index one let's put it this way and this is really important information because this entire row here i want to multiply for the y position with zero times 64 which is going to be zero but for the second row or the row of the index one we want to go with one time 64. so that way there's always going to be a 64 pixel offset between each row and all right now we have our row and our row index so that is going to give us the y position but from that we also need the x position so this is going to be another for loop so let me go back to my settings essentially we went through every single list with this for loop and we got the list and the index now what we want to do is that inside of each of the lists we want to look at each of these x's and then figure out what the information is so what's inside of the string and what index this string is on and that way we're going to get our x position and this is going to look very similar so for let's call it call index and column in enumerate and now it's going to be the row and that is literally all we are going to need for the basic setup so this is going to cycle through every single item so every single x empty string or p inside of this world map and it's also going to give us the x and the y position and i guess just for the formula now we can get an x and we can get a y position the x is going to be the column index multiplied by the tile size and y is going to be the row index multiplied by the tile size and with that we have converted the world map into a position so now what we can do is if the column so each individual item inside of this world map so x empty space or p and use that information to create a certain kind of sprite so for example if column is going to be equal to an x then we want to create a rock and for that to work we obviously have to import the tile for the rock so from tile import tile i think i called it yeah tile and i guess what we added from player import player essentially all we want to do is if we have an x we want to create a tile and the tile has two arguments we have to figure out we need a position and the groups so let me copy them and the position we already have that is just going to be a tuple with x and y and for the groups all i want is a list with all the groups this one is supposed to be in let's say for now it's just going to be self dot visible sprites so we can see them but later on there are going to be more groups in here and with that we have the basic setup this is not looking bad at all so first of all let's run out of this to see if we get an error and we don't that's generally a good sign so now we just have to display this visible sprites and we should be good to go and i think this could be a good exercise to see if you are still following along so try to display all the sprites inside of visible sprites i hope that was a simple exercise because all we have to do is self dot visible and then we need the surface we want to draw on which in our case is self dot display surface and now let's see if this is working and it is indeed working we can see the top part of our game we can't see the bottom part but for that we are going to create a camera later on but for now this is looking pretty good and let me make this a bit smaller so with that we have our rocks next up we also want to place the player so if the column is equal to the letter p then we want to place the player so we want to just create the player and the player is in here it also has position and groups for now so let me just copy them in here and we can actually just copy the arguments from the rock and place them in here so essentially right now the tile and the player identical but they are going to become very different very soon but let's try this and there we can see our player so with that we have our basic level setup and i guess one more thing that we can do for now is that the tile for the rock should be in two different groups it should be indivisible sprites and it should also be let me copy it it should also be in the obstacle sprites i guess let me call it obstacle sprites not obstacles sprite that's very annoying to pronounce now you will not be able to see a difference but now whenever we create a tile this tile is going to be in the visible sprites and inside of the obstacle sprites and later on this will become incredibly helpful because essentially what we will do is we will check the obstacle sprites and the player and if there is any collision we are going to influence the player from that collision and this is actually something we could start working on right now so the next part is going to be about the player and the player is going to become quite substantial because well it's the main player of the game but for now we are going to focus on two things only the movement of the player and the collision mechanics and that is going to allow us to sort of run around the level already and i guess let's do all of this straight in the code that should be the easiest way here we are back in the code and i want to look at my player and right now our player really doesn't do all that much so we have to add a few more things here now first of all we need some kind of direction the player is supposed to walk in and this in my case is going to be a 2d vector so self.direction is usually a good name and what i want is pie game dot map dot vector 2 and don't forget the brackets if you leave them empty it's going to be 0 and 0. and this is going to give us a vector that is going to have x and y and right now by default both are going to be zero and what we want to do is to use keyboard input to change either of these numbers to a certain direction for example if we are pressing right then this zero for the x should be a one and then later on we are going to multiply this vector with a certain kind of player speed and that way this direction would become something let's say 5 and 0 and our player would move to the right at the speed of 5 pixels per frame so we essentially have to do two things number one we have to get keyboard input and number two we have to multiply this vector by a speed and well let's start with the keyboard input so let's call it just input needs self and nothing else as always and in here we need to get our keyboard input and i guess this could become a good exercise so try to get the keyboard input for up down left and right on the keyboard and see if you can figure this out so first of all i need to get all the keys that are potentially being pressed and this happens with pygame dot key dot get underscore pressed and now what i can do is if keys and we can check for specific key let's say i want to start with pygame.k underscore up and if that is the case i want to set self.direction.y to negative one and that's all we need now we can copy this thing and change this one to down and now y should be one and now we can copy both of them although don't forget they should be alif so right now we are pressing negative one so our player is going up later on at some point now for pressing down this y becomes 1 so our player is moving downwards however now we have a problem that let's say in our game we pressed down and then we lift up the key again our player would keep on moving down because this y being 1 sticks around because we don't change it anymore and well our play will just keep on moving downwards which is not ideal but we can fix that quite easily by adding an else statement that self.direction is going to be zero so really all we're checking is is the up key being pressed if that's the case y is negative one if we're pressing down y is going to be positive one and if we are pressing neither of these buttons the player doesn't move in the y direction at all actually i forgot direction dot y and that's it for the y direction now i can just copy the entire thing and do the very same logic for right and left let's say we want to start with right and right is going to be x and it is the positive number and if we go with k left this should also be x and it should be negative one and then direction x is going to be zero this one doesn't have positive or negative and all right with that we have our basic input so now we can give this class an update method so update self that's horrible spelling and for now i just want to get self dot input and now what i want to do back in my level dot pi i also want to update all of the visible sprites so self dot visible sprites dot update and now let's run all of the code and let's see if anything happens so we can't see anything right now but something is happening at least hopefully inside of our player and actually we are able to visualize what's happening by using our debug function but first of all back at my level when i created the player i also want to put this inside of self dot player player and the reason for that is that i'm going to use this software player quite a bit and this way i can target it directly but it is still going to be inside of this visible sprites and well now what i can do is right at the top i can from debug import so this function here and now in my run method i can call debug and i can call self dot player dot direction and now if we run out of this we can see in the top left we have 0 and 0 right now and that's our direction and if i press to the left we get negative 1 for x or positive 1 if i press to the right and if i press up we get negative one and if i press down we get plus one for the y and that way i can press in a different directions and we get different numbers so this is already going to give us the keyboard input and all we want to do is to multiply this with a certain kind of speed and that is also going to happen inside of the player so now besides direction i also want to give my player self dot speed at least for now and let's put it at 5. although be aware later on this speed is going to disappear because we will replace it with a proper dictionary of all the player attributes but for now we can work with it quite well and besides that i want to create a move method and this one itself and it's going to need the speed and in here we are going to move the player all we have to do is self.rect.let's say center plus equal self.direction multiplied by the speed and that is all we need so now i can run in the update method self.move and the speed is going to be self.speed and let's actually try this and see what happens so nothing happens if i don't press a button but if i press to the right or to the left or up and down our player is moving so this is working quite well although well you can see that the overlap with the different rocks doesn't work at all right now and we have no collisions but we can at least move around obviously we also don't have a camera so if the player moves outside the window it just disappears but that comes soon although before we get to that there's one more thing i do want to work on and let me illustrate what the problem is right now if i just move left or right or up and down we have a certain kind of speed however if i move to the right and down we are moving significantly faster i think it's quite good to see and the reason for that is trigonometry essentially that if we apply two different directions we are moving slightly faster and this we have to account for and essentially what we have to do in this player so this direction here we have to normalize it and what normalizing means is that we are changing the length of a vector to 1. and that way if we multiply by the speed it's always going to have the same speed no matter what direction we are going in and well doing that is actually super easy all we have to do is if self dot direction dot magnitude 2 that's how you spell that so magnitude essentially is the length of the vector and if that is different from zero then i want to get myself dot direction and simply get self.direction.normalize so first of all we are checking if our vector has any kind of length and as soon as it has a length we are setting the length of the vector to one that way it doesn't matter which direction it's going in it's always going to be one which down here instead number 3 is going to result in the same speed in all directions now the reason why we need this if statement is because a vector of 0 cannot be normalized pygame would throw an error this is why we need this if statement but now if i run main.pi i can move left and right still works but now if i move down now we can see in the top left we get 0.7 and that is because of the normalization but well you can see in the game now the movement looks significantly more constant so that's a pretty good start and you might have one question that in the player why do i add the speed as an argument instead of just writing self.speed now this would work but the reason why i'm not doing this is later on for the enemies we want to use the same move method so what i'm essentially going to do is i'm going to later on remove this move method from the player and put it inside of another class along with a couple of other methods actually and then both the player and the enemies are going to inherit from that class and that way i'm going to keep things a bit more flexible so both the enemy and the player can inherit from them and use all of these methods so just keep that in mind if you want to use self.speed but okay with that we have our basic movement so next up we have to work on the collision and collisions generally can be a bit finicky to work with for the simple reason that in pygame all we can really check is if two sprites are overlapping but pygame doesn't tell us where they're overlapping so let me put two sprites on the screen right now we have one sprite and one sprite slightly to the right and the bottom now these two obviously overlap but do they overlap from the right or from the bottom that's a really important thing because what we want to do if they overlap we want to place the colliding rectangle either to the right or to the bottom of this other sprite so the problem we might have is that if we get a collision from the right pie game might get confused and place the sprite at the bottom of the other sprite and in the game this would look like our players teleporting around and it might even break the entire game but fortunately it can be fixed fairly easily all we have to do is to apply each direction individually let's say we're going to start with the horizontal movement so we're going to move the player in the horizontal space check for collisions and if there is a collision we are going to move the player to the point of that collision and once all of that is done we are going to work on all of the vertical movement and collisions that way there cannot be a confusion between what kind of collision is going to happen and well that is all we need to get started so let's go back into our code and let's have a look at this here we're back in the code and i have my player class open now what i would like is to have all of the collisions inside of this class the problem is that this player doesn't know where all of these obstacle sprites are so we have to pass them into the player and this is going to happen by simply giving the player another argument and let's call this one the obstacle sprites and then in the init method i want to get myself dot obstacle sprites it's just going to be obstacle sprites and now when we create the player at the end it is going to get self dot obstacle sprites be aware here we are placing the player inside of this group and then we are giving the player this group here but just for the collisions the player itself isn't in that group that is a really important distinction all right with that we can actually create let me create the collision method in here so let's call it collision it needs self and i want to give it a direction essentially what we are going to do first of all we are going to check the direction and this one could either be horizontal and then we want to do stuff and i guess let's be a bit specific so if direction is going to be vertical then we want to do other collision stuff and let's work on the horizontal one first essentially what i want to do i want to look at all of the sprites inside of my obstacle sprites so for sprite in obstacle sprites in self dot obstacle sprites and now for all of these sprites if sprite dot wrecked dot collide wrecked and self dot rect so we are essentially checking the rectangle of the sprite with the rectangle of the player so this information is going to tell us if there is a collision between these two but we still don't know if this collision happens on the left or on the right but this we can also get quite easily because we know the direction of the player so for example if this is our player and our player is moving to the right then it would be pretty unlikely to have a collision on the left side that would be a little bit strange instead we can kind of predict that we are always going to have a collision on the right side if the player is moving to the right and then the same thing for the left side if we're moving left all of our collisions are going to be on the left as well i guess important to say here all of our obstacles are going to be static so that should make it much easier all we have to do is if self dot direction dot x let's say is greater than zero so if that is the case we are moving right and if we are moving right we need self.rect.right that's not how you spell that is going to be sprite dot wrecked dot left so now essentially what's happening here if we have our player so this again is our player our player is moving to the right and now our player is colliding with some kind of obstacle and they are overlapping right now what i essentially want to do is to move the right side of my player so this side here to the left side of the obstacle we have been colliding with so that way it looks like the player is always on this particular side and they're not overlapping and that is all we have to do with this line here so now next up we have to do the very same thing for the other side so if self.direction dot x is smaller than zero then self.rect.left is going to be sprite dot direct dot right so the exact flip side of the upper line this is then all we need for the horizontal collisions now next up we have to do the very same thing for the vertical ones and this i think could be a really good exercise for you so after looking at the horizontal collisions try to do the same thing for the vertical ones so you want to check for the up and the down movement let's try together now but first of all i want to add proper comments so this is moving left and now let me just copy the entire thing now the first two lines are still perfectly fine but besides that i now want to look at direction dot y so if direction dot y is greater than zero we are moving down and if that is the opposite way so we are smaller than zero we are moving up so if we are moving down we want to place the bottom of the rectangle at the top of the sprite so essentially what we are doing if this is our player again right now our player is moving down and if now we are colliding with any kind of obstacle the bottom of our player should be at the top of the obstacle so this line here and then we have to do the same thing for the up movement so the top of our rectangle is going to be at the bottom of the collision object and all right with that we have our collisions actually not all that bad so let me minimize this and now we have to work in this move method and essentially we have to take this method here and split it apart into the x and the y movement so self.direct self.rect.x plus equals self.direction.x multiplied by the speed and then we can do the same thing for the y so if i just left it at this and ignore the collision method entirely we shouldn't see any kind of difference and things are still looking pretty identical cool good start but now what i want to do after we are moving our player let's say on the x after we have done this i want to call myself dot collision and i want to check my horizontal collisions and let's just use one of them to see what is happening so now if i run my main file i can move to the left and i have proper collisions although if i move from the top nothing is going to happen and pie game is getting a bit glitchy but this we can fix quite easily because all we have to do is call self dot collision and now we want the vertical collisions so now if i run out of this we get very nice working collisions and everything is working just fine cool this is looking really good there are no bugs as far as i can see this is working very nicely now the problem is i can actually demonstrate this i can move outside of the window no problem so this is not ideal also the game doesn't look as good as it could because there are no overlaps so for example if i'm on top of a rock my player stops where the rock begins but ideally there should be a tiny bit of overlap to give the illusion of depth which is what we are also going to need so let's work on these two bits now to achieve both of these things the camera and the overlap we essentially have to create our own group or at the very least we have to take a spread group and change some key functionality and that is very neatly going to bring us into a bit more of an advanced concept inside of pygame so far if you follow this channel we only ever used a group to place a sprite in there to update them and to draw them but you can totally take a sprite group and rewrite some core functionality but to do that we first have to understand what a group is actually doing and fortunately it really isn't all that complicated essentially all that the spread group really does is that it stores a ton of different sprites then it can call the update method and all of these sprites and we can also draw all of the sprites and all that is really going to happen inside of a draw method of a group is that we are going to call blit with the sprite and the rectangle of whatever sprite we have inside of that group so with that knowledge we can totally override key parts of a group or give it extra functionality here i'm back in my code and i want to go to my level and i want to change this visible sprites class to a custom made group and let's create that class in the same file i think that makes sense and i'm going to call this new class y sword camera group and it's going to inherit from pygame.sprite.group and the naming here has two key parts number one the more obvious one the camera group so this spread group is going to function as a camera and that's the part we are going to work on in just a second the other part the y sword means that we are going to sort the sprites by the y coordinate and that way we are going to give them some overlap now in here we are going to need a couple of different things first of all as always we need a dunder init with self and nothing else and let me start with a general setup of all the stuff we are going to need now first of all as always like with the sprite we need super ideally spelled correctly that tends to help dot init no arguments are needed now once we have this we can actually replace our visible sprites with this group so why sort camera group and since we haven't replaced any functionality yet and we've initiated the original class this should still work let's try it and we still get the very same functionality everything works as intended so at the very least we didn't break anything yet but with the setup we can make some simplifications for example what we could be doing let me actually go to the display surface and let me copy this line here just to illustrate what we can do a very simple example now with our display surface inside of our class so now i can create a new let's call it custom draw and itself and nothing else for now and really all we need to create our custom draw is for sprite in self.sprites and don't forget the brackets and now we can get all of the sprites and now all we have to do is self dot display surface dot blit and we need sprite dot image and sprite dot rect so this is essentially what a normal sprite group is going to do and now in our run method we can replace our draw from the original group with custom draw and now we don't need any arguments because we already have the display surface and let's run this and it's still working just fine except now we're using a custom draw that is going to give us significantly more power and i guess what i can do we can get rid of this debug it isn't useful anymore now we want to use this for two specific purposes number one we want the camera number two we want some overlap between the different sprites in the y direction and let's start with the camera that's the more important bit and the logic to make the camera work is actually surprisingly simple and all of it happens in the custom draw but by default we are always drawing this bright image in the same position as the sprite rectangle but we don't have to we can totally give this bright rectangle a certain kind of offset and this is what we are going to use for the camera so really all that's going to happen in practice when we are calling blit on the surface we are still going to keep our sprite dot image but now for the sprited rect we are going to add a vector to give them a certain kind of offset and this vector is essentially going to be our camera because it's going to give us control where the sprites are going to be drawn and then really all we have to do is to get the offset from our player and connect this to this bright rect vector and once we have that we are good to go essentially we are going to give the offset of the world to wherever the player is going to be and well i think this makes much more sense once we actually implement it so let's go back into the code and here we still have our y sword camera group and what i want to achieve is that the player is always right in the middle of the window but that's going to come in just a second first of all let me illustrate what i mean with the offset essentially all that's going to happen is we're going to create a vector let's call it offset and this offset is going to be pygame.math.vector2 needs to be capitalized and by default is going to be 0 and 0. and this vector we are going to add to our sprite rectangle so all we have to do in here let me create a new let's call it the offset rectangle and this offset rectangle is going to be the sprite dot direct dot top left and then plus self dot offset and that way we are going to get a new position it's not a rectangle anymore but well high game is happy with a tubal so this is still fine so now we can do is put this offset rect actually let me call it offset position that's going to make more sense so offset position and now anytime we have any kind of offset we are going to add this to our rectangle now right now this is going to be zero so we should not be seeing any kind of change so let's run main.pi and we still get the same outcome but what we are now able to do is if i give this vector some starting positions let's say 100 and 200 now if we run out of this our entire game is slightly offset so this is the offset we have just given it so what you can see here is that this distance is 100 and this distance is 200 so essentially our game itself didn't actually change any kind of position we are just drawing all of the elements in a different spot and the distance to that spot is determined by our offset so this is working really well now next up what i have to figure out is how to connect this offset to my player and since i want the player to be exactly in the middle of the screen i first need half the screen width and half the screen height and we can do this in the init method so let's call this half with and all we need to get this is self dot display surface dot get underscore size and for x we need zero and we want to floor divide this by two so we are getting an integer now we can do the same thing for the height and all we have to change is from the tube we get from get size we need the first one and that's going to be the y one so now we know how much distance we want from the left and from the top so all we have to do in our custom draw i want to get another argument and that is going to be the player so when i call custom draw up here i want to pass in self dot player so now i can access the player and get the player position and let me add another comment here and let's call it getting the offset and in here i want self.offset.x and then dot y so now we have to figure out these two positions and unfortunately we couldn't just add player.rect.center x and player.rect.center y although it would be nice and simple actually let's try and see what happens if we just use those two numbers so now back in my main file now if i move the player we get something but looks a bit weird but we do get something that's at least a start and essentially all we have to do is from this number subtract either self dot half with and self dot half height so now we are getting some kind of weird outcome and i might be able to see the player i could see her there for a bit so now the camera movement is a bit weird and the reason for that is that this plus here should be a negative and now let's try this again it should work and there we go this feels significantly better and with that we have our offset and if you're really interested in the math here i would recommend to go over the geometry a couple of times it is a little bit weird but once you go over it it should make sense and probably just draw it out a couple of times eventually it starts to make sense but that is literally all we needed for the camera movement so now we have covered the first part we have a proper camera movement so i guess now we can start working on part number two the overlap and this one consists essentially of two things the first one is a hitbox for all of our sprites so right now for example for our player the hitbox is the entire image but i don't want that to be the case i want the hitbox of the player to be slightly smaller than the original image and these parts are going to be the overlapping parts but this by itself wouldn't be enough because our group right now doesn't know what elements to draw on top and what element to draw on the bottom this is going to be another part we have to make ourselves it's not actually that difficult but it's something we have to implement but i guess let's go through it step by step and let's first of all start by creating all of our sprites a custom hitbox so here we are back in the code and i want to start with the tile that's going to be the easiest one and right now we have our rectangle so this is always going to be the full size of our entire image i want to give it another attribute and that is going to be self dot hit box and the hitbox is going to be essentially the same as self.rect except now we want to change the size and this happens with inflate and what inflate essentially does is it takes a rectangle and it changes the size so in my case really all i want to do is if this is my original rectangle then i want the hitbox to look something like this so we have the same width the same center but the top and the bottom are a bit shorter and that way later on the player could be standing behind this for example and that's really the entire idea of all of this and inflate needs two arguments one for x and one for y now my x can just remain zero but for my y i want to have a specific number and let's say just to get started let's go with negative 10. oh and by the way this is going to keep the center point at the same position so let me draw all of this again this is our original rectangle and now our hitbox is going to have the same center but now on the top and the bottom we are going to have a 5 pixel because we specified negative 10 up here and negative 10 makes the entire thing shrink by 5 pixels on each side and now we have to do the very same thing for the player and let me do it right below the rectangle so self dot hitbox is going to be self dot wrecked dot inflate and for my player let's say for now i want to go with 0 and since the player is a little bit taller i want to go with negative 26 and now let's run the code and well this shouldn't make any difference for now but at least the code isn't crashing so that's a good start but now essentially what i want to do i am not going to move the rectangle anymore instead i'm going to move the hitbox and i'm going to move the hitbox and check collisions on that hitbox as well and after all of that is done i'm going to put the center of the rectangle where the hitbox is going to be so that way the rectangle always follows the hitbox and that way i can get all the collisions with the hitbox and have some overlaps but then draw the player in the correct position so essentially what we have to do let's go with move first and let's get rid of this comment we don't need that one anymore so instead of self.rec.x we want to move self.hitbox and we want to move both x and y and at the end of all of this we want to get self.rect.center is going to be self.hitbox.center and now what we can do that instead of checking the rectangle of all of the sprites we want to check the hitbox so this should be hitbox and we're also not going to check the rectangle of our player but the hitbox of our player and this is going to happen for basically all of the rectangles we are going to replace them with the hitbox so this should be hitbox this should be hitbox this should be hitbox hitbox hitbox and finally hitbox and now let's see if this is going to work so now we can indeed see some offset so right now our player is behind the rocks and this is looking really really good the problem we have now is that our player is always below the rocks so no matter where we go oh except here because these rocks were created earlier in the level setup so these rocks are behind the player because they created earlier in the code but these were created after these were created after and further down here all of these rocks are above our player so this is going to look kind of silly but we are very nearly there so we are making some definite progress there's only one more thing that we need so right now we have a custom hitbox for both our player and for our tiles now the last thing we have to do in our ysort camera group we have to order our sprites so we have to tell it when to draw each of these sprites and right now they are being ordered by the time of when they are being created this happens here some of the tiles were created before the player but some tires were created after the player was created so those tiles would be on top of the player whereas the titles created before the player was created they would be below the player and in most situations this really doesn't matter but in our case we don't want to order our sprites by that logic instead we want to order our sprites by the y position and essentially the sprite that should be drawn on top should be the one with the highest y position because if the sprite is a lower wide position than another sprite then the sprite that should be behind or high up on the screen should be behind that other sprite in godot for example this is just being called y sword and this is basically what we're implementing ourselves manually right now and the way we are doing it is by using the sorted function and let's do this straighten the code so here right now we are just going through all of the sprites but this i don't want to do anymore instead i want to go with for sprite in sorted and sorted essentially takes two arguments first of all it wants a list of what we want to sort and this we do have it's just self dot sprites and again don't forget the brackets it's very easy to do and next up it wants some kind of key and the key essentially going to be by what kind of metric we are going to sort all of the sprites now in our case this should be the y position of each of the sprites and to get that we basically need a lambda function so lambda and i want to look at this sprite and all i want to return is sprite.rect.center y i guess let me know if you want a specific video on the sorted function once you're nested lambdas it's actually pretty simple but now we have overlaps so let me run the code again and now we are still behind the rocks but now if i go a bit further down now we are on top of the rocks but if we go behind them we are well behind them and all of our collisions still work just fine and all of the overlapping works really nicely and this is going to make our game look really good so cool this is working exceptionally well nice there are no bugs so anything this is all working good cool and with that we have a basic topdown game with a camera collisions overlaps and all of the good stuff now i guess for the rest of the game we are just going to add more and more visual detail and enemies and extra stuff to it to make all of this into a proper game but at this stage you already have the basic logic you need to really create any kind of top down game i guess next up we can start working on importing the actual map to make this entire thing look significantly better now for the graphics we are going to need quite a few different things for now we only had our world map and we spawned either a rock or player which really wasn't ideal but to get the actual graphics of the entire game we are first of all going to need significantly more data and that is going to be way more data than i could assemble by hand so we have to use a program and the program that i am using is called tiled which is super useful completely free and it allows you to assemble graphics and let me actually show how this looks so here we have the tiled editor and right now you can see our entire map and this thing i essentially created from these tiles on the right so here we have all our floor tiles here we have the details we have flowers and we have trees so i could for example literally just pick a tile and draw over this thing and expand it and i have made an entire tutorial on how to use tiled so for this video i am not going to go over it and i will keep the map i have already created so this thing took about an hour possibly a bit more to assemble as a whole actually let's go through the entire thing layer by layer and then i can explain how this comes together so right now we have nothing and the bottom layer looks like this this is going to be our ground and on top of that we have some details they will be integrated into the ground as well and essentially what i'm going to do i am going to export this entire thing as one image and this one image will be below all of the other objects so even below the player and then if we move this map it looks like our player is moving on top of an actual surface but in reality we are just moving an image now on top of that something we can't see but that's really important is floor blocks and flow blocks if i make it visible is going to be our constraint that our player cannot walk outside of the map so all of these red squares are going to be obstacles that the player cannot cross and they are blocking the entire map so the player cannot leave it and in the game they are not going to be visible so let's hide them now on top of that we have our entities the blue p is our player and besides that we have all of our enemies now then we have grass and the grass is well the grass and finally we have the larger objects and those are of the statues the trees the rocks all of that kind of stuff and importantly all of the objects the grass the entities and the flow blocks have to be placed by going over the entire layer so we have to circle through the entire layer like we have done for the world map and place all of these elements and to make that work in our game we will later on have to import quite a few different things for example we have to import the graphics for each individual tree and rock and statue into pie game same for all the enemies same for the player and there is going to be a lot of importing and also when we export these data sets we get a csv file which stands for comma separated value which effectively is a long list with numbers and these numbers tell us where stuff needs to be and those numbers we also have to import and all of that gets quite complex so this section will be quite heavy on managing all of that data but i guess let's go for the step by step and let's start with the easier bit and that is going to be the floor and for that we are just going to be importing an image and placing it below every other element and then we are good to go here we are back in the code and i want to go to level and all of our drawing is happening in this section down here so essentially this part here draws all of our elements and we kind of want to draw our floor in there as well the problem is that the floor is slightly different from all of the other elements so we couldn't just add the floor to the sprites and call it a day for the simple reason let me actually draw this that right now we are drawing all of our elements by their y position so this is essentially how our drawing is going to work so the greater of a white position an object has the higher up on this thing is going to be drawn and we are looking at the center of the y position now the problem with that is that our map is always supposed to be on the bottom so our map is always supposed to be here it needs to be below all of the other elements otherwise it wouldn't be a ground or a floor so we have to place this in here anyway and if we didn't do it it would end up somewhere let's say here and since it's a giant image it would essentially cover up the entire field and we wouldn't be able to see anything so we have to make sure it's below all of the other elements so what we are going to do to this group we are going to add a surface and a rectangle for the floor specifically and that is not going to be a sprite but then in this custom draw we are going to draw it and i guess let me implement this straight away so in here creating the floor and for this i need two different parts first of all i need the actual image of the floor so self dot let's call it floor surface and this is just going to be an image so pygame.image.load and this i need to go up i need to go to my graphics in my graphics there's a folder called tilemap and in tile map we have ground dot png and this we also want to convert but we don't need convert alpha this time and next up since we do want to place it i also want to have self.floor underscore rect and let me call it surf instead of surface so things are lining up a bit nicer and this is just going to be self dot floor surface dot get underscore rect and the top left for now is going to be 0 and 0 but this doesn't actually matter all that much since we are going to change it well right now and really what we have done so far in our custom map we have created an offset position and the offset position came from the top left of the rectangle and the offset and the offset we got from the player so now what we want to do is the exact same thing except now we only want to do it for the floor surface and not for all of the sprites and this could be a pretty good exercise for you so try to implement the offset for the floor and then draw the floor before the for loop for the sprites now first of all let's add another section and let's call this one drawing the floor and first of all we are going to need a floor offset position and this we get in the same way that we have used just before so we want self dot floor rect dot top left and then minus self dot offset and that is going to be all that we need so now we can run self dot display surface dot blit and self dot floor surface and i call this one floor offset position and that is literally all we needed so let's run this and see what happens and there we go now in the top left of our world we have oh well below our player we have the entire world map now right now we can't really walk over it and we can well we can kind of walk over it but you get what i mean but right now all of the rocks don't line up at all anymore so we have to make a few more changes but at the very least for now the basics are working so this is quite nice and now next up we have to work on all of the other objects and this one is going to need a little bit more work but i guess we can start with by removing the old stuff and just placing the player somewhere in the middle of the screen and this is going to happen in our level and let me minimize our camera group so we can focus on this a bit more so right now we are using all of this stuff here to set up our world and this worked so far but now we want to get rid of it so let me comment out essentially all of this except i want to copy the player and now i want to place the player somewhere on the map let's see what works let's say 400 and 300 and that might be a good position yeah okay i probably need larger numbers let's say 2000 and 1500. we are almost there let's say one thousand four hundred thirty because that way we should be on the path and we make sure we are not going to hit any other tile so our player isn't going to collide with anything by default but now we can move around our entire map there are no collisions yet but well we have a much better system so now essentially all we have to do is to reintroduce all of the layers and then work with them although they just might be a little bit oversimplifying things so let's go through what we are going to do first of all we have to make our tile a bit more flexible because so far the rocks are the only tile we could have but in this section we have many more and many more differently sized tiles and we also have some tiles that shouldn't have any graphic whatsoever for example the tile for the collisions that limit our player they don't have a graphic but since they are also sprites they will need some kind of surface so essentially our tile class needs to be able to accept any size graphics and also be able to accept no graphics at all and i guess let's implement this and all of this is going to happen in our title class or well the tile file and this is going to get two more arguments the first one i want to call sprite type because later on we do want to have a bit more control over what kind of sprite we have and besides that i also want to pass in a surface as an argument and this could then be anything but if we don't pass in any surface this class should generate its own surface so as the default argument here i want to have pygame dot surface so this is just going to give us a black surface that we can work with and the size of that should be tile size and tile size so by now since our tile size is 64. the one we determine here if we don't pass in the surface as an argument we get a tile size of 64 by 64. and then for the image this is then going to be what we get and besides that i also want to get self.sprite type is going to be sprite type and this later on for example could be an enemy or could be invisible or it could be any of those things and that's going to allow us to target in a bit more detail what's going to happen to any of these so we are using both groups and the sprite type to determine what a sprite is going to do in the game for example later on if the player attacks grass the grass should disappear immediately but if we attack an enemy we should just reduce the health of the enemy but both of those are going to be in essentially the same groups this is for now all we need for our title class now we can go back to our level and what we first of all have to do is to import all of the layouts because right now let me open them in the folder so in our project we have a map folder and in here we have six different files we don't need all of them so map floor and map details we could just ignore but floor blocks we do need to import and by default we couldn't work with a csv file so we have to figure out how to import this kind of file and then convert it so it looks more or less like this world map so that we can work with it and this i still want to do in my create map and since we have a couple of different files i want to turn this into a dictionary and in here let's start with the easiest one the boundary so this is going to be what limits our player and in here essentially what i want to store is this kind of world map except for all of the boundaries so i have to write a function like import csv layout and this one should then get the path to my csv file something like this so what we have to do is to actually write this function and this since we are going to be using it quite often i put into a separate file so let's create a new file and i save this one as support dot pi and in here we want to define import csv layout and it needs a path and nothing else and just to demonstrate what i'm doing while we're doing it let's call this function and let's see what it does so right now if i press pass we run this file nothing is going to happen because pass doesn't do anything now the first thing that we have to do is to figure out how to read a csv file and fortunately python has a module just for that but i don't want to import all of it instead i want from csv import reader and this is allowing us to read a csv file and now to use it we first have to open the csv file so with open and we pass the path in here and then python wants a name for this file and i called it level map and all of this so far could work for any file so this could also be a text file and unfortunately right now you wouldn't really be able to see anything so if i print my level map all you would get is something in our memory not particularly helpful but this thing we now have to convert with our reader to something actually readable and the reader needs two arguments first of all the file we want to work with which in our case is level map and besides that it also wants it delimiter and a delimiter in our case is a comma and what it means is what separates each individual entry in our file this could also be a space for example now this information is going to return another value that i'm going to store as layout now unfortunately still if i print the layout now we get a csv reader object so at the very least i guess we know we have a csv object but that's about it but now comes the actual part where we get to see something because now what we can do is for row in layout we can print the row and now we can see the actual files so in here we can see a whole lot of negative ones but all the way at the top you can already see we now have a list so here the list starts and the list is ending here and wherever we have a negative 1 there is no tile however if we have 395. so any of these numbers here there should be a constraint for the player so the player wouldn't be able to move over this tile and it's really hard to see right now but if all of these tiles were on the same line they would in my tiled editor have the same shape as this red line here but in our case since the line isn't wide enough this is really hard to see but now all we want to do is to put all of these lists into a separate container which is going to be another list so let's call this one terrain map and this one is just going to be a list and now for each row that we get from the layout i want to append this to my terrain map so this could just be row although just to be sure i want to convert this row to a list and now the last thing we are going to need is to return that terrain map and now whenever we get this import csv layout we can put all of this for example in a print statement print it and now we get a list that contains a whole bunch of other lists that give us the layout of our map so that is going to be quite useful and now let's actually go straight ahead and use it so in my level dot pi i now have the boundary for my floor blocks as i called it which is just going to be my boundary now i actually want to place them in the same way i have used it earlier with the tile map but what did i call it my world map so now my boundary has the same kind of layout as this thing except it's significantly larger so let's work with it and since it's so similar we can reuse all of this code except there's going to be one modification i want to place all of this inside of another for loop and what the other followup is going to be let's call it style and layout in layout let's call it layouts that makes a bit more sense dot items and don't forget the double colon so essentially the style is going to be boundary right now and the layout is going to be this csv map and right now we only have a single one of these so it doesn't make too much sense however later on we are going to add more and more data in here and then this followup is going to make significantly more sense so that way our code is nice and scalable but now we are still looking at the y position we get the x position and we are converting all of this into an x and y position so now we can use this quite well and all we have to do now is if the style is equal to boundary then we can create a new tile so we can now create a new tile group and let me copy all of the parameters place them in here and let's go for them one by one actually or actually even better try to figure this one out yourself to place in all the proper arguments for each of the parameters to place the boundary for the world map all right let's go through it one by one first of all position that should be the easiest one because in here we just want to get x and y and that's just going to be what we created up here and actually this should be indented one more line next up we want our groups and for now let's place let me copy from the player i want the visible sprites and i want the obstacle sprites then we need the sprite type and the sprite type i have called invisible because they're not supposed to be visible later on and then finally we have our surface and this one we can just ignore since it's then going to use the default argument and all right that is then going to be all we need for the boundary and let's actually see what happens so we don't get an error we do get an error and the error we're getting is import csv layout is not defined that is an error i tend to make very often fortunately it's quite easy all i did was i forgot to from support import star so that this function is another file and we didn't import that file now let's try this again and now i made another mistake the obstacle sprites are not defined and that is probably because i forgot the self there we go and now if i run the code we can see something strange so at the very least we get some kind of collision although something is definitely gone wrong here and i think i can already tell the problem so right now when we are calling this boundary our boundary is slightly different compared to this map here because for boundary there is no empty space we get a negative one actually in my support file let me open it again so let me copy this one and let's call import csv layout and let's print it so what we can see here is the number 395 a whole lot of time and besides that a lot of negative ones and what pygame did it always put a block where we have a negative one but we only want to block at 395 and that was different from our world map so let me get rid of this one again so what we want to do in here when we go through the column we want to add another if statement that if our call is different from the string negative one and only if that is the case we want to do anything in here and negative one in a tiled export means there's not supposed to be anything so this negative one would work for any kind of layout so now let's try this again and let's see what we get we still get a giant block that seems like something is going wrong with the position so let's investigate what the problem is and i just realized the problem is i am very very stupid well so in here we are still using the world map we are not actually using the layout so that may have been a problem so now let's try this again that should fix the issue so now if i go to the right at some point there we go now we have the black coastline that we can't walk over and we still get our overlap that one works pretty well cool and now we are not able to leave this game anymore but we can still use something like a bridge and we can move on this tiny island and obviously right now we don't want to draw any of these black tiles and to get rid of them at least in terms of visibility we can just remove the visible spreads group and now let's run this again now we can't see them anymore however we can still not move over into the water so this is all working very very nicely this is a very nice upgrade cool okay that took way more time than i expected but well here we are all right so for now we need two more objects we need the grass and we need the objects so all of the trees and the statues and stuff like that and for that first of all we have to import two more csv layouts and let me just copy them that's going to save me a bit of writing so one is called grass and the other i have called object so essentially what we need to do with those two is if this style is going to be grass let me just add a comment create a grass tile and if the style that's not how you spell that if the tile is object then we want to create an object tile and we do have most of it but we don't have the most important part we don't have the graphic for either the grass or any of the objects what we have right now is two folders one with three different grass images and another folder with like 20 different objects and right now those really aren't usable and i really do not want to import every single one of these images individually so i want to create a function that does all of this for us and this is also quite easily done let me add a path in here so python doesn't throw an error and in my support file besides import csv layout i want to create another function and i call this one import underscore folder it also needs a path and this one is going to go through a folder import all of these images as a surface into pygame or well into our python code and there's one module that we will need for this it is called the os module and i don't want to get all of os instead i just want to get the one that's called walk and walk just allows you to walk through the file system that's really all it does and let's actually check out what it is doing so for data in walk and now we have to add a path and let me use the path for the grass objects that one is looking like this and now let's just print our data and now let's run import folder oh i made a mistake the import grass should be what we pass into the function and then walk gets the path from the parameter that looks much cleaner now let's run this and now we are getting three different bits of information first of all we get the folder name the first bit here in our case we just don't care about it and we already have it anyway so this one we could just ignore next up we have an empty list this one here and if there was any folder inside of this folder this list would contain the names of these folders in our case we just don't care about it now finally we have the list of the images or well the files inside of this folder and this is what we care about essentially what we want to do let me clean this up a bit basically what i want to do is i want to combine this path here with any of these names so these three names and that is going to give me a whole file path to that image from my code wherever i run it in my setup and once i have that i can just import this file as a surface so i would just loop over all of these names turn them into a full file path and then import all of this as a surface and that is what we are going to do so first of all let me rename the data and split this into three different parts now for the first one before the name i'm going to use an underscore since i don't care about the information for the subfolders i can use a double underscore because i don't care about this either now finally i have the let's call it the image files this is what i actually care about and this is still going to be a list so i want to split this up so i need another for loop so for image in img files and now if i print each individual image we get the list ideally of our grass images so grass one two and three and now what i can do with them is i can turn them into a full path so right now all we have is strings that we can combine quite easily and what i want to do is to get my path on that i'm going to add the string of a forward slash and to that i'm going to add my image so if i print this full path i have a nice path to my image that i can use to import this image so literally all i want to do let's call it my image surface i want pygame.image.load i need my full path and don't forget convert alpha and spelling this correct also helps and this is then going to be our image or our surface now finally we want to return this entire list and right now we can't really do that so what i usually do is i just create a surface list that by default is empty and then as soon as we create this image surface we get our surface list and we append this image surface and at the end of all of this we are returning the surface list and that way let me print what import folder gives us ah we get an error pi game is not defined because we need to import pygame and i suspect we get another error aya right now we haven't initialized pygame.display because we're only running this file by itself so i can't really show this right now but fortunately when we are running our level we have initiated pi game this happens in the main file so this happens here as a consequence we don't have to worry about this error you're gonna see in a second what this means actually let's import all of the graphics that we need and since we have more than one i want to put this into a dictionary as well so we have graphics it's going to be a dictionary and in here for now we only have the grass and for the grass i want import underscore folder and i have called it this one here and now we can actually print our graphics so let's run all of this we get our file no error and now we can see in the dictionary we have grass and we have three surface files inside of a list that's exactly what we wanted so all right you can get rid of this and now we can actually work out our grass tiles and essentially what i want to do i want to pick a random image from this folder or from this list and then create a tile with that random image and this could be a really good exercise for you so try to create a tile with the grass and the sprite type should also be grass and see how far you get all right so first of all let me get rid of all of this and the first thing i want is to get a random grass image so we want to pick one item from the list and to do that we need the choice method which we get from random import choice so now in here we can just call choice and get our graphics and i want to get the grass list and once we have that we can just create another tile now the x and y position is still going to be x and y that one didn't change but now for the groups we want self dot visible sprites and self dot obstacle sprites because the grass is supposed to be visible and collidable and finally i gave those a type of grass and now this should be working and oh yeah i know what i forgot so we can see something but we have a problem and look at this for a second and just think about what i forgot the important thing i forgot was the actual graphic so random grass image now let's try this again there we go this is much better so now we have our grass image and they are collidable they are very much visible and this is working really well so now we have our grass this is working really nicely i think down here we have quite a few more there we go this is coming together quite well cool so with that we have the grass and then finally we need the larger objects and we already have up here the object in our layout and besides that we are also going to need the graphics and this one i called objects and then here we just want to get the import folder and the file path towards it i have called this and with these two things we have a layout and we have the graphics so we can start working on actually creating these tiles here but now we do have a bit of a problem because for the grass tiles we could just select a random grass tile from the list for the objects we cannot do that because each of these objects is one specific thing that we couldn't just randomly pick now fortunately that isn't too much of a problem and let me open tiled again to explain why so here we have tiled and all of the objects are in here and if i click on one let's say this tree stump this is the id of zero if i go to the next one it's the id of one then two three four and five and so on and essentially what tiled is exporting is this id and this is really useful because we can use this id to import the index of the image in that folder so when we import the images they are in the list so they can be indexed and the way we're importing them right now is by the name and since you can see it in the image the name is 0 1 2 and so on so the naming here lines up quite nicely with the file name and that way we can use the id as an index and this means all that we have to do to get our surface we have to get our graphics and in here we want to get the objects and this is then going to return a list and from this list we want to get the index and the index we get is this column here so this is the column we want to use for indexing now right now this column is going to be a string so we want to turn this into an integer and now we can just use this surface so i can just copy the tile we again need x and y then we also want visible and obstacle sprites so i can just copy them and for the type i call this one object and finally for the image we want the surface and that is all we needed almost at least so now if we run this we can see some trees so this is coming together very nicely the problem is this isn't working perfectly so for example here you can see the flower and the column on top of each other and i think further here that this one's actually working quite well um i guess if i go in here you can see a couple of overlapping things that don't look as good as they should be oh especially down here you can see some problems and the problem is this in our tile.pi right now we are basically assuming that all of the files or all of the images are 64x64 pixels but the larger objects really aren't that and let me explain this issue entitled now here we can see the thing that we just saw doesn't work in code and the problem is this that in tile we always assume we have a 64 by 64 tile grid and this works for most of the objects like the grass for example where it doesn't work is with these larger objects so this column here for example is much larger than 64 pixels and we are always placing the top left of this column but since this is larger than 64 pixels we are placing this column somewhere here on this line so we are placing it here as a matter of fact all of these larger elements are a bit further down than they are supposed to be but that's something we can fix quite easily so let me go back in the code and when we are placing the rectangle now we have to adjust things a tiny bit and essentially what i want to check if this bright type is equal to object because those are the only things that are going to be larger than that and these we get from object here and we're placing them in here and that way we do have access to them and if they are an object we want to do an offset but if they're not an object we just want else else and do the thing we have already done and the rest can stay exactly the same now if we do have an object we still want to get self.write and we still want to get self.image.get underscore act and we are still placing the top left but now we are still placing it x and y as well and the x stays exactly the same so this is going to be position zero so we are splitting apart this position into the first and the second integer and now for the y we have to make a tiny adjustment i guess we still want the first index but now we have to reduce a tiny amount from that and here our life is going to be made a tiny bit easier because all of these larger objects have twice the height of all of the other elements so really all we have to do is to subtract the tile size from it here is a normal tile it's 64 by 64 pixels and the larger tiles look either like this where we have 64 by 128 or we have even larger tiles that look something like this well we have 128 and 128 and the problem that we faced is that all of these tiles are being offset over here so the position we want to place is actually this one instead of this one so what we want to do is to just move any of these larger objects a little bit further up and since they're always the same height with 128 pixels we can just move them up by 64 pixels or exactly the tile size which is making our life significantly easier and all right that's all we needed so now let's run this we don't get an error and that is looking quite good i can't see any overlaps this is also looking really good and yeah i think we have a pretty nice looking map that is coming together very much so all right with that we can get rid of these old comments and we can get rid of in our settings of the world map we don't need it anymore so i guess with that we can start working on a better looking player so we have the different kind of animations and that is going to be the next section so let's talk about the player animation and to make our player animations work we have to figure out what our player is doing at any given time so what the status of the player is and at the end of the day there are going to be 12 different states our player can have we can either walk in any of the four directions we can be idle in any of these directions or we can be attacking in any of these four directions so it's going to be 4 times 3 and that's how we get to 12 different states and in the most basic sense all we really have to do is whenever there is a certain kind of state we are going to play a certain kind of animation that's the easiest way to think about it but that's still quite a bit away first of all we have to import all of these graphics and we also have to give our player the ability to attack and to cast magic and i guess we should work on those two first here we are back in the code and i only want to work on my player we don't need anything else right now as a matter of fact let me minimize the functions so it's a bit easier to see what we are doing that makes a bit more sense first of all in my input here we are getting the input to move around and i want to get a few more and let me actually add a few more comments so this here is the movement input and down here we have the attack input and then a bit further we get the magic input and for the attack input we can still use our keys so if keys and in my case i use pygame dot k underscore space so the spacebar means that we are attacking and for now if we are attacking let me just print attack and now we can do the same thing for the magic i can just copy all of this and and for magic i use the left control which is triggered with lc tr so left control and if that is being triggered i want to cast some magic and now if i run this we don't get an error if i press space we get attack if i press ctrl we get magic so that's a good start but there is a bit of a problem right now let me run the game again so if you press attack we attack multiple times same for the magic and the reason for that is that our game runs at 60 frames per second if we press space once pygame checks for this multiple times a second and it finds the bar being pressed for longer than a few milliseconds that's why it triggers it multiple times so for these two if statements we have to add a timer that can only be triggered every few milliseconds so in our player let me add another section or it's our first section here actually and let's call those um i guess we can call them movement let's just give it a movement and we can put them up here and in here i also want to create a few more variables or attributes first of all the first point is called attacking and by default it's going to be false next up i want to have a self dot attack cool down and let's put this one for now at 400 i think is a good number and finally self dot attack time and by default this is none or could be zero doesn't really matter and these three numbers we are going to use to create a timer so what i want to do whenever we call keys for attacking and for magic we also want to check that our player currently is not self dot attacking and this we want to do for both magic and attacking and those two get the same variable for the timer because i want that to be an offset that the player can't cast an attack and magic at the same time or really fast after each other now once we are calling either of these i want to set self dot attacking to true and let me copy it to both and now what we should be seeing is that we can attack or cast magic once so let me press space for attack and now i keep on pressing space or control nothing happens and there shouldn't be anything happening because now attacking is true so this if statement cannot trigger anymore but obviously eventually we do want to attack again so we want to create another method that i am going to call cool downs needs self and nothing else and in here we are going to have all of our cool downs and let me explain the logic so i explained this a couple of times but the problem is that high game by itself doesn't have a timer function so we couldn't just tell pygame to do something in half a second it just doesn't have that and also i should check my spelling so instead we have to create our own timer which we can do and essentially what we want to do so here we have the timeline of our game so this is time 0 and this is time x this is the maximum time once we close the game and we want to check two things we want to check when our attack has occurred so let me use this in a different color let's say our attack occurred right here at around let's say milliseconds at 700. and now from this point we want to continuously measure our time so as the game goes on we want to check what the time is so for example here we could have 800 here could be 900 here we could have a thousand and here we could have 1100 and what we basically want to check let me write it so 1100 now what we basically want to check is this distance here and that is going to be our timer i have actually made a video specifically on timers but really all we are checking is one point in time and then we continuously check the time and if difference between our current time and our starting time is greater than our cooldown in this case then we want to trigger whatever code we have so i hope that makes sense we need to get our current time and stored in the variable and to get our current time we need pygame dot time dot get underscore ticks so this is going to continuously measure what our time is and the other thing we need is when the attack actually occurred and this we can get up here so what we want to do in here is self dot attack time this is going to be pygame.time.getticks as well now a really important thing here is that this sketch is only called once and once only because this if statement is only going to be run once however this get ticks down here will be run basically infinitely because there's no restriction on it and we're going to put this cooldown in the update method in just a second so to get ticks down here is being run multiple times they get ticks up here is only run once that's how these two functions differ okay but now all we have to do is let's say if self dot attacking because that's the only reason why we reject this if our current time minus self dot attacking time is greater or equal than self dot cool down should just be cool down did i make a typo again oh i put this down as attack cooldown so let's call it attack cooldown and if that is the case self dot attacking should just be false again and that is a very simple timer and later on we are going to add a few more timers in here for example when the player is vulnerable or when the player is switching a weapon but this is the most basic one and now all we have to do let's put it right on the input self dot cool downs and now let's try this again i can press space we only get it once but if i keep on pressing it it only happens after about half a second and this also works oh um magic is still a bit different so let's have a look ah the problem for magic is we didn't set the starting time so this is what we need now let's run this again and now both magic and attack work much better so now our player has the ability to move around up here and to attack and cast magic at least in theory so now we can actually import all of the animations to show what the player is doing and that is going to become quite extensive so let me minimize all of the functions and put all of this in a new method and let's call it import player assets needs self and nothing else and then here first of all i want to get my character path to the folder this shouldn't be capitalized and the path to my folder is going to be one fold up then graphics and then the player and then forward slash don't forget that because in this folder there are a couple of subfolders and now we need all the different states that our player can have and this i want to put in a dictionary because this will get quite extensive and let me just copy all of this it's going to look like this and there's a bit much white space like this so this is what i talked about earlier we have the animation states for the player walking in all the four directions the player being idle in all the four directions and the player attacking in all of the four directions so these are all the possible states the player can have and if you look at the folders they are named in the exact same way and that makes it really easy for us to use the names of these dictionary entries to import all of the graphics so what i can do now is for animation in self dot animations dot keys let's say if i just print it to illustrate what i'm getting so animation and in the init method i want to call this so let's put it right at the beginning in here and let's call it a graphics setup and self dot import player assets and now if i run the game we can see we have all of our different states the player can have that's working quite well and keep in mind those are names for folders we are not working with images yet but basically what i want to do i want to combine this player path here with all of these different subfolders and that is actually going to look really similar compared to our support file here so to what we have done with this and then once i have the full path i want to use my input folder function and fill the list for each of the states with the graphics from each folder and this might be a good exercise for you try to figure this out yourself that you go through every single animation you create a full path you use the input for the function to fill each of these folders with the associated images so try to do this yourself first of all we are going to need our full path and the full path is just going to be the character path plus the animation and now for each self dot animations and we can target the animation i want to set each of these lists to my import folder and this import folder i have to import into my player so from support import import folder and now my input folder just needs a path and that is going to be my full path so at the end of all of this let me just print my self dot animations and let's see what we get let's open certain error that looks good in here you can see for example we have up so that's walking up and there are a bunch of different surfaces in there next up we have down more surfaces then we have left at some point we have right then we have right idle and all of the different states are in here which is exactly what we wanted so now we have effectively imported all of the assets for our player so now we can minimize this method and not worry about it anymore with that we have covered the first part that we have figured out how to get the resources into our player now next up we have to figure out how to actually play all of these states and for that we have to talk about state management and essentially what we are going to do our player is going to get an attribute called self.status and this self.status is going to correspond with one of the keys in self.animation so for example it could be up down left right up idle left idle left attack up attack any of those and for example if it is up we are going to pick all the surfaces inside of the up folder and play those repeatedly so with that we have to figure out our state management and really what this one comes down to is we are going to look at our player direction and our player input and see what kind of movement the player is doing for example in our direction vector if we have something like 1 and 0 we know our player is moving to the right and just now from the timer if self.attacking is true we know the player has just been attacking so we want to play the attack animation and really all we are going to do is figure out the right condition for each of the 12 possible states and once we have that we can display an animation and be done with it so let's try to figure out some states here we are back in the code and let's put it under graphic setup self.status and let's say by default this is going to be down and now we also want to create another method and i call this one get status and itself and nothing else as always and in here we have to figure out how to get all of the different states and let's start with the easiest one the idle status and this one is actually fairly easy all we want to check is if self.direction.x is equal to zero and self.direction.y is equal to zero but now we have a problem and let me actually illustrate this by drawing so here is our player and right now we know our player is not moving so we want to play the idle animation now the problem that we have is that we don't know what direction our player was working so we have four different idle statuses we have down left up or right but right now all we know is that our player is idling we don't know in which direction he or she is idling and that is something we do have to figure out and i guess there are two ways to figure this out one way we could look at the direction before the player stopped moving so for example the direction before we stopped was positive one here the player was probably walking to the right but that would involve quite a bit of extra code that would be a bit annoying to work with so instead what i'm going to do i'm going to check the current status so for example right now it's down which means the player is walking downwards and all i'm really going to do is to add towards this and idle so that way i keep my downwards movement but now instead of walking it's going to be idle and really what we are doing i think the best way to think about this is if i show the animations so here we have up down left and right and then for idle we have right idle left idle up idle and down idle so to move from up to up idle all we have to add is underscore idle and the naming here is very intentional it's the same for attack so if we are moving right and we are attacking we just have to add underscore attack to up and we go from walking to the right to attacking to the right so basically all i'm going to do is instead of overwriting self.status i am just going self dot status last underscore idle and now what we can do in the update method let's say after cooldowns self dot get status and i guess what we can do we haven't used our debug method in a while i still have it i don't uh let's do this in the player so in here right now we have our run method and i want to call debug or myself.player.status just to see what's going on because right now we don't have an animation we just have the status so let's see what it's doing so right now you can see the problem that we keep on adding idle to it and we also don't get updated down not working too well yet and i guess i jumped a little bit had with the idle here because we first want to figure out the walking directions and this happens in the input method because we know if we are pressing up our player is going to move up so what we can do in here itself.status is going to be up and we can do the same thing for down and we can do the same thing for right and then finally we have left so this way we are just determining the directions and let me minimize input again and let's comment out get is for now just so not be confusing so now main.pi we have down we have right left up and down so this is working pretty well and even if i stop moving it still says right left down and up so these directions are working really really well the problem is right now i have no way to separate between our player walking and our player idling and that is what we have to work on and this is what all of this code here is for i should have planned that a little bit better sorry about that so now if i uncomment this method here what we basically get is if we are moving things are well but now if i stop moving we keep on adding idle and well it's not particularly helpful oh and what is annoying me i don't want to print self.animations all right now the problem is we don't check if our status already has idle in there so we have to add another if statement that if not idle in self dot status so what we basically do we first of all check if our direction for x and y is zero that's this part here so then we would assume if we are not moving we are idling now next up we are checking if our status doesn't already contain the idle part and only if that is the case we are going to add underscore idle to our status and that way we are only adding idle once and not multiple times at least hopefully let's check this now so we have down idle we have up idle left if i stop moving that looks pretty good so now we have some nice upgrades although if i now attack it doesn't change anything but the animation i want to play should be left attack or down attack so that's the next part and that is just going to be another if statement so if self dot attacking first of all i don't want the player to be able to move and attack at the same time so if we are attacking self.direction dot x should be zero and the same for y and now basically what we want to do is copy this line here and let me actually just copy the entire thing and i first want to check if we don't already have attack in our status and if that is not the case i want to add attack to my status and this is i guess kind of going to work let's try so now we have down idle up this is the working and now if i press attack we get left idle attack and right idle attack and well it's kind of working but the problem we have is that we only want left underscore attack we don't want the idle in there so what we want to do for attack is that we don't want to just attach a tag we want to remove idle if it is in there and the same thing here that if we are attacking we don't want the player to play the idle animation or to add the idle tag and this is just a matter of another if statement or well a longer if statement so for example for the status if not idle and self.status and not attack in self. status so now we are checking if the player isn't moving and we don't already idle or we are attacking and only if neither of these are true then our player is going to idle now at the same time for the other if statement we first want to add another if statement so in idle in self.status so if that is the case we want to overwrite idle but if that is not the case then we can just add attack to the status but now we want to overwrite the idle and this is done with self dot status is going to be self dot status dot replace and here we have idle and we want to replace it with underscore attack and that is technically all we need so now let's move up down left and right that is still working now if i stop we have left idle right idle up idle and down idle and now if i attack with down attack left attack right attack and up attack but the one final problem we have is that you can still see it in the top upper tag still sticks around so what i want to do after self.attacking is over up attack should automatically switch back to up idle and that's going to be the final bit and this is going to still happen in get status and this could also be a pretty good exercise so one self.attacking is false i want to remove the attack and self.status so try to figure this out yourself all right so we know this if self.attacking is only going to run if self.attacking is true so if we had an else statement at the bottom here we are checking if self.attacking is going to be false and in here all we want to do is self.status is going to be self.status.replace and now we want to replace underscore attack with an empty string although this by itself might throw an arrow because python might try to remove attack if there's no attack in the string so this needs to have another if statement that if attack in self dot status so now this should be working and i guess with that we have our player status let's try so down idle up idle attack we go back to idle we have left right i can attack i go back to idle this also works with magic and yeah this is working really good cool so this is then going to be our get status now i can minimize this and now we come to the finally good part where we actually animate our player so let's really briefly talk about the logic for the animation it really isn't all that difficult essentially all we have to do right now we always have the same image for our sprite and for an animation all we want to do is to loop over a list of different images for example if our player is moving to the right we have five different images to loop over for the animation and once we have that we are well we are good to go it really isn't that complicated so all that we have to figure out in our code is how to quickly loop over different sprites in our animation frames and let's do this straighten the code that should be the easiest here we are back in our player and i want to create a new method let's put it all the way down here and i call this one animate we need self and no other arguments and first of all i want to have an animation and the animation is going to be self dot animations and then we get the key from self dot status so if i open the play assets again our player status can only be any of these 12 states so if we pick any of these keys we are going to get a list with the right animation that we want to loop over so that's the first part now next up we have to give our player a couple of extra attributes and let's put them all the way up here first of all we need self dot frame underscore index which by default is zero and then self dot animation underscore speed and in my case this is going to be 0.15 now let me minimize this again and essentially what we are going to do now is that we are going to loop over the frame index so really what i want to do is self dot frame index plus equal self dot animation speed so this is going to give me a continuously larger number and let me actually draw this so we're going to start at zero and then we're going to get larger and larger numbers and let's say eventually we want to pick one we want to pick two we want to pick three we want to pick four and so on but the problem we have right now is that our animation so this thing here has a finite number of frames so we want to make sure that once we reach the end of this list we want to go back all the way to zero and this we can do simply by checking if self dot frame index is greater or equal than the length of our animation and if that is the case self dot frame index is going to be zero all we are doing is we are increasing a number and once the number is larger than the length of our animation frame index goes back to zero so that way we continuously loop over our list so that should be a pretty easy part now next up we want to actually set the image and all we have to do here is to create a new self.image and the image we want to get is from our animation and in here we want to get self dot frame index however right now pi game or python in general for this indexing expects number like 0 or 1 or 2 essentially an integer the problem is our animation speed is 0.15 so a floating point number hence if we passed this number in here python would be very unhappy so we have to convert this frame index to an integer which we can do very easily with the end function and we are good to go although there's one more thing i do want to do that if we are changing the image we also want to update the rectangle again so self.image.get and the center is going to be where our self.hitbox.center was in the last frame the reason here is that different images of our player have different dimensions so if we didn't update the rectangle the player might shift by a couple of pixels around it would make it look slightly weird but that's really all we needed so now after get status self dot animate and let's see how this is going to look so now the player can move up left right and things are looking good so now if i attack we get an attack animation now the sword and the magic attack are the same but well doesn't really matter however there's one last thing i do want to fix because right now let me run the code again so if i attack i can move to the left i think it's good to see now and i don't want the player to be able to change direction mid attack essentially i don't want a player to do any keyboard input during an attack anyway so what i want to do let me minimize animate and go back to input i only want to do all of this if the player so if not self dot attacking and now i can't do anything during an attack i guess with that we can also remove these lines here because they are not necessary anymore so now let's try this again still feels pretty good and yeah is working really well so with that we have player animations and for the next part let's add some weapons and essentially all that we are going to do whenever the player presses attack we're going to create a new sprite with any of the weapons we have quite a few different ones actually and that way we can already see the weapon the only thing we really have to do is to work with the position and then destroy weapon one self.attacking of the player is over but that's basically it essentially what we are doing is we are creating a sprite for a short period of time and that sprite shows the weapon of the player and later on we will have to add a bit more to make the weapon actually do anything but that comes later i guess for now let's actually show the weapon and the first thing we will need is some data so let's start working on that straight in our code here i am back in the file and i want to keep my data broadly in settings and right now it doesn't actually have that much so i want to import oh well not import but rather paste one dictionary that looks like this and this one has our weapon data so in here we have our sword our lance our x our repair rapier whatever it's called and our sigh and each has its own cooldown its own damage and its own graphic that we are going to show later in the ui and now that we have that i want to create a new class but let me first close debug and tiled so you can see all of the tabs i guess we can also close support we don't need those anymore so now i want to create a new file that i'm going to save as weapon dot pi and then here we are going to need the usual so import by game and then we have to create a class that i'm going to call weapon and this one is going to be a sprite so we need pygame.sprite.sprite and then we have our init method for now we're just going to go with self and then as always we need super dunder in it and now we have to figure out well we have to figure out two major things the first one is self.image and the second one is self.wrecked and let me actually draw what i'm hoping to do this square here is our player and our player is facing to the right and essentially what we want to do with our weapon is to spawn another sprite that essentially starts at the right side of our player and then stays roughly here so for now what we have to figure out is what is the direction of the player and from that how can we use that direction to spawn the weapon to that side of the player and i guess just to keep things simple for now our self.image is just going to be pygame dot surface with uh let's say 40 and 40. so for now it's just going to be a black square but later on it's gonna be a proper graphic so we have to figure out the rectangle the problem is to figure out the right position we need our player since our weapon is supposed to be right next to the player so we have to import let's say the actual player and i guess while we add it we can also add groups to know where the groups are supposed to be and for now just to have something let's say our rect is going to be self.image.get underscore rect and the center is going to be just on top of the player so player dot rect dot center and to spawn that weapon we need a twostep process first of all in our level this is where our weapon has to be let me actually minimize all of this so it's a bit easier to see so right now in our level class we have all of our well sprites all of our everything so my weapon has to be in here as well and that way it's later possible to interact between a weapon and an enemy or between the grass so our weapon has to be available inside of the level the problem is we are getting the attack input from our player so from this line here so our attack happens inside of the player but we want to sort inside of our level that's the main problem we have right now so we have to get around that and that fortunately is quite easy essentially what we are going to do in our level class we are going to create another method and let's call it create attack needs self and nothing else and what we want to do in here is to create our weapon and for that we also have to import it so from weapon import weapon and now let me copy the parameters again so we can figure out the arguments so our player we do have we created this in create map so our player is stored right now in self. player down here so i can literally just copy this one and paste it in here and let me minimize this again that makes our class significantly easier to read now for the groups for now i want this thing to just be in self dot visible sprites and well that is it for this method at least for now now next up what i want to do in my create map when i create a player i want to pass this method in here so self.create attack and really important here we are passing the function into this method we are not calling the function so there should not be brackets let me actually cross it out so these brackets here should not be there if they are there you are going to get some weird result because this function we want to call from inside of the player so inside of my player let me minimize everything in here as well there we go so now in our init method for the player we have another argument that we called create attack and let's put this under i guess movement works so self dot create attack it's just going to be create attack and now we have this method here available inside of our player and now what we can do in our input method we can call under create input instead of attack we can call self dot create attack and now we have no arguments so it should be fine by itself so let's run this and let's see what happens so now if i press space we can see a black square on top of our player and that is going to be our weapon cool so this is working already so now with our level and our player we have the ability to create a weapon although granted it's not particularly helpful right now but that's something we can work on and there are two things we essentially have to figure out the first one is where to place the weapon and the second one is how to figure out the graphic for the weapon because each direction is going to be different and since we already talked about the direction let's talk about with the placement of the weapon but let me actually separate this so here we want to talk about the graphic and then a bit further down we want to talk about the placement now in either of these cases we need the direction of the player because if the player is moving to the right we want to place the weapon to the right and also show the right image of the weapon so we have to figure out let's do it all the way at the top let's call it direction and this i think could be a pretty good exercise so try from the player to get our direction so our player has a ton of different attributes that he could be using try to figure out one so he can reliably tell which way the player is facing i guess there are two ways you could approach this you could either look at the status of the player or at the direction they both would work but in my case self.status i think is the easier one so that's the one i am going to use so really all i'm going to do is player and status and what i want to get essentially is let me illustrate it here so i want to have these four directions so up down left and right my problem right now is that i have to get rid of these other directions so right idle would be kind of annoying but this is fortunately quite easy to get rid of because for that we have the split method and split method needs two arguments the first one is at which character we want to split things in my case at the underscore because back my player the up for example is split from the idle by the underscore so if we split this string by the underscore we get up and idle so that's then the first thing i'm caring about and you could also pass in a second argument that tells you how many times you could potentially split the string but in my case that shouldn't matter and now let's actually print what we get that's probably the easiest way to illustrate this so now when i run this again i press space now we get right now down and idle now if i move up we get up we get left and idle right down left this is working pretty good now what you do notice if we only stand and we have up and idle then python splits this but if we are moving and we only have up then we only get a single element but in both cases this is working really well so essentially this split method here if it doesn't find an underscore it's just going to ignore whatever it has but now we have a list of our directions and if the player is idling or not now the information if the player idles i was attacking i don't care about so i'm just going to pick the item with the index 0 because our string is always going to start with the direction which is the only part i really care about so with this simple line we already have the direction of our player so with that we can start figuring out the positioning of our weapon so if direction is equal to right i now have to figure out a different kind of rectangle and again let me visualize what i want to do and let me draw it a little bit larger so here we have our player and the weapon should be if we're moving to the right should be right here and i would invite you to think about how we could place the weapon in the middle of the player to the right of the player so that they're right next to each other and do think about this for just a second basically what i am going to do is our player has a mid right position of the rectangle so that's the position we are going to use for the player and then when we are placing the weapon we are going to place the mid left so let's call this one ml and this one is going to be m r so if we place those two points in such a way we would have both of these right next to each other when my player is walking to the right i want to place the mid left of my weapon and the position where i want to place it is at the mid right of my player and for now let's just add an else statement so we have something so self.rect is self.image.get underscore rect and center is going to be layer.rect.center so we don't get an error but now if we're running the game and we're moving to the right our rectangle should be spawned to the right of the player so let's try this and if i move to the right we get indeed something that almost works so we have our rectangle of the weapons pointing to the right of the player but if we look a bit closely and during the attack animation our player's hand is a bit too low and the reason for that is that the player hand is a bit below the middle part of the sprite so we don't actually want to spawn our weapon right in the middle of the player we want to give it a tiny offset and this we can add quite easily actually so this position here right now is a tiny bit too high but really all we have to do to change it is pygame.math.vector2 and we don't want to move it in the x position but we do want to move it down by 16 pixels so now let's try this again and now we have a weapon exactly where the hand is supposed to be so with that we have one direction now all we have to do is figure out all of the other directions so l if direction is equal to left and for this one i can just copy paste the right direction and change mid left to mid right and then mid right to mid left and the vector can actually stay the same that one's perfectly fine so now if i move right still works if i move left name left is not defined let's have a look ah should be in quotation marks so now let's try this again so right is still working and left is still working so cool now we already have two directions that work just fine okay now next up we have l if direction is going to be down and i guess let me copy the line again except now we want to place the mid top of our weapon and we want to place this at the mid bottom of our player and now for the vectors we do have to make a slight adjustment so in this case we do want to move the x position but not the y position so let's try this and we have right we have left and now we have down this one also seems to work so the one thing left is up and this we could put in the else statement so in here we want to place the mid bottom of our weapon and it should be in the mid top of our player and then we want to add this vector to it now we should have the placement of our weapon so down all directions look pretty good so i can't see any problems with this nice so with that we have the placement of our weapon obviously right now doesn't look very good because we have to figure out the actual graphics of the weapon now fortunately this is quite simple and let me show you the folder setup so here we have all of our folders and the one i care about right now is weapons and inside of weapons we have our five different weapons now if i go inside of sword we can see down full left right and up and the full sword is the one that's going to be in the ui but all the other directions we are going to actually display in the game and notice here down is exactly named like the direction or the status of our player so we can use the string of our player to select a specific weapon inside of this folder which is exactly the idea here although before we can actually select any direction we first have to select the weapon we actually want to use so we have to tell our player what weapon is currently selected and that is the first one we have to work on so let me do it straight back in the code so here we're back in the weapon code and right now we want to pick one image of the weapon but to pick the right weapon we need to know what weapon the player has selected and this i want to keep in the player so let me minimize this one again the input as well so in the movement let me actually add a whole new section here and let's call this one uh let's call it a weapon i guess that works and then here we can actually put create a tag as well that works a bit better now what i want to do in here is self dot weapon index and right now it's zero and later on this is the number we are going to change to select different weapons and how that is basically going to work is i'm going to get my self.weapon and this is going to cycle through this weapon data list here and we are already importing all of the settings so i can just use weapon data so i want to get one specific key from this weapon data and to get that we need a couple of different things first of all right now we only care about the keys so in our weapon if we have a sword allowance an x or any of the other weapons and from this i want to get myself dot weapon index so for example if our weapon index is zero i want to pick the sword if my weapon index was 1 it would be the lance but right now this would not be working because what keys returns isn't the list that you can index from apparently so we have to turn it into a list and now we can just pick from this list with a different index and let me demonstrate so print self dot web pin and in theory now if we start the game we should be getting sword so let's try it and windy gets sword so this is actually working nice so now we know what weapon our player is supposed to have with that information back in my weapon i can now get a full path to that weapon and that is going to become an f string and first of all we have to go up to the graphics folder and inside of the graphics folder we have to go to weapons now inside of weapons we have to get the specific kind of weapon our player has selected fortunately the naming of the variable is the same as the folder so we can just go with player dot weapon now next up we want to select the right direction and this we get with direction and finally all we need is dot png so now we have the weapon and the direction so really all we have to do now is use pygame.image.load and import the full path and as always don't forget to convert alpha all of this and technically this is all we needed so now let's run this and now if i press to the right we get an error and you can see down here we have graphics swords weapons sword right essentially i forgot one slash so back in my weapon after weapons there should be forward slash so now let's try this again and there we go we have a sword that works in all the different directions and that's a pretty good start although you can see the problem right now our weapon does stick around which is not ideal although it's kind of looking funny but okay cool this is working pretty well so the last thing we have to figure out is how to despawn the weapon once it's supposed to end and this i am also going to do in my level.pi file and in here let me minimize everything again i just want to create another method that i'm going to call destroy weapon and in itself and nothing else and now i want to first check if this weapon exists in the first place now right now we can't really do this because we have no way to identify if this thing exists so i want to store it in its own variable so in my init method i'm going to create let's put it actually even better let's add a whole another section and let's call it the attack sprites because there's going to be a bit more later on but for now i just want to have self.current attack and it's going to be none by default and then when we create the weapon it's going to be stored in self dot current attack so now in our destroy weapon all we have to do is if self dot current attack exists then we want to get self.current attack and kill it and i guess just for good form we can also set self.current attack back to none and now all we have to figure out is how to call this method here and i think this could be a pretty good exercise for you so try to figure it out and it's going to work in a very similar way compared to create a tag so let me minimize the init method again and in my create map i have already put self.create attack in there and now besides that i also want self self. destroy weapon oh i just realized the naming here isn't ideal let's call it destroy attack and destroy attack and here as well that way our naming is a bit more consistent okay and then in our player we now want self dot destroy attack as well and that one is just going to be destroy the tag and this one then is going to be another parameter so now we can call destroy tag inside of our player we just have to figure out when to call it and the answer in my case is in my cooldowns because we know after this cooldown our player's attack is supposed to be over so we can attack again so what we can do in here is self dot destroy attack and that is all we needed i believe so now i can attack in each direction and we can see the weapon so this is actually coming together really nicely and on top of that our weapon is also obeying the drawing order so it's drawn above or below different sprites so all of this is working super well now i guess there's one more thing that we do have to implement because right now we cannot switch between different weapons or well i guess we can if we go to my player and we change weapon index let's say to a free let's see what we get if i now press now we get the whatever this weapon is called but it's definitely working so we have to figure out in code how to change this weapon index from inside of the game and well let's do this in the input so in here we already have quite a few different things and i just want to add another if statement and in my case if keys now in my case the key i am using to switch the weapon is q so pygame dot k underscore q and in the most basic sense all that this one is supposed to do is get myself dot weapon index and add 1 to it unfortunately by itself it's not that easy for the same problem that we have seen with the attack and the magic input that if we didn't add a timer in here pygame would press or would trigger this code very often because the normal button press for normal human being is going to be let's say half a second long now for pygame half a second is a lot of frames in our game and for each of those frames this button would be pressed so if we press this button once python would update weapon index with plus 1 probably about 10 times so instead we have to create another timer like we have done earlier and now this timer has to be independent from the attack and the magic one because the player should be able to switch weapons at basically any time so i want to create another timer and the first we have to do for that is let's say in my weapon i think it makes sense there and what i want to create in here is going to look very similar compared to these lines here so first of all i want to create another variable that i called can switch underscore weapon and by default this one should be true and then besides that i want to have self dot weapons switch time and this by default is going to be none so that's the equivalent of our attack time now finally we need to cool down duration and in my case it's going to be the same thing for the weapon and for the magic switching so we can call this one self dot switch duration cooldown and this one i put at 200 so now we have all we need to create a basic timer so now back in this line here i only want to trigger the cue press if we press the button and if self dot can't switch weapon is true and if we have pressed it then self dot can't switch weapon should be false and just like we have done up here we also want to get the time that we press this button so self dot i think what did i call it weapon switch time so weapons which time is going to be dot time dot get underscore ticks and only once that is the case we want to update our weapon with plus equal one and let me just check if i'm starting at weapon zero yep so now in the game secondly we should be able to switch our weapon once let's try so right now if i press the attack we get our sword now if i press q we still get our sword and i think i know why so back in my player we are updating our weapon index but if i go up to the init method we have changed right now our weapon index but what we have not updated is our actual weapon so this was only set in the init method but it's not being updated when we press the button so that's what we have to do as well and let me just copy the entire list i think that's the easiest way to approach this so after i've updated the index i also want to update myself.weapon and this happens basically with the same line well exactly with the same line so now let's try this again so sort now if i press q and now we get the lance although since i don't have a timer to react to weight my can't switch weapons we can't change it again but that we can do now and that's going to happen down here in cooldowns and i would actually recommend you to look at our cooldown for the attack animation and copy it so we can switch weapons and have a timer for that what i basically want to do is if self dot can switch weapon and i want to check if this is not the case because we are setting this thing up here to false so only if this is false we want to run the timer and if the time is running i want to get my current time and subtract self dot weapon switch time and if that is greater or equal to self dot weapons which what i call it again we start to have a lot of variables switch duration cooldown there we go so down here switch duration cooldown now if that is the case we want to set self dot can switch weapon back to true and now let's try this again so now my weapon still works now if i press q we get the lance if i press it again we get the x press it again different weapon and a different weapon but now i press it again and now we have list index out of range and this happens if i go to my player that we are always updating this number by one but we only have five weapons inside of our list so at some point this number is going to exceed the length of that list but that we can fix fairly easily and really all we have to do is if self dot weapon index is more than the length of the list of our keys so this thing here and only if that is the case we want to add plus one to our weapon index now if that is not the case we want to do something else and what we want to do is to set our self.weapon index back to zero so once we're exceeding that number we are going back to zero and that way i don't have to implement a backwards mechanic for this button but you could totally do that if you wanted to but with that logic we have the weapon mechanic so let's try so now i get sword lens x next one next one now if i press q again we still get an error okay not great let's have a look ah and what i just saw this should be length minus one because we start counting from zero so now let's try this again different weapons different weapons and answer again now we're back to sort cool so now this is working so this is a common thing in python that the length of our list was one too large because of the way we're counting the length of the list but well now we have our proper weapon mechanic so all right with that we have a weapon although right now you can't really see the weapon so next up we are going to work on the ui and i guess while we're at it we can also implement the health bar the energy bar the experience or the souls and then the magic we currently have selected so we have all of the stuff in one place so i guess let's talk about how to approach the ui that's going to be the next section i guess in the most basic sense the ui is going to consist of two different elements number one is our player is going to have a ton of different data for example what our current weapon is that's one we already have but besides that we also need health energy experience our magic and i guess that's it and these are the things we have to add to our player now once we have all of them we can actually start working on the ui elements that are visible and this is going to involve a couple of different things for example we have to show the health bar and the energy bar and both of those for example are just rectangles and the width is determined by the amount of health as a proportion of our full health or our full energy so we're not really going to do anything sophisticated we're just creating different rectangles and the weapon and the magic are just the images with some background rectangles one has a color one only has an outline and if we combine these different elements we basically get some nice looking ui that i think came together really really well and i guess this part is best explained when i actually implemented so let's start with number one and let's give our player a couple of key attributes to actually create a game here i am back in my player and let me go down and add another section here and let's call this one stats and what i'm going to paste in here is just going to be a dictionary so we have our health our energy our attack our magic and our speed and i guess if you're confused right now we have attack here and for each weapon we have damage and what i'm going to do later on is our ultimate damage of the player is the base attack plus the weapon damage so these are going to be our base stats but we need a few more things so right now our health is at 100 and this would be our current maximum but now imagine we run the actual game and an enemy hits us then we have to lower this amount but we still have to know what our maximum amount is and for that i want to add self.health and by default it's going to be self.stats and just health so by default our self.health is going to be the same as the maximum we can have however later on in the game we can actually lower this amount and then we can have a different between the maximum and our current health and we can do the same thing since we're going to need it anyway is our energy and this is just going to be self.stats and in here our energy and there's one more thing that we do need for the ui and that is self.exp and this one doesn't have a stats entry because it's well just the experience and let's say just so we have a number let's go with one two three and actually while we're here we can also now determine self dot speed is going to be self dot stats and speed so now we can go up a tiny bit and get rid of this speed here because later on we want to be able to update this and i guess it should be five by default so we keep the same speed okay now our player has some stats and some current stats that we can work with so now we actually have to create the ui and what i want to do is to create a new file that i'm going to save as ui.pi and in here as always we need import pygame and from settings import all of it and now i want to create a new class called ui and then here as always we need our init method with self and nothing else and for now let's just add a pass in here and figure out how to call this thing in the first place and i want to call this from the level because in here we are drawing all of it and let me minimize all the methods so it's a bit easier to see let's say we can minimize this one as well now in my level class i want to create another section and let's call this one the user interface and what i want to do here is self.ui is going to be ui so the class we have just created this one here and for that to work we have to do from ui import ui so now we can actually use it and pretty much what i want to do in my run method on top of everything else i guess i can get rid of the debug one i can run self dot u i and essentially i want to give it one method that i call display and to get the information from the player i want to pass self dot player in here and that is pretty much all we have to do in our level now we can just work in our ui and all we need is one method that was called this play and we need self and the player as the arguments so now we can go pass and now we have a class where we have access to the player and we can call it from the level itself or well we are always calling it and now let's run this we don't get an error so at the very least it's working cool so now we just have to figure out all of the ui elements and there are quite a few different ones so let's go through this thing step by step first of all we need a couple of general bits of information so let's call this general and first of all i want to have access to the display surface and this we get as always with pygame dot display dot get underscore surface now next up we also have some text so i want to create self dot font now we do have a font that we can just import and i also know the font size but for my ui design i have quite a few parameters like the bar height the width of all the elements the box sizes of the weapon and magic items and i want to store all of this in my settings so before i import the font let me go to my settings and in here i want to add another sections that i called the ui and in here i have a couple of parameters that look like this and these are all the elements i will need to well make the ui work and actually while we are here there are a couple more and these ones are going to be colors so we have our general colors we have the water the uibg color the border color and the text color and then we have the health bar color the energy bar color and then if we select something you're going to see how those look later on but for now all of these are just very simple variables that don't really store anything complicated so all right now we can use them so first of all i want to import my font and this is going to happen with pygame.font.font and in here we need the font we want to import which in my case is i called this one ui font so ui underscore font and then we need a font size which in my case is stored in ui underscore font underscore size and now we have to choose which element to start with so we can either do the health and the energy bar the experience or the weapon or magic and let's say we're going to start with the health and energy bar i'm going to add another tab here and let's call it for now the bar setup and right now i want to create some general rectangle where the health and where the energy bar is going to be and this is just going to be a rectangle and i'm going to call this health bar rect and this is going to be pygame dot rect and now for this one we need the left the top the width and the height now the width and the height we do have in here so we have a health bar width that we can put in here and the bar height is identical so it's just called bar height so bar height now next up for the left and the top i just went with 10 and 10 which is in the top left now besides that i also want self dot energy bar rect and this one is going to work in a very similar way so pygame direct and now again we need to left we need the top we need to weft and we need the height and now the height we already have is just the bar height for the width we have energy bar width in our settings so within here and i want this one to start on the same x position but the top is supposed to be a bit further down i went with 34 and now once we have that we could actually already try to draw something so let's see if this works in the first place so i just want to use pygame.draw.rect and in here we need a surface we need a color and we need a rectangle and for the surface we have self dot display surface let's say for the color for now it's going to be black we're going to change this anyway and for the rect let's go with dot health bar rect so now let's try this and we can indeed see a health bar in the top left and this one stays in a nice position so this is working very well cool but i don't want to draw this element right here so let me add a pass in there again instead i want to create a function that is a bit more flexible so just a function that can take a current amount a max amount a background rectangle and a color and then display either health bar or energy bar so we can use it for both and well let's implement this one so i call this one show bar and in here we need a couple of different arguments so first one we need the current amount then we need the max amount then we need the background rectangle and then we need a color so for example what i essentially want to do i want to call self.showbar and then in here i want to pass in player dot health and player dot stats and health so that's our max health then i want to pass in this rectangle and this is going to give us the position of where the health bar is going to be and then finally i want to give this thing a color and a color we get from our settings we have health color although granted it's just red so in my ui i can pass this in here and where this system is really useful now we could just copy all of this and change health to energy and then this health should also be energy and our health color should be the energy color although again the energy color is just blue all right now we have a function to create the health and the energy bar we just have to write it first of all we have to draw the background that is what i basically wrote just a second ago so again pygame.draw.rect and here we again need self.display surface then we need a color and in my case the color is the ui bg color so i can paste this here and then we're going to need our bg rectangle and i guess quite important this color here is not supposed to be this color up here so that's not the case right now we are just drawing the background of our bar we're not drawing the bar that's supposed to indicate the health right now that will come in just a second but now actually this should already work let's try this and yeah now we can see our two bars for health and energy in the top left and they are working perfectly fine and now that we have that we can start working on drawing the bar although now we do have a problem and let me illustrate what the problem is so right now we have one bar let's say it has a length of something like this and i know from my settings so the health bar width for example that this entire thing right now is 200 pixels wide and all of that so far worked pretty well now the problem is that my health is not in pixels so this player health here at the current maximum would be 100. so this would be our full health the problem is inside of this thing we have to convert this 100 to a 200 and this should then obviously be flexible so we have to figure out how much is 100 health in terms of pixels in our health bar so we need a bit of math to convert our health into pixels and let me actually add another section to that so converting stat to pixel and first of all i want to figure out a ratio and that is going to be my current amount divided by my max amount and that is going to tell me how much of my max amount do i actually have and this is already getting us really close to a pixel measurement because i know for example for my health my max amount is going to be 200 pixels wide so what i want to figure out next is my current width from that and all i really want to do in here is get my background rectangle and get the width from that so that is my max width in pixels and this i just want to multiply by the ratio and let's do some numbers just to illustrate how this is going to work so our current health right now is 100 and our maximum is also 100 so if you divide one by the other you end up with one now our b direct for our health is going to be 200 pixels wide and if our ratio then is one we are going to get a pixel width of 200 for our entire bar so this is then working quite well now let's say we have different numbers so instead of 100 we get 50. now our result is going to be 0.5 and if we multiply 200 with 0.5 we don't get 200 we get 100 which is exactly half of the width of our background rectangle all right so now we have to use that information to create a new rectangle so let's call it current rect and since i already have in my background rectangle most of the information i can just copy this one and now for my current react dot width i'm going to set this to my current width so this way i have a rectangle in the same position with the same height but with this line i give it a different width so all we have to do now is to draw this rectangle so pygame.draw.rect now we still need self.display surface next up we need the color and that color we are getting from the parameters so we don't have to worry about it and finally i want to draw my current rect and now let's try this there we go now in our top left we can see our health and our energy bar and what i can also do so let's say in my player just to illustrate let me multiply our health by 0.5 and our energy by 0.8 now if we run this you can see that we have half of our health and most of our energy so this way we can change the health and the energy of the player and it updates automatically so this system works super well now there's one more thing i did add to this and that is basically a border around the health bar which does make it look a bit nicer and this is just pygame.draw.org self dot display surface now for the color we have in settings a ui border color so that's the one i'm going to use here and then besides that we have the current rectangle so right now we are just drawing a rectangle on top of the other rectangle which wouldn't be very helpful but now if we are giving this another argument this would be the line width in my case it's free and once it gives something in line within pie game the fill disappears and we only have the line let me actually demonstrate now it looks like this oh when i did make a mistake right now we are just drawing a bar around our actual health which is not what i want instead i want to draw around my bg rect so we are covering the entire bar with an outline so now let's try this again and there we go this is looking quite a bit better it's a touch hard to see but if you look at the left of it it is definitely there so alright with that we have our health bars wasn't actually that bad so now i can minimize my show bar and never worry about it again so with that part covered we can start working on the experience and that part should be really easy basically what i want to do i'm going to call another method and this one's going to be called show exp so let's create that method show underscore ex and this one besides self also needs let's call it the exp and now what i want to do first of all i want to create a text surface and the text is going to be the experience and essentially this means i want self.render and in here we need the information we need antialiasing and we need a color and let's go through them one by one let's start with the easiest one antialiasing in my case it's false because i have pixel art and this one shouldn't be in the earliest and besides that for the color i can go to my settings and in settings i have a text color so that's the one i'm going to use and then finally we have our information and this is supposed to become the axp and right now exp is going to be in our player and it is this number here an integer now the problem is that python for this one needs a string so this one wouldn't work by itself but we can fix that fairly easily by using the string method and there's one more thing i would like to do and that is that i want to convert this number into an integer now why do i want to do that because right now our experience already is an integer essentially this is to make sure that our numbers don't get too long so if by some weird math we end up with a floating point number with 10.0001 this would look very strange in the experience and converting this experience to an integer avoids that problem entirely so next up we have to figure out how to place this surface and i did that with a rectangle and really all we need here is the text surface and get rekt and since i want to place this thing in the bottom right let me actually draw it really quick so if this is my entire game window i want the experience to be down here ish and to place it down here i think the best point would be the bottom right so let's place that one actually i think this could be a pretty good exercise so try to place the text rectangle on the bottom right of the window wherever you think it looks good and then draw the text on the display surface first of all i need bottom right that's the point i would like to place and for this one i need x and y so i have to figure out what the dimension of these two variables are going to be and let's do them in separate variables so it's a bit easier to see what i'm doing now what we have to be aware of here if this again is our entire window and we are placing our experience down here with this origin point the thing i have to figure out is the maximum width of my window so this distance here and this would give me the right side of the window and now what i have to figure out from here is how far away i want to get from there and this would then give me my origin point on the xaxis and the same for the y we essentially first have to get the entire height of the window and then from that point subtract how high we want the experience to float from the bottom of the window so what that means in practice is we first have to get the dimensions of our window and this we can get with self dot display surface and get size and this is going to return as a tuple of x and y and for x we only care about the first one that is the x dimension now we can copy all of this and target the first one so with these two points our window would be right at the bottom right of the screen but i want that to be a tiny offset and in my case for x i went with 20 and for y i had the same number so now our text rectangle is in the bottom right of the window now all we have to do is call self dot display surface and blit and pass in the text surface and the text rectangle and we are almost done the one thing we haven't done yet is in show xp we have to pass in the experience and this we get from player and that is still the player we are getting from the argument of the display method but player right now isn't good because we want the experience of the player so i want player.exp i believe i called it so in here yeah player.exp and now this should be working so let's try to run all of this and there we go in the bottom right of the window so all the way down here you can see the experience so not a bad start although also not a great one because you can barely read it but this we can fix quite easily because we can use the text rectangle to draw a background and a frame around this box so let's do that and first of all the background has to be behind our text and all i really need to do in here is to call pygame.draw.rect and in here i need my display surface so self.display surface then i need a color which in my case i called u i b g color the same as the health bar and finally a rectangle so our text rectangle and now this is already looking quite a bit better although not ideal because i would like the box to be slightly larger than the text but this we can also fix so this rectangle i want to be slightly larger and this we can also do with the inflate method that's the same method we've seen earlier to create the hitboxes and earlier we passed the negative numbers to make the rectangle smaller but if we pass the larger numbers let's say 20 and 20 now our rectangle is going to become larger and that is exactly what i wanted so with that we have our background but i also want to draw a frame around this box and for that i am just going to copy the draw method and now i can add another argument and that way we get a frame which in my case has a width of three and then we also need another color and i call this one ui border color and now let's have a look and there we go the effect is fairly subtle but i do think it does make it look a little bit better but all right now we can show our experience so now let me minimize the experience method and now there's only one more element we have to cover and that is the selection box for the weapon and the magic and this i want to work kind of like the health and the energy bar that i have one method that just creates a box and then i can give this box different arguments to display different player statistics although this one has to become a little bit more complex since we're displaying an image but it's not that bad i guess let's work on it straight in the code now first of all i want to create another method that i have called selection underscore box needs self as always and then we need a position and i call this left and top and that is all we are going to need for now although there is going to be a change later on and this selection box is essentially going to give us the background box for our weapon so this is the box and then later on we are going to paste an image of the weapon in here so this selection box gives us the box and the position where to place this surface you're going to see a second what i mean now first of all we need a rectangle and i call this one the bg rectangle and for this one we want to create a rectangle so pygame.rect and for this one we have to figure out the left the top the width and the height and left on top we already have that part is literally the arguments we are getting from the function itself so those two we don't have to worry about now width and height are also very simple because in my settings i have an item called item box size and this one is supposed to determine the size of this box and since we are creating a square it's the same dimension for both x and y so now we have our background rectangle and what we can do already is draw it so pygame.draw.rect we need self dot display surface then ui bg color and then bg wrecked we can already call it just to see what's going on so selection box and let's say for the left i will go with 10 and for the height let's say 1150 so now let's try this and we can't see anything ah for the simple reason that this number is way too high it should be more like 600 let's try now there we go now in the bottom right you can see the rectangle i guess let's put it a tiny bit further down let's say 630. oh yeah this feels much better so now we have a rectangle cool now what we can also do is copy this entire thing give it a border radius and now call this ui border color and with that we also have the frame around this box which is already making it look better nice and this is basically all we are going to need for the overlay for either the weapon or the magic so essentially what i'm going to do is call this twice the first one is for the weapon and the second one is for the magic and for the magic box i went with 85 and i put it a slight bit further down i think 35 is what i used so let's call it and there we go now we have our two boxes and they are slightly overlapping which i think looks pretty good actually let's give it a bit more of an overlap let's turn this to an 80. and there we go i think this looks really nice cool so with that we have our selection boxes now what we have to figure out is how to pass the weapon or the magic image in here and i realize we don't have the magic yet we're gonna work on that in the next section but for now let's figure out the weapon and i'm gonna put this in its separate method and let's call it the weapon overlay and since this method has to know what weapon the player is using i also want to get what i call the weapon index and this weapon index is going to be this weapon index in our player file or player class and i'm going to use that to figure out which surface we want to draw now first of all i want to call this selection box method from inside the weapon overlay and for that i can just copy all of this and paste it in here that already cleans things up and instead of calling this method i can call weapon overlay and i guess what we call the method i can also place in the argument so player dot weapon index so right now there shouldn't be any change and there isn't so now we are already drawing our background but this is only one thing i want from this because what i really want from this background is the position where my surface is supposed to be placed so ideally what i would like to do is to take this background rectangle and somehow get it inside of my weapon overlay and then place my surface of the weapon inside of that rectangle and that i can just get by returning the bg rect at the end of this method so now in this other method i can get let's just keep calling it be direct and i can get rid of the comment i suppose so now we have our bg rectangle available in our weapon overlay and i can minimize selection box we don't need it anymore and now essentially what i want to do i want to get myself.display surface and blit and i want to get a weapon surface and a web pin rect the weapon surface i'm going to get from settings and in my weapon data it's this graphic here and my weapon rectangle is going to be just a rectangle and the center of this rectangle is going to be in the center of this bg rectangle and that way our weapon is inside of our background i hope that makes sense so we have to figure out two things first of all we need the weapon surface and for that we have to look at our settings and in here we want essentially get this information although right now this is slightly difficult to get because this is a dictionary and we only have an index so instead we have to convert this dictionary here into a more usable list and that i want to do in the init method so let me add a comment here and let's say convert weapon dictionary and really all i want to do i want to have self.weapon weapon graphics as a list and i also want to spell this correctly and in this list i want to have all of the surfaces of my weapons so essentially what i want to do is for weapon in my settings i want to get the weapon data so in weapon data and i don't really care about the keys i only care about the values so what i essentially get now is another dictionary and inside of this dictionary i only really care about graphic so let's save this one in path and we get this one in weapon and graphic i think graphic or graphics just graphic and now what i can do is get my weapon and just pygame dot image dot load and i need my path and as always i need my convert alpha and once i have that i just want to add this weapon to my weapon graphics so append and my weapon so now i have all of my weapons in an accessible list and what i can do with that in this weapon surface down here in my weapon overlay i can just get self dot weapon graphics and pick the one with the weapon index and that is literally all i needed now i have the graphic and now i can get my rectangle and this is just going to be my weapon surface dot get underscore rect and i want to place the center at the center of my bg rect so dot center and now we should be having a weapon let's try and there we go we can indeed see a weapon and now if i press q we also get different weapons depending on well what we have selected so this is working very very well attacking also still works with the same result nice now there's one more change i would like to make and that is when we change the weapon i want the frame of this box to be highlighted in yellow so we get some indication of what we are doing and that's just adding some visual niceties to it it really isn't anything major and all this really means in code is that this border color should have a different color while our player is switching the weapon and we know when the player is switching the weapon because in my player i have can switch weapon and essentially if this one is false i want to have the border color of this one differently and well for that we have to pass a couple of arguments through so let's start with the selection box that's the first one down and in here i want to add another argument and let's call this has switched and now i can add an if statement that if s switched is true then i want to do something but if that is not the case so else then i want to keep on doing what we already have done by drawing this border color however if it is the case that we have switched i can copy this and just draw this frame in a different color and the different color we have it's ui border color active although this one is just gold i'm very lazy with colors okay now we have border color active cool so now we have to figure out how to get this hair switched inside of our weapon overlay so in here our selection box also need has switched which we can't get right now because we only have the weapon index so i need to give this one another parameter and i guess we can keep on calling this as switched and now finally when we call this method we're getting our weapon index and now we have to figure out an argument and we know it's going to come from the player but now in my player we have can switch weapon but if i just pass it in here actually let's try this but first of all we have to comment this selection box out otherwise we get an error so now if i run this we get the golden border by default and if i switch my weapon it disappears for a second so we have to do the exact opposite because by default this attribute here checks if we can switch the weapon but what we want to check in here if the player has switched the weapon is the exact opposite and well all we have to do is add a not before that and now we should be good to go so now we're checking the inverse of that variable and now if i press this we are getting the right selection so this is working pretty good nice and i guess to get the magic in there as well we actually have to give our players some magic abilities and i guess let's work on that and once we have the magic we're going to finish the ui and the magic is going to work kind of like the sword at least in terms of data and the player so we have a dictionary with lots of data we give our player a timer and the ability to switch between different kinds of magic and then once we are casting magic we are doing something although that something is going to be slightly more complex than just spawning a sprite because our magic is going to be a bit more complex so for now we are going to skip this part and we are still going to just print at our players doing something the reason here is that to actually make the magic work we need particle effects that we don't have yet and that are really really important hence we can't really do this but we'll come back to this later but for now let's do at least the basic magic so we can finish the ui and there really isn't anything new so let's jump straight into the code and here we are back in my main file and i want to go to settings i need another dictionary for my data and this one is for my magic and if i paste this we essentially have two spells we have flame and we have heal and this dictionary works very similarly compared to the weapon data and for the ui the important one we care about is this file here or this string to an image and i guess for the player we also have a strength and a cost but really nothing particularly complicated so now we have to figure out in my player how to use this and i guess we need a couple more attributes and let's put it right below weapon it makes the most sense there and first of all i need a magic index that by default is going to be zero and that is the same idea we had for dot weapon index so those two are going to be the same as a matter of fact we are going to copy quite a bit from here since our weapon and our magic at least in terms of data are very similar so the next thing i want to do actually i can copy this entire thing and paste it in here so now i want to get myself.magic so the magic i currently have selected and for that i want to get my magic data dot keys and self dot magic index so this information essentially gives me either of these two strings which is the key for this dictionary then besides that we also want can switch magic to select it for the ui and by default this should also be true and then we need self dot magic switch time and this by default is going to be none essentially what we have done in these four lines here is the same we have done earlier for our weapon so nothing new although there's one more thing that we do need and for our weapon we have self.create attack and we are going to need the same thing for our magic and i guess just to keep the symmetry let's put it right at the top so self. let's call it create magic and this one is going to be create magic and this create magic we have to get from our parameters so here create magic now in my level let me minimize all of the methods besides create attack i also want to define create magic and this create magic is going to need a few more parameters first of all i want the style of magic i'm using then i want the strength of that style and finally i want to have the cost of that style and in this method later on we are going to have a system to select different kind of magic spells but well that's quite a bit off for now we're just going to print this style we're going to print the strength and we're going to print the cost so at the very least we can tell what's going on and besides that what we need is when we create the map and we create the player actually let me add a bit of a few more lines here so we can actually tell what's going on with the player okay this is much easier to read so now finally i want to add create magic and as always make sure you're not calling this method you're just passing it into the player and all right now in our player we have to create magic method and we have all of the attributes we need i hope i didn't forget any so for the next step let me actually minimize all of the methods for the player so it's a bit easier to see now the next thing i want to do is in my input right now we have one way to cast magic and what we have done so far we just printed magic but now i want to self dot create magic and for that create magic i need my three arguments i need my style i need my strength and i need my cost and let's put those three in the separate lines so it's a bit easier to see so we need a style we need a strength and we need a cost and this is information we will get from this dictionary here and we know which of these to target by using our in the unit method by using this magic index and i feel like this could be a pretty good exercise so try to use the magic index that when we are pressing the magic button we are calling this create magic in the proper way alright let's start with the easiest one this style and we first want to look at the magic underscore data and what style is supposed to be is a string that either says flame or here so we need the keys of this dictionary so magic data dot keys and this i want to turn into a list with list so we can use indexing on it and once we have that all we really need is self dot magic index and then we are good to go that is actually all we needed so next up we want to do something fairly similar so let me copy all of this and now we want to figure out the strength so let's look at the dictionary again now we actually want to look at one of the values for these dictionaries and from this dictionary we want to get the one that is called strength that has the key strength rather and that is actually kind of simple as well so now instead of keys we are looking at values so this list here would be a list of all of our values and if we pick one we end up with one dictionary let's say this line here if it was zero would be giving us this dictionary and once we have that all we need is to pick one element from this dictionary and i want the key strength is what i called it i think yes strength and now for the cost all we have to do is copy this thing and now instead of strength we are looking at cost and i guess just to check if this is even working let's try this in our game so let's run my game and let's press ctrl and we get flame 5 and 20. so this is actually working nice although there's one change i would like to make that right now my strength is just from the settings this strength here but essentially what i want to do is to give my player also a magic ability actually my player already has that this magic here that's basically the in build magic power of the player and we're gonna add this to the magic damage so for the strength i want to get the strength of the spell plus myself dot stats and i call this one magic i think yeah magic so this self dot stats magic here so that way we can level up our spells and we make them stronger so let's try this again and now we get five plus four is nine so this is working really well so with that we can call our magic and next up we have to be able to switch between different kinds of magic and that's going to look very similar compared to this weapon switching mechanic so i suppose what we can do is just copy the entire thing and then let's work from there first of all on the first line instead of q i want to look at e and then can't switch weapon should be can switch magic now the next line can't switch weapon is false should be can switch magic and for the time it should not be weapon switch time it should be magic switch time then next up we don't want our weapon index in any of these so this should be magic and then the list we are looking at shouldn't be weapon it should be magic but everything else is still the same this weapon should also be magic and then finally self dot magic should be our list with not weapon data or the weapon index it should instead be our magic index and now this should technically be working so let's try this in the game so now i press ctrl we get flame 9 and 20. now if i press e now we get here 24 and 10. if i press e again we should go back to flame and we are not it sticks to heal so let's have a look here we have our entire if statement and i think i just figured out what the problem is that for our weapon we have a timer that reactivates the weapon whereas for the magic we don't have a timer so once can switch magic goes to false it never turns on again we can actually test this so at the end of this if statement i want to print magic and now if i call this we get flame if i press e we get magic but if i press e again i don't see anything so we only ever update or we only ever call this one here once and the reason we can only call it once is because further down in our cooldowns there's no cooldown for the magic but we can create one quite easily by just copying the weapon switch mechanic so if can switch magic i want to get my current time then my magic switch time is what i called it and if that is greater than my switch duration cooldown that's the one that can stay constant or well the one that doesn't change between the weapon and the magic and if that is the case mike can switch magic should be true so now we have the cooldown now let's try this again so i get my flame 9 and 20 i press e we get heal i press e again now we're back to flame and i can keep on pressing this it always works nice and with that we have our basic magic obviously it doesn't do anything right now but that will come later i guess what we can do now is work on the ui to display the magic and this is going to work in essentially the same way that we have done for the weapon overlay so let's actually implement it straight away although if you want to do this as an exercise i would recommend you to try this out in my case let's call this one magic overlay and here we need self we need the magic index and we again need has switched and if that is the case actually let me copy all of this again since it's going to look fairly similar so magic overlay might be direct is now going to have these two numbers so these two numbers and i actually also want to call self dot magic overlay with my player dot magic index and then not player can switch magic i believe i called it so those two methods are basically identical except we're using different data and the bgrack still works but now we need a magic surface and a magic rectangle and for the magic surface we need our magic graphics and our magic index oh and i just realized we don't have our magic graphics yet let me cover this one in just a second first of all for magic rectangle i want to get my magic surface and the rest can stay the same and now i want to replace weapon with magic okay we are nearly done the one thing i did forget is that in the init method we also have to get the convert magic dictionary so kind of the same thing we have done for the weapons that we create a list with all of the surfaces and i want to do pretty much the same so self dot magic graphics by default it's an empty list and now for magic in magic underscore data dot values i guess for this one we can go straight to the magic surface and i want to get pygame dot image dot load and the path is going to be magic and graphic and as always for this one we also need convert alpha and then self dot magic graphics dot append magic i guess if you were to do all of this by yourself i would recommend to combine these two imports into one function so you can reuse them it's a bit more elegant and i guess you could also combine these two functions here in a bit more detail but i guess there are so few lines in my case i don't really mind that much but alright now we have our import graphics and this magic overlay also works and i think we're done let's try so i can see my magic and i can see my weapon if i change my weapon it still works if i change my magic it also works cool so now i can change between my different magic and weapons and we can still use them in the game as well so this is working really well so with that we have the ui all covered next up i guess we can actually start adding some enemies to make the game a bit more interactive and the enemies have to be able to do quite a bit because they are nearly as complex as the player so there are a couple of things that we have to implement here and there's one more thing i would also like to cover that since our player and our monsters are fairly similar they can share a couple of methods with each other in my case the methods they do share is the move and the collision method they essentially move in the same way the only difference is that our player gets the direction from the input whereas the enemies get the direction from what the player is doing so if the player is very close to them they're moving towards the player and if the player is further away they don't move at all but once we do have a direction they are basically going to work in the same way so what we have to do for now first of all we have to import a bunch of data for the enemies to actually display the very basics of them then we have to split some methods from our player and create a new class called entity and then both our player and our enemies are going to inherit from that class and once we have all of that we can actually start implementing some enemy functionality so i guess let's jump straight into the code and let's have a look at this so here i'm back in my code and first of all i need some data and all of that is in the settings and in here i want to add yet another section that i called enemy and in there i want to import another dictionary that looks like this so in here we have our enemies for example we have let's say the raccoon we have a health experience damage their attack type and their attack sound and then at the end we get quite a few more like speed resistance attack radius and notice radius and all of these things are going to determine how they are going to operate but that is literally it besides that the classes are going to be identical and i guess really quick to go through what each of these pairs do health should be fairly obvious it's how healthy they are experience is how much experience they give and damage is well how much damage they do to the player attack type is purely for the particle effects so when the enemy is attacking the player this is going to be what will be displayed on the window and besides that at the end speed should be fairly obvious resistance basically means if the player is hitting the enemies so let's say this is our player and this is our enemy and if the player hits the enemy then our enemy is supposed to go a little bit backwards and the distance by how much the enemy is being pushed back that's the resistance then we have attack radios and notice radius and essentially what they mean let's say that this here is our enemy and the enemy has two radiuses the first one is the attack radius and let's say this one is going to look something like this it is literally a radius around the enemy and if the player is inside of this radius let's say right now our player is here if that is the case then the enemy is supposed to attack the player and that is the attack radius and you see it's 80 and 120 or very small numbers they basically mean if the enemy and the player are very close to each other then the enemy should attack now besides that we have our notice radius and the notice radius is substantially larger it essentially is something like this let me draw it out and if our player is inside of this radius then the enemy should only move towards it but it should not attack so that way once our enemy is close enough to the player it starts moving towards the player and then once the enemy is close enough to the player so the players inside of the attack radius then the enemy is going to attack and if the player is outside of that so here then the enemy isn't going to do anything so i hope that makes sense and all right with that we have the data for our enemy they do get fairly substantial now next up in my player let me minimize all the different methods so it's a bit easier to see now right now the move and the collision method we want to reuse for the enemies as well so what we could do is make the enemies inherit from the player but that feels kind of weird so instead i'm going to take these two methods out and put them in a separate class and let me for that create a new file and let's call this one entity dot pi and in here we have to import pi game and then i want to create a class that i called entity it has to inherit from pygame.sprite.sprite and once we have that i want to give this thing a done there init method in itself and groups and then in the super dot init method we're going to pass in the groups now once we have that we can from the player get this move and this collision method so let me just copy them paste them in here and now our entity has these two methods so what we can do now in the player i can literally just delete both of these methods and now the player isn't supposed to inherit from sprite anymore instead we want to inherit from entity and for that to work we have to from entity import entity and now technically nothing should change and this is still looking very good cool we can still do all the stuff yep that looks very good this is then what we can use for the enemies as well it's going to make our life a bit easier and on top of that we can actually add a few more things in here so we could for example add the self dot frame index with a start of zero self.animation speed could also be in here so 0.15 and self.direction is going to be pygame.math.vector2. these basic attributes are going to be shared across our player and our enemies anyway so having them in here seems to make a bit more sense so now in my player i can get rid of frame index and animation speed and from direction and just to make sure things are still working let's try and seems to be all good and working so with that we have a basic setup for our enemies and with that we can start creating the actual enemy class but first of all let me clean this up a bit so we don't need our ui anymore and we also don't need the weapons and if i close them we have a bit more space and now let me create a new file and i'm going to save this one as enemy dot pi and in here as always we have to import pi game then from settings import everything and don't forget from entity import entity and now we can create our class and me and this one is supposed to inherit from entity and that way we already have all of this available so we don't have to rewrite it but we are still going to need an init method needs self first of all then i do want a couple of different things first of all i want something like a monster name and this monster name is going to be used in a bit to pick either squid raccoon spirit or bamboo so we get different monsters then besides that i also need a position so i know where to place it at the beginning of the game and don't forget we also need the groups now besides that let's start with a general setup and in here the first thing we always need is the super done the ended method and in here we have to pass in our groups and there's one more thing that i would like to add that is self.sprite underscore type and in this case it's just going to be enemy and this sprite type let me open my tile again it was in here so this is our tile class for all the inanimate objects this one also has a sprite type although this one is a tiny bit more flexible because we have different types of tiles but for our enemy we are always going to have our enemy and the reason here is that these are supposed to react differently that if our player attacks an enemy for example then we want to reduce the health or kill the enemy if the health goes below zero however if our player attacks a tile that is a grass for example then we want to destroy the grass immediately the grass doesn't even have any kind of health and then if we have something like a tree or a statue they are not supposed to react to the player whatsoever and for that reason we need different kinds of sprites and i guess you could organize this with different groups as well but i feel like using this system is a little bit more straightforward but there are different solutions to this all right now we have our spread type now next up we have to work on the graphics setup and i guess for now let's just place the enemies on the map and then improve them continuously so what i want to do for now is create a self.image and a self.wrecked and that way we can just place them on the map and then improve on them and for now for the image i just want pygame dot surface let's say 64 and 64. we're going to change that anyway and self.image dot get rekt and the top left should be the position and with that we have our enemies now if you remember all the way back in our level we made this thing here and we are still going to use it to place the enemies and for that we first have to import the csv file which fortunately is very easy so in here i want to create my entities and this is going to be both my enemies and my player and we again want import csv layout and in there we have one more string that we didn't import so far and let me just copy it in here it looks like this it's in the same folder as all of the other csv files we just didn't import it earlier because we didn't need it but we always had it and all right so now this for loop is going to get another csv layout so what we can do is add another if statement in here so if the style is equal to entities and there are a few different kinds of enemies we have to be aware of so this if statement will get more complex but for now we only really have two different kinds of tiles we either have the player that one's actually right here and then we have our basic enemy class that for now is just black image and how this is going to work is if the column is a certain number for example the player in this list is number 394 and if that is the case i want to create my player in that if statement and let me just indent things properly so it's a bit easier to see uh this player also works yes okay now i think you might be confused where do we get this 394 from and the best way to see this is if i just open tiled you're going to see it in a second alrighty here we are entitled and this is our entire map and we got this map from this tile set here and let me open the tile set by itself and here we have the tile map and if i just click on the random tile let's say this one here let me add an arrow to make this a bit more visible so this tile here has an id of 252 and if we export this tire set that is the number we get and now if we click for example on the player it says 394 exactly the number i used to import the player and if you clicked on different kinds of enemies we get 390 91 92 and 93. so basically where this number comes from is on this tile set tiled orders each tile from 0 all the way to the end so we have 0 1 2 3 4 5 6 and so on so if you ever have to double check the numbers that's where they are coming from so now we are importing our player and later on we are going to have more if statements with the different numbers for the enemies as well but now we can also update the position of our player it should not be this random position i gave it it should instead be x and y and those are the numbers we created ages ago all the way up here so we're just reusing those and i guess for now let's just see if this is working in the first place and there we go now our player is starting in a slightly different position but besides that nothing has changed but at the very least we know it is working so now back in my level i can for now just add an else statement and what i want to create in here is an enemy although for that to work i have to import the enemy class so chrome enemy import and me and now we can use it in here and i guess let me copy the parameters and paste them in here so it's a bit easier to work with now for the monster name let's say for now we can just say monster doesn't really matter for the position we keep on using x and y and for the groups let me copy it from the player so we definitely want the enemies to be in the visible sprites but besides that since the player isn't supposed to be able to collide with the enemies that's all we need for now so now we technically should be having all we need to create some basic sprites and there we go this is actually working well i guess kind of at the very least we can't see where the enemies are supposed to be so that's at the very least a start so i guess now we can just flesh out our enemy class and add more and more to this to make it actually work and i guess the first thing we can start with is the graphics setup so we can actually see what's going on and to get our graphics i want to import something and this i would like to keep in its own method so let's call this import graphics and since we have different kinds of data so in my settings i for example want to import all the data for this squid for that i will need the monster name and this i'm going to add in the import graphics so in here we are going to add monster name and i guess let's create that one so import graphics self and let's just call it name and this import graphic is going to be kind of similar compared to what we have done for the player so if i go back and here we have import player assets we had a character path and then we had different kinds of animation states in a dictionary and i want to do something similar for the enemies so the first thing i want to do let's call it self dot animations and this is going to be a dictionary with only three different value pairs we have idle then we have move and finally we have attack and these three states correspond to what the enemy is supposed to do so if the player is really far away it's supposed to idle if the player is kind of close it's supposed to move and then move towards the player and play the move animation and then if it's close enough it's supposed to attack and if you look at the folders there is a folder for each enemy that corresponds to this name so for example the squid has one folder for idle one for move and one for attack and this is going to work exactly like we have done for the player so what we can do we can create a main path and this is going to be an f string and in here i want to go up a folder i want to go to graphics then i want to go to monsters i called it and now we want to go to the specific subfolder for our enemy and this is going to be the name and now don't forget we want to go into different subfolders so we need one more forward slash so this path is going to lead us to each individual enemy and let's call it main path and now all i have to do is for animation in self dot animations dot keys and in here self dot animation and animation sorry this should be animations so essentially we want to get this dictionary and go for every single key of this dictionary so right now we want to get the idle and for this idol i want to import a couple of graphics and what is i need again my import folder function so from support import let's just say star so now i want my import folder the one we created earlier and then here i just want to create my main path plus the animation so just to explain what's happening here this main path is what we have created up here and then the animation is what we get from the for loop and this for loop could for example be idle move or attack and we are just combining them and that way we get a whole path to a specific folder and then we're using the import folder function to import every single image inside of that folder and turn it into a surface and that way we can use them in our dictionary so with that we have our import graphics now next up in my init method i want to set self.status and for now this is going to be idle but later on we are going to work with this to make a change depending on how far away the player is so this could be any value inside of this dictionary could be idle move or attack and depending on the status the enemy is then going to do different actions so now we have a dictionary and we have a status pretty much the same thing we had for the player and with that we can actually start setting the image and i think this could be a good exercise to see if you're still paying attention the video is getting quite long so try to use the imported graphics so selfdot animations and the status to pick out one image for each monster i want first of all to get myself.animations so i want to get this dictionary here and from the dictionary i want to pick one of the animations depending on what my status is and right now my status is idle so i want self.status i guess could be anything but right now it is idle so this would give me a list but image wants a surface so from this i have to get self dot frame index and you might be asking yourself where do we get this frame index from do we have to create it in this class and the answer actually is no because in our entity we have the frame index and this frame index already works in the player so in this player we have no frame index but the animations still work just fine somewhere down here so frame index comes from the entity and we don't have to declare it so we don't have to worry about it but there is one thing we do have to worry about and that is the different kind of monsters so in my level we always call it a monster but that wouldn't be accurate because in my settings i have squid raccoon spirit and bamboo and for now let's just use this squid those i think look the best and now this would actually work with the import and now let's try this and there we go we can see some enemies they don't do anything right now and they're all the same but at the very least it is working also we can't detect them but that comes later so for now we have some enemies now obviously we have different kinds of enemies and that's something we have to work on now and essentially what i want to do i want to create a monster name variable and now i want to create some if statements to check what kind of name we are going to get and this could for example look like if the column is going to be 390 then my monster name is supposed to be bamboo then l if if my column name is equal to 391 then my monster name is supposed to be spirit that's not how you spell that now next up if that is not the case and my column is 392 i am really bad at typing today if that is the case my monster name should be raccoon and if neither of these is the case so else then my monster name should be squid and let me indent them all properly python tends to be a bit annoying if you use if statements on the same line oh well sublime is a bit weird but with these couple of lines we now select the right kind of monster for the specific monster name and now let's try this again and we are getting an error that we have list index out of range and the error here let me close it all is simply that when python looks at this file here for the raccoon i misspelled it it should be spelled with a double c and because of that misspelling when we imported the folder python couldn't find it and try to loop over it and well that didn't work but now let's try this and now we can see different enemies so in here all of this is working really nicely so this is then giving us a ton of different kinds of enemies that we would like to have and i guess there's one small downside here let me actually open it again so our enemies have very different sizes these bamboo ones are 64 by 64. same for the squid and same for these little flames but the big raccoons are quite a bit larger and you could give the larger ones an offset but in my case i'm not going to worry because they're basically in the right spot but that's something you could work on but it doesn't really matter that much alright now we can place our different kinds of enemies and we can actually see them in the game i guess now we can start working on their movement and let me add a separate section to it and let's call it movement and then here we already have the rectangle and besides that i also want to give them self.hit box and this is going to be self.rect and let's go with 0 and negative 10. and this hitbox we are definitely going to need because in our entity we are moving the hitbox not the rectangle so our enemies are going to need a hitbox and besides that we are also going to need self dot obstacle sprites and that's just going to be obstacle sprites and again this is going to work just like we have done for the player so in our entity we are looking through self. obstacle sprites so our enemy has to have this attribute as well and well this one we are going to get from the parameters so this is obstacle sprites and then on our level for the argument just like the player we need obstacle sprites and that way our enemies also get collision mechanics with the rest of the level it would look very silly if they didn't have that so now they have the ability to move but they well don't move at all right now so that's something we do have to work on and to make them work we first of all need an update method and this one itself and nothing else it's the usual sprite update method and in here i want to add self.move and now this move method will need some kind of speed and i want to pass in self.speed in here and to get that kind of speed in the init method i want to give the enemy some stats and actually while we're here we can add a couple of different stats and let me just copy them it is quite a few so this is going to look like this so we get the monster name and that's just going to be the monster name then we get some monster info and that is then going to give us the health the experience the speed the attack damage resistance attack radius notice radius and attack type so all of this is basically this dictionary here just now converted into attributes and that way we can use them significantly easier and in here we have our speed so now they could be moving and although if i run the game they are not going to move for the simple reason that they don't have any kind of direction or well they do have a direction but each of their direction is zero and zero so i guess you could say they're all moving except they're moving in the same place so well kind of pointless and that means we have to give them another method to check where the player is and this is done in another method that i called get status and this one itself and we have to know where our player is and all we really want to do in here is we want to get the distance to the player so in here let's just add a question mark for now because this one gets a bit more complex but let's just imagine for now that we have the distance all i really want to do is if the distance is smaller or equal than our self dot attack radius then i want to set self.status to attack then l if if my distance is small or equal to self dot notice radius then self.status to move and if neither of these is the case then self.status should just be idle so really all we're doing in here is here we have our enemy so this is our enemy then we have one radius around it and we have a larger radius around it and if our player is inside of the yellow circle then we want to attack and if the enemy is inside of the blue circle then the enemy is supposed to move towards the player and if the player is outside of that then the enemy is just supposed to idle and not do anything and that's really all we need we have to make some more refinements in here later on but for now this is good to go so now we have to figure out what's the distance to the player and in here i want to create an extra method because we essentially need two bits of information let me actually draw them actually let me just redo the entire circle i've just done and let's say our player is here right now and i want the enemy to move towards the player now for that to happen i need two bits of information first of all i need the distance so how far the player is from the enemy but to move the enemy towards the player i will also need the direction so i need to know what angle this arrow is going to be so that i can move the enemy in this direction but once i have this direction i can just move it with my speed and then use the move method and then my enemy would be moving basically what all of this means i want to create a method it's called define that is going to get player distance and direction and this one itself and the player again and what this method at the end of the day is really all supposed to do is to return a distance and a direction direction so now we have to get both of these things and this might be a good exercise to check your vector math so try to figure out the distance and the direction between the player and the enemy although don't worry if you can't do it yourself all right let's do some vector math first of all i want to get some vectors let's call it my enemy vector and my player vector and essentially all that means is i want to use pygame.math.vector2 and pass in self.rect.center so that way we are converting the center of our enemy into a vector and that makes it much easier to work with and i want to do the same thing for my player so pygame.math.vector2 and then player.center so now i have two vectors and that's going to make my math significantly easier and that's already bring us to the first variable we want to get the distance and really all we want to get is the distance between these two vectors and the first thing we have to do for that is get our player vector and subtract the enemy vector from that so this is going to give us another vector that shows us the relation between these two vectors but importantly this is not a distance right now it's just another vector and let me illustrate this this can be a bit confusing so right now this is our entire game window and let's say our player is here and our enemy is here and each of those have their own separate vector and remember a vector is essentially an arrow so the vector looks like this for the player and like this for the enemy so we're going in x and the y direction to get to our player or our enemy and when we subtract these two vectors from each other we are getting this vector here and let's say just for some numbers this could potentially be something like for the x it's going to be positive so x could be let's say 100 and for y possibly a bit less let's say 80. so this would be the vector that shows us the distance between our player and our enemy oh well not the distance just the arrow to get from the player to the enemy but importantly this is not a distance we couldn't really use this by default to understand how far away the enemy is but this we can change quite easily all we need is dot magnitude and this is converting a vector into a distance and this we can actually use so with that we already have our distance and i guess with that we can also work on the direction and this one isn't all that much more difficult it's actually very similar so we again want to get my player vector and subtract my enemy vector from that so again now we have our vector let me actually again bring it up again so now we have this vector but the problem we have now is let's say we have this vector and we want to multiply it with the speed let's just call it s to move our enemy towards the player the issue we have now is that this vector is going to be way too large so if you just multiply it with s being 5 then this arrow here wouldn't go towards the player it would go all the way to something like this so our enemy would just move way past our player since the original vector is way too large so essentially what that means is we want to reduce the length of this vector to one so we keep the direction but we reduce the length of this thing to make it exactly with a length of one and that way we can multiply it with the speed and have a proper movement and what that basically means is we have to normalize it and that way we will get a proper direction that we can actually use fortunately that is a very easy thing to do because all we have to do is pass in normalize afterwards and we are basically good to go although we do have to be careful and this is something we have seen with the entity earlier so in the move here we had to first check that the magnitude of our vector isn't zero and only then could we normalize because you cannot normalize a vector that has a length of zero so essentially we have to check if the length of this vector is greater than zero and only then can we normalize it now fortunately we already know how long this vector is going to be it's just our distance so we can use the distance in an if statement and just check if this is greater than zero and only if that is the case we want to get this vector and this distance could actually be zero if our player and our enemy are in exactly the same spot remember there's no collision between the enemies and the player and i guess what we can also do is if that actually happens so if my player and our enemy are on the exact same position we know in that case the direction could just be pygame.math.vector2 with 0 and 0. so if our enemy is right on top of the player we can just give it a vector of 0 and 0 and not move it at all and well with that we have our proper function that gives us a distance and the direction so now let me copy it we can paste it in here make sure to call it and pass in the player and right now we only really care about the first one so we only care about this distance here for now we don't care about the direction that will come very soon though but now we have another problem that i want to get myself.get status but now i have to get my player in this update method unfortunately this update method is going to run for every single way to have it every single visible sprite and passing in an extra argument to all of these seems kind of inefficient since only the enemy is going to need a player in the update method so instead here's what i'm going to do let me minimize all the methods in my level and in my ysort camera group i'm going to give this another method and i've got this one enemy update and only in here we get self and we get the player and essentially what i want to do in here i first of all want to get all of my enemy sprites and this we're gonna get in just a second and then for enemy in enemy sprites i want to call sprite dot enemy update and then in here i can pass in the player and then in my run method besides the regular update i want to call self.visiblesprites.enemyupdate and this one is going to get self dot player lay here so that way we can separate the enemy with the update method and i guess that means i want to copy or cut out all of this and give this enemy the enemy update method that is going to work very similar compared to the update method except now it's for the enemy only and this one gets self and player so now we have access to the player so the last one we have to figure out is how to actually get all of the enemy sprites and essentially what i want to do is i want to get my sprite or sprite in self.sprites so this would give us literally all of our sprites and i only want to select the ones with the enemies from that so this is going to be an if statement and here it becomes important that each of our tiles or each of our classes has a sprite type so our enemy has a sprite type and our tile has a sprite type and our player should have one as well not sure if i gave him one but doesn't really matter the player doesn't need one so what i want to check if sprite dot sprite underscore type is equal to enemy because in my enemy my sprite type is enemy now this can be a tiny bit dodgy because if a sprite doesn't have a sprite type attribute we're gonna get an error so what i want to check first is another if statement that if has attribute now has attribute basically just checks first a class and then we can check for a specific kind of attribute which in my case is sprite underscore type so we are first checking if the sprite has a sprite type attribute in the first place and once we have that we are checking if that sprite type is going to be enemy so that way it doesn't matter if the player has a sprite type or not or if we just forgot it for some other tile or maybe if you want to add more tiles later on this would basically save you alright so now we should be having a distance to the player i guess let me run the code nothing should happen yet we get invalid syntax let's check it out ah the problem here is this should not be an if statement so we only need one if statement and then we can combine the different if statements so now let's try this again and now we have name sprite is not defined oh and the reason here is i call this enemy i didn't call it sprite so next attempt and we get now name in our enemy name get player distance direction is not defined i think i know where this is coming from exactly here this should be self so now the next attempt and now things are working again although still nothing is happening but at the very least we are not getting an error so what's happening now is we are getting the status but we are not using that to move the enemy but let's work on that now then we can actually see what's going on so i want to create another method and let's call this actions and then here we need self and we again are going to need our player and in here i want to check my status so if self.status is equal to attack then i want to do a certain thing for now let's just print attack then i want an l if statement if myself dot status is equal to move i believe i called it let's double check yeah move so if this move is the case let's say we're going to work on this in a second let's call it pass for now and if neither of these is the case i well don't really want to do anything but let's just say self direction is going to be pygame.math.vector2 this line here is important if our player let me draw it actually so if this is our enemy and this is the circle that attacks if the enemy is supposed to move towards the player if the player is inside of the circle then our enemy is going to move towards the player but i also want to make sure that if the player moves out of that circle then the enemy is supposed to stop moving so this is what this line essentially ensures that once the player is leaving the circle the direction of my enemy gets back to zero so it stops moving all right the actually interesting one is this one here i want to make my enemy move towards the player once the player is getting closer and this is again going to be in self dot direction and in here we need self dot get player distance direction it needs the player and now we care about the second element being returned so index one which is the direction so this is what we are getting now and now in my any update i can call self dot actions pass in the player and now let's try this so now we can actually see something moving so now the enemies are coming towards us if we are close enough on the cache you see if the enemy is overlapping we get attack in the bottom left so now we can actually do something so this section was probably one of the more difficult parts of this tutorial because there are lots of steps that need to be taken together so if you struggle to come along i would really recommend to double check each of these methods and see what they are doing there wasn't really any easier way of doing all of this but all right i guess now what we can work on is to animate the enemies and in here we basically want to do the same kind of animate we have done for the player let me just have a look actually let's minimize all of the methods here and i kind of want to do the same thing i've done for the player to animate the different kinds of states although for the enemy it's going to be a tiny bit different so we couldn't put this animate in the entity and also apply to the enemy although it is arguably somewhat similar but let's go for it step by step so first of all i want to get myself dot frame index and add plus equal self dot animation speed so these two parameters we are getting from the entity they are all the way at the top and now i want to check if self dot frame index is greater or equal than the length of self dot animations and then myself dot status and if that is the case i want to set self dot frame index back to zero so this is pretty much the same thing we have done in these two lines except i guess the animation we have set for the player in a separate variable makes it a bit easier to read let's do it here as well so now length of our current animation so so far those two are pretty much identical and for now they will continue to be identical because now we can set self dot image is going to be my animation and i want to get my integer of self dot frame index and importantly here what we have done for the player as well we have to update the self.rect so let me copy it actually and now we are setting our rectangle in the center of the hitbox because remember we are moving the hit box we are not moving the rectangle so if we didn't add this we wouldn't display the enemy in the right position but now we can in the update method actually called self dot animate and let's try this now and we actually get animation and they don't really have a good attack animation i think this one is an attack animation yep there we go so now this thing has an attack animation and i guess the proper attack animation comes with the raccoon and there we go this is working not badly although now we have a problem and let me actually stand here i want to make sure that my enemies have a proper attack animation so for the raccoon for example it's supposed to play the entire thing and not be stuck in the attack loop which i think looks a bit silly so that is something we have to work on in our enemy and i think it's a good idea to minimize all the methods in my enemy it's getting a bit longer and in my init method i want to add another section and let's call this one player interaction and for now on here i want to have one method that's called self.can attack and by default this should be true and then in my get status i only want the enemy to be able to attack if the player is close enough and if self dot can attack is true and now in my actions once the player has actually attacked i now want to restart the timer to make the enemy not attack anymore but now we have a problem so this entire graph is the entire length of our attack animation for the enemy and for the sake of simplicity let's say it has just a couple of frames so we have zero one two three and four and each of these is a frame for the different cycles of the attack now if we set dot can attack defaults in here then we would only get to the first step and then our attack would stop so we would not actually see the attack so what we want to do is we want to set self can attack only to false after the animation has finished and this is then going to happen in my animate would i put it down here animate function so what i want to do in here is if self dots self.status is equal to attack so right now we're checking if our current frame index is longer than the animation and if we are attacking and only if those two are correct then we can set self dot can attack back to false and that way the player only stops being able to attack after the attack animation so now we have a proper method here so technically now the enemies should only be able to attack once let's try this with the raccoon so there you could see our raccoon could attack once but not again so this is working reasonably well so now what i want to do i want to create a timer that the enemies can attack again after a certain period of time and this i think could be a pretty good exercise so check the previous cooldowns we have created and try to make a similar one for the attack animation of the enemies alright first of all we need two more attributes we need self dot let's call it attack time by default it's going to be none and we are going to need some kind of let's call it attack cool down in my case i've set this one to 400 it's identical for all of the different enemies although this you could also put into this dictionary if you really wanted to but mine is already getting quite long so i didn't worry too much about it now let me minimize all of those methods and let's put it down here i want to create a timer for the attack cooled down and in here i first want to check if not self dot can attack because we only want to check this timer if this one is wrong and here we have to get our current time with pygame.time dot get underscore ticks that was atrocious spelling all around this one should work now and now if my current time minus myself dot attack time is greater or equal than myself dot attack cooldown and if that is the case self dot can attack should be set back to true now the one thing i haven't done is to get my attack time and this is going to happen in my not in my animate it's going to happen in my actions so in here besides print attack i want to get self dot attack time and it should be pygame by game dot time dot get underscore ticks and now let's try this and we get invalid syntax in the enemy ah because for attack cooldown i forgot the self now let's try it again and there we go so now we get attack okay that's a bit hard to see so the animation still doesn't seem to work perfectly let's see what went wrong ah and i believe in my get status in this line here after we have just attacked i want to check if self dot status is different from attack and if that is the case i want to set self.frame index back to zero so we essentially always want to be able to reset the animation once we switch to different animations maybe that helped nope also didn't make a difference so there's something else i missed sorry the code is getting very long it's a bit hard to plan this oh and i think i've just realized the mistake that this attack cooldown we don't actually call so self dot attack cooldown and while doing this i realized we have one attribute called the tag cooldown and the method is called the same so let's just call it cooldown our enemy only has one anyway so now let's try this again so let's go to the raccoon and this is looking much better cool there we go so now we have proper attack animations and once we add particles this is going to look even better but now we have the basic enemy logic and i guess this was a really long section so let's finish this one for now and for the next one we are going to start with the interaction between the player and the enemies so let's talk about that and this has to go two ways on the one side our player has to be able to attack the enemies with the weapon or with magic and on the other side the enemies have to be able to attack the player as well now the logic for the enemies attacking the player is actually quite simple we already made most of it all we really have to check is if the enemy is close enough and then triggers an attack and if that is the case we can just call a function to reduce the player's health now the other way around is a bit more complicated because we have to check if the player weapon actually collides with an enemy and here's how we are going to do that we are going to create two more sprite groups one is called attack sprites the other is called attackable sprites and whenever we create a weapon we are going to put it into the attack sprites and magic is also going to go in there and all of the enemies or anything that can be attacked will go into attackable sprites and then in our level we're going to check the collision between any sprite and attack sprites with the attackable sprites and if there is any kind of collision then we're going to check the tile type and trigger a certain thing for example if we have grass we're going to destroy the grass if we have an enemy we are going to lower the health of the enemy and that's pretty much the entire logic there are a couple of visual things we are going to add but let's implement the basic logic first here we are back in our main file and i want to go to level and in here we already have quite a few different methods and i want to go to my init method and add a bit more here and i guess we can put this under attack sprites it doesn't really matter where you put it so here we have attack sprites and this is just pygame.sprite.group then i can copy it and let's create another group that's called attackabilt sprites so the basic logic is we are going to spawn our weapons and our logic inside of this group all our enemies will be in this group and then we can check the collisions between these two groups and check if we hit anything but for that to work we actually have to assign things to the different groups so let's start with the enemies in create map so in this section here actually in this section here we are creating all of our enemies and right now the enemies are just invisible sprites but they should also be in selfdot attackable sprites and i guess for this one let me put the enemy on multiple lines so it's a bit easier to see what's going on because enemies will get a few more lines of code and i'd like to keep it a bit more readable now next up when we are creating an attack so in this method here we have our weapon and right now this one is also only invisible sprites and it should also be in self dot attack sprites so now we have well different kinds of sprites and there's one thing i forgot because the grass is also supposed to be attackable and that could be a good exercise so try to figure out which group the grass should belong to should be really easy so in my grass right now i have self.visible sprites and self.obstacle sprites and i want to add a third group that is self dot attack a bill sprites attack bill sprites there we go and since grass is also getting quite large let's put this on multiple lines so it's a bit easier to read so now we have a couple more groups although if i run the game nothing is going to change but now in my level let me minimize the create map function again it's getting a bit large i want to create another method and let's put it right at the end and let's call this one player attack logic and we need self and nothing else and in here we basically want to cycle through all of the attack sprites and then check if any of those are colliding with any of the attackable sprites and be aware for now we only ever have single attack sprite whatever our weapon is but later on once we have magic there could be multiple sprites inside of that group so just be aware of that so first of all let's use an if statement to check if anything is in attack sprites in the first place because if not we don't have to bother anyway now once there is something inside we can check for attack sprite in self dot attack sprites and now i want to use pygame dot sprite dot sprite collide and in here we need a sprite we need a group and then we need to do kill argument and let's go through what this one means and sprite is the easiest one it's just going to be a sprite let's say it is this sprite here then we are going to check this sprite if it collides with any sprite inside of a group so let's say we have our group here and inside of this group we have a bunch of sprites it doesn't really matter how many you have it's completely relevant and this method basically goes through if this sprite is colliding with any of these sprites and then the do kill argument determines if the yellow sprite is gliding with the purple sprite are we going to destroy that sprite and that's literally all that sprite collide does so in my case i don't want to kill any of the sprites for the sprite i want to check my attack sprite and for the group i want to look at it's going to be self dot attackable sprites and this then returns a list of all the sprites that have been colliding so we can store it in let's call it collision sprites so what we can do now once we have that we can check if collision sprites exists so if we have any kind of collision and then once we have that we can cycle through that list and let's call it for target sprite in collision sprites and now we finally have the sprite that have been colliding with our weapon so what we can do now is check different kind of things but i guess for now we can just check if this is working so let's say target sprite dot kill so we essentially destroy any kind of sprite we are attacking and we have to make sure we're actually calling it let's call it right after the enemy update so self dot player attack logic and now let's run it we don't get an error it's good start and now i can attack the grass it disappears i can attack the enemies they disappear and this seems to be working quite well obviously not ideal so far but at the very least something is working the problem now is we don't just want to destroy the target sprite we want to do something else and to figure out what we have to do we have to figure out the sprite underscore type so for example for my grass the sprite type would be grass that's the one we set here so this is basically then an if statement so if the target sprite is equal to grass then well if that is the case we just want to destroy the grass anyway so in here we actually do want to get target sprite dot kill and let's try this now so i can attack the grass this one still disappears and if i attack the enemies they also disappear so something has gone wrong here let's check oh and i realized that this argument here should be false because i do not want to destroy the sprite so you have just seen that because this one was true we are destroying any kind of sprite so we basically never got across this line so now it is false let's try it again now so we can still destroy the grass but now the enemies we can't destroy anymore now it's working and right now this destroying here looks kind of boring but later on once we had some particles it does end up looking significantly better but step by step now besides that if we're not attacking grass i guess i can just add an else statement because we only really have one other thing we can attack and that's the enemies although each of our enemies also has a sprite type so you could be more specific if you really wanted to but now we can again target our spread type and now i want to give them a method and let's call it get damage and for this one i need a couple of arguments so first of all i want to know what the player is doing and besides that i also have to know with what attack we are hitting the enemy so are we using a weapon or are we using magic so i basically want to know the attack sprite dot sprite type so this is the attack sprite we got from all the way up here that we are going to pass in there and let me just make sure that our weapon actually has a sprite type so we can reopen our weapon and right now this one doesn't have a sprite type so we have to give it one and let's do it right at the top so self.sprite underscore type is going to be weapon so now we can use it and let me close it again so we don't have too much random stuff and all right now in our enemy we have to create this method and i guess let me copy it so we can work on the parameters so back in my enemy let me minimize things in here i want to create get damage and we will need the player and besides that we are also going to need let's just call it the attack type and essentially what i want to do in here is if the attack type is equal to weapon then i want to set self dot health negative equal and now i have to figure out by how much i should lower the health and for that i have to know what is the player's damage and this i'm gonna get with another function and from the player i want to create a new method let's call it get full weapon damage so this is basically a getter function and let's copy this one and now we can go to my player in here let's minimize things as well and now we can add another method in here itself and nothing else and in here really all we want to do is want to get our player base damage we can get this from this dictionary here so our base attack is going to be this one and then besides that we also want to get our current weapon so the one we have basically up here and we basically want to get these two together and that is our full damn mitch so we're just adding those two numbers together so in this function let's first get the two different kinds of damage we have so we have our base damage and we have our weapon damage and all i essentially want to return is my base damage plus my weapon damage so all i have to figure out is what these two numbers are going to be and actually let's do this as an exercise so try to figure out from the player what is the full damage so what is the base damage plus the weapon damage for the base damage we essentially want self.stats and in there we have what is called attack we are essentially looking at this dictionary entry up here and then besides that i want to have my weapon damage and for that i first have to get my weapon data so in settings i am essentially accessing this data here and i want to get one of those keys let's say right now my weapon is a sword and then i want to get this key and this is information i can get from self.weapon what i can do here is weapon data and then self.web pin and once we have that i can just pick another entry because now we have this dictionary for the sword and inside of this dictionary we have damage and well all i have to do is add this to damage oh and while we are here i realized i forgot something because in our settings we also have a weapon cooldown and i didn't include that one in our player cooldown so in my player in cooldowns here we have the attack cooldowns and this is my base cooldown and to watch this i also want to add the weapon cooldown so in here we can basically do the same thing so we still use our weapon data let's copy the entire thing but except now instead of damage i want to add cool down and that is going to be this cool down here all right but now we have our get full damage so with that we can return to our enemy and now we have something i guess later on what we're also going to do is else let's add a pass in here but this is going to be magic damage it's going to work slightly differently and right now i guess this would work but we would never be able to see it because well our enemies don't have anything to well react to so i want to add another method again and this is just going to be check def needs self and nothing else and all we're going to check in here is if self dot health is smaller or equal to zero and if that is the case i just want to run self self.kill although right now this logic isn't going to work but i guess let's just try the entire thing and see if things are working so we can still destroy the grass enemy get damaged doesn't work so let's have a look should be here in my player attack logic so we have self the player and the tech sprite so this one seems to be working so in our enemy i'm pretty sure i know what i forgot and what i forgot itself so now let's try this again let's attack an enemy and we can see that nothing has happened and this happened because in my enemy i'm not calling check def so in my update method we can run self.jackdev you could also call it in the enemy update it doesn't really matter so now let's try this again and there we go now we have something that maybe a tiny bit weird that all of our enemies die in one hit so even the bigger ones they just die immediately and this happens even though they should be having quite a bit of health so in my settings for the monster data the raccoon for example has 300 health but all of our damage is like 15 or maybe 30. and the problem here is that get damage runs on every cycle of our game so we think we're hitting the enemy once but pygame just sees a collision and it runs this get damage every time it has this collision which in our case is 60 times a second and that way we are essentially multiplying our damage by 60 which kills anything instantly so it's not really fair and essentially what we have to do is to create a timer that enemies can only be hit after a short amount of time so essentially all that means is we have to create another timer and let's put it all the way down here so here we have let's call it the invincibility timer and let's add something like let's call it vulnerable by default this is going to be true then we have self dot hit time by default this is none and let me spell it properly and then self dot invincibility duration let's say it's going to be 300 but again this number you could also put into the settings to have different kind of enemy behavior in my case well it wasn't really needed so now we have the basis for another timer but first of all let's implement that our enemy can only be hit once in a while and this is going to happen in my get damage so in here i want to check is if self dot vulnerable and only if that is the case i want to run all of this and by the end of it once we have run everything else i want to run self dot vulnerable is going to be false and i guess now let's try this so now the enemies shouldn't disappear anymore and they don't cool so seems to be working but obviously we do want to be able to attack the enemies so what we also have to get is self dot hit time is going to be pygame dot time dot get underscore ticks and with that we have all we need to get another timer and i guess this cooldown let's call it cooldowns and now in here we can check if self dot vulnerable if that is the case then we want to run this timer and i guess i can run the current time outside of this function so we have it available everywhere and then here we just want to check if my current time minus self.hit time is greater or equal than myself dot invincibility duration and if that is the case self. vulnerable is going to be true and i forgot this should be not self.vulnerable and now let's try this so i probably have to hit the enemy a couple of times but it does disappear eventually let's look at this one so i hit it once i hit it twice there we go this looks pretty good okay those ones are going to take longer so i just assume it's going to work but all right so with that we have the ability to damage our enemies the problem right now is the enemies aren't really being pushed back so our attack is well kind of pointless because the enemies can attack us right away anyway so i want to get them some kind of hit reaction that they are being pushed backwards and that is going to be another method let's call it hit reaction and basically what i want to do in here i just want to check if not self. vulnerable so if my enemy has just been hit then i want to set myself dot direction and multiply it with myself dot resistance and this number should be negative so think of it like this right now this is our enemy and this is our player and our player has just attacked the enemy essentially what i want to achieve is that my enemy is being pushed back in the same direction and the distance by how much the enemy is being pushed back should come from the self dot resistance and this self.resistance we are getting from somewhere in the enemy so i believe it is there resistance so that's kind of all we are going to need and this i just want to call in my update let's call it right before move so hit reaction that way it's going to happen early on but now i also have to make sure i actually get the right direction so in my get damage all the way at the top i want to set myself dot direction and in here self dot get player distance direction i want to pass in the player that i already have and then just get the value with number one so this is the direction and really all we're doing here is we are working with the direction of the enemy and just moving it in a different direction so i guess let's try if this is working so there we go they're being pushed back and this is making all of this feel much better and let's use different weapons this also works cool so now we have well a better get damaged method although there's one more thing i would like to implement and that is that my enemies are flickering once they are being hit actually they should apply both to my enemy and my player so essentially i want some kind of indicator that they are being hit and usually in games this works by flickering and to achieve that i have to work with the visibility of both my player and my enemy and that is something we can kind of put inside of the entity although since our player and our enemy are animating slightly differently we do have to put this in kind of different ways but let me actually implement it so in the enemy for my animate i want to add a bit more at the bottom to make them flicker once they are being hit and essentially what that means is if self dot vulnerable and again this should be not because we're checking once the enemy is being hit then we want to essentially flicker and if that is not the case so else then i just want to get myself.image and set the alpha to 255. so when you set the alpha you set a transparency of the layer and 255 is the full value so all of this basically means if the enemy is not vulnerable anymore this one then we are setting the full alpha but if that is not the case i want to get a specific kind of alpha and this we are going to get from somewhere else and this can either be a 0 or 255 so invisibility or full visibility and then self dot image dot set underscore alpha with the alpha so now we just have to figure out a function that toggles between 0 and 255 and the same thing we are going to need for the player so i'm going to create this in my entity and let me minimize all the other stuff in here we are not going to need it so in here let's call it a wave value l u we need self and nothing else and let me explain what we are going to do and we are going to use a sine wave in here and let me explain how it's going to work so let's say this is going to be a graph we have here our time and on the y axis we have the well y axis and a sine wave kind of looks something like this except in beta drawn and we can check each point of this value in time and pretty much what i want to do is if this curve is positive so if we are here we are going to return 255 and if we are below that curve so we are down here then we are going to return zero that way we are switching between those two numbers actually pretty simple but first of all for that to work we need from math import syn and now all i want to get is my value and i need to get my sign value and in here i have to pass in some kind of x which in my case is going to be the time and the time i get with pygame the time dot get underscore ticks and now if this value is greater or let's say equal to zero then i want to return 255 and if that is not the case i want to return zero and let's add proper indentation and there should be return and that's all we need for this method i can go back to my enemy now and self.wave value and no arguments are needed and now this should actually be working let's try so now this is working beautifully cool makes the game look significantly more responsive nice now if you wanted to do the same thing with a white color instead of invisibility you would probably want to work with a mask but in my case that's a bit of an overkill but i have made a whole tutorial on how to use a mask you could totally use that one as well but alright now i want to give my player the ability to flicker as well so in my player i want to minimize all the different methods again and look at my animate and in here i want to add flicker now unfortunately to actually implement this we well we need to know if the player has been hit or not which we don't know just yet so let's first implement the enemies hitting the player and then we can work on the flicker and fortunately this isn't all that difficult the only real limitation is that we have to figure out how to get from our enemy back to the level so we know when the enemy is attacking the player that's going to happen in where are my actions so we know in here we can print an attack if the enemy is attacking the player that one is working perfectly fine but the issue is from this place we can't really access the player actually we can we have the player right here so technically we could run something on the player from here but i don't want to do that but a simple reason that later on whenever the enemy is attacking i also want to create some particle effects and for that to work i have to create this function in the level so essentially what i'm going to create is create a couple of methods inside of my level and one of them for example is going to be damage layer this one will need self as always then we need an amount and then we need an attack type amount should be fairly obvious it's the amount of damage the enemy can deal attack type is going to be in settings it's what we get from attack type it's basically what kind of particle we are going to spawn once the enemy is attacking but for now we are not going to use it so now in here we want to write a function that can damage the player but first of all we need to deal with the same problems we have with our enemies that we first want to check if self dot player dot vulner vulnerable so essentially we want to create a timer after the player is hit so we can't attack the player multiple times in one attack but essentially once we have that we're going to implement that in just a second we want to get self dot player dots health and from that reduce the amount then we want to set self.player.vulnerable to false and in our player we want to have self dot player dot let's call it hurt time and this is going to be pygame dot time dot get underscore ticks and at the end later on we want to spawn particles but we don't have that one just yet now this damage player i want to create from the enemies so in my create map when i am creating the enemies so all the stuff down here i want to pass this one in there as well so self dot damage player and as always don't call this function and now in my enemy we also have to put this into a parameter uh spelling it correctly there we go so now in my let's call it player interaction i guess it fits best in there so self dot damage player is going to be damage underscore players what i called it oh i wrote parameter well never mind uh damage player that makes more sense so now our enemy has the ability to damage the player and now in my actions instead of printing attack i want to run self dot damage player and in here we have to figure out an amount and an attack type and well if you look at the init method we have a ton of statistics in here so the first one is self.attack damage we can just pick this one and paste it in the amount and we can do the same thing with the attack type it is all the way at the bottom this one here so attack type and actions this one here so now our enemy is able to attack the player and i guess let me minimize all of the methods it really is getting a larger project all right so this should be working at least hopefully now in my player we just have to set up all the attributes for the timer and let's add another section to this and let's call it a damage timer and in here we have self.vulnerabil which is true by default then we have self. i believe i called it hit time or was it hurt time it's hard to tell i called it her time there we go so self.her time and this by default is going to be none and finally we need something like self.invulnerability duration and let's say this one could be 500 seems like a decent value but you can take it with this and all right now in my not animate but in cooldowns i can add another timer so in here if not self dot vulnerable then i want to run the timer so if current time minus self dot hurt time is greater or equal than so self dot invulnerability duration and once that timer is running we want self. vulnerable and set it back to true so now okay well now we can't really see it but we should actually be able to see it in our health bar so let's try it and there we can actually see it in our health bar it's going down so obviously if it goes below zero we should be dying but in my case that doesn't really matter so much at the very least we know it's working so now in the player not the level the player we can now start working on the flickering and let's do this as an exercise so try to figure out to make the player flicker once we get hit should be very similar compared to the enemy right so if self. vulnerabil is not the case then i again want to get my alpha value and we want self.wave value the thing we get from the entity so this one here and we want to get our self.image.set and paste in the alpha in here and if that is not the case then self dot image dot set underscore alpha and set this to 255 so full visibility and that should be all we needed let's try this now and we indeed get hit and we can still attack the enemies and that is working really well now i guess the one downside is it's very easy for enemies to overlap but well not going to worry too much about that but you can add a few more collision mechanics and improve on this alright so with that we have pretty much all of our collision mechanics at least in the most basic sense so with that let's start working on the particles that's going to be another major section now a particle effect sounds difficult in theory but in practice it really isn't that hard we already kind of created the basics for it anyway so essentially for my particle effects it is just going to be another sprite that animates for a couple of different images the only difference now is that this particle effect is going to disappear once we're running out of animation frames so we're not looping the animation anymore we're just playing it once and then we are giving it a position and that's kind of all we need although there's one downside here that we have a lot of different images for all of the different animations so i think in total we have about 15 different animations and each animation individually has about 5 different frames so we are looking at a lot of images overall and what i want to do is to import all of these images when the game starts and then keep them in memory and only play them when they're needed in the game and the massive downside to avoid here is that we are importing images every time we are creating a new particle effect because that would be very slow importing images does take some time although i guess this is something that we can work on when we actually work on it so let's go into the code and let's have a look at this here i'm back in my file and i can close a couple of things because we don't need them for now so my entity and my tile and i guess for now my enemy as well i'm not going to need them and i do want to create a new file and let's call this one particles.pi and in here as always i want to import pi game and i already know that from support i want to import my import folder and now let's just create a dummy particle effect and that's going to be a particle effect class and this one is going to inherit from pygame.sprite.sprite and in here i want an init method as always we need self spelled properly then we need a position and we want some animation frames so this is what we are going to loop over where we are getting this from you will see in a bit and then finally what groups we want to pass this into and then we need super and dunder init as always with not self but with the groups and now in here we need all the basics for an animation so self.frame index is going to be 0 then self.animation speed is going to be 0.15 self dot frames is going to be the animation frames but now we can already set the first image so self.image is going to be self dot image dot get underscore rect and then here self dot frame index so essentially this is going to be the basic setup for any kind of animation and now that we have that we can create an animate function give itself and nothing else and now self dot frame index plus equals self dot animation speed and now here we come to the difference so if self dot frame is greater or equal than the length of my self dot frames so we are going beyond the length of our animation then we want to self.kill but else self.image is going to be self.frames and we want an integer of self dot frame index so really all we are going to do in here is we are increasing frame index and if we are still inside of the list we are just picking one image from this list however if we go beyond that list then we are going to destroy that sprite so this way we are only running this animation once and once the animation has finished we are destroying the sprite and now we also have to be able to call this particle effect with the update method and then here self dot animate now we have a basic particle effect the problem is we need to figure out where to get these animation frames and now you might be tempted to just create another method like import particle images or something like that but that'd be a really bad idea for the simple reason that we have a lot of particles and if pygame always imports something when we destroy an enemy or some grass the game is going to run very slowly so i'm going to do something else i'm going to create another class and this i have called animation player doesn't need any inheritance and in here we are going to create an init method with self and also nothing else and this one is going to get one long dictionary where we are importing every single thing so this is going to look like this a slightly longer dictionary that well um imports all of the different material so we have our flame our aura and our heel so these are both played when the player heals then these are different attack types then we have our monster deaths and we have different leaves when we are destroying grass although in here i have created one more method that is called reflect images and this we also have to create in here let's make sure i am on the right line should be this one let me actually minimize this dictionary it's getting very hard to read things so what i want to do in here is reflect images and we need self and frames and let me demonstrate what this one is doing right now for the leaves so this is when we're destroying grass we have six different animations and pretty much what i'm doing here is i'm importing these animations twice once in the proper direction and then once reflected so that way we are going to get a bit more variability in there that's really all it is and really all i'm going to do in here is for frame in frames i'm going to create a flipped frame and this is going to be pygame dot transform dot flip and we want to flip the frame for true and false flip can reverse something up in the x or in the y axis in my case i only want to flip the xaxis and ignore the yaxis which is why this one is true and false and now i have a flipped image and i want to save this one in a new list so let's call it new frames and that one's going to be an empty list and now new frames dot append and i want to get the flip frame and at the end of all of this i want to return my new frames and that is basically all we are going to need for now and now back in my level we can start working with this particle effect so in here all the way at the top actually let me minimize all of this stuff again it is getting a bit confusing so at the bottom here i want another section and let's call this one particles and i'm going to create my animation player with my animation so the animation player we have created in here and this animation player is basically going to be able to run a particle effect i'm going to see in a second how that's going to work but first of all we have to import it so from particles import animation player and to illustrate how that is going to work let's create our grass particles so in my player attack logic i know when i have destroyed some grass so in here i want to add a bit more logic to spawn some particles and basically what i want to do is run self dot animation player and do something like create grass particles but for that to work i am going to need two bits of information at the very least i need a position and i need to group so i can put these sprites into the visible sprite group but i am also going to need a position so let's first get the position and the position we can get fairly easily all i need is my target sprite dot rect dot center so we are playing these particles right where the grass used to be now next up for the group we just want self dot visible sprites and let's put it in the list so we're doing it in the same way we have done earlier pretty much all we have to do now is actually create this method here in my particle animation player this is going to happen down here great grass particle we need self we need a position and we need the groups and in here first of all i want to get some animation frames and the animation frames we are getting from self.frames because in here we have our leaf and i essentially want to pick a random animation from this list and to pick a random animation we need from random import choice and now in here i can just call choice and pick for myself dot frames and in there i have leaf so leaf is essentially a tuple with a bunch of lists inside and we are picking one of these lists and now that we have that we can actually create a particle effect so particle effect and then we need these parameters let me just copy them in here so position we already have animation frames we get from animation frames and then groups we get from groups so we didn't actually have to make any kind of change and well that should be it let's try so we get an error with inconsistent use of space let's see where he's complaining in there and in return new frames and from level a couple of errors so from particles in there not sure what happened with this one that was very strange okay there we go and now you can actually see that this one it took quite a bit of time to load and we get a key error so let's check my particles and oh i didn't mean left i mean leave okay now let's try this again now we get self where was that arrow so in particles we are getting self.image okay it is getting a bit late let's try this again now and now particle effect has another problem let's check it out and self.image this should be self.frames um it may be getting a bit very late let's check this out let's try again okay and now for the particle we are going to need a rectangle and this we get with self dot rect is going to be self dot rect dot get rekt and then here i just want to place the center is going to where the position will be okay we are working for all the errors so now particle effect has the same error that shouldn't happen anymore self dot image okay i am going to take a break after this section okay now particle effect we are back here and this should be self dot frame index so another attempt there we go finally now we have some particle effects that are going to spawn randomly and this is looking much better now there are a couple of things we have to work on first of all right now we are only spawning a single leaf which is not great so i want to create multiple and essentially what i want to do for a leaf in range and then here i'm going to use rand int which i have not imported yet i believe from random we have choice but we don't have rendent i want to get random number between let's say three and six and then for each of those numbers we are going to create another animation and that way we get a bit more particles let's try this now this already feels a bit better so this is quite a nice effect cool although now i feel like in my level this position doesn't feel like it's really appropriate so i want to give this one a tiny bit of an offset so i'm just going to add an offset and this is going to be pygame.math.vector2 and here 0 and 75. so we're just lifting up the particle effect by a tiny bit and this i'm just going to subtract from my position and that just feels like it's looking better and there we go might even be a bit too high although this one feels pretty good and okay with that we have some basic particle effects and we are making some solid progress okay let me close it and now we can work on the other particles for the enemies and fortunately we already have in my level let me minimize all of this again we already have one method that's called damage player and in here we want to spawn some particles so what i want to do in here is self dot animation player and let's call this a bit more generic generate particles although for this one we need a few more arguments so i want to know what the attack type is going to be so which of these different attack types are we going for so slash claw thunder and leaf attack besides that i need a position and i will need the groups where they should be and we can basically figure out all of these things right now so the tag type is pretty straightforward this is the one we already get from the argument position is going to be self.player player.rect.center and for the groups i'm just going to go with the visible sprites so now all we have to figure out is how to create this function here about this method so in my particle effect i want to create my particles we have a tag type we want a position and we want the groups and let's do this one as an exercise so now try to write this function that our animation player plays one particle once the enemy is attacking the player alright first of all we need animation frames again and we want to pick from self.frames and in there we have different kinds of attack as a key so we can just pass in the attack type actually i think since we are later going to use discrete particles for something other than attacks let's call this not attack type but animation type that makes a bit more sense and now we have our animation frames now i can just call particle effect we again need a position we need the animation frames and we are going to need our groups back in my level now i have all i need i think and let's try this actually let's check let's reopen my enemy and let's see if we are passing in the right information so when we call in my where is my actions so in my actions when we call damage player we pass in attack damage and attack type so attack type is what we need i guess let's try it and let's see what we get so again we have problems with the indentation i do not know what his problem is okay let's try now and now if the enemies hit us we get an error so three position arguments but four were given so let's have a look i think i already know the problem i forgot self okay now let's try this again and now we get proper animations and let's try different enemies so we get this one and we get sparks we get all of this i may have spawned too many enemies uh okay but this is looking pretty good let's get to this squid as well and this one okay yep you can definitely see it but yeah i pretty much spawn too many enemies but who cares right now okay so with that we have our basic particle system and what you can see in there as well we have used basically the attack animations and the leaf animations now there's two more that we need to figure out we have the monster death animation and we have the magic one the monster deaths we can already take care of the magic ones come in the next section so let's talk about the monster deaths and essentially all we have to do is play this animation once the monster is being destroyed all this really means is back in my level let me minimize this one i want to create let's call it trigger death particles and we need self and a position and a particle type and all i'm really going to do in here is get myself dot animation player and call create particle the decoded particles create particles yes particles and i get the particle type from the argument same for the position and they should always be in self dot visible sprites and now all i have to do is when i create all of the enemies again so all the stuff down here i'm going to pass this function in there as well so self dot trigger def particles and now in my nme class i guess let me minimize all the methods here as well we first want to create another parameter so let's call it trigger def particles this one has to be stored let's put it into play interactions self dot trigger def particles is going to be trigger death particles so now we can call this method from inside of the enemy actually let's do this as an exercise so try to figure out when to call this method with the different arguments all right so i want to trigger this when the enemy is dying so this line here and really what i want to call is selftaught trigger death particles and in here i need let me actually copy it from the particles so we're just calling the animation type a position and a group and in here let me open it in the level we want to trigger def particles we need a position and a particle type so in the enemy position and particle type now position is going to be self.rect.center and the particle type is just going to be self.monster name i think i called it all the way at the top uh monster name there we go so this is the name if you look at the particles monster name is the name of the particle or the name of the key and with that we should be good to go let's try so now if i tag any of these we're getting a proper animation so let's try it again looks pretty good and let's try with a different enemy u and this is also working so i assume they all work identically and with that we have most of our particles covered the one thing we still need is the magic so in the next section we are going to figure out the magic that one is going to be a bit more complicated but we are getting very close and i'm going to take a break before i go to the next section because those were way too many errors sorry about that so let's talk about the magic and for the magic we right now have two different spells one for fire and one for healing and those two do very different things the flame is going to work kind of like the sword that it damages enemies whenever there's contact and this is literally going to work like the sword in the sense that we are going to put the flame inside of the attackable sprites and then check for collisions so all we really have to do is place the flames and animate them for which we have most of the things we actually need now for healing it is getting a little bit easier because this one doesn't need any collision with the enemies we just have to spawn some particles and heal the player so increase the health but i want to create this in a slightly more flexible way so i'm going to put all of this into a separate class and let's implement this straight in the code i think that's going to make the most sense so here we are back in our project and i want to create a new file that i'm going to call magic dot pi and in here i want to do the usual so import pygame and from settings import all of it and now i want to create a class that i called magic player there's no need for inheriting anything and i want to create an init method with self and besides self we also want to get an animation player as a matter of fact this is the animation player we have created here so when we create this magic player it can play animations from our animation player so in here all i want is my animation player and that's going to be my animation player and now basically all i want to do i want to have one method for here needs self as always we're going to add more parameters later on but for now let's add pass and i want to create a flame that for now works in the same way that it doesn't do anything so right now we have two spells you could be adding more here if you really wanted to so how can we actually use this thing now well in my level let me actually move it all the way to the left because it's the most important one and let's minimize some methods so essentially what i do in here in my init method besides the animation player i also want to create a self.magic underscore player and this one is going to be my magic player and as the one argument we need the self dot animation player and for this to work we have to import from magic import magic player so now we have our magic player and as a matter of fact we already have a create magic method and then here we have the style the strength and the cost and this we can use to cast the magic so essentially what i want to do is if the style is equal to heal is one i want to cast some healing and if the style is equal to flame i want to do something else which for now is going to be pass but let's start with healing that's the easier one i think so we already have our self.magic player and all i want to do here is call heal so i want to call this heal method and i just realized this is a horrible way to spell magic so let me save this one and let's spell this one properly so magic dot pie all right now in my here i want to actually cast the heel but let's first check if this is working in the first place so i want to print heal and this should actually be working for now so let's try it let me go to my heel and we can see heal we still get the other stuff but that doesn't matter right now so i printed this one as well but i guess we can get rid of it we don't need it anymore at the very least we know this heal spell is going to work and in here now we have to figure out a couple of parameters so i first of all want to know my player then i want to know my strength then i need the cost and then i need the sprite groups and now when we call this thing we can pass all of this in here let me actually copy all of the parameters that's going to make things a bit easier my player is just going to be self.player in this one we need for the position now the strength and the cost i already have is just the strength and the cost up here so we can just pass both of those in here and we are good to go now finally for the groups this is going to be a list again and in here i just want to have myself dot visible sprites and since there's no collisions with these sprites we don't need anything else but for the flame we will also need our attack sprites but all right now we have all the arguments we need now we can actually work with this and the first thing we will need is if we can actually call this spell so if my player dot energy is greater or at very least equal to the cost and if that's not the case nothing should happen and once that is the case i want to get my player dot health and at plus equal the strength of the spell and besides that i also want to get my player.energy minus equal the cost so we're increasing the health of our player and decreasing the energy that's kind of how all of this works and i guess now we can actually try this so now let's select the magic spell it is working but now we if we press this again well we keep on increasing our health bar but once we're running out of enough energy we stop being able to cast it although the animation still plays but i kind of like the effect all right now what we have to figure out is that if our energy gets too large we don't want to overshoot on the health bar which also is fairly easy to do all we want to do is if our player health is greater than or equal to my player dot stats and then here health now this health is our maximum health so in the player i have it right here our stats is what we initiate the player with so 100 here right now is the maximum player health and then in our code we are keeping our actual current health in this variable or this attribute so this is going to be our max health if our current health is greater than our max health i just want to set my player health equal to my player dot stats and the health in here so now i can select my healing spell again now we have maximum and i made a typo this should be player now let's try this again and now we have our energy still decreasing but we cannot increase our health anymore and i guess here we have to make a decision do we want to play it to be able to increase the health or cast the healing spell if we already are at maximum health and i think most games handle it by allowing the player to cast the healing spell even though we have full health so i'm not going to worry about it but with that we have the basic healing mechanic now finally we have to spawn some particles and in my particles i have aura and heal and i want to spawn both of those once we are casting a spell hence we should be calling this animation player here twice and i think this could be a good exercise for you use from our particles they create particles method and spawn the aura particles and the heal particles every time we are calling the heel magic effect right so in my heel method i want to get myself dot animation player and create underscore particles so now we are calling this method here and this method has three arguments and in my magic i want to paste the paradise so animation type the first one is going to be aura then for the position this should be in the center of my player so i have my player i want to get the rect and the center and groups we are just going to get from the groups we pass in into the parameters so that's something we're going to figure out in a bit but now in my level i am already casting self.visible sprites in here so i have the right group and this should give us one particle animation let's try it actually so now we get the aura spell this looks pretty good and once you run out of energy it doesn't work anymore and now i also want the heal particle and for that i can just duplicate this line and right here for the particle type so now let's run this again and now we get the other particle as well what you could theoretically do give this heel extra effect an offset that can look kind of nice so in magic when you add the center you can add plus pi game dot math dot vector 2 and 0 for x and something like negative 60 or the height and now if you try this again this thing is now slightly on top um whatever you think looks better in my case i'm not going to care too much about it so let me just remove it so all right with that we have our healing spell although there's one more thing i would like to add because right now we don't really have any way to increase our energy once it's run out which doesn't feel very good so in my player let me minimize all of the methods here i want to create another method that i called energy recovery and we need self and nothing else and basically what i want to do in here is if self.energy is smaller or equal to myself dot stats and energy and then i want to get self dot energy and for now let's say plus equal one although that number is going to be way too high and now if our energy for whatever reason gets greater than our maximum energy so else i want to set self dot energy equal to self dot stats and energy and now we can call this method so self dot energy recovery and we should have recovering energy so now you can already tell our energy is increasing really fast i can't even cast the spell fast enough to deplete my energy but at the very least it's working but we do have to make some adjustments in my player first of all they shouldn't be smaller or equal they should just be smaller so now let's rise again and now our energy bar stops at the maximum but if we cast a spell it still recovers way too fast so instead i don't want to add one i want to add 0.01 and now if i cast this again now we can see a small increase and even if i cast the magic it still keeps on increasing so this works quite nicely now what you can also do is use in my stats i have it right here in here we have magic and this one i think is best to use it for two purposes one is our magic damage and then the other is our magic recovery so i want to multiply this with self dot stats and magic so that way if we're leveling up our magic we do more damage and we recover energy faster so now let's try this again and we have i guess it's kind of fast but you can play with this around and see what works well but i quite like this so now we have magic recovery and we have our healed spell so next up we can work on the flames and those do get a bit more complex although not that much let me explain the basic logic before we start right now we have our player here and essentially what i want to do is i want to cast five different flame spells that go in the direction of the player so for example if our player is facing to the right i want to create one flame two flames three flames four and five flames and then each of those flames get a bit of an offset to create some randomness here to make it look better and well that's the general idea and let me leave the graphic open for now we're going to need it in just a second again but first of all in my flame i want to check if my player dot energy is greater or equal to the cost of the spell oh and i forgot we need the parameters again so in here i want to get my player i want to get my costs and i want to get my groups now importantly here we have no strength i'll show you later how to get that strength but now we can work on the cost and once we have cast a spell i want to get my player energy minus equal the cost so now we have the basic setup and now what we have to figure out is how to get this direction because this direction determines if the flames are spawned to the right to the bottom to the left or up so this direction is really important to figure out fortunately we can get it reasonably easy from the player itself and we have kind of done something similar before so what i want to get is if my player dot status and my player status i can get from let me minimize all of this again it's kind of hard to read so when i imported all of the player assets we created animations and in here we have all of our possible player states and i just want to get just the direction so up down left or right and if we have something like down underscore idle i want to get rid of the underscore idol actually let's do this as an exercise because we have done this like four hours ago so figure out how to split this string to only get the direction and ignore anything like idle or attack alright so what we need is the split method and in here the one argument we need is an underscore so that is going to return a list with the strings that we have split so for example if we had down idle we would get a list of down and idle and in my case i don't care about anything that comes after the first element so i just want to get the index of zero and if that happens to be let's say right then i want to create a direction that is going to be a vector so pygame.math.vector2 and a vector facing to the right is 1 and 0. and that way we can use the vector in some math and now i can just copy all of this three times to have it three times and turn this into an l if statement and then at the end we have an else statement now first of all here we have left and left should be negative one and zero then let's say we can go with up and up has zero on the x and minus one on the y and then finally for else let me copy this direction so else is going to be just one which is downwards so with that we have our different directions and i feel like putting all of those on the same line looks a bit cleaner although it's entirely up to you to do this but in my case when i have a one line if statement tends to feel better to have all of this on one line now we have our direction and now basically what i want to do since i want to spawn five flames i want to create a for loop so let's call it for i in range and then here you might be tempted to go something like five but i want to use this i for the offset so the first element should be a 1 and that way we can multiply this one with the tile size to get an offset of 64 pixels to the player center so this shouldn't start at zero it should start at one and since we still want five elements it should stop at five and go up two but not include six so now we have a proper for loop and now for the math i have to split this thing into horizontal and vertical direction so if direction dot x exists so it's different from zero this is going to be horizontal and else it's going to be vertical and let's just add a pass here for now so we don't get an error now we can work on let's start with the horizontal one first of all i have to get an offset and this one is in the x direction and basically what i want to do let me draw this out let me get a bit of space here we have my player again and let's say my player is facing to the right so my direction is going to be a vector that is one and zero the one we have created up here and essentially what i want to do i want to multiply this with i so the number we got here so if the vector is positive this one is going to get us further to the right and if the vector is negative for example if it was going to the left this would give us an increasingly larger negative number but now we would still just go by pixels of one so we go one to the right two to the right three to the right and so on so i want to multiply all of this again with my tile size and that way the first flame is going to be right to next of the player and we have an offset here of 64 pixels which is going to be the tile size and then for the next flame since i now is 2 we go another 64 pixels further to the right and now the center of our rectangle is going to be here the arrow should be a bit let's put the arrow but here so essentially all i want to do i want to get my direction dot x and multiply it with i and now i want to multiply all of this with my tile size i think i called it yep tile size this one and now for each of the flames i want to get an x and a y and once we have all of that i want to call myself dot animation player and create particles and then in here i want to call my flame so in my particles the flame here and besides that i will need a position and my groups so i need my flame i need x and y and then i need the groups i am getting from the parameters so all we have to do is figure out the x and we have to figure out the y and this might be a good exercise for you so try to figure out where each individual flame needs to be spawned so where the center x and y is supposed to be alright so first of all i want to get my player.rect.centerx and player.reg.center y because my flames are always supposed to start from my player now for the x position i want to get my offset x and that's basically all i need and for my y position since we're only moving in the horizontal direction we can just leave it as it is and that is basically all we need so now in my level when i call flame i can call self.magic player and the arguments i passed in here was player cost and groups so player is going to be self.player again cost we already have and groups let's say for now this is only going to be self dot visible sprites the attack sprites we do later let's first figure out the flames by themselves so now if i run this we are getting an error because the dict has no attribute split so this is going to happen in my magic and self.stats it shouldn't be stats it should be stat twist so now if i run this down isn't going to work but if i look to the right we are getting some flames and if i look to the left we're also getting some flames so this seems to be working just fine and let's try one more time we do need enough energy there we go so i'm happy with that although there's one small change i would like to do right now i feel like those flames look too predictable like they're too much in one straight line so i want to give them a bit of a random offset for both x and y and for that i need a random number generator so from random import rand and now for both of these positions i want to add rand and essentially what i have done i went from negative tile size divided by 3 all the way up to tile size divided by 3 except in the positive direction and this i have also done for the y position so essentially tile size is 64. if you divide this by 4 you get a number around 21. and that way if we have a larger tile size we get a larger offset so let's try this now and this looks a bit more random i kind of like that one so with that we have the horizontal flames now all we have to do is do the same thing for the vertical ones so let me copy all of this we can pass it in here and now instead of offset x we have offset y instead of direction.x we want to get direction.y and the rest for this line can stay the same now for x and y we need the offset x removed from the x position and added to the y position and this should now be offset y and besides that we don't need anything else so let's try it now so this side is working this side is working let's wait for some energy this side is working as well nice so now we have our flame spell it doesn't do anything just yet but we can work on it i guess let's work on it right now first thing that we have to work on is we have to place each of our flames also inside our self dot attack sprites so let's try this but we will get an error once we attack an enemy so for the grass it should work and it does it's actually really cool effect so this is pretty good but now if we attack an enemy let's say this one we get an error that particle object has no attribute sprite type and this error happens in player attack logic so player attack logic in here and in here we have target sprite get damage and in our enemy let me minimize all of the methods in here we have where's get damage get damage is here so in here we need an attack type and for our weapons we have a sprite type called weapon and this sprite type we are passing in here so our attack sprite dot sprite type is the attack type in the enemy the problem is our particles don't have one so in this particle effect we don't have a sprite type we can give it one though so self dot sprite underscore type is going to be magic and magic is a bit broad but right now we only have a single attack spell but if you had multiple types of spells you could just get another parameter in here and there classify what kind of sprite type you have or you could even get a whole new particle effect that inherits from this particle effect and this one has a sprite type for different kind of spells so you can certainly make this very flexible with just a bit more effort but in my case i don't really mind and now let's try this actually to see what's happening now so now if i attack an enemy we are actually getting something but you see now it doesn't actually damage the enemies in any meaningful way and the reason for that is in my enemy i have weapon and we're reducing the health but when we have anything else nothing is really happening so in here we want to do something else and in here we have to figure out how much damage we are going to get but first of all we have to get our health regardless of what we are doing but besides that i want to get from my player which we still have available from the parameters so we're going to pass this in here and now from this player i want to get full magic damage like we have done just above so now in my player i right below get full weapon damage actually let me open this method just for reference so in here define get underscore full magic damage needs self and nothing else and in here again we need a base damage and we need let's call this one is spell damage and then we are going to return the base damage plus the spell damage and well for our base damage we have self.stats and this one is magic and then for our spell damage we have magic data and in here i want to get self dot magic and then from that i want to get what i called the strength so now this should be working let's try so now if i attack an enemy they should theoretically disappear let's try it again um okay this needed okay let's try this properly without reducing for the flame damage the energy cost so that way we can call it indefinitely so let's try this again let's use this one and let's do it again i'm not sure how much damage i gave ah there we go so it does indeed work and everything else still works just fine cool so with that we also have our proper flame spell so now in my player let me minimize all of the methods again and i think with that we have our magic figured out so that's another major part of this game and now it's actually coming together really nicely and we can call different spells different attacks and all of this is working very very nicely cool we are actually getting very close to being done the one thing we still have to figure out is the upgrade mechanic and that's going to be the next major section actually the last major section all right now how can we implement an upgrade mechanic and there are a couple of things that we need first of all something i haven't done yet our player should get some experience once we are destroying an enemy that one's really easy to implement and once we have that the basic upgrade mechanic works like this in our self.stats we want to be able to upgrade any of the key value pairs so for example we want to increase health by 20 and every time we are doing that we are reducing the amount of our experience by a certain amount so i guess it's not really experience it's more like salts from dark souls but you get the mechanic and i guess the only really complicated bit in all of this is the gui for the upgrade mechanic because for that we need quite a few different bits but i guess let's do it step by step and let's first add an xp mechanic and then give our player a bit more data so here we are back in the code and i want to close down a couple of things so we don't need magic anymore we do need the enemies we don't need particles and settings can stay open i guess so in my player in the ending method i have down here right now my stats and i am going to need a few more stats the first one is going to be max stats so this is the maximum amount of health or energy or attack damage that my player can have and i realized speed of 12 was a bit high so let's go with 10. i also want to have an upgrade cost so this is going to be how expensive each upgrade is going to be and now just to get started let's increase our experience to something like 500 so we can work with this a bit more easily and now the first thing we are going to need is that our player should get some experience every time we are destroying an enemy and for that in our level let me minimize all the methods in here again i want to create another method and that's just going to be add xp and this one needs self and amount and really all we're doing in here is we are getting our self dots player dot exp and plus equal the amount and now this method i want to place into the enemies so when we are creating all of our enemies the final method i get is self dot add xp and now in my enemies when they die so check def in here i also want to call self dot add exp and then we can add the amount but first of all in the parameters we have to add add exp and then let's say player interaction self dot add exp and now we can actually call it so add exp now we have to figure out how much experience the enemy should give and that information we have up here so for each monster we have a custom experience so we can just copy this one and place it in here so self dot exp and now this should actually already be working let's try and we are getting an error so enemy object has no add experience which no enemy and it's in the level and let's call it self.exp self.exp and then in my enemy the parameter is called add exp and oh i just forgot add exp okay now let's try this again there we go and now if i take an enemy there we go and we get some experience trice again there we got another 120 experience and let's try this one again and we get even more experience and i can also heal and well technically we should have just died but in my case i didn't really implement the death mechanic because well the game is already getting complex as it is but if you had an actual game this could lead you to an over world or something alright now in our enemy we have the ad experience so we can close enemies and minimize the create map method and add xp as well so all right now with that our player has the experience and we have the data now all we have to figure out is how to increase the stats of our player and for that i want to create a separate menu and that i actually want to do in my main file because in here i have my event loop and what i want to check in here is if event dot type is equal to pygame dot k down so we're pressing any button and if event dot key is equal to pygame dot k underscore m so my case the m button is the upgrade menu button and if we are pressing that i want to run myself.level and then there i have a method called toggle or i want to create a method so now in my level i can create a toggle method actually let's call it toggle menu that feels a bit more appropriate so toggle menu and if i'm doing that self dot toggle underscore menu wii itself and nothing else and basically all i want to do i want to create self dot game underscore paused is going to be not self dot game underscore paused and in my init method let's say all the way in the basic setup self.gamepast by default is going to be false and now what i can do in my run method of this level essentially what i want to do in here is if gamepost is true i want to display the upgrade menu and if that is not the case i want to run the game and now we have to figure out what to draw in here what to draw on here and what to draw all the time so let's go through it one by one our visible sprites we always want to draw even if the game is paused however we only want to update them if the game is not paused and same with the visible sprites and the enemy update then the attack logic should also be in here but my ui display i always want to display even if the game is paused because there we can see the experience so now we can get rid of all of those and now we have to figure out what to do when the game is paused and for now i just have pass in here and to actually get the full menu i want to create yet another python file and this one i called upgrade dot pi that is actually going to be our final new file so we are getting very close to finishing this project and in here as always we have to import pi game and from settings import everything now i have my class upgrade there is no need for inheritance and in here i want it under init method with self and i want to place the player in here as the parameter and in this method for now i want to have a general set up and first of all we need to display underscore surface that's just going to be pygame dot display dot get underscore surface and then self dot player is going to be my player we will need quite a bit more but that comes later the really important thing i want to have for now is a method called display this one doesn't need any arguments and for now i just want to make sure we can see what we are doing so for now i just want to get myself dot display surface dot fill and let's say we're going to fill it with black so whenever we have this menu open we're going to fill the screen with black and once it's gone we are not going to fill it so essentially what that means in my level i want to from upgrade import upgrade i believe i called it yep upgrade and now in the innit method all the way down here i guess this is also user interface so self.upgrade is going to be upgrade and this one is going to need self dot player so let's minimize this one now and now in my run method i want to run self dot upgrade dot display so now we can toggle at least in theory between a menu so in my game we get game paused not defined in my level.run because this should be self dot game paused there we go the game runs now if i press m it goes to black and if we press it again we go back to the same stage actually let me get chased by some enemies now press m and now we return back to the same stage where we were earlier so this is actually a pause mechanic and this keeps on working just fine cool and the reason why this is working is because when our game is paused we are not updating the main part of our game anymore and because of that the game picks up once we are stopping this so this is a nice pause mechanic so all we have to figure out now is how to create a proper menu and that is going to become a slightly longer section so i guess let's work through it one by one now first of all we need some input and for that again we need keys and pygame dot key dot get underscore pressed and then if keys and pi game dot k underscore right then let's say for now we just want to pass and l if keys pi game dot k left we want to move left but for now this is going to be passed as well and finally i want to check if keys and pie game that's not how you spell that pie game dot k space we also want to pass but this is going to be our select button and let's spell keys correctly all right so now we have to figure out how to actually implement these mechanics for left and right and let me explain how this is going to work i am basically going to create a selection index and this selection index can be a number between 0 and 5 and that is the amount of stats my player has so once that could be health the other set could be energy and then i have speed attack and magic and then for each of those five i'm going to create a box and each of those boxes is going to be one class so three four five and essentially what i'm then going to do is i'm going to have a selection number that let's say right now it could be one and if it is one we're going to select the box with the index number one if it is three we're going to select this box here so that way when we press left or right we are either increasing or decreasing this number and that's then all we need to do okay but for that to work we need a couple of things first of all we need our self dot attribute number and all i really want in here is the length of my player dot stats so the length of in my player i want to get this dictionary and in there i have these different values and i guess while we're at it i can also get the names so self dot attribute names and this one is just going to be a list with my player.stats and from that i just want to get the keys and finally i am also going to need a font just like we needed one for the ui so self.font and in here we have pygame dot font dot font and now we can use the same font from our ui so ui font and ui font size so ui font and ui font size and that would then be all the basic information we are going to need but besides that we are also going to need let's call it a selection system and that is the number i just talked about that we're going to increase from zero to five and this i called self dot selection index and by default it's going to be zero and since we're going to move it we are also going to need a timer so self dot selection underscore time by default it's going to be none and then self dot can underscore move and by default this one is going to be true and now in my keys the most basic thing i want to do is self dot selection index not selection time selection index plus equal one if we are going to the right or minus equal one if we are going to the left but now for the proper timer we also want to set self dot can move to false and self dot selection time is going to be pygame dot time dot get underscore ticks and these two lines we need for both of the movement so in there and there we go and now when we call left and right besides the button we also want to check and self can move so this is basically our basic movement that we have implemented a couple of times by now and now finally we need a selection underscore cool down and this one again it's just going to be a basic timer so if not self dot can move then i want to get my current underscore time it's going to be pygm.time.get underscore ticks and then finally if my current time minus myself dot selection time is greater or equal than a certain number um let's say for this one 30 milliseconds once we have that can move is back to true and now we can get rid of this surface fill and just replace it with self dot input and self dot selection cool down actually let's do this slightly differently this self dot can move probably makes more sense when we put it as a general one all the way at the top and then check all of the other keys sorry about that this makes more sense because there's one more thing that we do have to check so if we are all the way to the right we don't want to be able to go any further so i'm going to check and self dot selection index is smaller than myself dot attribute number and this one needs to have negative one because of the way we are counting in the length method and then the same thing for left so self dot selection index except this one needs to be greater or equal than one at the very least and now finally we can also start with our space button so in here i also want to run the timer and what i want to do for now is just to print my self dot selection index so at least we have something and let's try all of this is working i press m the game pauses now if i press space you can see zero in the bottom left if i press right we get to four and if i press down we get back to zero so something with the input doesn't work just yet and the reason is that this selection index should be selection time now let's try this again if i press m never press space we just get one if i press to the right we get one result up to four but if i go back we get the numbers that i actually wanted cool so this is working now okay this really is a long tutorial now i can minimize my selection cooldown i don't need it anymore and for now let's minimize the input method as well so we can see a bit better what's going on now basically what i want to do let me draw this out here we have our entire game window and what i want to do i want to spawn a couple of boxes over this thing five in total and each of these boxes should have some kind of bar on the inside that shows us how much we have and on top we want to have the name of that stat and at the bottom here we want to have the cost and i'm going to create a class for each of these boxes so each of these red boxes is going to be one instance of a class but to be able to do that i first have to figure out a couple of dimensions about the screen so i have to know how wide each of these boxes have to be and how tall they have to be and for that i need to do some math so let's work on that first and we can do this straight in the init method let's do it right here so i called the class item and we want to get item dimensions and we need the height we need self dot width as well and height is the easier one i basically want to get myself dot display surface and in here get size and this is going to give us x and y and we only care about y and i am just going to multiply this by 0.8 so we have most of the screen but we are losing about 20 percent so we have a offset essentially now for the width i can actually copy most of this except this one should be zero so we get x and i'm going to divide this by six which is my attribute number plus one so that way i have my five elements and the sixth one or the width of the sixth one is going to be the padding between them and now i can create another method and i call this one create items and for this one we don't need any arguments and essentially let me create a class right now i want to create a class that i called items or item and each of those is going to be one box that we can upgrade and for this one i need an init method and then here i want the left i want the top i want a width i want a height i want an index so we know what is selected and i want a font so all of this is what we have to figure out in this create items i guess for now let me add pass in here so python doesn't throw an error okay now first of all i want to store all of these items in the list so let's call it self dot item underscore list for now it's just an empty list and now i just want to go for i let's sorry for item in range self dot attribute number and now i have to figure out the horizontal position i need to figure out the vertical position and then i have to use that to create the object so let's do the last step first item is going to be my item and in here i want to have a left the top then the width i already have that's the one i have up here so self dot with and self dot height then the index we're also going to get in just a second and then the font we already have that's just self dot font so essentially we have to figure out the left the top and the index and once we have all of that i can get myself dot item list dot append and my item now we have to figure out the horizontal and the vertical position and the vertical position is kind of easier so let's start with this one and here we need the top and right now we know let me draw this actually so if this is the entire height of our game let's call this h so this is the entire window in specific numbers this would be 12 80. and we know that 80 of this so let's say roughly this one is going to be our current self.height so this number here so we have 10 here and we have 10 up here now because i want my boxes to start on this line essentially all i really need is 10 of the screen height starting from the top of the screen that's the only number i need for the top and this one is really easy to get so i need self dot display surface dot get underscore size i need the y number again and now i have to multiply this by 0.1 i guess you could make this system a bit more flexible by putting these two numbers inside of one variable but i'm not going to worry too much about it but all right with that we have our top now our left unfortunately is going to become a bit more difficult i guess first of all i want to have my full width and this one i can actually copy it is this number here except we want to have zero so right now we know the entire width of our window then i want to know by what increment i want to move to the right and let me actually draw this so right now this here is the entire height of our game so let's call it h oh and this one is actually 1280. the height before window is 20. the height of our window is 720. uh well i guess you get the idea but anyway this one right now is 1280 pixels wide and this is what i got with full width and now what i essentially want to get is i want to have a bit of an offset from the left and then i want to have my first element so let's start here with the left of the first element the first element should then go let's say roughly to here and then i want to have a bit further to the right another element and this should then be the left of the second element or i guess to be a bit more specific this should be the index zero and this should be the index one that is a bit easier to comprehend and this number is then going to be the increment it's basically the distance from the left to get the left side of each item and this number i basically get with my full width divided by myself attribute number so right now we are splitting the entire window into five different parts and with all of the information i can get my left so now all i have to do is i want to get my current item number so this could be either 0 1 2 and so on and multiply this by my increment and then to what's that i want to get my increment and from that subtract my self.width of each of the items and floor divide this by two and that way we are offsetting each of the elements a little bit further to the left and well with that we have our left side now finally i need the current index and the best way to get the index is just to use the enumerate method and then we get item and index so with that we have the basic setup to create each of these items and let's actually draw them so we see what's going on i know it's getting a bit theoretical so basically what i want to do in the init i first of all want to create a self dot rect and this is just going to be a pygame dot rect and then here we can just pass in left top width and height and besides that i also want to get myself dot index and that is going to be the index and i want to get myself dot font and that's going to be the font and now each of these items is going to have their own display method and for this one besides self we need the surface to draw on so our display surface then we need this selection underscore num so what our currently selected item is so we can highlight it and then we need the values we actually want to display so be aware the item is essentially a box that could display any kind of information whatever we pass in so we actually have to pass in our stats so i want to have a name a value a max value and a cost and these are the informations i want to draw now that we have all of that for now let's just draw some basic thing all i want to do is pygame.draw.rect and we get the surface from the parameters then for the colors for now i just want the background color from my settings oh actually in my settings we need to import a bit more information because in here the upgrade menu has its own colors so finally a tiny bit more this is the last bit we need but for the background i just want to have the ui bg color so let's copy this one and paste it in here and finally self.wrecked the one we created up here here so for now we're just drawing a basic rectangle to see if something is going on in the first place and now finally for my display i can just draw all of them so i can for item in self dot item list i can do something but first of all i forgot to actually call self.createitems and let's do it below this one so self.create items and let's call this section just item creation okay we are nearly done sorry this section gets a bit more complex it's kind of hard to visualize but now in my for loop i just want to get item dot display and here we need the different arguments so we need all of these arguments let me copy them so surface is going to be myself dot display surface selection number for now we're not going to care about it it's going to be 0. name let's say for now we can just write test for value it's going to be 1 max values let's say 2 and cost 3. these numbers for note don't matter i just want to see if this is working in the first place but now we should see something so let's try to run main.pi and press m and there we go we can see our five different boxes so at the very least this is working and i'm fully aware that the logic here is getting a bit more complex so i would recommend you to go over this if you're struggling with this so especially to create items can be a bit finicky but well let's continue with what we have now the first thing i want to do is to actually display the names of what we are dealing with so for now i want to show the name of the attributes and i guess what we added we can show the cost and for that to work we have to let's call it get attributes and we will need the name we will need the value we will need the max value and finally we will need the cost and since we also have to figure out what the index of each number is i also want to put item list in an enumerate method so this should be index and item and now let's work for them one by one first of all the name we already have in our attribute names so in here all i really have to do is get myself dot attribute names and then select the index for the values i need to get myself.player and for this one i want to write another method in the player that i called getvalue by index and this one's going to get the index we're going to write that in just a second now for the max values i want to get them right at the top here because those don't change so in here self dot let's call it max values and to get this one it's supposed to be a list and i want to get my player.max stats i think i called it it is mac stats here and from this one i want to get the values so now for my max value i can just look at myself.max values and pick the one by the right index and finally for the cost this one also i want to get myself dot player and then get cost by index and we want to pass in the index all right and now in the player let's create those two methods and let me actually copy them so it saves me a bit of writing and let's write them right below the other two getter methods so we have get value by index self and index and then let me copy all of this and get cost by index and in here i essentially want to return just the value for each specific value in our stats so essentially i want to get my current value from this list here or this dictionary rather and all we have to return is first of all we need a list with our self dot stats dot values and from that i want to select the index and that's really all we need it's not a particularly complex one and now i can copy this and now instead of stats i want to look at my upgrade cost so this way we also get our current index right in here with just one line of code and now all we have to do is to pass all of this information in the display method so first of all the surface we still have and now for the selection number i want to pass in myself dot selection index then next up we have my name and this can just be name then we have the value that's going to be value then we have max value and then we have the cost so let's check if this is the working we're not getting an error message that's at the very least a good sign so now we are passing in all the information we need in here so let me for now hide the upgrade menu we're not going to need it for a while so essentially all i have to do now is create a couple of methods to display the different things first of all i want to write display underscore names and then here we need self we again need the surface to draw on then we need the name and we need the cost and i also want to check if this is the currently selected box and in here we are going to create the title text and we are going to create the cost text and then at the end once we have created them we are going to draw everything so let's create the title first and then here i just want to create a title surface this one is going to be self dot font dot render and what we want to render is the name we already have and since we're drawing pixel art i don't want to antialiasing and now we are going to need a color and the color i am getting from my settings and in here we have a text color so let's pass this in here and then besides the surface we need a title rect and what i want to do is to get my title surface get wrecked and now the mid top should be where myself dot rekt dot mid top is and from that i want to give it an offset so pygame dot math dot vector 2 we want 0 offset in x and in my case 20 pixels in the y direction and with that we can get our surface and blit and create a title surface and the title rectangle so now in my display method i can run self dot display names and then here pass in the surface we already have then we want the name we want the cost and let's say selected for now is going to be false we're going to change that later on okay and let's try this if i press m we are getting an error because get rekt here should not be capitalized and now let's try this again there we can now see health energy attack magic and speed this is working really well and now besides that i also want to display the cost and this could be a good exercise for you so just like the title try to display the cost except now the cost should be at the bottom of each of the bars right first of all i want to create a cost surface going to be self.font.render again and in here i want to draw my cost but my cost right now is a number so i'm going to turn this into an f string and there is a chance that my cost might become a floating point number so i'm also going to convert it into an integer but besides that we can just copy the other arguments from my title surface and now once we have that we need our cost rect and our cost serve dot get underscore rect and this time i want to place my mid bottom and it's going to be myself dot rect dot mid bottom except with an offset so pygame.math.vector2 and 0 and 20. although now be aware we are subtracting that vector without increasing like in the upper one and now all we have to do is surface dot blit we need my cost surface and cost and that should be all we needed let's try now and there again we can see our cost now there's one more thing that we do have to do and that is to work with this selected and essentially what i want to do is in my upgrade i have a selection index and if the selection index and the index of each item is identical then i want to highlight this and actually let me illustrate this this might be slightly confusing so this right now is our entire window and in here we have a couple of bars let's do all of them so here we have five and each of those has an index that's the index we created just here and there are zero one two three and four and besides that i also have a selection index and this one could be anything between zero to four and this is also the number we can influence with our keyboard input and essentially what i want to do if for example our selection index is a 1 then i want to highlight this box here and if it's let's say a 4 i want to highlight this box here so whenever the index of our item is the same as our selection index then i know i want to highlight this box and i can change some colors that's the entire idea here and i have both available in my class actually so this selection number is our selection index so the one we are passing in here and essentially all i have to do is if myself dot index is identical with the selection number i think i called it yeah selection number if that is the case we should be drawing something in a highlighted way and we're going to use this later but for now let's add pass in here and what we can also do is copy all of this and pass this in here for the true or false argument so this comparison can become either true or false so now that this selected here gives us either a true or false statement we can use that to influence the color and we have two different colors in our settings so we have the text color and text color selected so now if my text color is selected i basically want to do i have text color selected if selected is true and if that is not the case so else i just want to have my text color and now i can pass in color for both of the text colors and we should be good to go let's try this so now i press m and now my health and my health cost are darker if i press to the right we now have other fields selected and this is working quite well now obviously right now this is very hard to see but later on we are also going to change the background color for each of these items so it's going to be easier to see but for now this is working quite well i guess we can actually do it right now so if this if statement here is true we want to draw a selected color and if it's not true we just want to draw the regular background rectangle and i guess while we're at it i can duplicate this one because we also want to have a border color so i want 4 for the width and now for the border color i have ui border color and back in my upgrade i can change this one and let's try if this is working and yeah this looks pretty good oh now you can even tell we're not drawing any background for the currently selected item not ideal but it does look kind of funny but we can change this quite easily by just copying those two and putting them in here and now in my settings we have upgrade bg selected that we can place in here and ui border color actually stays the same so now let's try this and i press m and there we go this is looking really nice so with that we can properly see which one is selected what we have to do next is create another method and this is going to self dot display let's call it the bar and this is going to be the upgrade bar and then here let's actually create the method because this one also needs a couple of parameters so display underscore bar self as always we need a surface then we need our value we will need a max value and we need to know if this one is selected or not because that will change the color and now let's talk about what we have to do this one here is going to be one of the items and inside of each item i want to have a bar and inside of each bar we have the name and the cost that one doesn't matter right now but now what i want to do is to place a line in here and on this line we have a rectangle that shows us how much the player currently has in this skill and this one can go all the way to the max level and actually let me leave this one up here right now might be kind of helpful and let me spell properly this should be display bar now first of all we need some let's call it drawing set up and in here we want to know what the top and the bottom and i guess also the color of this bar is going to be so right now we just want to know what is the top and what is the bottom of this bar going to be is going to be self.wrecked.mid top and then i want to give this one an offset so plus pi game dot math dot vector vector 2 and 0 and 60. so we're going down a tiny bit and then for the bottom we can do something fairly similar except now we look at the mid bottom and we are subtracting in the y axis and for the color we have in our settings bar color and bar color selected so i want to have bar colors selected if selected and if that is not the case i just want to have the normal bar color and i guess we can actually already draw this line so draw elements and essentially what i want to do is pie game.draw.line and this one first of all is going to the surface and the surface we have from our parameters besides that we need a color this one we also have and then we need a top and a bottom also elements that we have so all of the stuff we just created so now i can actually call my bar so let me copy all the parameters again my surface is going to be my surface again my value we already have my max value we also have and selected is going to be the same thing we got from earlier so now this should be working let's try and there we can see we have a line although it is very very thin and the reason why it is so thin is because i didn't set a border width by that we can add with another argument and let's give it a width of five and now let's try this again there we go this fits better and this is looking pretty good so now what i essentially want to do is to place a rectangle somewhere on here to illustrate how much of this value my player currently has so we have to get let's call it a bar set up and first of all i need to know the full height of this thing and that is just going to be bottom and be aware my bottom right now has an x and a y position and i only care about the y one and from that i want to subtract my top and i also want just the y position and be aware here the origin of our window is in the top left so the bottom one is the higher number which is why we are subtracting top from bottom but all right now i want to have the relative number this right now is the value that i currently have divided by the max value so let me add a bit of space let's say right now in my init method they're my stats so if my health is 100 and my max health is 300 i want this bar to be at one third of the maximum amount and this is exactly what we are doing here so this is going to give us something like 0.3 and this then i just want to multiply with the full height to turn this into a pixel measurement and now i can create let's call it a value rectangle and this is going to be pygame dot rect and this one does need to be capitalized and in here we need left we need top we need a width and we need a height and for the width and height i just went with 30 and 10. fairly random numbers i just went with what looked good now for the left i just went with either top or bottom doesn't matter they have the same position anyway and i went with zero so this is going to give me the x of the top and from that i'm going to subtract 15 which is half of my width and then the top is going to be the bottom of my bar so one and from that i'm going to subtract the relative number so just to illustrate what's happening here if this is our entire bar then bottom one this bit here is this point all the way at the bottom and then the relative number is going to be however much of a gap that is from the bottom so this way our bar would be here ish and all right with that we have something to draw so pygmy.draw.rect i again want the surface the color and this time i want to draw a value rectangle and now let's try this and this is looking pretty good with that we only need to figure out how to actually increase any of these values and for that i have another method and this i called trigger and trigger needs self and player and we first of all have to figure out how to actually call this thing and this is going to happen let me minimize all of these methods this is going to happen essentially in here so right now we're just printing our selection index it doesn't really do anything right now instead i want to call this trigger inside of my item and we can minimize quite a few different things so it's a bit easier to see that is feeling slightly better i guess ah there we go okay essentially i want to get the trigger from my item list in here so i first of all want to get myself dot item list and from that thing i want to get myself dot selection index and this one then i want to call the trigger method on and pass in self.player and now in this trigger method we can get the first of all let's call it the upgrade attribute and this we get with player dot stats dot keys turn all of this into a list and once we have that we can use self dot index to get one specific value and index will always be the same for each item and i guess for now let's just print our upgrade attribute so we know this is working so back in here i can press space on health we get health energy attack magic and speed so this way we know which element we are selecting now besides that we have to first figure out if the player has enough experience to upgrade this certain kind of value so i want to check if my player.exp is greater or equal then my player dots upgrade underscore cost it was called so in my player we have upgrade cost so upgrade cost and i am only caring about my upgrade attribute and now once i have that and that is actually true i want to get my player.exp minus equal player dot upgrade cost again and get my upgrade attribute so now we are lowering dxp and then for my player.stats now we can finally upgrade something yep we have my upgrade attribute and in my case i'm just going to multiply each value by 1.2 and what i'm also going to do every time we are upgrading a certain part i want to increase my upgrade cost by 1.4 so we get increasingly more value and it becomes even more expensive every time we upgrade and now actually let's try this so now if i press space on health we get 140 and our experience did go down so now we get to 64 and we can't press this anymore because we don't have enough experience and let's actually try to destroy some enemies okay this should be enough now our health still stays at 274 and i can press space again and now we get even more health cool this is working really well and i can still heal up and all of this is working really nicely so with that we have some basic upgrade mechanic now there's one more thing we do have to do and that is if our current value exceeds the maximum value i don't want that to be possible so if player dot stats and we want to check my upgrade attribute is greater than my player dot max stats and again my upgrade attribute and if that is the case i just want to set those two equal to each other and i guess what we could also do is in here we only allow the player to upgrade if my player stats is lower than my max stats i guess just another safeguard can't hurt to have those and all right with that we have a trigger and i guess we can test this so in my player i'm going to give the experience of 5000. now in the game i can upgrade i guess my attack is the highest one right now i can increase this to well the maximum and we can't go any further so seems to work just fine and alright with that we have our upgrade menu there's one more thing i do have to do because in my player so far we had self.speed but we don't really upgrade this after we upgrade so after unit method this self.speed is not being used anymore so i can get myself.speed and now all the way in my update method i don't want to use self.speed i want to use self.stats.speed and now in my game this is how we move by default and if i increase my speed all the way to the top we are moving significantly faster so we know the upgrades actually do something in the game cool except i'm still terrible at my own game but never mind and that was the last major section in the game there's only one more thing we have to do well two things we have to add the sound and there are some tiny details i do want to change but let's talk about them in their own section the first one is to fix a couple of smaller issues that are annoying me they are mostly visual and once we have that we are going to work on the audio and essentially what i want to do in my game in terms of visuals that in the original i had an offset for each individual object so the trees and the grass for example had different kinds of offset because they have different sizes and this i forgot earlier so i did want to include it and besides that right now if we walk too far to the right of our map we can see the black background which looks a bit weird actually let me illustrate all of this straight in the code and then we can work on it so here we are in the game and if i run this and move all the way to the right let's go all the way here i think you can see it there you can see the background is just black which looks kind of weird and for this or well the reason is we have a black background color but in my settings we have a watercolor and this i just want to copy in here and we have our settings available so this watercolor is the same color as the water that's why it's called watercolor and well now if i run this we can go back here and now we can see only water so this looks a bit better although admittedly the water does look a bit boring but well we are at least getting a decent color so now besides that in my settings i also want to add another entry let's put it all the way up here and that is called hitbox offset and in here we have one for the player one for the object one for grass and one for invisible tiles so let's actually go through them and in my player let me minimize everything again in the init method here we have our hitbox and there we already have the 26 so we could leave it as it is but just to have everything in the settings let me call the hitbox offset and in there i want to get the key player and what i also want to do is just for the player i want to reduce the hitbox for the x dimension as well although not by much let's say by 6. and let's try this and with this it becomes a bit easier for our player to move through smaller gaps so especially here well it's kind of hard to see but with our player being a bit less wide it does make it easier to move around not a major change but it does make the game feel significantly better okay with that then we have to work through the appetites so we have the player now we need the object and the grass and all of this happened in my tile this one here and in here we are getting our hitbox all the way at the bottom and this one can change depending on if we have grass or an object so i want to put this in a separate variable let's call it y offset and in here we're just going to use hitbox offset and then we have a sprite type so sprite type we are getting from our level and we are getting it from create map and in here we have grass and we have object so we're passing them in here or in here so this is how we then get the y offset and now we can just get the y offset and paste it in our inflate method to get the hitbox and that way we have quite a larger offset for the trees so the objects get minus 40 and the grass only negative 10. so this is now going to make it drastically easier to move around because we can move much further behind the trees and this means that when we work for the forest things are much better in terms of movement so this feels considerably better for the movement and that is kind of all i wanted for the basic movement oh and i actually forgot in my settings there's also invisible and invisible we get from our boundary tiles and they also work in here with the sprite type so this tile class actually pulls a ton of weight but all right so with that we have a couple of fixes that i really wanted to add that make our game feel surprisingly better but now that we have that all we have to do is add sound and then we are done and okay i guess we can go through it step by step add the different sound effects and all the way at the end we add the soundtrack for the game so let's go through it step by step first and i guess we can start with the player that one probably has the most common sounds so here we have the player and in my indian method i want to import his sound and all i want for the player is self dot weapon attack sound and this one we get with pygame dot mixer dot sound and in here we need a path we have to go up out of the folder then into audio and then we have sword dot wav and one thing i also want to do is for my attack sound i want to set the volume to 40 of what it is that way it's not getting too annoying and now in my input method whenever i have my attack input i also want to call self dot weapon attack sound and play it and that should be all we need for this one sound let's try it now and seems working just fine now next up we can add some sound to the magic because in there in my init method i want to have let's call it self.sounds and this is going to be a dictionary and here we want to have a sound for heal and another sound for the flame and in here i want to run pygame dot mixer dot sound and we have to go up a folder then to audio and then to heal dot wav now i can copy all of this and paste it in here except now we want flame and i guess if you want to make this a bit more elegant you could paste these sounds or the path to these sounds into this magic data i have actually done this for the sounds for the attacks but in our case the magic sounds are so few it doesn't really matter all right now when we are playing the health effect we can somewhere in there round self dot sounds call heal and then lay it and then we can do the same thing oh and we have to reactivate the energy cost for the flame effect and while we had added we can add the flame sound and now let's try this so we are getting an error that audioflame.wlv was not found let's have a look so i couldn't find this one because the file was called fire.wav now let's try this again and that looks better attack still works and now the name works and magic also works just fine cool so with that we can close the magic file and not worry about it anymore then next up i have my enemy sounds and that is going to be in the enemies let's open that file enemies enemy enemy and in here just in the init method i want to have a sound section and we essentially have two sounds self dot def sound this one is going to be pygame dot mixer dot sound and i want to have my fold up then my audio and then here we have def dot wav now i can copy all of this and i have a hit sound and this one is called hit.wav and now for both of these self dot def sound i want to set the volume a tiny bit lower to 0.2 and the same for the hit sound and now we just have to figure out where to call them and the death sound is the easier one actually let me minimize all of the methods this code is really getting extensive so in my check dev if this is true i want to call self.def that's not how you spell that deathsound.play that's the first one and the other one we want to play when we get to get damage down here so in get damage we want to play this once self dot hit sound dot play and that should be all we need so let's try this that feels pretty good now for the enemy again there's one more sound we have to import and let's put it right here as well actually let's put it right here so in my settings we have one more sound this attack sound for each of the different attack types so self dot let's call it the attack sound and this one is going to be pygame dot mixer dot sound again and in here i want to have first of all the entire dictionary so my monster data and in here i first of all need to get my monster info i think i called it so in here we get the entire dictionary so the dictionary we get is this one for example for the squid and in there we want to pick the attack sound string and this one we can just get by indexing and i also want to reduce self dot attack sound dot set volume and this one i set to 0.3 and now we just have to figure out when to play it and this happens in my actions so in here if the status is attack my enemy is attacking so what i can do is self dot attack sound dot play and now this should be working so let's try this one and i can edit here the bamboo enemies i can hear all of the enemies and there certainly is some sound cool seems to be working so the final thing in this entire project is going to be in my main file where we start playing the sound so right here in the init method of my game i want to have sound and i'm going to import main sound and i am importing pygame dot mixer dot sound and in here we have a string we go one fold up we go to audio and there's a file in there called main dot o g g and this main sound i want to play and in here importantly we want to determine the loops they should be 1 so we are playing this continuously now let's try this all right now i think the one thing i do want to do is main sound dot set underscore volume and set this to something like 0.5 it's probably a touch loud right now and okay this one feels better i guess in terms of fine tuning the enemy sound effects feel a bit quiet so let's set those to 0.6 and let's see how that feels and yeah this is feeling much better and all right with that we are actually done i think that covers the entire game so thank you so much for sticking around if you actually managed to get all the way to the end of this project i hope you got something out of it and well i'll see you around