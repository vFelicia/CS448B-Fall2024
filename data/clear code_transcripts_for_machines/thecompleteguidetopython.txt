python is the world's most popular programming language and that is for a reason you can use it to make games and apps run databases build robots and create artificial intelligence with ease the example you see right now is an ai program that tracks my face it took me about five minutes to write and that is a general theme for python it is incredibly easy to learn while also giving you a ton of power for more advanced functionalities and all of this you're going to learn in this video starting from scratch i am assuming that you have never used any kind of programming language before so we are starting all the way from the bottom and over the next 10 or so hours you are going to learn basically everything you need to know about python and after that you can learn pretty much whatever you want in the language and it should be fairly straightforward as a matter of fact this video is part of a larger paid course and this one is going to use all of the stuff you're learning about python and uses it to make four games and that way you are learning in much more detail how to actually use all of this in practice so check this one out if you're interested although this entire video works by itself and you can use it for any other nongaming purpose as well it's a general introduction to python before we start the program we need to cover some fundamentals first of all if you are just getting into programming you are probably overwhelmed by choice besides python you could learn a few hundred other programming languages some have clear names like html5 or java while others are much more difficult to separate like c c sharp and c plus plus so what makes each language different and where should you start also how does python compare to these other languages one good way to separate these languages is by using two axes the first one is about the language being made for a specific purpose or if it is more openended for example sql and r are programming languages for highly specific purposes databases and data analysis respectively on the other side you have languages like python that can also analyze data and run databases but can do a lot more besides that this flexibility is one of the reasons why python is so popular it just can do a ton of different things although this line is not static the best example for that is html initially it was purely a language to make websites it was very much designed for a single purpose however over time people kept on adding more to it and nowadays you can make apps and games with html it became much more flexible and that is the main reason why modern websites are as powerful as they are the other axis is the level of abstraction now when i say a language is more abstract than another i don't mean to say it's more complex instead abstraction refers to how far removed a language is from physical computer hardware let's use html again to see a website written in html5 you first need a browser like chrome or safari that browser in turn runs on an operating system and only that operating system has access to actual physical computer hardware there is a huge distance between the html code and the computer it runs on that means html is a very abstract language this however does not mean that html is more difficult than a less abstract language quite the opposite actually in broad terms the more abstract a language is the easier it is to use that is because a less abstract language needs to work with computer hardware it needs to be very specific about memory management you sometimes have to write for different kinds of computer hardware and generally it is very easy to break things now in this axis python like html is a very abstract language in fact python itself was created using another programming languages that one is called c and this language is much less abstract generally in the bottom right of this graph you have all of the c languages like c c sharp and c plus plus you also have java down there the differences between them are mostly technical and you don't really have to worry about them at least for now that being said csharp was only created because microsoft didn't want to pay license fees to the creators of java these two languages are very similar so there can be a ton of overlap between these different languages they are not entirely unique now when you are just getting started you want to begin in the top right of this graph with more abstract general purpose languages these are easy to learn work everywhere there's a huge community for support and resources and you can use them for a huge variety of projects what you also want to be aware of is that all programming languages are somewhat similar if you know python for example you can learn c or sql much more easily this is actually a really common pattern people start programming in python and then migrate to another language python was actually designed to be a tool to learn programming itself and it just happened to expand over time to become a really popular languages by itself although that doesn't mean that you couldn't stick with python especially for data science think of artificial intelligence databases and data analysis python very often is the default choice and these are fields where you can earn a lot of money it is totally fine to stick with python by itself entirely for your entire career lots of people do that but generally if you are not sure yet what language you want to go for don't worry about it what you're learning in python can very easily be migrated to another language what you want to do is just get started somewhere and work on projects you like and see how far you get and if you feel like changing you can totally do that and not start from scratch a lot of things you are going to learn you can use in other languages as well you are always going to make some progress even if you are switching alright in this video we are going to install python and the main target of this session is to write hello world using python now this task you can approach in two ways number one you can do all of this on your computer and this is going to be the main way if you want to use python normally you want it to be installed on your computer now that being said you can also run python online and for that you don't have to install anything if you just want to have a quick look at python and check if you like it i would recommend to just run python online for now and then if you decide that you do like it you can install it properly so let's start with some websites that let you run python code there are quite a few actually here for example we have one website called programmist.com and this one lets you run python code online besides that you could also use other languages like c c plus javascript and quite a few more but in our case i want to get rid of all the code in here and to print anything in python remember we want to write the word hello world and to print this you have to do a couple of things first of all you have to put this entire phrase into quotation marks could either be single or double quotation marks and for now just follow along i will explain all of this in much more detail later on but now that you have this word it should be green and what you have to do now is write print and then put the quotation mark phrase inside of brackets which means we first of all have the word print then we have a bracket then we have hello world in quotation marks and then we have a closing bracket and if you have all of this you can click on run and now you get hello world if you could follow along so far you have written your first python code and if you don't want to install anything on your computer or register for anything this website here would be really really good so this is definitely something i would recommend you can also make it a bit larger that's a bit easier to read besides that there is also a website called rapple.8 or replit i'm never sure how to pronounce it in here you also have an online editor that you can use for python here we already have print hello world if i run this we get hello world for this one to use it properly you do have to register although it is a bit more powerful but both of these are really good to get started using python although keep in mind you are running all of this in a browser which is somewhat limiting what you ultimately want to do is run python on your own computer that way you have significantly more power and you also have more flexibility so this is what we want to do now for that we have to install python on your computer and the important thing to understand here is that python is just another program that you have to install on your computer it's working basically like word or excel or literally any video game and the file you have to install you get from python.org so let's have a look at this one here we have the python website and what you have to do is click on downloads and in here you want to download python and then the latest version right now this is 3.10.5 by the time you are watching this there's probably a higher number but that isn't going to make much of a difference so click on download and then you get the file downloaded and this is going to work with your specific operating system in my case i have windows but if you have a mac this would also work although you would get a slightly different file and once you have that you click on open file and now you get either install now or customize installation however before you do anything in here there is one incredibly important thing and that you can see down here it says add python 3.10 to path this is an incredibly important option that you absolutely have to take this one you really want to add i will explain later why this is important but do keep in mind this is incredibly important if you don't add this you are going to run into a ton of problems but besides that you can leave everything as it is and then click on install now then you get an installation and this one is going to work like literally any other program so just wait until it finishes and you should be good to go there we go the setup was successful now we can close it and nothing changed however now what you can do if you press the windows key you can type python and you have python 3.10 installed on your computer if you run this you get something like this in here you can write whatever you want for example what you could be writing is what we have already seen you can write print then in quotation marks hello world close the bracket and now if you press enter you get hello world and this was done using python in here you could also write something like one plus two you would get the result and you can do quite a bit more but this is basically valid python so with that we have basic python code although the limitation here is that we can only ever write a single line of code which well isn't great what we need is some kind of code editor and that we are going to cover in the next video because this is a slightly larger section and just to make sure that everybody can follow here i have mac os in there i still have to click on download python and now i'm downloading a pkg file other than that i can click on open file and now we're getting a python installer that messed with my window sorry about that but in here you click on continue you click on continue continue more you click on agree and then you click on install now you need your password as always install software and then you're just installing anything for mac os you don't have to worry about a path and now here you can see all of my programs and i have python 3.10 although just wait a second and there we go now the entire thing finished i can click on close and move this thing to the bin and now i have python installed now to actually use it on macos i need my launcher and you have a program called python launcher although this one does look a bit weird in here you can't do very much although you have a tick box that says run in terminal window or at least i hope you do a terminal is another program inside of mac os if you open the launcher again and type terminal there you have a terminal and let me increase the font size here a bit so this is easier to read now what you want to do in here is you want to type python 3 and then press enter and now you can write python code for example you could write print brackets open then quotation mark hello world and then closing quotation mark closing bracket and now if you print this you get hello world and like we have done on windows you could type one plus two and you're getting free and this is valid python code but once again you're only writing a single line of code but for that again we're going to work on the code editor in this part we are going to install a code editor and let's first talk about why we are going to need that right now we can run python code which is a really good start but we cannot use python comfortably right now we can write single lines of code but later on we want to write hundreds if not thousands of lines of code and right now we just cannot do that for that we are going to need some kind of text editor for our code think of this like word or pages it's simply a text editor except now we are writing code instead of sentences and there are a ton of popular code editors here's the list of the really famous one we have visual studio code pycharm atom and sublime although there are a lot more there basically is no end to code editors the one that i am going to use is called sublime this is a really straightforward and simple code editor that you can also customize quite a bit which i really enjoy but basically all of those would be fine if you have a strong preference although i would recommend just to follow along to also use sublime and this is going to be just another program that we have to install oh i should mention all of them are completely free you don't have to pay anything but let's install it alright here we are on the website of sublime and the url is sublimetext.com the full name of the code editor is sublime text but nobody really calls it that and then here you can go to download and download the entire thing now you can see it already probably there is also a buy option you can purchase sublime it costs about 80 i think but you don't have to do it the free version has exactly the same features and this is what we are going to use basically when you are buying it you are supporting the creators but you don't have to do it so in download you can download the version you need either mac os windows or linux in my case i need windows so i'm clicking on that and now i have a download for my specific version obviously if you have a different operating system this would look a bit different but now you click on open file and then you get this kind of menu in here you just click on next and you install it like anything else and finish there we go now you have installed sublime on mac os the installer might look slightly different but that is minor details but once you have all of that you can type sublime text and now you should be seeing something like this this is our code editor and in here you can write any kind of text whatever you want to write in my case what i want to write in here is print and brackets and now quotation marks hello world and this is going to be the python code we want to execute now to execute all of this we need two major steps number one this is the easy one we have to save our file this we do under file and save or controller command s if i do that i end up somewhere in my file system in my case i have the folder here already you can save it wherever you want it really doesn't make any difference although what does make a difference is the naming of the file let me call this one test but you do have to specify an ending so you want dodge and then add p y short for python this is telling your computer that you have a python file you could compare all of this to word which always needs a docx ending or a text file which always has a txt ending but in our case we want dot pi and now i want to save and what you should be seeing now is that the colors of our text changed if they didn't don't worry too much about it but now what you want to do let me show my mouse and i want to go to tools and in here we have build and build with this basically means you want to execute your code i want to click on build and now i can see hello world down here now you might be seeing something else what you might be seeing is a dialog that looks something like this in here you want to select python so if i click on this one you're getting the same result the reason here is when you're running python for the first time sublime does want to double check that you do indeed want to run python but if you have done that once sublime does remember and most of the time what i am going to do is instead of up here clicking on build i am pressing ctrl or command b this one is going to give you the same result and if you want to close this dialog down here you press on escape although there is a really important topic i do want to cover and that is when we are running any kind of code in sublime what essentially happens is that sublime inserts all of the code into the python app however sublime doesn't know by default where that python app is because remember python is just another program on our computer it's nothing special the only reason sublime right now can find the python app is because of the path files these path files are basically a directory inside of windows that makes it easier for programs to find other programs and because of that sublime can find python very easily if we didn't add python to the path though sublime would not be able to find it and you would have to add quite a bit more yourself to make it all work which fortunately we didn't need because we did add python to the path files if you forgot that for some reason just uninstall python and reinstall it with the pathfire selected that's the easiest way to go on about it but alright what you can do now you could for example copy this line here and paste it multiple times run all of this and you can see hello world multiple times once again how all of this works in detail i will cover in the next well 10 hours or so but in here what you can also do is inside of print add a math operation like 5 10 and now run all of this again under tools and build and you get 15 all the way at the end and with that we can run python code over multiple lines so with this we can basically start the actual python tutorial although before we get started on that there's one more thing i do want to do that you don't necessarily have to follow because i think all of this is looking kind of ugly and a bit hard to read as a consequence i want to change the styling but i am literally only going to change the look of sublime in terms of functionality nothing is going to change so if you want to skip this part you can totally do so let me show my mouse what i want to do most importantly under view i can hide a couple of things that we don't need for example all the way in the bottom you can see a couple of bits of information that we don't need so i want to hide all of this this is the status bar and i want to hide the status bar already looking better besides that up here you can see the tabs if you have multiple python files this can be really useful each tab would be one python file but for a long time we are only ever going to have a single python file later on we are going to use these tabs though but for now i want to go to view and hide tabs already looking much cleaner besides that what you can also do is hide the menu and this is making everything look even cleaner if you want the menu back you are clicking on alt and now you can see it until you click outside of it but then you can bring it back and all of this is already looking significantly cleaner now if you want to get rid of this top bar here you have to click on f11 and now you have a full screen app which i think is much nicer to work in now what you can also do is change the text size what you do with controller command and then either the equal or the minus sign equal makes the text larger minus makes the text smaller and in here just choose whatever you can see best in my case i usually aim for having 30 lines of code on one screen so in my case the font size i usually choose if i copy this a couple of times is something like this i have 30 lines of code on one window but this is entirely subjective you probably want to have something smaller and finally what we can do is change the color scheme and the theming of this and for this you can install external themes this you do with control or command shift and p if you click all of them you get a couple of options that you can use inside of sublime in here you want to click on install package now click on enter now sublime is going to think for a second and now you can install external modules some of these change the functionality of sublime but most of them are just different color schemes and in my case what i want to install is the agila theme so if you type agila this should be the first result and now just press enter and there you can see the nodes for the argila theme but we don't care about that now to get back to our code you want to press alt for the menu and at least for now i do want to show tabs so we can navigate around here although this package control message you can close by clicking on the x here and now we are back in the code but nothing has changed now to actually apply the changes you have to go to preferences and in here you have select a color scheme and select a theme let's start with the theme in here you have a bunch of different themes if you click on down you can see what is changing so if i click on a couple you see what the difference is in my case i just want to use the agile theme so if i click on this we already have a couple of changes what you can also do now if you click on preferences again you can select the color scheme this one changes the actual code in terms of what you see and in here once again you can select a lot of different things i don't want to go over this too fast because it might be a ton of colors and well i don't overwhelm you but in here you can search for different color schemes depending on what you have installed in my case i'm gonna look for agila and then oceanic next if i select this one all of this is looking significantly nicer if i now go to view and hide the tabs this is basically what you're going to see most of the time and i think this is much easier to read although you might be wondering what is this line here on the left and well for now you really don't have to worry about it it's something much more advanced you can entirely ignore it as a consequence since it is not going to be relevant for this entire tutorial i have hidden it which is bringing us to some more optionality inside of sublime so if i go to preferences and here i go to settings we get another window and in here you can see the settings now you might be used to other programs you just have checkboxes in sublime this is working a bit different you are basically having on the left here all of the different options you could be changing for example you could change the margin size to a four and to change this you would have to copy this one here and paste it on the right side like this and now you can change the margin to whatever you want although my case i don't want to do this and i don't want to add too many complications in here because all of this is getting a bit more advanced so what i'm going to do is i have a text file let me increase the size of the right one i have a text file that you can just copy if you want to have the exact same styling that i do you just paste it in here and now if you click on control s to save everything you should see not much of a difference although the yellow bar for example disappeared and all of these options here you can find in the description so with that you can minimize all of this and now all of this looks as clean as it can be at least i think so so with that we have python installed and we can get started i want to start by talking about how code in python or in basically any programming language is being executed and there are a couple of things you have to understand the most important concept is that code will always be executed from the first to the last line for example if we have these three lines of code python is going to start from the top so line one this one here then we do line two line three and then we continue until we reach the end of the code and later on we are going to learn some tools to make this more flexible for example if we want to repeat code or only run code if a certain condition is true but for now i just want to execute some basic code so we can get started and let's have a look at all of this in some actual python file and here we have a completely empty one and something we have seen already is to use the print statement and in here you can just write a random word so a random word and now if i execute the code which again i do with ctrl b or if i press alt i can go to tools and build same thing if i click on it i get a random word and just to be a bit more specific here let me change this word to first line of code and now if i add another print statement let me duplicate this line which i by the way do with ctrl shift and d that way you can duplicate lines and sublime very easily now what i want to do for the second line of code i want to rename this to second line of code and now if i run this we get the second line of code meaning this line here was run first then we have number two and this would then continue forever we are essentially executing code downwards in this direction and this would work with any other data type as well for example i could print some numbers and now we will get one two and three and that is then giving us the most basic thing you have to understand that now we can execute some lines of code and i suppose there's one more important thing when we are talking about words and print and that is let me copy this again a space in here would also show up meaning if i add a ton of white space and run this again we now get this line of code here let me rename it really quick third line of code all of this white space here is still showing up so just keep that in mind and well with that we have covered all of the basics of really basic code execution and i guess with that let's do an exercise i want you guys to use these print statements to print some kind of tree looking shape and for that you want to use basic characters and white space and then combine these two and create that shape so pause the video now and see how far you get the way you have to think about it i want to print again and i want to write five axes and if i run the code now we can see these five axes if i now print these five axes again one two three four five but remove the first two and replace them with a space if i now do this i get the three axis on top of the five axes and before the first x we have a white space so we start to have some kind of pyramid shape i just want to continue i want to print two spaces and an x and if i run the code now we can see we have a proper triangle and this would be the top of my tree and now i can copy this line and at the bottom of the tree i can add it 3 times if i run this now we have a tree this is looking pretty good granted it doesn't look too nice but it is what it is i suppose what we can also do i can just print empty strings with no word inside if i do that we have one line of space between the words we have covered earlier and our tree although one important thing really quick there is one line in here that i left intentionally empty to organize my code for python this line does not exist if i run the code the empty line we have here is because of this empty statement this one comes right below the one two three this one to three this line for python is just being ignored meaning if you don't write a line of code python is just going to ignore it which is really helpful to keep your code organized so alright this is then the most fundamental thing you have to understand and it's pretty simple we are just executing code from the top to the bottom in this part we are going to learn about math operations and those are in python fairly similar because you probably already know them from basic math classes that you learned when you were something like 5 or 6 it's really basic we have plus minus multiply and divide and besides that we also have power floor divide and remainder i guess the letter 3 are a tiny bit more advanced but not that much besides that you can also use brackets perfectly fine like in any kind of computer calculator you ever used there are also comparison operators like smaller than or smaller equal then but those we will cover later because they work ever so slightly differently i guess i can talk about them for a tiny bit but don't worry about those too much yet let's have a look at all of this here again i have a completely empty python file and i want to start by printing a math operation and this i just do by typing the math operation in here for example 10 plus 5 is going to give me 15. and that is literally it it's quite simple if i duplicate this line i can change this to a minus and now we get 5. i could duplicate this again change this to multiply and duplicate it once more and change this to divide and that way we have all the basic operators so if i run this we get 15 5 50 and 2. i guess the one thing you do want to notice here is that when we're using division this operation here python is giving us 2.0 it happens to add a point zero even though we wouldn't need it it's really not a big deal but just keep it in mind besides that we have slightly more advanced math operators let me print 10 star star and 5 and this is giving us a fairly large number because we are taking the power here i guess if i do a 2 we have the equivalent of 10 to the power of 2 which is 10 multiplied by 10 which is 100 and this is what we are getting down here besides that we also have what is called a floor divide and to understand what that means let me divide 10 by 3. if i do this we get 3.333 and it continues basically forever if floor divide essentially gets rid of all of the stuff after the decimal point and this floor divide you get with two divide symbols meaning if i run the code now we are only getting three you are essentially rounding the result of whatever you are getting in here although keep in mind this value is not rounding the result what we're doing is truncating the result which is a fancy word for saying we are cutting off anything after the decimal point i can demonstrate this by dividing 7 over 2. if you do this in your head you are going to get 3.5 with a normal division and if we were to round this number it should be 4 because 0.5 is closer to 4 than it is to 3 but if i run the code again i am getting 3. and just be careful here this can sometimes cause you some errors where you're losing decimal points and then end up thinking you're rounding when you're not actually doing that there's one more math operation we need and that is done with the percentage sign for example this could look like seven percentage two and if i run this let's see what we get we are getting one and this one here is the remainder the best way to think about it is we have seven units in total we have one two three four five six and seven and when we are dividing seven by two we are basically looking for two whole units to get a full number meaning here is one there is two and here is 3. and that is giving us the result we got from this operation and this percentage symbol is giving us whatever remains at the end which is this one here and since this is one the one we're getting down here is well a one you don't see this symbol too often but it can be really useful to figure out if a number is even or odd something you do surprisingly often we're going to have a look at that later there's one more thing i do want to cover and that is brackets for example i could print 5 times 2 and the result is going to be 10 this should be fairly simple but now if i do 5 plus 5 multiplied by 2 think about it for a second and see what you should be getting the result is 15 and it is 15 because we always do multiplication first and then we are doing addition and subtraction meaning this operation is basically 5 plus 10 which gets us 15. if i don't want to do that and add 5 plus 5 first of all i have to put both of those into brackets and now i'm getting 20. what we're doing now is 5 plus 5 is 10 and this we multiply with 2 which is getting us 20. i guess the one thing we can also cover is very simple comparison operators and those do work in the same way that you would expect them to work to be honest for example i could type 10 is greater than 5. the difference here is the result we are getting because the result we're getting is true which i guess doesn't make sense because 10 indeed is greater than 5. if i flip this around that 10 is smaller than 5 and run the code again we are getting false and how we can use these values we will see later on but for now don't worry too much about this one now with that we have covered the basic operations and let's do an exercise what i want you guys to do is to get the average of the numbers from one to seven so one plus two plus three plus four plus five plus six plus seven all divided by seven and see how far you get once again i have to type print and now in here i want one plus two plus three plus four plus five plus six plus seven and all of this has to be inside of brackets because what we're going to do afterwards is divide all of this by 7. and the issue is in terms of math if we left it like this we would first divide seven by seven which would be one and then we are adding all of these numbers but what we want to do instead is do all of this here first and then divide it by seven for this sort of thing sublime is quite intelligent i can just select the entire text create and open brackets and then sublime automatically adds the closing bracket afterwards and with that we are done if i execute the code now we get 4.0 although looking at the result here i realized for this entire part so far i have only ever used full numbers which you don't have to it is perfectly fine to write something like one plus one plus five you would still get the appropriate result any number in here is going to be fine this is working like any math operation you have ever seen in this part we are going to talk about how to connect different lines of code and let me explain the problem let's say we have some kind of math operation and we want to print the result of that map operation on the next line the issue we have now is how can we connect these two lines and the answer here is we are going to need variables and variables are an incredibly important topic in any programming language so let's talk about it all that variables essentially are is a simple container for any kind of data we could for example put a word a number or really anything we have a python in there and once you have created this container you can reuse it over and over again and this variable you create like this we have the variable name then we have the assign operator and that is just an equal sign and then we have the actual data or the value we want to assign and that is basically it this instead of a word could also be a number like one and it could be anything else but how you would solve the earlier problem is you would first store the math operation result in a variable called result and then this result you would print on the next line and i suppose let's actually try all of this once more completely empty python file and in here i want to do a map operation again and so far we always used print and then did some math in here let's say ten plus five but this print we don't need we could just have lines like this although if i execute the code now again by pressing ctrl b nothing would happen although something did happen python did calculate the result here we just didn't tell to print the result so it doesn't print a result and we can't see anything but something did indeed happen instead of printing this result i want to store it in the variable and this variable i called result and this is going to be the name of my variable now and now to assign this value here to this result we are going to need the equals sign which is telling python that the result of this operation should be assigned to this variable and now on the next line we can just print that result and if i run the code now we are getting 15 or the result of this operation here and what is even better we could use this result for further operations and we would use it like the actual value for example what i could be doing i could have another variable let's call it result 2 and the value here should be the original result divided by 2. and if i now print result 2 we can see we get 15 and 7.5 which is this result divided by 2. and this we could do forever this result is basically a stand in for the value we have created here although there's one thing you do want to be careful about and that is variable naming let's talk about this one really quick there are two variable naming parts the first one is the mandatory parts that you have to follow if you do not follow these naming conventions python is going to throw an error and fortunately they are fairly simple the most important one is that variable names can only contain letters numbers and the underscore symbol you couldn't use something like the dollar sign percentage space something like this space in particular should make sense quite intuitively if there's a space in a variable name it's really a python to tell if we have one variable or two variables it just gets messy and if you have a longer variable name and you want to add multiple words together you would use an underscore and that is quite a common thing to do i will show you in a second the second rule is a variable name must start with a letter or an underscore the important thing here is numbers are not allowed a variable name cannot start with a number finally variable names must be different from the inbuilt python tools for example we couldn't name a variable print i hope this one makes sense as well it would just be confusing and i guess let's have a look at all of these rules and see if we can play around with them i want to create a new variable let me call it test and then here we can just add a word test it doesn't really matter if i run this code now we are not getting an error because this variable name here is perfectly fine and i could also add an underscore add some numbers add another underscore and add some capital letters all of this for python totally fine although this name here probably really confusing what python doesn't like let me put this on the next line is if we for example start with a number for the variable let's say to test and the value here could be test again it doesn't matter if i run this now we are getting a syntax error oh well we are getting quite a bit let's actually go through this error message here first of all python is telling me which file has caused the error and also it's telling me on what line the error occurred line 8 in this case which you can see here on the left side besides that i also get the actual line that caused the error so 2 test is equal to test and below that we have the really important information and that is this syntax error invalid decimal literal it sounds somewhat cryptic but what python is complaining about here is that we are starting a variable name with a letter however if i change this to 2 test everything is working just fine again and on top of that adding a number anywhere else inside of the variable name is perfectly fine i could for example add the two at the end this would also work just fine the other thing that you are really not allowed to do is to add spaces in your variable name and if i run this one now we are getting invalid syntax again and here python is giving me a ton more information although it really doesn't tell me all that much this line here is the really important one and i think it does make sense why there's no space allowed if we have something like this it looks like we have two separate variables which obviously would be kind of confusing so what programmers i usually do in basically any programming language is they always add underscore signs to show that we want to add a space but with that we have all of the basics for variable naming or at the very least the mandatory parts there are some more that are more optional let's talk about those the most common rule that you are going to see is that you should use snake case and snake case just means that when you are starting a new word you always start with lowercase and every additional word always is lowercase you basically only use lowercase letters and then to connect words you're using the underscore and this one you have to use anyway since this is a python rule what snare case basically means is you are always going to use lowercase letters and space is replaced with an underscore that's all it means besides that the other rule is that variable names should make sense this sounds very obvious but i can show you a couple of examples in just a second that might get very confusing generally it's fine to have longer variable names but make sure that the variable name expresses its content it's very easy to not do that and end up with code that you do not understand anymore so always write long names that express what the variable actually does and finally variable names should be consistent i suppose this one is pretty obvious and i guess the really important one is this one here because this one is looking terrible if you were working with other people and try to name a variable like this you would have some questions about your mental wellness i suppose something better would be more like test variable and let's call it practice this one here would be a perfectly fine variable name it isn't a snake case because we have lowercase letters and we are connecting the words with an underscore and this one here would also be at least a valid python name but we are kind of inconsistent we are first writing a word with letters and then the actual number so what you might want to do here is write 2 a bit more consistently or don't use any numbers when variable names begin and always stick with numbers whatever you prefer just be consistent it really helps the final thing i really want to mention what i see a lot of beginners do is do something like x equals i don't know some words and this is fine for shorter programs but once you have longer ones it can be really confusing meaning you want to replace this with something that actually means something it is a really common thing that you write a program you don't look at the program for half a year then you come back to the program and you have no idea what you did half a year ago happens to literally every programmer and naming your variables properly makes it a lot easier to read what your code actually does so name your variables properly there's one more thing that i really want to do because now that we have variables we get a few more math operations although those math operations are going to look a bit weird they are looking like this we have plus equal minus equal divide equal and multiply equal i think to explain what they do let's do an example let's say i have num one is equal to one a really basic variable and i want to increase the value of this num by a certain amount for example let's say by 5. to do that i could write some code like this that num1 is itself plus 5. and this would be fine but this also feels kind of clumsy and for that we have these operators here what you would do instead in python is something like this we have num itself then plus equal 5 and those two code snippets here do exactly the same thing they take the original variable and then add a certain value to it let's do this in code actually i think that's going to make more sense i want to create another variable let me call it num1 and by default this one is 10. and now this 10 i want to increase by 5 again and this could look like this i want to get my original num1 and then add 5 to it if i now print num 1 we are getting the value all the way at the end which is 15 again i guess let me use different numbers so we get some different results now we get 20 which is 10 the value of num1 plus 10. but again this here is kind of clumsy and python gets around this biting plus equal and then we are adding 10 meaning now we are taking the original value of num1 and adding 10 towards it and assigning all of this again to num1 and if i run this we are getting the same result so if i spell this out a bit better these two lines here are doing the exact same thing and this is working with the other math operators as well for example we could have minus equal and we are getting zero we could add multiply equal which is getting us a hundred and we have divide equal which is getting us one and if you just want to update a variable this is how you would do it and this is now bringing us to the exercise for this part and what i want you guys to do is to create a variable that has some kind of snake case and try to use a bit of a longer word assign a value to it and on the next line increase this value by 20 and then on the third line print the variable let's get started by creating a really long variable name that is a bit annoying obviously you would never use something like this in practice but i hope you get the idea and the value i want to assign is let's go with 10. on the next line i want to get my really long variable name that is a bit annoying and i realized i do have a typo let me fix it really quick and i want to increase this value so i want plus equal and i think i said 20. and now finally i want to print my really long variable name that is a bit annoying and if i print this we are getting 30. and with that we have variables which is an incredibly important concept in this part we are going to talk about functions and all that functions are are special commands in python we have actually seen one already and that is print which is printing a certain kind of text this one you should be really familiar with at this point but there are quite a few more for example len gives you the amount of characters in a word and another one would be abs or absolute which is giving you the absolute number which in practice just means if we have a negative one and we're using apps this is turning into a one although to understand functions we need one really important concept and that is brackets meaning when we're adding brackets after the name of the function we are calling it and this we have done multiple times already anytime we use print we have called a function by adding brackets afterwards and inside of the brackets we are adding what is called arguments for example for print we can add any kind of argument and this is then what we are going to print in the case of well print and let's have a look at all of this in code i want to once again start with print and this is the name of the function and to call it i need brackets and what we're adding in here is the argument which right now is the word which that's called test and what this function does is it prints the word so we can see it another function that we can use is called len and in here we could add another word if i run the code now we can't see any result because this is only giving us a value but we're not doing anything with that value and to overcome that we have to print the result and now if we run this we are getting 12 and this 12 means that inside of this word we have 12 characters we have 1 2 3 4 5 6 7 8 9 10 11 and 12. notice here that python is counting a space as well and all of this could also be used with variables for example this len i could assign to the variable word length and then on the next line i want to print my word length and i get 12 again and this would be a slightly cleaner way of doing this although the previous one would also be perfectly fine and another function we can also work with is absolute or abs and in here i can add negative 50 and for this once again i have to print the result otherwise we wouldn't see it but now if i run the code we are getting 50 meaning abs removes this negative 50. and there's one more really important thing that you can also do with functions that right now we always only added a single argument but for some functions you could add more than that print is actually one example of that let's put this on a separate line so far for print i always added one argument but what i can do i can add a comma and then add another argument and now i have two arguments if i run the code i get one argument and then print adds the other argument and print accepts an unlimited number of other arguments meaning if i run this now we are getting more and more arguments the important thing here is you always add one argument then a comma and then another argument another comma and so on depending on what the function accepts and some functions only accept a single argument for example absolute only takes one if i added another we will get an error and that is abs takes exactly one argument and we have given two python here is very clear apps only gets one argument but that is essentially the basic concept of calling functions now for the exercise i want you guys to do some research online and i want you guys to look up the function called max and try to figure out what it does and call it inside of this code here i have google open although you could use any search engine and to learn coding you have to do a ton of research so it's a really good idea to start early and what we want to do right now is look at the python function max and let's just see what we get in here we can see a bunch of websites and for python all of them are basically fine w3schools program is are really big ones geeks for geeks is also really big but the one you probably want to use the most is docs.python.org this is the official python documentation if i click on this one we can see all of the builtin functions for python and the one i'm looking for is called max if i click on this i get a ton of information the most important one is right in the beginning it's returning the largest item in an iterable or the largest of two or more arguments what an iterable is we have no idea so far but what we do know is the largest of two or more arguments so let's have a look at that one once again we are in the code and i want to use my max function and in here i want to just add a couple of random numbers now i once again have to print the result and if i run this i get 10. and well we get 10 because max is selecting the largest argument that we are passing into it which right now is 10. and well that is basically what it does if you understand this one you also understand min which is taking the lowest number which in our case is 2. and with that we have covered functions besides functions we also have methods and especially for beginners methods and functions can be very similar so let's compare the two in the most basic sense a method does the same as a function the only difference being that the method is always attached to an object which means we are still calling a method with the name of the method followed by brackets and this is still called calling a method just like a function we can also still pass an argument in here this works in exactly the same way the difference is that methods always are connected to an object and this happens with a dot which in practice looks like this we always start with some kind of object in this case it's a word it could also be a number or any other data type in python this is then followed by a dot and this is really important then we have the method name and then we have brackets with whatever argument you want to put in and then all of this does a certain thing just like a function what this thing could be is for example we can use the upper method and this one takes a word and returns the same word all in uppercase letters and i think this example also illustrates why we have functions and methods sometimes functionality only makes sense for a certain kind of data type or for certain objects with a certain data type and here the upper case really only makes sense for a word there's no uppercase for a number for example and this is why we have methods and i suppose we can implement all of this a bit more practically so let's have a look at all of this in code once again i have a completely empty python file and i want to create a new variable let's call it test and the value for this test is going to be a word to get started i want to print my test variable and if i print it we are getting a word so far all of this should be very familiar and the method we have seen we are calling with a dot after the word and then the name is upper and don't forget the brackets if i run this now we can see a word all in uppercase letters and with that we have called a method what we can also do let me demonstrate it first and then explain i can cut out this upper here and run it on this variable if i run all of this now we are getting the same outcome and why this happened i will explain in the next section but in the most basic sense methods always change a value where you change that value is really up to you in the first example we created the word and then when we are creating the word we are calling the upper method and this is returning the uppercase letters and storing them in the test variable and once we have that we are printing the test variable that's all that's happening here and then the second example looked like this and in here we first created the word and saved the word inside of the test variable after that we are still printing the test variable but now when we are printing it we are modifying it with the upper method which is giving us the uppercase word the result for both of these examples is the same how this works in detail you are going to understand very soon for now i'm going to call the upper method when i create this value now obviously this example really isn't all that useful let's do something more relevant let's say we have some kind of user name and we are expecting something like john smith where we have a first name and a surname but since you are allowing user input this might instead look something like this we have a typo and maybe we have some access at the end and let me add another typo in here this would still be valid user input but obviously it would look terrible which is something we couldn't use for our purposes and methods are really good to clean all of this up and the one method we could start with is called title and let me print the username and see what that one does now we get always let's expand this a tiny bit we are always getting the first letters uppercase and then every other letter is lowercase meaning now we have john smith in the proper spelling at least for names meaning with this we get rid of this o and this i what you can also do is combine different methods what you do by adding another dot after whatever value you want to change and then calling the other method in my case for this one i want to get rid of these two axes and for that i need this strip method and what this one does is it looks at the right and the left side of any word and removes a certain kind of value whatever we specify inside of the arguments and in my case i want to get rid of these two axes which means i want to add the string x in here and if i run this now we can see there is no difference so what went wrong here and i think you can already tell what the problem might be in the original word the two axes were uppercase and this is what we are trying to remove but what this strip method here sees is this string changed by this title meaning strip doesn't see a capital x it sees a lowercase x and for python again remember capitalization really matters an uppercase and the lowercase letter are two completely different things for python to fix that all we need is a lowercase letter and if i run this now we have removed the two values you might be asking yourself what methods are available and there are a couple of ways to achieve that if you want to stay inside of a code editor you would use the dir function and in here you can pass in any value to figure out what methods it has for example i could pass in the user name in here and if i run the code now nothing happens the reason is that this function only returns all of the methods it doesn't print them for that we again need the print function now if we run this we get something that looks a fair bit more technical and you have two main things in here you start with all of this stuff here a lot of names with double underscores before and after the word like this lte here we have two underscores before and two underscores afterwards what these mean we're going to cover much later what you want to focus on for now is all the stuff down here these are the methods that you could be using and we have actually used a couple of them already for example strip we have used title and we have used upper i guess we can do one more method and let's use is alpha what this method does is it checks if the values inside of a word are in the alphabet meaning they are not numbers let me close this one and instead of the dir function i want to print user name and then dot is alpha and don't forget to call it and now if i run this this is saying false the reason for that is that inside of this word we have one value that isn't inside of the alphabet and that is this space here if i remove it and run out of this again now it says true meaning every letter inside of the word is inside of the alphabet if i added any kind of number in here this would go back to false although i don't really want to do that but this would be another way to check something in your word that may become useful especially when you work with something like user input you might want to check if there are numbers inside of the name however if i go back to the dir function run this again this list here still isn't that useful because you have a name but you don't really have an explanation of what the specific method does and well to really understand what a method does you do want to use google and if you want to google for specific things you need to know their names for example in python or in really any programming language a word is always called a string we're going to cover that in much more detail in the next major section just remember for now a word in programming is always called a string and with that let's do some googling in here i want to look for python string methods and then i am getting a ton of different results and again all of these websites here work quite well the one that is the official documentation by python is called docs.python.org and this one says built in types python something something documentation and in here on the left side you can see all of the data types again we're going to cover those in a lot more detail very soon for example here you have numeric types we have sequence types and then we have text sequence type str which stands for string methods this is the one i want to look at and in here you have a very long list let me minimize this part you have a very long list of methods that you could be using along with a fair bit of text explaining what they do for example here is is alpha the one we have just looked at and if you have any kind of problem yourself you would probably read through this list and try to figure out what method works for your purpose and i suppose let's have a look at another website for example w3schools is also really good and in here we also have a long list of all of the methods the list contains the same number of methods and in here let's say if i click on is alpha we get to another website we have an explanation along with an example you honestly can use any of these websites they all cover basically the same thing all right with that we can do an exercise and in my case i want you guys to do some research because i have an exercise string that is saying i like puppies and what i want you guys to do is to find a method that replaces the word puppies with let's say kitties or any other animal that you really like so pause the video now and try to figure this one out yourself in my case i want to look for python a string remember this is just a word and i want to replace a let's say a value if i do this i already get one answer predicted by google that is called replace although if i go down i see replace a bunch more times and well i just had to look at one of them doesn't really matter which one it is let's choose program miss this time this one is really good and then here we have an explanation of what this one does we have an example and then we have the syntax so how we would use it and in here we have a string so any kind of word then the replace method then we have an old value a new value and a count and down here then we can see how we would use these values the old value here means the value we want to replace the new value is what we want to replace it with and then the count basically means if we have the old value multiple times how many times we want to replace it and this one is optional so you could leave it out entirely and with that we can implement all of this back in my code i want to add a dot and then the replace method and in here we first of all need the old word which in my case is puppies after that we need the new word and this in my case is going to be kittens although any kind of word would be fine in here and these two values would be mandatory so we have to have them but once we have them we can print the result and run this now and all the way at the bottom we get i like kittens we have successfully replaced puppies with kittens we could also add a third value and this one determines how many times we would want to replace this value let me actually paste it in a few times here now we have puppies four times by default i am replacing all of them with kittens meaning what i get is i like kittens kittens kittens and kittens but if i add another value in here and this has to be a number let's say i want to add a 2. now if i run this i am only replacing the first two instances of puppies with kittens but after that i keep my puppies around and again there are a lot more methods far too many to cover them in one video what you basically do as a programmer is you keep on working and you learn more and more methods as you go along but that being said even after a few years you are not going to know all of them for that you have google and you just look up different methods i have been programming for years and i still forget them all the time it's really not a major issue and with that we have methods in this part we are going to cover return and return is one of the most important concepts in all of programming so let's talk about it in the most basic sense return is the glue that connects everything in python what that means is that any operation returns a value for example if we calculate 2 plus 2 f4 is being returned we also have functions and methods and those can also return values for example upper returns the uppercase letters of a string and by combining different return values you are creating more complex logic and what you are basically going to do in programming is combining different return values to create something more complex and an example here could look something like this just read through this and try to think of what the outcome here is going to be and let's go through this line step by step we are always starting with the innermost part in this case it is a word and then we are applying right now the first function which is len this is going to return a value and the value it is going to return is 6 or the amount of letters inside of this word and next up this value we are going to multiply with negative 10. this again is going to return another value negative 60. this is then going to return 60 because the absolute function always turns a negative number into a positive number and this would be one example of the return statement where we are taking specific functionalities like the length function here and then use the value they return in another operation like this 6 multiplied by negative 10. what you absolutely have to understand is that every operation in python returns a value and then this value you can combine with other operations like using it in another function or with another method or in a math operation it's really up to you but this is a really powerful system that allows you to add lots of logic on a single line of code let's play around with this i think that is going to be really important once more completely empty python file and let me create a test variable let's use the example from the previous part where we had e word and then we used upper let me print it as well and we are getting a word all in uppercase letters and i think i want to have a bit of white space around it that makes my life a bit easier what happened in here is we have a word and then we're using the upper method to change the word what this combined statement here returns is a word all in uppercase letters and once we have that we can add another method to it and the method we could be using here the one we have already seen let's use replace and what we want to do in here is replace the letter a with the letter let's say x and now if i run this we have x word what happened here is that this first statement returned eword this one should be obvious by itself after that we have used the upper method to turn this eword into e word all in uppercase letters after that we have used the replace method to change this a to an x and we could continue this forever for example what we could do for example what we could be doing is wrap all of this inside of the len function and now if i run this we are getting six we start with a word then we are turning all of this into uppercase letters then we are changing the first letter from an a to an x so what we have inside of these brackets is x word all in uppercase letter and what we do then is use the len method to count how many characters we have inside of this word which right now is 6 and this is what we are storing inside of the variable i hope this makes sense it is a really important concept to understand all it means is every time you perform some kind of operation a different kind of value is being returned and then this value is what you are working with next you really have to be aware that every operation returns some kind of value although this can be kind of weird sometimes one really good example let me remove the white space here and then let's play around with the print function because this one by itself just prints whatever we pass inside so what's going to happen when we print a print function and let's see we are getting 6 and none the 6 we are getting from this inner part and the none is what gets returned by a print statement and none is an actual data type in python you can work with it but it basically denotes the absence of a value but again print is returning something although in this case what it is returning is the data type none i hope you get the idea here now for this part i am not going to do an exercise but i would recommend you to play around with this yourself in your own time and see what you can do yourself throughout this series we are going to do a lot of examples so there's plenty of time for practice a really important thing you have to understand is comments and comments do not influence your code whatsoever they are just explaining it or well they are commenting what your code does and you really want to use comments quite extensively because they are really useful to help how you organize your code and to understand what it does especially if you work in a team you want to add lots of comments because other people would really appreciate it it also works as a really good reminder for your own code it's a really common thing for programmers that you write some code you don't look at it for half a year and then you have no idea what it does anymore and writing comments is a very good way to remind yourself there are two ways to write comments in python the first one is the hashtag symbol anything on that line after the symbol is going to be ignored by python the other way is a triple quotation mark this one will comment out anything inside of these quotation marks this would also work over multiple lines although technically it's not a comment we are going to learn later what this is but you can use it as a comment and let's say i have again a test variable and this one is a really important value i want to add a comment to explain that this is a really important value we are just using the hashtag symbol and anything after that symbol is going to be a comment you can also add multiple if you want to add some specific kind of styling which is fairly common actually what you see fairly often is programmers doing something like this then a comment and then something like this at the end i guess we can close this box as well to make it look a bit prettier with something like this you have a very clear section inside of your code but the important thing here to understand is that anything after hashtag symbol on the line of code is going to be ignored i guess let me actually run the code by printing the test variable run this now and we can only see a really important value anything here and here was ignored by python you could also put this anywhere else in your code for example here and then this line of code is going to be ignored entirely and something that would make more sense is you could comment out the entire line and that is basically it for the easiest kind of commenting although for this type of comment sublime has a very neat trick let me duplicate it a couple of times and imagine all of these are different examples of code and you want to comment out all of them it would be really annoying to write a hashtag in front of every single line of code it just wouldn't be efficient so what you can do is select all of them and then press ctrl and the forward slash the one below the question mark if you do that all of them are being commented out and if you press it again the comment disappears which is what i am using all the time and well with that we have the first type of comment what you can also do i guess let me add something below here let me call it another variable let me just use some numbers and now duplicate this a few more times and again i want to comment out multiple lines of code for that i can use three quotation marks at the start and at the end you can already tell the color was changed to gray and this tells us this is going to be a comment meaning if i run the code now we wouldn't be able to see it okay granted we wouldn't be able to see this at all so let me add a print statement in here with another variable if i run this now we still cannot see the print statement because all of this is a comment now this example here isn't exactly great because it's just lots of individual variables that i copypasted how you would use this kind of comment most of the time is by adding a couple of lines of code that explains something more complex let's say this is a really important section it does a couple of things that we need for the code to work whatever you want to put in here after that you would have the rest of your code this is what you see fairly often and python actually incorporated this into its functionality we're going to see this later on as well i guess for now the really important thing you want to be aware of is this one here the simple kind of comment that you can just put anywhere and that way you can either add explanations or sections to your code which really help with the organization before we are finishing off this section i want to talk a bit more about the lines of execution logic because there are a few things that i haven't covered yet let's go through them the most important part is that how you see lines differs from how python sees them a really good example here is that python does not see empty lines in the code only you do and let me illustrate what i mean if i start typing print and let's call it first line and then duplicate the line and type in second line if i execute this code i get first line and second line this is the stuff we have already seen quite a lot it should be fairly obvious by this point however what happens if i add a space in here now we have a line of code nothing and another line of code if i run all of this now we are still seeing the same result the reason being that python ignores a line without any code if there's nothing on the line python is just going to ignore it meaning what you could be doing is add a huge amount of white space and it would not make any difference to your code which is very often something you do want to work with quite extensively because this is making it much easier to organize your code especially if you add more comments with something like let's say second line and then this could be the first line you could have a setup like this which in your case might make it much easier to read but all that python sees is this line and this line here which is giving you a ton of work to customize whatever explains your code the best but there are quite a few more things that you should be aware of what i have also covered is that python ignores white space within a line meaning you can add as many spaces as you want let's have a look at this one as well for example what i could be doing inside of a string i could add as much white space as i want and this one is going to be reflected in the code i am running what i can also do is add white space between the different parts of the code something like this would still work just fine although granted in this case there isn't much reason to do something like this i suppose something slightly more relevant might be we could add 1 plus 2 plus 4 and so on and for this line python would just ignore the white space meaning if i run this we are just getting the result python doesn't care what you do between these lines which i suppose you could be using for something like 5 multiplied by 5 and then plus 10 so you indicate which operation comes first the 5 multiplied by 5 although still kind of a stretch what you can also do is use tab you can add this as much as you want python doesn't care it trades tabs like white space that being said there's something really important and that is python really cares about the indentation of an entire line let me demonstrate this this is going to become incredibly important later on what we have seen so far is that these annotations do not matter to python however what python does care about is if this entire line is indented if i indent this entire line and run this again python is going to give me an error the error we are getting is called indentation error unexpected indent why that is you are going to learn later what you have to keep in mind for now is that inside of a line you can add as much white space as you want but you couldn't add white space when you start the line like here python is not going to like that but right there's one more topic i do want to cover and that is how to break the line space or at least how to make it a bit more flexible because you can create multiple lines of code in one line the reason here again is what you see as a line and what python sees as a line are two separate things if you want to be a bit more specific about it what you see is a physical line all that really means is whatever is in a single line of code it's as simple as that but what python sees is a logical line and this is what gets executed one step at a time let me demonstrate this one as well actually let me clean all of this up actually so things are a bit easier to read we have two physical lines and two logical lines meaning what we see and what python sees is identical we have this line and we have this line however what i can do now is put both of these print statements on the same line and python isn't going to like this at all and the reason here is that for us this is one physical line and we can i guess read it but to python this is one logical line now that doesn't make sense python can only execute one of these functions at a time it has to execute this line first and then this line second it cannot do them at the same time which is why we are getting an error here although this logic you can break to some extent and there are two ways of doing that the first one is you can use a semicolon and this way you can separate a physical line into logical lines all of this here would be a physical line but because of the semicolon python is going to break this one out into two logical lines and is going to keep happy the opposite operation i suppose you could call it would be a forward slash this one is breaking two physical lines into one logical line this is something you are going to use fairly often if you have a really long operation the example here is we're just adding some numbers and at some point we ran out of monitor space as a consequence we wanted to have all of this on the same line meaning this is two physical lines but because of the forward slash python turn all of this into one logical line and keeps being happy so all is good and let's have a look at those two and then we are done with this entire section and i guess we can start with the semicolon if i put print and print on the same line run this again python is going to be unhappy but if i put a semicolon between the two then python is going to remain happy because this semicolon is breaking a logical line now that being said this semicolon you are probably never going to use or at the very least you are very rarely going to use it it really is very very uncommon what is however much more common is let me create another variable let's call it a what you do see fairly often is some kind of very long math operation let's say one plus two plus three plus four plus five and this could go on forever and you want to break this up and for that you would use forward slash and then on the next line you can continue writing the line as you would normally do meaning i could add a plus 6 plus 7 plus 8 and so on if i now print a and run this we are getting a proper result keeping your code readable is a priority that you want to keep in mind and the forward slash is really useful for that but right with that we have all of the basics covered in this section we are going to cover data types and this is going to be an incredibly important part because understanding data types is one of the most fundamental things you have to understand about programming python does have quite a few different data types we have actually seen some already the one that we have used the most is words which is just a string it really is just a fancy word that programmers use we are just talking about words besides that we have also used different kind of numbers we have seen integers and we have seen floating point numbers the only difference between the two is that floating point numbers has decimal points whereas integers are always full numbers the reason why that is is quite technical and you don't have to worry about it you can work with them very very easily and they are basically interchangeable from your point of view there are only very rare exceptions where that is not the case and those exceptions you probably are not going to come across unless again to some very specific topics besides that there's one more data type that we have seen as well and that is a boolean and boolean data types can only ever have two values they are either true or false and in the context where we have seen them is some kind of math operation for example 10 is greater than 5 was true these boolean values you are going to work quite a lot later with to organize the flow of your code for example you might only want to run some code if a certain condition is true besides those four data types python has quite a few more some are more important some are less important but there are four that you absolutely have to know and let's start with the easiest one a list this is basically just a container to store other data types for example in this list right now we have three values we have one and two and both of those are integers and besides that we have a string which is just a word you could also store boolean or floating point numbers and you could even store a list inside of another list python really is flexible here besides that we have tuples we have sets and we have dictionaries and all four of those data types are just there to store other values the difference between them is that they are storing data slightly differently a list and a tuple differ because a list can be changed whereas a tuple cannot be changed a set would be different because every value inside of it has to be unique and there are a lot of ways to compare different sets to filter out data and finally a dictionary is a much more organized way to store your data in here we always have a name and then a data type i am going to go through all of those in detail throughout this section and then we are going to go in quite some detail into all of them besides those there are also some data types that are much less common i will cover those at the end of this section they really aren't that important but you do want to be aware of where they appear and why they matter but generally python is incredibly relaxed about different data types most of the time you are actually not even going to notice for example if you have an integer and a floating point number for example this could be 1 plus 1.2 and python here would automatically convert these two numbers into a floating point number with 2.2 you have essentially combined different data types but because python is so flexible about it you didn't even notice which is one of the main reasons why integers and floating point numbers especially for beginners are basically identical and you never have to worry about them on top of that python also has a ton of functionality to change different data types i'm going to cover that very soon as well let's get started by talking about integers and floats or well just numbers and i just covered them but just as a recap we are creating numbers either with integers or with floating point numbers and again the only difference between the two is decimal points for floating point numbers and integers are always full numbers again the difference is because of how computers work but you really don't have to worry about it the most important thing for you is that all math operators work just as normal meaning if you add an integer and a floating point number you are getting a floating point number let's have a look at some examples and a really useful function to understand what data type you're working with is called type if i write type and then add an integer so a one in here python is going to tell me what data type i am working with and again we have to print the result so we can see something if i run the code now we're getting class and integer what a class is you're going to learn much later in this series but the important thing for now is the integer this is the kind of data type we are working with if i change this 1 to a 1.1 then we are getting a float or a floating point value which means you are working with different data types you could also add a string in here so a word let's say a word that is horrible spelling but you get the idea and we have sdr for string let's stick to a1 actually we don't need to type at all anymore instead what we can look at is the conversion between different data types and for numbers this is all automatic and here i could just type 1 plus 1 plus 1 and we get 2.1 since this does have a decimal point we have a floating point value although if you didn't know this specifically you would never notice although i guess sometimes this can be slightly weird we have actually seen this very early on in this entire series if you divide any number by another number let's say 10 divided by 5 i am going to get a floating point number even though i wouldn't necessarily need it and this always happens in python you can't really get around it but that is basically all you have to know about numbers in python in terms of data types python here is really flexible and makes all of this very easy which does make it much easier than most other programming languages i guess one thing we can cover as well is let me add this on the next line you can use functions to convert different data types for example let me print something again and i have a integer let's say 2 and i really want to convert this integer into a floating point number one way of doing this is to add 0.0 to it if i run this now we get 2.0 although this isn't exactly elegant so we're not going to use it a better way would be to use a function that is called float and float converts any kind of integer into a floating point value if i run this now we're getting the same result you can see it's a float because we have a decimal this would also work the other way around let me put this on the next line if i print a number like let's use something else 5.1 if i want to convert this 5.1 into an integer i could use the int function or int for integer if i run this i am only getting 5 because remember integers are always 4 numbers we do not have values after decimal so we are losing some data also keep in mind when you are using int you are not rounding the operation you are doing is truncating and truncating means we are getting rid of anything after the decimal point which means if i had 5.9 and run all of this again we are still getting 5. if you wanted to round you would use round and then you were getting 6. it would also return an integer because again we don't have any decimal point now there's one thing that you do want to be really careful about and that is that floating point numbers sometimes can get really weird especially if you combine integers and floating point numbers for example if i print 1.1 times 3 what we would be expecting here is 3.3 however if i run the code we are getting something really weird three point three and then zero a lot and then a three at the end technically this result is wrong it resulted because floating point numbers are kind of weird in computers now that being said in most cases this error here makes absolutely no difference because it's such a small deviation you are never going to notice it but do keep it in mind you generally want to avoid floating point numbers because they can add some arithmetic errors once in a while generally integers are much easier and much cleaner to work with but obviously sometimes you just have to use floating point numbers and then you can just use them they work just fine in basically all circumstances the next data type i want to talk about are strings and this is the one we have seen a lot by now all we're talking here are words and this is something we do have to talk quite a lot about because we are going to use them extensively strings are created either with single or with double quotation marks you could either write word with single quotation marks this one and this one or you could use double quotation marks this one and this one python really doesn't care the only limitation is that you have to stick to the same kind of quotation mark you couldn't add a single quotation mark and then end with a double quotation mark and strings have a ton of methods to manipulate them i guess some examples we have seen are upper is numeric and strip what we haven't seen yet is you can also use strings with math operations for example if you add hello plus world you are combining these two strings we are going to explore that functionality a bit more in this section besides that you can also add values into strings in quite a few different ways the most important concept here that you have to understand are f strings you will see in a second what that means it's basically another kind of method and finally we can also cover how to write over multiple lines and how to add quotation marks inside of a string and that's a ton of stuff to cover so let's have a look at all of this let's start by creating some test variable and in here to create a string we can either use single quotation marks or double quotation marks i guess let's start with single quotation marks let's call it test 1 and then for test variable 2 we can have double quotation marks with test 2. if i run the code now all of this is going to work just fine as a matter of fact if i print testvar1 and testvar2 both of them are going to give the same result python does not care if we use double or single quotation marks the one thing python does care about is that we do not mix quotation marks meaning something like this wouldn't work if i run it we are getting a syntax error undetermined string literal i think the reason here should be quite obvious it would be very strange what i also want to do starting from well now is to comment my code so it's going to be a bit easier to read when you read through it and this section here is about quotes for strings along with that there's one important thing that we do have to cover and that is quotes inside of strings what that means let me create another test variable let's call it testvar3 and let's do an example let's say i have the case that he said and then i want other quotation marks this was great and let me add a bit of white space here so this is easier to understand we are using quotation marks here and here and that way we are creating a string inside of this string though we have another quote and you can already see by the colors here python is not exactly happy about it if i run out of this we are getting an error invalid syntax python just doesn't know what to make of it as far as python is concerned we are starting a string here and we are ending the string here then we are adding some random words and then we are creating another string the reason now where python is confused is because these three words are neither variables nor inbuilt functions so python just doesn't know what to do with them and it gives us an error so how can we get around it and there are two ways of doing this the first one that you are probably going to use the most is to mix the quotation marks now we have single quotation marks to create a string and inside of the string we have double quotation marks to explain that we have a quote this python is completely fine with let me print it actually testvar free if i run this now we are getting he said this was great python has no problem with that and let me remove the white space that should make all of this a bit easier to read while we add it i also want to comment out this stuff here at the top so things are a bit easier to see now if i run this we can see we have quotes inside of a string this would also work the other way around if i start with double quotation marks and end with double quotation marks then inside of here i can add single quotation marks like this run it again and we would also see the result now we have single quotation marks this would be one way to approach this although this system has its limitation for example if i add a test var4 and in here we want to have for whatever reason a single quotation mark a double quotation mark and then a single quotation mark as well and this would just not work python would just get very confused not exactly something you would do all the time but it might come up once every year and then you have a problem to overcome this you need what is called an escape character let me add a comment and escape character an escape character is again a forward slash and this you need in front of every character you want python to just interpret as a string and this you need in front of every character you want python to interpret as a normal character so in my case i want this escape character in front of my double quotation mark and my single quotation mark and now you can see the comment appears as a proper comment if i print it i can see the two quotation marks this way you can literally add any kind of character without disturbing your code as a matter of fact let me rename this to simple escape character because escaped characters can do quite a bit which means i want to add another comment for escape characters what we can do in here let me comment out the earlier part and now i want to have a test var five and for this one i want to print some text over multiple lines let's say i want to have line 1 some text and then i want to have line 2 some more text and i want to tell python that this should be over multiple lines of code for example if you want to build some kind of text editor you want to store all of the text inside of one string but when you present a string you want to have line breaks between them how could you do that i guess let me print the test bar first if i run this we get all of this on one line and to create a line break in here we need once again the forward slash and then the letter n if i run this now we are getting those two lines on well different lines forward slash n tells python that we want to add a line break between these two different parts of the string there are actually quite a few more for example forward slash t is adding a tab inside of your string there's also forward slash r this one adds another kind of line break you don't really have to know the difference here for your purposes work essentially the same forward slash n though is the most common one so that way you can write text over multiple lines besides that let me add multiple lines as a comment here there's another way to write multiple lines and this is one way we have actually already seen what you need here are triple quotation marks something that python by default considers a comment however if you assign this comment here to a variable let's call this one test var six all of a sudden it changes the color and it becomes a string and this string is kind of special because for this one python does respect the white space which means now i can press space end up on another physical line write some more text do the same thing again and then write on another line if i print this test var 6 python is going to preserve all of the line breaks for example what we could be doing in here let me actually copy it that should save some time i could copy something like this in here if i run this now we have the tree we created in one of the very first section of this entire series and this is a much easier way to see what's going on although granted because of the first line here this is a bit difficult to understand but with all of this covered we have quite a bit more understanding about strings now there are two more things that i do want to cover the first one is math and strings and before we start that let me comment out the earlier stuff so it doesn't get confusing what you can do let's call this testvar7 you can add something like one string hello and then plus a world and python when it sees this plus it is just going to combine these two strings if i print test bar 7 now we are getting hello world keep in mind here there's no space between the two because neither hello nor world have any white space one way to add them would be to just add them here and then combine all of these with another plus you can add as many pluses here as you want there's no limit on it this would also work with different types of quotation marks python literally does not care another math operation that we can use let me create a test var eight i can let me write a word like copy i can multiply it for example times ten if i now print the result i get the word copy copied ten times but again i think this concept here should be fairly straightforward let me comment it out and now we come to the most important section of this entire video and that is how to get values into strings and let's do this by example i have a name and in here i have bob and i have an h and let's go i don't know 40. now i want to create another let's call it a greeting string and this greeting string i want to say hello bob you are 40 years old let me add the print statement as well so we can see what's going on i want to have the greeting string and let's run this i can see hello bob you are 40 years old right now the two values are matching we have bob here and bob here and we have 40 here and 40 here but this is only the case because i have written bob if i change this bob to tom and run all of this again we wouldn't see a difference so what i want to do is to somehow get this name variable into here and this h variable into here and python has quite a few ways of achieving that the one people tend to learn first is called format this is just another method this one works by adding curly brackets inside of your string where you want to add a variable in my case i want to replace the name with a curly bracket and the age with another curly bracket and now i can add values into this format this could for example be a one and a two if i run all of this now i can see hello one you are two years old what python has done here is it looked at the first curly brackets and then it looked inside of format and found the first value after that it saw another curly bracket and looked for the second value inside of format and then inserted it into the string granted just adding one and two in this example isn't particularly helpful but what we can do is add variables in here as well like name and age if i run this now we get hello tom you are 40 years old and this now means we can change these variables let's say a hundred and something it really doesn't matter what it is although you do have to be careful about the order if i switch them around with h coming first and then name now we have hello100 you are something years old the order here being wrong messed all of this up which can be kind of annoying especially if you have longer strings where you want to add more variables this can become very confusing and as a consequence python has a way to make all of this more organized you can inside of the curly brackets add something like variable names let me call them one and two and now you can assign one to name and two to the age if i run this now we are getting the same outcome although now we know very specifically which value is being assigned to which curly bracket one gets this one here and two is getting this value here meaning now we're going to sign h to 1 and i guess we could keep h for 2 as well if i run this now we get hello 100 you are 100 years old the reason is we are assigning h to both 1 and 2 which is putting this age into here and into here and that way you can be much more deliberate about where you put the variables that being said very few people use this kind of method because when you look at it it's kind of inefficient why do we have to add a whole method with arguments why couldn't we just add variables straight inside of these curly brackets that would be much better and python developers agree and to achieve that they have created what is called an f string let me create another variable let's call it greeting string better for this one i want to copy this entire string and paste it in here and now i'm going to add the variables i want straight into the curly brackets we have name for hello and h4 years old although now if i print greeting strings better i am getting hello name you are 8 years old python interprets this and this as a simple part of the string which isn't ideal to tell python that these are supposed to be variables we have to add an f at the beginning of the string and that is all we need if i run this now we're getting hello something you are 100 years old and you can see it by the colors the name and the age are not green anymore which in our case means they are not a string anymore although your colors may vary depending on what color scheme you have we can let me return to bob who is 40 years old this is still going to work and this version here is much more readable than this one up here i guess let me fix it this is better but still this one here is very annoying to read whereas this one is really clear and f strings can actually do quite a bit more inside of these curly brackets you could even do basic math operations for example we could add h plus 10 all of this would also still work with that we have covered a lot of stuff for strings and i think this part is getting quite long so let's do an exercise and then finish it off and what i want you guys to do is this one here i want you guys to create an f string that says hello my name is x and my hobby is y x and y should both be separate variables and the second half of the sentence should be on a separate line and by second half i mean and my hobby is y this should be on a separate line when it is being printed pause the video now and try this one yourself let me comment out all of this here so we're not getting confused and now let's go for this step by step first of all i want to start by creating an f string here let me copy it and let's call this the exercise string in here i want hello my name is x my hobby is y since we want x and y to be in separate variables x should be in curly brackets and y should also be in curly brackets and since we want python to interpret these as variables we need an f at the beginning of the string so now we have to tell python the values for x and y let me put x here and y here let's say for x a value we haven't used yet is lisa and i like i don't know programming with that i can print the exercise string and we have hello my name is lisa my hobby is programming this is already covering the first two parts of the exercise next up is the second half of the sentence should be on a separate line and this we could approach in two different ways the first one is we could use an escape character meaning forward slash n and now if i run this we get hello my name is lisa and my hobby is programming on two different lines another way of approaching this let me copy it you could use triple quotation marks so i add two at the beginning and two more at the end now i get rid of the line break and put all of this on separate lines i guess let me call this exercise string two and now print two and we're getting the same result these two lines here and this line here both do practically the same thing although i guess this one is a bit more readable well i guess it's debatable you could choose here whichever you like although be aware the first one is much more common also keep in mind here the variable naming i used capital x and capital y is quite bad this should rather be called name and hobby in this part we are going to learn two more data types lists and tuples both are very similar and both are simply data containers for other data types which means they are storing other kinds of data that's what a container does and they can contain any kind of data this could be a string a number it could also be a boolean other lists and tuple and a lot more there's no limitation on what they can store a tuple would look something like this we are starting with normal brackets and we're also ending with normal brackets and inside of that we have values that are being separated by a comma for example in this case we are starting with an integer and then we're adding a comma then we have a string another comma then we have a boolean value another comma and then we have a tuple inside of this original tuple which python is totally fine with and inside of this tuple we have another string and that is the only value for this tuple so it really doesn't make too much sense i just wanted to illustrate that you can do it besides a tuple we have a list and a list is looking very similar the only difference now is that to create a list we need square brackets but other than that we are still adding values inside like integers strings booleans and other lists and we are separating each value with a comma like here here and here on the surface those two would look identical and you would be kind of correct the two are very similar but there's one incredibly important difference tuples are what is called immutable which just means that they cannot be changed for example you could use something like list append and this would work because list can be changed but a tuple and depending a value would not work because we cannot change a tuple under any circumstance if you really wanted to add a new value to a tuple you would have to create a whole new tuple and combine the old values with a new value which you can do fairly easily but if you are going to do that you could just use a list it would be much easier that being said because of this immutability tuples process a tiny bit faster in python although the difference is so small you are hardly ever going to notice i guess let's have a look at all of this and see how far we get let's get started by creating some lists and a list let me store it in the variable again you are always creating with square brackets and in here you're adding values that are separated by a comma for example you could be adding numbers like 1 2 and 3 you could add floating point values like 4.5 and you could be adding words like let's say word those are the data types we have already seen but any data type would be valid in here now if i print my list we can see the output we have entered into this list it does work pretty seamlessly what you can also do is to use the functions we have already seen for example len is now going to give us the amount of items we have inside of this list which right now is 5. finally you could also use the list with methods and lists do have quite a lot of methods i suppose a simple one would be clear this one removes every value from the list meaning if i print my list after running this method i am getting 5 items from this line here and this line now is going to print an empty list i suppose if you want to look this up in google all you would have to do is look for something like python list methods once again you are going to find a lot of different websites that talk about it the official python documentation this one here is probably the one you want to use and in here let me hide this one we have append extend insert remove and a lot more the one we have just seen was called clear this one is removing all items from a list and it is equivalent to something else what this part here means we are actually going to learn in a couple of minutes it's super useful for now just keep in mind there are a lot of different methods in here that you could be using another easy one would be reverse this one reverses the list let's have a look at this one i suppose we could change clear to reverse and now if i run the code we are getting the entire list in the reverse order compared to this list here just like with words or well with strings the main way you are going to learn the different methods is by just using python and encountering different problems and finding the solutions to them and most of the time the solution is going to involve some kind of method at some point you are going to get used to different methods for a list that being said also you don't need to know all of them by hard i myself completely forgot about reverse until i saw it when i prepared for this video but well with that we have lists and i guess we have functions and we have methods at least in a very basic outline although there's one really important method that i do want to talk about and that one is called append and this one appends a value i think the name makes sense here basically anything you add in here as an argument will be added at the end of the list for example if i added let's say it 10 at the end run all of this now we can see all the way at the end we have this 10. this would be one of the ways you add an item to a list there are quite a few more but this is a really basic one that i just want to cover for now with that we can look at the other kind of container and that is called a tuple and the tuple you let me save it in a variable that i called my tuple you would be creating with brackets and in here again you can add any kind of value you want could be a number could be a floating point number it could be a word or it could be a list as well that itself contains other values let's say 7 8 and 9. let me comment out the earlier stuff and print my tuple and there we go now we can see all the values we have added in here a tuple and a list work in very similar ways at least up to a point because there is a major difference that difference being that tuples cannot be changed under any circumstances this means i couldn't run something like my tuple append and then let's use a 10 again the method we have used up here if i run this line of code we're getting an error that tuple object has no attribute append we also couldn't delete a value and we couldn't reverse the order of this tuple let me demonstrate the reverse one this one here this one also would not work on a tuple most of the time when you are using tuples you generally only want to use tuples when you know you are not going to change the values but most of the time let's say 70 80 you are going to use a list this one is the much more common data type because it is more flexible with that covered we have to cover a really important topic and that is how to pick elements from a tuple or a list what that means is for example i might want to get this floating point value here from the list and then work with it so how could i get this value and for that we need a specific process that in python is called either indexing or slicing the two are very much related let's talk about it actually let me actually go for this a bit more properly to restate the problem we want to pick one element from a list this could also be a tuple they both work in exactly the same way for us to do that we need to cover two important concepts the first one is that python assigns each value in a list on a tuple and index number if this is our list python would give each of these numbers an index the first number is always going to be a zero and then every successive number is going to be plus one of that number meaning the second value is one the third value is two and then so on and a really important point to notice here is that we always start counting from zero not one and this can be a very annoying concept to deal with i think for beginners forgetting about this covers about half of all of your errors just be ready for that but anyway the concept we have for now is that every item inside of a list has an index and this index we can use to pick an element and this works by adding square brackets after the list or tuple in practice this would look something like this right now we have our list and then after the list we have another set of square brackets with an integer and this integer is going to pick one specific index right now the index one which is going to be the second element this one here meaning this operation would return the value 2 and since we are using an index this entire operation is called indexing it works on quite a few data types lists and tuples should be fairly obvious we could also be using it with strings because they are basically another kind of container we can have a look at this one as well however indexing does not work on dictionaries and sets dictionaries work in a slightly different way and sets work in a very different way we are going to see that later on and i guess let's play around with all of this here i am back in my code and i want to comment out the two methods for the tuple and i want to uncomment my list meaning now i have a list and a tuple to work with and i want to just pick some random elements from them i guess we can start with my list and in here i am using square brackets and now i need an integer i'm going to pick 0 just to pick the first element this zero now is going to refer to the first element inside of my list or the one with the index zero if we added a one we will get the next element two three four and so on to show all of this we have to print it again now if i run this we are getting one indeed the value up here if i added it 2 in here and run this again we are getting the integer 3 which is this item here we have 0 1 and 2. all of this would also work with a tuple meaning if i use my tuple this tuple here and now pick let's say the item number 5. run this again we are now getting the list this one here at the end of the tuple because this one is the element with the index five we have zero one two three four and five what we can do now as well is to add another square brackets afterwards because remember what we are getting from this one here is going to return one item from this tuple in this case this list here which means that this operation here stands in for this tuple so when we add the square brackets afterwards these ones here we are basically adding the square brackets after here and then we can take other elements from that if i add a zero in here we should be getting seven my tuple five gets us this list here and then the zero gets us the first element inside of it these operations are fairly common right now i assume they do seem quite confusing but if you play around with them for a while they should become fairly familiar just remember what is getting returned and how you can work with that there's one more thing that you could be doing in here let me duplicate the line i only want to use one indexing operation what you can also do is go in the negative direction for example if i use negative one we are getting the list again what this negative one means is we are always starting at zero and if we go in the positive direction we are basically going to the right however if we are choosing a negative number we are going all the way to the back of the list and then going in the opposite direction meaning this list here would be negative 1 word would be negative 2 and the 1.45 would be negative 3 which means that negative 3 and 4 should have the same result unless i made an error let's try if i enter negative 3 we get 1.45 if i add 4 we are getting word and i just realized i can't count um sorry about that this should be a 3 and this is a 4. talking and writing can be kind of challenging i guess you noticed this one already but now what you should be able to see is if i add a 3 in here we are getting 1.45 and if i add a negative 3 we are also getting 1.45 all right with that we have basically all we need to get started with indexing this is a very simple operation when it comes down to it although this video is getting kind of long so let's do an exercise and then we finish this section and what i want you guys to do let me paste it in here's the exercise we have a long string and of the string i want you guys to pick one word or string and that is hello that is going to be this element here although do notice here that this is a list inside of a list inside of another list so you have to pick elements that are quite a bit nested but if you paid attention so far this should be doable so pause the video now and try this one yourself alrighty let's get started and just to illustrate what is happening here let me save all of this in a separate variable that i'm going to call solution var and this is going to be we always have to start with the exercise list now we need square brackets and we want to pick one item from here with the index we have item number zero we have item number one and we have item number two and item number one covers this entire list here this is what we want meaning in here i want item number one which means if i print the solution variable and comment out all of the stuff above and run all of this now we can see we have the list with one two three four five and then the other list inside and from this we want to get another index now we have let me clean this one up a tiny bit purely inside of this list here we have a few more elements we have 0 we have 1 and then we have 2 2 being this entire thing this is all we want right now which means we now want the index number 2. now if i print my solution i get another list with zero and hello we are getting very close now inside of this final list this list alone here we have two entries we have zero and we have 1 and 1 is our solution which means at the end of this i want to add a 1 and then we should be done so let's try and there we go we get hello obviously you would very rarely see something like this this is very poor data management because it's a very messy list that is really hard to work with but i guess it's a very good exercise this video is going to be part 2 on lists and tuples and this is primarily going to be about picking multiple elements so the main problem we have to cover is how to pick multiple elements from a list let's say we have a list with the numbers one two four and we want to get the second and the third element how could we do that right now we can only pick a single element fortunately python can do this with something that is very similar compared to indexing and that is slicing how this works is you are still going to need square brackets like with indexing but now instead of adding one number you are adding two numbers separated by a colon the first number is the start and the second number is the end value for example it could look something like this for example in here we have the indexes from zero to three one right now is going to refer to this two here and 2 is going to refer to the index number 2 which right now is going to be a 3. this is how we are picking the start and the end value however there is going to be a really important concept you have to understand and that is python only goes up to the end but it does not include it which means in this case we would only get one number we would be starting on this 2 here that is our start value however we are only going up to index number two we are not including it so in practice our list indexing ends here right before our end index as a consequence this operation here is only going to return this two and nothing else that is going to be a fairly common issue but you will get used to it let's practice this one once again here i have a completely empty python file and i want to create a test list and that is the list we have just seen this one has the values one two three and four and just to demonstrate what i've just talked about i want to print my test list and in here i want the values from 1 colon 2. if i now run this i am getting another list with 2. that means that list slicing always returns a list even if there's only a single value inside for example what we could even do is go from index 1 to index 1 which would get us if i run this an empty list and this is something you always have to keep in mind if you want in this case for example the second and the third element you have to go to the index after that in this case this is going to be one two three if i run this now we are getting the numbers 2 and 3. and that for start is all you have to know about slicing although you can do quite a bit more but let's talk about this inside of my slides besides the start and the end value you can also add a third number for the direction by default this one is going to be zero meaning we are always moving plus one in the positive direction it might look something like this we again have the same list and we have our indexes 0 1 2 and 3. and this one here at the end means that we are moving in the positive direction in a step size of 1 which right now will get us the next element but we could have a larger or smaller value you could also have negative values to go into the other direction here we are back in the code and i want to add a few more values to this list so it's a bit easier to visualize what's happening now we have the values from 1 to 10. although if i run this one here it is going to give us the same result but now let's say i want to have the values from 0 to 8. if i run this we are getting the first eight values although now what i can do i can add another set of colons and then for example add a two in here and now if i run this i am only getting every second value so we are starting at the index number zero and we are only ever picking every second value which is the three the five and then the seven and since our last index is going to be here we're not including this 9 anymore and then we're getting the values 1 3 5 and 7 the values down here and this step size can also be negative for example you could in here add a negative one although right now this wouldn't do very much so the issue here is we are starting at this value as our starting point and our end value is eight which i believe is this value here and since we are now moving in this direction there simply isn't any value so this entire operation doesn't give us anything however what we can do is flip those two around so our start value is 8 and our n value is 0. if i now run out of this we get all of these values reversed and negative values you can add actually everywhere in here so for example you could have the start value of negative one and the end value let's say at four this is going to work just like normal indexing this would mean you are starting here all the way at the end that is the negative one and then we're going to the fourth element which is going to be zero one two three and four this one here is index number four so we are expecting to get the numbers from ten to six let's see if that's the case and it is we get numbers from 10 to 6 and that is basically all you have to understand about the basics here although there's one more thing that you can do and that is you can also leave values entirely empty when using slicing this might look something like this this does look a bit strange but it does work what it means is let me talk through it every number in the slicing operation has a default value so we have a start and end and a step value for start the default value is always the very first item inside of the list in the example here it would be a 1. the end value by default is always going to be the last item inside of the list in this case here that would be a 4 and for the step size the default value is a 1 which means we are always moving plus one in the positive direction by default this one should make sense it's quite straightforward and let's play around with all of that let's see how far we get so here we are back in the code and let me actually add all of this inside of a variable let's call it negative slicing i should probably add more variables so it's easier to follow in the notes but let's start working on leaving values empty this i want to save in a variable let me call it default slicing in here as always i need my test list and in here i want to go from my start to the end of the list and i only want to get every second value now the start is going to be easy because this one is always going to be one but you could also leave it completely empty it would have the same result and here we could also leave empty that would get us the very last item inside of a list 10 right now and this is actually really useful because by default we don't know what the last index is going to be finally i want to have every second element this would be a 2 in here and now let me print the default slicing variable let's run this and we're only getting every second value we could also add every third value in here and there we go if you left all three of them empty and run this again you will get all of the numbers so this is looking a bit strange but it certainly is working and this system can be incredibly useful as a consequence let's do an exercise and what i want you guys to do is this exercise here i want you guys to start from 8 and go to 2 and only pick every second element and when i say 8 and 2 i mean actual number not indexes so you want to start at this 8 here and then go to this to here at the end these are the values you are going to cover except only every second element meaning the 7 shouldn't be in here this 5 shouldn't be in here and so on so pause the video now and try to figure this one out let me save all of this inside of a variable and as always we need the test list in here we need square brackets for slicing and now we need a start an end and a step size since we do have to go negative remember we are starting from 8 and we are going to 2 this has to be a negative number let's say negative 1 now just to have a start value while i do this let me show the solution right now what we are going to get is the entire list in reverse although in my case i don't want to start at 10 i want to start at 8 meaning we have to figure out how we can get this 8 here that would be our start value and one mistake you could be making in here is simply add an 8 because this would not work right now we are starting at 9. the problem here is remember when we're using indexing we are starting at zero meaning this is zero one two three four five six seven eight and nine meaning if we are adding the index eight we are adding on the nine here which isn't helpful instead what we could do is add a 7 in here and now if i run this again we are starting at 8. alternatively what you could also do is add a negative 3 in here if i run this one we are also starting at 8. and i guess remember we could also go negatively so this 9 would be negative 1 then we have negative 2 and negative 3 that would be our 7. both would be fine it's really up to you what you prefer i guess the 7 here is a bit more expressive but well it's basically subjective but now we have to find the end value and in here you might be very tempted to pick one for the index let me actually do that if i add a one in here run this again we are ending on three as our final element the reason is that python always only goes up to the final element but it doesn't include it as a consequence three is going to be our final element the way around that one is this should be a zero now our final element is this zero so we're going up to that element but we're not including it so two is our final number the final thing we need is we only want to pick every second element this is quite easy all we need is a negative two if i now run out of this again we get eight six four and two and with that we are done this is basically all you need for slicing and this would also work for a tuple i guess let me demonstrate this one really quick let's call it tuple slicing and then here we have a test pupil and this one would just have the values one two three four five six seven 8 9 and 10 and in here i could for example print test pupil with the values 0 5 and let's say 3 it should be a colon and let me comment out the exercise here and there we go we get 1 and 4. once again a list and a tuple are incredibly similar the only difference is is that a list can be modified whereas a tuple cannot there is one more topic that i want to cover with lists and tuples and that is unpacking basically what that means is both lists and tuples can be unpacked in a way like this we have a and b and we are assigning a tuple to them what this is doing we are taking the first value and assigning it to the first variable a and 10 in this case and the second value gets assigned to the second value and that way you are unpacking a tuple on two variables this would also work with a list you would have the exact same result and let's have a look at all of this in code so for example what we can do i have a variable called a and a variable called b and i want to assign them to the values 10 and 5 inside of a list and this is well all we need if i now print a and print b we are getting an n5 we have unpacked this tuple on these two variables although keep in mind this only works if you have the same number of items as you have variables if for example i added a third item to this tuple let's say a 1. if i run this now we're getting an error that we have too many values to unpack and python expected 2 which we don't have but if you have the same number of variables as you have in the tuple you are good to go and this would also work inside of a list but let me add two more variables let's say c and d and now we have a list with i know 20 and this also works with strings let's say hello if i now print c and i print d we are getting 20 and hello and this you can also make more powerful because when you are creating a tuple you don't actually need brackets for example you can have a list like this or you could create a list like this without the brackets just having values separated by a comma automatically creates a tuple although most of the time when you want to create a tuple it makes more sense to write the brackets because it's clearer what you are doing but you don't actually have to do it now where all of this becomes really interesting is when you combine these two approaches because by doing that you can assign multiple values to multiple variables on a single line of code which is super powerful for example we have the variables a b and c and we are assigning the values 1 hello and 4.5 we have assigned values to three variables inside of a single line of code so let's have a look at this one in practice and then we can do an exercise for example for video game you could have health you could have energy and you could have a weapon and this you could all assign inside of a single line for the health we could have 100 for the energy we could have 50 and for the weapon we could have a sword and now i could print weapon for example and all the way at the end we are getting sword and i hope you see the value of this if you have to assign multiple variables this is really really useful to keep your code a bit more organized and all right this video is going to be a bit shorter we can do the exercise right away and what i want you guys to do is this we have a variable 1 with the value 10 and variable 2 with the value test and i want you guys to switch the values of these two variables meaning value 1 should have the value test and value 2 should have the value 10. so pause the video now and try to figure this one out alright the solution here is actually incredibly simple all you have to do is you want to assign value 1 and value 2 and what you want to assign them to is value 2 and value 1. basically what we're doing now is for value 2 we are assigning it to value 1 and value 1 gets assigned to value 2. this is basically how you would switch around different values across different variables meaning now if i print value one let me run this we are getting test the value the value that used to be in the second variable before we're getting to the next section i want to do a short intermission and this one is strings lists and tuples because those are surprisingly similar all three of them are basically just containers they just happen to have different formats and as a consequence you can move between them very easily and also use indexing on strings let me demonstrate all of this actually i already have two variables a test string and a test list i suppose we can start by turning a string into a list or a tubal the two are very similar we don't really have to worry about the difference here and to convert a string to a list or tuple you have a couple of different ways the first one we can use to test string and then use the method split and this one splits the string at a certain point if you don't specify anything in here and print a result we are using a space to separate the values if you enter a value in here let's say a t and run this again we now separate this wherever we have a t we start at the beginning here and the t in there disappears meaning now in the string this t disappears and we have an empty string at the beginning of the list then we have all of this stuff here up to the next t which is his is a and then a space then we have the next t here and this one then gets us to the next point the e s bit this one here and then finally we have another t and this one disappears and we are just left with an empty string most of the time you are just going to use the space here this one does make a whole lot more sense another thing you could do is to use the list function and this one turns any kind of data type into some kind of list or at least it tries to it doesn't work with every data type but a string definitely does work if i run this we are now turning every single character into one element inside of a list this would also work with a tuple this is another function here we can add test string once again and now we have the same thing except now it's a tuple instead of a list the other way also works just fine we can turn a list or a tuple into a string although the process here can be a bit weird basically what you would be doing is you first get a string and right now i'm going to leave it empty intentionally then i need a dot and then i need a specific method and this method is called join and into this method as an argument i have to pass in some kind of list and as an argument here we are going to need a list or a tuple although it has to be a special kind of tuple because this one has to contain some kind of string let's say one and two just to keep it simple and now for run this these two elements here have been merged together what we are specifying inside of the string is going to be what determines the gap between the two right now it's empty so there's no gap between 1 and 2. i guess i could just add the gap in here if i run this now we get one gap two if we added more values in here let's say three and four we would always have a gap between each of these values most of the time you are just going to leave it empty and now you have one space between the values what you really have to be careful here though is that all of these values have to be a string i guess let me copy it and replace this with the test list we have up here if i run this now we are getting an error that python has a type error sequence item 0 expected is string instance in found which is python's way of saying it wanted a word or a string but it found a number and it's really not happy about it finally what you can do is to let me print it again you can use the str function and pass in a list in here to turn this list into a string if i run this now we are getting what looks like a list but this is actually a word or a string to demonstrate this let me put all of this inside of the type function if i run this now we get class string this one here is going to be a string it just looks like a list but i hope you get the idea one more thing really quick and that is indexing on strings this one works like it would work for a list for example i could have my test string and in here i want the first element which right now should be a t if i print all of this i am indeed getting a t just like with a list in the string the first element is going to be 0 then we have 1 2 3 and so on you could even use slicing here and for example at the 5 and now we're getting this the first word and i think it is quite valuable here to compare these two data types because when you think about words they really are just containers for individual characters and for python it made a lot of sense to make these interchangeable with a list or a tuple because well it does make kind of sense one of the major operations you are going to do as a programmer is to work between different data types so understanding how you can change one data type to another data type is a really valuable experience but okay there's one exercise i do want you guys to do and that is going to be connected to this operation here let me copy it and add an exercise here at the end what i want you guys to do on this string test list i want you guys to use string methods to remove all of the stuff so you only get one two three and four let me comment out all of the other parts to see what we get right now we're getting square brackets then 1 comma 2 comma 3 comma 4 and square brackets again and i only want to have 1 2 3 and 4. try to use some methods to get rid of all of the other values besides the numbers and see how far you get to make this a bit easier let me save the result in a separate variable let's call it exercise this is also what i want to print right now we have to get rid of a couple of different things let's start with the square brackets for those we need the method we have already seen much earlier called strip and this one we want to start with one of the square brackets doesn't really matter which one you start with if i run this now we got rid of one square bracket and remember we can combine different methods meaning i can call strip again and now add the other square brackets the closing one we now have all the numbers and the commas in between them and to get rid of the commas we want to replace them meaning i want to target my comma and then replace it with an empty string so nothing now if we run this we are only getting the numbers 1 2 3 and 4 and we are done if you wanted to you could even get rid of the spaces here as well and this you would achieve with another replace method and now i want to target the empty space and replace this with nothing now if i run this we have all of the numbers right next to each other whichever you prefer at this point this is hopefully at least manageable the next important data type is a dictionary and this one is a more complex container but still just a container for other variables this one always has a key and a value pair the example 4 that i have is this one in here we have a key and we have a value the key right now is an integer the one but it could also be any other data type python is fairly flexible here and then we have a value this one here a list but again it could also be any other data type what you ultimately have to understand about dictionaries is that they are a container but a more organized one where every value has a key associated and you would use the key to access the value that way you wouldn't go by indexing you would instead have specific values we're going to cover that in more detail later on but let's start playing around with that let me start by creating a test dictionary and a dictionary you always create with curly brackets and inside of the curly brackets you need a key then a colon and then a value both of those have to be valid python data types for example for the key let me call it capital a and the value could just be an integer let's say one two three this would now be one key value pair if you want to add a second one you would add a comma and then the second key value pair let's say i want to call this one b and now i need a colon again and for the value now i want a list with the values i guess one two and three again i guess let me print this one so we can see the result if i run this we can see we have a dictionary with two key value pairs right now the key is always a string but this doesn't have to be the case you could also use a number like 1 and then give it the value of i guess we haven't used the boolean yet so i can just add true in here if i now run this we get another key value pair the one limitation you do want to be aware of here is you cannot duplicate keys for example if i added another a with i don't know let's say another value and if i now run this this first value has disappeared the reason being that once we add the same key we are overwriting the original key value pair although most of the time that really isn't an issue you are too concerned about and once again you also have a ton of methods you could be using for dictionaries to go through all of them here is w3schools with a list of all of the methods you have available some that you are going to use fairly often are values keys and items this one here because those return specific parts of the dictionary let's play around with a couple actually right now if i run this we are getting the entire dictionary but if i add another method here and add values don't forget the brackets run this again now i am getting some kind of list looking thing with just the values from this dictionary keep in mind this is a different kind of data type if i put this into the type function run this again we're getting class dictionary values this is a completely separate data type in and of itself although you don't have to worry about it too much there are specific use cases for it and they all work basically automatically and you never think about the data type here the other method would be keys and this one gives you all of the keys again in the dig keys data type finally what we could also be looking at is items and this one is going to return the list but now it has two builds inside and those we could also access we are going to learn how this works later on and if you go for the list of the different methods this one should be fairly straightforward besides that you can also use once again the lan method is incredibly versatile in here we can add the test dictionary and we would get three meaning we have three key value pairs inside of this dictionary we have one two and three and that's kind of it for the basics of a dictionary it really isn't that complicated i guess let me add a comment here at the top for basics of a dictionary one topic i do want to cover really quick is converting a dictionary for example what we could be doing i guess let me print the results straight away i could get my test dictionary and convert it to a list for example if i run this we are now getting an actual list with all of the keys meaning the list contains a b and 1. something you really want to keep in mind when you are converting the data type here tuple would result in the very same outcome i guess finally you could also convert all of this to a string and then you would get the entire dictionary as a string probably not the most useful thing you could do but well you can do it i do want to cover one more important thing and that is indexing with dictionaries and here we have a problem because indexing the way we have learned it so far does not work and i think this makes sense if you have a dictionary like that and you want to add some kind of indexing operation at the end let's say with the number zero this to python would be kind of confusing this could for python mean you want to have the first item inside of the index or it could mean you are supposed to look for a key with the value 0. in this dictionary this doesn't exist but python doesn't know it when it sees this number here as a consequence the normal indexing does not work but there is another way actually there are two other ways you would do something like this instead of an integer you would add the name of the key in this case we have square brackets with an a and the a refers to this key here what is then being returned is the value associated with the key which is the one another way of doing this is the method get this one works in the same way you are passing in a key this key looks for a specific key value pair in the dictionary and we are getting the value associated returned back in my code i want to print test dictionary and now i want to get the value for capital a if i run this now we get 1 2 3 which is the value we have gotten all the way up here along the same lines instead of using square brackets you could use the method get and in here pass in the key you are looking for and you will get the value associated with it one two three again you may be wondering now what is the difference between these two approaches and generally get is slightly better because if you're looking for a key that doesn't exist let's say x in this case if you use square brackets you are going to get an error meaning your entire code is going to crash which usually is not a good sign but if you use the get method you don't get an error instead you get none returned which means let me add comments doesn't crash when it cannot find a key and i guess the comment here would be does crash when it doesn't find the key or e besides that the two approaches are pretty much identical and with that we have covered all of the basic things for this part so let's do an exercise what i want you guys to do is to do some research and look up the update method for a dictionary and via this method add another key value pair to this dictionary once again i am on a website that looks at all of the different methods that we could be using with a dictionary and the one we want to look for right now is called update if i click on it we have an example a definition syntax and quite a few different things that we could be doing usually what i'm looking at is the example in here we have one dictionary and then we're using the update method and we are passing in as an argument in another dictionary and this dictionary has a key and a value pair and this is going to insert all of this into the other dictionary so let's have a look at this i want to get my test dictionary and i want to use the update method and what we have seen so far is to insert another dictionary and in here we can just add some values let's say i want another key that's not how you spell that then a colon and then some other values i guess what we haven't used yet is a tuple with i don't know some other values in here if i run this we're not going to see any difference because we are not printing our new dictionary meaning now if i print my task dictionary i can now see another key and one two three at the end although you could be using this method in another way as well let me get rid of the argument we had so far and what you could be doing as well is specify some kind of name for a key in my case c and then specify a value let's say let me call it test if i run this now we get a string c and then test as another value and you could even add multiple values in here let's say d is going to be i know one two three it doesn't really matter and with that we have well another value i suppose while we are here there's one more way to add a value inside of a dictionary or a key value pair to be more specific and that is by using test dictionary and then using brackets and specifying a new key here this is very similar to using the key here except now we are creating a whole new key value pair a value we haven't used yet would be e and now you can just assign a new value to it let's say a hundred if i now run this we have all the way at the end the key e with the value 100 the thing we have specified here and that is basically all you have to know about dictionaries it really is a fairly simple data type but one that gives a lot of order to your code the final major data type is a set and these are also simple containers just like the other containers we have seen but this one is kind of different and special in some way it would look like this we still have curly brackets like in the dictionary at the start and at the end and inside we have values separated by a comma so far all of this is really straightforward the only difference compared to dictionary is we don't have keys we just have values where a set becomes unique is that every single value inside of a set has to be unique and any kind of duplicate will be deleted once more i have a completely empty python file and i want to create a variable let's call it my set and here i need curly brackets and inside of those i want to have some values i want to have separated by commas once i have that i can print this variable run the code and we can see we have some kind of set you know it's a set because we have values surrounded by curly brackets without any kind of keys if they had keys it would be a dictionary the one crucial thing you have to understand is that if i have a duplicate value in here let's say i have two fours if i run this again the second four is going to disappear because every value in here has to be unique and python is going to get rid of any value that is duplicated let's say duplicate values will be exterminated all right but other than that we can do quite a few normal things with a set for example we could print the len of my set that is not a bracket let's run this now and we know this set has a length of 4 because we have 4 elements inside of it because we get rid of the duplicate values what you can also do is to use methods and sets do have quite a few one that is fairly popular is you can add another value and in here you just add as an argument the value you want to add and if you run out of this now we have a 5 added at the end of the set along the same lines you can also remove a value and let's say i want to remove the 2 in here if i run this now we don't have a 2 in the set anymore for the full list of all the methods you have available let's use a different website this time i'm using a website called geeksforgeeks this one is also quite good for python and i do want you guys to get used to looking at different websites they all do very similar things but slightly different so it is a really good idea to understand different ones all i really did was i typed python set methods into google and there we have w3schools we have programmers we have geeks for geeks and we have the python documentation these are the four that usually come up in google that tell you all you need to know about specific parts of python in here if you scroll down you have a whole list of all the methods you could be using the one you have just seen was add and this one adds another value and in here well you have a lot of different stuff you can work with and the list really isn't that long it should be fairly easy to work with now there's one thing that is quite limiting for sets and that is that indexing and slicing does not work i guess let me put these two print statements at the top and now i want to print my set and then the one with the index 0. if i run this we are getting an error and the type error we are getting is set object is not subscriptable which is a pythonic way of saying that you cannot use indexing for a set as a matter of fact there actually isn't a really easy way to pick one element from a set the one that gets closest to it is to use the pop method let me comment this one out and instead i want to have my set and then use the pop method if i run the code now we are getting a 1 or the first item inside of the set however what this one is doing if i print this set after this operation the one has now disappeared the reason being that this pop takes the first item from the set returns it and then removes it from the set if you call this multiple times at some point your set is going to run out of items which again very often is not what you want to do sets are not designed for indexing or generate to pick items from them the actual use case is something entirely different i'll cover that in a second but first of all we could actually do a really interesting exercise just in the middle of this and the exercise i want you guys to try is to use type conversion to get one item from the set by index basically what that means is you should try to convert this set into another data type and then on this data type get the index the main thing i want you guys to take away from this is that you can very easily change the data type of something in python and then use different methods or different operations so see if you can figure this one out we know that we cannot take the index of a set this one just doesn't work however what we can do is get the index of a list so what i can do is convert my set to a list and then from this list i want to take the index meaning if i run this now this one is going to work i get the first index i could get the index at one or any other index this is now going to be a list that we can work with if i remove the indexing and show the entire thing that we are getting is well it's just a list that came from the set and this is also nondestructible we are just doing this for this one print statement outside of it the set is going to remain a set we are not changing the entire variable just for this one line we are changing the data type for a very specific purpose which is what you are going to do very often as a programmer meaning this is something you definitely want to get used to and that way you would select different values from a set although that really isn't the idea of a set but i guess let's talk about what the actual purpose of a set is in python and what they are supposed to do is being used for comparison operators sets are incredibly good at that there are a lot of ways to check if two sets have values in common or if they have different values for example what we could be doing is set one and check if there's a union with a set two and that way we are getting all of the shared elements another way we'll be looking at the intersection between two elements and now we only get the values that are present in both data sets there are actually quite a few more let's go through a couple of them let me add another comment for another section and let's call this comparison operators and in here to keep things a bit cleaner i want to have two more sets set one and set two that do share some values and everything else i want to comment out so we are not going to get confused what you can do for example the one we have seen already i can print set 1 and then union and set 2. if i run this now we essentially merged these two sets i suppose an operation that is a bit easier to see in terms of what's going on is the intersection method if i run this one we are now only getting 4 because 4 is the only value that is shared with set 1 and set 2. any other value disappears because they are not shared by the two sets a really good way to think about it is to use venn diagrams this one is set one this one is set to and let me draw two circles and set two would be the other circle what intersection is doing this one here is it only finds the shared values between the two union got all of the values and the third operation we could go we can have set one and the one here is difference again i want to check with set two and this looks like a typo difference this fits better let's run this now and there we go now we only get the values one two and three these three here we are getting this area here now where we only get the values that are not present in set 2 which specifically here means that 4 is disappearing and those are the main comparison operators that being said there are a few more there's a different way to use these methods and those are going to look slightly weird for the union instead of writing union we could do set one then i think this is called a pipe operator and then set two let me comment out the other two lines so we're not getting confused if i run this now we get the exact same outcome along the same lines in this section we could replace with the and character so set one and set two if i run these two i am getting four we are only getting the values shared by both sets and finally difference we could access with set one minus set two and if i run this we are again getting the same values this one may look weird but it actually makes a lot of sense we are basically taking set one and we are subtracting all of the values from set 2. if they exist they are going to remove the value for in this case if they don't we're just going to ignore them now that being said these operators or sets in general you are not going to see all that often they are very rarely used list tuples and dictionaries are the really common one and sets you only really use when you do some more data oriented stuff all right now with that we are nearly done i just want you guys to do an exercise and for the exercise i have a long list i'm not even sure how many numbers are in here but there are a lot and what i want you guys to do is to use a set to figure out if this list has duplicate values try to figure this one out yourself it's a really common operation that is incredibly useful i have added a comment to explain what the exercise is going to be but it actually isn't all that difficult the function you want to use here is len and right now if i pass the list in here i know we have 34 items in there in total let me comment out the earlier stuff so we're not getting confused we have 34 items inside of this list how we can use this is we know if we are creating a set so i want to create a set from this test list since a set cannot have any duplicate values if the length of this set is shorter than the length of this original list then we know there are going to be duplicates inside of this list which means if i run the lan method on this run both we are getting 26 which means we have quite a few duplicate values in the original list if you want to do this a bit more fancy you could also do i guess let me put this on a separate line you could print len of the test list then the comparison operator i don't think we have seen this one yet but this checks if two values are equal to each other and then we have len of the set of the test list and if i run this now we are getting false and if this is false we know there are duplicate values with that we have all the important stuff for a set although keep in mind sets are fairly rare in python you would only really use them when you run something that requires a lot of data work like running a database or doing data analysis for anything else like making a gui or making games they really aren't used that often so don't worry too much about them for now when you actually need them you can learn about them in more detail the next incredibly important data type is a boolean all a boolean is is either true or false and usually we are creating booleans with comparison operators for example if we are running something like 5 smaller than 10 we are getting the boolean value true and this is incredibly useful to control the flow of our code something we are going to talk about a lot in the next section for example if a condition is true then you want to do something and booleans can be created in a lot of different ways the one way we have seen already is we're using either integers or floats and then we use comparison operators we can also use some string methods like is num to check if there's a number inside of a string i think we have seen is alpha to check if there are only letters inside of a string another way is we can check if there are values inside of a list instead of tuples or a set or a dictionary this would also work we could also compare different sets to create booleans and finally we can also create booleans by themselves although that's something you really aren't going to do too often i guess let's go through this entire list and we're going to start with comparison operators and there are quite a few the one we have just used in the last part is the equal sign so we are checking if two values are equal with two equal signs and we are using two because a single equal sign is reserved to assign a data type to a variable meaning we couldn't use it and to check if two numbers are not equal we have the exclamation mark equal and that checks if two numbers are different and finally we have smaller or smaller equal to check if something is smaller than or smaller or equal than and greater and greater equal would work in the same way those are the main comparison operators in my code let me start by printing and i want to print if 1 is equal to 1. if i run this we are getting true if i use a different number let's say 10 run out of this again i am getting false because 1 is different from 10 this should be quite obvious the next operator would be exclamation mark equal and let me add comments is not equal whereas the double equal sign looks for is equal if i run those two we get false and true false here because those two are not equal and we get true from this operation because they are indeed different i suppose a better way of writing the comment here would be true if is equal or is not equal or besides not equal is different we can also print if 1 is smaller than 10 and this one gives us the obvious result because 1 is indeed smaller than 10 and we could also use smaller or equal than and this one in this case would also be true i guess where this one matters if we have a 10 smaller equal here is going to be true but 10 is not going to be smaller than 10 meaning this operation would return false this also works with greater than again this would be false because 10 is not greater than 10. and those are all the major comparison operators for integers for the next part we could look at lists and booleans and in here we can check if a value is in a list or if a value is not in the list and this by the way also works with strings an important point here is that not reverses a boolean if we have not false it is going to be true if we have not true it is going to be false python here works very similar compared to what you would use in a sentence and i am trying to be better with comments let's do this booleans and numbers i think it's a good name here next up we have booleans and lists and strings what you could do for example here is you could check if one is in the list one two and three if i run this we're getting true because one is indeed in the list of one two and three let me comment out this part here so we're not getting confused and run this again now we are only getting true and this is also going to work with different data types if i for example had a tuple and run this again we would have the very same outcome if i duplicate all of this i can also check if e is in the word hello and run this again and we will be getting true again because e is indeed in the word hello finally what you can also do is to use the not operator for example you could be checking if 4 is not in the list of 1 2 and 3. if i run this one now we're getting true again because 4 is indeed not in this list generally not reverses all of these operations i could for example uncomment this print 10 is greater than 10 and this one let me keep it the only one without a comment if i just had this one line by default this one is going to be false but if i put a not in front of it and run this again we are now getting true not reverses any kind of boolean so if you have not true you are going to get false you can actually do this by itself let me add another comment and let's call it booleans by themselves and comment out everything else what you could do you could just create a boolean by just writing true or false if you wanted to and this one would get you true which is its own data type and if you write not true you would get false this i think is going to make sense and i guess while we are here we can do another data conversion exercise so data conversion exercise and what i want you guys to do here are the notes i have an e and this one contains three key value pairs it's always the integer of a number and then the word of the number as well although honestly it really doesn't matter what the specific value here is and i want you guys to do two things number one check if one of these keys exists specifically if this key one exists just assume you don't know what's inside of the dictionary and you want to check if this key exists in the first place and number two i want you guys to check if the value not the key the value for exists inside of the dictionary and again assume you don't know the actual content of the dictionary so try to figure out these two problems the first problem i guess let me put it right below is the easier one we want to check for a specific key and in here we can use the same thing we have used up here it works in the same way i can just check if one exists inside of the edictionary and let me comment out this print statement down here so we're not getting confused if i run this now we're getting true because we can see it right here this one does exist inside of the dictionary as a key if you want to be more specific about it you could also use the method dot keys and you would get the same result this edict.keys would now return something that looks like a list with only the keys inside of it although this is what you get by default anyway so you don't really have to use it the second part is we want to check if the value 4 is in the e dictionary although this right now is not going to work because this edict is checking for keys not for values which wouldn't help us all that much to access the values we would need the values method the one we learned about earlier and now we're getting something that is basically a list and it only contains all of the values of the dictionary if i run this now we're getting false because we know this 4 does not exist as a value inside of this e dictionary although if we had a 3 this one would be true so we know it is working all right with that there's one more really important topic i want to cover and that is the bool function let's talk about this one bool is a function that creates a boolean data type and this one can accept basically any kind of other data type it's really flexible here we could pass a number a string any type of container and we would still get a value as a matter of fact bool accepts so many different values that are actually different rules that determine how the values are going to be converted and just think about the problem here you have some really complex data set let's say a really long word and you pass this into the boolean function to ever get true or false how is python going to determine what values count is true and what values count as false and the logic here is actually so common that python has dedicated words for it we have the words truthy and fault c truffy means all the values that will be converted to true and false c is all the values that will be converted to false the way you have to think about it is that some values will always be converted to false and those are fairly specific and anything else will always be true and faulty values are 0 or 0.0 so integers or floats that have the value 0 any positive or negative number will become true any kind of empty string so a string without any content not even a space any kind of empty list tuple set or dictionary is also going to become false and finally none so the absence of a value and literally any other value is going to become true meaning you don't actually have to learn that much now this is something we definitely want to play around with so let's have a look at all of this in code let me comment out all of the stuff we have written earlier so things are not getting confusing right the bull function is another function that creates a boolean data type and i do want to print the result we could for example add in a number any kind of number and we will get true what python basically does is it looks at a number and then determines if the value is truthy or falsey if it is truthy we get true if it is falsy we're getting false and what i talked about just now is that any number besides zero will be true this one here indeed has become true this would also work with negative numbers let's say negative one is also true the only time a number becomes false is when you have zero this one is false or 0.0 this one is also false as soon as you have any other value besides zero let's say zero point a lot of zeros and one you are getting true again but if you have any floating point with just zeros it is going to be false and this was the first rule besides that for strings if you have any kind of word even if it's just a space it is going to be true however if you have an empty string this one is going to be false finally if you have an empty list this one is also going to be false but if you have any kind of value inside it is going to be true the way you want to think about it is that if any kind of data type has an actual value then it is going to be converted to true if it doesn't have any content it is going to be false there's one more data type we haven't really covered yet in detail and that is the absence of a value so none and this by itself is also data type in python and this one obviously is also going to become false i think this one makes sense we are actually going to talk about this in just a second in a bit more detail but it's not something you have to worry about too much but well with that we have boolean data types that's kind of all you need to know and in the next section we are going to use this a lot more before we are finishing off this entire section i want to cover some other data types because python does have a lot what we have seen so far is that python is really flexible with data types sometimes data is even converted automatically like with integers and floating point numbers but other than that we also have functions to change data types and this is the entire list for the major data types you would most of the time actually need and these are very forgiving python here again is super flexible now besides those we do have a couple of data types you see once in a while but not very often or in other words data types you don't specifically use the most common one here is none or the absence of a value this could for example happen if a certain kind of value got deleted or if you didn't get value from some kind of input field but besides that we also have a sequence like a range of numbers bytes complex numbers memory view frozen sets lots of really specific data types that you sometimes see in very specific circumstances you usually have to look them up and they are very rare so i am not going to cover them i will however cover later on none and sequence those you do see reasonably often but values like bytes complex numbers memory view frozen sets you would only ever use in highly specific circumstances and i'm not going to cover them because we don't really need them almost the entire time you are going to be perfectly happy with these data types here and they are what i am going to focus on so right with that we can come to the next major section and welcome back in this section we are going to work with the flow of our code now what does that mean basically so far we always executed code from the start to the finish meaning if these are different lines of code we are starting all the way at the top and we are going down line by line which works fine by itself but it is fairly limiting because sometimes we want to do something else for example we might only want to run code if a certain condition is true or we might want to run code multiple times or we might want to run code for every item inside of a list or a tuple or something like that and all of these things can be done quite easily python has a lot of ways to control the flow of your code although to understand how it is going to work we need to understand one really important concept and that is how python groups chunks of code together you're going to see in a second why that is important but the way python groups code together is by using indentation let's say we only want to run some code if the condition is true and this white line here is the left side of our code editor just to better illustrate how we are using indentation the basic problem we have now is if we have code below this condition how do we tell python that it belongs to the condition and isn't something that's independent of the condition for that we need indentation anything that is indented by one indentation after this line belongs to this if condition meaning these three lines here all belong to this if condition i think i actually added a bit more text here yeah there we go indentation determines where the code belongs to if we added some other code in here like line three and line four those would be independent of each other they would run no matter what happens whereas line 1 line 2 and line 3 would only run if this condition is true if it was false then none of this would be run but line 4 and line 5 would still run meaning lines that are not indented do not belong to that if statement i hope this makes sense once you understand the system it makes a lot of sense and indentations indentations in general and python are incredibly important you are going to see them all the time but first of all once we understand indentation there are four major ways to determine the flow of the code the first one is if l if and else these are different kind of if conditions to run code if certain conditions are true we are going to talk about this one in the next part besides that we have match this one is kind of like if but it's more designed for specific value to find one very specific condition then we have while and this one just repeats code as long as the certain condition is true and finally we have four and this one is about running some code for every item inside of a container let's say you have a list with one two and three and you want to run some code for every item inside of the list a for loop for that would be perfect and those are the four major concepts that we are going to learn there are also a few more extra tools you can use like breaking a certain kind of statement or skipping to a next part in a while loop i will talk about those at the appropriate point so i guess with that let's start with the first major part possibly the most important concept to determine the flow of your code is the if statement all this one does is it tells python to only run some code if a certain condition is true note here we are always looking for a boolean value they are crucial to make all of this work and an if statement can also be extended with l if and else and you can also add different conditions together we're gonna cover all of this in quite a bit more detail over the next two videos let's have a look at all of this in code let's do a super quick recap of boolean values all i really do is if i have something like 10 is greater than 5 i print it i'm getting true because this condition is indeed true and if i do the other way around that 10 is smaller than 5 this would get me false because this condition is not correct and these boolean values we can now use to control the flow of our code for example we could run some code if a value in a variable is greater than let's say 10. for that let me first of all create a variable let me call it x and let's start with five and now i want to run some code only if this value is greater than 10. and for that i would need the word if and then the condition i want to check which in my case is x is greater than 10. after that i need a colon and now if i press enter sublime is very intelligent here and already creates one level of indentation so we are here if i write some code and this is really important let me write some code here actually let's say print the if statement was true because of this indentation we know that this print statement belongs to this if statement here if i execute all of this we can see nothing the reason why we can't see anything is that this condition here was not true 5 is not greater than 10 but if i change this 5 to a 15 run all of this again now we can see this print statement here the main thing that you have to understand here is this condition if it becomes true then we are running all the indented parts below the if statement and if it is false we're not running any of the indented parts this would also work over multiple lines of code i could for example print another line if i run this again we get another line as well i could also create another variable in here let me call it y is equal to 10 and i could print y all of this works just fine we can write any kind of code in here as long as it's indented it always belongs to this if statement however if i write now some other line of code after the if statement that is not indented let me call it some other code this one is always going to run regardless of what the if statement does because it's not indented if i run the entire code right now we can see some other code the line we get here and if i return x back to 5 run this again we now can still see some other code because this line is not affected by the if statement because again of the indentation indentation is really important to python you absolutely have to understand it although that being said this is the core part of an if statement it really isn't that complex although you can extend the logic here in two different ways a very easy one would be an else statement this one again is going to need a colon and now if i press enter again we have another indentation and in here i can write the code that was run if the statement was false how does this work basically this else statement always has to be connected to an if statement and what it does is if this condition here is false then we are not running any of this but we are running anything inside of the else statement since x is 5 this condition is going to be false meaning none of this will run but this one here should be run and this line is going to run no matter what happens so if i run the code i should be seeing the output of this line and of this line let's try it and there indeed we can see these two lines and there's one more thing that you can do and that is called an l if statement and again this elf statement has to be connected to an if statement basically what it means is shorthand for else if it's kind of similar to the else statement except now we are adding a condition which means if this condition here is false then we want to run this statement here but we only want to run this one if another condition is true and this condition is just going to be another boolean value let's say i want to check x again and i want to check if x is different from 0. if that is the case i once more need some indented code and for this one let me print the l if statement was correct and now we have a much more complex if statement we first check if this condition here is true which in our case right now is going to be false because 5 is smaller than 10 meaning this would be a false statement then we are coming to the al if statement and now we are checking if let me use a different color if x is different from zero and since five is different from zero this one is going to be true as a consequence we are going to run or expect this code here to be run let me add it properly here so we can see what's inside of the line and once any of these lf statement has run we are stopping this if statement meaning this else statement here would not be run at all and once again this print statement here is going to be happy either way because it does not care what happens in this entire thing let's try all of this now and we can see the al if statement was correct which is this line here and then we have some other code this bit here i suppose we could be doing another example and now let me add a zero in here and i would really recommend you to go over this one yourself and see which line you would expect to run here once again we are starting at the first line and we know 0 greater than 10 is going to be false that can never be true next up we are looking at x being different from 0 which in this case is also going to be false which means at the end we are left with this else statement which means the code we are expecting is the code that was run in the if statement was false and we're also expecting this one at the end although that's getting repetitive let me run the code now and we get the code that was run if the if statement was false and some other code with that we have all the basics for an if statement if you understand if l if and else you already understand what you need i guess one more thing that i haven't covered yet is if and else can only occur once inside of this if statement but l if you can multiply as many times as you want for example i could add x is greater than negative 20 for example and then add something else i know print something else and you could add as many if statements as you want or as you need but else and if can only occur once although what you could be doing is add another if statement afterwards i guess we could add if one in the list one two and three and then we want to print another if statement when i said an if statement or an else statement can only occur once i was always referring to this block here where we are starting with an if and inside of that we can only have one else we couldn't have a second else however python is totally happy to have a completely separate if statement but with that we can do an exercise and what i want you guys to do is this one here we have one variable that determines how much money we have and from this amount of money i want you guys to figure out what we are going to eat if we have greater or equal than 80 units of money i want you guys to print eat something fancy if the money is greater than 45 eat something nice if it is greater than 15 eat something okay and else eat something cheap and obviously there should only ever be one print statement running at any point in time so pause the video now and try this one yourself before we start i want to comment out all of this because it would otherwise get kind of confusing first of all we need an if statement and now i want to check the money available and i want to work on the first line here and what we are being asked to do is greater or equal than 80 which we get with greater or equal and we want to check for 80. if you want a reminder on boolean values check out the last section on boolean data types this is going to be really important for this entire section but in here i now need a colon and now i want to print eat something fancy i guess let's add an exclamation mark because why not the really important part here this print statement has to be indented but with that we have covered the first line of the exercise next up we want to check if the money is greater than 45 which means we want to first check if the money is greater than 80 but if that is not the case and the money is still greater than 45 we want to do something else which means we need an l if statement else because we want something else in the if statement and if because we have another condition what i want to check in here if the money available is greater than 45 after that again i need a colon i need an indented line and now i want to print eat something nice and with that we have covered this line here next up we have a very similar line meaning now we again need l if and what i want to check now if the money available is greater than 15. if that is the case this is getting a bit repetitive i want to print it something okay that covers this line and finally we have an else statement that if all of these conditions are false we want to do something else anything else we want to do is to print eat something cheap and there we go this is going to cover all of the four if statements if i run this now we get each something fancy because the first if statement this one here is true however if i change this 100 to let's say 50 we get eat something nice if i change it to 20 we get eat something okay and if i change it to 5 we get eat something cheap and with that we have basic if statements now that we have learned about basic if statements we can work on the more complex ones because if statements can be extended number one is you can combine different conditions inside of one if statement on the same line and number two is you can nest one if statement inside of another if statement which lets you create really complex systems that check different values let's start with combining conditions and in here the two keywords we need are and and or kind of confusing to say but you get the idea how this would look like is we have if 5 is smaller than 1 and e in hello or 10 is different from 4. this may look confusing but let's go through it one by one to understand how this works we have to understand and and or and means that all the parts have to be true meaning when we are talking about this and here this bit in particular both of these conditions five is more than one and e and hello have to be true individually for this entire statement here to return true as a whole whereas or works in the opposite way where only one or a statement has to be true which means if this or statement here is true then it wouldn't matter if all of this is false because as long as one or statement is true then the entire if statement is going to return true as a whole and this is probably going to sound very confusing so let's do this a bit more practically let's do this actually in the simplest possible way let's say i have if true and i want to print true this if statement here really doesn't make too much sense but to illustrate the point it's really useful but since we're adding the boolean value true in this if statement this is always going to run meaning if i execute the code we are getting true and now what we can do is use and in here and if i add false now and run this again nothing is going to happen this line will not be executed because of and both the first one this one here and the second one have to be true for this entire condition to be true as a whole which there aren't right now but if it was true then this would run again the way you have to think about and is i'm only going to run this if statement if this is true and this is true and anything else is true and if any single statement is false then the entire thing is not going to be run i hope that makes sense it does take some time to get used to it let me go back to false and the other word we can use is or now we want to run this line of code if this is true or this is true meaning if either of these is true then the entire if statement is going to run if i run this now this is going to be true because for or only one of them has to be true and once you get so far you can combine and and or for example what i can do is true and true and true or true now this would obviously return true as a whole because we only have true values in here but now if i set this to false this would still run and the reason is let me add a bit of white space around it so i have more space to draw on i am assuming that this is kind of confusing right now still python essentially combines all of the n statements into one block inside of the if statement and this entire block can either be true or false for and every single value has to be true and if a single value is false then the entire thing is going to be false in our case since there is one fault statement the entire block here is going to be false once we have that python is looking at the or statement this bit here and as a consequence of this we now have false from all of the and statements and then we are checking false or true and if either of these are true then the entire if statement is going to be true which in this case it is just to make sure let's do one exercise for this one already and what i want you guys to do is here we have three variables and the exercise is going to be fairly similar compared to what we have done in the last video what you should be working on is another if statement that checks if the money available is greater than 80 and if you are hungry if those two conditions are true print eat something fancy or whatever you want however this should also run if board is true and for that to work you have to combine end and or statements so pause the video now and try to figure this one out to get started i need an if statement once again and now i want to check if money available is greater than 80. this covers this first bit on top of that i also want to check the end if hungry is equal to true with that i have covered this entire bit now that i have that i can print eat something fancy if i run this now this is going to return eat something fancy let me comment out this stuff at the top so we're not getting confused eat something fancy if i change hungry to false run this again we are not getting anything the simple reason being that both of these statements have to be true because of the end statement here if either of these is false then the entire thing is going to return false which it does right now so none of this is going to be run however now what we can do is use an or statement as well to cover the last bit or if bored and now i want to check our board equals to true as well if we run all of this now we get eat something fancy and what happened here is python first checks the two statements connected by and and it sees that money available is 100 which indeed is greater than 80 meaning this part here is going to be true but then for hungary equals true it looks at the hungry variable and this one is false meaning this one is going to return false as a consequence the entire bit here is going to give us a big false the difference now is we are also checking this or statement which means we want to check if anything in here is true or if this condition is true which it actually is right now and as a consequence the entire thing combined is going to return true consequence being we are going to run this line of code and i hope this makes sense using these and or keywords can be a bit confusing definitely play around with this in your own time if you're struggling that being said most of the time you are going to keep this fairly simple you usually only have a single and statement in here and then you are good to go don't overthink this the other way to make if statements more complex is by nesting them and let me do an example we could have an if statement if a is inside of the list a and b right now this one would be true but inside of this we can add another if statement that is indented by one line and inside of that we could even add another if statement and this system we could continue forever as long as we keep on adding more indentation levels let's have a look at this one in a bit more detail i'm going to comment out the stuff we have done earlier i guess i could organize it a tiny bit better there we go and now i will look at nested if statements and to keep comments a bit more consistent let me add one for the first part let's call it combining conditions the example we have just seen is we want to check if the letter a is in the list a and b if that is the case i let's say i want to print a is in the list executing the code is going to print this line this one should be fairly straightforward and again remember we are on one level of indentation on this line of indentation though we could add another if statement we could for example check if a and then use the method then i need a colon again and now i need another indentation line or another level of indentation and then here let me print it is a letter if i run this now i get a is in the list and it is a letter now this example really doesn't make too much sense but we can make it quite a bit more interesting for example what you could be doing is create a variable and in this right now i want to have let's say the string a and now i want to check if x is inside of this list and i want to check x is alpha if i run this again we are going to get the same result we essentially just replaced the string a with a variable that contains the same string but once we have that i could add another string in here that contains a 1 which is not in the alphabet so if i check this one here what i expect now to happen is that this is still going to be inside of the list so this entire condition should be true as a consequence this print statement should run however the number one even if it's inside of a string is not in the alphabet so this condition should not be true and if i run this we can indeed only see this line here was run but this was false and as a consequence this line here was not executed if you wanted to you could even add another level of indentation i don't know let me just add true so we always execute it and inside of that you could keep on adding more if statements there's absolutely no limitation on how many if statements you can add the only thing you really have to consider here is that each if statement has to be on a separate level of indentation at the very least if you want them to be part of the other if statement if you added an if statement here let me get rid of this one you would check those two individually the way you want to think about it is that each if statement is one block of code this if statement here is one block inside of this if statement we have one block for this if statement and another block for this if statement and these two here are independent of each other but they both depend on this if statement to run if this if statement does not run neither of those will run just to have something in here let me print something and let me add some purple white space so this looks a bit cleaner all right with that we can do another exercise and then finish this part what i want you guys to do let me copy it from up here i want you guys to check these three conditions but now instead of using this system here i want you guys to create a nested if statement and if all three conditions are true so you have enough money you are hungry and you are bored then i want you guys to print eat something fancy or really whatever you want it doesn't matter that much let me actually uncomment them and add a comment for the exercise and now pause the video and do this one yourself let's start with money available is greater than 80. that's the one we have already used and i guess while we are here i can also print something to check on what if statement we are for this one i want to print i have enough money after that i want to check the next if statement and i just want to check if hungary is equal to true and if that the case i can print and i am hungry inside of that i want to check if board is equal to true and if that the case i want to print the final thing eat something fancy before i run it i do want to comment out this part here so we keep things a bit cleaner if i run this now we only get up to i have enough money this line here we are not getting to if hungry because hungry is false if i said this hungry too true we get let me expand this a tiny bit i have enough money i am hungry and eat something fancy all three conditions here are true and with that we have if statements obviously you could also add else statements in here if you really wanted to and make this even more complex now there's one more thing that i want to cover really quick writing something like this is a bit redundant all you really need is hungry by itself if i run this it would still work what happens here is that python looks at the hungry variable and the value for hungry is true meaning this if statement here is essentially if true and keeping like this is much more readable if a value is truthy you could just add it in here and then python would take care of the rest for you but being more explicit about it would also still work perfectly fine but alright with that we have if statements covered in this part we're going to cover the match case statement and this one is kind of similar to an if statement the major difference is you still run some code if a certain condition is true but match case is more designed to check for one specific value out of a long list of possible values that probably doesn't mean too much let's do an example let's say you want to check the mood of something if you used an if statement it might look something like this we have if hungry you want to run some code and else if you're tired or bored you want to run some other code all of this would be just fine but it also feels kind of inefficient having one l if statement for each mood seems kind of annoying to write every single time and as a consequence python has a slightly different way to approach this kind of case and this is a match case you would use the match keyboard and then you would look at the variable in this case i am looking at the mood and then you can specify different kinds of cases for example case for hungary and if that is the case we have colons again and we are running some code inside of it and then we can check for different cases and run some code for all the different possibilities it is very very similar to an if statement if you compare the two match case is actually a tiny bit longer if that makes a difference to you although the main thing you want to look at here is readability all of these l if statements here eventually get kind of annoying to read whereas case this case that gets much better and is a much easier way to check the value of this mood both approaches here would be perfectly fine though as a matter of fact match case is a reasonably recent addition to python which is the reason why very few people actually use it most of the time you are going to see some kind of if statement which is still perfectly fine but in some cases match is the more appropriate way to go on but well let's have a look at all of this in code once again i have a completely empty python file and i want to create a new variable let's call it mood and right now my mood is going to be hungry if that is the case i want to run some code what we have seen so far you could use an if statement if mood is equal to hungry then let me print get some food or something like that running this will get me indeed get some food this one is working just as intended the difference now is if we have lots of options here for our mood we could be hungry bored thirsty tired and whatever else you want for each of these conditions we would have to add another l if statement to check for all of the possibilities which does eventually get kind of cumbersome to write and because of that we have match and then we want to look at the variable mood in my case now you need a colon and if i press enter we are again indented by one line and now i have to specify a case that could be one scenario for this mood for example the case could be hungry if i add a color now and press enter we are once again on a separate line and now i can print get some food if i run all of this we are again back to get some food this result here is basically a simple if statement the difference now is that we can specify other cases for example a case first d and then let me copy this one get some water i could specify a case for tired and continue like this forever there really isn't any limitation how many cases you can have let me just write it out get some sleep with that established i can now change the variable and get different outcomes i suppose there's one more thing that you could include here and that would be case underscore still needs a colon and now you can print in here any other mood because an underscore is run when none of the other cases are correct for example right now if i write in here something like board a case we haven't accounted for yet if i run this we get any other mood if python doesn't find any of these it is going to run the underscore one and with that we have match case covered and i am fully aware this is about as efficient as an ifelse statement it really isn't that much of a difference match case really is not something you absolutely have to use if you want to stick to if else statements this would also be perfectly fine but all right let's do an exercise what i want you guys to do is this one here create a variable with an integer between 1 and 5 and this should be a great a grade you could be getting at school and then create a match case statement for all of the values that this grade could have one would be very good and five would be very bad and print something like this for each of these cases and i mean all of them from one to five also don't forget to include some default behavior if you get the value you didn't expect like a 10 for example pause the video now and try this one yourself let's get started and i want to comment out all of this and then we can start by creating the great variable and let's start with number one i want to start by writing my match and what i want to look for is the great variable then i need a double colon and now on an indented line i want to check for one case and the case right now could be a one now i need a colon again and once again on an indented line i want to print very good i can now run this and we get very good indeed with that we have one case now we can do case 2 print let's say still good case 3 would be print ok case 4 would then be print needs improvement and finally case five i want to print very bad i think i said yeah very bad up here and this would already be a working match case statement i can run this again we get very good the same we had earlier let's say if i use a 3 we get ok and if i use 5 we get very bad the one thing we haven't done yet is if i have a 7 a value we don't have accounted for nothing is running in here i guess i haven't specifically mentioned that but if the match case doesn't find a value it just doesn't run we do not get an error message just keep that in mind it's a specific behavior of it all right but i want to add case underscore for all the other values i haven't accounted for and for this one i can print let's say great not recognized if i run this now we get great not recognized this would also work with i don't know something else python doesn't really care what the value here is all right with that we have match case something fairly similar to an if else statement but it could be useful in very specific scenarios a really important concept in python is the while loop and this one is actually quite simple all it does is it repeats some code as long as the condition is true for example this could look like while true i want to print an infinite loop this infinite loop here would run forever unless we manually break the code not exactly the most realistic scenario but something we could be doing i suppose something slightly more realistic would be something like this we are starting with x being 0. then we are checking if x keeps on being smaller than 10 and inside of this while loop we want to print a certain thing and we are also going to increase the value of x on this line here this condition now is only going to run 10 times and this is how often we are going to print this loop here and with that we have some basic theory out of the way let's actually have a look at all of this in code i guess we can start with the examples i just talked about we always start with the while keyword once we have that we need some kind of boolean statement this could either be true or false although if you have false this while loop is not going to run it will only run if the value is true if that is the case in here you can print i think i called it infinite loop if i run this now we get an infinite loop that keeps on running forever it's not particularly exciting but it definitely does work the way you would exit this one is by just pressing escape and it would stop although you really want to be careful with while loops it can not crash your code but it can make your code not work anymore let's say if you have some kind of game and you end up in a while loop that you can't escape from anymore your game might just stop because your computer is stuck in this while loop and it doesn't continue from it let me get rid of this one and let's do something a bit more reasonable instead i want to create a variable x and by default this one is going to be 0. and now i want to check while x is smaller than i want to print x look at this code if i run it what do you think is going to happen what we get is if i run this we have a whole bunch of zeros that keep on running forever and the reason here should be fairly clear this boolean condition x smaller than 10 is always going to be true because x is always zero and we are never changing it the consequence being that this print statement is going to run forever it is never going to stop to overcome that we would have to do something like x plus equals 1. and now if i run this we get the values from 0 to 9. i suppose what you could also be doing is combine this with an if statement for example if x is equal to 5 and this has to be indented really important to tell python that this if belongs to this while loop here but once we have that i want to colon again and on another level of indentation i want to print x is 5. if i run this now we get the values from 1 to 9 and at the value 5 we have x is 5. and this way you can repeat code quite easily that being said there are two ways to make all of this a bit more complex let's talk about it you can break an entire while loop and you can also skip one iteration of the while loop and let's do this by example this is a bit difficult to explain here's the example i've shown you earlier and this one would just print the word loop 10 times on the screen but what you can do let's say with one if statement you could for example add the break keyword and just a keyword no brackets just break and if you write this the entire while loop is going to end whenever x is equal to 5 you would never get to this 10 here at the end besides that you also have continue continue doesn't break the while loop instead it just skips to the next iteration of the while loop meaning in this case if x is 5 this print down here would be skipped over because after continuing this line here we would go back to the while loop and then continue with the next iteration i think i added a bit more text here there we go so break ends an entire while loop while continue skips to the next iteration of the while loop and that's basically all you have to understand about it let's play around with it i already have an if statement inside of the while loop and this one i want to use let's start with the break keyword and you can already tell sublime is coloring it differently so we know that it has some kind of special functionality if i run the code now we get only the numbers from 0 to 4 and this happens because of this break here it ends the entire while loop as soon as xs5 the other keyboard we have seen is continue and this one right now is not going to work and maybe you can figure out why let me run it actually in this case we are getting all of the numbers and try to think of why we didn't skip over one of them after we are running continue we are skipping the rest of the current while loop in our case though we don't have anything after continue continue is on the last line of this while loop which means it doesn't actually do anything we could change this though by putting the print statement after continue and let me add a bit more white space here this looks a bit cleaner if i run this now we would expect this print statement to be skipped if x is equal 5 meaning we shouldn't see 5 in the output let's try it and indeed after 4 we skip straight to 6. we do not have 5 because of this continue here and with that we have a while loop let's do an exercise and then we are done that is horrible spelling there we go what i want you guys to do is to use a while loop to create a list with only even values from 0 to 100 i guess as a tip here create an empty list first and then from the while loop append more values i haven't covered yet how to only get even or odd values maybe try to do some research it should be fairly doable but let's see if you can figure this one out i guess this one was a slightly more challenging exercise but let's try it together i first need some kind of list let me call it my list and this is just empty brackets for an empty list and there's one more thing that i am going to need and that is some kind of counter by default i want to set this one to zero this is what we are going to use to control the while loop like the x we have used up here actually let me comment out this earlier stuff so we are not getting confused what i want to do with that is run my while loop again with counter is smaller or equal than 100 because this is the maximum number we want to go to and we are starting from zero which is the value here and let's start by adding every single value to the list for that we need my list append and then the counter once we have that i can just print my list and let's see what we get and we are getting nothing the reason here look at this again i have actually made the mistake i warned you about earlier right now the code is stuck inside of the while loop let me end it with the escape button this if this was an actual code example would have been really bad the reason here is this counter doesn't increase it always stays at 0 and as a consequence this condition will always be true and as a consequence we keep on adding the value 0 to this list and besides that we would do pretty much nothing else i would spend my entire processing time just adding zeros to a list which not only would break my code it would also be a waste of resources the way around it is i want to increase the value of the counter by 1. and now if i run this we are very quickly getting the values from 0 to 100 already a pretty good start but now i don't want every single value i only want the even ones meaning i want 0 2 4 6 and so on for that we are going to need an if statement inside of the while loop all you really need is the percentage sign and this we want to use with the number 2. if this is 0 we know we are getting an even number if i run this now i am getting only the even numbers this operation here if you forgot about it is the remainder for example if the counter was at three i think early on i used dots and that's a really good system to explain it let's say we have three dots here representing this three and if we're dividing this number by 2 we have one full block and this would be 1 unit after division and what this percentage sign here gives us is the remainder so this one here and if this is any value besides zero we know we have an odd value on the same line if there is any value so if i use different from zero we are only getting the odd values and this is the most common use case for this remainder operation it's a really easy way to get even or odd values i guess while we are here we should also practice skipping one while loop so let me extend the exercise i also want you guys to do not add the value 58. for some reason i really do not like this one try to add this one as well all right this is turning kind of into extra practice for the if operator but i suppose that can't hurt we can approach this in two different ways we could either add another if statement in here or add an end keyword after the original if condition i guess let's start with this one i want to check if my counter has a remainder of 0 and my counter is different from 58 this is the number i want to avoid if i run the code now i get let me find the value we have 54 56 and then we skip to 60. we do not have 58. this would be one way to add it here a different approach could be another if statement inside of this counter i could check in here if counter is different from 58 and then this append here has to be on one more level of indentation to tell python it belongs to this if statement here and if i run this now we are getting the same outcome here with the 58 being skipped all things considered while and if work really well together and all right with that we have while loops something fairly similar to a while loop is a for loop and this one works in a somewhat similar way we are still running code a certain amount of time so we are basically repeating code the difference now is that we are running code for every item inside of a container this could for example look something like this we want to run a for loop for every item inside of the list that contains one two and three the way this works is that python goes through this entire list and picks every single value one two and three here and then for each cycle it assigns the value to the x in this case but you could name it whatever you want meaning if you added something like a print inside of this for loop you would print 1 2 and three four cycles over every single item in the list and then it stores the value inside of x and you can treat it like a variable and just like with while you can also use break and continue and that is basically it let's have a look at it i want to create let me call it a basic list and here let's use the example i have a list with the numbers 1 2 and 3. and i want to run a for loop to access every single item of this list the example we have used is for x in basic list and then inside of it we have printed x if i run this now we're getting one two and three so what happened here i think it actually makes kind of sense python is going to run this block of code here for every item inside of this list and on every cycle it picks one of the values starting from one then two and then three and it always assigns this item to the variable we have specified here but you could use any python variable name and then inside of the for loop we are doing something with that value right now we're just printing it we could also add it to a list or doing some math operations or really do whatever we want and that way we can run code for every item inside of a list and this would also work with the other types of containers like a tuple a dictionary or a set as a matter of fact there are lots of different things you could be cycling over for example a string would also work inside of a for loop and there's one particular case i do want to cover if you want to cycle over a number this would also work but it does need some adjustment let's actually play around with all of this and i have prewritten some values these ones here we have a basic tuple a basic dictionary a basic set a basic string and a basic number tuples and sets work exactly like the list if i replace the basic list with a basic tuple we get the very same outcome and we would also get the same thing with a set there we go we always get one two and three python just really doesn't care what kind of container you have it's fine cycling over any of them the basic dictionary also works but it looks a bit different in terms of what you get let me paste it in here basic dict and now we are still getting one two and three we are getting all of the keys which if you cycle over a dictionary is probably not what you want to do the way around it is you would use either values to get the values now get one two and three the strings attach to each key or we would use items and that way you're getting a tuple returned with the key and the value we are going to learn later on how to work with dictionaries in a bit more detail but for now i think this is all we are going to need for a basic string we can just paste it in here and now python takes the string apart and gives us every individual letter including the space finally we have a basic number and this right now is not going to work if i run it we get a type error into object is not iterable let's talk about why this one didn't work to loop over a number so the operation we have seen was for x and three and this one didn't work the reason it didn't work is because python needs some kind of iterable and integers cannot be iterated over that being said iterating from zero to a certain number is such a common operation that there's a specific python function for it it is called range how you would use that is you would add a number in it and then it creates a range object if you use something like range 3 we would get a range object from 0 and then all the way to 3. and this we can iterate over it's fairly similar to a list although it is its own data type meaning if you want to iterate over a number you would use for x in range and then the number and i guess let's implement this one as well here we are back in the example and instead of using the number i have to put the number inside of the range function if i print this now we are getting the numbers 0 1 and 2 which if you pay close attention is kind of different from these numbers here we are not even getting 3 we are again starting at 0 and then going all the way to 3 but we are not including 3 and this is why we are getting two a better way of illustrating this let me copy this and comment out this entire for loop and just print the range object running this gets me a range object from 0 to 3. it very much is its own data type and this one simply gives us something we can loop over and it starts from 0 and goes all the way to a number we specified but it doesn't include it which granted is a bit confusing to read the range function actually works very similar compared to slicing because inside of range right now we only specified one value which was the end point but you could specify up to three values in here you could have the start the end and the step size for the values start by default is going to be zero and the step size is always going to be one meaning if we don't specify them we are getting those values most of the time you are only specifying the end value which is what we have done ourselves but in here you could specify something like 10 let's say 20 and 2. if i run this now we are getting range object from 10 20 and a step size of 2 which by itself isn't particularly useful but if i cut all of this out get rid of this print statement and uncomment this for loop and now i want my range object to look like this if i run it now we get only the even values from 10 to 20 and again we are not including 20. but that is essentially the for loop it is very often used alongside the range function they are very much connected to each other and i guess with that let's do an exercise once more and what i want you guys to do is this one here and this list contains other lists these are nested lists you are supposed to cycle through this entire list using a for loop and then only print the numbers below 50. although skip the values below 10. as a tip here you will need one for loop to go through this list and then another nested for loop to go through each individual list inside of this list finally i want you guys to break this for loop if any value is above 100 which is the case here for this one you are going to need a for loop inside of a for loop and also throw an if statement in there somewhere see if you can figure this one out yourself alright let's do it together now first of all i need for and now i need a good name and since i know that each of these lists here are nested inside of this practice list i want something like for a nested list inside of my practice list meaning i'm looking at this practice list here and i'm cycling over this entire list what i'm getting from that is going to be let me print the nested list i am getting these three lists here we still get the earlier results let me comment out all of this to make all of this a bit cleaner there we go now we have a couple of lists with numbers inside of them problem is this still doesn't help us figure out individual values for example i want to print this 10 here but right now i can't access it because it's inside of a list to overcome that we are going to need another for loop with for let me call it value inside of the nested list and now if i print this value and let me comment out printing the nested list that's going to get confusing if i run this now i am getting all of the numbers basically what happens here let me use different colors for this the first for loop this one here is going to go through this entire list and it is looking at every item and an item is counted at anything separated by a comma meaning this is one item this is another item and this is the final item python doesn't care if the item is a list or a number it treats all of them the same and to access every value inside of this nested list we have this second for loop here and this one is going to go for every individual list it starts with this one then it does this one and then this one and via this for loop we are going through every individual value inside of the list or the nested list to be more specific the result being that this value here is going to be every individual value from all of the lists and this is what we are printing that is a really good start so now we have to cover that we only want to print the numbers below 50 and we want to skip values that are below 10. i guess we can start with if the value is below 50 only then do we want to print the entire value let me run this now and we are only getting values below 50. this is going to cover the entire first line now we have to cover the part to skip if a value is below 10. and this again we could either do by adding an end here or we could add another if statement inside of here i guess i'm going to stick with the if statement inside of here although it really doesn't matter i want to skip the values if we are below 10 meaning if the value is below 10 then i want to use continue if this is the case we are stopping this entire cycle and we are not getting to the print value so let's try this and indeed we are only getting values that are at least 10 and the values two and 4 we have skipped now finally we have to cover the last part that i want to end this entire for loop if we get a value above 100 which is going to be this one here and now you might be very tempted to add something like if value is greater than 100 then i want to break this entire code or at the very least the for loop however now this is not going to work i guess to demonstrate it the last value after 101 is going to be this 10 here and since this is not below 10 we do expect this to run although i just realized that since we have a 10 here enter 10 here it might be a bit hard to see let me change the name here to a 12 so we have a specific number if we run the code now we still can't see the 12 and i would recommend you to look over this and see why we can still see a 12. the error here is because of one of the if statements try to have a look for it the error happened on this line here this if statement checks if the value is below 50 meaning we are never getting a value above that 50. as a consequence when we are getting to this line here if value is above 100 this line doesn't even run because we never get to it after this line here we are only getting values below 50. so this line here is essentially pointless we can however cut it out and paste it at the top of of the inner for loop let me fix this one now when we are looking inside of this for loop if we find any value above 100 we are breaking the entire thing and none of this would run i guess let me run it and now the last value is 10 this 10 here this does look confusing especially if you're just starting to program but if you get used to indentation here this should eventually make more and more sense this is definitely something you want to practice in your own time even more when it comes to python and the flow of the code understanding indentation is really important to understand what's going on there's one more topic i do want to cover before finishing this section and that is flow and line breaks so far we always wrote code with a colon and then with an annotation on the next line you don't have to do that you could just write straight after the colon for example for a for loop instead of the line break after the colon and the indentation here you could simply continue writing the print statement here this would also work with an if statement it would also work with a while loop as a matter of fact you could even use a semicolon to add multiple lines of code all of these here would be counted as indented python is totally fine with that that being said most of the time you do want to indent your code because having multiple lines is easier to read but that's not always the case sometimes if you have a very simple statement it might make more sense to have it on the same line for example match case very often has each case on an individual line without a line break between the case and the actual code because the idea here is each case should be fairly simple we're gonna have a look at that in a second but much more important for the if statement python does have a special operation here to have a one line if statement and this is called a ternary operator this one works like this let's say we have x equals 5 and we want to check something like if the value is below 5 we want color equals blue and else the color should be red a really simple if statement the problem is that we have four lines of code for something that really is very simple we could make this more space efficient by skipping the line break here this way we only have two lines and this i think is more readable but this may be debatable here however there is an even more efficient way of doing all of this and this would look like this this by the way is called the ternary operator this entire line would be this bit here then we have the if statement as always but now the if statement this bit here with the condition is this part here from the original if statement we also have an else and then we have the else condition so this red here would be assigned to the color if the condition this one here was false and the way you would understand this ternary statement here is if you read it like a sentence i want the color blue if the value of x is below 5 if that is not the case so else i want the color red and that way if you have a simple if statement you can cover all of this on a single line of code once again we have a completely empty python file and i want to start with the match case statement and here is the exercise we have done earlier if you see this now with the understanding that we don't have to do these line breaks i think all of this starts to make a whole lot more sense this one we could write like this let me get rid of all of the line breaks this here is something incredibly readable especially if you have some kind of statement where you would expect a lot of specific values you want to check for this would be a very readable way to organize all of it although granted using ifelse statement wouldn't look all that different the much more important operator is the ternary operator and let me comment out the match case stuff because we don't need it the example i've used earlier was x equal 5. from this value i want to assign some kind of color and in here you first of all need the value in my case red if the condition you want to check for is true i want to have red if the value of x is i think smaller than 5 i said doesn't really matter what it is if that is not the case so else i want to assign a different value which in my case is blue and that is all we need if i now print my color run this we are getting blue because 5 is well this condition here is false but if i change x to 1 run this again we are getting red and this way if you have a very simple if statement you can cover it on a single line i guess let me go over this a bit more theoretically a ternary operator always looks like this we have a true value if an expression results in true if the expression is false let me add a cross here then we are getting the else value so the false value and then either the true or the false value will be assigned to whatever kind of variable we are assigning all of this to that way you can cover an if statement on a single line of code and this is really readable and very efficient if you have a simple if statement if the if statement gets more complex obviously you want to use a normal if statement the ones we have already seen i guess one thing i haven't covered yet is that this sort of operation here this ternary operator works in a lot of different tools as well for example you can use it inside of an fstring or when you are creating a list let's have a look at those two examples let me get rid of this print statement and instead i want to print an f string and in here i want to write something like the color is and then i want to have an operation and in here i could copy this entire thing instead of the variable and it would still work so i can copy it although there's one thing that we do have to take care of and that is that right now the quotation signs are going to confuse python so it doesn't know where the string ends and where it begins the way around it is to use double quotation marks at the end and at the start and this should be working now let's try it and there we go the color is red and in here we have a fairly complex statement inside of a string this way we don't have to assign variables before or after we can keep everything nice and neat inside of one line finally we could also do something like a is equal to some kind of value in the list and in here i could once again copy all of this paste it inside of the list and then have some other values like i know yellow and green if i now print the entire list we're getting red yellow and green all i really want you guys to take away from this is that this sort of operation works basically anywhere in python you could also put it inside of a function or a method python really doesn't mind and this can give you a ton of power and avoid you having to write extra code that you wouldn't need in this section we are going to cover functions and let's talk about what functions are and what purpose they serve so far we covered some basic data types like integers and strings and we also learned how to change them using functions and methods on top of that we also learned how to change the flow of the code using if else match well for statements and stuff like that so we are basically able to create simple programs that work just fine but all of this only gets us so far and to understand why let's do a metaphor and let's say we want to build a car and the tools we have learned about so far are the basic parts that you would need for a car like screws pipes wires plastics and all the most basic parts you can have for a car the problem is these parts don't really make a car we don't build a car out of plastics and wires instead we build a car out of an engine out of steering systems out of control systems batteries and stuff like that meaning what we want to do in our code is to take these simple parts here and use them to create more complex systems like a control system or like an engine and once we have these more complex systems we actually create the entire car and in this analogy a function is one of these more complex systems like the engine the control the battery they are just more complex parts but they're still made out of these simple bits here and the main purpose of this is to make our code more reusable and more organized so what we are going to focus on for this section is to combine these simple tools to create more complex parts and that is the main purpose of functions later on we are going to learn even more powerful ways to organize your code using classes but that comes later for now we are just going to look at functions and the one really important thing i already want you guys to understand is that a function is simply a block of code that can be reused we're not really learning anything fundamentally new instead we are just putting our preexisting code into a simple block or container and then we are using this container to execute that code that's basically it although to use functions we need a twostep process let's talk about that one and then we actually create some functions for function we first of all have to create the function and this is where we are adding all of the code to the function or while we are creating the code inside of the function once we have that we have to do what is called calling the code this is a very common word calling a function means you are executing the function or you're telling the function to run and execute the code inside of it and you can also add information into the function when you called it we will see that in just a second but with all of that covered let's actually create some basic functions and this we should do in our code so let's have a look at that and to create a function we need a special keyword and this is called def short for define and now we need a name for a function and in here we have the same naming convention that we have for variable naming so for example a name for function could be test underscore function and this would be perfectly fine and once we have the name we need a pair of brackets and those you always need i will explain in a second what they actually do i am going to leave them empty for now though and now we need a colon and if i now press enter i am going to be in one level of indentation this space here tells python or while this indentation that any code we have inside of here belongs to this function really important to understand it works like a for loop or an if statement same principle and now in here we can write any code we have already seen for example i could print hello i could create a new variable let me call it test and test could just be one plus two and then i could print test we can write the very same code in here that we can write in normal code and once i have this i have created a function so this is the first step and now to call it i need my test function so the name of it and then add brackets afterwards and this entire process here is called calling a function essentially every time you're adding brackets after the name of a function you are calling that function and what that essentially means is you're telling python you want to execute all of this code here if i run the code we can see hello and free so this hello here and the result of oneplus 2 printed in this line and what i can also do now i can duplicate this call of the function and run this again and we can see this code run or executed multiple times and i hope you can already see why this is useful you can basically create some specific functionality in here and then execute it wherever you need so if you had some really complex code and you wanted to organize it better this is one of the main ways you would be doing it and let's actually do another example and for this one let's do something more specific i want to create a calculator and again i need brackets and all i really want to do in here i want to create a variable result and this result should be the result of number one plus number two and once i have that i want to print my result meaning this would be an incredibly simple calculator that just adds two numbers together but for this to work we kind of have a problem and that is how can we get this and this number here and for that we're going to need these brackets here and those brackets are called parameters and what they mean is let me add them actually i can add a parameter for number one and a parameter for number two and let's actually do the entire function now when i call this calculator and execute it with brackets i have to add arguments in here let's say two and three if i run this now i can see five which is the result of two plus three now why did this happen essentially this number one here and this number two are both parameters and a parameter is essentially a variable that you can only use inside of the function meaning this number one here we can use as a variable inside of this function same for this number two here and then the value for these two parameters or these two variables inside of the function come from the information that we pass into the function when we call it meaning this number two here is going to be the value for number one and number three is going to become the value for number two let's actually do this the other way around when we are calling the calculator by calling the name of the function and adding brackets afterwards python is looking what happens inside of the bracket and right now we are adding two numbers two and three and next up python looks at the actual function and the parameters and right now it has number one and number two and now what happens is that python is going to add the first argument which right now is this 2 it is going to assign the value of this 2 to the first parameter and then the second argument so this 3 here is going to be passed into the second parameter and that way num1 becomes 2 and num2 becomes 3. and once we have that we can use those two numbers like variables inside of the function although one thing you do have to be aware of is that both of these parameters only exist inside of the function meaning if i try to print num1 outside of the function i would get an error and that error is name 1 is not defined because this name 1 here only exists inside of this function so in the code besides coding the calculator once i could also call it twice and add different numbers let's say 10 and 20 and i would get the result again so again this function here we can call multiple times and well with that we already have the basics of functions so let's do an exercise and what i want you guys to do is to work on this calculator and give it some more functionality it should still accept num1 and num2 for two numbers you can add but besides that the user should also be able to add an operation so a third parameter and i want you guys to add a plus and a minus operation here so for example if the user adds let's call it the better calculator in here we can add one two and then we can add minus or we can add plus and obviously if the user does that we get either plus or minus operations now first of all i have to create a new function by writing better calculator the name of our function and now in here i need three parameters i want num1 and num2 again and besides that i need an operation or operator doesn't really matter what you call it and one important thing really quick since these parameters are always relevant only to the function we can reuse names here quite easily meaning to python these num1 and num2 parameters and these up here have no relation whatsoever so don't worry about naming here now what i want to do inside of this function is to add an if statement and in here i want to check if the operation is plus and if that is the case my result should be num1 plus num2 and once i have that i want to print let's do this a bit more fancy i want to add an f string and in here i want num1 plus num2 is equal to the result and we can actually try this so i already call the function with 1 2 and plus and the plus we have in this if statement here meaning if i run this i get 1 plus 2 is 3. and let me comment out these two lines here so it's a bit cleaner and one important thing here the indentations continue on each additional level i guess we haven't talked about this too much yet but inside of this function all of the code has to be on one level of indentation and now if we use more code inside of this like an if statement for example we have to add the code for this if statement inside of another level of indentation and that way python knows that this code here belongs to the if statement and all of this code here belongs to the function it's really important to understand indentation early on python uses it extensively to organize the code if i add a minus to this calculator we get nothing because we have no if statement or any of this but we can add it quite easily because i want to add an l if statement and in here operation i want to check for minus and now for this one i can just copy all of this and now the result should be num1 minus num2 and then for printing all of this there should be num1 minus num2 and now if i run all of this again i get 1 minus 2 is negative 1. that seems right and now i can copy this line change the numbers let's say i don't know some larger numbers let's add a plus here this is not how you spell that let's run this now and we are getting something that looks pretty good and i hope now that we have some better examples you can see the value of functions this is a really good way to organize your code because when we actually execute the code we just have one line but this one line executes a whole bunch of code and in actual programming examples you might have hundreds of lines inside of one function and what you see most of the time is that programmers create all of the functions at the top of the file and then a bit further down the actual code logic is written and that way you create some pretty good logic that is quite easy to follow and you can just change some functions here if you wanted to now with that we have basic functions although you can do quite a bit more with functions and the next part we have to talk about is arguments and parameters so let's talk about that in the next section so let's talk about parameters and arguments and let's do a quick recap because it's really important to understand these names when we are creating a function we are setting some parameters this would look like this for this function we are creating parameter one and we are creating parameter two and these parameters we can use like variables inside of the function so for example inside of the function we could print perimeter one and parameter 2. and again remember these parameters only exist inside of the function and now the next important step is when we are calling the function we are adding an argument to give the parameter a value which means when i call the function and i pass in hello and 42 then the first argument is going to be assigned as the value to the first parameter and the second argument will become the value for the second parameter and after that we are using those two parameters like variables inside of the function and the output we would get in this example would be hello and 42 and the basic thing you have to take away from this is that a parameter is basically a slot for an argument we are only using arguments when we are calling the function here and the parameters are the slots that we add the arguments to now there's one thing that we also have to talk about and that is how this ordering happens so how do we assign this hello to parameter one and by default arguments are being assigned to parameters via their position meaning the first argument is going to be assigned to the first parameter and the second argument to the second parameter and so on but there is another options and that is called keyword arguments and for this one you specified the specific parameter you want to add an argument to and let's have a look at this in practice that should explain this the best here again we have a completely empty sheet of code and i want to create another function that i called test function and right now i want to have argument 1 argument 2 argument 3 and argument 4. and then inside of the function i just want to print all of these arguments so let me copy it a few times three and four and now when we are calling this test function i can add for example one i can add hello i could add true and let's say for a list i could add one to and test you can essentially pass anything you want as an argument inside of a function if i execute this function we get one hello true and a list now the problem we have here when we are using position to assign this argument to this parameter for example is that this can get messy really fast and i think you can already see this one here where it's kind of hard to tell where things belong to it's really starting to look messy and for arguments still is a fairly low amount imagine we had 20 arguments in here which isn't impossible so we want to have something to organize this a bit better and for that we have keyword arguments and what those are is well we're adding the name of the parameter in this case arg1 and then we are assigning it a value like we are assigning values to a variable this in this case i want to do for all of these different arguments this would be argument 3 and this would be argument 4. and if i run this now we can see the very same result although here when we're using keyword arguments python does not care about the order for example i could assign argument 4 here and at the end i assign argument 1. if i run this now the first item so argument 1 that we are printing here is going to be this list and this would then be a clearer way to call your function what you can also do is to add this over multiple lines so i can do something like this and call all of this again and it would still work python here is quite smart and it understands that all of this is one function and this one here is actually fairly readable so even if we had more arguments this would be workable quite easily now what you can also do is combine positional and keyword arguments although you do have to be careful here and let me do one example let's say i want to assign argument 1 argument 2 and argument 3 via keyword arguments and then the final argument should just be a positional argument if i run the code now python is going to complain and the complaint here is positional argument follows keyword argument and this is a general rule you have to follow that positional arguments always have to come before keyboard arguments meaning this positional argument here would have to be before all of the keyword arguments let's say now i only want to have argument 1 as a positional argument and all of the other arguments this one is arg4 i want to have as keyword arguments if i run the code now this is working just fine and the basic reason why we have this is let's say i want to assign this argument here via position and right now this would be the fourth argument because this is the fourth item when we are calling the function problem is if i change this argument to to argument four then this keyword argument would also be referencing this argument for here and as a consequence python would get confused and if we have positional arguments before the keyword arguments this is somewhat mitigated although you could still mess this up for example if this first argument here is argument 1 and then the first keyword argument also references this arg1 and i run the code we are getting an error the test function got multiple values for arc 1. so you do have to be careful here but it's generally quite doable now with that we have positional and keyword arguments there's one more concept that i do want to cover and that is default arguments and the concept here is really simple let's say for this argument 4 if we don't get a value i want to assign a default value and this i do by simply adding an equal sign and now adding a value let's say for argument 4 i want argument 4. if i have this set up here i can get rid theoretically of this argument 4 comma function and now argument 4 is going to be argument for here or the parameter value is going to be this string and what you could even do if you really wanted to you could assign a default argument to all of your parameters that would look like this i hope i didn't forget anything and now you could call the function without a single argument and it would still work just fine although this again becomes kind of hard to read but sometimes this can be quite useful now let's do an exercise and let me copy in what i want you guys to do it's getting a bit long so i want you guys to create a greeter function with free arguments oh well free parameters we have person greet and weekday person and greed should have default arguments person for the person parameter and hello for greet and inside of the function use an f string to print the greet and the person and also print the weekday and when you're calling the function use at least one positional argument and one keyword argument and pause the video now and implement all of this yourself i want to create my function all the way at the top below my test function and the function name is greater and in here i want three parameters let me actually fix this one three parameters i want to have person i want to have greed and i want to have the weekday and with that we have covered the entire first line now next up for person and greed we want to have default arguments for person this should be person and for greed this should be hello and now inside of the function i want to print an f string and that is the third line of the exercise and in here i want to print the person and i want to print the greet and i guess on top of that we can print another f string and in here let's say it is the weekday and now with that we only have to call the function and let me comment out the test function and instead i want to call my greed turf and now we need one positional and one keyword argument let's say the first argument has to be positional because remember position arguments come before keyword arguments and let's say the person then is going to be bob for me now next up we need a keyword argument and for this one i want to go with weekday and let's say it's tuesday and now since greed has a default value this should be all we need so if i run this we are getting an error and the error here is that nondefault argument follows a default argument meaning python is unhappy that we have a default argument a default argument and then no default argument and this again can cause confusion in terms of what argument we are assigning to what parameter and i guess in our case to fix it for the weekday we can also assign a default argument let's say monday is our default weekday so now if i run this this function is working just fine and i can assign arguments via keyword arguments so i have person weekday and for greed let's say i can say welcome this would also work and i can also use positional arguments to assign the values like so and if i run this we would get something slightly weird because now we are assigning this tuesday here to this greet so you do have to be careful but at the very least this is working and i guess let me put this exercise on top of the greeter so it's a bit easier to read and right with that we have some default arguments and keyword and positional arguments the main thing you should be taking away from this video is how you assign arguments to parameters understanding that is really important to use functions we can actually do some more things with arguments so let's put this in the next section okay so let's talk a bit more about parameters and arguments and the main question we have to answer for this part is what if you don't know the number of arguments can you still make a function and the answer for that is absolutely yes although we do have to learn some new things and let's do this trading code here i have a completely empty file and i want to create a new function that i want to call print all and this function should take an unlimited number of arguments and then inside of the function i want to print all arguments but the problem is i don't know how many arguments i am going to get now one thing that you might have already figured out you could add some parameter called arguments and this arguments would be a list meaning if i run print all and add a list in here with let's say one two three four five and hello now inside of the function i could run for argument that is not how you spell that in arguments and i want to print the argument and this is indeed working via the list we can basically add as many arguments as we want and this would still be working just fine there's no limit on this although this is kind of annoying to work with and because of that python has a special way to work with unlimited arguments and this is called let me add a comment here it is called list unpacking and how this works is we are adding a star before the parameter that we want to unpack and now what i can do when i'm calling the function i can remove this list here and just have unlimited values and if i run this now we are getting the same result so what is happening here and i think the best way to understand this is just to print what we get so let me print the arguments and run the code again and now you can see we have a tuple with all of these values here and then later on inside of the function we are just looping over this tuple and printing each item inside of it that's all that's happening in here and that is essentially all the unpacking operator does it looks at all of the arguments we potentially have and then return all of them as a tuple and we can use it along with other parameters for example if i added another parameter here let's call it first i want to print my arguments and i want to print first and let's see what we get we get one and then we get all of the other items meaning what happened in this function call here python sees that this one here is the first position argument and we have one parameter so python is putting this one in there and then it sees we have a list unpacking arguments and we have a ton of arguments here so all of these are being stored in this arguments as a tuple and once we have that we can work with them inside of the function and this would also work with a parameter after the list unpacking although for this one here we would need keyword arguments so let me print the extra parameter here the one that comes after the list unpacking if i run this now we have print all is missing one required keyword only argument extra and python here is quite specific we want a keyboard argument for extra and this extra here since it comes after the unpacking has to be a keyboard argument the reason for that is that python by default doesn't know when this list unpacking ends and when this parameter starts but well we can fix that quite easily let me remove the error message i can assign extra another value let's say 12 and remove this 12 here if i run this now this would be working again and here are the values we are getting and with that we have simple list unpacking and now we can essentially add unlimited numbers of arguments inside of our functions now this you can actually make even more powerful and how this would be working is with keyword unpacking and for that let's create another function and this let's call it print more and here i again want to have my arguments and those i want to unpack but now i want to unpack them again and those i want to unpack but now i want to use two stars and you see in a second why and i guess inside of this function let's just print the arguments of what we are going to get and let me comment out print all and let's call print more what this double star arguments does is it looks for keyword arguments and then unpacks all of them inside of a dictionary so we have arg1 could be one then we have arc 2 is going to be test and finally we have arg3 is going to be let's say a list with 1 2 and 3. if i run this now we get a dictionary with three key value pairs we have arc one with the value one arc two with test and arc three with a list and those are the three arguments we passed in here or keyword arguments to be more specific and we're getting this dictionary because of this double star here now so far we haven't really learned how to work with dictionaries so we don't really know how to use this dictionary but we're going to learn about that in the next major section so for now don't worry too much about this but we are going to work with this quite a bit more later on when we learn more about dictionaries for now all you have to understand is if we're using double star and arguments then we get all of our keyword arguments as a dictionary returned in our function and what you can also do finally is combine these arguments or the list unpacking arguments and the keyword unpacking arguments inside of one function and for that let's create a final function let's call this one print even more and in here i want to have my arguments and i want to have my keyword arguments and these arcs and quarks is what you see quite often it's just a shorthand for arguments and keyword arguments and now inside of this function we could basically pass in whatever we want it would all be captured by these two parameters let me print the arcs and the quarks and now i can comment out this function call and add print even more and now in here i can just add whatever i want let me add hello and true and then besides that i can also add i know test is going to be one test two is going to be five whatever you want in here and now if i execute the code we get a tuple from the arcs parameter and the dictionary from the quarks parameter and even if you didn't add anything in here so if i didn't have any keyword arguments it would still work i would just get an empty dictionary and that means if you have this kind of setup as long as you add any kind of parameter that is valid python code into the function you are going to execute that function or at least you're not going to get an error in this stage of the code and well with that we have covered some really powerful stuff and let's practice it actually and what i want you guys to do let me add an exercise down here and what i want you guys to do let me paste it in here i want you guys to create a calculator function that prints the sum of an unlimited number of numbers or what a limited amount of numbers so pause the video now and try to figure this one out yourself all right let me paste this exercise here so we have all of our function at the top of the code and i want to create a new function that i'm going to call calculator and in here we want to have an unlimited number of numbers so i want the tuple or the list unpacking operator and let's call it args and now essentially what i am going to get in here is a list let's actually print it so i want to print my arguments and now let me comment out this function here and i want to have my calculator and add a random amount of numbers if i run this now we are getting a tuple with the numbers we are passing into it that's a really good start what we have to figure out now is to get the sum of all of these numbers and this we can actually do quite easily but let me do it over two lines so it's a bit easier to read i first of all want to create a new variable let's call this one the result and the result is going to be the sum of my arguments remember here this argument or these arcs is going to be a tuple and tuples can be used with the sum function and the sum function is just going to return the sum of all the numbers inside of that list this list here in our case and once i have that i want to print the result so now if i run this and we are getting 21 this seems accurate if you wanted to be more efficient with your code you wouldn't actually need this result here so you could just print some of the arguments and not the result at all let me comment it out this one would also work just fine although the earlier one was a bit easier to read so let's stick with this one and with that we have a function that uses list unpacking alrighty welcome back in this part we are going to talk about functions and scope which can be a really annoying but very important topic basically what it means is that variables created inside of a function are only available inside of that function and this is called a local scope and if we are creating variables outside of a function we are creating a variable in the global scope and the problem a lot of beginners have is to combine the local and the global scope and i think all of this is going to sound a bit cryptic so let's do this in a bit more of a practical way here we have a completely empty python file and i want to create a variable i called a and assigned a value 10. it doesn't really matter what it is and after that i want to create a function let's call it test func we don't need any parameters and in here i want to print a and this is going to work if i print test func i can run this we get 10 all of this is working perfectly fine and there are no problems whatsoever however now we can do something weird let's say i want to get a and add some kind of value to it let's say 2. if i now run the code we are getting an error and the error we get is a local variable a was referenced before the assignment now to understand that we have to understand the local and the global scope and this a here is a global variable and we know it is a global variable because it was not created inside of a function it is just there by itself however this test function has a local scope and the reason why we got an error is because when we are creating a variable like this a inside of the function we are creating a new variable inside of the scope of this function only here and since we are now adding a value to it when we are creating it python gets confused because there is no original value at least according to python what we could be doing is set this a just to 2 and now run this again and this is going to work and now this might be even more confusing because now we have an a inside of the function and an a outside of it and to python those two are completely separate variables there are no connections for python and the reason why there is no connection is again because this is a local scope of the test function and all the variables we are creating inside of it only exist inside of this function meaning what i could also do now is create another function let's call it test func 2 and in here again i can create variable a again let's give it another value 200 and print a again and now i can run test func 2 and run all of this and now the value for this a here is going to be 200 the one we are getting down here and again the reason why this works is that each of these functions have their own local scope and on top of that we have this global variable here and understanding scope does take some time but there's one really important thing i do want to cover and that is that functions are supposed to be separate from the rest of the code this scope isn't a necessity it's by design and the reason is that once the code becomes more complex it is really easy to run out of variable names which can be very annoying for example for the car we have we could have one function for the battery and one function for the tank and both might have some kind of capacity variable and because of the local scope this is perfectly fine we can reuse that word if we didn't have functions we would have to play around with that like capacity battery capacity tank but then if we have more more capacities this gets really annoying and this is one of the main reasons for scope inside of functions that we want functions to be separate from each other so we can focus on one function at the time so let me put it in red local scopes inside of a function help us keep things organized especially later on when we are writing more complex code this is becoming incredibly important and incredibly useful as well but right still when you get started with this it's very very annoying so let's talk about the rules of scope they are not that complicated the first one is that every function has its own local scope and every local scope is separate and let's play around with that one and this we have actually already seen in practice we have test func here and testfund2 and both of those have the variable a inside of them and this variable a is completely separate for each function and i guess just to keep with the example from earlier this could be something like capacity and i could print that capacity as well and we will get different numbers and i am probably repeating myself but this capacity here for example only exists inside of this function here and this also means i couldn't print capacity or well i could but python would give me an error that name capacity is not defined and the problem here is that this capacity we are trying to print in the global scope but capacity does not exist in the global scope so i can't do that i can only print capacity inside of the local scope of the test function because in there it does exist and well that is the first rule of scope inside of a function for number two we have global variables and those can be accessed in the local scope but they cannot be changed or created at least not by default and let's have a look at this one and practice a bit more this one is really important and let me comment out all of this so we have an easier example and this is actually what we have seen earlier so let me run test func let's call it test function to keep things a bit more organized when we started this part i just printed a and this did work meaning now if i run test func 3 we get 10. and what happened here is we are creating a variable inside of the global scope and then inside of the local scope of the test function we are printing this and if we are running all of this we don't get an error and we are printing the global variable this is working just fine and the reason why it is working is because we can access global variables inside of a function however what we cannot do is update the value meaning we couldn't do something like a plus equals two because then we are updating the value which python doesn't like now with that we have the problem of scope the question now is how can we solve it and for that we can use parameters global and return and parameters we have already seen it's just normal function parameters and those allow us to pass global variables inside of the local scope of a function the more interesting ones are global and return and i do want to emphasize straight away that global is a very easy solution to scope but not a good one you will see in a second why but the one you want to use the most is return this one is much better and global you generally want to avoid but let's actually have a look at how they work the first way to overcome the local scope of a function is by declaring a variable to be global and this you do by just typing global and then the name of the variable you want to declare as global in my case a and now if i run this this is working just fine the reason why it is working just fine is because when python now sees this a plus equal to we are telling it that this a is a global variable which means python is now looking in our global scope for the variable a and then we're using that value and if you really wanted to you could declare global all of your local variables inside of every function you ever write and then never worry about scope ever again which i guess would be possible but a really bad solution you are supposed to be using a local scope and keep variables inside of that which is why global is not really used that often and when it's used it's not really looked at favorably upon you generally want to avoid it a better way would be using parameters and return and parameters we have already seen so for this test function we can just create a parameter let's call it a as well and now when i'm calling this test function free i want to pass in my and if i run this now we are getting 12 again meaning if you want to update a global variable inside of a function you would want to use a parameter that is generally how you get global variables inside of a function and then work with them and to get values outside of a function you usually want to use the return value and in my case for this function i want to return the value a and this return is the same return that basically anything in python does it's just a custom implementation of that principle meaning if i have that i can comment out my print a and now when i run this function it is going to return the value of this a i could for example print it and if i run this i get 12 again or 10 plus 2. and just to go over what's happening here i first declare a 10 inside of the variable a inside of the global scope then this a i pass into the function so we have a parameter inside of the function that is local to this function only and to this value we are adding the integer 2. and after we are doing this we are returning this new value and then this value is being printed with the print function and we are getting 12 and all of this is working really well and if you wanted to update this value here you could even do something like a equals the test function with a and now we could print a and get the same result and this is then how you would actually want to work with functions that you're using parameters and a return statement to keep everything inside of the function organized and separate from the rest of the code and especially for beginners this is generally something kind of confusing so i guess when you are just getting started using global can be okay sometimes but you generally want to rather use return it is a much cleaner way all right let's do an exercise on all of this and let's see how well you understand it and basically what i want you guys to do let me copy all of it i want you guys to create two global variables called multiplier and has calculated multiplier should have an integer and has calculated should be set to the boolean false what integer you set is entirely up to you i really don't care after you have done that create a function called multiply calculator in this one should take one argument and then calculate the multiplication let me put this on another line it simply multiplies that number that's just about it all you really have to do is inside of the function multiply the parameter with the global variable multiplier and once the calculation is done set has calculated to true and that is this global variable has calculated then store the new number in a variable called result and return it from the function and finally print a return value of the function after it was called with the number okay um probably read for this a couple of times it's a tiny bit longer but pause the video now and try this one yourself alrighty let's do it together now and let me comment out all of this at the beginning so we don't get confused first of all i have to create two global variables one is called multiply and this one i want to set to an integer let's say 5. and after i have that i want another variable called has calculated and this one by default is going to be false and with that we have these two parts already covered next up i want to create a function called mold supply calculator and this one takes one argument so it needs one parameter let's call it number meaning now we are basically here so next up i want to do this step here i want to multiply my number with my multiplier and this is perfectly fine for python because remember we can use global variables inside of the local scope so this multiplier here is from the global scope so we can use it but we couldn't update it but next up we have to take care of the has calculated and set it to true this part here and for that i want to set has calculated to true but here now we have the problem this is the local scope so we cannot update this global variable here and i guess for now the easiest way of doing this would be to set global has calculated and well with that we have this part covered here now next up we have to store the new number generated inside of a variable called result and return it and all i really want to do in here is the result is the result of well this operation here and let me put this below has calculated that feels a bit cleaner and now what i want to do is to return that result meaning whenever we call this multiplication function we are returning this value here and this i want to use with print and i want to multiply calculator and in here i can add any number i want let's say 10 and let's see what we get 50 which is 10 times 5. so this is working just fine and what i can also do now i can print as calculated and this is now true so as soon as we're calling this function this is being updated although there's one really important thing about the return statement that i forgot to mention earlier and that is that return ends the execution of the function for example if has calculated is after return and i run this again has calculated is still false because this has calculated is equal to true is not being executed and that happens because return ends this function call the function essentially ends here this is something you do want to be careful about but right with that we have scope and again scope very early on can be kind of a tricky topic so i hope all of that makes sense but for now don't worry too much about it just play around with different examples of code and come back to this video when you get to something more complex it will become more important and i hope eventually starts to make more sense for this part we are going to cover lambda functions and lambda functions are fortunately fairly simple all they really are are single line very simple functions and the syntax for them looks like this we have the lambda keyword then we get whatever parameters we want to use and then we have a colon and at the end we have an expression and this is the actual code that's really all it does it's a single line function if you have some very simple functions you want to work with and you don't really want to write a whole function this for example could look like this where we have lambda then we have an x parameter and inside of the function we are just adding x plus 1. and an important thing about lambdas is that the result of this expression this one here is returned automatically meaning when we are passing 10 in here this lambda function returns 11 automatically and i guess let's have a look at this in practice this shouldn't be too hard all right once more we have a completely empty python file and i want to create a lambda function and let's use the example i've just mentioned so i have a lambda function and the one parameter i want to use is x and what i want to return is x plus one and this is then the entire function how you would use this is by assigning it to a variable and this variable now contains a function meaning we can call it by using brackets again and passing in any number we want let's say a 10 and if i run the code now we don't get anything because we have to print this value let me print it and we get 11. and that is the main idea of lambda functions it's basically very very simple functions that only consist of one line of code i guess a slightly more useful one could be let me copy this one here let's call this one simple calculator and for this lambda i want a and b and all i really want to do is return a plus b meaning now i can call my simple calculator and pass in let's say two and three if i run this we get five obviously right now these examples are so simple that you wouldn't even create a function for it in the first place i guess instead of this simple calculator you just write 2 plus 3 and you would get the same result if you can type properly so why would you ever use these kind of lambda functions and there are two main reasons that we don't really are going to cover in too much detail the first one is that some functions want our functions as argument and this is something we are going to see later for example python has a sort function and this one sorts any kind of list for example a list like one two three four and five and we could sort this if it was unordered let me mess it up a bit to something like this to order this function python is expecting another function to tell it how to order this list and this function would usually be a lambda because we don't want anything too complicated we are going to cover this later on the other examples where you see lambdas fairly often is with graphical user interfaces and essentially what happens in there is that every button gets one lambda function because a button would only return a value like 5 for example so you don't really want a full function you just want some very simple line of code that executes some basic thing when a button is being pressed so this could be really useful but for this introduction to python we are not going to cover it but alright with that let's do an exercise and then we should be done with it and for the exercise i want you guys to create a lambda function that accepts one argument that should be an integer and if the integer is greater than 5 return hello and otherwise return by and then obviously when you have created this call this function and print the result let me comment out these lambda functions here and i want to create a new lambda function that accepts one argument let's call this one x for the parameter name and now i want to return hello if this x is greater than 5 and by if it is below 5 and for that i want hello if x is greater than 5 and if that is not the case so else i want to print by and this lambda function i now want to assign to a variable let's call it x but it doesn't really matter what it is and now i can print my x and pass in a free we get by and if i pass in a 10 we get hello and with that we have covered lambdas they honestly aren't that difficult and you really aren't going to use them that often so don't worry too much about them all right next up we have one final topic for functions that is actually really important although it might not seem that much for this part we are going to talk about documenting functions and this is incredibly important although we are not adding more functionality all we are doing in here is explaining what our function does and this might not seem important but it really is because functions can get really complicated so you want to explain them and this is something you are going to notice when you are starting to code where you are writing a function and then don't look at it for a couple of weeks you probably have absolutely no idea what you did and when you look at other people's code it might be even worse and well explaining what your function does is just good form and really helps you when you work with other people and there are two things you can do to your functions to explain what they do the most common one is you just add some explainer text and this is called a docs string and besides that you can also add what is called type hinting and all that really means is you indicate what you expect for the parameters and for the return value of the function and if you have all of that your function should make quite a bit more sense so let's implement all of this all right here we have a very simple example of a function if i run this we are just printing two arguments so obviously this isn't complicated but i just want to keep it simple and to explain what your function does you can add what is called a dog string at the beginning of a function and a dog string you create with quotation marks like any other string and for a dog string you always want three quotation marks on each side it looks like this and sublime essentially turns this into a comment by default and now for this dock string you can write whatever you want or well whatever explains your function the best let's say i could call this one a simple function that prints two parameters and if i run the function we don't see any difference however now what you can do you can print the name of the function test in my case then dodge underscore underscore dock and underscore underscore again and if i run this i get the docs string of the function or a simple function that prints two parameters now why we're using two underscores before and after this dog you are going to understand later on for now just write it like this it really isn't too important for you right now just remember how it looks like i suppose another way you could be accessing this is by writing help and then test and if i run this we get some more information about the function and in here we also can see the docs string a simple function that prints two parameters and it is fairly common to use either of those to understand what a function does meaning if you write code with a team you really want to use this but well that's basically it it isn't that complicated now besides that what you can also do is to hint what you are expecting for these parameters and what the function should return and right now this function doesn't return anything so let's add return a plus b and now i want to indicate that for these parameters i am expecting integers all you have to do for that is to add a colon after the parameter and then add integer if you wanted to you could also set a default parameter for this and this you do in a normal way by just adding an equal sign and let's say 10 for this value and all this really means i am telling other programmers that for this a parameter i am expecting an integer and by default this parameter is going to be 10. and for b i also want an integer but i don't have a default value and with that we have some default parameters where we are indicating that we are looking for integers and let's say for b i want the default value of 0. and with that we are indicating to other programmers that we want two integer values that both have a default parameter meaning if i run the code now we can't see well not much of a difference because this isn't supposed to influence what the function actually does and besides that we can also indicate what is being returned from this function so this line here and this could do by adding an arrow after the function but before the colon that's really important and then here you again add the name of the type and here again use the name of the type you want to return for an integer this would be int i guess other data types could be str for string bool for a boolean list for well a list and dictionary for a dictionary but in my case i want to stick with an integer and now i can run this again and we again don't see any kind of difference and a really important thing you have to understand about type hinting is that all of this is optional and it can be ignored so for example what i could be doing is add a string in here and also a string in here i know let's say test if i run this now the function is still going to work let me comment out those two lines here to make it a bit more readable so now we have indicated for the function we are expecting an integer but when we actually call the function we are adding two strings and python doesn't really mind it still works just fine so you don't have to follow it it's mostly indication of what is being expected but alright with that we have covered all you need to know about functions in this section we are going to cover more advanced data operators and this is one of the parts where python is incredibly powerful there are lots of ways to manipulate data and get a certain kind of outcome there is a reason why python is really popular for data science and machine learning it is because there are lots of different ways to work with data so let's have a look what we can do what we are going to cover in this section is more advanced ways to loop over data we are going to sort data we are going to learn list comprehension a really important topic even though the name here is probably a bit weird and finally data handling if we want to import or export data let's get started by looking at more advanced ways to loop over data so in this part we are going to manipulate lists to get stronger for loops and this is a super powerful topic because very often python you want to merge a list and then loop over this merged list and for this for example python has a zip function that zips together two lists and you could also get the index for each of the lists when you use a for loop and i suppose all of this is going to sound a bit abstract so let's do all of this a bit more practically here we have a nearly empty python file and i already have two lists we have inventory names and inventory numbers and the scenario we have here is you are running some kind of warehouse and people gave you two lists one with the things in your inventory and then how much of that thing you have and for the order here you are looking at the index meaning the first item and the first number belong together then we have the second item and the second number then the third one and so on we are sorting things here by their order this could for example happen if somebody copies a column from excel it's very easy to get the problem for you is if you want to write a for loop and you have two lists you kind of have a problem if you want to access both of these lists at the same time so the scenario here might be you have some kind of website and on this website you want to display all of this information for customers so you want to loop over both of these lists but this you can't do right now you can either do for name in inventory names or you could do for let's call it num in inventory numbers but both of these for loops are going to be independent of each other so you have no way to connect the two python in this case has one specific function and that is called zip what zip does is it wants two lists we want inventory names in our case and inventory numbers if i print the result we are getting a zip object some point in our memory not particularly useful we're going to see how to use this in just a second but for now what you can do is to convert all of this into a list with the list function if i run this now we can see something much more useful we have a list with tuples inside and each tuple is right now the combination in this case of screws and of the number and these are again sorted by the index which is what i want in this case that being said this zip you hardly ever use in the list and inside of a print statement instead you would usually use it inside of a for loop and the followup here could be let's say for thing in and now i want to have the zip of inventory names and inventory numbers and this i can now print as the thing and let's see what we get there we go this is looking not too bad we have a tuple with our screws and how many of these we have but the issue still is we want to have each individual value to work with we don't want to have an entire list i guess what you could be doing here is use indexing to get one value from this tuple 0 would give you the items and one would give you the inventory number and you could access both like this and you would get the name of the item and how many you have this would work but it's kind of hard to read thing here really isn't too specific for that python has some really interesting functionality basically what we have seen earlier when we assign two values to two variable name instead of writing thing we could write for example name and number and now when python goes through this list and it sees a tuple let's say for the first example we have screws and we have 43 so this screws here and this 43 this would be the first item we get inside of this zip operation here it's kind of hard to read if you have a tuple and you write more than one variable name here python is going to unpack this tuple into these separate variables meaning in this case screws would be stored in name and the 43 would be stored in number and that way we can access them much easier inside of the for loop so name and number if i run this now this is still giving us the same result except now this is much easier to read and this is an operation you do surprisingly often i guess what we can do here to make all of this a bit easier to read we could use an f string and then i want to write something like let's say name and current index with the number if i run this now we get screws current index 43. i guess index isn't ideal let's use inventory that's better so we have screws current inventory 43 and this information if you give it to somebody designing a website would be very easy to work with another thing that you could be using here is called the enumerate function and this one is basically used to get the current index inside of the for loop i guess an example here could be if you are cycling over this list and when you get halfway into this list somewhere here you want to run some other code the question then would be how do you know when you are halfway into the list and for that you would have to know the current index i guess let me demonstrate how this actually works that should make much more sense we need enumerate and this is a function what it wants is some kind of list or something you can iterate over in my case i want to go with my inventory names and now if i print what this is giving us we are getting once again an enumerate object doesn't help us too much but if i convert all of this into a list i am getting the index and the item from the list this zero here is the index of this screws inside of the list wheels would be number one metal parts would be number two rubber bits number three and these are the numbers we are getting down here and again this enumerate you would basically always use inside of a for loop let's say again for thing in and now i want to have the enumerate function and inside of this let me print the thing if i run this now we are getting again a tuple with the index and with the name of the item and just like we have done up here we can unpack this again what you usually see is index and then the name of the item or whatever you want to call it this is entirely up to you but index here is the common name for what enumerator returns once i have that i could do something let me print an f string again and here index with the name of the thing and there we have the current index and the screws and this i could for example use if the index is let's say the example i had earlier if we are halfway into this list i want to run some other code maybe i want to notify my boss that my operation here is halfway done something like that i want to check if the length of my inventory names is equal to the index and this will give me the whole list but i only want half of that and then here you do want a flow operator so you're getting an integer or a whole number because the index is always going to be a whole number in and of itself and if that is the case i can print something like half way done now if i run this i am getting the first half and then the second half although you might have to tinker around with this to get exactly to the halfway point the most important part here is that enumerate gives you the current index where you are inside of the list when you are using a for loop and with that we have two functions you see very often alongside four loops the other one we have seen earlier was the range function which also is almost always used alongside the for loop we can do an exercise and then finish this part and what i want you guys to do is to combine zip and enumerate to get some kind of string like screws then in square brackets id 0 and then inventory and then the number of inventory items for each of these numbers from this list here so pause the video now and try to figure this one out yourself let's go through it step by step first of all we need some kind of for loop and let me start by just writing thing we can refine this in a bit and i want for thing in let's start with inventory names in here i can already print something we definitely didn't have string and i want to have my thing this should be in curly brackets let me run this now i forgot we got lots of stuff because i have to comment out all of this if i run this now we get the different items from this list not a bad start we have the first word but well we're getting there i suppose next up i can put all of this inside of the zip function and then combine inventory names and the inventory numbers i called it if i run this now we're getting a tuple we essentially create a new list full of tuples and each tuple will be captured by the variable thing and this is what we are pasting inside of here this we can unpack i want to have my name and i want to have the number this is basically what we have done up here i want to have a name and then i can add my inventory with a colon now i need curly brackets and the number running this now gets me screws inventory 43. we are definitely making progress finally we need to get the current id of each of these objects and for that we need enumerate what that means is i want to wrap the entire zip function inside of a numerit i find this one very hard to write you might struggle as well and before we work more on this i want to check out what we actually get returned from this thing here it's quite a complex one so let's see if i print thing in here we have one tuple and inside of this tuple we have two values the first one is the index the second one is another tuple that we got from this zip operation here unfortunately now this thing is kind of annoying to unpack we can't do this easily what you might be very tempted to do here is something like index name and number but if you run this python is not going to be happy because we have not enough values to unpack what that means is that python here returned two items inside of some kind of data structure in our case this is a tuple with the index let's say 1 and then the other value is a tuple with the let me call it the name and let's say 43 for the number and don't let me forget the closing brackets that is important now python looks at this tuple and it's these two items this one and this one but we are telling python inside of the for loop down here that we want to unpack all of this into three parts but python doesn't know how to do this because it only sees two items as a consequence we are getting an error what is most efficient here is to only use two unpacking variables we have index and then we have let's call it the inventory to pill let me print the index here and the inventory tuple now we're getting all of this not ideal but definitely something you can work with let me get rid of this one here and uncomment all of this now what we want the name is going to be part of the inventory tuple and it is the one with the index zero because remember this one is just a tuple nothing else after we have that i want something like this square brackets with id and then the current id meaning i need square brackets inside of that the word id a colon and then curly brackets with my index finally i want to have my inventory tuple and now i need the first item inside of this tuple and with that let me run it we get all of the different items properly formatted i suppose the most important part here is to understand this and what different values are being returned definitely play around with this one and understand how these things interlock with each other zip first of all returns a new list with tuples inside that are zip values from names and numbers and then enumerate creates a whole new tuple by adding an index and then adding the original tuple it got from the zip operation for this part we are going to cover one of the most powerful parts of python and that is called list comprehension a very strange name but it is for a super powerful concept basically what a list comprehension is is a way to create a list on one line of code and this can get surprisingly powerful you can either use it to create a list or to manipulate existing lists like to filter out values for example but let's keep it simple for now and let's say you want to create a list with the numbers from 0 to 99 for that right now you will probably write something like this you start with an empty list then use before loop so for num in range from 0 to 100 because remember we only go up to this number we don't include it and we want to end at 99 and then inside of this for loop we are getting our list and we are appending the number we are getting from this for loop fairly simple operation and since it is so simple wasting three lines of code on it feels kind of pointless as a consequence we would use list comprehension this one would look like this it's kind of comparable to a ternary operator actually we still keep most of the words here so we have four the same four we had here then we have num we still have the num here then we have the in in both of them and also the range stays the same as well we pretty much put the whole line here after the number the major difference now is instead of writing my list dot append we only need num inside of this this one automatically gets appended to the list you are assigning it to and that way you can write all of this much more efficiently and this is only a very simple example this can get significantly more powerful but let's have a look at some easy examples here is the operation i have just shown you in the slides and this if i print my list we are getting the values from 0 to 100 inside of a list and again here this is three lines of code for something that ultimately is kind of simple so let's do all of this in one line and let me call it my list comprehension or just comp and in here we always need square brackets this always has to come in there and then we again need this entire line here as a matter of fact let me actually copy it so we have four num in range 100. the difference now is we don't add a colon and then the operation we want to do like my list dot append none of this is going to happen instead the value we want to return to this list comes as the first word inside of it and this will automatically be appended to this list as a consequence we would just need this we need num for num in range 0 to 100 if i print this now we are getting exactly the same outcome all we really have done is condensed this entire line here into a single word with the entire rest of the for loop staying identical that being said now you can make more changes to this part here for example you could multiply all of this by two run this again and now you have every value multiplied you could also put all of this inside of let's say a tuple and then add num num and num and now python would automatically assign each value inside of the number basically what we are doing is this num looks at the range and gets the values from 0 to 99 and then it assigns each of these numbers to one of the values inside of the tuple and this is then what we're getting here so we'll get 0 0 0 1 1 1 2 2 and so on and this is only the most basic kind of list comprehension you can do and there's one way to make this significantly more powerful you can combine list comprehension with the ternary operator which is just a fancy way of saying you can add if to a list comprehension there are actually two ways of doing it the first one would be at the end so num for num in range 0 to 100 if a certain condition is true although an important thing here is else does not work i don't actually know why but you just get an error if you add an else after this however the other way would look like this where you first add the value you want to return and then the conditional statement so if num is 10 else 0 and then the for loop we have seen up here and choose whichever works better for you both are totally fine just keep in mind the second one is a tiny bit more powerful i honestly have no idea why the first one doesn't work with else statements it might be something internal and this is something really powerful because you could be using it to filter other lists let's have a look at this in practice actually and let's do some basic examples first i can add an if statement here at the end and i only want to get these values here if the number is let's say below 20. if i run this now my list comprehension stops at 19. although again keep in mind else 0 for example would not work i would get an error that says invalid syntax so this is not good but what i have to do to get around that i would have to cut all of this out and paste it here now if i run this this is working just fine we get all of the two bits from 0 to 19 and then for any other value we are getting 0. and that is basically a trade if statements in here one example how you could be using this here are the two lists you have seen from the last part and i want to clean them up let's say i want to create a list with all of the parts that have less than 25 items so i want to select wheels because they only have 12 items and i want to select the screwdrivers because they only have 23 items and for that list comprehension could be really really powerful along with the other stuff we have already seen let me call it the replenish that's not how you spell that replenish list and now in here we want to look through all of these items and for that first of all we again need square brackets and let's start with thing for thing in and i want to again use my zip list because i want to access both of these lists and here i need inventory not numbers but names and now inventory numbers if i print now my replenish list i get the entire list inside of the square brackets so far this isn't helpful at all but now what i can do first of all this thing here instead of thing i want to name let's call it name and number and to get the same outcome again i would need my name and my number so far again we are still going to get the same outcome but now i only want to do all of this if a certain condition is true and in my case the condition is if the number is below 25. if i run this now we are only getting two items with the name and the number attached to it which is a very nice way to get data out of this list here and this is a kind of operation you would actually do fairly often in python and list comprehension for that is what you would use very very often now what you can also do is to combine different list comprehensions let me add a comment here let's call it combine list comprehension although this one is going to get a little bit more complex but let's go through it in a really simple example let me create a new variable combined comprehension and in here first of all i want to have something really simple let's say x for x in range 5 then i'm going to comment out all the stuff we have done so far and print what we are getting from the combined comprehension we are getting the numbers from 0 to 4. this should make sense it is fairly simple at least i hope it is but now what we can do is put all of this inside of another list comprehension so all of the stuff we have seen so far for y in range let's say 10. if i now run this we're getting something that possibly looks a bit weird i think there's a better way of presenting this instead of printing the list by itself i want for row in combined comp print row and now if i run this we can see the entire output like this much easier to read and let's go through what happened here that is probably kind of confusing right now i think the best way to go over this is to separate these two lists we have an inner list this x for x in range five and then we have an outer range the entire list comprehension that's a terrible line let's do it like that's still a terrible line let's do it like this the yellow part is always this inner part here and this we now got multiple times we have one here one here one here and so on they are all x for x and range five the reason why we got this multiple times is because of this part here we basically created this list 10 times and that way you can create a list that contains other lists although still not particularly useful but where this system becomes incredibly powerful is you can put this yq for example into the original list let me actually demonstrate instead of just having the x as the value for this list i want to have instead a tuple with x and y if i run this now we are getting let me use different colors for this we have a tuple this tuple here and this tuple is inside of a list this list here that is the list we are getting from this inner list comprehension finally then we have a list of lists and this is the entire list comprehension and i suppose inside of the tuple we have the x and we have the y value x increases on every column and y is increasing on every single row e is y0 y1 y2 and so on with the system you can create incredibly complex data structures you could theoretically even add a third and a fourth list comprehension but by that point things are a bit overkill i think i would not recommend overthinking this it can get really complex and it doesn't have to be as complex if you really wanted to make something more complex you probably want to use a for loop but alright with that we can do an exercise and then we are basically good to go and what i want you guys to do is to create the fields for a chess board and just in case you had actually fun hobbies at school a chessboard has the fields a b c d e f g and h which is eight letters in total and then we also have the fields from one let's say one two three four five six seven and eight which basically means the first field you are going to get is a one and then you keep on creating more fields and at some point all the way at the bottom you should have h8 and if you want an extra challenge this is not actually a chess board because a real chess board would have the a1 at the bottom and the h8 in the top right i guess i can cover both see how far you get but pause the video now and try this one yourself let's get started by commenting out all of this and then i want to start let me call it chess board and in here i want to start with the square brackets for my list comprehension and i guess we can start with the numbers so num for num in and now we want range and let's start with 8 and let's see what we get i want to print my chessboard and i get the numbers from zero to seven which is not a chess board we need the numbers from one to eight for that i'm going to specify a start value here and now the end value is going to be 9. if i run this now we get the numbers from 0 to 8. we have the inner list comprehension now for the outer and now this might have been the one part where you struggled that was how to get each individual letter here and the solution is actually really simple all you need is to type the string a b c d e f g and h if you have this and i run this again we get this entire list except it's very hard to read so let me do it again for row in chessboard print the row there we go this is much easier to read the problem now is that we want to have the letter and the number this happens inside of this part here i want to have the letter and then the number if i run this now we have a 1 in the top left and h8 in the bottom right that's a good start although i guess doing this as a tuple isn't ideal but you don't have to you could totally create an f string here and in there i want to have the letter and i want to have the number now running this gets me something like this i think that looks a bit more appropriate the difference here really doesn't matter all that much and now if you wanted to invert all of this meaning that instead of the a1 here you would want this top part to be h1 and then this part down here would be a1 in a chess board the bottom left field is always a1 and the top right one this one here would be h8 to achieve that you could just type out this string here in reverse but that would be kind of annoying and not exactly scalable if you wanted to make something larger but here we can do something really clever we can use slicing remember this from quite a few videos ago we are specifying a start an end and a step size now the start and the end if we leave them empty is giving us the entire string but now if we specify for the step size negative one then we are going to go backwards over the string now to understand this part you have to understand return statements basically what happens here is originally we just returned this string but now because of this slicing operation the four letter in is looking at the entire operation here because this is what gets returned this is really something you eventually understand when you play around more with python it does take some time but now if i run this we are starting with h1 in the top left and a8 in the bottom right and with that we have a proper chest field i hope that wasn't too bad list comprehension especially early on can get very confusing besides a list comprehension we have other types of comprehension as well one for each type of container at least kind of and before i cover them i really want to emphasize that list comprehension are by far the most common comprehension you are going to do i am going to include these mostly for completion sake but you probably aren't going to use them very much comprehensions work quite easily with dictionaries and sets this would look like this for a dictionary and like this for a set set is actually super easy all we are doing here is we are replacing the square brackets with curly brackets and then we are done that is literally the only difference for a dictionary the one thing you really have to keep in mind is that we always need the key then a colon and then a value in this case both of them would be num meaning we would create a dictionary that would have key value pairs like 1 and 1. then 2 and 2 three and three and so on not exactly useful but it's something you can refine and that brings us to the final type of comprehension a tuple comprehension this one works a bit differently in here you are still using num for num in range 10. the problem is for python this kind of operation was already covered using the normal brackets as a consequence this operation gets a bit weird to create a proper tuple out of it you would need the tuple function but after you have done that you are back to a normal tuple with whatever operation you have in here so not that much of a change and that is basically it let's have a look at all of this in code and let's get started with a set comprehension this one we are creating with curly brackets and now in here we can just do the normal comprehension stuff for example num for num in range let's say 100 and if i print the set comprehension i am getting all the numbers from 0 to 99 this is basically all you have to know and well let's get to the next one the much more interesting one the dictionary comprehension for this one we again need curly brackets but now the important thing is we need a key and we need a value but once you have those two you would still continue with four x in some kind of list in my case let's go with num in range 100 and now i have to define values for key and for value i guess from the example i could name both num and then print the entire dictionary comprehension and now we are getting a dictionary although i do want to fix the typo that is annoying me there we go now what we are getting in here is a dictionary with lots of key value pairs this is one this is another this is the third and so on and in here we have set the key and the value to the same number as a consequence they both have the same number which really is not useful to make this a bit more interesting we could for example get the power of num and run this again now we can see a bit more of a difference the key is 2 for this one and the value is 4. 3 gets us 9 and so on this way you can at least see different values that is basically it for dictionary comprehensions finally we have tuple comprehensions and in here you would use normal brackets and now you would still write something like num for a num in range 100. if i print this tuple comprehension we are getting a generator object at some location in our memory which well is really not useful that being said you could work with this super comprehension for example in a for loop i could write for let's say value in tuple comprehension and i want to print the value if i run this now we are getting all of the values inside of it meaning this object is working as intended we just can't really see the result to actually see it we would have to convert it to a tuple and then we are done if i print the tuple comprehension run this again now we can see the result we would expect the reason for this is that these normal brackets are used quite often in python and in this case they are in conflict with the tuple comprehension but that's not something you have to worry about too much i have never ever seen anybody use a tupel comprehension to be honest the one thing you see once in a while is a dictionary comprehension but most of the time you see a list comprehension and nothing else and i guess with that we can do an exercise what i want you guys to do is to create a dictionary with the keys a b c d and e and each key should have a list as a value with the values one two three four and five that should be one list for each of these keys pause the video now and try to figure this one out yourself all right let me start by creating an exercise comprehension or whatever you want to name it since we are creating a dictionary i want to have my curly brackets now in here let's get started by creating the keys we need to format key and value then for x in some kind of iterable and since these are the values that change the iterable here should be a string with a b c d and e for proper naming here let me rename this x to a letter and now my key should be this letter and since the value doesn't change it is always one two three four and five i can just type the value in here and now all i have to do is to print the exercise comprehension run all of this and we can see we have the dictionary here this one worked pretty well let me comment out the earlier part there we go this looks much cleaner in this part we are going to cover functions that take functions as argument which is probably going to sound a bit weird but let's talk about it when you pass arguments into a function it is perfectly fine to pass a function as an argument into another function and let's do this by example to actually illustrate what i mean and for that i want to use the sorted function this one sorts some kind of iterable in some kind of way it looks like this the name of the function is sorted we have to pass in some kind of iterable most of the time it's going to be a list but it doesn't have to be and then we need some kind of function to tell python how it needs to sort this list for example do you want to sort the list from the smallest to the largest number do you want the opposite of that or if you have for example a list that contains strings how do you want to sort that do you want to go by the character in the alphabet do you want to go by the amount of characters inside of each string it really depends here python doesn't know by itself meaning you have to write a function to tell how to sort this iterable and this is the function we have to create ourselves which well isn't that difficult but you do have to understand the system so let's have a look at this straight in code in my code i already have one list and this list right now is kind of unsorted it's a bit random and to sort it i need the sorted function and in here at the very least i have to pass in one argument and that is the list i want to sort what i get returned from this let me print it i am getting the list sorted and this you usually do with a list as a matter of fact a list even has a sword method that sorts the entire list if i run this and let me comment out this line here list.sort after i run this i can print my list1 and now the list was sorted as well this method and this function they are basically doing the same thing but this is not what we are here for we want to look at sorted via the other arguments and there are two you can pass in here one is really easy and one is the function i just talked about but let's start with the easier one the one argument you can use here and let me use a keyboard argument we want to specify a reverse and then here python expects a boolean if i set this to true it reverses the entire list now we go from the highest to lowest instead of the lowest to the highest that's basically it what is much more interesting is the key argument or parameter because in here python is expecting some kind of function and let me actually demonstrate a use case where you would need it for that i have another list that i want to store in let's call it list 2. in here i have a list that contains two builds in each tuple we have for example a and 3 we have b and 10 c and 6 and so on and this would be really difficult to sort if i print sorted and list 2 let me comment out the first part and run this again we now get well no change in the list python just doesn't know what to do with this list but in my case i want to sort this list by the integer inside of each tuple meaning this one here should be first then the second then this third and then this last and for that behavior i have to tell python which value to access and for that we have to create a function let me do it straight below the list although most of the time you would do it straight at the top of the code but in my case i'm going to keep this a bit more readable i want to create let me call it a sort function and this is always going to need one argument let me call it item and now how this is going to work inside of my sorted function i have to specify a key and for this key i want to have my sort function and really important now you do not call this function there should not be any brackets after the sort function except to close sorted and print you are only passing in the function you are not calling the function python or well sorted does this one internally so you don't have to do it and basically what is happening is that sorted goes through each of these tuples in this example and passes each tuple inside of the sort function as an argument and then this function has to return some kind of integer let me write i n t and the size of this integer is going to determine how we are ordering this list so in my case all i want to do inside of the function i want to return item and then 1. for example if i'm getting this tuple here as an argument all i really want to do is to pick this integer and return it and then python knows what to look for inside of this list for the sorting algorithm and that is literally it if i run this now we can see the list is sorted now via the integer inside of the tuple so we have 3 5 6 and 10. and of course inside of this function you can be really fancy and add a whole bunch of stuff the thing is most of the time you are not going to do that in almost all cases you simply want to tell python a bit more in detail what kind of value you are looking for this is very rarely becoming complicated as a consequence you hardly ever write a dedicated function instead you use lambdas let me actually copy this line and now i want to have my list 2 and for the key now i don't want a function instead i want a lambda function and for this one we again as the first argument here we have to specify what kind of parameter we want that is this item here this one would be equivalent to this item here inside of this we have to tell python what to do with this item in this case all i want to do is get the item and then pick the first index and since this item here will be returned automatically this is equivalent to all of this and with that we are done i can run this now and we get the same result so this is working just fine and that is essentially it now with that we can do an exercise and for the exercise i want to stick with the same data we have used earlier this one here we have inventory names inventory numbers and i already used zip to zip these two together meaning now let me comment out all of this i want to print my combined list run this one now and we have a list with tuples inside and inside of each tuple we have the name of the item and the amount of how much we have of that item and i want you guys to do two operations actually number one is sort this list by inventory numbers for this list the first item should be this 12 year with wheels next up should be 23 with screwdrivers and so on and number two sort this list by length of the inventory name this means that the longer the word gets the later it should be in the list i guess what should be first and screwdrivers should be last we are looking at the length of each string here and well pause the video now and try this one yourself let's start let me call the first one sorted comp by numbers and here i want to have the sorted function and inside of list i have to first of all pass my combined list now i have to specify a key and for this one i want to have a lambda function let me use a num here as the parameter name since the argument we are expecting is some kind of tuple let's call this one the inventory tuple all we want to do with this one is to get the inventory tuple inventory tuple and get the item with index number one we should be done let me print this sorted comp by num and there we go the first tuple is now with 12 then 23 43 43 95 and 421 this is working just fine so next one we get the sorted comprehension by name once again we are going to need sorted i want the combined list and now we have to specify a key i guess here again we are still going to get the inventory tuple inside of this we still want to look at the inventory tuple but now we want to have the index 0 because we want to look at the strings and we don't want to return the strings we want to return the length of the string meaning we want to have the length function and then the result of that is going to get returned i can now print the sorted comp name and we get the first item is wood there are four letters in here then we have screws this is six characters wheels is also six and metal parts is definitely more than six meaning this seems to be working just fine and with that we have the sorted function but there are two more functions like it that i would like to cover for this part we are going to look at two more functions that take functions as arguments besides sorted we also have map and filter at least for basic python now that being said you probably are very rarely going to actually use or see them they have basically been replaced by list comprehension which is a more elegant way to do all of this but let's have a look at all of this in practice once again i have an empty python file except now i have my list that contains a list with the numbers from 1 to 5. the two functions let's start with map all that this one really does is it changes values with a function inside of a iterable just like we've sorted we have to start by using the map function name and in here we need two arguments we need some kind of key and then we need an iterable in my case the iterable is going to be my list for the key i want to create some kind of function and in my case i want to create a power function so basically what map does is it cycles through this list which in our case is going to give us one two three four and five every single one of these values will be passed into the power function as an argument and then whatever the power function returns will be used to create a new list instead of sorting it we are just changing every single value map in a way is simpler than sorted i want to create a power function and this one again is going to need some kind of parameter in my case i'm going to call it num and now we have to return what we want this new value to be in my case i just want to take the power of this num and that is all we needed now i can print all of this and let's see what we get we are getting a map object cool completely useless but we can convert this to a list and then we can actually read it if i run this now you can see we have taken the power of every single value inside of this original list one remained a one but the two became a four and the three became a nine and so on we went through this list and we applied this function to every single value and that is literally all that happened here once again since it's kind of annoying to write a whole function for something so simple we are usually going to use a lambda function we need the lambda keyword and now the name of the parameter in my case i want to go with num all i want to return here is num and the power of that if i run this now we get the same outcome if you compare this to list comprehension it really should look kind of familiar we're going to talk about this in a bit more detail but first of all i want to look at the filter function and this one filters out values from a condition for example let's say in this list here i only want to get the values that are smaller than four one two and three we would need the filter function and in here again we are going to need some kind of key and then an iterable we want to change the iterable in my case is going to be my list and for the key i guess we can create another function let me call it get below 4 that is not an underscore and for this function we are going to need another parameter once again i'm going to stick with num i want to check if this number is below 4 so if num is below 4 i want to return true and if that is not the case i want to return false and this is the function i want to pass in here and this let me comment out all of the stuff we have seen earlier now i can print my filter and you might already expect what we are going to see we are getting a filter object which is useless for us but we can convert it to a list and then we can see now we only have values smaller than four essentially what happened in here is that filter looks for every item inside of this list we are again looking at 1 2 3 4 and 5. each of these numbers is going to be passed into this get below 4 as an argument and depending on what python gets returned here this item either stays inside of a list or it gets filtered out if python is getting true from this function the number is going to stay inside of the list one two and three all have the function returning true however four and five had the function return false as a consequence they were filtered out out of the list that is literally all that filter does i guess once again i can duplicate the entire line because we don't have to create a whole function we can use lambdas for that which is kind of how this was intended to be used i want a lambda in here i want my number and in here i want to run num is smaller than 4 and this works because python is going to convert all of this into a boolean value so if i run all of this now we are getting the same outcome except this line here is much easier and shorter than all of this and with that we have filter and map basically two functions you very rarely see nowadays why that is we can actually see from the exercise what i want you guys to do is to convert both of the power and the filter function so this one and this one here let me uncomment all of this i want you guys to convert this one and this one to a list comprehension and see how much you remember let me copy the two functions first and now i can comment out all of this here so we are not getting confused the first one is the map function and for this one let me do it straight inside of a print statement in here i need to square brackets for the list comprehension and now i want num for num in my list this is the list we have gotten all the way up here all we want to do is to get the power of it and with that we are actually already done if i run this now we're getting the same result except i think it's pretty obvious this is much easier to read than all of this which is why map is very rarely used nowadays if you really wanted to you could even use a function in here as well and this would imitate map even more so there's very rarely a reason nowadays to use map the main reason why you are still learning it is because some older code examples might use it and you know what they mean but chances are that you aren't going to use it yourself all right now besides that we can do the same thing for filter and let me comment out those two for this one again i want to have my list comprehension and i want num for num in my list which if i run this is giving me the entire list but now i only want this number if the number is smaller than four and running this is giving me the exact same result and again this is much easier to read than this one here which again is why filter is very very rarely used nowadays in this part we are going to cover file handling meaning we are going to open a file and we are going to write into that file which is surprisingly simple python is very capable of opening simple file formats the one we are going to see in this video is dot txt which is the simplest form of storing text on windows computers also works on a mac they are kind of universal besides that you could also open a picture and there are a couple of other basic file formats you could be working with but i'm going to stick to txt now that being said python could at least in theory open basically any kind of file let's say a blender file an excel file a word file a pdf document python can open all of them but most of the time you are going to need external modules to do that what those are and how to use them we are going to cover later in this series i guess as a good example here for some selfpromotion a while back i made a video on how to create a snake game in excel using python totally doable kind of fun although very strange but anyway let's have a look at all of this in code before we start coding i want to look at my folder this one is looking like this let me extend it a tiny bit inside of the code i have the python file itself and i have a txt file called test if i open this one i am getting a simple txt file with a bit of text inside nothing complicated but well we don't want to over complicate things this is the file i want to open and this is also the file i want to write in keep in mind here both the python file and the text file are in the same folder that is important to open it you have two ways you could either open and close it manually this means i want to create a new variable let me call it file and the function you're looking for here is called open and this open wants a file path and the name of the file in my case this is going to be test.txt let me actually print what we get so i want to print the file we are once again get some random thing that we can't read but this we could convert to a list and now we have the document as a list with all of the text inside notice here at the end of each line we have a line break the one we have seen all the way at the beginning this way the document knows where to end one line the one thing you want to be aware of right now is that we only need the file name because both files are in the same folder if that wasn't the case you would have to specify in what folder you are for example if the text was inside of a folder you would need folder then a slash and then the name of the file and if you want to go up one folder you would need two dots and that's basically it this way you can create file paths and find specific documents you want to open besides that there's one more thing that you do want to keep in mind and that is we have to close the file again if we had a longer code example and kept it like this we would keep this file in memory which wouldn't be necessary to do that you would need file.close if you run this again now you are not going to see any difference but this line removes the file out of the memory which is more efficient and with that you can open and close a file that being said this approach isn't really used that often because the better way is let me call it open and close it automatically the way you would most of the time import a file is with the with statement in here we need with open and then the file name this is still going to be test dot txt and now you have to write s and give this a name in my case i am going to go with file what's happened here is basically the same that we have done up here we opened a file just like we have done here and this file we are storing in a variable called file the same thing we have done up here the difference now is we have to write some indented code in here and as soon as this indentation is over then we are closing the file automatically that way we are not going to need this line here this is also more deliberate and possibly easier to read it's basically up to you both approaches are fine but this is the one you are going to see more often in here we could for example print and let me use the same line i want to print the list of my file and we get exactly the same outcome let me comment out the earlier part because this is the one i want to work with the most now python has a few functions that you can use to read documents especially txt files the one you're probably going to use the most is file.read don't forget the brackets if you're calling this you get a proper output from all of the stuff read basically converts this into something that you can work with more easily although keep in mind this read is going to return if i use the type function it is going to give me a string which means if i convert all of this to a list i would get a whole bunch of individual characters that don't help me that much the way you want to use this read function is just to get an overview of what you have it's kind of difficult to cycle through this but for that you could use something like for line and then i want the list of the file and now i can print the line and i want to comment out this part here and now i get basically the same thing since i'm not going to use this too much i'm going to keep it short but this is kind of all you need to know about it if you had other kind of data you could work more with this but that's beyond this video what is not beyond this video is write some file let me comment all of this out and to write a file we again need with open and in here i again want to open my document but now i have to specify another argument and this has to be a string most of the time this could be r it could be a or it could be w r stands for read a stands for append and w stands for write the default one is r meaning we are just going to read the document but the one that we could also use is a for append and now i want to keep this as a file and in here now i could use file dot write as an argument in here i can now write some more text and just to make it a bit more visible let me add a whole bunch of axes so we know what we're doing if i run the code now we cannot see any kind of difference that being said if i now open the folder again open the document we can now see the end the one we already had and then write some more text with axes around it the kind of annoying thing here is at the end we don't have a line break this one you would get by adding a line break character manually and now if i run this again and open the folder with the document we now have all of this on a whole new line and you do want to be careful here because this a means append if you write w you're going to write a whole new file with this content here let me run it if i open the folder again test file is still there but if i open it we only have write some text with a line break on the first line the reason here is that this w tells python to create a whole new file if there already is a file python is going to write over it and this you could also use to create new files for example if i renamed this test to new file that is terrible spelling if i run this now with proper spelling and open the folder we now have new file python has created a text document and that is basically all you need to get started with reading and writing into text files let's do an exercise i want you guys to create a new text file and draw a tree in it kind of like the tree we have seen all the way at the beginning of this entire series so pause the video now and try to figure this one out yourself i first of all want to comment out all the stuff i had earlier and now i want with open and let me call this tree dot txt for this one to work i need w as an argument and i want to call this one as let me call it the tree file inside of here let me save the tree inside of a string and this i want to do with the triple quotation marks that are going to be assigned to the tree string i have to work with white space and access to create a tree so three axis i hope i can still get it just right something like this should be good and i realized i have one quotation mark too much now that i have that i want to have my tree file and i want to write in it what i want to write is the tree string now i can run this we don't have an error that's a good start and if i open my folder once again we now have a tree file and inside of that we have a tree although i messed up here a tiny bit i think if i put this x on the next line run this again and open my folder run this now and there we go now we have a tree or an arrow but you get the idea and all right with that we have file writing and file opening for this part we are going to look at deleting stuff which is something you can do but you rarely need to let's talk about it the way you can delete something in python is with the del keyword this one here all you have to do is specify what you want to delete and python gets rid of it this would even work with variables if you delete them they are going to be gone thing is you basically never need it that way it hardly ever happens that you absolutely have to get rid of a variable instead most of the time you only need to delete values from a list and this is what i am going to focus on for this part let's have a look at it i want to start by just creating a basic variable let me call it a and give it a value of 1. inside of my python file i want to create one variable let me call it a it really doesn't matter because we are going to delete a if i print a now hyphen is going to be unhappy because a is not defined which is python's way of saying a does not exist which makes sense because we just deleted a that's kind of all you need here the thing is this kind of operation you basically never do there just isn't a need for it although if you are going to learn other languages they are much more aggressive about clearing memory after you used something so you might see something there but in python all you ever really are going to do is remove items from a list i guess let me reuse a and i want to assign it one two and three and i want to delete individual values from this one here delete is where you are going to see it the most it removes an item by index so for example i could write delete a and then the index 1. if i now print a we are getting an error message because up here we still have the problem if i comment this one out run this again we now can see one and three the reason we can't see two anymore is because we deleted the item with the index 1. inside of a we have index 0 index 1 and index 2 and we have told python to delete the 1 with the index 1. that's all that happened here what you could also do let me comment this one out you can remove an item by value and this should be a comment so let's say in this list you want to get rid of any value that has a free but you don't know what index that three is on for that python or while a list has to remove method all you need is a dot remove and then specify what you want to get rid of in my case a free if i now print the list we only get one and two the three has disappeared besides that let me comment this one out you can also use the pop method what this one does is it removes an item again by index although the default value here is negative one after i have run this i can print my list again and we again get rid of the three all the way at the end the difference between pop and remove is that pop pops out the value we have deleted meaning we could print this one as well so if i run all of this i get free the value that was deleted and then the list itself with this line here and finally you can just clear the entire list and this i think we have actually already seen all you need is a dot clear and if you then print the list it is going to be empty most of the time this is kind of overkill but well it is something you can do and with that you have a couple of operations to get values out of a list or well remove items from a list in this tutorial we talk about objects and classes and well more specifically i will talk about what objects and classes are i will cover how to create and use them we will cover dunder methods and also simple and complex inheritance and finally i will cover how to use classes in practice and well let's get started by talking about what objects are in the first place and well an object is just a container for variables and functions for example we could make a video game with lots of monsters and i think video games are really good way to explain objects so i will stick with that for this entire video but basically for the monster we are going to create we want to have variables and functions and in this case i want the monster to have some health some energy stamina and damage and you could add whatever else you want in here it's really up to you and then besides that the monster should also be able to attack to move to animate and again you could add whatever else you want in here and what you have to understand here is that these variables and functions only exist inside of this monster object it's very similar compared to the local scope of a function if we tried to get this health outside of the container it wouldn't exist because this health exists only inside of a monster object although in terms of naming there's one minor complication and that is special names all that really means is that variables inside of an object are called attributes and functions in an object are called methods and that is more or less the only difference the only reason why this exists is so that we are a bit more specific with our language for example when you talk about health with somebody else for your game you really want to emphasize that you don't talk about a global variable you talk about the specific attribute of one object and one more thing methods should actually be familiar to you because you are using methods very very often in python anyway for example when you call the upper method on any kind of string you are turning every letter inside of that string to an uppercase letter and that is also a method and that is the same kind of method we are seeing here essentially a string in python is just another object with functions inside of it or methods to be more specific this also applies to integers floating point numbers booleans all of that stuff is basically just other kinds of objects that python creates but that's something we don't have to worry about for now now another thing that is really important to understand is that it is possible to have multiple objects for example i could create three different monsters and each of these monsters could have customized attributes these red pieces of text here so my first monster has 90 health 20 energy the next monster has 60 and 40 and the final monster has 40 and 10. so when you create an object you can give it custom attributes however this does not apply to methods and as you can see here monster 1 monster 2 and monster 3 all have the same methods and these can be customized to an extent but not nearly as much as the attributes that's something you do want to keep in mind but still each object has its own attributes and methods meaning that this attack here and this attack are not the same function or well the same method they always apply to their respective object and what you can also do is have objects interact with each other for example if monster 3 attacks one stat 2 we could run some code to reduce the health of monster 2 from 60 to let's say 20. and that actually brings us to a really important topic and that is object oriented programming or oop in short and all that really means is that you are organizing your code via different objects and then you make these objects interact with each other and this approach is basically how almost all large projects are made in any programming language or at the very least any modern programming language meaning if you don't understand classes you will be very much lost and well you will have no idea what you see when you look at larger examples of code here we have a couple more objects we still have monster 1 and monster two but now we also have a player we have an obstacle and we have a menu and all of these have slightly different attributes and slightly different methods and just to talk about how these different objects can interact with each other the one we have already seen is that monster 2 could for example attack monster 1 and then monster 1's health be reduced from 90 to 60. and if monster 2 is attacking it might reduce its own energy from 40 to 20. so attacking isn't free for the monster what we can also do is have an object without any methods like the obstacle here and all the obstacle is is well an object with a position and a size and this we could use for example with the move method of any of the other classes so the player and the monsters all have a move method and this could interact with the obstacle and let me clean this up something even more interesting if you look at the player this one here and the menu those two do look very much connected because the player has one method called menu and what this one would do is to create or the very least open a menu and then when we create the menu we are passing in the player itself so this player here is going to be passed in as one attribute of the menu object and this is totally fine to do you can totally add a function or an object inside of another object as an attribute and then this select could for example change the weapon of the player and we could close the menu as well and i hope this makes sense the main thing you have to understand is that objects can interact with each other and this is how you want to organize code it makes it very easy to work with and especially for larger bits of code this approach is essentially mandatory or at the very least it's the easiest way to organize it and let's actually do a practical example here is zelda like game that i made a while ago and basically everything you see on the screen is an object for example right in the middle we have the player and that's one object and we also have this raccoon here and this spirit and each of those are one object and beyond that each of these flames here is its own object and these are only created when the player is attacking with some magic and finally in the top left the bottom left and the bottom right you can see some ui elements and they are all part of the same object and this object is very much related to the player so those two work together very closely and besides that each of these pillars and trees and rocks and statues they are all objects that i created just for this game so i hope that illustrates how useful objects are that make it really easy to group together code chunks that should belong together and for a bit more detail the raccoon for example has three attributes health speed and damage and the methods attack and move and all the other objects would have similar attributes and methods and with that we have objects now the next question is what are classes and this is fairly easy to explain as well the class is basically a blueprint for an object meaning whenever we create an object we first have to create a class and a class can also accept arguments to customize the object we are creating for example this would be a class we have a class and this class has two attributes health and energy and right now the value for both of these is not being set this we do when we actually use this class to create an object but this class also has two methods attack and move and those do not change and basically what we're doing is use this class to create the object and in the process we are giving it the specific values for health and energy so in this case the monster is going to have 90 health and 20 energy and this process we could do as many times as we want for example earlier you have seen monster 1 we had monster 2 monster 3 and we could continue with monster 4 5 up to an unlimited number of monsters and that is essentially the main idea all you really have to understand is that we always need a class to create an object now what we can also do with classes is that one class can inherit from another class and the resulting objects will have attributes and methods from both classes for example let's say we want to create a shark class and this one right now only has speed for the attribute and byte for the method and this class will be fairly limited because we well don't have any attribute for health or for energy and we also don't have any kind of method for move or attack but we don't need to because what we can do is have this shark class inherit from the monster class and this means this shark is going to get the health and the energy from the monster parent class and that is also going to get the attack and the move from this class as well meaning when we actually use the shark class to create a shark object we are going to get health energy and speed for the attributes and attack move and byte for the methods and i think i should use better colors here in the shark class health and energy are coming from the monster class same with attack and move those two are coming from the monster class and then speed and byte are from the shark class and this would allow us to reuse code quite extensively for example we could have a lot of different monsters we could have a shark some flying enemy some armored enemies lots more and they all inherit from this one monster class and with this approach we would save a ton of writing in terms of code and on top of that if we change the move method for example it would affect every single other class as well which is very useful if you want to make some changes and make it affect every single other class and especially with larger projects this is just about the only way to manage them and let's do an example again here is the screenshot from earlier and we have a monster class we have another monster class and those two have the same attributes and methods although with different values and besides that we also have the player and what is really important to understand here is that all of these inherit from the entity parent class and this for example contains the method for movement because all of the monsters and the player move in the same way so they could share this method quite easily and just to emphasize it i do want to go over the advantages of classes and objects and the first point here is that classes and objects help you organize complex code and the second point is related classes and objects also help you to create a reusable code and just from these two points i hope it becomes obvious that if you want to create some really large projects let's say a really good looking game you need objects and classes without them it's still possible but significantly more difficult besides that classes are also used everywhere meaning if you don't understand them you will be very much lost as a matter of fact in python there are quite a few modules that require you to use classes for example pygame tkinter and matplotlib respectively the model you use for games for guise and for data analysis they all work with classes primarily so if you don't know how to use it you pretty much cannot use these modules or at least you could only use a very small part of them and there's one more point that i haven't mentioned yet and that is that classes make it much easier to work with scope i will talk about this in more detail later but if you struggled so far with getting information in and outside of functions you will really like classes that make it very easy to work with different levels of scope so these are the arguments where you would want to use classes and objects however you can write code without using objects at all and this is very common especially for beginners and let me illustrate the problem here the yellow line is the need for classes and especially when you start writing code let's say you are somewhere here and your average program is something like 50 lines of code in this case there really isn't any need for classes because well your code is very simple and there isn't any need to organize complexity however the longer and more complex your code is becoming the more you will need classes and this ramps up really really fast but as long as you are in this area here it well it's very tempting to never use a class and ignore them entirely and this especially as a beginner you really want to avoid so even though when you are here i would really recommend you to use classes even though it's not strictly necessary in your example just to practice for more complex code because when you are an actual software developer you are never going to write just 50 lines of code most of the programs you are going to work are somewhere here with a few thousand lines of code let's say 2000 and if you are up here and you don't use classes you are going to be in a lot of trouble but all right with that we have the theory of objects and classes and for the next part we are actually going to create and use objects so let's have a look at some code here i have a completely empty sheet of code and the first way i want to do is to create a class and this you do with class and then the name of the class in my case i want to go with monster and here already we have to cover something important and that is the naming scheme so far in python what you probably have written is something like monster and generally you always used the snake case styling for any kind of text so why is this different here and well in python by convention last names are always written in the camel case so camelcase looks like this where you don't have any spaces between words or well any underscores but any word starts with an uppercase letter and this is different from normalpython where variables are written in snake case where everything is lowercase and a space is an underscore and this isn't strictly necessary you can call a class monster with a lowercase m just fine this is purely convention but all the other python requirements for naming still apply for example a class couldn't start with a number and we also couldn't have a space in between so we don't have to learn any new naming scheme now next up what you have to do is a colon and now in here we can work on the attributes and methods of our class and for now i just want to create some basic attributes let's say i want to give this monster some health and for now i want to have specific numbers let's say 90 i want to have energy and this one should be 40. so now we have a class and what we have to do now is turn this class into an object and this we do by typing the name of the class and then calling it by using brackets again very similar compared to functions and this is going to return the object so we have to capture that in a variable and this very often is written like this and here i hope you can see why we have the different naming schemes to python this name here and this name here are two completely different things because one starts with a lowercase the other with an upper case although to us as the programmer we can tell that those two are related because they basically have the same name and for that reason we are usually writing class names in camel case and variable names in snake case it makes it very easy to connect these two and clearly indicate that they are connected although you don't have to do any of this you could totally call this i don't know hamster and this could be lowercase it's totally fine all of this is just convention although you should follow conventions they are there for a reason but i can run the code now and i am not getting an error that's a good sign and now what i can do i can use print and monster dot let's say health and now if i run this we are getting 90. and this knight here is coming from this health and the same would also work for energy in just the same way so we get 90 and 40. now just to emphasize that both this health and this energy only exist inside of this class let me print health by itself that is horrible spelling health and if i run this python is going to give me an error and we have name health is not defined meaning python cannot find this health anywhere in the global scope which makes sense because there is no health in the global scope we only have health in the scope of this monster class and let me add some comments here to make this a bit more readable we have attributes and besides that i also want to create methods and those work kind of like functions we again need the define keyword or def and now we need a name for our function and for that we have the exact same naming scheme for normal functions for example attack would be a perfectly fine name and after that you need a colon and then let's say for this attack method i want to keep it simple and just print the monster has attacked and now i can call monster dot attack and don't forget the brackets and now if i run this we are getting an error and this error says that monster.attack takes zero position arguments but one was given and this is probably very confusing because when we called this method here we didn't pass anything inside of it and the method itself doesn't have any parameters so why is python being so weird here now the reason why this is happening is that whenever we call a method so a function inside of a class what is going to happen is that python automatically passes a reference to the object created by the class as the first argument into the method in this first argument we always have to capture with some kind of parameter meaning a method always needs at very least one parameter for example i could just write monster in here and if i run this now we get the monster has attacked and let me just print what we actually get so i want to print the monster we get as an argument in here and what we get is main monster object at somewhere in our memory and well in my case i don't really care about this monster so let me remove the print statement but i do have to keep this first parameter however once we have the first parameter i can add as many custom parameters as i want for example i could add the amount of damage here and i could let's say print the amount with an f string and i want to say the amount of damage was dealt and now when i call this method down here i can pass in any number i want and i get the monster as attacked 40 of damage was dealt that does not make sense in terms of grammar let's try this again but the damage was dealt that feels much better what is really important to understand here is that this monster or more specifically the first parameter of any method always references the object created by the class so this class up here creates an object and then this monster is a reference to that object the monster is not a reference to the class itself and this is really important because that way you can create multiple objects that always work with the first parameter here for example i could have monster 1 that i'm creating from the same class and now call monster 1 dot attack let's say with 10 in here and now the first argument passed in here and the first argument passed in here are different essentially we are passing this monster in here and this monster one in here that way this first parameter is really flexible it can target any kind of object or more specifically any kind of object you are using it with i don't want to do this one right now but what you could also do if i add another line here you could for example print monster dot energy this once again would target this first parameter and then this first parameter targets the object itself which in this case is going to give me the energy here the one i've just drawn over but if i run this we are getting 40 the 40 we have seen from here and this right now is created in a class but later on when we use this class to create an object every single object would have this energy attribute and this is what we are referencing here and what you could also do is increase this amount so monster.energy minus equal 20 and if i print it now we get 20. and i hope you can tell how useful this can be because if you imagine that this monster here is the global scope and these attributes are global variables if this attack was just a normal function then this would not work because you would be creating a local variable that wouldn't work with the global ones but because of this first argument that the method always gets we can influence variables or well attributes outside of this function which is incredibly useful so i hope this kind of method here makes sense as a matter of fact let's practice this one i want you guys to create another method for this monster and this one should be called move and it should accept one parameter besides the reference to itself and that is the speed of the movement and then inside of the method you should just print that the monster has moved at a certain speed it doesn't really matter what you put in here as long as it is working so try to figure this one out yourself alright let's try together now i want to create a method called move and in here i want to have speed as a parameter however what we have learned from the attack method is that we always need a reference to the object as the first parameter meaning the first parameter here should be something for the monster and it really doesn't matter what you call it so i could even write something in here it would still work and now in here i can print the monster has moved and let me add another line with an f string that says it has a speed of and then the speed and let me fix the typo and now i can call monster dot move and add let's say a 10 in here and let me comment out monster.attack and let's see what we get the monster has moved it has a speed of 10. so all of this seems to be working very nicely now obviously calling this first parameter something is a bit confusing and as a consequence in python there is a convention that this first parameter is always called self and this applies to all of the methods meaning this is what you are going to see most of the time and what i am going to use as well you don't have to do it but i think it makes the most sense although i do want to emphasize that this parameter here and this parameter here have no relation whatsoever they are entirely separate but it is totally fine to call self here and self here the names are not in conflict with each other and all right with that we have the very basics of using classes and objects although right now we do have a problem that our monster always has the same health and the same energy so even if we created multiple monsters so what i could be doing is monster 1 monster 2 monster 3 and let me get rid of this one here all of these monsters would have the same amount of health and the same amount of energy and they all have the same attack and move method which is fine to an extent but i do want them to have different amounts of health and different amounts of energy and to implement that we need another concept and that is called dunder methods so let's talk about that one and the dunder here just stands for double underscore meaning we are talking about a double underscore at the beginning and at the end of the method but it's important here we are still talking just about methods so essentially we are calling a specific kind of function and let's talk about why it's special a dunder method is just another method the thing that makes it special is that it is not called by the user instead it is called by python when something else is happening for example there is the done therein method and this one is called when the object is being created another example is the lan method and this one is called when the object is passed into the len function and besides that we also have done the apps and this one is called when we are passing the object into the apps function and that is really the entire idea it honestly isn't that complicated the most important dunder method you have to understand is done their init this one you are going to be calling all the time but let's actually do all of this in code that should make the most sense all right here we have the class i created earlier and what we have seen earlier as well i can create monster one and that is just going to be the monster and i can also have monster two and if i now print monster 1 dot health and monster 2 dot health we get the same number because we always set health to 90. there's no way to customize it and basically what i want to do is as soon as the class is being created then i want to create these different attributes and instead what i want to do is when this class is being created i want to create this health and this energy with custom values and for that to work we need to define a dunder method and the one we need is called dunder init and this is just going to be another method like attack and move we are just calling a method meaning the first parameter here has to be a reference to the class itself and for now let me just print the monster was created and do pay attention i am never calling the init method myself but if i run this we get the monster was created the monster was created and then 90 and 90. and what that means if i minimize this a bit every time we are creating a monster so first here and then here then we are calling this dunder method and this standard method we can also give some parameters for example we could specify in here the amount of health and the amount of energy we want and well i hope you can see where this is going basically what we can do now is we can set self.health to whatever health parameter we pass in and we can do the same thing for energy and the names here might be a bit confusing so let me add a bit of white space and explain this self.health here is referring to this self.health of the monster class whereas this health here refers to this parameter and the important point here is self because this one specifies where health belongs to i hope this makes sense this is something you see fairly often let me remove the white space again and now when i am calling the monster i can either pass in arguments or named arguments let's say for the first monster i want health 10 and energy 20 and for the second monster i could specify health being 50 and energy being 100. now if i run all of this we get monster 1 health is 10 and monster 2 health is 50. and this 10 here refers to this 10 and this 50 is referring to this 50 here meaning now we can have custom attributes and what is even better since this self is a reference to the class itself we can just create the attribute in here which means we don't need those lines at all it would still work without them if i run this now this is still working just fine and this is what you see most of the time where the class by itself doesn't have any attributes we only create attributes when we are creating the class with the init method or the done therein method and then inside of the other methods we are calling self all the time to refer to the class and i just realized this should be self instead of monster so we're capturing this self here and what you are going to notice is that you are going to write self all the time it is a little bit annoying but well it is manageable and well with that we have the first init method but there are quite a few more although those you wouldn't use that often and just to keep things simple let me get rid of monster 2 and i don't want to print anything at all another danda method i talked about in the introduction is len and this one needs self and no other parameters and in here we just want to return something let me return the number 5 and what this one is going to do is if i call len and pass in monster1 in there and this len just as a quick recap if i pass in any kind of string into len let's say test and if i print the result i get 4 or the number of characters inside of the string i guess i could also pass a list in here that might make a bit more sense so i have a list with 5 entries and the length of it is 5. but what i can do now if my monster has a len method i can pass monster 1 in here and it would return 5 as well and any number that is being returned here is going to be passed into the length function and i guess for something slightly more relevant instead of returning a number i could return self.health and now if i run this i'm getting 10 or the amount of health my character has which is 10 right now and another example we have seen in the introduction that works in the same way is abs and we need dunder on both sides and in here self and again i have to return something so return and for this case let's say self.energy and if i copy this and pass it into absolute i get 20. now usually absolute is if you have a negative number and you want to make sure it's always positive that's what it does but well you could theoretically do whatever you want with it now what you can also do is one specific function in python and that is called dir short for directory i think or directory listing or something like that basically what it does you pass in an object and then you want to print the result and what you get from that is all of the dunder methods and at the end the attributes and the normal methods and in here you can see a lot of stuff actually and what you have to understand here is every time we are creating an object python already gives it some dunder methods for example here we can see the dir method and this one is necessary for the ear function to work it kind of works like the len method the one we have created ourselves or the abs function and i guess the one we have just created is the init method this is the really important one and most of those you really don't want to worry about because well they're just there to make the class work but we don't really have to worry about them although some dunder methods in here can be very useful for example dander dict is well it's kind of a dictionary but not in the way you would expect basically how you would use that one let me print it right after the monster i want to print monster 1 and then dot dunder dict and in here this is the one exception where this is not a method this is just an attribute so no brackets afterwards and this one gives us all of the attributes of the method inside of one dictionary can be quite useful sometimes although you wouldn't be using it too often now another way to get this dict here is to let me duplicate the entire line you can call the varus function and pass in monster1 and this one is giving us the very same thing although i have hardly ever used either of these most of the time you just don't need them and with that you should understand dunder methods reasonably well now there are quite a few dunder methods that get a bit more advanced i only covered the really fundamental one some other examples of thunder methods is for example dunder call and in here we only need one parameter self and in here we can return something else again and let me dissipate dunder on both sides let's say the monster was called and what this dunder call does is it essentially turns our object into a function meaning i can call monster1 and then add brackets afterwards and if i do that we are not getting anything because i would have to print what i get so i have to put brackets around it and call print and now the monster was called i guess a cleaner way of doing this is to return nothing and just print this string so now if i call monster1 we get the monster was called and nothing is being returned and when you create a function in python it basically behind the scenes creates an object with this standard method here and this we can just create ourselves it really isn't that complicated and what we can also do is to add and subtract numbers and this you would for example do with dunder add and in here you need two parameters first of all self as always and then you need some other number and what you can do in here is return something let's say i want to self.health and then plus whatever other number i get and now that i have that i can print monster 1 plus 10 and if i run it i get 20 which is if i find it so the health of my monster is 10 and i add 10 towards it so i get 20. and i guess to make this a bit more understandable let's add 55 in here and i get 65 which is 10 plus 55 and well that is a couple more dunder methods they can be incredibly useful although most of the time you are only going to use thunder init this is the one you absolutely have to understand but i guess they don't really get that much more complicated so it shouldn't be too hard all right now for the challenge for this part i want you guys to do some research because there's another dunder method that is called str and i want you guys to look up online what it does and how to use it in code alright here we are in the official python documentation and there you can see dunder string or dunder str and basically what it does it's called by the str object built in function format and print to compute the informal or nicely printable string presentation of the object basically what it means is that this object is going to return some text so let's have a look at it here we are back in the code and i only need one parameter and that is and now i have to return some kind of string and the string i want for this one let's say a monster and what i can do with that let me get rid of this print statement and instead i want to print str or monster one and this is going to return a monster and we don't even need this str because print is trying to find a string so let me duplicate this line and remove the str and just have monster 1. if i call this now i still get a monster and this can be a really nice way to look at your objects and see what they are doing because if we didn't have this done their method let me comment it out and run this again all we get is a monster object which really isn't that useful and obviously this str can return a lot more than just a simple string for example we could have an f string with health that says self dot health and energy that says self dot energy and now if i run this we get quite a bit of information by just passing the monster or the object into the print statement so this str can be really really useful and with that we have covered quite a few dunder methods if you look online you can find even more but well most of the time you are not going to need them this is very often a fairly advanced topic except thunder init this is the one you are going to use a lot all right with that we have dunder init methods covered and if you understand all of this so far you can actually understand python itself quite a bit more let's talk about this one in the next part and the one thing i think that confuses beginners quite a bit is that every single thing in python is an object meaning every time you see a string or integers you are going to see an object just like the objects that we have created so our monster and this even includes functions which are just objects with the called under method and i'm going to show you some examples in just a second but most of what i will cover here isn't really important i just want you guys to understand how it works so you don't get confused later on and there's another thing that i believe is very often confusing and that is the difference between a function and a method and the reason why this is confusing is both just execute a block of code so in terms of functionality they basically do the same thing however the difference is that a method always belongs to an object it doesn't matter if the object was created by us or by python and a good example here would be using a string so if we have a function this would be len for example and we can pass a string into it this will return four and a method would be something with dot and then upper for example for string returns uppercase letters for this string and that really is the entire difference that's the main thing you have to understand and it doesn't matter if we create the method ourselves or the function ourselves or if it's created by python and the reason why these are different for example is that the lan method could work for lots of other things as well for example you could pass in a list in here you could pass in a dictionary or a tuple it would still work with different data types whereas upper only works for strings you couldn't add a list with upper that one would not work so it makes sense in this case that upper only exists as a method for strings whereas the ln should be a function so you can pass in different kinds of objects in here and they would all work you could perfectly find create some kind of len method for test and it would work just fine although then you would also have to create a lan method for lists for dictionaries for tuples for all of that stuff and it would be quite labor intensive so all we're doing here is to keep things more efficient but all right let's have a look at some code and let's have a small deep dive into python here i have a completely empty sheet of code and what i want to create for now is create a test variable and this one should have a string let's call it a doesn't really matter what it is and what i can do now i can call my print dir and pass in my test in here and if i run this now i am getting a bunch of dunder methods and after they are over starting from here i get a couple of methods and attributes now the dir method doesn't separate between methods and attributes so we just get one big list but well basically what we get here is an object and anything in here you could just call like upper or title or strip all of these are very simple methods and along with that we have the len dunder method and this is what's being called when we are passing this string into the len function and besides that what you can also do let me get rid of this test and instead create define test and then here i let me just add pass so this is a function with the name test and i'm still printing dir test so if i run this i am getting another object and this object is special because it has a call dunder method meaning when we're adding brackets afterwards it is being executed and that's basically what a function is in python it's just an object with the dunder call method it really isn't much more than that although we do have a couple extra things that make this a bit more special but that's the main idea and if you really wanted to you could even store this function inside of a variable and this works because the function is an object so this is just going to be an object meaning if i now print a we are getting the same outcome although what we can even do now let's call it another attribute that is not how you spell that and this could just be 10 and now if i run this our function has another attribute and again this is working because functions are just objects although in practice you wouldn't really do this there's no reason for it but what is much more common is that you are passing functions or methods into other objects so what is much more common let's say for example a simple add function and this one takes a and b and is going to return a plus b obviously this still isn't particularly useful but i just want to illustrate what it does and now i can create a class and let's call it test and in here for the dunder init method i want to have self and i want to add an add function and now inside of this dunder init add function i can set an attribute self dot add function and this should be the argument we get from the parameter add function and now when i create this test i have to pass in one function and i want to have this add function here so i'm going to add it in here and let me use a named argument so it's a bit easier to see what's happening and in here it is really important that you don't add brackets because we don't want to call this function we want to get the function itself so the object of the function not what's being returned and if i run this now this is working just fine and even better what i can do i can call test dot add function and i can pass in let's say one and two and this is not doing anything because we're not printing anything we're just returning something so if i put all of this into a print statement now we are getting free and i hope all of this is making sense this is a really important thing to understand right now this here is creating an object of a function and this object we can pass around for example we could pass it inside of a class and this would work just fine and then inside of the class we can store it inside of an attribute and then call it from outside of the function this is working just fine there's no limitations on this and this is something you really want to practice because passing around functions is a really important thing to understand and i guess since this is really important we should practice this with a slightly larger exercise and let me add some comments that should help quite a bit first of all i want you guys to create a monster class with a parameter called funk and this funk should be stored as a parameter that's the first step after that i want you guys to create another class and this one is called attacks and this has four methods we have let me put it on another line we have byte strike slash and kick and for each method you just print some text basically whatever you want i would recommend to print kick slash strike and byte but it really doesn't matter and let me add proper white space here and then for the final step i want you guys to create a monster object and give it one of the attack methods from the attack class and remember here that methods are basically just functions the only difference is that they are part of an object so this should work kind of similar compared to what you have seen here but well it's going to be slightly different so experiment with this and see how far you get all right let's try together now first of all i want to create a monster class and this i do with class monster and in here i want a dunder init method that needs self and a funk and this funk i want to turn into an attribute so self dot func and i want to capture the parameter or the argument we get here in there and this is covering all of this next up we have to create another class so class and this one is called attacks and in here we don't need a donderended method instead i want to create define let's start with byte and we need self as always and in here i just want to print byte and since we need four attack methods let me copy this a few more times and now besides byte i also want strike then i want slash and finally i want kik and i think you can already tell why this might be useful it's a very neat way to organize all of your different functions if you have a really large game with hundreds of different attack methods this may actually be really nice to organize all of this all right now finally i want to create an object of my monster so monster in lower case and then here i want to have my monster and now we have to define a function now this you could approach in a couple of different ways although there's one way that is definitely wrong and it's very tempting to go this way you could write something like attacks and then dot byte and if i run this code we get a 3 and this 3 comes from up here so let me comment out all of this and if i run this again now we can't see any difference but if i run monster.funk we are getting that attack.byte is missing one required positional argument and that is self and this is a reasonably common error the reason is that this here is not returning an actual object it's returning a class and this is confusing python now an easy way around this is to actually turn this class into an object by calling it so adding brackets afterwards and now if i run this we are getting byte and basically what is happening here think of this in terms of return statements when we are calling this attacks it's returning an object and then inside of this object we are getting the byte method which is this byte method here and if you don't like how this looks what you could also do is create a separate object let's call it attacks and in here i could add this attacks and then call attacks.byte and we will get the same result and this is something we are going to explore quite a bit more that you pass different things around different classes so that in this example we are taking the byte method and passing it into another object and this is getting incredibly powerful and really important to understand if you want to understand more complex code because a key part of object oriented programming is that you work with different objects and make them interact with each other and this example here so this part down here is one example to make classes interact with each other and i would really recommend you to practice this in your own time it's really going to be helpful but all right with that we have covered a really basic deep dive into python although i do want to practice this a bit more and there's one important topic i do want to cover and that is going to be scope in terms of objects and classes let's talk about that one in the next section alright so let's talk about classes and scope and this is one of the really powerful parts of objects that make it really easy to work with this scope but let's talk about it basically every method so every function inside of a class has a reference to that class and because of that it's really easy to get and change class attributes and because of that methods are much easier to work with than normal functions meaning they rely much less on parameters the global keyword and return statements although you can still use them if you really want to and sometimes that does make sense but you are going to do this much less often and what is even better objects can be influenced from outside of the object itself and even from the local scope of a function basically objects you can change wherever you want there is no limitation on the scope for them which makes it even easier to work with them but i guess let's have a look at all of this in code that should illustrate this the best here i have a completely empty sheet of code and first of all i want to illustrate the problem so let's talk about scope again let me add a comment scope problem and let's say i have a game and i have some kind of health that right now is 10. and for this health i want to have a function let's call it update health and this one takes an amount and what it really does is it adds that amount to the health a super simple function just about the simplest function you could write now what i want to do let me say i want to print health then i want to update my health with 20 and then i want to print my health again and if i were to run this what do you think is going to happen just think about it and well if i print it we are getting an error and what python is unhappy about is that we have a local variable health referenced before assignment and what is happening here is that this health to python is a local variable let me remove the error messages they are getting a bit annoying that's easier to work with essentially this health only exists in the scope of this function here or in other words this health here and this health here to python are two completely separate things and then when we are trying to update this health with some amount i even cannot find any starting amount for this health as a consequence we are getting an error and there are a couple of ways to get around this for example we could use global health that's probably the easiest one and now this would work although you could also use return statements but it really isn't the cleanest way to work with this so this is not great so let me comment it all out and let's do the same thing with classes so let me create a class monster again and in here i want to create a dander init method that needs self health and energy and then as always i want to set self.health equal to health and self.energy is going to be energy and now let me create an object from this class and let's give it a health of 100 and energy 50. it doesn't really matter what values you put in here so now i can print monster.health and we are getting a hundred so this one works just as expected and now what we can do we can just get monster.health and add let's say 20 to it and if i now print monster.health again we're getting 120 ie the sum of 120. and what is even more powerful let me uncomment this function up here and now instead of the health i want to get my monster.health and update the amount and this would still work if you are using an object so let me get rid of these two lines here and instead call the function update health and let's say i want to raise this by 20 again and now if i print monster.health after calling this function i get 120 meaning even inside of the local scope of a function you can still update anything inside of an object but the simple reason that here python is very clear about what kind of object you are talking about this monster is not going to become a variable in the local scope and this monster could be updated anywhere it could be in the global scope it could be the local scope of a function it could be in the scope of another method it could even be inside of the object itself so this monster python just doesn't care which makes it really easy to work with so i guess one thing you do see fairly often is inside of a class you have something like let's call this one update energy and then here we need self and let's add an amount in here as well and all i really have to do to update this self.energy would be to first target the attribute itself so self dot energy and then plus equal amount and now i could just run monster dot update energy pass in anything i want in here and then print monster.energy and we are getting 70. and again here this is a very easy way to work with scope you don't have to worry about return statements you don't have to worry about global all you do is target the attribute and then you set it to a new value or update whatever you want that's it it's super easy to work with although if you wanted to you could use a return statement as well for example if i wanted to set energy and then here i want self and energy and let's say for this one i want to create a new local variable that i call new energy and this is going to be energy times two and then i want to return this new energy and now in my init method instead of setting energy straight as the attribute i want to call self.set energy and pass in the energy and now let me comment out this line down here to update the energy and just get the energy now we're getting 100 which is this 50 here this 50 we are passing inside of this energy here from that energy we are passing it inside of another method inside of the monster class and this method is down here we are getting one parameter and this we are doubling and assigning it to new local variable inside of this method and after that we are returning the new energy and this new energy is going to become the attribute self.energy kind of a roundabout way of doing it but it is possible to do all i really want you to understand is that you can still use return and parameters just like with any other function although most of the time you don't really need it a better way for this one would be to remove this part entirely just call set energy and then self dot energy is going to be new energy this would work in exactly the same way although it is much cleaner to read so if we run this we are still getting a hundred and i hope you understand why self is really really powerful it essentially bypasses all of the scope issues very efficiently all right let me get rid of all of this because i don't really care about it and instead i want to set self.energy back to energy all right now with that let's do an exercise to practice this and what i want you guys to do first of all create a hero class with two parameters one is damage and the second one is a monster which is going to be this object here so this object you want to pass into another class as an argument and second of all the monster class should have a method that lowers the health and i guess you can call it get damage and this one should take an amount and then this amount you would reduce from the health of the monster and finally the hero class should have an attack method that calls the get damage method from the monster and let me put this on a second line and the amount of damage is hero dot damage which is going to be the damage you specified up here which should be an attribute so i hope all of this makes sense try to implement this yourself and see how far you get all right let's try together now first of all i want to create a new class and this is going to be and the hero needs a dunder init method and here we need self and besides that i want damage and i want a monster and let me add a bit more white space there we go now i want self.damage to be damaged and i want self.monster to be monster and let me spell this correctly there we go and this would then be step number one and for step number two let me move it up a bit so it's easier to see what's going on the monster class should have a method that lowers the health and this i want to call get damage so define get underscore damage and then here i need self and i need the amount and all i really want to do in here is self dot health minus equal whatever amount we specify and this get damage i want to call from inside of the hero and this brings us to step number three and this right now we are still inside of the hero class which you can see by the indentation i probably should have actually mentioned that for the class we always define something by one level of indentation a in here i want to now create let's call it an attack method and this one itself and nothing else and all i really want to do in here is get myself dot monster and this self.monster is the monster we specified up here and on this monster we want to call get damage and all we really have to do for that is call get underscored damage and now we have to specify how much damage we want to cause to the monster and for that i want to get the damage of the hero and all we need for that is specify self dot damage and we are done and if you just read through this i hope this really illustrates why this makes a ton of sense it's basically a normal sentence we want to get the monster we want to cause the monster some damage and the amount of damage you want is selfdot damage so the damage of the hero and now with that all we have to do is to actually create the object of the hero meaning i want to create a hero object and this is going to be hero and in here we need damage let's say damage for the hero is 15 and then we need a monster and the monster is going to be the monster object we created just a second ago this one here and this we're just passing in here and now let me print monster.health and if i run this we are getting a hundred which is this 100 here but now if i call hero dot attack and this one doesn't need any arguments and afterwards i can print monster.health again and now if i run this we get 85 which is 100 minus 15. this is how this 85 comes about and to get to this point to lower the health of the monster we just had to call one method and that's it all we are really doing in here is we are passing different objects around and make them interact with each other and since we don't really have to worry about scope this is very easy to implement and again this is something you really want to practice on your own and try to work on this more to make sure you understand it but right with that we have covered scope and i guess for the next part let's talk about inheritance and inheritance really just means that one class gets the attributes and methods from another class or multiple classes and i have already shown an example earlier and that was we are the monster that we have already seen multiple times with health and energy and this right now is called a parent class and the reason why it is called the parent class is because there's a child class and this one was the shark and this shark by itself only has a speed and a byte method and what i want to happen is that the health and the energy of the monster parent class comes into the child class and the same for the method so attack and move should also be available inside of the shark class so that when i actually use this to create an object the shark object has health energy and speed for the attributes and attack move and bite meaning we are combining the monster and the shark class to create the actual shark object and the reason why we are doing this is this makes it very easy to reuse code let's say this monster here could be the parent class to every monster in our game and if we have this we never have to set the attributes health for energy for any other monster they are always available for every single class because they all inherit from this monster and obviously this is still a very simple example in an actual game the monster class might have a few hundred if not thousands of lines of code and then it really makes sense to reuse code as much as we can because then we don't have to create new classes all the time with all of these methods that we have to type over and over again and then on top of that if we wanted to make changes to how things move in the game so this method here if we didn't use inheritance and we want to make change how things move in the game we would have to change possibly hundreds of different move methods for every single monster but if we use inheritance we don't have to if we change one move method we are changing how every monster in the game moves so i hope that makes sense and one important concept here is that the class can inherit from an unlimited number of other classes this could look like this in here we could have a parent class 1 a parent class 2 and a parent class 3 and then the child class would have the attributes and methods of all of these parent classes and you can also turn this around where you have a parent class and this parent class is being inherited from by an unlimited number of other classes and this would look something like this you have one parent class and you have one child class a second child class and a third child class and all three of those would have the methods and attributes of the parent class and this here for example could be the monster class and then this one here maybe the shark class and let's say this one here could be i don't know like a bird class or something now there's one thing you do want to be aware of though and that is that inheritance can get very very complex up to a point where it really doesn't become fun to work with them and this is also the part where beginners really start to struggle because well i'm going to show you an example later on but this can get very very complex and really hard to work with fortunately this is fairly rare most of the time you just need simple inheritance and this one is really easy to implement and this one might be something like this the example we have already seen and this one should be very easy to follow so for this section i just want to focus on implementing this part here and i guess let's actually implement this one in code and let's see how this is going to look like alrighty so here once again we can see our monster class and from this monster class i want to get a shark class and this one should get the health the energy the attack method and the move method of this monster class we want to put all of this inside of the shark now passing in the methods is very simple but the health and the energy are going to be a bit more complicated so for now let me simplify things a tiny bit by commenting out the dander init method and instead setting health to something constant let's say 50 and energy to 100. the reason being that init is a bit more complicated for inheritance so i'm going to ignore this part for now just to keep things simple but we will implement this in just a bit all right now for this shark i want to create an init method by itself and this one needs self and in here i want to set this speed and now what i want to do is self.speed is going to be speed and this way we are getting our attribute and besides that i also want one method and that method i have called byte and in here we just need self and let me print the shark has bitten or whatever you want to put in here and this by itself would be a functioning class but also a very limited class because it only has a single attribute and one method it doesn't really do all that much so how can i get all of the monster attributes and methods inside of the shark and to get inheritance what we have to do is add brackets after the shark or the name of the shark class and then here we have to pass in what class we want to inherit from in my case this is monster and for start this is all you need meaning now i can create my shark by calling shark and i have to pass in a speed for the shark and let me just say i don't know 120. and now if i print my shark all of this works just fine and we are getting an object but what i can do now is get my shark dot health and this is the 50 we have set all the way at the top here i can also get my shark speed this is the 120 we set for the shark in here and besides that i can also call shark dot byte we get the shark as bitten and besides that i can also set shark dot attack and this one needs an amount so let's say 20 and this is the attack method we have gotten from here so the parent class and if i run this we get the monster has attacked and well with that we already have super simple inheritance just by adding this brackets monster we are getting all of these attributes and these methods here so that's a pretty good start now what you can also do let's say let me remove some white space here let's say for the shark this move method here doesn't really work because for the shark i want something else i want the shark to swim and for the speed i want to set since i have a speed i want to use self.speed meaning i want to overwrite this speed from the parent class and to achieve that all you have to do is define a method with the same name in the child class so in here i want self.move and now i can add a print statement in here the shark has moved and let's say print again the speed of the shark is and then self.speed and this should be an f string and now if i call shark dot move and we don't need any arguments if i call this the shark has moved the speed of the shark is 120. and what happens in here is we are first getting the inheritance from the monster and then this move here is being overwritten by this move here which means you can overwrite what you get from the parent class very easily and this you could also do with attributes although we actually have to talk about attributes let's do it right now the problem we are facing right now is that the monster has an init method let me remove this health and energy and uncomment the init method essentially the problem we have right now to give the monster the attributes this self.health and self.energy we have to first call the init method and if we don't call the init method we don't get these attributes so what we have to figure out inside of the init method how to call the parent init method so this would have to happen in here and for that we have two ways one that is a bit outdated but still works and one you actually want to use and let's cover both but you don't really need the first one anymore but just in case you see it let's cover it now what you can do you can call the parent class so monster and then call the dunder init method and now in here you have to pass all of the arguments so these ones here that you want for the parent class so we need self health and energy and these we have to get from arguments so when i initiate the shark besides speed i also want to get health for the shark and energy for the shark meaning when i actually create the object of the shark besides speed i want to set health to 100 and energy to 80. now what i get let's go over this actually the first step happens down here i am calling the shark class and i'm passing in three arguments i have the speed i have the health and i have the energy and these three arguments are being covered in speed health and energy and inside of this init method we are calling the parent init method and into this init method we have to pass in three arguments self health and energy and self originally for the parent class was the class itself so this self here which refers to this monster however now the self is going to refer to this self here which is the shark meaning when we are setting self.health and self.energy we don't talk about the monster we are talking about the shark class and this is why the self here is important and then besides the self we also need health and energy and these are just going to be arguments we have to pass in here so this health and this energy and these two we get from these two parameters here which is health and energy and those are being passed in here and with the left to move method i don't care about this one instead let me print shark dot let's start with speed let's actually print all of them so besides speed i want health and i want energy if i run this we get 120 180 the numbers we have specified here and well this can get a bit complicated but look at the init method here and the init method here and if you didn't understand what i talked about in the last part practice this yourself and then go over this a couple of times if you get used to this it's eventually going to become fairly easy although i suppose in the beginning this can be a bit overwhelming the one really important thing you have to understand is that we are calling the init method and we are passing in the arguments that we want to set in this case speed health and energy and then inside of this init method we are right now calling the parent init method and then passing health and energy so these two in there as arguments so for example we first set the health here when we are creating the object this health goes into this health for the parameter and then this parameter goes into the init method of the parent and then the init method sets self.health or the actual class and that way you can connect the init methods of different classes now this is how python used to work and this still works but there are some downsides to using it this way so this isn't really used anymore instead what we use is called super and this is a function and this super all it really does is it gets the parent class so if we have that we can just call the init method on it as well and in here we don't need self all we have to do is pass in health and energy and then we are done if i run this now we are getting the very same outcome meaning those two approaches here are functionally identical at least up to this point when we get to multiple inheritance or let's say more complex inheritance super is the much better method and this is why we don't use this initial approach anymore and i guess this one is also a bit easier to read it kinda is up to you but this is the one you do want to use and super you can actually use for a lot of other things as well for example i could call super and then call the move method of the parent and in here i have to pass in a speed let's say 10 so now when i run the code i get the monster has moved at a speed of 10 meaning when we are calling the init method of the shark class we are also calling the move method of the parent and this way even if you overwrite a method from the parent class you can still call it with super if you really want to which adds even more flexibility to all of this and this is simple inheritance which is something you definitely want to practice this is the one kind of inheritance you are going to use fairly often and the one you have to understand let's practice this one and let me add comments one more time let's do an exercise i want you guys to create a scorpion class that inherits from the monster and it should get health and energy from the parent and then besides that there should also be a poison damage attribute and i want you guys to overwrite the damage method to show poison damage kinda like what we have done for the move method for the shark pause the video now and try to implement this one yourself and see how far you get i want to start by creating a class called scorpion that is not used for scorpion there we go and this one should inherit from monster and now in here i want to create a dunder init method and this one itself and besides that i want poison dammit and now inside of the scorpion i want to set self poison damage as poison damage so we are getting an attribute and then besides that i want to define or well overwrite the attack method let me minimize the shark class so we can see the code a bit easier and i want to overwrite this attack method here and in my guess what i want i just want self because i already have the poison damage and all i want to do in here is print the scorpion has attacked and print it has dealt and then we want self dot poison damage and poison damage and this should be an f string all right so far this should have been fairly easy what i can do now let me delete all of this and let's delete a shark as well we don't need him for now and what i want to do is to create an instance or an object from my scorpion i am really bad at typing scorpion and here i bought my scorpion and right now we have a poison damage i don't know of 50. and now if i type scorpion.attack this is working the scorpion has attacked it has dealt 50 poison damage this shouldn't have an underscore there we go it has dealt 50 poison damage this looks much better meaning what we have so far we have a scorpion with poison damage and we have overwritten the attack method and since we are inheriting from monster we're also getting this move method here meaning my scorpion can also move at a certain speed let's say 5 if i run this and let's make this a bit larger we have the attack method for the scorpion and we have the move method but what we don't have let me get rid of those two we don't have scorpion.health for example this attribute doesn't exist right now because monster only gets these two attributes once we're running the init method so what we have to do in the scorpion called the init method of the parent class which we get with super and then dunder init in here and if i scroll up the monster class for the init method needs two arguments health and energy so let me comment those two and in the united method i want to pass in health and energy now these numbers have to come from somewhere although they don't necessarily have to i could for example just set static numbers in here let's say 50 and 10. if i run this now we get 50 for health because all we are doing here is calling a function that is under init and we're just giving it different arguments although this lacks a lot of flexibility so i don't want to do it but we could if we wanted to instead i want to get this health and this energy from the init method of the scorpion class and in here just to be specific about what we are doing let me name this scorpion health and scorpion energy and somehow my brain always wants to add a tea to scorpion i have no idea why and now when i call the init method for the monster my health should be my scorpion health and my energy should be my scorpion energy when i am creating the actual object i want to have let me use named arguments that makes it a bit easier to read my poison damage should be 50 my scorpion health should be 20 and my scorpion energy should be 10. and now if i run this we get 20 for the health of the scorpion because remember we are only calling scorpion health the parameter so this is scorpion health here we don't actually set this parameter as an attribute instead what we do we are using the health attribute of the parent class and this gets the value of the scorpion health so our scorpion doesn't have scorpion health as an attribute it just has health and along those lines we also have energy if i run this we get 10. and i hope this starts to make a bit more sense this is definitely something you want to practice if you only partially followed along this is a really important concept to understand and definitely something you are going to see all the time and this you can actually make quite a bit more complex with well more complex inheritance so let's talk about that one and basically what that means so far we always had one parent class and then a child class so a pretty immediate connection something slightly more complex is you have a child class and two parent classes this is something we are going to build in this section but if you really wanted to you could do something like this and it would still work now maintaining something like this is going to be a ton of work although once you have it this child class is incredibly powerful because it gets information from a lot of parent classes so especially if you create something really large this is something you do want to be able to understand but for now especially if you're a beginner and this is the first time you've really engaged with objects i wouldn't recommend to worry about this too much because it gets overwhelming very fast instead make sure to understand this scheme if you understand that one you should be able to follow along with this one as well but for now just practice objects in the first place and once you have a better grasp of objects engage in this one so let's talk about how we could create something like this and this i think is best done in actual code so let's have a look how we can work with this now here i have some code already i have the monster class we have seen quite often by now this one i hope is familiar at this point besides that i also have a fish class now and this one is a very simple class all we have is an init method and this one sets a speed and has scales and besides that we have a swim method and this one just prints swimming at the speed of whatever the speed of the object is going to be and what i want to do i want to create my shark again but this time the shark is not just going to be inheriting from monster it is also going to be inheriting from fish so the first thing for multiple or complex inheritance is that all the objects you want to inherit from should be here in the brackets after the name of the class and in here you could add as many other classes you want there could be class 3 class 4 class 5 as many as you want there isn't really a limit and now inside of this shark i want to set a dunder init method and in here we always need self this one should make sense by now and besides that for the shark let's say i want to set a byte strength and then inside of this init method i want to self dot byte strength is going to be byte strength this one should still make sense it's quite straightforward but the more complex one is if i now want to call super and then dunder init now we have a problem because i have no idea what to put in here and the question here is what arguments should go into this inhibit method should i add the arguments for the monster class or for the fish class or both how would this work and there are a couple of things you have to understand to solve this problem the first one is called the mro or the method resolution order and what this really means is let me add a comment here mro or method resolution order what this basically means is in what order the parent init methods are being called and this you can get by just printing and i want to get the shark class not the object the class itself and call mro on it and this is still going to work and if i call this we are getting invalid syntax because the question mark here is not something python likes so let me comment it out for now and now let's run this again and now we can see the mro or the resolution order and basically what it means is in what order python is going to go through the classes we start with the shark itself this one should make sense this is the class that we actually work in so this is where we want to start next up we are looking at the monster class then we look at the fish and finally we look at a generic object and this generic object you don't have to worry about because this is something inbuilt into python it's the thing that makes all of the objects work you don't have to worry about it so what we have to worry about is the shark the monster and the fish and how this order comes about is from the order of these arguments here and basically how this works is that the leftmost item monster in this case is always going to be the first in line with the class itself being the very first item so shark is going to be 0 monster s1 fish is 2 and then every subsequent item is going to be next meaning what i could be doing is turn these two around and call fish first and then monster if i run this now we are still starting on our shark but now fish is the first item of inheritance then we have monster and we still have object finally but in my case i do want to keep monster as the first item so the first thing you do have to understand is if we are calling the super dunder init method we are looking at the first item inside of these arguments here so in this case monster meaning for now i can minimize the fish class and just look at the monster and let me minimize these methods as well so it's a bit easier to see and basically what i can do now let me comment out the mro and i actually want to create a shark object from my shark and this is something you should be familiar with from simple inheritance right now we only have the byte strength so byte strength and this we can set to whatever we want let's say 50. but now for this superintendent method i need the arguments for the init method of the parent class in this case health and energy these two i want to pass in here now for these two i again i am going to need some numbers so for the init method of the shark class i also want health and energy meaning when i create the object i also want health and energy and let's set those to i don't know 200 and energy could be 55 and with that we are essentially back to simple inheritance i first call the class itself and the first one we do after calling the class we are calling the init method and inside of the init method python knows that the first item of inheritance is the monster class and then after that python knows we have one parameter for byte strength and this we're just setting as a parameter and then we are done with it so this is as far as this one goes besides that we also have health and energy and these two we want to pass into the init method of the first parent class so the monster and those we are getting up here but now we have another problem and that problem is what happens to the fish let me run the code and let's see what happens are not getting an error that's a pretty good sign now if i run shark and the methods we have here could for example be attack and for attack we need an amount let's say 10. the monster is attacked 10 damage was stealth so this attack method works just fine besides that i can also print shark.health and let me print this this one is working 200 we also get shark dot energy with 55 and we are also getting the byte strength so far we have the shark itself and the monster what we don't have is the fish let me minimize the monster class and open the fish in here we have speed and has scales and this our class doesn't have right now so if i type shark and speed and run the code we are getting that the shark object has no attribute speed which means that the inheritance from the fish is not working right now and let me reopen the monster and hide the monster methods so we can see all of the classes quite easily basically what is happening the mro is important here again this one here essentially how you have to think about it we first of all call the shark and then we call the init method of the shark and then python knows the first item of inheritance is the monster and since we are calling super.init we are calling this init method up here and passing the arguments in there the consequence is that we have health and energy for the monster and the normal inheritance still works so we also have attack and move but now the problem is that the init method of the fish is never called and as a consequence speed and has scales doesn't exist inside of the shark and what we have to figure out is how to call this init method and since we still have to worry about the mro we have to figure out how to call this init method with the arguments from inside of the init method of the monster and for that purpose we are still going to need this super and then the dunder init method and this function is very smart because it follows the inheritance that we have set by the shark to begin with meaning if we call the monster from the shark it knows it has to look at the fish next in line however if you call the monster by itself this init method wouldn't really do anything so this is a very intelligent function in the simplest terms basically what this init method has to do is to set the speed and hash scales of the other class which is the fish again let me set some static numbers for the speed let's go with 75 and for scales this should be false and now if i run all of this again i get for speed let's try this again now for speed i get 75 and for hash scales i get false the arguments we have set in here and this is especially if you are starting with objects probably going to be really confusing but the one thing that makes all of this work is the order of the indent methods we are first calling this one here this is number one then we are looking at the monster which is this one here this init method is number two then and then finally we are looking at the second item in the inheritance which is the fish this for shear so this init method is called third and we always need the super init method to go to the next item and what we would want to add in here as well is a super and then dander init method for the fish as well so if there's going to be another item in the list of inheritance or in the mro we would also call that one and for that reason you very often see super init in most classes because it enables inheritance to work across multiple classes and well i hope you can still follow along this is getting quite complicated and it is just going to get worse because right now we do have one problem and that is that this speed here and the hair scales are constant right now but i want to be able to set them dynamically when i am creating the shark meaning what i want to do when i create a shark i want to set this speed let's set it to 120 and i want to set has scales to false and this would then be all the stuff i have for the shark and i think it makes sense to put all of this on separate lines to make it a bit easier to read all right but now if i run this we are getting an error that shark init got unexpected keyword argument speed basically what pipeline is complaining about that this speed and this has scales don't exist in the parameters for the init method of the shark class we can fix that by adding a speed and has scales in here if i run this now this is going to work but we're not doing anything with either the speed or the hass scales we are still up here setting the speed and has scales as constant numbers and now we kind of have a problem because if i try to in this superintendent method at this speed and has scales then let me fix the typo first if i run this now we are getting the other problem that monster.init down here is the error we're getting right now monster.init takes three positional arguments but three were given meaning python in the monster class wants three arguments self health and energy and those we do get let minimize the fish for now so we can see what's going on we are getting health and energy and this is what this init method wants but besides that now we are also adding speed and has scales and for this the init method doesn't have any parameters so python is very unhappy because it gets too many arguments and it doesn't know what to do with them but this is a problem for us because we need those two arguments to pass into the init method for the fish but the init method of the monster doesn't have as many parameters so we have a problem here and to overcome this we need one special concept and that in python is called keyword unpacking and basically what it means is in my monster class after i have added all of the parameters i definitely know i need i want to add star star and then keyword arguments and that way any argument i get after the parameters i am going to store those in a separate dictionary let me actually print what we get so i want to print my keyword arguments without the stars for now and for these double stars python is expecting keyword arguments so all of the arguments for the init method here need to be keyword arguments meaning health.health energy is energy speed is speed and has underscore scales is has scales and now if i run this we are getting a dictionary with speed and has scales and this faults here we are getting from printing shark has scales let me remove that and try this again now so now we can focus on just a dictionary and that is something really useful because this we could use in here now and essentially what you have to do is call the unpacking operator again and passing in the keyword arguments and now if i run this again we are still getting the same dictionary so we are getting speed and we're getting hash scales what happens now if we are calling this star again it turns each key value pair inside of this dictionary into a named argument meaning this speed under 20 is going to become a named argument and then this we are passing into the init method of the next class in the method resolution order and with that if i now print shark dot speed and actually display what we get i now get 120 the one we have specified in here and this is how you would work with this now for an actual example you would add a lot more quarks to all of these classes for example the fish would also have double star and keyword arguments and then you would pass this into the init method as well so in here quarks as well now in this case the keyword arguments is going to be empty if i print it keyword arguments and run this we're getting an empty dictionary because we don't have any additional named arguments that we have to worry about so this dictionary here is going to be empty well this dictionary actually but if we had more named arguments they would all go in there and this is then how you would deal with multiple inheritance and if again you are just starting with inheritance this really isn't something you want to worry about too much probably if you're watching this for the first time and you're still struggling with objects in general this is going to be way too much i would recommend just practice objects and simple inheritance for now and once you are more comfortable with them come back to this this sort of inheritance is only really something you are going to see once you get much more advanced especially for making games or for making gui's you probably don't need any of this whatsoever all of the games i have made so far have never used multiple inheritance they all use simple inheritance and they worked just fine but well at this point we have covered all the main parts of classes i guess at this point there is some more smaller things i do want to cover but they're all going to be fairly simple so let's talk about them in the next section alright for this part i want to talk about some extra parts for classes and those are things i couldn't really fit in in any of the other sections but they're all fairly simple but they can be quite useful and well let's do all of this straight in code i think that's going to be the easiest all right once more we have the monster class and this is just something i want to use to illustrate what we are going to do and let me create an instance of this monster with monster and for the health i want 20 for the energy i want 10. it really doesn't matter what number we go with here and now there are three things i want to cover the first one is private attributes the second one is has utter and set utter and the third one is going to be the dog string and once we have those we are basically done with classes and the first one is going to be private attributes which is just going to be an attribute inside of a class that cannot be influenced from outside of the class which may be something like an id number that you really want to make sure of cannot be changed from outside of the class to be sure that it doesn't mess with some other code and this actually isn't possible in python we are always able to change the attribute of a class so python developers came up with something else and this let me copy this comment here and in the init method of the monster class i want to create a private attribute and how you would do this is first add an underscore and then the name of the attribute let's say in this case i want to have an id and the number i want here could be 5 but it could be anything it really doesn't matter and now this id by convention is not supposed to be changed but this is just a convention basically what you do with this format is you tell other developers that this attribute should not be worked on but you totally could work on it for example what i can do i can print monster and then underscore id and i get 5 meaning you can work with it but there's a very clear indicator that you shouldn't so if you ever work with somebody else and they added something like this you probably should not change it and well that is all you need to know about private attributes you could do the same thing for methods you are essentially following a naming scheme so this works with both attributes and methods all right next up we have has utter and set utter and what those two are doing is they allow us to check if a class has an attribute and we can also use it to set an attribute and the first one is going to be has utter and that is just going to be a normal python function and this one wants two arguments it first of all wants to have an object and besides that it wants a string with an attribute name and let's try this one i want to look at my monster and for my monster i want to check if the monster has health and this is then going to return a boolean that either says true or false meaning i can print all of this and i get true so this monster has the attribute health if i check for something that doesn't exist let's say a weapon i get faults because the monster doesn't have a weapon and this you could then use an if statement for example if has utter monster health and if it has health i want to print the monster has and i guess then we can use an f string monster dot health and that is terrible spelling and let's turn this into an f string and add health at the end and now we run this the monster has 20 health and that is what we have set here and this is has utter it's a really useful way to check if a certain class has an attribute you are going to use this fairly often actually it's a really useful function and besides that set utter works in kind of the same way so let me call it set utter and in here we need three arguments first of all we need an object then we need a string of an attribute name let's call it attribute again and then we have to set a new value and this could be a string it could be a number it's really up to you i guess let's say again i want to look at my monster the attribute i want to set is a weapon and for the value let's give the monster a sword and now i can print monster.web pin and i get sword and this set utter is basically the same thing as calling monster dot weapon and setting this to sword these two things essentially do the same thing and now you might be wondering why do we have this kind of redundancy that this is kind of pointless at least seemingly that we have this entire function that does something very obvious but the reason for it that this allows us to very efficiently create new attributes for example what we could be doing let me comment those two out and i could run a for loop and let me add a let's call it new ad reviews and this is going to be a tuple with lists i want to have for example a weapon and there i can have an x besides that i want to have another list with let's say armor and the armor could be a shield and finally i want to have one more list and this could be potion i could set something like mana or whatever you want to go for and now i can use that as a for loop so for attribute and value in new attributes i can call set utter i can pass in my monster in here and then i want my attribute and my value and if i run this we are not getting an error which is a good sign and now i can print my vars for the monster and i get the new weapon the new armor and the new potion and this way you can set a lot of new attributes and values for class by using this if you just used monster.weapon this one here this would not be possible and this is why set utter exists although you probably would want to create all of these attributes when you actually create the object itself so this isn't something you want to do too often although in some situations it can be really useful alright with that we have set utter and has utter and finally we have doc and doc is just there to explain what your object does that's really just about it you are getting doc or the doc's string to be more specific by calling monster and then dunder dock and in this case if i run this we get none for the simple reason that we have to create a dock string for our object and this you do first thing in the object and all you do in here is you set a triple quotation mark like this and then in there you are setting what you want for the monster for example i could write in here a monster that has some attributes and i am really bad at spelling monster for some reason and now if i run this print again and now i get a monster that has some attributes and this you could make significantly longer depending on what kind of class you have but this is usually what you want to set to explain your code to other people and especially if you work in a team with much larger projects it's really helpful to set something like this because well somebody else might have no idea what you're talking about what you can also do is let me comment out this print statement here and instead call help and i want to look at my monster if i run this i am getting a long list of different things and in here i can see lots of useful things for example i can see monster and its parameters i can see the dog string and i can see all of the methods inside of it and if you just find a new object you don't really know much about the help function is really useful as a matter of fact you can also pass normal python code in here for example what i could pass in here is just str for string and now python gives me the help function for strings and if i go all the way to the top there you can see basically that we have another object and the object takes one argument which is going to be a string then we have the dog string and this one explains what this object does and afterwards we have all of the methods and there are quite a few because strings are very complex objects and with that we have covered objects and classes i hope that wasn't too difficult but this is definitely something you do want to practice so hope that was helpful and i will see you around in this part we are going to be talking about modules this is the part where python really becomes powerful so let's talk about it essentially modules are just extra parts that we can attach to our programs for example if we wanted random numbers we would add the random module that's basically what it is there are quite a few modules that we can use that come with python by default and random is the one you are probably going to use the most but i will cover a few more in just a bit besides that we can also create our own modules to make our code more organized and each module would be in a separate file which makes it really easy to organize larger programs which is something we're also going to cover in just a bit but the much more important part is to use modules for extra functionality and let's start with that one and in here we have two different options we can either import from the python standard library all this really means is that these modules come with python when we install python so we can just import them and then work with them it's super easy besides that we can also import additional modules made by other people but those we have to install on our computer first these modules here can become incredibly important for example if we want to make games or work with machine learning or do data analysis or run databases we would basically install additional modules to make all of this work but let's not get ahead of ourselves and let's start with the python standard library and by just talking about basic modules here we once again have a completely empty python file and what i want to create is a random number the problem we have is that there's no way so far to create random numbers but we can do it by importing a module and this we do with the import command and then the name of the module and the module we want here is called random and this one is giving us random numbers i think the name makes sense here and random has lots of different sub modules that we could be using and the way you would access them is first the name of the module and then the methods inside of it and one here is called randint which is standing for random integer and this is just a method we can call it although this one is expecting two arguments a minimum and a maximum number but once i have those two i can print the random number and now if i run this i get different random numbers every time i'm executing this code and now you might be wondering how do you know what else is inside of the random module and that's a really good question usually what you do is you just google the module and then you find lots of information for example for random we have a whole documentation that is actually incredibly extensive so all of the stuff in here would be part of the random module the one we have seen already is random.rentend and all it does is it creates a random integer between two numbers and this is a function you are using all the time it is really popular another one that you are seeing fairly often is choice and this one picks a random item from some kind of sequence this could be a list it could be a dictionary something like that and let's actually implement this one here i'm back in the code and i want to create a test list and for this test list i just want to have a couple of numbers it really doesn't matter i guess let me put the print on top and now i want to select one item from this list and for that i would get my random again and i would add choice and now this choice is expecting one argument and that is the list so test list in here and now all i have to do is print the result and let me comment out this stuff up here so we're not getting confused and if i run this we get different items from this list i guess to make it a bit more visually appealing let's add a few different data types in here this one is looking better so now if i run this we get all of the different values and that is in the most basic sense how you would be using modules and there are a lot of different modules that come with python already if you look this up online you are going to find this list calling the python standard library and those are all of the modules that come with python and in here we have a lot of different options that we could be working with for example the one i'm seeing right now is called tkinter and this is the most common way to create guise or graphical user interface in python it basically gives you buttons besides that we also have a ton of modules that work with the internet and if i go up a bit more we can see i hope i find it there should be random in here somewhere there we go there is random and there are quite a few more modules that we could use with numbers chances are you are only ever going to see a very small part of all of these modules even i have only ever used a very small part of them for example i have no idea what rl completer is i have never used it even once but some modules in here are incredibly useful and you do want to have a basic awareness of them and you basically learn all of them by just using python and then discovering more and more of them now if you want to import multiple modules you can do it in two ways you could either on another line import something again let's say what i could also import is the string module and what this one does let me comment this one out i could for example print string and in here i could print the s key underscore lowercase and be aware this is not a method this is just an attribute and if i run this i get all the lowercase letters of the alphabet that's really it string is a very simple module if you are importing two modules just like that to save a bit of space you can put all of this on the same line like this and then i can get rid of the second line run all of this again and we get the same output the random module would still work just fine i guess one more module that we could be looking at that you do see fairly often is called math and this one is giving us a few more advanced math functions for example what we could do in here is print math dot sign curve and add like a 1 in here and if you have no idea what this means don't worry too much about it it's just a sine curve not something you use too often unless you are doing some fairly specific tasks i suppose a more common operation for math would be floor and this one gives us the floor of an integer meaning if i have 4.9 this one is giving me 4. we are basically just rounding down that's all that's happening in here and with that we have a couple more modules now there are a few more things you can do with the import statement and those are mostly to be more specific in terms of what you import for example for my math i only want to import math.floor and nothing else and if that is the case you can just type from math import floor and this way we are only importing floor and we don't have to worry about the math part in front of it meaning now when i'm calling it down here i can remove it and call floor like any other function oh and let me get rid of the comma all the way up here that shouldn't be there now if i run this we get the same outcome and this flow now works like any other python function if you really wanted to you could also rename this floor function and this you would do by adding s and then the name and you could name this any valid python name i could for example call it get floor and then this one here would be get underscore floor and there we go same outcome i guess what you would mostly do in here is to shorten method names if they get too long for example i could shorten this to f and this would then save me quite a bit of writing and some modules do get very long so this isn't actually as rare as you would think it is and finally there's one more thing that we can do let's say for this random here i want to use all of the methods but i don't really want to write this random at the beginning every single time and to achieve that we would use from random again but now when we import individual modules we are typing a star and this tells python we want to import every single method and function from the random module and then use it in our code and this allows us to use all of them without writing random first really now i can run this and i still get the same outcome although this you really don't want to overdo because if you import all of it you are well importing all of it and this could add a ton of functions and methods and variables that you don't want to use and that could clutter up your program but alright with that we have covered the basics of modules and let's do an exercise and this is going to involve a bit of research on your part what i want you guys to do is to get the current time from the date time module so do some google research and try to figure out how to get this it should be doable in a single line of code i guess two lines of code if you include the importing part as well but pause the video now and try this one yourself i suppose the best way to start this is by doing the research ourselves here again we have the website with the python standard library and what i'm looking for it's already in here i am looking for date time the module and this i get here if i click on it i get a lot more information and in here if you scroll down you can find a ton of different things it's actually quite an extensive module but i'm just looking for one specific thing i hope i can find it for example here we would have today that is kind of useful but i want to find the current time and the current time i can find ah in here class method daytime now this is what i was looking for and this gives me the current time now you obviously didn't know that this one even existed so this probably took you a bit more googling but most of the time this is how you discover new modules you just google a problem then you in some form find a new module and this solves most of your issues that's basically how everybody learns python or any programming language in general let's implement it here i'm back in the code i want to import date time although day time is a bit weird because what we have to do is from date time import date time and what that means is inside of the date time module we have one object called datetime they just happen to have the same name which can be kind of confusing but well it is what it is and i guess just to be a bit fancy here let's abbreviate it as dt and now to get the current time i need my datetime dot now and this i can just print and if i run the code now i get lots of stuff let me comment out all of this and now i get my current date and my current time down to some nanoseconds with that we have covered all the basics of modules meaning if you got so far you already have a pretty good understanding although you can do quite a bit more and that is going to be the next part in this part we are going to cover external modules and external modules are just modules that are made by other programmers and this is giving us a ton of extra functionality for example any kind of game development any kind of data analysis machine learning graphical user interface and a lot more is essentially just a module made by somebody else and we are using these functionalities and this is one of the really strong parts of python there is a very active community that makes a lot of extra modules that you can use for your own projects almost all of them are free there are some very select ones that are being paid those are usually more business oriented ones that you don't have to worry about and these modules are imported like the standard modules the only difference is that these modules have to be installed on your computer first and this can be done in a couple of ways the most common one is in the powershell or the terminal now what does that mean the powershell is for windows and the terminal is for mac os and both are command line interfaces and what a command line interface is is simply a way to interact with your computer simply by typing text if you ever watched any kind of old movies those always use command line interfaces where people just write commands into computer there are no buttons no windows you just write text into your computer and this is what we are doing here as well and this is the way python is intended to be used it's honestly the easiest way and sounds way more complicated than it actually is but let's actually have a look at this and let's start with windows both versions are identical bar a very minor difference now for windows you just have to open the start menu and type powershell and if you press enter you can see something like this let me full screen it and this is a command line interface for windows and in here i can type a ton of commands to make windows do something in my case i only want to do some very specific things and what i want to do is to type pip and install and then the module i want to go for and pip is the python package manager meaning this is what we are using to install any kind of external module and the module i want to install now is called pi auto gui and now all you have to do is press enter and python is installing a bunch of different things there really isn't that much we have to do ourselves but at the end you can see successfully installed pi out to gui and then the version name and that is basically all you have to do although i guess there are a few more things i do want to cover in here one command that i found really useful is called clear and this one clears the entire interface so things are a bit cleaner and one more thing that can be useful is called pip list and this one gives you all the modules that are being installed and your list should be a good bit shorter than mine but you can install a ton of different things here and finally if you want to uninstall a module you will just run pip uninstall and in my case i want to uninstall pi or to gui then python would ask us if we want to proceed i want to with yes and now it's uninstalled now i can clear all of this again and since i do want to use pi to gui i want to install it again and this could be a good exercise for you so install pi or to gui yourself again and see how far you get all we need is pip install pi or to gui if i type this we get all of this again and we have installed pi or to gui and that is pretty much all we needed and now that we have that let's do the same thing for mac os you open all of your programs and in there you type terminal once you do that you're getting a new window and let me maximize it in here if you hold the apple key and plus you can increase the font size which i really want to do you might not need it and in here we can work with mac os using commands just like in windows i could type commands here to control mac os obviously not like that but you get the idea for example clear works just in the same way most commands do actually the one minor difference here is we do not type pip install and the module instead we would be writing pip 3 install and then the module the only difference here is the free the rest stays identical d3 here is needed because on mac os python comes preinstalled the problem is the python version is really old and when we installed python on the mac we installed a separate version of python and this three is to tell python that we want to use the latest one which is python 3 we do not want to use the original python but that is the only difference so in my case i want to install pi auto gui i press enter now python is doing a thing and at the end we get successfully installed pi auto gui and if you notice here this is the same version we have on windows and with that we are good to go inside of our code editor there's not going to be a single difference so let's have a look at that alright here we are back in my python file and i'm using windows but this is going to work both with mac and with windows the installing part was the only difference between the operating systems but now i have pi out to gui so i want to import it so import pi or to gui and what this module is doing is it automates windows to a certain extent for example what you could be doing is to move the mouse around or to write some text from your computer with python and i guess let's get started with that now that we have pi out gui i just want to call the entire module and then right and now and here i can tell it to write some text for example this is written by a computer and now if i would run this code we would have this typed out although right now this would be kind of awkward because i have no time to switch to another program like a text editor meaning i want to import another module from the python standard library or another part of a module and this is called from time import sleep and all that sleep does is it pauses our code for a certain time interval let's say i want to call sleep and one second and now let me bring in a text editor and let me run the code switch back and now we have this is written by a computer the text you have just seen was just written by python not by me i suppose to make the effect a bit more noticeable is for this method here we can add another argument or a named argument to be more specific and this is called interval and in my case let's go with 0.5 probably a bit long let's say 0.25 and this is the interval duration between each letter that is being typed out i guess let me write it again and switch back to the text editor and now you can see this is written by a computer just very very slowly i guess what you also could do is run the code itself and now python is writing this code by itself in sublime this is also working just fine prior to gui doesn't care where it's writing it just starts typing these letters let me get rid of them and with that we have one module the only difference to standard modules is we are first installing it via pip and then we're using it like any other module and the main task for you is to understand what each module is doing and for that you usually find documentations online let's actually have a look at the one for pi auto gui it is looking like this and if you scroll around here you can find a ton of different things you could do for example you could move your mouse you could add a click you could add a double click you could write you could press a button there are a ton of things you can do with pi or to gui it's a really fun module and well this is then bringing us to the exercise bit and what i want you guys to do is to do a bit more research and what that means is create a graph from any of the examples below i should type these things out more but essentially here you have a link to a website if i copy this and open the website you can see a tutorial for pipelot in the matplotlib module and this is the standard module you would use for data analysis it basically makes nice looking graphs and i want you guys to look at any of these examples and try to understand what is happening or well you first have to install maploid lib and then you can follow any of these examples so try to do that install the map.lib module and try to copy or understand any of these examples it's entirely up to you which one maybe go for something slightly more complex this could be a really good challenge for you i want to work on the simplest example here because i want to keep the video short and the first thing we have to do is to install matplotlib so once again for windows i want the powershell let me maximize it i guess let me clear this one first so it's a bit easier to read and now what i have to do is pip install matte plot lip and if i run this we have to install quite a few different things this is going to take a second and we have successfully installed map.lib 3.5.2 and if you are working on a mac this would be pip 3 install matplotlib now that we have that let's return to the code and in here let's comment out all of this and we have to figure out how to import mapp.lib and let me bring in the reference from the site let's put it here this is good for reference on the first line we have to import map.lib.pipelot as plt when we're importing map.lib we are not importing all of it we're just getting one subpart of it pipelot and we are renaming this to plt because typing is hard so i want import mad plot lib dot pi plot as plt and now after the exercise i have to create a plt dot plot and this one wants a list with a couple of numbers in the example it's one two three and four and once you have that you can already run this program and you're running this with plt dot show meaning if i run this now we are getting a graph the one you can see on the right besides the y labels and in here you can change the numbers quite easily for example i could add 10 0 100 and if i run this again we get a very different looking graph all that the plot method really wants is the list of numbers and then it puts them into a line chart and what we also see in the example is plt dot y label and all this one really does is it adds a label on the y axis so some numbers in this case on the example and i guess let's copy it one to one we have some numbers for the y axis to be a bit more specific now if we run this we have some numbers for the y axis we can also do the same thing for the xaxis if you really want to and this you get with plt dot xlabel and then we have some number for the xaxis if i run this we can see at the bottom now we have some numbers for the xaxis and that would be matplotlib or at the very least a really basic introduction to map.lib map.lib is a really complex module that can visualize data in a ton of different ways so if you want to learn it it is going to take you quite some time all right with that we have external modules so the last part for modules is to create our own or at this part we are going to create our own custom modules and the one question you might be having is why would you want to do that and the answer primarily is organization that you are creating modules and each module is in a separate file and that way you just never have too much stuff in one file which really helps organizing your code so far we just never really needed it but later on when we have thousands of lines of code this becomes incredibly useful to not get lost on your own program that being said you don't have to do it but it's a really good idea to do that i guess let's implement all of this and that should explain it the best all right here once again we have a completely empty python file now since we are working with multiple files i want to be able to switch between them and the best way for that is using tabs so in sublime i'm pressing alt and then i can see all of the menu options you could get the same result by pressing f11 and then you get this menu item here and you can select different things and in my case i want to in view show tabs and then i can see the different tabs i've opened right now only one and let me return to full screen so it looks a bit cleaner and now this module is only going to import the stuff from another module meaning i have to create another python file with control n and this one i want to save so if i click on save i can save this to whatever i want let's call this one my module and this is still going to be a python file and now i save this and now i have two files open that i can switch between although right now both are completely empty and let's start in mymodule.pi in here for the simplest possible example i just want to create a test variable and this could have any value let's say test and now this module i want to import in my custom modules python file and this happens in the normal way i first have to import my underscore module and this should not be capitalized and if you run this and you don't get an error this is looking pretty good and now that you have that you can use this module like any other module for example in our case i can run my module and then in my module i have a test var let me copy it i can print this and i get test this is also going to work with functions and with classes for example i could create a test underscore function and then here we could even add some parameters and let's say i just want to print this is an imported function with the parameter and then parameter and now this function i can also use inside of my main module meaning i want my module dot test underscore function and the argument i want to pass in here let's say is one two three and if i run this now we are getting an error the name parameter is not defined and oh the reason is that the parameter and this parameter here have different names this one should be content and now if we execute the code we get this is an imported function with the parameter one two and three so this one is working just fine finally what you can also do let me do it below the function i can create a class called my class added here you can run init with self and give it a self.name let's call it my app and we can call self.value i don't know 12. and this can also have a method it's literally like any other class let's call it do something it needs self and nothing else and then here i just want to print hello so once again super simple class that we now are able to import in the main file actually what i can do if i hold ctrl and click on my module i can see both files side by side which is quite handy and while looking at this i realized that this has the wrong naming scheme this should be my class in fact now looking at this this feels like a really bad name let's rename it to test and now i can call test and mymodule.test and don't forget the brackets now i can run test dot do something and if i run this we get hello meaning this module test here refers to this class test and this do something refers to this do something here and later on you are really going to appreciate having more files with less code in each individual file it makes it much easier to work with but i guess let's do an exercise and what i want you guys to do is to create a some calculator function that takes unlimited arguments and returns the sum and create it here and run it in the main file so pause the video now and create this one function import it to the main file and then run it there all we have to do is create another function and let's call this one sum calculator and in here i want to have one parameter that i called nums but i want to be ready for unlimited arguments so this i want to unpack and now inside of the function all i want to do is to return the sum of these nums and that is literally it now that i have that i can i guess we can be a bit more fancy here let's say from my module i want to import the sum cal q later and again this is working exactly the same way compared to what we have seen before with the external or the python standard modules and now that i have that some calculator and i can add one two three four and five run this and we don't get anything because we're just returning something we are not printing it so let's print it and there we go we get 15. and with that we are pretty much good to go for modules although there is one more topic we do have to cover that is going to be quite short though when you are creating your own python modules there's one really important concept you have to understand and that is called thunder main all this one really means is when a python file is called it creates a couple of internal variables and than the main is one of them it is in fact the most used one essentially what it does is it gives a name to the current python file and the one that we are executing is always called thunder main but any imported file is called dunder and then the file name and this is really useful to control what code is being executed and more importantly to avoid executing code by accident here is the example from the last video and in my main file i want to print dunder name both in my main file and in the one i am importing and if i run the code now i get done domain all the way at the end and all the way at the top i get my module i guess let me comment out all of the other print statements that is going to make it easier to read now if i run this we get two print statements we have my module and main and what happens internally is python first runs all of this imported code here and what it gets at the end is print name so it prints my module and this my module is the same as the name my module up here this is the name of the file and after that we are printing in the main file then the name and then we are getting done domain and the reason why this is called main instead of the file name we get up here is that this is the file we are currently executing if i just looked at my module so this one here and run this again and we are getting main here because right now we are executing my module which turns this one into the main file and this is being used usually with an if statement and you're looking for if dunder name is equal to thunder main only if that is the case let's say i want to print the main file this makes sure you're only running this code if this is actually the file you are executing and most of the time when you have multiple files like in this case all of the actual code is inside of this if statement if you have other kinds of code let's say for this one here for my mymodule.pi i would add the same if statement this one here and then the print statement would be inside of it if i executed my custom module i would only get the main file this one here and inside of my module this one here would not be executed and this way if you have this if statement for every single file you have a lot of control about what is getting executed when you are importing the file which can be incredibly handy in this entire section we are going to cover some extra topics now i do want to be clear here basically all of these parts are very useful but not that common especially for beginners the longest video in here are decorators and error handling as a beginner you are not going to encounter them or use them basically at all meaning at least for now it's perfectly fine to skip this entire section and return later it is probably a good idea for you to practice basic python and then explore these areas especially decorators can get really really complicated and if you're just getting started you are not going to use them anyway so you might as well skip them at the very least for the beginning that being said i do want to cover them because i want to cover all of python and first of all i want to cover two very simple topics that i would recommend you to check out and those are called pass and input all that pass really does is it tells python to not do anything this does seem kind of pointless and basically you would only use it if you have a function but no content yet so maybe you have a function with a good name but you don't yet have good content for the function so you have to fill it with something and you would use a pass for that besides that we have input this is another function that can get user input although you are hardly ever going to use it i'll talk about it in just a second but it really isn't as useful as it sounds so inside of a python file let's say i have a function that is really important function name with whatever parameters you have and for this function you don't have content yet you don't really know what to do with it or at least you're prototyping it but you do want to keep the function by itself but if you're doing this without any content and run the code you are going to get an error because python expected an indented block after function defined on line one so python needs to have something in here and for that you could just add pass and now everything works just fine so pass is basically telling python to not do anything and well not doing anything is something you usually don't have to define though this past you hardly ever see anything productive it's pretty much only there to cover some kind of content where you don't have content yet it's a filler essentially now besides that we have input let's say i want to get some kind of user input and for that we would need input and now in here we can use this kind of like print for example i could print to the user press a button and whatever the user is going to press is going to be stored inside of this user input however there is going to be a problem because if i am running all of this we can see press a button however if i keep on pressing a button i keep on typing in subtime the issue here is sublime does not support input for that we would have to run this python script inside of the powershell or the terminal and how this is going to work let me print the user input at the end so we can tell what's going on and really importantly do save the file what i want to do now is to run this script inside of the powershell or the terminal and let me put this on a separate screen so here we have the powershell and here i have the folder with my python file that i have just created and if you want to run this what you have to do is you first have to type hyphen to run a python command and then you need the file path towards this folder here let me show my mouse actually inside of the terminal you can add a ton of commands to navigate to folder structure the thing is that's kind of complicated and you don't need it all you really have to do is to drag the file in there and then you get the rest automatically so this is all you really have to do just drag and drop the file don't forget the python at the beginning but other than that all you have to do is press enter and now you get press a button exactly what we have specified inside of the python file and now i can press this is my input and if i now press enter i get this is my input and after that the code finishes and we can add another kind of input for example we could add clear in here and we are done and that's really how you run files inside of the powershell or in windows in general and welcome back in this part we are going to cover error handling and well for this part we are going to handle some errors which means obviously your code should not contain any errors because that would crash your program and that would be bad the issue is sometimes you can't really avoid having some errors for example you might try to find a file and it just doesn't exist and you don't notice in advance and as a consequence you want to have the ability to anticipate and deal with errors and fortunately python can deal with that quite easily there are quite a few different ways to do it actually and let's jump straight into the code and let's have a look at all of this alrighty here we have an empty python file and let's just create an error just to get started i want to print one divided by zero and if i run this we're going to get an error we have a zero division error that we are dividing by zero and this is not allowed because math doesn't like it so what could we do to overcome this or rather how can we make python try some code snippet and then do something else if we get an error and well the command is literally called try and this works kind of like an if statement except without any arguments we're just telling python try this line of code here if it works cool if not we want to do something else and the else here is called accept and inside of that i can print something else let's literally write something else and now if i run this we get something else what happened here is that python first went with try and the code in there was this print statement and this print statement included the operation 1 divided by 0 which is not possible as a consequence this here gave us an error and because of that we are going to accept and inside of that we are printing something else and this is what we got in the end as well if i had valid code inside of the try statement let's say 1 divided by 1 we will get the result of this line of code here and accept would not be run and that is the easiest way to deal with errors in python however we can both be more specific and we can add more things towards this and let's be more specific first and that is for this except statement we can specify specific errors that we are looking for for example what we are looking for right now is a zero division error and if i run this we are getting the same outcome however now if i add another print statement and i print a variable that doesn't exist yet which if i run this is giving us another kind of error specifically a name error and we are right now only dealing with zero division errors so when python sees a name error it doesn't know what to do with it but well we can account for it by adding another except statement and now we want to look for a name error and if that is the case i want to print let's say does not exist and now if we run this we get does not exist and be aware what happens here python starts all the way at the top with try and then it goes through these lines of code here and we are starting with print a and this one doesn't exist and as a consequence none of the stuff below is executed and we jump immediately to this name error and in there we are printing does not exist which is what we are getting down here now one important thing you may have noticed is that let me actually get rid of it this print here which should have given us this accept statement is not being printed down here in the console meaning that this here wasn't even executed it's really important to understand as soon as try finds any error any code after that is not being executed which is why we only ever get one except statement or the result of one except statement to be more specific and if you happen to be interested in all the possible errors that could happen in python there is a whole documentation online and in here you can find for example arithmetic error buffer error lookup error assertion error lots of different things that could be raised so if you are looking for some specific errors that could come up this list here would be really useful what you want to look for is build in exceptions there are two more things that we can do one is else and the other is finally and let's start with else that one is well it's basically an else statement that you should know from the if statement let's say in here i can just print let's say the else statement and if i run this right now this else statement is not run because we do have an error this name error here specifically but if i run some code in here that does exist let's say print try if i run this now we get the code inside of the try statement and we are getting the else statement as well but the else statement is only run if the try statement doesn't have an error the way you have to think about it is that this else is an else to these except statements and finally we have well finally and finally runs whenever all of this stuff finished and it runs either way it doesn't matter if we have an exception or not let me print finally and if i run this now we get finally again and this is going to happen let me run the zero division error again this finally even comes when we have this division error here i guess i should rename these things a bit more properly you cannot divide by zero and now let's run this again this looks better what is happening in the code right now we first number one start with the try part up here and inside of that on this line here we're getting an error and this leads us to the exception error for zero division error and in there we are printing you cannot divide by zero which is this part here number two and finally we are ending on finally which is number three and this finally runs no matter what happens and with that we have covered how to handle exceptions although there's one really interesting topic and that is you can raise your own error let me actually add comments here to make this example a bit clearer this part here what we covered so far is anticipating errors or to be more specific exceptions what we can also do is raising exceptions ourselves and what i want to do in here for the example is i want to create a variable that must be a string and for now let's give it a string let's call it test string it really doesn't matter what the string here is and now what i want to do is to run an if statement that if this variable contains a string i want to continue as normal if that is not the case i want to raise an exception or well call an error same thing and for that we first of all need an if statement and to check the type of a variable we need is instance and in here i want to check my var must be string and the second argument is the string type or the type we want to look for which in my case is string and if that is the case the variable is all good and let's say i want to print must be string and let me comment out the earlier part and run this code and this is working indeed because a var must be string is a string indeed or it contains a string however now if that is not the case i want to raise an error and this you do with raise and then the type of error you want to raise in my case i want a type error and in here i can add a message as well as the argument and in my case i want to write must be a string if i run the code now nothing happens however if i change this string to something else let's say an empty list now i get a type error must be a string and that way with raise you can create your own errors to your heart's content and along those lines there's another thing you can do to raise an exception and that is called assert and assert basically means that you want to make sure that your code only runs if a certain condition is true think of assert as a stronger if statement that if this condition is false your entire code stops with an error for example what you could do in here let's do a simpler variable a is 5 and a always has to be 5. if a is not 5 i want to end all of the code immediately and this i do with assert and in here i can just look for any kind of boolean statement meaning a is equal to 5 and if i let me comment this part out if i run this now we get nothing however if i change the value of a to 6 we are getting an assertion error and that is caused by this line here and sometimes in your code you really want to make sure that a certain condition is true especially if you work with something more securely concerned this is something you really want to be using extensively but well with that let me uncomment all of this here as well if you understand these three parts you basically know all you ever need to know about error handling it doesn't get that much more complicated and that means we can do an exercise and then call it a day and what i want you guys to do is to create a list and then try to raise an index error and obviously account for this arrow as well and type some kind of message with the print statement also try to use else and finally and see how far you get you might have to do some research online to find what an index error is although i think it makes sense what it might be just try to guess let me start by creating my list and in here i want to list with one two three four and five the content really doesn't matter and an index error basically means that you are trying to get an index that doesn't exist for example i could get my list and then get the index 99 which does not exist i am getting a type error and the type error comes from here let me comment out all of the earlier stuff so we can focus on one thing now let's try this again and now we're getting an index error and that is what i want to account for let me cut this one out and instead i want to go with try and in here i want to get my list 99 which i know does not exist right now so i want to run and accept and i want to look for my index error and if that is the case i want to print that index does not exist and if i run this now we get that index does not exist and no error message anymore i guess with that we have covered the first two parts of the assignment besides that i also want an else and finally let's start with else and in here i just want to print that index exists let's try it if i run it by itself we are getting that index does not exist meaning this line here and we don't see else because else is only run if there's no index error so let's try to get the first index and let me print this one as well now we get two and that index exists which is this print statement here and this else statement and well finally we need finally and in here i just want to print finished and this one is the easiest it always runs we get finished either way if this is working or if it is not working and with that we have covered error messages it really is a fairly simple topic and quite easy to cover in python the main thing i suppose you have to learn is all the different types of exceptions that you can have but if you play around with this a bit it's getting quite natural so we are done with this one hello there in this tutorial we are going to cover decorators which are is somewhat more advanced topic in python so let's go over some theory first in the most basic sense decorators are functions that decorate other functions which does sound a bit cryptic but essentially what we do is we are wrapping one function around another function and let's do this a bit more visually to illustrate what's happening this is a normal function and usually what you do is you just call it somewhere and then you have something happening what decorators do is we still have the normal function but now we are putting another function around it and then when we are calling all of this we are calling the decorator function and inside of that decorator function we are calling the original function and this is allowing us to execute code before and after the function so when i'm calling this function here i could run code here and i could run code here without making any changes to the original function this function here would stay exactly the same all the actual logic happens inside of the decorator we are literally putting one function inside of another function and this other function executes extra code that's the entire idea of a decorator now why would you want to do this basically this way we can give extra functionality to a function without changing it a simple example here is we could write a decorator for a function and it makes the function execute twice when called not the most useful function but we are going to talk some more useful examples later on i just want to illustrate what is happening now in practice you are seeing decorators in three different circumstances let's go over them the most common one is you want to test your code without changing it let's say you work in a team you have some really complicated code and you want to test your code without making too many changes a decorator would be excellent for that the other example would be you are working in a team and you want to avoid making unnecessary changes now those two points are pretty similar you basically want to do something with your code without making too many changes and both of these are also fairly advanced if you are just learning python you are quite far away from either of these which is why you may be struggling with decorators because you don't really need them however there is a third case that you probably are going to use and that is using a decorator inside of a class because this allows you to run code when an attribute is accessed or changed so for example let's say you have a monster with health and every time that health is changed you want to run some other function inside of the monster with a decorator doing this is fairly easy although that being said decorators can be quite hard especially for beginners because we are going to use some more advanced functionalities in python that may be slightly confusing although i would really recommend you to try to follow along because this is going to be really good practice to understand functions and how to pass them around in fact before we start with decorators we need to recap functions itself so let's have a look at that here we have a completely empty sheet of code and let's just get started with a really basic function i want to define let's call it func there are no arguments and inside of this function i just want to print function just about the easiest function you can write if i call this function i get function so this really doesn't do all that much now there's a really important concept you have to understand that right now we are calling the function here and if we didn't do that so if i remove those brackets i could run this and nothing would happen but what i could do is print the function itself and now i get a function object meaning this function here as the whole function not what's being returned just the function itself and this is just going to be an object if that doesn't tell you anything check out my videos on objectoriented programming they should be quite helpful but basically what this func is giving us is a simple object that we can call and if we don't call it we are just getting a function object still not particularly useful but what we can do with this function object is pass it around like any other object like an integer like a string like basically any other object we can pass it around for example what we can do i can create another function and this let's call it a wrapper because this one is supposed to take the argument of the function and then i want to execute the function itself meaning what i can do now i can call my wrapper function and run this and i get function again and what is happening in here i am calling this wrapper and i'm passing in this function here what happens as a consequence is this function is being passed as a parameter into the wrapper function and inside of that function we are calling this function and when we are calling it we are printing the word function and now that we have that we could also do something like print hello and print goodbye and if i run this now we are running the function inside of another function and before and after we are calling it we are running some other code and this is basically the main idea of a decorator although it does get a bit more complicated but we'll come to that in just a bit now there's one more thing that you can do inside of a function and that is you can create a whole new function so for example let me create another function and let's call this one a function generator and then here we have no arguments to keep it simple and now inside of this function generator i want to create a new function and let's call this one new function i guess it's a good word and in here i just want to print new function and since this new function is just going to be an object we can return the new function and what i can do with that i can create a variable let's call it new function and i want to get my function generator and if i run this we can't see anything but now this new function is going to have this new function in here meaning what i can do i can call my new function execute it and we get new function so just to go over this because it may be a bit confusing this new function executes this one here and what we are getting from this function generator is we are defining a new function this one here and at the end of the function we are returning this new function and this we are capturing inside of this new function variable and this new function variable now is just a function meaning we can call it here and when we are calling it we are getting this print statement that's really all that's happening here the main thing you have to understand is we are basically passing around functions with the return statement with that we have some function basics so now we can actually start working on the decorator and for that let me open up a new file and in here i want to create an actual decorator now first of all for decorator we are going to need a basic function we want to decorate so for my function basics i want to copy this basic function here which is just printing function by itself so if i run this we get function literally the easiest function you can write more or less and now for this function i want to create a decorator and this is going to be another function that you can give whatever name you want let's say i want to call this one decorator to keep things simple and this decorator is going to accept one parameter which is going to be a function so in just a bit we're going to pass this function inside of this decorator what we are going to do with that inside of this function we are going to create another function and let's call this one the wrapper and this one right now doesn't have any arguments but now inside of this function i want to run the original function and besides that i can do quite a few other things for example i could just print the decoration begins and let me write this properly and i can also write the decoration ends and now after i have done that i can return this wrapper and now what i can do i can create my new function and this is going to be my decorator and instead of this decorator i want to pass in my function and once i have that i can just call my new function and i get the decorator begins the function and the decorator ends what is happening here let me go over this this is probably a bit confusing we are starting with our basic function and this function we are passing in here into the decorator function and this is the one we have up here and inside of this decorator function we are creating a whole new function this bit here and inside of this function we are calling the original function meaning this one here and then around this function we are doing some other stuff like we are printing these two statements here and then at the end of all of this we are returning this new function and this new function we are storing in the new function variable and then we can just call it like any other function and now we have extra functionality around our original function now where this becomes really interesting is let's say somewhere later in the course i am running function by itself which would just give me the word function let me comment out these two lines here if i just run fung i get function and nothing else and what i can do with decorators if i uncomment those two lines and get rid of this new func when i create the variable name for this i can just call it the same way like i have called the original function so i can call both func if i do that and run the code again i now have a new functionality for this function because we are essentially overwriting the original function name and that way our function even with the same name has new functionality and this is the basic idea of a decorator if we have this kind of system we can have really complex code and still check our function without making any changes to the code and since this is a reasonable common operation python has a shorthand for it and let me comment out this statement here and the shorthand looks like this i first write an add and then the decorator function so in this case decorator and now if i run all of this again we are seeing the same outcome for the simple reason let me uncomment it that this statement here and this line here they are doing essentially the same thing we are wrapping this function here inside of a decorator this one here and let's go over this a bit more slowly i think that's going to be useful here we have the function you have just seen and you can wrap this in the traditional way by writing the function and then we are putting the function inside of the decorator and then we are calling the function i hope this is making sense if you're confused about this i would recommend to pause the video now and just go over all of these different statements and see how they connect i guess i can go over it as well again we have this decorator here and inside of this decorator we are passing in a function and then we get this function here as a parameter now inside of this function we are creating a whole new function and this one is called wrapper and only inside of this function we are calling the original function this one here and then around this function we can do whatever we want like calling these two print statements here we could also do lots of other things i'm going to cover that in just a second and finally at the end what we are doing is we are returning this wrapper function and this wrapper function we are storing right now in func and then we can call it like any other function and that way we're using the name of the function and overwrite it with this new function that is being wrapped inside of the function which means if i took out this line here the function would come back to its original functionality and just print function now the problem with that approach is that we are writing func three times one two and three and if you want to call it a fourth time which is kind of annoying so what python developers have done is to create a shorthand for this and this is called a decorator and this one is looking like this and basically this line here where we have the name of the function a decorator and then the function as an argument is the same as this add decorator those two lines are doing the exact same thing meaning when you are calling this function you have the same result now obviously just printing two more statements isn't particularly useful so let's actually do something more relevant to see why decorators can be useful here we are back in the code and i want to create another decorator and this one i want to call the duration decorator and then here again as a parameter we need the function and inside of that i want to create a wrapper it doesn't need any arguments and in here first of all i want to execute my function and then return the wrapper and this is essentially a decorator that doesn't do anything right now and what i want to do with it is to measure how long it takes to execute this function here and for that to work we need the time module meaning i want to import time and now what i want to do inside of this decorator i want to get my start time and this i would get with time dot time and this has to run before i call the function and after i have called the function i want to get my duration and my duration is my time.time which is my current time and from that i want to subtract my start time and once i have that i can print let's call it duration and this should be an f string with the duration and now just to get some reasonable numbers in here when i am calling the original function i want to call time dot sleep and make it sleep for one second and now with this duration decorator let me actually call it so duration decorator i can now comment out this line here and now if i run the code we get function and we get the actual duration and from this line we know it took one point a tiny amount of time to execute all of this and this now we could get without making any changes anywhere else in the code we're just calling the function here we have the wrapper up here and then we're adding this one line of code to add some debugging functionality so this is something you could be doing if your code is running very slow and you want to identify what is slowing it down now another thing that i haven't covered yet is that you can combine different decorators and this happens by just adding them with the different add statements on top of each other and we already have another decorator so let me call this original decorator and let's run all of this again and now let me go through them i have decorator begins and decorator ends that is what we are getting up here from this original decorator besides that we have the duration of the decorator and this is what we are getting from this print statement here and the actual function so this print here is this line meaning now even though we have a very simple function by using decorators we can give it a ton more extra functionality without making any changes to it which is well the entire idea of a decorator if you understand this it can be really useful in very specific circumstances although if you are a beginner you probably just are going to add more stuff to this function although well if you know decorators you don't have to and this makes it much cleaner to work with your functions but alright let's do another exercise on this i want you guys to create another decorator that calls a function twice and this decorator should be called with this decorator and this decorator as well so that this function has three decorators in total and let's see how far you get again i have to create another function and let's call it the double decorator and in here once more we need a function and inside of this function i want to create a wrapper it doesn't need any arguments again and now in here i want to call my function twice which i just do by calling my function twice it's very simple once it comes down to it and once i have that i want to return the wrapper once more oh and by the way i'm just calling this wrapper because i think it makes sense you could call this whatever you want there's no naming restriction and all right now what i can do i can add another decorator with the double decorator and now if i run all of this we have to wait a second and if i expand this we have the code being executed once and then twice and well this is working really nicely and here again our actual function is really simple and we are just adding more and more stuff to it and that way it gets more and more complex with that we have some very basic decorators now there are some more things we can do with them and what i want to cover for this part is that you can have functions with parameters being decorated that part is actually really simple and besides that decorators themselves can also have parameters although implementing this gets even more complicated because we are wrapping a function inside of a function inside of another function so this we will have to explore in quite some more detail but let's have a look at all of this here i am back in a completely empty sheet of code and i want to create a new function so define function and now i want to have a function parameter it doesn't really matter what it is and in my case i am just going to print that function parameter and now once we have that i can call this function with whatever i want let's say hello and if i run this i get hello a super simple function and to decorate this we kind of need the same thing we have done here it's not really that much more complicated as a matter of fact let me actually copy this decorator here and paste it in here and now i want to decorate this function with the decorator and just as a reminder this would be the same thing as calling function is the decorator with the function however now if i call this i am getting the decorator takes zero position arguments but one was given and this happens in this one as well as in this one so we're getting the same error message that's usually a good sign at the very least the problem python has is that this function needs this parameter so when we are calling the function up here we again need the parameter but on top of that when we call this function here we are calling this wrapper and right now when we are calling hello we are passing it essentially into this parameter here which doesn't exist yet which is why python is so unhappy and to get around this we just have to create the parameters meaning this wrapper here and this function need the same parameters or well for this wrapper it's a parameter for this function it's an argument and let me name them properly here i want to have a wrapper parameter and now if i run all of this again we should see a different error message and that is that func is missing one required position argument func parameter meaning this one here and well i get this argument from the wrapper parameter so now if i run this we get hello and if i change this argument to something this is still working and we could also do this the other way the more traditional way and we will get the same outcome and let me just go over what is happening here by using the traditional style to make it a bit easier to explain we are again calling this decorator function here and passing in the function itself now inside of this decorator we are creating all of this here and right now the wrapper has one parameter the wrapper parameter and then inside of this wrapper function we are calling whatever code we want and we also have the original function here and then we are passing the wrapper parameter as an argument inside of this function and once we have all of that at the end of the code we can just call the function with something and then this something would be passed into the parameter for the wrapper and then this would be passed into the original function now what you see very often for the rapper you don't have one specific argument instead people very often just add arcs with a star and then double quarks and then this you pass into whatever original function you have so if i run this we get the same outcome and these are very simple unpacking operators this one is for a list and this one is for dictionary or keywords and the reason why these are used is because they allow for this decorator to accept basically any kind of function with any kind of parameter right now we only have one parameter but we could also have more name parameters an unlimited amount of arguments it doesn't really matter if you have this setup you can accept any number of arguments or named arguments which means that this decorator works with literally any function without limitation and all right with that we have basic parameters what we can also do let me uncomment the decorator let's try if this is working it does what we can also do is create a decorator that is accepting other arguments like a 10 for example but for that to work we need something even more complex so let's do this in a separate file all right and here once more we have an incredibly simple function if i call this function we can see function and now what i want to do i want to create another decorator and let's call this one a repetition decorator and this one should accept one argument by how many times i want to repeat this function here for example if i add a five in here i want to repeat this code five times when it's being called or rather i want to call it five times when it is being called now for that to work we need some pretty extensive setup and let me go through what this would look like i am first going to create the actual decorator so repetition decorator but this one is not going to accept a function instead it is going to accept this argument here so in my case i want to call this the repetitions and now inside of this i am creating another function and this is the actual decorator and this decorator is going to accept a function and now inside of this decorator i want to create the actual wrapper and this one in my case has no arguments and what i want to do is for let's call it r in range repetitions i want to run my function and now what i have to do i have to inside of the decorator i want to return the wrapper and then inside of the scope of this repetition decorator i want to return the actual deck curator and now if i run this it is going to work five times and i can change this to a 20 and we will call this function 20 times now the question is why does this work so let's go over it and let's do this in a traditional way which i guess i haven't done yet but if we didn't use decorators and still wanted to use this it would look like this i'm still using my func variable name and now i want to call the repetition decorator and now for this repetition decorator i have to specify how many repetitions i want let's say 4 in this case and after i have that i am calling whatever i get from this and passing in my function and if i run this we get function 4 times now if you look at this this is probably really confusing but to understand this you basically have to understand the return statement and let's go through it one by one first of all we are calling the repetition decorator and passing in four that is this line of code here and this one by itself doesn't actually do all that much all we are doing is creating a new function and returning it so all we are getting from this repetition decorator with a 4 is this decorator here a new function meaning this decorator here is going to replace the entire decorator we have seen so far and on this new decorator we are calling the new function this one here meaning now we are passing this function inside of here and this function is being captured inside of this parameter and once we have that we are basically back to a normal so inside of this decorator we have a wrapper and this one just loops over the range of repetitions that we get from up here and then inside of that we are calling the function and then we are returning the wrapper and then this wrapper is being stored inside of the function and we can call this function and then we are repeating it by whatever we specified in here and well if i comment this out again and return to my decorator let's add four in here and we still get four repetitions and i would really recommend you to practice this in your own time although if you're just starting don't worry too much about it just get used to functions and classes by themselves and once you are a bit more comfortable start working on decorators they are definitely one of the more advanced topics in python although there is going to be another section and this is where you are probably going to use decorators the most as a beginner and that is to use decorators inside of classes so let's talk about decorators inside of classes and there's one really important one it is called property and what this allows us to do is it allows us to turn methods into attributes and this is something we get from the property function that we can use inside of python it actually comes with python and i'm pretty sure all of this is going to sound really cryptic if i just explain it theoretically so let's do all of this in code that should be better all right here i have a completely empty python file and what i want to do is to create a new class let's call it generic and in here i want to create a dunder init method and this one itself and nothing else and what i want to do in here is create one attribute let's call it x and let's set a value for 10 it really doesn't matter what it is and now i want to create an object from this class let's call it generic and i just want my generic class and now i can print generic dot x and i should get 10 and indeed i do and now what i want to do is i want to observe this x here meaning whenever i look at it so i retrieve the value or when i change the value i want to run some other code and this by itself in python isn't really that easy to do i guess what you could be doing is run some kind of function that let's call it get x in here self and in here i could return self.x and then besides that i could print some other code let's say get x and now inside of this print statement instead of x i want to get x and don't forget to call it if i run this i get get x and the value so when i get x i can run some other code and this is fine by itself but it's not very elegant and again like we have seen with the other decorators what happens if i already have a lot of code let's say i have this generic x 10 times in my code and i don't want to change all of these instances here i just want to change my class itself to account for that that whenever we get x i want to run some other code and this we can do but we need some special function in python and this function is called property and into this property function we can pass in a getter a setter and a deleter and then we can assign all of this to one attribute inside of our class let's say x right now and then this x is what we are actually going to work with so now when we are calling generic x this line here this x refers to this x here and then when we are just looking at this x we are calling the getter method when we are changing this x we are calling setter and when we are deleting this x we are calling deleter meaning now what you usually see with this the original attribute we have this x here we are turning into a private method with an underscore before it and now to python this x here and this x are two separate variables but i as a programmer still know that they're the same because of the naming convention here and now basically what i'm going to do for this getter i am going to return underscore x and with that we have a getter so this method here is going to be this getter meaning whenever we are calling this generic x we are calling this get a method which is then returning this underscore x and essentially what we are doing here outside of the class we are working with x and this is what we are accessing but inside of the class we are using underscore x and this is what actually keeps track of the value and now basically what we have to do besides a getter we also need a setter so let me change it and for the setter we need self and a new value and when we are calling this let me run set x and then self underscore x should be the value and this we do not want to return and finally besides that let me copy it one more time i want to have it deleter this one doesn't need a value and what i want to do in here is delete x and all we have to do for this one is to run del and self dot underscore x and now i can run this and let me make this a bit smaller now when i print generic x we get get x and the value of x meaning we have run this method here what i can also do before i'm printing x i can run generic x is equal to 4 and now if i run this i am setting x and i'm getting x and then i get the actual value of x and finally what i can do i can also run delete and generic dot x and now if i run this i have set x get x the value of x and delete x meaning now whenever i for example get the value of x i can run whatever other code i want and for example what i could do with that i could import from date time that's not how you spell that from date time import date time and i want to know whenever i get x which i get by just printing the date time dot now and now if i run this i am getting the current time when i'm accessing x and since we're just returning this underscore x you could even make changes to whatever x you get depending on the time of day some other variables some basically anything you want to look at which is why all of this is really powerful and i would recommend to go over this in your own time it's really useful but just to go over it really quickly again i think that's going to be useful when we are initiating this class we have underscore x this one here and this is the variable we actually storing values in right now that is 10 but it really doesn't matter what it is once we have that we are running this line here and this one turns x into a property and this property has a getter a setter and a deleter and those are referring to this getter here this setter here and this deleter and now from outside of the class whenever we are accessing this x here we are running either of these methods and these methods then influence self.x which is where we actually store the value so this one here and that way when we are accessing changing or deleting a value we can run whatever code we want in there and i hope this is making sense this is again something slightly more advanced that you probably want to practice on your own time but what python developers also realized is that this isn't exactly an elegant way of writing all of this which is why this property works really well as a decorator and let me copy the entire class to implement this as a decorator and let me comment out all of this and basically how you would implement all of this as a decorator for the getter you would simply add the add property decorator although then the getter you would rename to the name of the property which in my case is this one here so i just want this to be x now for the setter i want to get another decorator and this one you would call with the name of the property in my case again x and now you would add dot setter and then the actual method would also be called x or the name of the property and finally the same works for deleter so we need x dot deleter and now the name of the method should also be the name of the property so x in my case and now once we have that i can get rid of this property here and now this code does the same as this code up here meaning if i run all of this we get the exact same result except now it's a bit easier to read i suppose and this is something you are going to see reasonably often even as a beginner because running some code when you're just changing a value or even when you're just looking at the value can be really powerful so understanding this here or at least being able to replicate it by yourself is going to be something you do want to practice but again this is all very advanced so if you're just learning python and all of this is too much don't worry about it you are not going to use it for quite some time and it would be much more valuable for you to understand classes and functions by themselves so don't stress yourself if this is too much but anyway this is all you need to know to get started with decorators and i hope that was helpful in this video we are going to cover eval and exec which are two fairly special functions in python let's talk about them both eval and exact are simply functions inside of python the thing that makes them special is that both of them translate strings into python code in practice this would look something like this if i'm running eval 1 plus 1 this would return the operation 1 plus 1 which would give me a 2. and notice here this one plus one originally was just a string nothing else and with eval we are turning this string into an actual python operation which can be incredibly powerful as a matter of fact you could even create new variables from a string which i guess very occasionally can be incredibly useful and while it overall gives you a ton of flexibility however there's something really important and that is you have to be extremely careful when using exact or eval for the simple reason that if you handle these functions badly it allows users to run their own code inside of your code which if you for example run a database might end up with them stealing all of your data for example you might have some kind of input field and this field was originally designed to handle names from users and then you use the eval or exec function to update this kind of name to make sure there are no typos or something like that a user instead of writing a name could just add a ton of code and thereby accessing your database and if that happens you probably are going to be in a lot of trouble so be really careful when you're using these functions they can end up horribly wrong but alright before we jump into code let's talk about the difference between the two eval is the simpler of the two functions it only evaluates code which means you can run functions or simple operations but you cannot create new variables or run if statements or stuff like that for that you would need exac this is the more powerful one and it basically is capable of running any kind of code and let's have a look at both and let me start with eva i need to type eval and now in here i can write any kind of simple statement for example 5 plus 10 and if i execute this we don't get anything because this only returns a value it doesn't print it meaning i have to put all of this inside of a print statement if i run this now we are getting 15. and we could even run some kind of code for example what i could be doing is create another string inside of the string with the different quotation marks and let's call this one test and on this test i can call the upper method and run this now and we are getting test essentially what happens is that python just removes these quotation marks and then runs all of this as normal python code however there are limitations especially for eval for example what i couldn't do is print eval if true then print let's say test and if i run this we are getting an error that we have invalid syntax and the invalid syntax we are getting because if true or an if statement in general cannot be run inside of eval for that you would need exec if i run this now this is working just fine and this is a more general theme that in eva we are quite limited in terms of what we can do another example would be i couldn't assign a new value to a variable so in eva i couldn't do something like a equals 10 i would be getting a syntax error however if i use exec this would work just fine and after running this code we have a variable a meaning i can print a and we get 10. the value of this 10 here and that is the entire idea behind exec and eval now most of the time especially as a beginner you are not going to use them whatsoever because there are certainly more advanced things however there's one good example that i think can be quite valuable let me copy in four lines of code and i guess i can comment out the earlier stuff what you're looking right now is i have my string and this is just a string and on this string i'm running upper title lower and case fold meaning if i run the code now i get all of these results the issue here now is we have four lines of code for something that is actually really really simple and using eval here could shorten all of this quite substantially and this i think could actually be a really good exercise try to express these four lines here using an eval statement and if you want a tip this should happen inside of a for loop try to figure this one out yourself i first of all have to convert upper tidal lower and case volt into some kind of string and in my case let me just copy it it is looking like this and i want to cycle over this with a for loop meaning i want to do for operation inside of this list and now inside of this i want to run my eval function and in here i need a string of my string and on this i want to run each of these operations and this i would do with an f string and inside of that i want curly brackets and my operation and importantly we do want to call these functions which means i want brackets so for example we are starting with upper and this is going to be inserted in here for the operation which means we are ending up with my string dot upper and then we're adding brackets to actually call this method and eval then basically removes the quotation marks and turns all of this into valid python code and the last thing we have to do is to actually print this so we can see the result let me add the print statement and comment out this earlier stuff and if i execute this now we get the very same result and this may be a bit arguable but i think this is much easier to read than these four lines here but both approaches would be perfectly fine and well with that we have eval and exec