hello there in this tutorial we are going to be talking about collisions and pygame and specifically we are going to create a project you can see on the screen right now and the really important thing i'm going to cover in this tutorial are the collisions between moving and static objects as well as the collisions between two moving objects which can be quite a hassle if you don't know how to think about it so this is what i'm really going to focus on in this tutorial and understanding the logic behind collisions is fundamental to make more complex games like zelda or mario game that i created on this channel they both use collision mechanics quite extensively and there isn't really that much else to talk about so let's jump straight in and the first thing just to save some time i have already created a basic project so for this section i want to talk about the project setup and once we have that i'll talk about collision logic but let's have a look in the code what we already have so here we have the project already it's not the shortest thing ever we have nearly 150 lines of code but it really isn't that bad i'll explain all of this in just a second but if i run this project so far here is the project you have seen in the intro except we don't have any collisions so the blue rectangle here is my player i can move it around and nothing happens and in the same logic the red square is supposed to be a ball that moves around right now it's just static without any collisions so we can move around but we can't really do anything other than that and well we are going to add collisions in just a bit but let's first talk through this entire project now all the way at the top we are importing pygame sys and time high game and cis are the basic things you need for pie game and time is going to be used for delta time that we're using down here to make the entire project frame rate independent if you don't know what that means check out this video in fact if you're new to pygame and you feel all of this is too complex check out this video it's explaining the entire module in quite some detail and i will assume that you already know basic pygame after the import we have five classes we have static obstacle moving vertical obstacle moving horizontal obstacle player and ball and i'm not going to go over them for now just assume they do what the name implies i will explain them in just a second for now just assume they work now once we have that we have a general setup with pygmy.init and we are creating a display surface nothing complicated so far then we have a group setup and in here we have all sprites and collision sprites and all sprites is for literally every single sprite we are going to create and this one is going to draw and update every single sprite collision sprites are for all the obstacles that the player is supposed to be able to collide with or well the player and the ball so this group here is literally just to figure out which sprites are supposed to be collided with and which ones aren't it doesn't really do anything besides that and once we have the groups we can create some sprites and in here we have seven sprites in total we first create three static obstacles and really all we're doing in here we are creating a position a size and then which groups this sprite is going to be in so all of the static obstacles are in all sprites and in collision sprites after that we have our moving obstacles and they work in the same way we have a position we have a size and then we have some groups and the arguments here are identical compared to the static obstacles so all of this is ultimately fairly simple code and at the end of all of this we have our player and we have the ball and those get predefined positions and sizes so all they need is all sprites to place both of them inside of this group here and once we have that we actually get to the game loop and this one is very simple for this project at the beginning we're getting delta time and we're using delta time in all sprites for the update method to update everything with delta time and once we have that we are drawing all of the elements on the display surface and before that we are filling the screen with a black color so we have some background color besides that we are checking for the player closing the window but that's pretty simple and we are updating the entire window so that we're actually drawing something but that's really quite simple nothing really complicated here actually now look at the classes and let's see what's going on here and the simplest one is our static obstacle and in here we have one in it method and then there we are defining a position a size and groups so all the stuff you could see down here and well it's only four lines of code we are using the super.init method to allocate the groups we are creating an image with the size we are filling the image with a color in this case yellow and then we are creating a rectangle and the top left of that rectangle is the position and that's literally it it's not a complicated object now besides that we have a moving vertical obstacle and moving horizontal obstacle and both of those inherit from the static obstacle so both of these classes inherit from this class here the one i've just created and since this one inherits from a sprite those ones become sprites as well except they already have a couple of basic attributes so let's have a look what they actually do we have the very same arguments we have positions size and groups and then in the unit method we're passing the same information in there and this happens both for moving vertical and moving horizontal as a matter of fact both of those classes work in basically the same way except they move either vertical or horizontally and i guess they have a different color but that's a small thing now for moving vertical we are filling the surface with a green color we are giving it a position a direction and a speed then for the position we have a vector 2 and by default the position is the top left of the rectangle and this position is what we are going to move why we don't move the rectangle by itself is because of delta time that this position is more precise which is what we really care about now besides that we have a direction which is a vector 2 and then we have a speed which in this case is 450 but it's basically random so we essentially create two vectors one for the position one for the direction and the speed that's kind of all we need then we have the update method and in here ignore this part for now the important bit happens down here essentially all we do is we get the y part of our position vector and towards that we're adding direction.y multiplied by speed multiplied by delta time so we are essentially moving it in one direction and after we have done that we are getting our rect position and this one actually creates the position of the sprite and for this one we're getting position at y and we are rounding it and that way we are getting the correct position if this gets complicated i have explained all of this in a bit more detail in my delta time video now once we have that we have these couple of lines of code here and basically all they are doing is imagine that this right now is the entire distance we want this moving vertical obstacle to move in and essentially what this one here does is the top part is 120 so that's 120 up here and the highest part is 600 so we are down here and essentially what happens in this top bit here is if the bottom of the rectangle is greater than 600 so if the obstacle is let's say down here and the bottom part is at let's say 605. if that is the case we're moving the bottom of the rectangle to 600 so we're moving this thing up by a tiny bit then we are updating the position and then we are reversing the direction and that way once this rectangle is below the bottom part it's going to start moving up and then the exact opposite happens on the second if statement the one down here now we are checking if the top part of our rectangle is smaller than 120 so we are up here and if that is the case we are moving the rectangle to 120 and we are changing our direction again so this thing is moving downwards and that way the sprite is always going to move up and down and up and down continuously and that is literally the entire moving vertical obstacle class and if you understand this one moving horizontal obstacle works in exactly the same way except now we don't change position.y we change position.x and that way we're moving in the horizontal axis not in the vertical anymore but besides that this one does pretty much the same thing except well we have different numbers so those two classes pretty simple now besides that we have player and ball and i guess ball is the easier one of those two because this one doesn't do anything right now so in here we only have an indented method we have super done the init then we have an image and we're filling the image we're creating a rectangle and then we have a position a direction and a speed and for now since we're not updating any of this this doesn't do anything but we will work on that in just a bit now finally we have our player and this one is getting a touch more complex although not that much we again have an image that we're filling with blue we have a position that is in the middle of the screen roughly and we have a movement we have position direction and speed again so this is identical to all of the other classes besides that we are getting some input so we are checking if the player presses up or down to move in the vertical direction and if the player presses neither we are not moving at all and if the player is pressing right or left we're moving left or right and if the player presses neither of those two we don't move at all so this is getting all of the input and essentially what we do for the input we check keyboard input and we use that to influence the direction and now once we have all of that we have our update method and in here we are first checking for the input after we have done that we are normalizing the vector in these two lines and normalizing a vector basically means that we make sure the length of the vector is always one the idea here is that we only move up we would move by a unit of one and if we moved only right it would also move by a unit of one but if we move to the top right we would have a speed of 1.4 so if we move diagonally this basically means we'll move faster and these two lines avoid all of that so all this really does is it makes sure that this 1.4 becomes a 1. once we have that we are again updating our position and this time we are getting just the position and we're in the direction the speed and delta time and multiplying all of them together and then we are setting the top left of our rectangle to rounded position x and rounded position y and that way our player is going to move so if i run all of this again we can move the player around and everything works just fine cool so that is a pretty good start i hope all of that makes sense so the important question now is how can we add collision mechanics and for that we do have to talk about some theory i'll try to keep it short and in here the first important thing you have to understand is that we have a separation between updating our game and drawing all of the elements so essentially before we are drawing a frame we first figure out where all the elements have to be and this is important because it gives us some leeway to place elements and for collisions this matters in particular so let's think about collisions in the real world let's say you throw a ball at any kind of object essentially what happens at some point the ball collides with the outer part of the object and the two don't really intersect with each other because they're both solid in games collisions work slightly differently essentially what we do in a game we first check if the two objects are overlapping with each other so if the ball and the other objects share some space and if that is the case we want to move the ball outside of the object and only once that is done we are actually drawing the image so for the player it looks like the ball didn't actually go inside of the object but what actually happened was that the ball went inside of the object and we placed it just outside of that object and that way we are simulating a collision and that is the first thing you really have to understand that we don't check actual collisions and then we are placing one element at the edge of the other element and to the player it looks like a collision but it actually isn't but now we have a problem and to really understand this problem let me give an example here we have a ball and an obstacle and right now they are obviously overlapping and now imagine you're the computer and you have to figure out where to place this ball and the problem you now have is you don't actually know where to place this because this ball could have come from any direction and you really have to know where the ball came from to place it on the edge because you don't know on which edge to place it and if you had the wrong edge you would just teleport the ball around which is something that can happen very very easily and would make your game look very glitchy and might even break it so you need to understand where the ball came from to place it in the right position after an overlap now to solve this problem you have a couple of different approaches and i'm going to talk about two but there are quite a few more and there's one thing both already have in common and that is that we are separating the horizontal and the vertical axis so what we are going to do we are first moving an object in the x direction then we are checking for a collision and only once we have done that we are moving the object in the y direction and then we are checking for the vertical collisions and this is already making our map significantly easier because we only have to check for a single axis and now inside of both of these axes we have to figure out where the ball came from and in the first approach we are checking our direction so essentially what we are doing imagine the ball is again overlapping with an obstacle and the ball came from the left and is moving to the right if that is the case you can assume quite safely that the ball is colliding on the left side of the obstacle and now that you know that you can place the ball on the left side of that obstacle and you're basically done and this you can do with all of the other directions as well and this system is totally fine it's really easy to implement and it works pretty well i have actually used it myself for a complex zelda game and in there it worked really well but there's one downside and that is that in this system you cannot check collisions between moving objects so for example in my zelda game we have zelda and we have the enemies moving around but these two objects do not actually collide so they can totally move on top of each other but if you had any kind of moving platform or anything moving that can be collided with this approach would break and the reason why it breaks is quite simple imagine again we have our ball and our obstacle and now we have our ball moving to the right and the obstacle this time is moving as well also to the right and happens to be overlapping with the ball now for the game's purpose we know that the ball is moving to the right so we would assume the collision is happening on the left of the obstacle but in this case this is wrong the collision would happen on the right side of the obstacle so we would need another kind of system and this system does work with both static and moving sprites but it is a tiny bit more complex essentially we are going to check for every single sprite the current position and the position on the previous frame and essentially what we are going to do is we are checking for each direction if for example the right side of a ball is greater or equal than the left side of the obstacle and on top of that we are also going to check where each of these sprites were in the previous frame and now again with the same example we have a ball moving to the right and we have an obstacle moving to the right and the obstacle moves a tiny bit faster and on the old frame the obstacle is just to the left of the ball and then in the current frame the obstacle is just overlapping with the ball on the left side if we have this kind of setup we know that in the previous frame the obstacle was just to the left of the ball so we know where the collision is going to happen on the left side of the ball on the right side of the obstacle whichever one you want to work with and that way we don't get confused by different directions we just check where the object is now and where it was in the last frame and that is also going to be the system we are going to implement now unfortunately this is going to be a tiny bit more complex because for every single sprite class we have to check the current frame and the previous frame although that's well one more line of code it really isn't all that bad and well let's implement all of this and let's see what we get here we are back in the code and for each of these objects i have to check where they are right now and what i wear in the previous frame which sounds way more complex than it actually is so let's start with the static obstacle this one needs one as well even though it doesn't move and essentially all i am going to do i'm going to give each of my sprites another attribute that i'm going to call self.all direct and all i'm going to do here is self.rect.cob for this one we are just going to copy this rectangle and since this one isn't moving we can just keep it like this but let me copy this line we are going to need it a bit more so this one already done now a slightly more complex one we have our moving vertical obstacle in here we still want to copy the rectangle but now we have to do something else that when we are updating this sprite all the way before we do anything else i want to get my old rect and copy it so this is the position where it is right now and after all of this code is run this sprite is going to be in a new position essentially what this means is that this is the previous frame and this one down here is going to be the current frame and well this is actually all we needed so now i can minimize this class here and do the same thing to my moving horizontal obstacle and here we again are going to need an old rectangle and we have to do the same thing for the update method and again this is pretty much the same thing as we have done with the vertical obstacle in an actual game those two could probably be one class i was just a bit lazy for this setup but alright now we have the player and in here let's say for the position i again want my old rectangle and copy it and then before i do anything else in the update method i want to get an old rectangle as well so again we have our previous frame and we have our current frame down here and now let me minimize the player and we can do the same thing for the ball we just need the old rectangle and now if we run all of this we literally cannot see any difference but we can actually visualize what we have just done before we are drawing all of the elements what i want to do is for sprite in all sprites dot sprites and i just want to draw pygame.draw.rect and this just means we are drawing a rectangle and in here i want to draw on the screen i want to draw in a color i haven't used yet let's go with orange and then sprite dot old rect and let's see what happens now so now you can see this very faint orange background and this is the previous frame now because of the frame rate it is kind of hard to see but it is definitely there so this previous frame very very small so at the very least we know it is working but now that we have that we actually have to work with the collisions and this let's start with the player so inside of my player i want to create another method and this i called collision and then here we need self and they also want to get a direction because remember we are first going to check the horizontal and then the vertical direction you could switch this around it really does not matter and now first of all i need all let's call it the collision underscore sprites and this essentially is going to be all of the sprites our players overlapping with so let me comment this out so for example if i move my player to the obstacle down here right now they are overlapping so this yellow rectangle here should be in my collision sprites and if i were to collide with multiple objects they should also be in there now pygame has an inbuilt method for that it is called pygame.sprite.sprite collide all in lowercase but for this to really work our player has to know where all of the obstacles are so what i did when i create a player we have another parameter that i called obstacles this is just going to be self dot obstacles is going to be obstacles and these obstacles let me minimize my player we get down here when we are initiating the player besides putting the play on all sprites i also want my collision sprites and the important thing here is that we don't put the player inside of the collision sprites we just give the collision sprites as an attribute to the player so the player knows where all of the sprites inside of this group are and that's all we care about so i hope that makes sense all right so now inside of the player we need three arguments in here we need a sprite we need a group and we need what is called do kill now the sprite we want to look at is just self spelled properly then the group we want to look at is self dot collision sprites i think i called it no i call it self dot obstacles and for do kill this should be false because i don't want to delete any of the sprites and all right now we can just print and see what we get so print collision sprites and then let's put it down here self dot collision sprites self dot collision and let's say just test it doesn't really matter what we put in here for now so now if we run this we get an empty list but if i move over something we get static obstacle sprite in two groups we get our moving horizontal sprite and well we know what each of these sprites are going to be so this is all we care about so this is already telling us if there is a collision over an overlap and with what object the overlap happens now what i want to do i first want to check if collision sprites exists in the first place so if there's any object inside of that list and once that is the case i want to check if my direction is either horizontal then i want to do something let's say pass for now and if my direction is equal to vertical and i want to do something else let's say pass in here for now and let's start working on horizontal although again it really doesn't matter which direction you start with and what i want to do in both of these is for sprite in collision sprites and now the question is is the collision on the right or do we have a collision on the left so remember we already know that there's an overlap and right now we are just checking if we're moving left or right so all we have to figure out from the player's perspective is if the collision happens on the right or on the left and then once we get to the vertical side we are checking if the collision is on top or at the bottom so now how can we check if the collision is on the right and in here we need two if statements or we need one if statements with two conditions the first is self.rect.right is greater or equal than sprite.rect. left if this one here is our player so this is our self and then our sprite rectangle is let's say this yellow thing here right now we know there's no collision and we know that because the right side of the player so this point here is let's say on position 100 and the left side of the obstacle is at let's say position 150 now because this position is smaller we know there's no collision between these two they couldn't be because the right side of the player is too small to even touch the left side of the obstacle there literally cannot be any kind of collision but now if we have another kind of collision let's say now our player moved to the right and now looks something like this the right side of the player is at position let's say 200 and now this condition here is going to be true because the right side of the player is greater than the left side of the obstacle and as a consequence we know there's going to be a collision on one of these sides and let me clean this one up a tiny bit so i have a bit cleaner off a space so now we have this situation here where we know the right side of the player is greater than the left side of the obstacle and this means we do have a collision the problem we have right now is that this situation by itself doesn't help us to understand where the player is supposed to go so is the player supposed to go to this point here this point here this point here this point here or any of these other points we don't know where to put the player because we don't know where it came from and it might seem obvious to put a player on this side but that would not be a good way to think about it because the player might as well come from this direction here or if the player moves really fast it might have even come from this side and the collision was actually supposed to be here remember that when we just check initially we're just checking for an overlap so if the player moves very fast it might even happen that the player jumps over most of the obstacle so even though the collision is on the right side initially a player is more on the left which is also the reason why you couldn't check something like this center that's not really reliable but okay i hope that makes sense to fix all of this we are going to need another statement that's going to be and and what we're going to check in here is self dot alt rect dot write is smaller or equal than sprite dot alt right dot left and let me actually reopen this one and clean it up a tiny bit here again we are in the starting situation where again we are in this situation here we know there's an overlap but now what we're also going to check on top of that is this situation here let me use a blue color so this situation here we are basically checking in the previous frame if the player for example was here where the right side of the player so this bit here is smaller or equal than the left side of the obstacle which in practice means that the player in the previous frame was to the left of this obstacle so with these two conditions we know that in the previous frame the player was to the left of the obstacle and in the current frame so this one here we know the player is colliding so with these two conditions we know the player is colliding and did come from the left in the previous frame so once we have all of that we can self dot wrecked dot right is going to be equal to sprite dot rect.left and don't forget you also have to set self.pause.x is going to be self.direct.x so what have we done here let me reopen all of this and clean it up a tiny bit again there's a lot of drawing involved in all of this these two lines here are going to do if we again have our situation up here essentially what we want to do we want to move this purple rectangle to this position here where we are moving the right side of the player to the left side of the obstacle and that way it looks like the player is colliding with the obstacle and cannot go any further or at least that's what it looks like to the player but in reality we checked for an overlap and then we place the player in a certain position and then position.x is our actual thing we are moving so this always has to be in the top left of this rectangle and this is why we're updating it here as well and there is one more thing that we have to do and that happens in the update method here so this line right now is a problem because remember we first want to move into horizontal direction then we want to check the horizontal collisions then we want to move in the vertical direction and then we want to check collisions in the vertical direction so we essentially have to separate this movement here in an x and a y position so what that means in practice is ultimately fairly simple i first want to get myself.post.x plus equals self.direction.x multiply this with self.speed and then multiply this with delta time and now once we have that self.reg.x is going to be rounded self.post.x and now once we have done that i want to check myself dot collision and for now i just want to do my horizontal collision and just so we can move around with the player i also want to do the same thing here for the y position so let me copy all of this and let me remove these two lines entirely so now this should be self.pause.y and direction.y then rect.y and position.y and what we're going to do in just a second is self dot collision and check for vertical collisions but this one we don't have right now so this one doesn't do anything and well let's run the code and let's see what we get so oda could already see something is happening so now if i move around with my player there we have a collision and right now this only works on the right side but it does work both with moving and with static objects the red square right now doesn't have any collisions so just ignore that one but you can already see the problem if i move from any other side but the right side the collisions don't work so this we have to implement as well but the right side by itself works beautifully fine cool so essentially all that means is we have to write three more if statements for the left the top and the bottom and i would really recommend for you to try to figure this one out yourself so try to write the collision mechanic for the left side the top and the bottom and see how far you get let me just copy the entire if statement and paste it in here now what we want to check for this one is if the left side of our rectangle is smaller or equal than the right side of the current sprite so if i'm drawing all of this one out let me give a bit more space this one here is going to be our obstacle and right now what we want to check is a collision on this side here and in this if statement right now we basically want to check if the player is somewhere like here so if the left side of our player is smaller than the right side of our obstacle kind of the opposite what we have done in the first if statement for the right side and on top of that we want to check the second if statement and this one has to check if in the previous frame the left side of the player was further to the right than the right side of the obstacle so what that means is self.oldrect.left is greater or equal than the old right side of the rectangle and once we have that we are good to go those two lines can't stay identical so let's run the code and these collisions still work just fine now let's try the left side and they don't work because i made a mistake let's have a look but this is actually really good so now you can see what happens when you mess up the collisions that the player just teleports around which feels pretty bad well kind of funny but let's see what i did wrong like i should tell this line here has to change because now we want to change selfdirect.left has to be on the sprite.rect.right and now let's try this again so now left side still works and the right side now works as well and with the static obstacles this one works as well and this one works as well cool so with this we have the left and the right side nice so next up we have to do the same thing for the vertical direction and for all of this let me copy these couple of lines here and let me paste them in there and now we want to check a collision let's say on the bottom and a collision on the top and i guess let's do another round of drawing for the bottom part i again have my obstacle and what i now want to check is if my player did something like this where the bottom of my player is greater than the top of the obstacle and for that i need self.wrecked dot bottom is greater or equal than sprite.rect.top so now we know there's some kind of collision at least on this axis and now what i want to check if in the previous frame the player was above the obstacle so if all dragged dot bottom was smaller or equal this one can stay then all direct dot top and now once we have this if statement and this is true i want to check my rect.bottom to the top of the other rectangle and now this position x has to be position.y and this is basically all we needed now for the final if statement let's do this a bit faster we want to check if the top of my rectangle is smaller equal than the bottom of the obstacle and if the old top part of the player was greater so below than the bottom of the obstacle and if that is the case i want to set the top of the player to the bottom of the obstacle and then again we want to check position and rect.y and with that let me fix this typo with that we should be done let's check this now our player can't move inside of this purple rectangle anymore because we are being moved along with it i can't also move inside of any of these objects here and let's check the green rectangle and this one works perfectly fine as well cool so let's try the top side and yeah this is working really nicely so with that we have a basic collision mechanic so this one is working really really nicely and i guess now that we have that let's minimize the player let's move some white space and now we can do the same thing for the ball and this could be a pretty good exercise for you so from the stuff you have just learned try to make the ball bounce around the game window and make it collide with the player with the obstacles both the static and the moving ones and this should take you some time but try to implement this one first of all we need to create an update method that needs self and delta time and in here i am going to steal quite a bit from the player because well it doesn't make sense so we can take all of this actually all of this from the player so let's copy all of this into our new update method and the one thing i don't need for this one is the input because the ball doesn't have any input we essentially just give it a starting vector and then change the direction whenever it collides with anything and now we are going to need two more methods the first one is going to be collision and this one itself and direction let's copy this one straight from the player again because we're going to reuse quite a bit so i'm going to copy all of this here and paste it inside of the collision method so quite a long method but i hope you understand it now we do have a problem and let me go to the init method and let me minimize the collision method this ball right now doesn't know whatever of the obstacle or where the player is so we have to tell it that and for that i created two new parameters when we initiate this class obstacles and layer and let me add them right at the bottom so we have self dot obstacles is going to be obstacles and self.player is going to be player and now when we are creating this ball i first want to insert my collision sprites and besides that i also need the player but right now i don't have access to the player so i'm going to place this in a separate variable and then this variable i'm going to place inside of the ball so now our ball is going to know let me minimize the player we don't need it anymore so now our ball is going to know where the obstacles are and where the player is and now let's actually run this and let's see what happens so now the ball is colliding but well you can see two problems actually the first one is that when the ball collided here with this object it didn't change the direction so it just went like this then shimmy along the side and then went down and the second problem is that it just left the screen so it went down here so these two things we have to work on and both of these things aren't terribly complicated i guess let's start on changing the direction essentially what we want to do if our ball collides on the horizontal axis we want to self.direction.x and multiply equal this with minus one so at a plus one we become a minus one so this way i have to copy this to both of these we would change our direction if the ball is colliding in this direction and we have to do the same thing for the vertical axis except now it's direction dot y and now let's try this again and this is working better but we do have to work on the window itself and that one shouldn't be too hard as a matter of fact if you understand this logic here figuring out the window logic shouldn't be too hard but well let's do it together so i want another method and i call this one the window collision and here we need self and i also want to have a direction and basically what i want to do after we have run all of this i also want self dot window collision and this one should also be horizontal and then i can copy all of this and do the same thing for the vertical collision so we essentially have two different kinds of collision except the window collision is going to be fairly simple basically all we are going to do in here is if the direction is equal to horizontal and if that is the case if self.rect.left is smaller than zero which means that our ball is moving to the left side of the window if that is the case i want to set self.rect.left to zero i have to update the position as well so self.post.x is going to be self.rect.x and finally self.direction.x i want to again multiply equal with minus one so we are changing our direction and now we just have to do the same thing for the right side of the window so right dot right and in my case my window is 1280 pixels wide although in a real game you would store this variable somewhere separately so you can access it a bit more easily and the game is a bit more flexible but in my case i don't care about that now if that is the case self.rect.right should also be 1280 and this one is still fine so now let's try this one and something about weird and the problem here is self.direct.right should be greater than 1280. now let's try this so now we have a collision with the right side but not with the top so at least something is working and well basically all we have to do is copy all of this here and change the direction to vertical and now we want to check if rect.top is smaller than zero and if that is the case you want to set the top to zero and then position dot y is going to be rec dot y and direction not y we multiplied with negative one so we are reversing the direction and for the final one self direct bottom is greater than 720 and if that one is the case then self.rec.bottom is going to be equal to 720 and finally we have to change all of the axes to a y and now let's try all of this again this one is working this one is working this one is working as well we don't have player collisions yet that's going to come in a second but besides that things are looking pretty good okay cool now the final thing we have to address is the collision between our player and the ball and this is going to happen inside of collisions let me minimize all of the other methods so it's a bit easier to see what's going on the problem we have right now that our collision sprites just checks for the obstacles so we don't check for any collision with the player and well we just have to add two more lines here to fix that and basically what i want to check if self dot wrecked dot collide rect so if the current rectangle of the ball is colliding with self.player.rect and this is a very simple i should spell it correctly this is a very simple wreck collision method that just checks if two rectangles are overlapping that's all we're trying to do here so this is basically telling us if the rectangle of the ball is overlapping with the rectangle of the player and if that one is the case we want to collision sprites dot append self dot player and now let's try this again and now let's try to get it and yeah this is working just fine hope i can get the ball again the ball is moving quite fast so it's a bit difficult to get it okay uh well i hope you get the idea uh there we go there yeah so this seems to be working just fine cool and well with that we are pretty much done now before i finish this video there are two i wouldn't call it bugs but two things we don't really cover in this kind of logic and to fix this we would need quite a bit more code so i'm kind of going to ignore them but let me visualize what the problem here is right now let's say i'm going to move my player exactly in this in wait a second in this position here now you can see that we get kind of a bug that the player is pushed through the yellow rectangle and the reason for that is that this green rectangle is just pushing the player and that is overwriting this collision here and the other problem we have here is if our ball is colliding with any of the moving obstacles it's kind of hard to see right now i'm probably going to add some kind of video to explain it a bit better because it only happens sometimes the basic problem is if the ball is being pushed down by another moving obstacle so for example the ball is being pushed down we get kind of a random direction because every time these two collide the vertical or the horizontal direction of the ball is being reversed so if they collide once on one frame we get one collision and then a change in direction but if they collide again on the next frame we get the same thing again so the direction changes again and this happens probably hundreds of times if the ball is being pushed down or up or left or right and as a consequence we get kind of a random direction afterwards and you could add a lot more code to account for these cases although another thing you could be doing is design your levels in such a way that this problem doesn't even come about so for example if you have moving platforms in the game make sure these platforms can never squash the player between themselves and another kind of object or if you have something bouncing around make sure you work with the directions to address all of this that there couldn't be a bug so just keep these things in mind but well i hope this video was helpful and i will see you around