hello everybody in this tutorial we still keep the same pong game but we are going to be making some updates and by the end of this tutorial our pong game is going to be looking like this we have a couple more colors and otherwise it's still basically the same game and yeah that's pretty much it but the most important thing is that we don't just make updates instead we are going to rewrite our code quite fundamentally with the purpose of having just sprites to organize our code and this should make our code ready to add more stuff in the future so let's jump right in the main problem our game has right now is that we are essentially only using a functional approach which means that we're using functions to organize the logic of all of it which is fine for very basic game but we can already see some problems arising from our approach the most visible one is that we have a ton of global variables which does get problematic quite fast so in our code right now especially for the ball animation we have way too many global variables the score is a global variable the ball speed is a global variable the score time is a global variable there's way too much stuff in the global scope which is generally bad practice for code and the way we are going to update our code is that we are going to use sprite classes which organize our code much better and give us specific objects so effectively our player pedal our ball and our opponent pedal are going to be objects and each of them has attributes and methods that organize our entire game and if you organize it like that our game is much more modular and much easier to maintain and once we have that we can add much more stuff to it later on without much hassle so effectively we're going to take our game organize it in sprite classes and then add some slight visual improvements to it and just as a recap for sprites if you are completely new to sprites then this video is probably going to be confusing but I made an entire dedicated video just on sprites so if you are completely new to the concept check this one out first but in short a sprite and pie game is the class that can combine a surface and a rectangle so that we can work with it easier and then this part class can be moved into a group and then we can update each sprite and grouped quite easily so let's talk about how I'm going to reorganize the code to make it more manageable and I'm actually going to use five different classes in there so it is getting a little bit more complex the most basic class I have is a block class and this one is not going to be drawn on this screen whoever the three main classes on the screen the player pedaled the ball and your opponent pedal are going to inherit from that class so the block class is basically just there to save me some writing it just takes the surface and puts a rectangle around it and puts it on the screen nothing fancy here the first major class we have is our player class and this is our player pedal that we can control and this one only does two things it can be moved and has a constraint so that we cannot move it outside of the screen then we have our ball class and this one is the most complex one of them all and it has quite a few different methods it has one to move the ball itself just like we're before then we have a collisional effort that calculates all the different collisions with the top and the bottom of the screen and to play and the opponent then we have a reset ball method that resets the ball to the middle of the screen then we have a restart counter method that basically gives us a counter if a score has been achieved and finally we have the opponent ask and this one is also quite simple it only really has two methods the first one is the update method and the second one is to constrain method and it works kind of like the player class the update method moves the opponent and it just moves it to every ball happens to be and the constraint method just make sure that it doesn't move outside of the screen so also quite simple so this will be the first four classes but there's going to be one more class that I called game manager and our game management class actually organizes the entire game and this isn't strictly necessary but it is going to make it much easier to organize our code later on and what this class does is that it runs the game loop it resets the ball to the middle of the screen and a draws the score at the end and with these five classes we can recreate our entire pong game logic and I'm not going to go through the entire code line by line instead I have already written the entire thing and I'm just going to go for each object and explain how it works so that this tutorial isn't going to be an hour long but with that let's jump into our code right at the top we have the five different classes that organize our code and for now I have hidden all of them but I'm gonna talk about them in just a second for now let's talk about the easy stuff the one that we already have the first ones the general setup where we have our mixer per unit we have our PI a minute and our clock this one stays just the same no change here then we have our main window this one also stayed exactly the same so we have screen whoof and screen height we create our display surface and then we give it a title that one's pretty simple then we have our global variables we have a background color and now we have an accent color and the accent color is a dark bluish color and it's for the text so the score and the line in the middle it's nothing fancy then we have our font then we have the two sound files and then we have a middle strip and the middle strip is just a rectangle that is the line in the middle of our screen it is four pixels wide and goes from the middle two pixels to the left and two pixels to the right so it's really just a thick line and all of this is actually incredibly simple so if we could follow the last tutorials then this one should seem quite familiar and if I go a bit further down we still have our event loop and in here this one also looks fairly similar we're going to explain what these lines mean and a bit more detail later on but they should already look quite familiar it didn't change all that much but in the actual game loop we still have a background color then we draw the rectangle that's the middle strip and then in our game manager we have one game so all the game logic runs in here and then we do the usual we just render the entire thing so all of this is pretty simple now let's go for each class and talk through it one by one so I go all the way to the top and let's start off the block class this one is the easiest so let me open it and all it does is it takes a path to a file and x position into y position and then in our screen it puts this image on a new surface it draws a rectangle around that surface and it places the new rectangle somewhere on the screen whether we specified it so this entire class is basically the easiest kind of sprite you can possibly create and it doesn't really do much more and the only reason we have it is that for the player the ball and the opponent they all inherit from this block class and this is the only reason why it's here it basically just saves in some writing but all right we can close this one and never worry about it again so quite easy and with that we come to the player class and this is the first one where actual stuff happens so when we start it inherits the stuff from the block class and then it has two attributes beyond the block class it has a speed that we define and a movement and then in the update method we take the rectangle and add selftaught movement and the logic here is quite similar to the stuff where before basically our rectangle is always being moved on every single frame of the game however if we don't press any button the movement that's being added to the rectangle is going to be zero so for all practical purposes if you move something by zero it just doesn't move however when we press a button this movement value is going to become the value of this speed attribute and all of this happens further down in the code in our event loop all the way down here all of this so the player movement is going to be minus equals or plus equal to player speed so for example if we press the UP button then the player movement attribute is going to get minus equal player speed which in our case when we create a class it's going to be five so it's going to be minus five so it's going to move upwards and then when we lift the key up then we add the same number to it so effectively player movement becomes zero again and the pedal stops moving so this is all that this line here does and then we come to the constrain method and all this one does is prevent our player from moving outside of the screen and this one works exactly in the same way what we have created earlier if the top of the player goes outside of the screen so it's smaller than zero then we place the top of the player at position zero if the bottom of the player gets higher in the screen height then we place the bottom of the player at the screen height and the important thing here really is that the logic for this was already a established we just put in the context of a class so if you compare this to the function we created earlier it is really similar the major difference is the self in the beginning but all right with all of that one done we have our player class and it's actually really simple so when we go down into the creation of all the important variables you would create a player from the player class it gets a picture this one here we place it at the x position and the y position and we give it a speed then on this line we create a pedal group and then we have to play it to what's that and with that one let's close the player again and let's go to the ball class and this is the really large one and again when we created we inherent a couple of attributes from the block class and we're going to add three more attributes we have speed X speed Y and the paddles and the pedals are going to be the perils for the player and for the opponent so this one is a group of pedals but this one comes in just a second for now speed X and speed why we put them in here and we randomized whatever value has been put inside of it which basically means when the ball is starting it goes into a random direction and then we have a group of the pedals and this is gonna be when we go down a little bit we have yep for the pedal group we had a player and the opponent to your point explained in just a second but when we create the ball we put this paddle group in there so that the ball knows where the two pedals are so it can collide with them and bounce of them that's the only reason we have it in there so let me go all the way up again this is this line here and then we have two my attributes that don't need to be specifically declared self to active and score time self thought active basically determines if the ball is moving or not and score time is to check the time when the score was being achieved and this is the logic we have seen earlier that if it scores being achieved we want to start a count on to wait a couple of seconds until the boss that's moving and after the score was achieved and all of this basically happens in this part here the update method and basically what happens in here is that if self to active is true then we are moving the ball and checking for collisions and if it's not true we start to reach that counter and this is really similar to a logic we had before and the collision logic happens down here and this one should also look quite similar it is what we have done the last video in this line here we check a top or bottom collision so this one is super simple and all of this part here is to check the collisions for the different paddles so both the player and the opponent pedal happens in here and this logic should look really really similar in the last tutorial we created this entire thing for each of the pedals but that isn't actually necessary so it's quite simple to combine and with that one done we have a reset ball method and this one just puts the ball in the middle of the screen and starts the count on timer so the score time is being set here and again we have seen a really similar functionality before and then finally we have our restart counter and all this one does is that it draws the number on the screen how far down to count on primaries and this one is identical to what we have done earlier except in the context of a class and all right that is the ball class it is quite a long one okay and then we come to the opponent class and this one gets a bit easier again so in here we still inherit the same stuff from before and we give it a speed value and then in the update method we move this paddle whatever the ball happens to be and this one is really similar to logic we had before and then just like for the player we have a constraint method and this one constraints the opponent to the screen and when we create this opponent which happens all the way down here we put it in the same group as the player so the pedal group has the player and the opponent and then this group is being passed into the ball so this would cover our first four classes and they are quite extensive already but now we come to the game manager and this is what the actual logic of the game happens so we put all of these four together and make a game out of it and I can't get it all on one screen but that's okay so when we created it doesn't inherit anything and we have a couple of attributes we have the ball group and a pair group so where the ball is and well pedal group is and then by default the score is zero and we make the groups part of the class itself then we have our run game method and this is what the actual game loop happens and here we have the pedal group and the ball group so this is where we just draw everything on the screen and then in the paddle group we update it and we pass in the ball group and this is quite important so let me go up and let me open the opponent group first that wants the easier one Swamy called update on the opponent group we pass in the ball group and then this method uses the ball group to move the opponent so this one needs this argument however for the player group when we look at the update method this one also needs the ball group as an argument but it doesn't actually use it but you still have to put it in there because when we call all the way it was here when we call the update method then this paddle group is going to call the update method on every single sprite inside of it so it's going to call the update on the opponent and on the player and it's going to pass this one into it and if we don't specify a parameter in the player group for this then it would cause an error so if you want to pass in an argument into any sprite in a group you effectively have to pass it into all members of the group which can be a bit cumbersome but it's generally workable and especially in our case it's quite straightforward thing to do so that kills all of this again and we're back here we just update our pal group and then we also update our group and after that we're free set ball and draw score reset ball is quite an interesting class so let me explain and the important thing you want to be aware of here is that our ball class also have reset both us so we have to reset ball methods in our game and they are named Sonali by design and effectively the reset ball method of the game manager calls the reset ball method of the ball itself so it effectively this entire method resets the ball and that's the score whoever achieved the score and then finally we just draw the score and this happens on every single frame and all of that is basically the logic of our game and if you compare this to the previous game we made and you are going to see quite a lot of similarities and I hope that made sense and let me know if you're going to go through this in more detail however there's one thing I do want to cover and this is when we create the ball we call group single and this might throw you off if you just follow these tutorials that in Pugin we have two different kinds of groups we have pi game dots brighter group and we have pi gamma dots brighter group single and both of these groups are really similar the only real difference is given from the name that a group can take any number of sprites so we could have a hundred different sprites in here and update them all at the same time group single on the other hand only accepts a single sprite and if you added another sprite to this group it would kick out the ball sprite so a group single only ever has a single sprite in there kind of like the name implies but besides that it does the exact same thing you can still call update on it and it would update the sprite inside of it but okay that is basically all of it I hope that made sense and let me know if you want to go for all of this in more detail but that would be quite a long tutorial but yeah I see