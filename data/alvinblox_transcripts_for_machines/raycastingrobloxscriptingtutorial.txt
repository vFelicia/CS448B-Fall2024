okay in this video I'm going to show you how to use raycasting in Roblox so what is raycasting well raycasting is essentially the act of firing an invisible part and I say part in this context to make it easier to understand but we actually call it a ray and it's sort of like a projectile which travels in a certain direction until it hits something and this Ray it doesn't collide with anything it doesn't stop the game from doing anything you know it does you can't walk into a ray for example it's just an invisible um moving projectile which starts in one position all right it could be right here where the camera is and it could be instructed to go in this direction and it will travel in this direction until it hits something and when it hits something it will give us the information about what it is it is hit so you can sort of think of it as like a moving touched event that that's always active but moving in in One Direction sort of the opposite of of how a touched event currently works because with a touched event you're waiting for something else to hit the part whereas in this uh example with Ray casting you're waiting for the ray to hit apart so it's the ray that is moving so you can think of the ray as just being like an invisible projectile like a bullet that's moving in a certain direction and we tell the game where we want the ray to go using some parameters which I'm going to going to show you so how do you make array well array can be cast uh client and server I believe uh usually you use it on the client though because um usually you're you're building things like guns or click events um so that's where we're going to use it today I'm going to put a local script into start a GUI and let me first show you how to create array it's very simple all you say is game. workpace C on Ray cast like this this tells the game look we want to fire array so we need to tell it where to start where do we want to fire the ray from so let's create a few parts that are going to help us visualize this so we'll just create a part for our starter position we'll call this start you don't have to do this I'm just doing this as an example we're going to make sure it's anchored and we'll make it green right because it's the start and then what direction do we want our aray to go in okay do we want it to go in this direction do we want it to go in this direction well I'm just going to move it over here okay this is where we want the ray to go we want the ray to start off here and we want it to travel in the direction of the red part now it's not going to go to the red part it's going to go beyond the red part so it's going to go in this direction and it's just going to keep on going until it hits something okay but we need two parts in order to tell the ray where we we want it to start and what direction do we want it to go in so that's what I've done here I've created these two parts so let's go back to the local scripts and let's input these two parts as our origin and our Direction so what we've done here is we've said Okay I want the ray to start at this position you've got to pass in a position not an object so we're starting at this position and for the direction we're just going to put this for now okay the the finish part and what you could do instead instead of passing a position here you could pass an actual Vector 3 and that will just be the amount of studs in each direction of x y and Zed that it will travel from the start position so what I like to do instead of saying the finish position in order to get the direction because this isn't actually the direction this is just the position of the Finish point but we want to get the direction between this part and this part so to do that we can just subtract the positions so let's just create a variable here for direction and this will be the Finish now we don't want code assist the finish part its position subtract the start position and this will give us a vector of the direction that it's traveling in okay so it will give us this position right where it's looking at this part so it's saying this direction is where we're going to be traveling so now that we've got the direction and the start we have told the game okay we want the ray to go here but now we also need to give it a few more bits of information because we haven't told the ray where we want it to stop at we haven't said look stop when you hit this specific object stop when you hit a player stop when you hit the end of the world we haven't told it this information so we need to create something called raycast pams and this is almost like a table it's a specific data type and it has some details which we need to configure for our raycast so for example we have raycast prams do filter descendants instances and this is a table of objects which you either want to ignore or wh so if we were to put let's say we had something in the middle of our two parts here like a wall okay and our array is going to hit this wall now perhaps we don't want it to hit this wall we want it to ignore this wall well that's fine what we could do is we could put this into our filter descendants instances like this and if you were to supply something such as a folder which had loads of different instances inside of it then if you were to pass the folder well it should include all of the children by default okay you wouldn't have to say get children because it would include any descendants of that item so we will just put our wall as the filter descendant instance and then we have to tell the script well do you want us to ignore or whitelist these parts and when I say ignore it will simply ignore it if it hits these parts if we whitelist them though it means it will only uh finish the ray it will only trigger when it hits one of these instances that's what the difference is between ignore and and wh list but I don't think that's the actual um vocabulary that we have to use I think let's have a look uh raycast filter type okay so it's include or exclude so we want to exclude in this case because we don't want the ray to detect these objects so we're going to set that to exclude if you want wanted it to exclusively trigger when it hits this object you'd set it to be include and then finally you can say ignore water so that will if you said it to true it won't fire it won't end the ray if it hits some water okay some terrain water so I mean you can set that to true or false it doesn't really matter if you don't have any terrain you don't have to worry about it but this is our Ray and our Ray will now be cast and we will just add the ray cast perams as our third parameter now make sure when you're typing raycast params you're dealing with your variable which is lowercase raycast uh upper P for pams okay because you might accidentally say raycast pams and it will turn to Blue which is the data type we want the variable that we've just created okay so this will fire our array and we can store this as a variable and usually you call it raycast result you can call it whatever you like I'm just following how they do it on the Roblox docs and then how do you detect that your array has actually hit something well you can say if Ray cast results then if raycast results do instance then print raycast results do instance. name and this will print the object that it hits now let's just open up the output and let's create a second wall okay now this time we don't mind if it hits this wall so we're going to just call it second wall and this isn't a part of our filter descendants instances table so let's see what happens here if I just go and in fact what we'll do is we will do a task. weight of 5 Seconds here so we can see everything if there's no raycast result I'm going to print no result and if there's no instance then I'm going to print no instance okay let's have a look and see what happens here so we click on play and we wait for 5 seconds so the ray should fire from here should go through our wall and it should return uh second wall but it does not it returns finish because it's hit the finish part before it has hit the blue wall because it's traveling in the direction so that it will meet this part and it just so happens that it hits the finish part before it hit the second wall because guess what the finish part is in front of the second wall so I don't want it to class hitting my finish part as the end of the ray because that's merely a visualization that we've made so I'm going to add the finish part and also the start part because why not to the filter descendants instances which should mean the next time we fire the ray it is going to instead carry on traveling and it will hit the second wall but there's no result this time how strange let's have a look and see why that could be so ah yes so because we got the direction by subtracting the start position from the finish position we only have a vector which is going to travel to this part it's not long enough the direction that we've passed to our Ray doesn't go far enough to actually hit this wall because it goes to the length of the finish part because that's what we've calculated so the direction has given us essentially the angle that we want to move in right it say because if we were to supply the start part well we could be wanting to move in any direction by subtracting these two parts these two positions we have found the direction in which we want to travel however that direction Vector is only as long as the distance between these two parts because we've subtracted their positions so how can we keep the the direction the orientation right which is telling us to move in this direction but how can we extend it well what we can do is we can take this direction vector and we can turn it into a unit vector by saying do unit and putting these into parenthesis and what that does is it takes the vector and it reduces the length of that Vector in every single axis the X Y and Zed axis to just a multiple of one okay so imagine the direction is well let's print it out let's print out what the direction is okay and then let's print out direction do unit okay and if you type do unit it will say a normalized copy of the vector 3 has the same direction so it keeps that direction it tells us it it remains uh the direction so it tells us what direction we're going to travel in but it has a magnitude of one it has a length of one so let's click on play and see what happens so we have our normal Direction Vector that's telling us the direction then we have the unit Vector which is making it a number between 0 and one essentially so what we've done is we've removed the magnitude we've removed the distance from this Vector but we've kept the direction in which it's pointed so it's essentially just a really really small Vector that's heading very very slightly in One Direction so what we can then do is multiply this by an amount of studs and then we can say I want you to travel in this direction for x amount of studs so we're basically extending the vector so we'll just set this back to unit but this time we'll multiply it by 100 and that means it's going to travel in Direction by 100 studs because we've brought it down to a value that's near one so that we can then multiply it by a distance okay so that we have an accurate distance representation yes we could have probably multiplied this by 100 but it would have given us a huge vector and the ray potentially would have been traveling for thousands and thousands of studs which isn't very performant right we only want it to travel for 100 studs if you wanted it to travel for longer than that you could obviously change that but in this case only 100 studs and then what will happen and also what I'm going to do is I'm going to do a task. weit of two seconds here just to make sure these two parts have loaded in by the time we click on play if you get an error you might want to check that yourself and then click on one uh click on play sorry and if we just wait about 7 Seconds you should see that the aray will fire and it should hit the second wall because this time it's ignored the finish right it's still traveling in this direction because we got the unit Vector which has kept that information as part of our vector by saying unit we've just Shrunk the length of the vector from the distance between these two parts down to one and then we're multiplying that unit vector by 100 which is bringing it back out to around here so the length of that Vector means that it's going to be able to hit this wall which it's done and it's returned the second wall now you can also print out the array cast result do position that will be the position where it ended up where it hit the part so if it is hit our second wall it will log the position where it is hit and just to show you we can create another part and call it hit and we can say game. workspace do hit. position equals raycast results. position just going to change these to task. weight of one and if we zoom out you can see that the pink part has appeared at the exact position where it has hit the second wall and you can see it still traveled in the same direction because we've kept that directional aspect with our unit vector and if the wall hadn't have been here it would have kept on traveling until it would have reached 100 studs and then it would have stopped so you can see how this would be used in a BL game for example with guns so the green part in this instance would be the position where your character is if you're holding a gun and it would the direction would be based on where your your camera is and then or where you've clicked sorry and then where you clicked might have been another player so the Bullet would have traveled in this direction perhaps it's hit a wall perhaps it's hit a player and then you would detect whether that raycast instance is a player if it is a player you'd then fire a remote event and on the server you deduct their health and you'd potentially check to see if it was a um you do a sanity check to ensure that the player could legitimately injure that player with a bullet perhaps they in the same vicinity they're not exploiting so that is how to do raycasting in Roblox uh you get the direction which in this uh in this example I've calculated the direction by subtracting two positions you could also just Supply a vector 3 of your own like this it's completely up to you but if you want to specify the direction I'd recommend turning it into a unit vector and then multiplying it by your distance so that is how you raycast in Roblox let me know if you have any questions please subscribe if you found this video helpful as well like the video and I'll see you in the next one thank you for watching