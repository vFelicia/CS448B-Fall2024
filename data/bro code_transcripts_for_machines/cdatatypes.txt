all right what's going on people let's discuss more about data types we discussed a few in the last video but there's a few more that you should be made aware of so chars they store a single character and use the percent c format specifier to display a single character there's an array of characters which can store one or more characters then to display that you use percent s as the format specifier floats they will store a decimal number and we use the percent f format specifier to display a floating point number and then we have integers which only store a whole integer there's no decimal portion and we use percent d to display an integer now along with floats we have doubles doubles have double the precision of a float we can store even more significant digits floats use four bytes of memory they have 32 bits of precision and we can store between six to seven significant digits doubles they have eight bytes of memory double that of floats and they have 64 bits of precision and we can store between 15 to 16 significant digits with my float and my double i'm storing the first several digits of pi i'm going to attempt to display as many digits of pi as i can with a float so i'm going to display these so to display a float use percent f and lf for a double which means long float now by default when i use printf to display a floating point number or a double this will only display the first six to seven digits but we can actually change that we'll discuss more about these in the next video on format specifiers if i would like to display even more digits after the decimal i will add zero point and the amount of digits i would like to display so i would like to display 15 digits after my decimal and i'll do that for my double as well so after the percent signed 0.1 f then add lf and let's take a look at these numbers okay after my two which is i believe the sixth digit after the decimal we actually lose our precision these numbers are not the same but our double will actually retain these numbers so point being a double is even more accurate than a floating point number there is more precision but it uses more memory a double uses eight bytes of memory because of this reason we tend to use doubles a lot more than floats just because they're more precise we don't want to lose our precision next up we have booleans to work with booleans and c include this at the top std bool.h booleans store true or false so they work in binary one represents true and zero represents false so when you need to declare a boolean variable you type bool then a variable name and you set it equal to true or false technically we only need one bit to represent true or false one for true and zero for false but this still uses up one byte of memory and then to display a boolean you can use percent d so if i was to display this boolean variable i would use percent d so one corresponds to true and zero corresponds to false although there are some tricks that we can do in the future where we could display the word to true or the word false but for now we're going to stick with percent d as the format specifier so these work in binary one for true zero for false now another thing that we can do with chars is that we can store a whole integer between the range of negative 128 to positive 127. so in this example we have char f and i will store the integer number 100 we can display this number as either a decimal an integer or a character so if i was to display this number as a character we will use the ascii table to convert this number to a character representation the ascii table has a range between 0 to 127 so if i was to display this number as a decimal using the percent d format specifier of course this will display as 100 but if i was to convert this to a character using the percent c format specifier this has a corresponding character and that would be lowercase d so i'm actually going to change this to something else what about i don't know uh 120 so let's see what the character representation of that number is and that would be a lowercase x so you can use chars to store more than single characters you can also use them to store a whole integer however the range is between negative 128 to positive 127 because they have one byte of memory now there is a keyword unsigned so when you declare a variable that is unsigned we disregard any negative numbers so effectively this doubles our range with our positive numbers so if we have unsigned char we can store a number between 0 to positive 255 because we know we're not going to store a negative number so then if you need to display an unsigned character we can use just percent d i'm going to store 255 within my unsigned chart and that would be of course 255. however if we go beyond this range this will overflow and go back to zero so if i was to display this we have a warning unsigned conversion from int to unsigned chart so then this resets back to zero so if you go beyond the maximum range this will reset all the way back to zero whatever the beginning is so if you add this keyword unsigned you can effectively double the range of positive numbers that you can store within a variable by default most data types are already signed but we don't need to explicitly type that so point being with chars you can store more than a single character you can store a whole integer between ranges negative 128 to positive 127 if it's signed if it's unsigned you can store numbers between 0 to 255. you can display them as an integer by using the percent d format specifier or you could convert them to a character using the ascii table by using the percent c format specifier next we have short ins short ins use two bytes of memory they can store a number between negative 32 768 to positive 32 760 because while they use two bytes of memory they can only store a number so large and if it's an unsigned short int the range is instead between 0 to 65 535 and we use the percent d format specifier to display a short in so within my printf statement i'm going to display these two numbers so i will display variable h and i h is a short integer and i is an unsigned short integer so these are the maximum values for a short integer and an unsigned short integer and like i discussed with chars if we go beyond this range we will encounter an overflow so i'm going to change this short end to 32768 and let's see what number displays so this will overflow and reset this value back to the minimum value which in this case is negative 32 768 and if you do the same thing with the unsigned short integer that would be zero because that's the minimum value for an unsigned short integer so those are short integers they use two bytes of memory and they can store numbers between these ranges depending if it's signed or unsigned oh and another way of writing these you don't necessarily need to declare these with the word and you could just say short and that would do the same thing people usually just call them shorts instead of short ends so those are what shorts are now with integers we kind of discussed this in the last video just briefly integers store a whole number between just under negative 2 billion to just over positive two billion because they use four bytes of memory and we use the percent d format specifier to display a signed integer if that integer is unsigned the range changes from zero to just over positive 4 billion however there is a different format specifier to display an unsigned integer you instead use percent u so then let's display these percent d for a signed integer and percent u for an unsigned integer and these are the maximum numbers and then if i was to exceed the range this again would cause an overflow and reset these numbers back to their minimum values so those are standard integers they use four bytes of memory so they can store numbers between these ranges depending if they're signed or unsigned all right the last data type we're going to talk about for this topic is a long long integer now the reason that we have long twice is that with standard integers these are already considered longs but we don't need to explicitly type long for standard integers so to represent a really large number we can use a long long integer and these use eight bytes of memory the effective range for a signed long long integer is just underneath nine quintillion two just over nine quintillion and the format specifier for a long long integer one that is signed is percent lld now if it's unsigned that changes the range between 0 to just over positive 18 quintillion and the format specifier is percent llu then let's display these so for a signed long long integer that is lld and if it's unsigned that is llu now we'll encounter a warning so this warning applies to our unsigned long long integer integer constant is so large that it is unsigned so one way in which we can prevent that warning is after our number within our unsigned long long integer add a u to the end of this so then we can display this number with no warning so since long long integers use so many bytes they can store a gigantic number we tend to not use long long integers very often because well we don't really have a need for this large of a number but in certain circumstances you might perhaps you're dealing with the speed of light or something you may need to use a long long integer but commonly we use standard integers a lot more well yeah everybody those are even more c data types we likely won't be using most of these but you should still be made aware of their existence i would say that we're going to focus on chars array of chars doubles booleans and integers so pay attention to those ones but you should still be made aware of the existence of other data types just in case you encounter them if you found this video helpful please smash that like button leave a random comment down below and subscribe if you'd like to become a fellow bro