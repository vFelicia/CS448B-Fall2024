how's it going everybody its bro here hope you're doing well and in this video we're going to be discussing multithreading in Java we're gonna be counting up and counting down at the same time how about that let's get into it if you find this video helpful please remember to Like comment and subscribe your support will help keep this channel running all right everybody let's discuss the definition of multithreading real quick so this is the process of executing multiple threads simultaneously and it helps maximize the utilization of your CPU and with threads they are independent so they do not affect the execution of other threads and an exception in one thread will not interrupt other threads since they run independently and this is useful for serving multiple clients multiplayer games or other mutually independent tasks so let's do some multithreading right now so what we're going to be doing for this example is that we're going to create two separate threads and each of these is going to have basically a sub program in the first thread we'll create a simple counter that will start at ten and count down to zero and in the other thread we'll do the same thing we'll have a counter but let's start at zero and then count up to ten and both of these threads are gonna run at the same time and display the results as they continue so there's two different ways of creating a thread the first is that we can create a subclass of the thread class so let's try that so within your project folder go to file new class and let's call this maybe my thread it doesn't really matter just make sure that this subclass extends the thread class and then we're going to need to override the run method of the thread class so we're going to type in public void run parentheses curly braces and since we're overriding a method it's good practice to add at override although it's not necessary so when we start the instance of this thread class it's going to execute this run method so let's create an instance of my thread within our main class so we're going to type in my thread or whatever else you name to this let's call this first thread thread 1 equals new my thread all right so when we eventually start this thread it's going to execute this run function so what do we want this to do well this is a great time for us to place our counter program within here so we can do this with a simple for loop so we'll start at 10 and then count down to zero so we'll put for int I set this equal to 10 we'll continue I as long as I is greater than zero and then we'll decrement I by one after each iteration of this for loop so within this for loop let's just system that out dot print line maybe thread number one and then we'll display whatever the current value of I is so we don't want this to run like instantaneously maybe we would like some sort of like pause for like 1000 milliseconds between each of these iterations to simulate like a countdown so what we can do is just type in thread dot sleep then within here we want this to sleep for 1,000 milliseconds after each iteration and then since we're using this method we have to surround this with a try and catch block so make sure you put that in as well all right so then once we exit this for loop let's just display a message such as thread number 1 is finished all right and that's all there is to it so there's another way that we can create a thread so the other way is that we can create an instance of a class that's implementing the runnable interface and then we can pass this instance within the constructor of a thread object but I'll show you how to do this so within your project folder go to file new class and we're going to be implementing the runnable interface so let's call this class maybe my runnable and click finish so we're going to have my runnable implements runnable and then we need to add unimplemented methods so since we're using an interface we need to use all methods that runnable have within its interface and that is the run method within here so going back to our main class what we're going to do is create an instance of my runnable so my runnable and let's call this runnable one equals new my runnable now the second step is that we're going to take runnable and send this within the constructor as an argument within the thread class when we create an object so we'll type in thread thread not my thread and let's call this thread two equals new thread and then within the parentheses of thread just place your runnable instance within here so this is the other way of creating a thread use a subclass or a class that's implementing the rentable interface create an instance of it and then pass it as an argument to the thread class so there's two ways in which you can create a thread the first way is that you can create a subclass of the thread class so you just create a class name and make sure it extends the thread class and then you have access to a run method and the other way is that you create a class that implements the runnable interface and then you take this instance and pass it as an argument to the constructor of the thread class and then that's how you get your other thread so you can do it either way it depends on how you want to write your program like for this example we've could have done like thread 1 and thread 2 by using the my thread class otherwise we could have done like my runnable 2 and you know thread 2 the other way but for this example I wanted to show you guys both ways but yeah you basically have two different ways of creating threads personally I tend to prefer to you is the runnable class or the runnable interface and then pass this instance as a constructor to the thread class because with this class you can still use inheritance like we can extend another class but if you use this class as a subclass of the thread class well in Java you can only have one parent so we can't like have another class as a parrot we're limited to just one the thread class however we can implement another interface so just from my own experience people tend to use the runnable interface more compared to extending the thread class but do it works for you though but I'm getting off track again so we should probably finish this program so we need to fill in the run method of the my runnable class so what we can do actually is go to the my thread class and copy everything here and make a few changes so I'm going to copy this and then paste it within the run method of the my runnable class so instead of counting down from 10 let's count to 10 starting from zero so we'll set a equal to zero we'll continue this as long as I is less than 10 and then we're going to increment I by 1 each time and then let's change system dot out dot print line thread number one to thread number two and then down here after we exit this for loop will display a thread number two is finished all right so that should be everything so let's go to our main class we're going to start thread 1 and thread 2 so I'll type in thread 1 dot start as well as thread 2 dot start and that's it let's run this so thread 1 starts at 10 thread 2 starts at 0 and you can see that they're both either counting up or counting down depending on you know which one is running but you can see that they're both running at the same time and they finished at the same time so that's one of the great benefits of multithreading because it's kind of like you can make your own sub program that runs independently so ladies and gentlemen we have successfully multi and one of the great things about multithreading is that if one of these threads encounters an exception and gets interrupted the other threads will still continue so let's actually intentionally cause an exception so within the run method of the my thread class let's divide a number by zero which we can't mathematically do so I'm actually going to fit this maybe within the for loop so what I'm going to do is just within a print line statement I'm going to divide number one by zero so this will throw an arithmetic exception and let's see what happens now so you can see right off the bat thread one encountered an exception the technical name of the first thread is thread zero but that is thread 1 for all intents and purposes but you can see that even if our thread 1 stopped thread 2 still continued along with our main thread so let's actually take this and then move it within our main class so how about after these threads start thread 1 and thread 2 we'll divide by 0 right after these threads start so it says exception and thread main but these threads are still continuing so that's proof that threads can run independently and if one thread encounters an exception the other threads will continue still now there's one method I want to talk to you guys about and that is the join method so the calling thread that calls this join method will actually wait for a specified thread to die until it resumed x' so let's say that we want thread 2 to start right after thread 1 so what we'll do is type in the thread that we're waiting to die or finish basically let's say thread 1 so what ends up happening is that if we type in thread 1 dot joined we're going to pause our main thread until thread 1 is completely done and then we'll need to either surround this with a try and catch block or add throws declaration which I did at the top so if we type in thread 1 join the main thread is going to wait until thread one is finished and then it's going to continue on with the rest of the program so let's try it so thread one is running right now but thread two doesn't appear to start and then once thread one is done thread two will start because our main thread resumes with the rest of the program so it says thread 1 is finished and then thread 2 started right after that so you can also put an amount of milliseconds in here and that allows for like a delay so for example if we put 3,000 milliseconds in here the main thread is going to be paused for 3,000 milliseconds before the main thread will continue so let's try it again but place 3,000 within here so it's going to wait 3 seconds before thread 2 begins and that seems about right so then thread 1 is about to finish and then thread 2 is going to finish a little bit later right about now with the join map that the calling thread and for this example it's the main thread well wait until the specified thread dies or for X amount of milliseconds hey you know what I forgot to talk about demon threads in this video so I should probably do so before we wrap things up so a demon thread is a background thread it is a nonuser thread so user threads and demon threads are kind of like opposites so the Java Virtual Machine will not wait for any demon threads before exiting but as long as there's one user thread the Java Virtual Machine is going to wait to exit until all user threads are finished so let's take our previous example where we divided a number by 0 within our main class so what we did for this example is that the main thread encountered an exception but these other two user threads are still running so since there's at least one user thread that is still running the Java Virtual Machine will not exit until all user threads are complete but if we were to set these as demon threads well the Java Virtual Machine is to exit then as soon as all user threads are finished so let's change these to demon threads so we'll take thread 1 dot set demon and set this to true and we'll do the same thing for thread so thread 1 and thread 2 will no longer be user threads they are the opposite basically they are demon threads and when we run this program well we don't get that countdown anymore we have an exception and thread main and the Java Virtual Machine actually terminated because there were no more user threads we had some demon threads running in the background but they terminated because the Java Virtual Machine doesn't care if they're running it'll exit regardless so that's the basics of multithreading and just as a reminder before you go there are two different ways of creating threads I just so happen to use both of these ways for this example you can either create a subclass of the thread parent class or you can implement the runnable interface and pass that instance as an argument to the thread constructor so you can do it either way you might have a preference for one or the other but for this example I just did one of each you don't have to do it exactly in the way that I did so yeah if you want a copy of all this code I'll post this in the comments down below and well that's the basics of multithreading in Java hey you yeah I'm talking to you if you learn something new then you can help me help you in three easy steps by smashing that like button drop a comment down below and subscribe if you'd like to become a fellow bro