hey everybody so we have finally made it to Python objectoriented Programming this is a very important topic in Python an object is a bundle of related attributes and methods attributes are similar to variables to describe what the object has so look around you right now you are surrounded by different Real World objects next to me I have a phone a cup and a book each of these objects can have different attributes to represent it for example an attribute of the phone next to me could be version number I could set that to be 13 is on could be another attribute is the phone powered on or not that could be true or false or even a price I have a cup next to me what liquid is within the cup in this case coffee what's the temperature of the cup is the cup empty is empty or even a book What's the title of the book that could be a string how many pages does the book have Pages could be another attribute now objects also have the capability to do things they have methods which are functions that belong to an object people mix up functions and methods all the time they're technically different even when teaching I tend to make that mistake calling a method a function and a function a method usually people know what you're referring to though a method is a function that belongs within an object what are some actions these objects can perform with a phone you can make a call or receive a call turn the phone on or turn the phone off those could all be functions with a cup you could fill the cup drink from the cup or empty the cup with a book you can open the book read the book and close the book an object is a bundle of related attributes and methods they can represent real world items to create many objects we'll need to utilize a Class A Class is a type of blueprint used to design the structure and layout of an object we need to design what our objects have their attributes and what they can do their methods we will create a class of car we will create some car objects class car to construct a car object we need a special type of method called a Constructor it works similarly to a function we will Define a function of double underscore init meaning initialize double underscore again and then follow this with a set of parentheses this is our Constructor method we need this method in order to construct objects it's a Dunder method Dunder meaning double underscore that's a future topic I don't want you to be overloaded with information right now all you need to know is that we need this method in order to create objects this method behaves similar to a function we need to set up the parameters self is already provided to us self means this object we're creating right now this car so what are some attributes that a car should have a model that could be a string like a BMW a year that could be a number a color let's add a Boolean of for sale is the car for sale or not that's true or false to assign these attributes we're going to access self self dot the name of the attribute self. model equals the model we receive these are parameters when we receive the name of a model we will assign it to this object let's do this with year self. year equals year self. color equals color self do for sale equals for sale this is an example of a few attributes that a car might have a model year color and if it's for sale or not represented by a Boolean now to construct a car object we need a unique name for this car let's just say car one car one equals take the name of the class add a set of parentheses to invoke The Constructor we're going to do this this almost exactly like a function we have parameter set up we need to send a matching number of arguments self is provided to us behind the scenes automatically we need a model year color and if it's for sale or not so pick a car of you're choosing I'll pick my favorite car the model will be a Mustang for the year I'll go with the recent year of 2024 a color I'll pick red is the car for sale I like this car so no I will set that to be false make sure false is capitalized let's see what happens if I attempt to print our car object of car one what we're given is the memory address of this car object where it's located but I would like one of the attributes located at this memory address instead of printing the object itself we're going to access one of the attributes found within this car we will follow the name of the car with a DOT this dot it's known as the attribute access operator I would like the model of car one that would give me Mustang let's access the year take the name of the car car 1 dot the year 2024 followed by the color car1 docolor red car one is it for sale we'll print that that is false now let's create a second car we're going to reuse this class to create a second car we will create Car 2 equals car we'll pass in some different arguments a Corvette the year will be 2025 the color will be blue is this car for sale let's say that is true instead of accessing car 1's attributes let's access car 2's attributes that would give us a Corvette the year is 2025 the color is blue for sale is set to true or even a third car car 3 equals a new car we will pass in a string of charger the year 2026 the color will be yellow is this car for sale let's say that is true as well then I will print car 3's attributes the model is charger the year is 2026 the color is yellow for sale is set to True with classes they can take up a lot of space for better organization you can place them within a new python file so let's cut our class and we will create a new python file within our project folder file new python file the name of this python file is going to be all lowercase car then we will paste the class that we cut originally class car which has a capital c so from our main python file we're going to import our car file our car module modle from the name of the module car import the name of the class car then when I run this program nothing should change we should still have access to all of our car objects you could either keep your classes within your main python file or import them if you would like to organize things let's talk about methods methods are actions that our objects can perform within our class we will Define a method of Drive self is going to be provided to us when we invoke the drive function let's print you drive the car what other things can cars do let's stop we will print you stop the car let's take car one access the drive method you drive the car car 2 also has a drive method you drive the car same thing with car 3 you drive the car let's access the stop method car one. stop car 2. stop and car 3. stop these methods are identical for each car object instead of printing the word car let's insert the model of the car I will convert these print statements to F strings instead of the word car let's add a placeholder let's add self. model self is referring to the object we're currently working with use the attribute axis operator followed by the name of the attribute let's also do this with the stop method self do model let's take car one use the drive method you drive the Mustang car one. stop you drive the Mustang you stop the Mustang let's do this with Car 2 you drive the Corvette you stop the Corvette car three you drive the charger you stop the charger now within our F strings let's also insert let's insert the color I'll add a placeholder self. color do this with stop as well self. color you drive the yellow charger you stop the yellow charger car one you drive the red Mustang you stop the red Mustang card two you Drive the blue Corvette you stop the blue Corvette let's add one last method let's create a method to describe our car we'll print the details of the car let's print I'll use an F string add three placeholders let's print self doye followed by self. color then self. model we'll take car 1 use the describe method that we created describe car 1 car 1 is a 2024 red Mustang describe Car 2 Car 2 is a 2025 blue Corvette car 3 is a 2026 yellow charger all right everybody so those are objects in Python an object is a bundle of related attrib attributes attributes are variables that an object has and methods methods are functions that belong to an object they Define what this object can do and well everybody that is a summary of objectoriented programming using python hey everybody today I got to talk about class variables in Python class variables are shared among all instances meaning objects created from a class instance variables are defined inside of the Constructor class variables are defined outside of the Constructor with class variables they allow you to share data among all objects created from the class with instance variables each object has their own version with a class variable all those objects share one variable here's an example we will create a class of student we also need a Constructor when we create a student object object this Constructor is automatically going to be called but we need to pass in some arguments we are provided with self self refers to the object we're currently working with we will set up a name parameter and an age parameter we will assign self the object we're currently working with set the name attribute to equal the data for the name that we receive from this parameter and self. AG equals age let's construct two student objects we will have student one equals then call the Constructor for student so type the name of the class followed by a set of parentheses to invoke it this will automatically call The Constructor but we have to pass in data for the name and the age for the name let's pass in SpongeBob because basically everybody in the world knows who SpongeBob is I don't know how old SpongeBob is we'll say he's 30 we will create another student object which we will refer to as student 2 we will call the Constructor of our student class pass in data for the name and age student two will be Patrick Patrick will be 35 okay let's make sure this works let's print student 1's name followed by student 1's age and we should get SpongeBob and his age is 30 let's print student 2's name and student 2's age Patrick Patrick is 35 now we'll create a class variable class variables are defined outside the Constructor and they are shared among all objects created from that class each object has their own name and age property these are instance variables but class variables are defined outside the Constructor each object will share this one variable so if we're working with students let's say there is a class variable of class year what is the graduating year of this class 2024 now let's print student 1's graduating year print student one. class year okay so SpongeBob has a class year of 2024 that's when he's graduating let's check student two Patrick is ages 35 his graduating class year is 2024 now with class variables you can access them through any one object such as student one or student 2 it's good practice to access a class variable by the name of the class rather than any object created from the class since we're accessing class year we'll access this class variable by the name of the class of student make sure the S is capital this helps with Clarity and readability if I was looking at this print statement I can tell that class year is a class variable because we're accessing it directly from the class and not any instance from this class without looking at this class I can't tell if class year is an instance variable or a class variable but if I access it via the class name it's more explicit so it's good practice to access a class variable by the class name itself and not any one instance of this class let's create another class variable we'll create a class variable to keep track of how many students we have created this class variable will be num students meaning number of students equals zero So within our Constructor we can write any code that we want this code will always be executed when we instantiate an object I would like to take our number of students and increment it by one each time we construct a new student object so instead of using self self refers to the object we're currently working with if we're constructing student one just imagine we're replacing self with student one or student 2 if we were constructing student two if we're going to be modifying a class variable in place of self we'll use the name of the class student access our class of student get the class variable of number of students then I will increment it by one plus equals 1 we are constructing two student objects I will print X access our class of student get the number of students and print it we're constructing two student objects if I print the number of students that we have it should be two then just to be sure that this is working let's construct a third student object student 3 equals student this student will have a name of Squidward Squidward's age will be 55 now we have three students and for good measure let's construct one more student 4 equals we will create a new student with a name of Sandy sy's age will be 27 the number of students is now four just as an exercise using an F string let's print the student classes class year as well as the number of students I will print use an F string my graduating class of let's add a placeholder access the class of student then access the class Year my graduating class of 2024 has then we need the number of students We'll add a placeholder access the class of student access the number of of students has blank students let's see if this works my graduating class of 2024 has four students now if I were to change 2024 to 2025 my graduating class of 2025 has four students let's print the name of each student these are instance variables student one. name then we need Student two three and four my graduating class of 2025 has four students SpongeBob Patrick Squidward Sandy all right everybody so those are class variables class variables are shared among all instances of a class they are defined outside of the Constructor the benefit is that they allow you to share data among all objects created from that class and well everybody those are class variables in Python what is going on everybody so today I got to talk about inheritance in Python inheritance allows a class to inherit the attributes and methods from another class much like how a child in real life can inherit traits from A parent by having a class inherit attributes and methods from another class this helps with code reusability and extensibility in this example we're going to create an animal class the dog cat and mouse class will inherit attributes and methods from the animal class we will create a class of animal then I will Define The Constructor when we construct an animal object let's pass in a name it's not required but it might be good for this example we will assign the attribute of name equal to the name we receive let's also add an attribute of of is alive whenever we create an animal we will set there is alive attribute to be true and that is a capital T all animals can eat Define eat we will print using an F string add a placeholder self. name the name of this animal is eating all animals should be able to sleep Define sleep print I'll use an FST string insert self. name is sleeping and that is all we need for the animal class let's define class dog for a child class to inherit the attributes and methods from another class after the class name that's going to inherit we need to add an inheritance list with the set of parentheses then list the name of the class we're inheriting from the parent parent the dog class is going to inherit all of the attributes and methods of its parent animal for the time being as a placeholder I'll add pass just to demonstrate this class cat is also going to inherit from animal and class Mouse will also inherit from animal okay I will collapse this for now we'll create a dog object dog equals dog then pass it a name for this dog because we have one parameter set up of name this dog will be named Scooby as in ScoobyDoo cat equals call the cat Constructor this cat will be named Garfield and mouse mouse equals Mouse our Mouse will have a name of Mickey even though there's nothing within this dog cat or Mouse class we should still have these attributes and these methods if you inherit the animal class you should have a name attribute and is alive attribute set to true you can eat and you can sleep let's print our dog's name dog. name Scooby print dog. is alive our dog is alive that is true let's have our dog object use the eat method Scooby is eating and sleep dog dos sleep Scooby is sleeping let's replace dog with cat the name of the cat is Garfield Garfield is alive Garfield is eating Garfield is sleeping and Mouse replace any instance of cat with mouse our mouse's name is Mickey Mickey is alive Mickey is eating Mickey is sleeping even though these children classes are empty we're still inheriting these attributes and methods from its parent of animal this is convenient because you don't need to copy and paste these attributes and methods for every single class for example if I were to copy these attributes and methods and paste them well we have a lot more code to write and as a consequence if I need to make a change to one of these methods I would have to do that to every single instance of this method for example let's replace is sleeping with is asleep well now I need to find every single Sleep Method and change it manually it's not too bad if you only have a few classes but imagine if you have hundreds of classes that's going to take a lot of work it's a lot easier to write the code once and then reuse it and I only need to make that change in one place rather than make that change many times so let's change is sleeping to is asleep and see if that works again Mickey is asleep let's replace Mouse with dog Scooby is asleep not only that but with children classes they can have their own attributes and methods that are different from one another so dogs have all these attributes and methods and they can speak let's create a speak method and I will print a unique message for dogs woof cats will also have a speak method but it's going to be different cats will meow then for our Mouse class they will squeak let's have our dog speak woof let's have our cat speak meow and our Mouse squeak all right everybody so that's an introduction to inheritance inheritance allows a class to inherit attributes and methods from another class much like in real life a child can inherit TR trates from a parent these are also known as sub and super classes which is a topic for another day inheritance helps with code reusability and extensibility if all of these children classes inherit these attributes and methods from another class we only need to write that code once and not copy it for every single class that needs it we can write and change the code in one place for better reusability and extensibility and well everybody that is an introduction to inheritance in Python hey everybody so today we got to talk about both multiple and multilevel inheritance we'll begin with multiple inheritance that's when a child class inherits from more than one parent class for example a class of C can inherit the traits from both class A and B in Python you can have more than one parent multilevel inheritance we'll talk about near the end of this topic so in this example we're going to create two parent classes prey I'll write pass for now and Predator we'll create a class of rabbit a class of Hawk then class fish rabbit Hawk and fish are going to be children classes prey and predator will be parents if one of these classes rabbit hawk or fish inherit from prey they get the ability to flee we will Define a method of flee all we'll do in this example is print the following text this animal is fleeing if you're a predator you get the method to hunt Define hunt we will print this animal is hunting rabbits they will inherit from the prey class they're typically not Predators except that one rabbit and montypython and the Holy Grail that's the exception rabbit will inherit the prey class then it gets access to a flea method Hawks are predators they will inherit the Predator class now fish they will hunt smaller fish and flee from bigger fish you could consider fish both prey and predators so they will inherit both classes we will use multiple inheritance they will inherit everything from the prey class and the Predator class now let's see if this does in fact work now we'll create a rabbit object rabbit equals rabbit there are no parameter setup we don't need to send any arguments to the Constructor Hawk equals Hawk and fish equals fish so so let's take our rabbit object and they should have a flea method rabbit. flea method this animal is fleeing but they do not have a hunt method because they're not Predators rabbit object has no attribute hunt Hawks can hunt they Predators they inherited that method this animal is hunting but they can't flee they're not prey Hawk object has no attribute flea fish can do both they inherit from the prey class and the Predator class fish. flee this animal is fleeing fish. hunt this animal is hunting children classes can inherit from more than one parent which is what we did for fish they are both prey and predators whereas in rabbits are just prey Hawks are just Predators if you need to inherit from more than one parent you just add that additional class to The Inheritance list with multilevel inheritance a parent can inherit from another parent we will create a class of animal and for now I'll write pass prey and Predator are going to inherit from the animal class so we need to add animal to each inheritance list let's say if you're an animal you get a method to eat all animals will eat print this animal is eating and you can sleep Define sleep print this animal is sleeping so think of rabbit Hawk and fish as children classes prey and Predator are those class's parents and animal is the grandparent pray and Predator will inherit everything that the animal class has rabbit Hawk and fish will inherit everything the prey and Predator classes have so now our rabbit Hawk and fish classes should have the ability to eat and sleep and we'll test that rabbit. eat this animal is eating rabbit. sleep this animal is sleeping let's check out fish fish. eat this animal is eating fish do sleep this animal is sleeping okay we're going to expand upon our example a little bit let me zoom out each of our objects is going to have a name our rabbit will have a first name of bugs Hawk will be Tony as in Tony Hawk our fish will be Nemo within our classes we don't have any Constructor set up in which class should we assign the name attribute let's do so within our animal class so we will Define a Constructor to assign these attributes we will receive a name we'll assign self. name equals name now with these other classes if you're not assigning any attributes or if you don't need any other initialization logic you don't need a Constructor we'll implicitly use the Constructor RoR we inherit from the parent let's convert each of these print statements to an F string replace animal with self. name now let's have our rabbit use the E method oh we should get rid of this there we go bugs is eating rabbit. sleep bugs is sleeping rabbit. flee bugs is fleeing let's check out our Hawk Hawks don't have a flea method because they're Predators not prey let's eat Tony is eating let's sleep Tony is sleeping let's hunt Tony is hunting let's check our fish next our fish can eat Nemo is eating our fish can sleep Nemo is sleeping they can flee Nemo is fleeing and Hunt Nemo is hunting okay everybody that is both multiple and multilevel inheritance with multiple inheritance a child can inherit from more than one parent class you just add each additional class to The Inheritance list with multilevel inheritance a child can inherit from a parent which inherits from another parent Class C can inherit from B where Class B inherits from a think of C as the child b as the parent and a as the grandparent c will have all the attributes and methods even available within the grandparent class of a and well everybody that that is both multiple and multilevel inheritance in Python hey everyone welcome back so today I got to talk about abstract classes in Python an abstract class is a class that cannot be instantiated on its own abstract classes are meant to be subclassed they're supposed to be parents to children classes they can contain abstract methods which are declared but have no implementation abstract classes have a few benefits we can't create an object from a class that's abstract abstract classes you could say are incomplete we don't want to create an object that's incomplete also any children that inherit from an abstract class if there's any abstract methods we have to implement them so let me give you a demonstration we're going to create a Class A vehicle for now I'll write pass to work with abstract classes we'll need to import ABC ABC meaning abstract base classes we need import ABC all capital meaning abstract Base Class as well as abstract method so my vehicle class it's going to be an abstract class we will inherit from ABC the abstract based class I don't want myself or any other developers to be able to create a vehicle object I will make this vehicle an abstract class also I can add some abstract methods these methods will be inherited by its children to declare an abstract method we need to use a decorator at abstract method so what should all vehicles be able to do let's say go and stop if you're a vehicle you can go with abstract methods we declare them but we don't Define them we'll Define them within each of the children children classes that inherit from vehicle let's create another abstract method abstract method Define stop if you're a vehicle you can stop all right we have finished our abstract class A vehicle just to demonstrate that we can instantiate an object from this class let's attempt to do so and see what happens I will attempt to create a vehicle object vehicle equals vehicle and then run this type error can instantiate abstract class vehicle with abstract methods go and stop this is good this is what we want our vehicle class is incomplete we don't want to accidentally make a vehicle object if we were it's kind of like the invisible boatmobile from SpongeBob instead we will create some children to inherit from this class so now we will create a class of car which will inherit from vehicle car is the child vehicle is the parent but we are receiving a warning Class Car must Implement all abstract methods what we're saying is hey if you inherit from the vehicle class you need to include these abstract methods so I'm not going to currently let's just see what happens I will attempt to create a car object and run it type error can't instantiate abstract class car with abstract methods go and stop if a class is inheriting from a parent that's abstract and there's abstract methods we have to finish defining those methods So within our car class really I'll just copy this because I'm lazy our method is go we will print you drive the car we also need stop I will print you stop the car okay let's see if this works this has run with no problems I will have my car go then stop we're calling the go method then the stop method you drive the car you stop the car let's create a few more children for the vehicle class class motorcycle will inherit from the vehicle class again we have to implement the abstract methods found within the parent go and stop for go I will print you ride the motorcycle then with stop you stop the motorcycle motorcycle equals motorcycle we're calling the Constructor then I will have our motorcycle go then stop you ride the motorcycle you stop the motorcycle all right last example let's say we create a boat class which will inherit from the abstract class A vehicle I will include a go method where I will print you sail the boat but I will forget to add a stop method because I'm not paying attention let's attempt to create a boat well what the heck is this type eror can instantiate abstract class boat with abstract method stop then I'll look over my code and see oh I forgot to include a stop method with including abstract methods within a parent it acts as a set of checks and balances all vehicles should be able to go and stop if I forget to Define one of these methods well we'll receive a type error if we didn't I may not have noticed that we're missing a method so now we need to include that stop method I will print you anchor the boat this seems to have run with no problems I will have my boat go and stop you sail the boat you anchor the boat all right everybody so those are abstract classes it's a class that can't be instantiated on its own we can't create any objects from this class we don't want to because it's well incomplete they're meant to be subclassed they can contain abstract methods which are declared but we don't finish defining them we Define them within the children classes in this example car motorcycle and boat and well everybody those are abstract classes in Python hey everybody so today I got to talk about the super function in Python super is a function it's used within a child class to call methods from a parent class the child class is the subass the parent class is the super class hence why this function is named the super function using the super function it allows you to extend the functionality of the inherent methods here's an example we'll create a few shape objects we'll need to set up the classes though we'll have class Circle for the time being I'll just write pass we'll fill it in later class square and class triangle for each of these classes in order to instantiate objects we'll need a Constructor we will Define our Constructor our innit method when creating circles what sorts of attributes should a circle have let's say a color what's the color of the circle is it filled or not filled will be another attribute and a radius then let's assign these self. color equals the color that we receive self. fil equals filled self radius equals radius let's do this with the square and Triangle really I'll just copy our Constructor and paste it squares don't have a radius with a square the width and the height are the same let's replace radius with width we'll also keep the color and filled attributes self. width equals width now with triangles again let's copy our Constructor we'll need a width and a height self. height equals height so with programming we try not to repeat ourselves if we don't have to what do all of these classes have in common they all share the attributes of color and filled the ways in which they are different is that Circle has a radius attribute square has a width triangle has a width and a height if we have to make any changes to one of these attributes we would have to do so manually for example let's replace filed with is filed now I need to look throughout my code for any instance of filled and replace it with is filled it's a lot of work and I might make a mistake such as here and here it's better to write your code once and try and reuse it so that's where inheritance and the super function can come in handy we're going to take the attributes of color and is filled and place it within a parent class these children classes will inherit those attributes so class what do they all have in common they're all shapes class shape and for now I'll write pass circle is going to inherit from its parent of shape that also applies with square and triangle we'll set up a Constructor for shape Define init we will pass in the color and is filled then we will assign these attributes self. color equals color self. is filled equals is filled we don't need to manually assign these attributes within each of these Constructors for the children instead what we have to do is within the Constructor for each of these children classes we have to call the Constructor structor for the parent also known as the super class of shape so we will eliminate these two lines of code use the super function dot call The Constructor of the parent that is the dunder init method but we need to pass in the color that we receive and is filled this will be a Boolean and let's do this with the square class and the triangle class we still need radius for the circle width for the square width and height for the triangle we're going to call the super function to take care of whatever our attributes all these types of shapes have in common such as color and is filled now let's see if this works let's construct a few objects we will create a circle named circle called a Constructor for Circle we have to pass in a color a Boolean if it's filled or not and a radius so for the color of the circle let's say red is filled let's say that is true and a radius of five you could even use keyword arguments for better readability although not necessary but for clarity let's say color equals red is filled equals true radius equals 5 let's see if this works I will print our Circle color it is red print our colors is filled attribute the circle is filled that is true and the radius print circle. rius the radius of the circle is five we could even convert this to an F string I'll add a placeholder then add centimeters 5 cm let's construct a square object square equals Square we'll need a color is filled and a width I'll just copy what we have and make a few changes replace radius with width the color will be blue is filled will be false the width will be six we don't need the height because squares have an even width and height if we ever need the height we can assume it's the same as the width in this case six let's check out our square square do color square. is filled Square do width our square is blue it's not filled in the width is 6 cm let's create a triangle object triangle equals triangle pass in our arguments the color will be yellow is filled will be true the width will be seven and the height will be eight let's print our triangle's color is it filled its width and its height our triangle is yellow it's filled in the width is 7 cm the height is 8 cm so that's how you can use the super function to reuse the Constructor of a parent class we don't need to manually assign each of these attributes within each of the children classes we can do that in just one place when we refer to Super imagine that we're replacing this with the parent class name such as shape that might be a good way to think of it use the Constructor of the parent class of shape and pass these arguments in what you could do as well is extend the functionality of a method So within our shape class let's create a method of describe we will describe the attributes of this shape we will print use an FST string when we want to describe our shape let's say it is at a placeholder self. color what is the color of this shape and is it fill or not and add a placeholder we'll use a tary operator print filled if self. is filled is true else we will print not filled each of these types of shapes circle square and triangle will have access to a describe method let's attempt to use it take our Circle use the describe method that's inherited it is red and filled Square it is blue and not filled triangle it is yellow and filled so then we also have method overwriting what if we create a similar method of describe within circle square and triangle let's do that Define a describe method within our Circle let's calculate the area what's the area of the circle I'll use an F string it is a circle with an area of then we'll calculate the area given the radius to calculate the area of a circle we can take Pi I'll just say 3.14 just to keep it simple times the radius squared self. rius time self. rius if I were to call the describe method will we use the parents version of describe or the child so let's take our Circle use the describe method the result it is a circle with an area of 78.5 I should really add cim squar after that cm squared this is called method overwriting if a child child shares a similar method with a parent you'll use the child's version and not the parents this is Method overwriting if you would like to extend the functionality of a method from a parent you can use the super function not only do I want to use the describe method of the child I would also like to use the describe method of the parent So within this function we will use the super function access the describe method of the parent what we're doing is extending the functionality of the describe method it is a circle with an area of 78.5 cm squared the circle is red and it's filled or you can change up the order let's use the parent classes describe method and extend the functionality with our own print statement it is red and filled it is a circle with an area of 78.5 cm squ let's finish this with the square and triangle classes I'll copy what we have for the described method within the circle class but we'll make a different calculation describe the square it is a square with an area of take self. width times self. width the height and the width are going to be the same if it's a square then describe our triangle it is a triangle with an area of width time height we have a height in this case divid two we've already described our Circle let's describe our Square it is a square with an area of 36 CM squar it is blue and not filled let's describe our triangle it is a triangle with an area of 28.0 cm squ it is yellow and filled all right everybody that is the super function it's used in a child class to call the methods from a parent class also known as the super class it allows you to extend the functionality of the inherited methods within a child class you could use it within a Constructor to assign any attributes that all of its siblings have in common such as color or if that shape is filled when used within any other method you can extend the fun functionality of that method not only are we printing this message from the parent we're tacking on another print statement before that and well everybody that is the super function in Python what is going on everybody so today I got to talk about polymorphism in Python polymorphism is a programming concept it's a Greek word that means to have many forms or faces poly means many morph means form in programming an object can take one of many forms there's two ways to achieve polymorphism one is through inheritance an object could be treated of the same type as a parent class there's also duck typing which we'll talk about in the next Topic in this video we're more focused on inheritance what we'll do in this video is create a class of shape we'll write pass as a placeholder we will create a class of circle which will inherit from shape again writing pass class class Square inherits from shape class triangle which inherits from shape if I was to create a circle object Circle equals Circle our Circle identifies as a circle and since our Circle class inherits from the shape class our circle is also considered a shape it has two forms it's a circle and it's a shape but our Circle isn't a square or a triangle that could also apply to our Square class our square is a square our square is also considered a shape but our square is not a circle or a triangle those are two possible forms for our Square it's a square and a shape so let's say we would like to create a list of shapes what do they all have in common well they're all shapes a descriptive name for this list would be shapes equals an empty list I will instantiate a circle object a square object and a triangle object our circle is a circle and a shape our square is a square and a shape our triangle is a triangle and a shape each of these objects has two forms or two faces let's fill in some of these classes let's say that with our shape class we will define an area method Define area I'm going to turn this into an abstract method I'll just write pass to work with abstract classes we need to import that from ABC import Capital ABC as well as abstract method preceding the area method I will add a decorator of abstract method our circle square and triangle classes they're all considered shapes they inherit from this class we need to Define an area method for each since they're all considered a shape every shape has an area with our class of circle let's define a Constructor Define in nit we will pass in one argument a radius what is the radius of the circle assign an attribute of radius equals the radius we receive let's do this with square Define in nit one parameter the length of a side self. side equals side then triangle Define init we have two parameters base and height self. Bas equals base self. height equals height all right now let's finish defining these area methods for each class we will return 3.14 time self. rius to the power of two so given a radius that's how to calculate the area of a circle then with our Square Define area we will return self. side to the power of two then with our triangle Define area Return self. base times self. height time 0.5 now we have to pass in some arguments for our Circle we need a radius I'll pick four for the square the length of a side will be five then our triangle the base will be six the height will be seven we're going to write a loop to iterate through our shapes for every shape in shapes then we're going to print for every shape called the area method and that would give me these numbers if you would like you can format the output I'll just use an F string I'll add CM squar much better what if we were to create a class that's completely unrelated to shapes I will create a class of pizza I will Define a Constructor to construct a pizza object we need a topping and a radius what is the radius of the pizza self. topping equals topping self. rius equals radius within my list of shapes I'll add a pizza object but I have to pass in a topping such as pepperoni and what is the radius of the pizza let's say 15 cm so our pizza our Pizza class doesn't have an area method here's what happens when I run this we get an attribute error Pizza object has no attribute area our pizza object is considered a pizza but it is not considered a shape it does not inherit from the shape class at the top here you know what a pizza is circular it could be considered a circle so how about this let's take the pizza class it will inherit from the circle class and within our Circle class we're already assigning the radius to the radius attribute so instead of doing that here within the Constructor for our pizza class let's call the super Constructor super which refers to the parent use its Constructor then passing the radius we receive let's see if this works now that does here is the area of our pizza our pizza is considered a pizza it inherits from the circle class so it's also considered a circle and our Circle class inherits from the shape class our pizza has three forms our pizza is considered a pizza it's also considered a circle and it's also considered a shape it would make sense for it to fit into this list of shapes because our pizza also identifies as a shape so that's polymorphism everybody it's a Greek word meaning to have many forms or faces poly meaning many morph meaning form in Python there's two ways to achieve polymorphism one through inheritance an object could be treated of the same type as a parent and there's also duck typing which we'll discuss more in the next topic stay tuned for that and well everybody that's polymorphism in Python hey everybody so today I got to talk about duck typing in Python duck typing is another way to achieve polymorphism besides using inheritance objects can be treated as if they're type as long as they meet the minimum necessary attributes and methods required of them it follows this adage if it looks like a duck and quacks like a duck it must be a duck as long as an object resembles another it could also be treated of that type so in this example let's create a class of animal we will have a class attribute of a live if you're an animal you will have an attribute of aive you're a living creature let's create a class of dog the dog class will inherit from the animal class they will inherit the alive attribute let's also Define a speak method if you're a dog you gain the ability to speak we will print woof then we'll create a cat class class cat inherits from animal for the speak method we will print meow let's create a list of animals what do these two classes have in common they both could be considered animals let's create a list of animals we will construct a dog object and a cat object if I was to write a for Loop for every animal in my list of animals have each animal use its speak method which will result in the dog going woof the cat going meow they're both speaking what if we add a class that has nothing to do with animals like class car cars will have a horn method that's how they speak when you honk the horn you will print honk within my list of animals let's create a car object it really doesn't belong in here but let's see what happens we have an attribute error car object has no attribute speak our car object doesn't have the minimum necessary attributes and methods when iterating through this list of animals we're calling each animal speak method which our car object doesn't have but it does have a horn method so what if we rename our horn method as speak maybe it's an AI car or something something well this would work the dog goes woof the cat goes meow the car goes honk so our car object it quacks like a duck we could consider it a duck it has the minimum necessary methods to be considered an animal animals inherit this alive attribute let's utilize that after the animal speaks let's print their Al live attribute print my animals Al live attribute my car object doesn't have that attribute we get an attribute error car object has no attribute alive but if I was to add that attribute alive equals false we have true for the dog it's living true for the cat it's living but false for the car it's not living it's not a living creature my car meets the minimum necessary requirements to be considered an animal if I were to set this to be alive well then it would be a living car kind of like the movie Cars so with python duct typing is another way to achieve polymorphism besides using inheritance as long as an object has the minimum necessary attributes and methods you could treat it as a different type of object if it looks like a duck and quacks like a duck it must be a duck and well everybody that is duck typing in Python hey what's going on everybody so in today's video I'm going to explain aggregation in Python aggregation represents a relationship where one object contains references to one or more independent objects one object acts as a container the whole which can contain other objects the parts so what we'll do in this demonstration is create a object that's going to act as a container we'll create a class of library for now a right pass now a library can contain books we will create a class of book we'll be creating book objects which we will add to our library object the library object is going to act as the whole the container the books are the independent Parts a library can exist without its books and the books can exist without the library that's the main difference between aggregation and composition these classes are independent of one another they can exist without each other with our class of book we'll need a Constructor we will Define our Constructor if we create a book we need a title and an author we will Define a title attribute equals the title that we receive and self . author equals the author that we receive that's all we need for the book class now with the library class we will also need a Constructor Define init for our library we need a name for the library for example the New York Public Library self. name equals the name that we receive let's construct our library object first Library equals Li Library we need to pass in a name for this Library let's say New York Public Library so this should run with no problems then we'll create a few books let's say book one equals called the book Constructor we have to pass in a title and an author so pick a few books I will pick Harry Potter Happy Harry Harry Potter and the philosopher stone but I don't want to type the whole title let's just say Harry Potter do dot dot the author of this book is JK rolling okay let's create another book book two equals book for my next book I'll pick the Hobbit the author is J R R our token then book three equals book we need a title and an author I will pick the color of Magic by Terry pratchet we have no problems when running this our library and our books can exist without each other our books are independent so now now where aggregation comes in our library object will contain our book objects one way in which we can handle this is that within the Constructor for our library let's create an attribute of books this will be an empty list we'll need a way to add these books to our list of books we will Define a method of add book but we have to pass in a book object when we call this method we're going to access self. books it's a list list have a builtin append method we will append our book to our list of books let's see if this at least runs we're going to take our library call the add book method that we defined then pass in our book object of book one then let's let's do this with book two and book three and this is run with no problems our books can exist independently of our library our library object is just containing them it's housing these books now if I would like to print all the books in my library I could create a method to do that let's define a method of list books there will be no parameters besid self I'm going to return a list comprehension for every book in self. books remember that books is a list for every book in books Let's return an F string where we display the book's title and the book's author display book. tile the word by bookauthor okay let's see if this works first I'm going to print the library's name print libraryname New York Public Library then I'm going to print access the library objects list books method and here is my list of books although I'm going to reformat this so it looks better I'll use a for Loop for every book in Access our library objects list books method this will return a list we can iterate through it for every book in the list of books print each book all right here is our libraries name and each book in our list of books all right everybody so that's agre ation it represents a relationship where one object the whole contains references to one or more independent objects the books they can exist without one another and well everybody that is aggregation in Python all right everybody so today I got to talk about composition in python as we've discussed in the previous topic aggregation is a relationship where one object contains references to other independent objects they have a has a relationship composition on the other hand is when the composed object directly owns its components which cannot exist independently they have a owns a relationship aggregation has things composition owns things kind of like you're renting or you're owning something in this example we'll create three classes a class of engine a class of wheel and the composed object is going to be Class Car within our car class we will construct some engine and wheel objects we'll begin with our engine class we'll need a Constructor we'll Define that Define in knit let's say that with an engine we need a horsepower what is the power of the engine self. horsepower attribute equals the horsep power that we receive with our class of wheel we need a Constructor Define init let's add a size attribute what is the size of the wheel self. size equal size okay now with our car object now within our car class we need a Constructor we will need a make model the horsepower of the engine and size we'll say wheel size remember that you can rename parameters to something different we will assign these attributes self. make equals make self. model equals model here's where composition comes in we will define an attribute of engine then call the engine Constructor we have one argument to pass in Horsepower we will pass in the horsepower that we receive to the engine Constructor then we have to set up our wheels self. wheels equals now to construct a single wheel object we would call the wheel Constructor then pass in the wheel size however car have four wheels we don't want just one wheel so what we could do is write a list comprehension for every wheel in range four to iterate four times let's call the wheel Constructor and pass in our wheel size this list comprehension will create four wheel objects for us the reason that this is considered composition we're creating engine and wheel objects inside of this class car our class car owns an engine and owns four wheels we're not creating these objects outside of the car class let's create a car object car equals car we need a make model horsepower for the engine and wheel size so for my car let's say Ford Mustang for the horsepower I'll make up something 500 for the wheel size 18 in now just to make this more explicit I'm going to use keyword arguments but you don't have to so make equals Ford Model equals Mustang horsepower = 500 wheel size equal 18 let's create a method to display our car I would like the details Define display car no parameters let's return an F string let's begin with the make and model those will be easy display self. make and self. model let's take our car object use the display car method then I got to print it I forgot because we're returning a a string we're not printing it directly we have a Ford Mustang okay let's display the horsepower there's one additional step we are accessing self this car that we're creating but now we need the engine let's access the engine attribute and now with our engine our engine has an attribute of horsepower we'll use the attribute accessor that dot horsepower 500 I'll add HP meaning horsepower all right now for the wheels I'll add another placeholder access self access our Wheels now our Wheels it's a list I don't need all four wheels I just need one if I was to take my list then access the size this is what it'll give me list object has no attribute size so we need to access one of the elements of our list of Wheels let's just say the first wheels at index0 then give me the size 18 and that's going to be inches all right then let's create a second car object before we finish we have car 1 Car 2 equals car we need a make model horsepower for the engine and wheel size for the Wheels I will pick a Chevrolet Corvette and I'm just going to make up some numbers the horsepower is 670 and the wheel size is 19 let's display Car 2 Car 2 called the display car method we have a Chevy Corvette with horsepower of 670 the wheel size is 19 in so our car class it owns some objects it owns an engine and it owns four wheels that's why composition is different from aggregation if I were to delete these two cars this engine and the four wheels would stop existing whereas in our library example in the last video if I was to delete the library object the books would still exist all right everybody so that's composition it's where a composed object our car directly owns its components our car owns an engine and it own phones for Wheels we're creating them within the class and well everybody that's composition in Python hey what's going on everybody so in today's video I got to talk about nested classes in Python a nested class is a class defined inside of another class this has a few benefits we can logically group classes that are closely related we can encapsulate private details that aren't relevant outside of the outer class and also it helps keep our namespace clean it reduces the possibility of naming conflicts so for example let's say we have two classes both named employee within this class I'm just going to print something this is the first class then let's copy our employee class paste it again this is the second class we have a naming conflict we have two classes with the same name if I were to run this program we will execute both this is the first class this is the second class it is fairly noticeable that we have two classes with the same name but with python we do a lot of importing and exporting of large files we may not realize there's a name conflict one concept that'll help us avoid naming conflicts is the use of nested classes let's say we have employees for a company and another set of employees for a nonprofit organization I could write something like this we'll create a class of company within this class of company we will have an in class of employee with our second employee class we will create an outer class of nonprofit this is perfectly fine we can have two classes with the same name as long as they're within different Scopes these two employee classes might have different attributes depending on who they work for if they work for a company they might might have one set of attributes if they work for a nonprofit they might have a different set of attributes so by using nested classes this helps keep the namespace clean we can reuse this employee class because they have different Scopes now what we're going to do in this example what we'll do in this example is create some employee objects that belong to a company object as a placeholder for now I'll write pass within the employee class with our class of company let's define a Constructor do pay attention to the indentation we are within the company class but not the employee class this Constructor is for the company the company object we're going to create if we construct a company object we need a company name such as the Crusty Crab I will assign self. company name equals the company name that we receive we are also going to declare an attribute of employees this attribute will be an empty list we will append employee objects to our list of employees then we will create a method to add employee we will need a name meaning name of the employee and a position what's their job for now I'll write pass we'll get back to this later and I will Define a method of list employees and again I'll write pass okay let's be sure that our company name works I'm going to create a company object company equals company but I have to pass in a company name I will pick the Crusty Crab then just to be sure that this works I will display our company's company name attribute that would give me the Crusty Crab so we know that that works within our employe class let's define a Constructor Define innit we need a name and a position self. name equals name self.pos equals position let's create one more method Define get details we will return the details of an employee all we're going to do is return an FST string add two placeholders we will return self. name and self.pos all right now within our ad employee method we will construct a new employee object equals now if if we're going to access this inner class of employee we're going to prefix self self meaning this company object that we're currently working with we need the class of employee then we'll call The Constructor but we have to pass in a name and a position when we receive a name and a position we will pass that to the employee Constructor once we have our new employee object we're going to take our list of employees self. employees use the append method of lists then add our object of new employee to this empty list let's create a few employee objects we'll take our company use the add employee method that we have created we need a name and a position I will pick Eugene for Eugene Krabs his position is that he is the manager let's create two more take our company object use the ad employee method that we have defined I will pass in a name of this employee as SpongeBob his position is that he is a cook then we have Squidward company. add employee method first name Squidward his position is that he is a cashier so this should run with no problem s now I would like to list all of the employees at this company we'll need to rely on this get details method so when we list our employees we will return a list comprehension for every employee in self. employees this is an attribute it's a list of employee objects it is iterable take each employee that we're iterating through call the get details method and return it now if I was to take my company then call the list employees method whoops I forgot to print it we will print each employees name and their position however I think this would look better if we were to use a for Loop for every employee in take our company call the list employees method during each iteration we will print each employee we have Eugene that's Mr Krabs the manager SpongeBob The Cook and Squidward the cashier to demonstrate the reusability of classes let's create a second company object that has its own employees let's rename company as company one then we will create Company 2 Company 2 equals called the company Constructor my second company will be the Chum Bucket we'll take Company 2 then add two employees company 2. add employee we will pick shelden Sheldon is the manager company 2. add employee Karen will be the assistant for every employee in Company 2 list the employees during each iteration print the current employee we have Sheldon that's Plankton's first name he's the manager and Karen is his assistant all right everybody so those are nested classes it's a class defined inside of another class you have an inner class and an outer Class A few of the benefits is that we can logically group classes that are closely related such as having employee objects within a company object we can encapsulate private details that aren't relevant outside of the other class we may have no need to create employee objects outside of this class and by using nested classes it helps keep the name space clean it reduces the possibility of naming conflicts with another type of organization we could create another inner employee class and well everybody those are nested classes in Python hey what's going on everybody today I'm going to talk about static meth methods in Python a static method is a method that belongs to a class rather than any object from that class any instance instance methods we're already familiar with them they are methods that belong to individual objects created from that class they're best for operations on instances of that class any objects whereas static methods they're best for utility functions within a class that do not need access to class data I'll demonstrate the differences between an instance method and a static method we'll Begin by creating a class of employee we'll need a Constructor let's define that to create an employee object we'll need a name and a job position we will assign self. name equals name self. position equals position we will create an instance method of get info we will return employee info we will return an F string where we will display self. name equals self.pos get info is an instance method each object that we create from this class will have their own get info method to return the information on that object object the object's name and the object's position now we'll create a static method to create a static method we need a decorator of static method static methods are best for General utility functions within a class we'll Define a method to check to see if a job a position is valid which we will name is valid position so static methods they don't have self as the first argument we're not working with any objects created from this class to check to see if a position is valid we will pass in a job position which I will name as position I will create a list of valid positions let's assume that our company is the Crusty Crab what are some valid positions a manager is a valid position a cashier a cook then let's say a janitor then we will return we'll use a membership operator check if position that we receive is in our list of valid positions what we have done is that we have created a static method we don't need to rely on any objects to use this method for example to use a static method we will use the name of the class rather than any object that we create from this class such as this we don't need to do that we type the class name followed by the static method is valid position then I did set this up to accept one argument let's check to see if a cook is is a valid position then I do need to print this what is the output a cook is a valid position what about a rocket scientist that would probably be sy's job that is false a rocket scientist is not a valid position at the K crusty crab this is a static method it belongs to the class not any object created from that class now let's let's create a few employee objects let's say employee 1 equals a new employee we have to pass in a name and a job Eugene will be the first name that's Mr Krabs he will be a manager employee 2 equals employee Squidward will be a cashier employee 3 equals employee employee 3 will be SpongeBob SpongeBob will be a cook to call an instance method we have to access one of the instances of the class in order to use it if I want to check the info on employee 1 I will access that object that instance use the get info method then I need to print it take employee one get the info Eugene is the manager let's do this with employee 2 and employee 3 Eugene Mr Krabs is the manager Squidward is the cashier SpongeBob is the cook for an instance method you access an object then call the instance method with the static method you only need to access that class you don't even need to create any objects from that class it's a general utility method all right everybody those are static methods they're a method that belongs to a class rather than any objects created from that class they're usually used for General utility functions that do not need access to class data and well everybody those are static methods in Python hey what's going on people so today I got to talk about class methods in Python a class method allow operations related to the class itself they take CLS as the first parameter whereas instance methods will take self self refers to any object created from that class CLS meaning class refers to the class not any objects here's an example we will create a class of student we'll need a Constructor to construct some student objects all students will have a name and a GP self. name equals name self. GPA equals GPA we will also create a class variable for this demonstration of count we will count how many students we create whenever we construct a student object we will access the class of student take our count variable increment it by one whenever we create a student object object increase count by one I will create an instance method of get info instance methods have self as the first parameter we're referring to the object we're currently working with I will return an F string where we will display the students name and their GPA self. name self. GPA I'll add a comment that this is an instance method Now to create a class method to work with class data we will declare a class method with a class method decorator class method what we're going to do is Def find a method to get the count the class variable of count this method will be called get count rather than self as the first parameter we'll be working with a class CLS meaning class I will return an F string total number of students add a placeholder CLS count Let's test this to call a class method you take the name of the class followed by the class method get count and then then we do need to print this what is the count of my current students total number of students is zero let's create a few student objects we will create student one equals called the student Constructor we have to pass in a name and a GPA let's say that the name is SpongeBob SpongeBob has a GPA of 3.2 we'll create two more students student two student three student two will be Patrick Patrick has a 2.0 then Sandy Sandy Smart in fact she's a genius she has a perfect 4.0 now let's count the number of students total number of students is three when we call this class method we can access or modify class data this class variable of count rather than using self we use CLS for the class let's create one more class method this time I'll calculate the total GPA of all my students we'll need a class variable to hold that data let's say total GPA equals z whenever we construct a student object we will access our class of student get the total GPA then add plus equals this student's GPA that we have just created basically speaking the total GPA this variable is going to accumulate all of the GPA of every student and store it as a sum to find the average we're going to divide it by the count the number of students we'll do that within a class method to create a class method again we need to use the class method decorator I will Define a method of get average GPA the first parameter is CLS for class I will check if CLS count the count variable of my class is equal to zero that means if we have no students if that's the case if there's no students we're going to return zero because otherwise we're going to divide by zero and we'll get an error else we're going to return an F string follow this formula we're going to take the total GPA of my class class. total GPA divided by class. count the number students we have that's how to calculate the average GPA after getting the count of the number students to access a class method we take the name of the class student call the class method get average GPA then I will print it total number of students is three the average GPA is 3.06 repeating after calculating the average I'm going to add a format specifier of 2f just around to two decimal places and I'll add average GPA colon space then we'll calculate the average all right everybody those are class methods instance methods are best for operations on instances of the class any objects static methods are best for General utility functions which do not need access to class data class methods are best used when we're working with class level data or we require access to the class itself such as when we're working with class variables rather than using self as the first parameter we're going to use CLS meaning class and well everybody those are class methods in Python yo what's going on people so today I'm going to explain magic methods in Python magic methods are also known as Dunder methods meaning double underscore you typically find these within classes we're already familiar with one of them are Dunder init method we have double underscores on the left and double underscores on the right but there are others I'll cover a few of the more beginner friendly ones so what these methods do is that they're automatically called by using some of pythons built in operations such as printing an object seeing if two objects are equal greater than or less than when we use many of Python's builtin operations with objects we can Define and customize the behavior of those objects so in this demonstration I'm going to create a class of book we will construct some book objects we will Define a magic method a Dunder method of init to initialize these objects for a book we need a title an author and the number of pages we'll say num Pages self. tile equals title self. author equals author self. number of pages equals number of pages when we call the class of book we Are automatically calling Dunder init so let's create a book object book one equals book we need a title an author and number of pages so since we're dealing with this topic of magic methods I'll pick some fantasy related books for my first book I'll pick the Hobbit that's the title the author is JRR token the number of pages is 310 so for my next book book two I will pick Harry Potter and the philosopher stone the author is JK Rowling the number of pages is 223 then we have book three for my third book I will pick The Lion the Witch and the Wardrobe the author is CS Lewis the number of pages is 172 okay here are my three book objects when we call the class of book and pass an arguments we will call the dunder init method it's a magic method it's automatically called behind the scenes within this magic method we can Define and customize the behavior of objects and in this example we're just assigning the attributes of title author and number of pages that is one builtin operation of python what would happen if I was to print book one directly to the console here's what happens well we're given a memory address here's book two and book three well we can customize this Behavior we will use the dunder string method double underscore St Str meaning string double underscore again we have one parameter of self instead of returning a memory address we can customize this behavior let's instead return an FST string I'll add two placeholders we will display self. tile the title of the book by self. author and I'll place the title within single quotes now let's print book one we have The Hobbit by JRR tolken let's print book two Harry Potter and the philosopher stone by JK Rowling and book three The Lion the Witch and the Wardrobe by CS Lewis so that is thunder string we can return a string represent a of the object when we print it directly to the console here's another Dunder method we can check to see if two objects are equal I will print is book one equal to book two that gives me false if they were to have the same title the same author and the same number of pages then python would say they're not equal still so let's customize this Behavior we will Define a method of Dunder equals which is just EQ for parameters we have self the first book we're examining in this case book one and other other means the other book we're examining two objects for equality to do that we'll see if the title of two books and the author is the same we'll disregard the number of pages you can have two different versions of the same book they might have different font sizes or the dimensions of the physical Pages might be different so we will return a Boolean value we will examine if self that's the first book is the title attribute equal to our other books title and is the author of the first book self. author equal to our other books author if I were to run this we get false book one does not equal book two but if they have the same title I'm going to replace these and the same author then they would be equal and we'll disregard the number of pages let's say that with this version of The Hobbit they're using a smaller font size so there's less Pages we're using under equals to compare if two objects are equal what if I was to print book two is less than book three like what does that even mean and I'm just going to get rid of these two lines type error less than is not supported between instances of book and book so we can't use less than on two objects but we can customize that behavior by using Dunder less than which is just LT we're examining one book and the other book self and other let's compare the number of pages we'll compare if the pages of book two is less than book three we will return a Boolean value is self. number of pages less than other. number of pages so now this should not give us an error book two does not have less Pages than book three another would be greater then I'll just copy what we have Dunder GT for greater than for our first book of self is it greater than the number of pages of the other book well that's true the number of pages of book two is greater than book three let's let's use Dunder add to add the pages of two books together what would happen if I were to add two books together book two plus book three well we get a type error unsupported operand for book and book well to customize the behavior of addition we will Define Dunder add we have self and other for the other object let's add the pages together of two books maybe we need a summer reading list and we would like to see what the total number of pages is I will return self. number of pages attribute plus our other books number of pages that would give me 395 that's 223 + 172 heck I'll even put this within an F string CU why not then I will add the word Pages 395 Pages within an object we can search for a keyword within one of the attributes so let's find the word the lion within book three to do that I would write a statement like this Lion in book 3 Type error argument of type book is not iterable we will Define Define Dunder contains besid self we will pass in a keyword a keyword that we're searching for I will return then we'll use the in membership operator is our keyword in self. tile I'm looking for the word lion that's going to return true if lion is in the title of this book or is our keyword in self. author maybe we're searching for an author let's try that again that returns true lion is in book three however lion is not within book one that's false is rolling in book two that's the author that is true is rolling in book three that is false that is thunder contains we are searching for a keyword in an object now we could search for a key given an object for book one we'll use the index operator and look up an attribute let's get the title of book one the default behavior is that we get a type error book object is not subscriptable so to customize this Behavior we will use Dunder get item besides self we have one parameter of key we're accessing book attributes by indexing with this object return the value at this key what's that attribute we will check if our key that we receive is equal to title which it is in this case we will return self. tile What's the title of the book so that would give me The Hobbit here's book two and book three what if the key is author none we didn't set that up yet if key is equal to author then return self. author the author of book three is CS Lewis two is JK rolling book one is JRR tolken what about number of pages num Pages well we're not set up for that yet I'm going to turn this into an else if statement else if key is equal to num Pages then we will return self. num Pages the number of pages in book one is 310 book two is 223 book three is 172 what if there is no key otherwise if there is no matching key I'll add an else statement let's return an F string key placeholder R key that we pass in as an argument was not found what do books not have well they don't have audio I guess unless it's an audio book is there a key of audio in book three there is not key audio was not found and I'll place that within single quotes much better all right everybody so those are magic methods also known as Thunder methods meaning double underscore they are automatic called by many of Python's builtin operations they allow developers to define or customize the behavior of objects when we use those builtin operations and well everybody those are magic methods in Python hey everybody so in today's video I got to talk about the property decorator in Python the property decorator allows us to define a method as a property we can access it like it's an attribute one of the benefits is that when Reading Writing or deleting attributes we can add additional Logic the property decorator gives us a getter method to read a Setter method to write and a deleter method to delete when working with attributes in this example we'll create a class of rectangle we need a Constructor let's define that when constructing a rectangle object we will need a width and a height we will assign the attribute of width equal to the width that we received when constructing this object self. height equals height let's construct a rectangle object rectangle equals rectangle we need to pass in a width and a height then I will print my rectangle's width rectangle. width and the height rectangle. height with my rectangle the width is three the height is four using the property decorator when reading these attributes of width or height I can write some additional logic let's say that when accessing the width or the height I would like to display one digit after the decimal then add centimeters here's one way in which I can do that for each of these attributes I'm going to create a method we will Define a method of width no parameters beside self for now I'll write pass and Define he height preceding each of these methods I will use the property decorator so at property now when accessing the width or the height will be returned with whatever is Within These methods of width and height but there's one change we're going to make to these attributes we'll set these attributes to be private prefix each of these attributes with an underscore this tells you and other developers that these attributes they're meant to be protected they're internal we shouldn't access the width or the height directly outside of this class technically we could I will access the internal version of width and height we get three and four but we do have a warning access to a protected member width of a class that applies to height as well our width and our height are only meant to be used inside of this class if we need to get the width and the height we will do so through these getter methods provided by the property decorator so when accessing the width let's return an F string I will access self. private width add a format specifier to display one digit after the decimal 1f followed by cenm we'll do this with the height as well we will return self. private height so now when we access the width or the height we will do so using these getter methods if I access these private width and height attributes instead again they will be three and four it's kind of like their raw these attributes are meant to be used internally inside of the class so that's the point of a getter method we can add additional logic when reading one of these attributes when we Tred to get them we can also add Setter methods if we would like to set or write these attributes here's how let's take our width we will create a decorator of at width. Setter when attempting to set the width we will do so using this method we will Define our method name of width we will have one parameter a new width we don't want the parameter name to be the same as the method name that's why we're naming it something different when setting the width let's check to see if the new width is greater than zero if so we will take self. private width equals our new width else let's print something let's print width must be greater than zero and let's do this with the height height. Setter Define height pass in a new height if our new height is greater than zero assign self. private height equals the new height else print height must be greater than zero before printing the width and the height let's take our rectangle width set it to be zero then see what happen s well we get that message width must be greater than zero if I were to set width to be five well that does work our width is now five let's change the height rectangle. height I will set this to be Nega 1 height must be greater than zero and the height hasn't changed what about six six does work when using these Setter methods we can add additional logic when writing or changing one of these attributes these are Setter methods now if you need to delete an attribute here's how there is a delete keyword we will delete our rectangle's width and delete our rectangle's height in this series we really won't be using the delete keyword but you should still know that it exists so we will create a deleter method at take one of the attributes in this example with we will create a deleter method the method name will be width the name of the attribute there will be no parameters besides self we will delete self. private width then let's print something just to confirm that this was deleted width has been deleted same thing applies to height take the attribute of height Define height delete private height height has been deleted when deleting our width or our height we get that confirmation message width has been deleted and height has been deleted all right everybody so that is the property decorator we can define a method as a property meaning it can be accessed as if it was an attribute one of the benefits is that we can add additional logic when we read write or delete attributes the property decorator gives us a getter Setter and deleter method getter methods to read Setter methods to write and deleter methods to delete and well everybody that is the property decorator in Python