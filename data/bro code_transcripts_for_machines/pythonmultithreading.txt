yo what's going on everybody it's bro hope you're doing well and in this video i'm going to explain to multithreading in python so sit back relax and enjoy the show think of a thread as a flow of execution like a river and each thread can carry out its own separate order of instructions if we use this process of multithreading we can have our program run different parts of its program at different times they all run concurrently but not truly in parallel that is a concept for later referred to as multiprocessing so with reds they each take a turn running to achieve concurrency this is due to a notorious feature known as the gil the global interpreter lock only one thread can be running at one time but they can all take turns when one thread is idle so this allows one thread to hold control of the python interpreter at any one time so they run concurrently but not truly in parallel which is what we do with multiprocessing now programs and tasks can be divided into two different categories they can be cpu bound that is a program or a task that spends most of its time waiting for internal events such as a task that is cpu intensive it is better to use multiprocessing for tasks that are cpu bound now tasks that are io bound means that the program will spend most of its time waiting for external events such as waiting for user input or if you're doing activities like web scraping you do a lot of sitting around so with i o bound tasks it's better to use multithreading because we can have multiple threads running concurrently but not truly in parallel like what we do with multiprocessing after importing the threading module we can count the number of threads that are currently running in the background whenever we run a program we have one thread that is running that is in charge of executing our program and we can print the active count of threads running in our program using the active count function of the threading module so this will print one we have one thread that is running and we can print a list of all the threads that are running by using the enumerate function so the one thread that is in charge of running our program is referred to as the main thread by using this concept of multithreading we can have more than one thread running concurrently not truly in parallel all the threads will take turns while one of them is idle so we can have more than one thread running more than just the main thread which is in charge of running the main body of our program so while our main thread is in charge of running the main body of our program we can have another thread that's in charge of a separate part of it maybe like a countdown timer or something so one good example take that quiz game that we made some number of videos ago while we were waiting for user input which is a i o bound task we could have had a countdown timer going like you only have so many seconds to answer this question we could have had one thread in charge of waiting for user input and another thread in charge of the countdown timer so that's an example of multithreading we had two threads running concurrently and what we'll be doing in this video is creating a program that involves multithreading we can have different threads in charge of different parts of our program and they can all run concurrently they'll all take turns while one of them is idle so let's say that we're running late for school or work in the morning and we have three different tasks that we need to complete before we can leave for school or work so think of three different things you do in the morning such as maybe eat breakfast some people drink coffee or maybe a beverage of your choice so drink coffee and some people like me they like to do their homework last minute so i'll say study before i leave for work or school in the morning so what we'll do in each of these functions each of these functions should take some amount of time to complete so we can have our main thread sleep for a given number of seconds using the sleep function time dot sleep and let's say that in order for me to eat breakfast this task will take me three seconds let's just pretend that instead of minutes this will be in seconds so drink coffee will take me four seconds and study will take me five seconds then when we finish sleeping let's print a confirmation message let's say you eat breakfast as in you finish eating breakfast with drink coffee you drink coffee and with study you finish studying now each of these tasks are i o bound they're going to be spending a lot of time just waiting around for external events they're waiting for the sleep function to expire before they can finish their task so we're going to have all of these three functions run on our main thread and we'll see how long it takes for us to complete our morning ritual these three tasks so let's call these three functions within our main thread so let's call the eat breakfast function first followed by drink coffee and then study in that order so this program is going to take approximately let's see 12 seconds to complete so there's going to be a pause for a second you eat breakfast then followed by you drink coffee and then study you finished studying so this program took about 12 seconds overall so if this were realistic what we would have done is we would sit down and eat breakfast for three minutes well three seconds in this case and then once we finish eating breakfast only then are we allowed to drink our coffee and once we finish our coffee only then can we study so we completed these tasks sequentially and not concurrently for us to move down to the next function we need to complete the previous functions because we're doing this in order but realistically us human beings we would probably eat breakfast drink coffee and study together because we can multitask and we can complete these three functions in less time and that's kind of the same process as multithreading we can have these three separate functions running concurrently as if we're multitasking we're eating breakfast drinking coffee and studying all at once now currently we have one thread that is in charge of these three separate functions what we could do is that we can create three additional threads each thread will be in charge of each task and then we'll have our main thread running in the background that will complete the rest of the program so this is how to create an additional thread let's say that x equals threading dot thread we need to pass in a target target equals and then the name of the function so let's say thread x will be in charge of eating breakfast and then you can pass in arguments too if your function has parameters by typing args and then you pass in a tuple so let's say you have one argument to pass in you'll type your argument followed by a comma but we don't have any arguments in this example but you'll need to be sure to enter them in if you do have any okay then to begin this thread you type the name of the thread in this case x dot start so we now have an additional thread and this thread is in charge of eating breakfast now let's create another thread to drink coffee and we'll call this y and the target will be drink coffee and lastly we have a thread in charge of studying and this will be z and the target is our study function okay now let's see how long it takes for us to complete our program oh and be sure to comment out these function calls within the main thread because we don't want the main thread in charge of those anymore okay now we can run the program so we have four threads running this time you eat breakfast you drink coffee you finish studying so this program took approximately five seconds to finish and the reason that this program took five seconds instead of twelve is because before our main thread was in charge of running these tasks sequentially in order but now since we have a thread dedicated to each task we can run them all concurrently instead of sequentially so that this program now took about five seconds to complete and you may have noticed too that the active count function as well as the enumerate function were called before threads 1 2 and 3 finished their respective tasks that's because the main thread is not going to wait around for these three threads to complete it has its own set of instructions to do so it is no longer in charge of these three functions the program is going to handle those three functions to our three threads and our main thread is going to continue its own set of instructions its job is to print the active count as well as call the enumerate function which it did and it finished its tasks before threads one two and three now one trick that you can do too is that you can use the time modules performance counter function and this function will return how long it takes our calling thread as in our main thread to finish its set of instructions so our main thread is not in charge of executing these three functions our main thread is in charge of creating three additional threads and then calling the active count function and the enumerate function as well as the performance counter function so our main thread will take approximately 0.075 seconds to complete and our three threads are still running in the background our main threads job its order of instructions is to create three additional threads and then immediately print whatever is returned via the active count function enumerate and then your performance counter so our main thread says that it finished its tasks in about .07 seconds but threads one through three were still trying to catch up that's why the main thread finished before are three additional threads and once all active threads have completed their tasks then your program will finish an exit there's also this concept called thread synchronization we can have a calling thread in this case our main thread wait around for another thread to finish before it can move on with its own instruction set so let's say we would like our main thread to wait around for thread one also known as x so we're going to use the join function of thread x and now our main thread has to wait around for thread x also known as thread 1 to finish before it can move on with its instruction set so let's do the same with y and z so now our main thread before it can move on with the rest of the program has to wait for all of these threads to synchronize and join and then and only then can it move on with the rest of its own instruction set so this time our program is going to look a little something like this you eat breakfast you drink coffee you finish studying so by the time we reach our active count these threads are already joined and synchronized they're no longer active when we enumerate over our active threads we only have our main thread and our main thread completed in about 5.1 seconds this time because it did a lot of waiting around it was waiting for threads x y and z to join and finish in conclusion a thread is a flow of execution like a separate order of instructions that a program can follow and when we run a program we always have at least one thread running initially and that is referred to as the main thread however if you have multiple threads using the concept of multithreading we can have multiple threads running concurrently but not truly in parallel which is what we'll cover during the video on multiprocessing this is due to a feature known as the gil the global interpreter lock which allows only one thread to hold control of the python interpreter at any one time and tasks can be either cpu bound or io bound a cpu bound task is a program or task that spends most of its time waiting for internal events such as a task that is cpu intensive and o bound tasks spend most of their time waiting for external events such as waiting around for user input or web scraping with i o bound tasks it's better to use multithreading with cpu bound tasks it's better to use multiprocessing well everybody that is a quick overview of multithreading i will post all of this code to the comments section down below and well yeah that's how to achieve multithreading using python