all right everybody depth first search depth first search is a search algorithm for traversing a tree or graph data structure we can break this down into three steps when navigating a graph we will pick a route and we will keep on going until we reach a dead end or a previously visited node if we do then we will move on to step three we will backtrack to the last node that has unvisited adjacent neighbors let's navigate this maze using a depth first search approach here's the entrance and here's the exit so the general concept of a death first search is that when we reach more than one adjacent neighbor we're just going to pick a route let's say we prefer right turns over left turns but you can really set any rule that you want when faced with more than one adjacent neighbor i'm just going to pick her out and keep on going and if we reach a dead end then we're just going to backtrack to a node that has some unvisited adjacent neighbors so there's no more place we can go so we're going to backtrack all the way back to this intersection right here this route is unvisited so we will continue going not backtracking yet there's no dead ends but now there is so we backtrack and keep on going so this is what this looks like sped up and we have reached the end let's use a depth first search approach to navigate this graph maybe we're at node a and we need to travel to i but we don't know where i is one way in which we can keep track of our position is to use a stack or in the case of recursion we can use a call stack whenever we visit a node we will push it onto the stack we can either travel to nodes b or d so we will mark d as visited and push this node onto the stack then we can either go to e or g let's go to g we'll push that onto the stack then h e and now we circle the round back to d but d is already marked as visited so we're going to backtrack to a node that has unvisited adjacent neighbors which is a so we will pop all of these nodes off of the stack all the way back to a which has unvisited adjacent neighbors and this time we will go down this route and push all of these nodes onto our stack and we have reached the end using a depth first search approach when simplified you pick a route you keep going when you reach a dead end or a node you already visited you backtrack to a node that has unvisited adjacent neighbors and you repeat steps one through two alright well let's implement this in code now and here we are people so i'm going to be using a graph that utilizes an adjacency matrix if you're using an adjacency list the code's just going to be a little bit different but the concept is really still the same i'm using code from the previous few videos we have a node class a graph class and in the previous videos we've already populated this graph with nodes and edges and then i'm just going to print this this is my adjacency matrix now within the graph class we're going to create a depth first search method and a helper method so this will be public void and we will name this depth first search and there will be one parameter an index of where we would like to begin to keep track of the nodes that we've already visited what some people like to do is that they will create a boolean within their node class such as boolean visited and they'll just mark it as false or true however it's very easy to forget to change these back to false when you exit the depth first search so what i'm going to do instead is create an array of booleans and the size will be equal to the length of the matrix so let's create a boolean array and i will name this visited equals new boolean and the size of our array is the length of our matrix then lastly we will implement a helper function so let's name this dfs helper and we will pass in our source and our boolean array visited then we just need to create this method private void dfs helper and there are two parameters int source and an array of booleans named visited you can either implement a depth first search iteratively using a stack or you can utilize the call stack if you use recursion in this example we're going to use recursion when we invoke this helper function we're going to check to see if the current node that we're on is visited or not and we can use an if statement if our visited array at index of source is equal to true or you could write the shorthand and just say if visited at index of source since this returns a boolean value if we've already visited this node we're going to return else we will mark this node as visited else visited at index of source equals true if you would like although this parts not necessary within my console i'm just going to print that we visited this node so within a print line statement i do have my nodes within an array list i'm just going to access the data of one of these nodes dot get source dot data plus equals visited this part technically isn't necessary but it's going to help with my demonstration in this example maybe we start at node a we need to find any adjacent neighbors if we're using an adjacency matrix we need to iterate over this row we can use a for loop for that so into i equals 0 we will continue this as long as i is less than our matrix at index of source dot length this equals the length of a row and then increment i by one we're checking to see if one of these elements is a one that means that's an adjacent neighbor that we can travel to using an if statement if matrix at indices of source and i source is the row that we're working with i is the column if this is equal to 1 then we will invoke the dfs helper method again so this is recursive we will pass in i as well as our boolean array named visited if we successfully search through an entire row outside of the for loop let's return and that's it so let's run this within my main class i will call the graphs depth first search method and pass in an index of a starting node so let's begin at zero we visit a first then b c d e let's try b which has an index of one b c d e a c which has an index of two c d e a b okay now pay attention to this this is a directed graph and we're beginning at d there's no place that we can go so we're stuck at d we only visit d and lastly we have e which has an index of four e a b c d alright everybody that is the depth first search algorithm you pick a route you keep going if you reach a dead end or an already visited node you backtrack to a previous node with unvisited adjacent neighbors if you would like a copy of this code i'll post this to the comment section down below don't forget to give this video a thumbs up leave random comment down below and subscribe if you'd like to become a fellow bro