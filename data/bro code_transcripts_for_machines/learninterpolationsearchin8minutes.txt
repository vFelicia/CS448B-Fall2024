all right what's going on everybody interpolation searches these are an improvement over binary searches that are best used for uniformly distributed data basically speaking we're going to make a guess and i'm saying that within quotes we're guessing where a value might be based on calculated probe results if our probe is incorrect our search area is narrowed and a new probe is calculated basically we're guessing where a value is going to be and return the index so using an interpolation search this has an average runtime complexity of big o of log log n and in a worst case scenario where our values within our collection increase exponentially this can have a runtime complexity of big o of n so to demonstrate this let's create an array of integers int array we'll name this array equals and assign this some numbers all uniformly distributed let's say the numbers one through nine all in order this would be i would say a best case scenario then let's find an index int index equals and we will invoke an interpolation search function so interpolation search we will pass in our ray and a value we would like to search for let's search for the number maybe eight okay then let's declare this function private static and interpolation search there are two parameters an array of integers and our value we are searching for i'm going to rename this parameter as value so it's more descriptive the first thing that we're going to do is calculate the upper bound and the lower bound of our searchable area so int high will be the higher bound of our searchable area and this will be our arrays length 1 and the lower bound is well the first index and low and i will set this equal to zero using a while loop we will continue probing the condition within our while loop is while our value is greater than or equal to our array at index of low the lower bound and our value is less than or equal to our array at index of higher bound and our sizable search area is going to shrink after each iteration so while our value is within the new searchable area keep on probing keep on searching i'm going to add another condition too low is less than or equal to high after each iteration our searchable area is going to shrink once our searchable area is zero elements well we can't search anymore so we might as well exit now here's the formula to calculate where our value is probably going to be and our guess will be referred to as our probe int probe equals and here's the formula high minus low times r value minus array at index of low our lower bound divided by array at index of high minus array at index of low just going to add low to the front of this and i'm just going to make this a little bit more readable for us here's the formula to calculate where our value is likely going to be it's a little complex to read this a few of the contributing factors are the size of our current searchable area high minus low so to begin with we have nine elements times the value we're searching for minus the value at the lower bound so eight minus one divided by the value at the higher bound minus the array at the lower bound then at the end we're just tacking on whatever our lower bound currently is so it's a complex formula all you have to do is just copy this so during each iteration i'm going to display our probe this is going to be essentially our guess and let's check to see if our probe is equal to our value so using an if statement let's check to see if array at index of probe is equal to our value that we're searching for if it is let's return our probe this is the correct index else if our guess our probe is incorrect we'll need to narrow down our search area so using an else if statement let's check to see if array at index of probe is less than our value if that's the case we will need to set the new lower bound low equals probe plus one else high equals probe minus one now here's the deal with these statements we're currently searching for the number eight if we guess our probe is at let's say five and our value is greater than this probe we can disregard this portion of the searchable area so we're moving the new lower limit the new lower bound to just after where our probe was six so this is the new searchable area and then we'll calculate a new probe based on this data if we're looking for let's say two and our probe says it's likely here at five well then since 2 is less than our probe we can disregard all of this data and this would be our new searchable area we would move the higher bound of our data down to just below our probe so that's kind of the idea so at the end if we do not find our value let's return negative one as a sentinel value so back within our main function let's check to see if the value returned does not equal negative one using if else statements if index does not equal negative one then let's print a message system.out.printline element found at index plus index else element not found okay so this should work let's run it so we are searching for a so this formula calculated that this value is likely at probe seven index seven zero one two three four five six seven and this was the first iteration of our while loop we were able to find our value eight on the first iteration so let's find a different value how about one element found at index zero that's the first element so interpolation searches work very well with uniformly distributed data these numbers are all increasing by one so this is a little too easy for our interpolation search it's guessing the likely index on the first try so let's create a more difficult data set so with our new data set let's say that we will start with one and then double the number of the previous element so one 2 4 8 16 32 64 128 256 512 and 1024 and let's search for the number what about 256 let's see how many probes this is going to take all right so here's the results we iterated our while loop five times we had five different guesses after the first guess this was not correct so we narrowed down our search area then we probed again this still wasn't the correct answer so we probed again add again and again until we got the right value so that's an interpolation search it's an improvement over a binary search that is best used for uniformly distributed data it guesses where a value might be based on a calculated probe result if the probe is incorrect the search area is narrowed and a new probe is calculated the interpolation search has an average runtime complexity of big o of log log n and a worst case runtime complexity of big o of n this would be if our values increase exponentially so yeah that is the interpolation search if you would like a copy of this code i'll post this to the comment section down below and well yeah that is the interpolation search in computer science