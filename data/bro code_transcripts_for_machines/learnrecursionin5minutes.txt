hello everybody today I'm going to attempt to explain recursion in just a few minutes think of recursion as just a function that calls itself from within it helps to visualize a complex problem into repeatable basic steps these steps can be solved more easily either iteratively using a for Loop or a while loop or recursively which we'll talk about momentarily let's say we have a complex task like walking we can break walking down in two basic steps such as taking a single step multiple times let's write a program that does this both iteratively and recursively and take a look at the differences if I were to create an iterative walk function let's define a function to walk but a user has to pass in a given amount of steps how many steps do you want to take then I'm going to invoke this function let's say 100 steps if I were to take an iterative approach within this function I could create a loop such as a for Loop for every step in my range one through steps plus one I'm going to print an F string you take step number step so that solves our problem we have taken a single step 100 times to simulate walking so that's an iterative approach We're looping within a function now let's take a recursive approach recursion involves a function calling itself from within at the end of our function I'm going to invoke the walk function again but I will pass in steps minus one let's change step two steps we're invoking this function from within it's creating a loop but we will include the function itself whereas in with iteration We're looping only within the function let's see what happens recursion error maximum recursion depth exceeded this time we're beginning at 100 we're iterating downwards and we're going below zero we don't want to take negative steps we need what is known as a base condition when do we want to stop I'm going to add one line if steps is equal to zero to exit a function you can return let's try that again that's much better but we're counting downwards I would like to count up I'm only going to print the number of steps after we invoke the walk function okay that solves our problem so how does this work exactly when we enter the walk function after accepting a number of steps we check our base condition then we invoke the walk function again but pass in one less than the number we originally accepted in a way we're creating a loop but we're involving the function itself when you invoke a function you add what is known as a frame to the call stack there is a certain order in which we resolve functions it's a stack data structure you start at the top and work your way down it's like a stack of CDs or movies we add frames to the call stack until our condition is met then we undo everything starting at the top if you have too many frames on the call stack let's walk a thousand steps this is what would happen recursion error maximum recursion depth exceeded there's a limit to how many frames can be on the call stack that's an issue to keep into consideration you can solve many problems either iteratively or recursively for a problem such as this I would stick with an iterative approach a recursive approach tends to be slower than an iterative approach but at times it can be simpler to write which you'll see in data structures and algorithms recursion is going to be your best friend let's take a different approach we will find the factorial of a number both iteratively and recursively I will Define a factorial function we will pass in X as an argument if I was to write this function iteratively I will want to keep track of a result result equals one if x is greater than zero I will iterate using a for Loop for y in range 1 comma X plus one I will take our result equals result times y but we could simplify this to result times equals y then outside of the for loop I will return whatever the result is so let's invoke the factorial function pass in a number like 10 then I will print whatever is returned so factorial 10 is 3628 800. if I was to take a recursive approach that would look something like this we'll need a base condition when do we stop if x is equal to one then we will return one else all we need to do is return x times invoke the factorial function again but we will pass in x minus 1. and that's all we have to do even though recursion is slower than iteration the code can be simpler and easier to write with a problem like this I would stick with a recursive approach alright everybody in conclusion recursion is just a function that calls itself from within it helps to visualize a complex problem into repeatable basic steps problems can be solved more easily either iteratively or recursively well everybody that is recursion hey if this video helped you out please help me out by Smashing that like button leave a random comment down below and subscribe if you'd like to become a fellow bro