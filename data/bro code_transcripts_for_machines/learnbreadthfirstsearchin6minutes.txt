all right what's going on people breadth first search breadth first search is a search algorithm for traversing a tree or graph data structure this is done one level at a time rather than one branch at a time like what you see with depth first search here's an example in the previous topic on depth first search we would navigate a graph one branch at a time but in a breadth first search approach we would navigate this graph one level at a time so let's begin at node a and we are attempting to travel to node i instead of a stack we'll use a queue all unvisited nodes we will add to the queue so we're currently at a we'll add that to the queue then add any unvisited adjacent neighbors to the queue as well we have both b and d as neighbors so we will add these to the q then add any unvisited adjacent neighbors of nodes b and d that means we will add c e and g and for the next level we have f and h and lastly i so that is a breadth first search approach we will navigate a graph one level at a time using a cue rather than one branch at a time using a stack like with depth first search let's implement this in code now okay everyone so in my graph i'm utilizing an adjacency matrix we're reusing the same code from the previous few videos and we have a node class that contains some data and i went ahead and populated this graph already it's the same data from the previous few topics heading to our graph class let's create a breadth first search method public void breadth first search and we will take an integer name source this will be the index of the node we would like to begin searching at and with a breadth first search we can utilize a queue so q we will store integers these will be indices and i will name this q equals new now queues are actually interfaces we need to use a data structure that utilizes the queue interface one of which is a linked list okay so we have our queue and we're going to create an array of booleans to mark if a node has been visited or not so let's create a boolean array named visited equals new boolean and the size will be matrix dot length with the node that will begin at let's add that to the queue q dot you can use add or offer and then pass in the index of the starting node then within the boolean array of visited we will mark this as true at index of source equals true and now we'll need a while loop our condition is that we'll continue this while loop while the q's size method does not equal zero we'll assign our source equal to whatever is at the front of the queue q dot pull to remove an element with this code that i've written i've already went ahead and created an arraylist of the nodes to access the data whenever we pull a node i'm going to display the data so this part technically isn't necessary nodes dot get source dot data plus equals visited let's say that we're at node a we're going to iterate over this row and look for any adjacent neighbors so let's use a for loop for that 4 and i equals 0 we will continue this as long as i is less than our matrix at index of source dot length this means the length of the row then i plus plus during each iteration let's check to see if this value is one and the node that we're trying to visit has not already been visited if then matrix add indices of source and i is equal to one and visited at index of i is not true so we can use the not logical operator if we have an adjacent neighbor that's not been visited then we will add the index to the queue and that node is going to wait in line q dot offer i and i is an index and then mark this note as visited so take our boolean array visited at index of i set the sequel to true and there we go let's invoke the breadth first search of our graph class then pass in an index of a node we would like to begin at in this example node a has an index of zero b is one c is two so on and so forth so let's perform a breadth first search beginning at node a we will cover these nodes in this order a b c e d let's change this to 1 that would be node b b c e d a 2 is c c d e a b 3 is d we can't go anywhere from node d so only d is visited and e e a c b d now before we wrap things up here are the differences between breadth and depth first searches breadth traverses a graph level by level depth traverses a graph branch by branch breadth utilizes aq depth utilizes a stack breadth tends to be better if the destination is on average close to the start and depth tends to be better if the destination is on average far from the start in a breath first search siblings are visited before children in a depth first search children are visited before siblings and if you ever plan on creating video games depth first searches tend to be more popular than breadth first searches alright everybody that is the breadth first search if you would like a copy of this code i'll post this to the comment section down below don't be afraid to give this video a thumbs up drop a random comment down below and subscribe if you'd like to become a fellow bro