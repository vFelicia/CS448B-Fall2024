all right what's going on everybody in this video we're going to discuss binary search trees but first we'll need to know what a binary tree is a binary tree is a tree where each node has no more than two children that's why it's binary in this example node one has two children two and three and each of these children have their own children they have no more than two children nodes four and five are the children of two and nodes six and seven are the children of three in this similar example this would also be a binary tree node three only has one child node six but with a binary tree no node has more than two children since node three has one child that's fine but if node three had three children well that would no longer be a binary tree now what makes a binary search tree different from a binary tree is that the values are arranged in a certain order here's the order the root node should be greater than the left child but less than the right child four is greater than two and four is less than six that's the pattern that this data structure is built around if we take a look at some of the subtrees let's say this one two is greater than one but less than three and in this subtree six is greater than five but less than seven if done correctly starting at the root node the leftmost child should be the least value and again starting from the root node the rightmost child should be the greatest value the reason that these nodes are arranged this way is for quick lookup let's say we're looking for five what we'll do is compare 5 to the root node if 5 is equal to the root node well then we found our answer if 5 is greater than our root node we will move down to the right branch and do the same thing again is 5 equal to 6 no it's not however it's less than six so we know to go down at this branch the runtime complexity to find a value within a binary search tree is big of log n in its best case so let's code a binary search tree now okay let's begin let's create a node class file new class i will name this node and finish nodes will have some data maybe an integer this time int data and the node class should contain at most two nodes node left for the left child and node right for the right child if a node is a leaf node well then these will be null but we would still like to allocate space to hold children and within the constructor we will pass in some data int data and assign it this dot data equals data now let's create a binary search tree class file new class binary search tree and within our main class let's instantiate a binary search tree object binary search tree i'll name this tree equals new binary search tree and within the binary search tree class each binary search tree should have a root node node root here are some methods we'll need an insert method to insert nodes public void insert and there is a parameter of a node node node now let's create a second method this next method will be a helper method of the insert method so the insert method is going to call its helper method and this will be private the return type is node insert helper we need a root node node root and a node node node in order for our program to compile we do need to return something so just as a placeholder i'm going to return null okay for the next method we need a display method public void display and helper method private void display helper and this has one parameter a root node node root next method is a search method public boolean we're returning a boolean search and the parameter is int data and we will need a helper method private boolean search helper there are two parameters node root and int data again we do need to return something i'm going to return false just as a placeholder okay next method is a remove method public void remove and the parameter is int data and we'll need a helper method the return type is node remove helper the two parameters are node root and int data we do have to return something so as a placeholder i'm going to return null our remove helper method is also going to rely on two separate methods one to find a successor and another to find a predecessor this is in case we're deleting nodes we have to shift nodes around so this will be private int successor and we will pass in node route and we need to return something let's return zero as a placeholder and let's copy this paste it and this will be a method predecessor and that will be it so let's close these for now and begin with the insert method so with the insert method we will assign our root node equal to insert helper method pass in our root node and a node so the reason that we're using helper methods is that we'll be using recursion so it's a lot easier to use recursion if you have a helper method within the insert helper method let's declare int data equals our nodes data node is the node that we're passing in to insert so let's check to see if our root node is assigned or not so if our root is equal to null then we should probably assign this node to the root node because well this is the first node root equals node return root if root is not null we have to compare the data to see if it's less than a root or greater than our root else if our data is less than the data of the root node then we are going to assign this node as the left child of our root node are roots left child root dot left equals and we will use recursion insert helper method pass in our roots left node and our node the root node is going to change with recursion at first it's going to be the root node of the entire tree after recursion we're examining the root node of a subtree so if we're passing in the left child of the original root node well then that left child is now the root node of a subtree that we're currently working with so else if the data is less than the current root node we go left if it's greater than the root node then we will go right else root dot right that's the right child equals insert helper method pass in root dot write and our node and it's the same process all over again and at the end we will return the current root node okay that is it for the insert method and the insert helper method so let's insert a few nodes although we can't yet display them let's insert some anonymous nodes tree dot insert and we can pass in a node either a node name or an anonymous node so let's pass in some anonymous nodes uh let's pass in the number five or some other number of your choosing and let's pass in a bunch of numbers how about one and nine make sure these are not in order seven and three six four and maybe one more eight if you run and compile this there is nothing obvious that really happens so let's work on a display method next so with the display method we will invoke our helper method display helper pass in the root node within the display helper method we're going to check to see if the root node of our subtree does not equal null so if root does not equal null if you would like to display these in order we can use in order traversal and that uses recursion so invoke the display helper method pass in the root child's left node root dot left if we're using recursion the first piece of data that's displayed is the least value and these values will be displayed in increasing order technically the term is nondecreasing but think of it as ascending order so the very first value is going to be the least one followed by the root node of this subtree system.out.printline root.data in our first subtree the data all the way to the left is one and the root node of that subtree is two then we need the right child which should theoretically be three so again we'll invoke the display helper method and pass in the right child so this is in order traversal all of the nodes will be displayed in nondecreasing order so let's try this at the end of our main class let's invoke tree dot display and see what happens yeah there we go all of the nodes within our binary search tree are now in order if you would like this in reverse order you can just change these methods around replace left with right and right with left and these are now in decreasing order but let's change that back okay up next we have the search methods okay search will return then invoke the search helper method pass in our root node as well as some data within the search helper class we'll check to see if root is equal to null that means our tree is empty so of course we can't search for anything return false then add else if our root dot data is equal to data that means we found the data that we're looking for there's a match then we're going to return true we found what we're looking for else if our roots data is greater than our current data that we're looking for that means we need to go left so return then invoke the search helper method pass in the left child root dot left and the left child is now the root node of the subtree and then you need to pass in data as well else we go right so copy this paste it return search helper root dot write and data and we can get rid of this return statement at the bottom okay let's try this so at the end of my main class let's use a print line statement and i will type tree dot search and let's search for zero none of my nodes have zero as a piece of data so this should return false uh let's search for one now that returns true there's a one within one of my nodes what about nine that is also true and let's try ten and that is false okay so those are the search methods and lastly we have the remove methods as well as successor and predecessor now these methods are going to be a little bit tough but i'll try my best to explain it so within an if statement let's check to see if this data even exists first so let's invoke the search method and pass in our data so this returns a boolean true or false if we do find the data that we're looking for then let's invoke the remove helper method pass in our root node as well as our data then within an else statement and this part's optional uh let's let the user know that we can't find that data data plus could not be found so just to test things real quick i'm going to remove some data that doesn't exist tree dot remove zero zero cannot be found now let's move on to the remove helper method the first thing that we'll do is check to see if our root node is equal to null if our root node is equal to null then let's return the root node then within an else if statement let's check to see if the data that we're trying to remove is less than the data of our root node if it is we need to go left down the binary tree root dot left equals then invoke the remove helper method pass in the left child of the root node root.left as well as our data so we're going to go as far left as we can then add an else if statement else if data is greater than the data of the root node then we will go right so let's copy this paste it root dot write equals remove helper pass in root dot right as well as our data then add an else statement if we reach the else statement that means that we have found our node and i'll just add a note to explain that if the node we're trying to remove has children that kind of complicates things then we have to shift the nodes around but first let's check to see if it's a leaf node then that's really easy within an if statement we will check to see if the left child is equal to null and the right child is also equal to null that means that the node that we're trying to remove is a leaf node and that's really simple we don't need to shift any nodes around we can just set this current root node equal to null however if the node we're attempting to delete has a right child will have to shift those nodes around and find a successor else if root dot right does not equal no that means there's a right child and we need to find a successor to replace this node so we will assign root dot data is equal to the successor method which will find a successor for us and pass in the current root node then take root dot write equals and invoke the remove helper method pass in the right child root.right as well as root.data so when we delete a node that will create a gap and if there's a child well we don't want that child to be lost we don't want that child to become an orphan so we will link a child to that spot where we deleted a node now if there's a left child we have a slightly similar procedure so we can use an else statement take root.data and invoke the predecessor method take this line of code paste it root dot left equals remove helper method pass in the left child of the root node this else statement will find a predecessor to replace this node and at the end we will return root so we can close out of these two methods and we can open up the successor and predecessor methods what we're doing with the successor method is that we're attempting to find the least value below the right child of this root node we will assign the current root node equal to root dot right then within a while loop we will take root dot left and check to see if it is not equal to null while this condition is true take root set the sequel to root dot left and at the end return root dot data so what's happening here within the remove helper method if the node we're trying to delete has a right child we need to find a successor to fill in that gap and that successor should have the least value so we will go right and look as far left as we can because values on the left are less than the root numbers on the right are greater than our root after going right we will go as far left as we can to get the lowest value then return it so that's what we're doing when we're assigning a successor to fill in that gap when we delete a node that has children and then the predecessor method is going to be very similar we will find the greatest value below the left child of this root node so we can copy all of this paste it this time we will go left then go as far right as we can go i do apologize this is a lot to take in recursion can be very confusing but yeah that's everything let's attempt to remove a node so before we display our tree let's take tree dot remove then pass in the data of a node you would like to remove let's remove one and here are the remaining nodes we have two through nine all in order let's remove five okay one two three four six seven eight nine let's remove nine nine is no longer there and let's remove a node that is not within here like zero zero cannot be found all right then everybody that is a binary search tree just so you're aware the order in which you insert nodes into a binary search tree does matter if it's unbalanced technically my tree follows all the rules however it's fairly lopsided there is a way to balance binary trees but that's a topic for avl trees that's why the runtime complexity has a best case scenario of o of log n but a worst case scenario of big o of n depending on how balanced it is but basically a binary search tree is a tree data structure where each node is greater than its left child but less than its right the benefit of a binary search tree is that it's easy to locate a node when they are in order so yeah those are binary search trees if you would like a copy of this code i'll post this to the comment section down below don't be afraid to smash that like button leave random comments down below and subscribe if you'd like to become a fellow bro