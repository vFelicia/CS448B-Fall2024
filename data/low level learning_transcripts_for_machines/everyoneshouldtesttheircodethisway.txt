if you want to write code that is safe from hackers and doesn't have memory corruption vulnerabilities you should use a language like rust and before you go I understand that not Everyone likes rust so if you're like me or you're a c programmer it's good that you test your code what if I told you that one of the ways you can test your code to prevent it from being vulnerable to hackers is by screaming at it I mean literally just yelling at your code today we're talking about fuzzing which is the art of literally yelling bad data at your code and seeing where it falls over and then fixing those bugs today we're going to have a piece of code that I wrote we're going to find a bug in it by yelling at the code using a fuzzer let's get into it I've got some code here that may seem innocent to the untrained eye but hiding deep inside of this code base is a bug that if exploited could allow hackers to take over the code which is bad for anyone that eventually wants to use this code so we're going to go through and walk through the process of how you can use buzzers to yell at this code to give it malformed data and eventually find the bug and then patch the bug in your program so let's walk through what the code does here we do the basic socket IO stuff we create a TCP socket we bind it to Port 1337 eventually we listen for a client and then when that client comes in we accept the client into a new socket file descriptor and we receive some blob of data from that client the The Blob that we receive is into the data buff buffer and we use the reques size variable to denote how much data we're going to receive so in this case in the other header file it's 1024 bytes we receive that data and eventually we go forth and we par that request which is happening in a separate file here in request. C now the code is getting a little more complicated here right and this is where fuzzing is going to pay off a lot you know we could do a static code review of the code itself and try to find the bug but a lot of the times it's hard for us to wrap our head around how the code behaves in the wild so looking at a static code analysis like this isn't going to do it for us we need to test it dynamically so we have here defined a tlv structure that's a type length and eventually underneath that value that comes in from the user and then we parse that typ length value header and then do something as a function of the request they send us here we have a magic header to make sure that we get the right type of data from the user if it's not the proper header magic then we ignore the value we just drop the request and move on with our lives and then if it is the right magic value we have to check the type of the request the user sent us if they gave us a hello we say hello if they say goodbye we say goodbye but if they send us a special message type message we go forth and we parse that message and then take some kind of action and then here is the parse message where we copy in their data to some buffer and eventually use that to do additional processing so this is my server at a high level and let's show you guys it working run the server waiting for a connection here I will netcat to myself net cat Local Host 137 and I can send it some data so because I'm not sending it the proper magic value right it's going to drop the connection here say bad magic and move on to the next connection so I can use like Echo for example to form a proper packet I can say Echo NE and then the header was 45545 and then I can put that into the data and see if I get something else there so we got a Hello message there or still not crashing the program so this is the art of kind of making your own fuzzer where you're like writing your own known bad data into this thing but it's kind of hard to get full code coverage we want to make sure that we hit every possible case in this program and it's kind of hard and really painful to do that manually you should be writing code coverage tests that test every case yourself but luckily there are tools that are already exist to do this for us now our fuzzing Target is this request. C file right inside the request. C file we want to test the parse request function and give it just we wanted to scream at this buffer here we want to give as much data as we can to the request buffer variable and see if we can make the program fall over to find bugs that way so there's actually a really really cool tool called uh lib fuzzer it's a tool by lvm now before we go and find the bug in my code I want to talk to you guys about my new course website L level Academy I'm working on a course right now called Zero to Hero C programmer where I take you from having no experience in C at all to a Master of the C language and I've got a bunch of other courses coming out like Network code that doesn't suck and threads but good as well as get good at Version Control if any of those are interesting to you go check out right now at low level. Academy we see you guys there all right let's go find that bug so lib fuzzer is a fuzzing engine we're essentially you're able to point the fuzzer at a Target function and then the fuzzer will go through and put in bad data and try to get as much code coverage as possible and possibly find any edge cases that you weren't considering and produce a crash that that shows you where the bugs are right so what we're going to do is we are going to have the lib fuzzer fuzzer compiled against our program here I wrote actually a it's called a fuzzing harness here what the fuzzing harness does is it uses lm's lib fuzzer and it takes in the header of that function uh prototype and then we say pars request I'm calling my data parsing function from the user on data now this is an entirely separate program that I'm going to use to test to see if that function has any bad code in it let run the uh command to compile lib fuzzer so we say the you know pieces of C code that we want to compile together and we use f sanitize equals fuzzer and that puts in lib fuzzer into our code and we're going to produce a fuzz binary so we can run fuzz and what's Happening Here is lib fuzzer is going to run and try to find all the bad code in our code by by you know fuzzing it by screaming at it putting all this bad data into it and trying to get as much code coverage as possible and you can see pretty quickly uh Li fuzzer is able to produce a crashing State using the lib fuzzer what it actually does is it produces a file which represents the input that it took to crash this program so let's take this and Cat this let's do cat this file pump into xxd interesting so it found first of all the magic bites that we had to do to get into the processes execution and then after that it found the magical two value the two value is the request message right because request message is the type that calls parse message that's our bad function and then from here it put in a number 40 it's 004 I wonder why that crashes well to test this what we actually can do as well is we can run our server so we'll go to yell at your code we'll run our server we're going to do GDB on our server there we go after after Brute Force ing through a couple address already in uses we have our our program running so we'll put that in the background and we'll put that into window 3 and now to test our crash we can do is we can go to CDL code and we're just going to cat our crash file into netcat localhost 1337 so we're going to take all the data from the crashing input and send it to our server bada bing there we go and now we should have a crash Happening Here in uh Pond debug which is GDB so now we can look at our stack trace and see okay what was the issue that we ran into uh we had a crash that came from parse message line 63 okay let's go back into our code line 63 is actually the return here so something bad happened in this function oh we can see here that you know the hlen we are allowed to mem copy an arbitrary length into a 64 byte buffer so we can take this and now we can say if hlen greater than 64 actually less than 64 than let's do the mem copy otherwise we don't do anything all right so we can try this and let's see if this fixes our bug and if lib fuzzer is able to find any more problems go like this fuzz o it found another crash I'm interested in what this is actually oh you know what's happening here it's because the input is being looked at as a signed value so we have to do uh wow that's really interesting actually I didn't think this was going to happen in this video let's go ahead and patch that so we'll do server request. C yes we have to make the type of this and unsign short wow that's pretty cool that's a bug that I didn't even see in this code playing that fuzz it's going to run forever because in theory there are no additional bugs in this program this is a lib fuzzer this is a program going that's going to take our code it's going to try to get full coverage on it by screaming at it as loud as it can finding all the edge cases for us and we can take those edge cases that are produced as crash files and use them to find more bugs in our code patch those bugs and move on and if you think that these lines here are fast go watch this video about how switch statements are even faster we'll see you there