are gotos illegal you've probably heard the argument that gotos make your code unreadable but this code is unreadable and there's not a goto in sight so what's the deal with gotos in this video we'll talk about what a goto is under the hood how you can use gotos incorrectly and how to correctly use them to make your code not only more readable but more efficient let's Dive Right In to discuss gotos we need to First understand what a goto actually is here I'm looking at some code and in the code we do some pretty straightforward stuff if argc is equal to two which means that we gave it two command line arguments we invoke the goto statement that tells the compiler to insert code that will make the code run at the print label we Define a label which is different from a function that's just an area of code inside of a function with the name of the label and then a colon and then code after that so if we give it to arguments we go to the print label and then we go there and we print that we got two arguments awesome otherwise if this didn't happen we go to leave and then from there we return zero and we can see under the the H it's actually going on in our program by just doing an object dump tacd Mel on what is and then in main you'll actually see the exact logic here that we wrote in C in assembly if you don't fully understand assembly that's okay all we're doing here is we're comparing the variable ARG C to two and if it's not equal we go to one label but if it is equal we go to another label what a go to literally is it inserts a jump instruction in our code in assembly now you're probably wonder ing what does this do for us why would we actually use this and that's actually a great question because if you look at this code already we've began to very heavily obfuscate what the code does and make it very difficult to read I'm already just looking at this code having a hard time understanding what's going on so this is a bad example of when gotos are good and I would argue using logic like this to use gotos is actually really bad but let's go to a good example pun intended here I have some basic server functionality and obviously this is not broken out into same functions that all do one thing this is all happening in one function but this demonstrates the point that I'm trying to make so to run the server we open a file and like good C programmers we check that the return value of that open call is a good value and if it's not we print the error for open we leave our program if we don't fail if we succeed we move forward and then we maloc room on the Heap to readin data from that file if that Malo buffer returns null a bad value and again we're checking for that every time because we're good SE programmers we have to go and close that file descriptor then go to print the error for Malik then return negative 1 and then if that succeeds we call socket check for a bad value and then we have to free the previous buffer we got before we have to close the file that we opened before and what's Happening Here is we are increasing every time there's a possible failure the amount of duplicative code that we have to insert right because we already have close written here and written here now we have to add free if we have more conditionally failable code that we insert this gets very very ugly to maintain and then even if it succeeds as good programmers we have to close our file descriptors and free our memory so we have to duplicate this code again this is where gotos get really magical I'm going to insert goto into this code and show you how you can make it a little bit cleaner so here I've Rewritten the code but I'm using goto statements and you should immediately see that the code is not only more legible it's less chaotic and every error State as a Cascade down in the code doesn't get longer with the duplicate of code like close FD and free Malik for example and by the way if any of the syntax is confusing to you I am running a course right now called Zero to Hero C programmer Link in the description below go check it out if you want to learn more about the C language the C syntax really anything C or assembly related so the major change to the structure is that I've put a return value variable at the top of the code that will use to store our return value right it's zero success and if we return anything other than zero we have a nonsuccess state right and then later on in the code like for example when our socket fails right instead of the socket failing and us having to close a file descriptor free Malik and that same code appears all over the place we just do one go to that goto is a label that will then fall through and run all those pieces of code that we had in the previous example so instead of having to do free here and close here we can put free at this label and then the next line of code will run it'll close the FD after that and then return the return value Val which is set to1 and in the success case where none of this actually happens and everything succeeds we set the return value equal to zero and after our code runs we close the socket file descriptor we free the file buff we close the FD and we return the success value and you can see the structure is that the lowest function the one that's further on in the code goes to the top level error Handler because it has to handle the most things that has to do it has to free the buffer it has to close the file the scriptor ETC while goto in a lot of other cases make code a lot harder harder to read using goto to handle error cases allows you to write the same code one time in your error Handler and then use the gotos to jump to what layer of error handling you're at now another cool thing about C is that the switch statement is actually way faster than the if statement and the reason behind it is really interesting you'll find out about that in this video go go click goodbye