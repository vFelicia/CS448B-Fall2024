hey guys what is up I love learning here teaching you how to write better faster and safer code today we're talking about a weird thing that I think a lot of new programmers struggle with header files are this thing that we kind of learn on day one we have to pound include standardio.h but we don't really understand why header files exist and then when we go to make multimodule programs that use multiple C files we struggle to include header files in our process and don't really know where they're appropriate and not appropriate today we're going to break down the process of how the Linker Works under the hood what the compiler expects when you're using external functions and why the header file ties all of this together let's get right into it here we have some C code that's doing some basic C stuff we have our int main which is our entry point to our program and it's taking the standard main prototype we have the number of arguments for our program and the vector to those arguments we print F hello world just like we're used to but then we do something funky we say that an INT x a variable is equal to low level add which is a function that we have not defined yet it turns out the low level ad is actually a function that is exposed in a library that someone else me has written called lib low level math.so and we could go into and Cat this library.c and figure out what that function does and we also could in theory compile in liblibrary.c into our program statically by just including it into our build process including this code in our code and going from there but maybe this library is closed Source maybe we have to because of other dependencies in our build process have to just depend on the dot so file the problem with the code AS written is if we try to compile this we'll get a bunch of really nasty errors now the interesting part about these errors is that one is actually a compile time error and the other is a link time error the two of them being one an implicit Declaration of a function called the level add because again in our code we have not defined this function yet but we are calling it and then two we try to link in this function at link time after it compiles and the Linker says hey you tried to run a function called lowlevel ad I trusted you knew what you were talking about because I only called the implicit declaration a warning but I got to the Linker phase and I couldn't find the symbol low level ad before we go any further in this video I want to break down what the two words compile time and Link time mean I think they're kind of tossed around a lot and go over the heads of new programmers so let's kind of break down what the compile process looks like at compile time and Link time and Define those two so we can understand these two errors and how it relates to the header file when you run the traditional command to compile the program we'll do GCC Tac o um call my program p and we compile in P dot C right and I'm truncating that because my handwriting is terrible when you actually invoke GCC taco and do the whole command there are two things that happened there's what is called a compile pass where it compiles all of your code into object files so compiler produces objects objs and then the Linker pass or the link phase takes all the object files these are like an input to the link phase and it outputs an executable file and in some cases it could also output a library file but the final product of the link phase is one of these two things now it's really important to understand what is happening specifically in each of these phases and what the output is and how the header file plays into that now when you're writing code let's say that this is our piece of code here right it's it's a square and it has some code in it and let's say in that code for example I have a function called Foo right and then inside of that function also I have a function that's called add but add is not defined so during the compile phase right this is not the link phase this is at compile time the compiler will throw that first error that says hey you implicitly Define the function add but it won't throw an error yet what's going to happen is the output of the compile phase is this object file I like to think of them as like a spiky ball right so this ball is my let's say it's my P dot o because if this came from my P dot C file now it's P.O and the ball has this Spike on it that's like an arrow and the arrow is saying essentially hey by the way guys I still depend on the add function so let's say now that the program also has another file called M.C and the compile phase produces an M.O object file and it has no dependencies so our spiky ball analogy is just a ball by itself right so the compile phase will run and it will compile all these programs independently into objects once it's done compiling then the Linker phase comes in now the second phase the Linker phase is to do kind of what the name implies right it's to link all the things together if we have our spiky ball analogy where we have this one object file here that depends on ADD and maybe this other ball here the end product the Linker wants to produce is an executable that is just all of these balls attached together in the proper format so that all the dependencies are met right this thing here is the output of the Linker now the issue we ran into before where it said undefined reference to the thing is because the Linker was unable to find where the dependency to low level add was in all the object files so we have a bunch of problems we have to solve here now with our library lib low level at math.so which again could be a closed Source Library we are given an open source header file the header file acts as two things one for us as a programmer it's kind of an API that tells us how we can use the library it has good documentation like what do the parameters do and what does it return and the internal functionality of that could be a proprietary black box that maybe the manufacturer doesn't want us to know about or the authors want us to know about but they expose to us how do we use the function and then also it exposes a a header guard basically this prevents us from including the header multiple times and having recursive dependencies or circular requirements in our Pro and our programs so don't worry about that one too much but this is the meat and potatoes so the reason we use header files is it creates this symbol in our program so that the compiler doesn't yell at us when we try to implicitly Define things and so by including our libraries header file using lib slash low levelmath.h which is the path to the header file and again these quotes mean it's a local file that's in the current directory and these carrots mean that it's a global header file that exists somewhere else in a library that we installed on the system system lot so by including that we will get rid of one of the compiler errors now you see our implicit declaration went away but we still have this low level add error let's talk about what happened there so by adding this Line to Line one we include a header file into the program and that gives us the line that essentially says low level add the function is declared but we have not defined the function yet and again a definition is we say how the thing works the Declaration is just saying that the thing exists so this is a declaration and not a definition so what we need to do finally is you have to link against the library by giving a link or flag to GCC the Laker flag is we have to do Tac L and say low level math and then giving a library directory of the print working directory slash lib to tell it where to look for this library and then now we have a program by typing ldd that depends on a few things depends on our standard Linux libraries like Linux vdso and libc and then the loader but then also now our program depends on lib low level math and then we can run our program by saying LG Library path equals print working directory print working directory slash lib and then run our program and we eventually run our code and then we also Link in at runtime the shared object and that calls the external function that is defined in our header file and this line of thinking applies not only to using external libraries like we just did before but also using multimodule Code that we write ourselves for example if I have my main function here in a piece of code called code.c but I want to write a separate module that represents a different kind of functionality that shouldn't be in the same code AS main what I can do is I can make another C file and I can write the functionality for that module here here the module being some kind of client right maybe this is a structure that gets allocated when you connect from a server or something so in client.c we are going to also include client.h and that dot h does the exact same thing it exposes the API to the programmer of how the client module is supposed to behave and how they use the function reality so we Define our public structures like what the client even is here it's just some buffer you can put other data in that structure and then we declare what that function does the function called create client returns a client star okay awesome and then when we want to actually use create client in our code all we have to do is pound include client.h right there really simple now there is one tweak we have to do to our compilation process it will prevent things from breaking now in a perfect world maybe using a make file to automate this process but instead of doing the traditional GCC taco the thing the thing.c we're going to skip running the Linker step automatically and only do the compilation step by using the tax C Flag by using the tax C flag we're going to say hey turn our code.c into main.o the intermediate object file and again that set that spiky ball that has the arrow that says hey by the way I depend on create client don't forget about that and we do the exact same thing on client.o right we say GCC tax C so compile our client client code into the client object file and then to glue them all together we invoke the Linker which is that third and final stage here but says Hey output the full binary our final program called code and the sources are no longer C code they're the intermediate object files so we compile that and then we run our code and you can't see it happening but underneath the hood client.c is getting ran and it's allocating the client as defined in the C code and the only thing that code.c knows about is is what is exposed in the header file that's how header files work if you didn't know how they work now you do hey guys before you go I am working on some seriously awesome courses on my new website low level dot Academy the courses are going to range from everything from Zero to Hero C programming to threading and C to network code that doesn't suck in seed is how to get good at git if you're interested in any of those go check out sign up the first course Zero to Hero C programmer starts October 1st we'll see you there now another thing new programmers want to learn about is if it's okay to use numbers in their code like our numbers allowed is are this at legal go watch this video here while I talk about how numbers can actually be problematic in your code if you don't use them correctly we'll see you there so go click on the video all right bye