I wrote two Snippets of code that have the same functionality they both use a lowlevel language to perform some basic math one in C and the other in C plus plus but one program runs almost 20 percent slower than the other in this video we'll break down how C plus plus polymorphism Works under the hood with the keyword virtual is used for and why it's ultimately kind of slow but why is it so slow I guess we'll see we're trying to make a calculator that can perform several types of math operations but a generic operation doesn't just exist on its own an operation has specific functionality like addition multiplication Etc this problem is referred to as polymorphism or simply writing something in code that can take multiple forms by designing our code around a generic form of the class in our example in operation we can create what is called an interface which describes the behavior of a derived class without specifying the details of its implementation the code written in C uses a structure to represent a generic operation and at runtime uses an enum to determine what operation to perform so if the enum says hi I'm an ad it'll add if it's a multiply it'll multiply Etc but hold on C doesn't allow for objects so inherently this code isn't really object oriented actually it can't be object oriented C is not an objectoriented language so technically this code isn't polymorphic it's just well written code also notice that we can't use functions inside of the structure like we can in an objectoriented language we can't say operation dot execute or operation dereference and execute well in C technically we can use function pointers in a structure but the syntax is kind of gross so if we wanted to do formal object oriented programming this would not pass the test instead we have to use C plus plus C plus plus allows us to use classes which are basically just structures with function pointers inside of them classes in C plus plus can also be derived from one another meaning that if I have a Base Class B in a derived class D which is derived from B all of B's attributes become part of d first we have to define the parent class which represents the generic thing we're trying to represent in this case we'll Define a generic operation class the operation class will have two operands called operand one and operand two the operation class will also have a function called execute where the operation will take place by not implementing any functions this operation can be considered an interface it describes what needs to be implemented but not how but again remember a generic operation doesn't exist the execute method needs to be overridden by a child class that will implement this method to make this possible in the parent we have to call this a virtual method or a method that is allowed to be overridden by a child class by making this virtual and setting it equal to zero inside of the class in its memory it creates what is known as a v table or virtual table which later will account for the Slowdown inner code it is important to note that by default functions with the same signature in a derived class are virtual in the parent by default however for code readability it's important to use the virtual keyword so that readers of the code know that the code is intended to be overwritten to override this function execute let's make our child class and the execute function for add which adds operand 1 and operand2 now that we have our derived class how do we use the polymorphism in our code to invoke the polymorphic class we create a pointer for the generic class in operation and point it to an instance of our derived class for example our add and then we call execute on the operation class and our ad happens but wait a minute how did Operation know what method to call you know we defined a zero method and our add method how did it know which one to go to when we call Operations execute method the operation classes V table is invoked and this is where things start to slow down for the generic operation class to know what function to call all derived classes contain a pointer to a v table or virtual table in the child class object memory now I know I've said V table a few times now in this video so what exactly is a v table a v table is just an array of function pointers to functions that are overridden by the child class B tables from the same parent all have the functions in the same order so that when a parent invokes a virtual method it knows what index in the table to call for example the virtual method execute is always in position 1 in a derived operation V table this way whether it's an add or a multiply or a subtract the base class will always invoke execute and not something else so while the order of the V table is the same the function itself will be different depending on the implementation by the child class let's walk through a Constructor and see it happen live here in the assembly for our calculator program we see the Constructor for the add operation calling the parent Constructor for operation after this it copies a pointer to its specific V table into its memory before returning from The Constructor so when the operation eventually calls the execute method it looks into its own memory finds the V table pointer finds the function pointer in the v table at the known offset and then calls that Jared I said yeah it not only has to dereference the pointer to itself in memory but then dereference another pointer to find its veto only to figure out what function to call and this is why V tables are so slow every invocation of a child class method requires at a minimum two pointer dereferences which is a memory load into memory before any code execution takes place now that may not sound awful but memory lookups are some of the slowest operations in Computing if your child class is V table isn't loaded Into Cash the cash Miss on RAM could result in a significant performance hit this is why RC code was ultimately faster and why C plus plus polymorphism using virtual methods is generally thought to be slower in our C code we used a structure that contained a variable to tell us which area in our switch statement to jump to this was only one layer of memory misdirection and could possibly be even further optimized using additional caching schemes using registers in the background our C plus plus code on the other hand wasn't so lucky every time we invoked our operations virtual execute method two memory loads occurred and the craziest part is that in my example I called the same V table every single time which means that this program wasn't even cash missing imagine if it was so maybe polymorphism just sucks you see what I mean now if you want to learn other ways to make your code faster check out one of these two videos and I'll see you next time