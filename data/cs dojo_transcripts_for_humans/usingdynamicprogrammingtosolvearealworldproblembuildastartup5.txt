With timestamps:

00:00 - hi everyone so recently as some of you
00:03 - know I've been working on a project
00:04 - where I try to start a real startup
00:07 - that's based on this app I'm making for
00:09 - learning languages and in this process I
00:12 - run into a problem where I needed to use
00:14 - dynamic programming to solve it so I'm
00:17 - going to show you what the problem was
00:18 - and how I solved it so like I explained
00:21 - it in one of my previous videos on this
00:23 - app I'm developing which I'm thinking
00:26 - about calling Edit dojo people are gonna
00:28 - write stuff in different languages and
00:30 - other people are gonna fix them or edit
00:33 - them for them so one person might write
00:35 - the breakfast I had today was awesome
00:38 - and someone else might edit them edit
00:41 - this too this at the professor I had
00:44 - today was awesome and the function I was
00:46 - trying to make is the function that
00:48 - shows the difference between these two
00:51 - sentences so given these two sentences
00:53 - we want to be able to say that you know
00:55 - this word has been deleted from the
00:57 - first centers and also this word and
00:59 - then these two words have been sort of
01:01 - added to the second sentence and there
01:05 - are a few different ways of going about
01:06 - it
01:06 - one is to compare these two sentences
01:09 - word for word that's what I've done and
01:12 - that's why you see you know these two
01:15 - words changed but another way to do this
01:18 - is to compare these two sentences
01:21 - character by character so if you take
01:24 - the approach the UI might look like this
01:27 - instead so here you can see that instead
01:30 - of showing the whole words being changed
01:33 - we're only saying okay you know this
01:36 - character o has been deleted and the
01:39 - same thing with this letter e so which
01:42 - one is a better approach well I think
01:44 - either one works but in my opinion the
01:48 - comparison by word approach is much
01:50 - easier to read so that's what I'm gonna
01:52 - use for English but the thing is for
01:55 - languages like Japanese there's no easy
01:59 - way to split a sentence by worse so I
02:02 - decided to use the comparison by
02:03 - character approach for languages like
02:06 - Japanese and in this video I'm gonna
02:08 - explain the comparison by character
02:10 - approach because it's much simpler to
02:12 - explain
02:13 - anyway whichever approach you decide to
02:15 - take this problem actually reduces to
02:18 - another problem called the longest
02:20 - common subsequence problem I already
02:22 - talked about it in one of my really old
02:24 - videos actually but let me explain what
02:26 - it is here again
02:27 - so in the longest common subsequence
02:30 - problem you're given two strings for
02:32 - example these two a b c d and a c DB you
02:37 - want to be able to find a common
02:39 - subsequence between these two strings
02:41 - that's the longest so in this particular
02:44 - example the answer would be this one a
02:47 - CD so as you can see this is a
02:50 - subsequence of the first string you know
02:53 - it's a CD right here and it's a
02:56 - subsequence of the second string as well
02:58 - a CD right here and there are usually
03:02 - multiple common subsequences between
03:05 - these two given strings in this example
03:09 - another common subsequence would be this
03:12 - one a B you know there's a B right here
03:15 - and there's a B right here in the second
03:17 - string as well but in this problem you
03:20 - want to be able to find the longest one
03:22 - of those common subsequences and again
03:25 - in this example the the answer is this
03:27 - one and sometimes there are multiple
03:29 - answers you know there are multiple
03:31 - mungus common subsequences but let's
03:33 - just say that here you know we just want
03:35 - to be able to find at least one of them
03:37 - and it doesn't matter which one we find
03:39 - okay now let me just quickly explain how
03:42 - we can apply this problem to solve the
03:45 - problem that we saw earlier so let's say
03:47 - that the original text is this one
03:49 - I am waiting and let's say that someone
03:52 - else fixed it to this one
03:54 - I've been waiting then what we can do is
03:57 - we can first find the longest common
03:59 - subsequence between these two strings
04:02 - that would be this one i spaced space
04:05 - waiting and then to find which parts of
04:09 - the first string has been deleted we can
04:13 - compare this string with the longest
04:15 - common subsequence this one which is
04:18 - basically the common part of these two
04:20 - strings and then when you do that you
04:22 - see that this part just am
04:26 - has been deleted from the first string
04:29 - because the common string ice space
04:32 - space waiting is right here and then
04:35 - what's left is just this part and then
04:38 - you can do the same thing to the second
04:40 - string to see which parts have been
04:42 - added to the second string so compare
04:45 - the common string with the second string
04:48 - and you see that the ports that have
04:51 - been added is this part and this part
04:54 - and then you know you can highlight
04:57 - those parts to get this text okay so
05:00 - that's going to be the idea of my
05:02 - solution of course the first step of
05:05 - going about this solution is to solve
05:07 - the longest common subsequence problem
05:08 - so let me show you how I would solve
05:11 - that part okay so I'm gonna write a
05:13 - function called LCS of these two strings
05:17 - and this function is going to return the
05:20 - longest common subsequence of these two
05:22 - strings and I'm gonna solve this problem
05:24 - recursively and one case of this
05:27 - recursive solution it's gonna be when
05:30 - the given two strings have the same
05:33 - first letter in this case a right here
05:36 - and in that case we'll say whatever the
05:39 - longest common subsequence of these two
05:41 - strings is it must have a as the first
05:45 - letter so it's sort of like taking off
05:48 - these two letters and then saying the
05:51 - longest common subsequence of these two
05:53 - strings is gonna be a concatenated with
05:58 - the longest common subsequence of these
06:01 - two strings b c d and c de b the rest of
06:05 - the strings so we can write that as the
06:08 - longest common subsequence of these two
06:10 - strings is going to be a concatenated
06:14 - with the longest common subsequence of
06:16 - the rest of the strings b c d and c da b
06:19 - and this might be actually a little bit
06:22 - hard to get your head around so I'd
06:24 - recommend you know playing with a few
06:25 - examples to see why this is actually the
06:28 - case anyway let's go to our next case
06:31 - that's when the given two strings don't
06:34 - have the same letter at the beginning we
06:37 - have B C D and then C D B for example
06:40 - in this case so in this case we're gonna
06:43 - try two things one is we're gonna take
06:47 - off the first letter of the first string
06:50 - and then we'll ask ourselves what's the
06:53 - longest common subsequence of the rest
06:55 - of the strings so CD and CD EB and then
06:59 - we're gonna do the same thing with the
07:00 - second string take off you know the
07:03 - first letter of the second string and
07:04 - then ask ourselves what's the longest
07:07 - common subsequence of BCD and dB and it
07:11 - turns out whichever is the longer common
07:13 - subsequence is going to be the longest
07:15 - common subsequence of the given two
07:18 - strings so we can informally write it as
07:21 - the longest common subsequence of these
07:23 - two strings b c d and c d eb is compare
07:28 - you know these two longest common
07:31 - subsequence CD and CD B and then B C D
07:35 - and D B so that's CD and CD b or b c d
07:43 - and d b right here and then just take
07:48 - the longer one of them I was just ready
07:50 - as Max again you know this might be a
07:54 - little bit hard to get your head around
07:56 - so I recommend you know playing around
07:57 - with a few examples here too now if you
08:01 - implement this function as is you need
08:03 - to create new strings every time we call
08:06 - this function so for example if you're
08:08 - given LC s of these two strings ABCD and
08:11 - s DB
08:11 - we'll need to create these two strings b
08:14 - c d and c DB to call this function
08:17 - recursively and that's pretty wasteful
08:20 - but we don't have to do that instead of
08:22 - doing that we're gonna pass in two new
08:24 - arguments that are going to specify
08:27 - which letters we're currently examining
08:30 - in these two strings so instead of
08:33 - saying you know LCS of a b c d and a c
08:37 - DB will say LCS of these two strings and
08:41 - then 0 0 and that's gonna mean we're
08:44 - examining this letter right here which
08:47 - has the index 0 and this letter right
08:50 - here whose index is also 0
08:53 - and then when we call this function
08:55 - recursively instead of generating new
08:57 - strings we're just gonna change the
09:00 - indices so we'll say LCS of ABCD is DB
09:04 - and then 1 1 because now we're examining
09:07 - these two letters B and then C right
09:11 - here whose index is both 1 and we can do
09:15 - the same thing for this case as well
09:17 - instead of passing a b c d and c de be
09:21 - the original strings might be a b c d
09:24 - and a c DB and then you know we're
09:28 - passing 1 1 as we saw earlier and then
09:31 - instead of creating these two or these
09:35 - four strings we're just gonna change the
09:39 - indices again so this is gonna be like
09:43 - that max of LCS of the same strings and
09:47 - then 2 1 and then i will see s of the
09:50 - same strings and 1 2 ok so let me show
09:53 - you how i would implement this function
09:55 - recursively and i'm gonna show you that
09:58 - using pseudocode so like we saw earlier
10:01 - we're gonna write a function called LCS
10:03 - of s1 s2 the two strings and i-one i-two
10:08 - the two indices of the letters that were
10:11 - examining and then outside this function
10:14 - we're gonna have to call this function
10:15 - with the two given strings and 0 0
10:19 - because we're gonna start with the first
10:21 - letters anyway the first thing we're
10:24 - gonna do in our main function is we're
10:26 - gonna take care of the base case and
10:28 - that's when I 1 is equal to s1 s length
10:32 - or I 2 is equal to s2 slangs
10:35 - and this is sort of like saying what's
10:38 - the longest common subsequence between
10:40 - an empty string with another string and
10:42 - the answer is an empty string so we're
10:45 - gonna return an empty string from here
10:47 - and the next case that we need to take
10:50 - care of is when the current letters that
10:54 - were examining s1 square brackets i 1
10:56 - and s2 square brackets I 2 are the same
10:59 - if that's the case we're going to return
11:02 - it's one of the current letter S one of
11:06 - I
11:07 - one it should be i one here concatenated
11:11 - with the longest common subsequence of s
11:13 - 1 s 2 I 1 + 1 and I 2 + 1 and if we
11:18 - haven't returned yet at this point that
11:21 - means that the current letters that
11:22 - we're examining are different so in that
11:25 - case we'll need to find 2 results
11:28 - without a and without B result a is
11:32 - going to be LCS of s 1 s 2 I 1 plus 1
11:37 - and I 2 and then without B is going to
11:40 - be as LC s of s 1 s 2 I 1 and then I 2
11:45 - plus 1 and then we're gonna have to
11:47 - compare the lengths of these two strings
11:50 - and then we turned a longer one so we
11:53 - can do that with if result a s length is
11:56 - longer than result B's length then we're
12:00 - going to return result a and otherwise
12:02 - we're gonna return result B okay so this
12:06 - function works this implementation works
12:08 - but it turns out it's very very
12:10 - inefficient and the reason is because we
12:13 - end up calling you know the same
12:15 - function LC s with exactly the same
12:18 - arguments over and over again depending
12:20 - on the strings so for example we might
12:23 - call LC s of s 1 s 2 2 3 over and over
12:28 - again depending on what the strings are
12:30 - and every time we call this function you
12:33 - know we need to recompute what the
12:35 - result is for for these particular
12:38 - arguments and this is where the idea of
12:41 - dynamic programming comes in you know
12:43 - dynamic programming says why not store
12:45 - the return value of this function with
12:49 - these particular arguments so that we
12:52 - can reuse it and so that's the idea
12:54 - let's see what the code is gonna look
12:56 - like ok so this is part of the dynamic
13:00 - programming solution code and it's
13:02 - pretty much exactly the same as what we
13:04 - saw earlier except for this additional
13:07 - argument that I added here called memo
13:09 - this is going to be a two-dimensional
13:11 - array that's gonna store the return
13:14 - values of this function LCS and so
13:17 - before we call this function we're gonna
13:20 - have to initialize
13:21 - a new two-dimensional array whose size
13:24 - is gonna be s 1 dot length by s 2 dot
13:28 - length and then the results or the
13:32 - return value of LC s of s 1 s 2 I 1 I 2
13:36 - memo is going to be stored right here in
13:40 - this two-dimensional array at the
13:43 - indices I 1 and I 2 and so you know
13:46 - outside of this function we're gonna
13:48 - have to initialize that and then call LC
13:51 - s with s 1 s 2 actually 0 0 and then
13:57 - memo let's just assume here that every
14:01 - element of this array is gonna be
14:03 - initialized to either undefined or no ok
14:06 - and once you have that after taking care
14:09 - of the base case we'll say if memo at
14:13 - the indices I 1 and I 2 is not undefined
14:18 - that means that we've already seen these
14:21 - particular arguments you know i1 and i2
14:24 - and we've already stored the return
14:26 - value of this function with those
14:28 - arguments in memo at this at this
14:32 - location so we're just gonna return that
14:34 - by saying we turn memo square brackets I
14:37 - 1 and I 2 and what about this case when
14:41 - we haven't returned at this point and
14:43 - when the letters that we're examining
14:45 - are the same this case right here in
14:48 - that case instead of returning you know
14:51 - the thing that we saw earlier the first
14:53 - letter concatenated with LCS or the
14:57 - results of the next LCS call we're gonna
15:00 - store that a memo at the location that
15:04 - we saw earlier at I 1 and I 2
15:06 - just like that memo skyrockets I 1 and I
15:09 - 2 is equal to this thing that we're
15:13 - gonna return and since we just store the
15:15 - return value of this function with these
15:18 - particular arguments a memo of i1 and i2
15:22 - instead of computing it again we're just
15:25 - gonna return that just like that right
15:28 - here ok and to make this function
15:31 - complete you need to do the same thing
15:33 - basically
15:35 - for the second case when s1 square
15:38 - brackets I 1 is not equal to s2 square
15:40 - brackets I 2 so before you return the
15:43 - result you'll need to store it in memo
15:45 - and then return that instead okay so
15:48 - once you have all of that this function
15:50 - is going to be complete but what about
15:52 - the time complexity well just in case
15:55 - you're curious here it is
15:56 - suppose we write s once length as l and
16:00 - s twos length as M then the time
16:04 - complexity of this function is going to
16:06 - be this assuming that my analysis is
16:09 - correct
16:09 - it's going to be big-oh of L times M and
16:13 - if you're curious why that's the case
16:15 - I'd recommend watching my old video
16:18 - about the longest common subsequence and
16:20 - this is actually much better than the
16:22 - naive recursive solution that we saw
16:24 - earlier which has an exponential time
16:27 - Quebec City ok so that's the idea of
16:29 - this code but let me show you if we can
16:32 - actually implement it using javascript
16:34 - okay so here's the setup I have here I
16:37 - have this HTML file testa HTML for
16:41 - showing the test cases we have a few
16:43 - test cases here one of them is this one
16:46 - the original text is ABCD and the edited
16:50 - text is a fkd and the longest common
16:53 - subsequence between these two is ad so
16:57 - our function given these two strings
16:58 - should return ad so that's the expected
17:02 - result and the result of our function
17:05 - will come in here after actual result
17:08 - and our function right now just looks
17:10 - like this it's just a function that's
17:13 - called LCS that's going to take two
17:15 - strings s1 and s2 and returns a string
17:19 - so if I change this to hello we should
17:23 - see hello right here
17:25 - okay let's start by implementing the
17:27 - naive recursive approach I'm gonna
17:31 - create a new function called helper
17:34 - which we're gonna call recursively so
17:37 - this helper function is gonna take four
17:39 - arguments the two strings s1 and s2 and
17:43 - then the indexes the indices of the
17:46 - letters that were examining
17:48 - that should be zero zero at the
17:49 - beginning so let me define the
17:52 - functional helper here - this is gonna
17:54 - take s1 s2 and they i1 and i2 and just
17:59 - for testing let's return hello to make
18:04 - sure that's showing on our HTML file
18:08 - here and by the way I'm gonna put the
18:10 - end result of my code today at CSD dojo
18:13 - da yo / text so you can play around with
18:16 - my code yourself - anyway let me
18:18 - implement the rest of the recursive
18:20 - solution so the base case was when I 1
18:24 - is equal to s ones length or s I 2 is
18:30 - equal to s tooth length we should return
18:33 - just an empty string and then the second
18:36 - case is if s1 square brackets i 1 or the
18:42 - current letter that we're examining is
18:43 - equal to s2 square brackets i 2 then we
18:48 - should return is 1 I 1 that's the
18:53 - current letter that we're examining
18:54 - concatenated with helper of s 1 is 2 I 1
19:01 - plus 1 and then I 2 plus 1 and for the
19:05 - last case I would say first let result a
19:09 - be equal to helper of s 1 s 2 I 1 plus 1
19:15 - and then I 2 and results B should be
19:18 - helper of s 1 s 2 I 1 and then I 2 plus
19:24 - 1 and then whichever is the longer we're
19:26 - gonna return us the results so I'll say
19:29 - if results is length is larger than
19:34 - results B's length then we're gonna
19:38 - return result a and else otherwise
19:41 - return result B okay so this should work
19:46 - let's see if it works by going back to
19:48 - the browser and when i refresh this
19:51 - actually this takes too long and the
19:54 - reason is because the naive recursive
19:56 - solution is you know very inefficient so
20:00 - too
20:01 - sort of fix that for now we have you
20:04 - know three test cases right one of them
20:07 - is pretty short but the other two are
20:09 - kind of long let me close this window
20:12 - for now so the two test cases that we
20:16 - have here pretty along the text I am
20:19 - waiting for in snow and the break the
20:21 - breakfast I had today was awesome so the
20:25 - naive recursive solution is efficient
20:26 - enough for the first case but not
20:29 - efficient enough for that two other
20:30 - cases so I'm gonna take them out just by
20:34 - changing the code here and then I'm
20:37 - gonna go back to the browser and when I
20:39 - open the file again I see the correct
20:41 - result okay let's now make this code
20:44 - more efficient by using the approach
20:46 - that we saw earlier so the first thing
20:48 - we want to do in this parent function
20:50 - LCS is we want to initialize a new two
20:55 - dimensional array called memo whose size
20:57 - is gonna be s once that length by its to
21:00 - that length in JavaScript there is a
21:03 - neat trick for doing that so let me just
21:06 - write it here first I'm going to write
21:10 - square brackets dot array is one's
21:14 - length this produces an array of length
21:17 - s one's length whose elements are going
21:21 - to be undefined and then I'm gonna say
21:23 - dot map e ro and then array s2 length so
21:30 - with this we can create a
21:32 - two-dimensional array whose size is s1
21:35 - start length by s2 style length after
21:38 - that we'll just need to pass this memo
21:41 - to this helper function so let's add
21:43 - memo here and then also here basically
21:48 - everywhere a helper is called so here
21:51 - here and here so this doesn't change
21:55 - anything algorithm eyes but let's just
21:58 - make sure that everything still works
22:00 - and it does so let's go back to the code
22:04 - editor and then let's keep going okay
22:07 - the next step is after taking care of
22:09 - that base case we'll say if memo I 1 I 2
22:15 - is not exactly equal to undefined then
22:20 - we're just going to return that memo of
22:23 - i1 and i2 and then in the first case
22:26 - when s 1 i1 s 1 of I 1 is equal to s T
22:30 - of i2 we're gonna store this return
22:34 - value a memo of i1 and i2 and then we're
22:39 - gonna return that instead and we're
22:43 - gonna do the same thing here to we're
22:44 - going to first define a new variable
22:46 - called results and then instead of
22:49 - returning a result a and result be here
22:52 - I'm gonna put it here so results is
22:56 - equal to result a or result B and then
23:00 - before we return the result we're gonna
23:03 - put that in memo of i1 i2 and then we're
23:08 - gonna return that instead so this is
23:12 - gonna hopefully work let's see if it
23:13 - works
23:14 - for this particular test case and it
23:17 - does let's fixed test HTML so that we
23:21 - can you know test the other cases to
23:24 - hopefully this is going to be fast
23:25 - enough for for the other two cases too
23:29 - so let's see if it works here and it
23:32 - looks like it's working
23:33 - so in this case the expected result is I
23:37 - waiting for snow and the actual result
23:40 - is the same and it looks like it's
23:42 - working for the third case too okay so
23:47 - what I'm gonna do now is I'm gonna
23:49 - implement the rest of the algorithm here
23:51 - so that we can actually show the
23:52 - difference between the two given sets of
23:55 - text ok so here's what I have now as you
23:59 - can see you know we have for example in
24:01 - this example we have the original text
24:03 - the edited text we have the LCS but we
24:08 - also have the this view where we are
24:11 - showing the original text but we're also
24:14 - showing you know which parts of it have
24:16 - been deleted we show the edited text we
24:20 - show which parts have been added in blue
24:22 - text and the way I did it is like I
24:25 - explained earlier I compared the LCS of
24:28 - these two strings with the strings so
24:32 - for the original text I said okay what's
24:35 - the difference between I waiting for
24:37 - snow and I am waiting for snow and the
24:40 - difference is am so I highlighted that
24:44 - part in red and then I basically did the
24:47 - same thing you know compared LCS with
24:51 - the edited text and the difference is
24:54 - this part the bin and that part has been
24:58 - highlighted in blue using CSS okay so
25:02 - like I said earlier I'm gonna put all
25:04 - this code in CS nose without oil slash
25:07 - text so you can you know check how it
25:09 - works and play around with it and also I
25:12 - recently set up a discord server for
25:15 - this channel so you should come join us
25:17 - at C a snowsuit I owe slash D if you
25:20 - haven't yet and this was of course part
25:22 - of my build a startup series which you
25:25 - can find at CH dojo da io / start or
25:28 - through a link in the description below
25:31 - anyway thank you as always for watching
25:33 - my videos and I'll see you guys in the
25:35 - next one

Cleaned transcript:

hi everyone so recently as some of you know I've been working on a project where I try to start a real startup that's based on this app I'm making for learning languages and in this process I run into a problem where I needed to use dynamic programming to solve it so I'm going to show you what the problem was and how I solved it so like I explained it in one of my previous videos on this app I'm developing which I'm thinking about calling Edit dojo people are gonna write stuff in different languages and other people are gonna fix them or edit them for them so one person might write the breakfast I had today was awesome and someone else might edit them edit this too this at the professor I had today was awesome and the function I was trying to make is the function that shows the difference between these two sentences so given these two sentences we want to be able to say that you know this word has been deleted from the first centers and also this word and then these two words have been sort of added to the second sentence and there are a few different ways of going about it one is to compare these two sentences word for word that's what I've done and that's why you see you know these two words changed but another way to do this is to compare these two sentences character by character so if you take the approach the UI might look like this instead so here you can see that instead of showing the whole words being changed we're only saying okay you know this character o has been deleted and the same thing with this letter e so which one is a better approach well I think either one works but in my opinion the comparison by word approach is much easier to read so that's what I'm gonna use for English but the thing is for languages like Japanese there's no easy way to split a sentence by worse so I decided to use the comparison by character approach for languages like Japanese and in this video I'm gonna explain the comparison by character approach because it's much simpler to explain anyway whichever approach you decide to take this problem actually reduces to another problem called the longest common subsequence problem I already talked about it in one of my really old videos actually but let me explain what it is here again so in the longest common subsequence problem you're given two strings for example these two a b c d and a c DB you want to be able to find a common subsequence between these two strings that's the longest so in this particular example the answer would be this one a CD so as you can see this is a subsequence of the first string you know it's a CD right here and it's a subsequence of the second string as well a CD right here and there are usually multiple common subsequences between these two given strings in this example another common subsequence would be this one a B you know there's a B right here and there's a B right here in the second string as well but in this problem you want to be able to find the longest one of those common subsequences and again in this example the the answer is this one and sometimes there are multiple answers you know there are multiple mungus common subsequences but let's just say that here you know we just want to be able to find at least one of them and it doesn't matter which one we find okay now let me just quickly explain how we can apply this problem to solve the problem that we saw earlier so let's say that the original text is this one I am waiting and let's say that someone else fixed it to this one I've been waiting then what we can do is we can first find the longest common subsequence between these two strings that would be this one i spaced space waiting and then to find which parts of the first string has been deleted we can compare this string with the longest common subsequence this one which is basically the common part of these two strings and then when you do that you see that this part just am has been deleted from the first string because the common string ice space space waiting is right here and then what's left is just this part and then you can do the same thing to the second string to see which parts have been added to the second string so compare the common string with the second string and you see that the ports that have been added is this part and this part and then you know you can highlight those parts to get this text okay so that's going to be the idea of my solution of course the first step of going about this solution is to solve the longest common subsequence problem so let me show you how I would solve that part okay so I'm gonna write a function called LCS of these two strings and this function is going to return the longest common subsequence of these two strings and I'm gonna solve this problem recursively and one case of this recursive solution it's gonna be when the given two strings have the same first letter in this case a right here and in that case we'll say whatever the longest common subsequence of these two strings is it must have a as the first letter so it's sort of like taking off these two letters and then saying the longest common subsequence of these two strings is gonna be a concatenated with the longest common subsequence of these two strings b c d and c de b the rest of the strings so we can write that as the longest common subsequence of these two strings is going to be a concatenated with the longest common subsequence of the rest of the strings b c d and c da b and this might be actually a little bit hard to get your head around so I'd recommend you know playing with a few examples to see why this is actually the case anyway let's go to our next case that's when the given two strings don't have the same letter at the beginning we have B C D and then C D B for example in this case so in this case we're gonna try two things one is we're gonna take off the first letter of the first string and then we'll ask ourselves what's the longest common subsequence of the rest of the strings so CD and CD EB and then we're gonna do the same thing with the second string take off you know the first letter of the second string and then ask ourselves what's the longest common subsequence of BCD and dB and it turns out whichever is the longer common subsequence is going to be the longest common subsequence of the given two strings so we can informally write it as the longest common subsequence of these two strings b c d and c d eb is compare you know these two longest common subsequence CD and CD B and then B C D and D B so that's CD and CD b or b c d and d b right here and then just take the longer one of them I was just ready as Max again you know this might be a little bit hard to get your head around so I recommend you know playing around with a few examples here too now if you implement this function as is you need to create new strings every time we call this function so for example if you're given LC s of these two strings ABCD and s DB we'll need to create these two strings b c d and c DB to call this function recursively and that's pretty wasteful but we don't have to do that instead of doing that we're gonna pass in two new arguments that are going to specify which letters we're currently examining in these two strings so instead of saying you know LCS of a b c d and a c DB will say LCS of these two strings and then 0 0 and that's gonna mean we're examining this letter right here which has the index 0 and this letter right here whose index is also 0 and then when we call this function recursively instead of generating new strings we're just gonna change the indices so we'll say LCS of ABCD is DB and then 1 1 because now we're examining these two letters B and then C right here whose index is both 1 and we can do the same thing for this case as well instead of passing a b c d and c de be the original strings might be a b c d and a c DB and then you know we're passing 1 1 as we saw earlier and then instead of creating these two or these four strings we're just gonna change the indices again so this is gonna be like that max of LCS of the same strings and then 2 1 and then i will see s of the same strings and 1 2 ok so let me show you how i would implement this function recursively and i'm gonna show you that using pseudocode so like we saw earlier we're gonna write a function called LCS of s1 s2 the two strings and ione itwo the two indices of the letters that were examining and then outside this function we're gonna have to call this function with the two given strings and 0 0 because we're gonna start with the first letters anyway the first thing we're gonna do in our main function is we're gonna take care of the base case and that's when I 1 is equal to s1 s length or I 2 is equal to s2 slangs and this is sort of like saying what's the longest common subsequence between an empty string with another string and the answer is an empty string so we're gonna return an empty string from here and the next case that we need to take care of is when the current letters that were examining s1 square brackets i 1 and s2 square brackets I 2 are the same if that's the case we're going to return it's one of the current letter S one of I one it should be i one here concatenated with the longest common subsequence of s 1 s 2 I 1 + 1 and I 2 + 1 and if we haven't returned yet at this point that means that the current letters that we're examining are different so in that case we'll need to find 2 results without a and without B result a is going to be LCS of s 1 s 2 I 1 plus 1 and I 2 and then without B is going to be as LC s of s 1 s 2 I 1 and then I 2 plus 1 and then we're gonna have to compare the lengths of these two strings and then we turned a longer one so we can do that with if result a s length is longer than result B's length then we're going to return result a and otherwise we're gonna return result B okay so this function works this implementation works but it turns out it's very very inefficient and the reason is because we end up calling you know the same function LC s with exactly the same arguments over and over again depending on the strings so for example we might call LC s of s 1 s 2 2 3 over and over again depending on what the strings are and every time we call this function you know we need to recompute what the result is for for these particular arguments and this is where the idea of dynamic programming comes in you know dynamic programming says why not store the return value of this function with these particular arguments so that we can reuse it and so that's the idea let's see what the code is gonna look like ok so this is part of the dynamic programming solution code and it's pretty much exactly the same as what we saw earlier except for this additional argument that I added here called memo this is going to be a twodimensional array that's gonna store the return values of this function LCS and so before we call this function we're gonna have to initialize a new twodimensional array whose size is gonna be s 1 dot length by s 2 dot length and then the results or the return value of LC s of s 1 s 2 I 1 I 2 memo is going to be stored right here in this twodimensional array at the indices I 1 and I 2 and so you know outside of this function we're gonna have to initialize that and then call LC s with s 1 s 2 actually 0 0 and then memo let's just assume here that every element of this array is gonna be initialized to either undefined or no ok and once you have that after taking care of the base case we'll say if memo at the indices I 1 and I 2 is not undefined that means that we've already seen these particular arguments you know i1 and i2 and we've already stored the return value of this function with those arguments in memo at this at this location so we're just gonna return that by saying we turn memo square brackets I 1 and I 2 and what about this case when we haven't returned at this point and when the letters that we're examining are the same this case right here in that case instead of returning you know the thing that we saw earlier the first letter concatenated with LCS or the results of the next LCS call we're gonna store that a memo at the location that we saw earlier at I 1 and I 2 just like that memo skyrockets I 1 and I 2 is equal to this thing that we're gonna return and since we just store the return value of this function with these particular arguments a memo of i1 and i2 instead of computing it again we're just gonna return that just like that right here ok and to make this function complete you need to do the same thing basically for the second case when s1 square brackets I 1 is not equal to s2 square brackets I 2 so before you return the result you'll need to store it in memo and then return that instead okay so once you have all of that this function is going to be complete but what about the time complexity well just in case you're curious here it is suppose we write s once length as l and s twos length as M then the time complexity of this function is going to be this assuming that my analysis is correct it's going to be bigoh of L times M and if you're curious why that's the case I'd recommend watching my old video about the longest common subsequence and this is actually much better than the naive recursive solution that we saw earlier which has an exponential time Quebec City ok so that's the idea of this code but let me show you if we can actually implement it using javascript okay so here's the setup I have here I have this HTML file testa HTML for showing the test cases we have a few test cases here one of them is this one the original text is ABCD and the edited text is a fkd and the longest common subsequence between these two is ad so our function given these two strings should return ad so that's the expected result and the result of our function will come in here after actual result and our function right now just looks like this it's just a function that's called LCS that's going to take two strings s1 and s2 and returns a string so if I change this to hello we should see hello right here okay let's start by implementing the naive recursive approach I'm gonna create a new function called helper which we're gonna call recursively so this helper function is gonna take four arguments the two strings s1 and s2 and then the indexes the indices of the letters that were examining that should be zero zero at the beginning so let me define the functional helper here this is gonna take s1 s2 and they i1 and i2 and just for testing let's return hello to make sure that's showing on our HTML file here and by the way I'm gonna put the end result of my code today at CSD dojo da yo / text so you can play around with my code yourself anyway let me implement the rest of the recursive solution so the base case was when I 1 is equal to s ones length or s I 2 is equal to s tooth length we should return just an empty string and then the second case is if s1 square brackets i 1 or the current letter that we're examining is equal to s2 square brackets i 2 then we should return is 1 I 1 that's the current letter that we're examining concatenated with helper of s 1 is 2 I 1 plus 1 and then I 2 plus 1 and for the last case I would say first let result a be equal to helper of s 1 s 2 I 1 plus 1 and then I 2 and results B should be helper of s 1 s 2 I 1 and then I 2 plus 1 and then whichever is the longer we're gonna return us the results so I'll say if results is length is larger than results B's length then we're gonna return result a and else otherwise return result B okay so this should work let's see if it works by going back to the browser and when i refresh this actually this takes too long and the reason is because the naive recursive solution is you know very inefficient so too sort of fix that for now we have you know three test cases right one of them is pretty short but the other two are kind of long let me close this window for now so the two test cases that we have here pretty along the text I am waiting for in snow and the break the breakfast I had today was awesome so the naive recursive solution is efficient enough for the first case but not efficient enough for that two other cases so I'm gonna take them out just by changing the code here and then I'm gonna go back to the browser and when I open the file again I see the correct result okay let's now make this code more efficient by using the approach that we saw earlier so the first thing we want to do in this parent function LCS is we want to initialize a new two dimensional array called memo whose size is gonna be s once that length by its to that length in JavaScript there is a neat trick for doing that so let me just write it here first I'm going to write square brackets dot array is one's length this produces an array of length s one's length whose elements are going to be undefined and then I'm gonna say dot map e ro and then array s2 length so with this we can create a twodimensional array whose size is s1 start length by s2 style length after that we'll just need to pass this memo to this helper function so let's add memo here and then also here basically everywhere a helper is called so here here and here so this doesn't change anything algorithm eyes but let's just make sure that everything still works and it does so let's go back to the code editor and then let's keep going okay the next step is after taking care of that base case we'll say if memo I 1 I 2 is not exactly equal to undefined then we're just going to return that memo of i1 and i2 and then in the first case when s 1 i1 s 1 of I 1 is equal to s T of i2 we're gonna store this return value a memo of i1 and i2 and then we're gonna return that instead and we're gonna do the same thing here to we're going to first define a new variable called results and then instead of returning a result a and result be here I'm gonna put it here so results is equal to result a or result B and then before we return the result we're gonna put that in memo of i1 i2 and then we're gonna return that instead so this is gonna hopefully work let's see if it works for this particular test case and it does let's fixed test HTML so that we can you know test the other cases to hopefully this is going to be fast enough for for the other two cases too so let's see if it works here and it looks like it's working so in this case the expected result is I waiting for snow and the actual result is the same and it looks like it's working for the third case too okay so what I'm gonna do now is I'm gonna implement the rest of the algorithm here so that we can actually show the difference between the two given sets of text ok so here's what I have now as you can see you know we have for example in this example we have the original text the edited text we have the LCS but we also have the this view where we are showing the original text but we're also showing you know which parts of it have been deleted we show the edited text we show which parts have been added in blue text and the way I did it is like I explained earlier I compared the LCS of these two strings with the strings so for the original text I said okay what's the difference between I waiting for snow and I am waiting for snow and the difference is am so I highlighted that part in red and then I basically did the same thing you know compared LCS with the edited text and the difference is this part the bin and that part has been highlighted in blue using CSS okay so like I said earlier I'm gonna put all this code in CS nose without oil slash text so you can you know check how it works and play around with it and also I recently set up a discord server for this channel so you should come join us at C a snowsuit I owe slash D if you haven't yet and this was of course part of my build a startup series which you can find at CH dojo da io / start or through a link in the description below anyway thank you as always for watching my videos and I'll see you guys in the next one
