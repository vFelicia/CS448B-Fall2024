With timestamps:

00:00 - hey everyone in this video i'm gonna
00:02 - give you an introduction to
00:04 - an overview of quick sorts and by the
00:07 - way i recently restarted my patreon page
00:10 - so i would really appreciate it if you
00:12 - could check it out i'm gonna put a link
00:13 - to it in the description below
00:15 - anyway let's get started so suppose
00:18 - you're given an array of integers
00:20 - for example this one and your task is to
00:23 - sort it in the ascending order
00:25 - just like that and one approach you can
00:28 - use for this
00:28 - is quick sort quick sort implements a
00:32 - recursive function
00:33 - which we're going to call qs that takes
00:35 - three arguments
00:36 - the given array l and r l and
00:39 - r will be two integers that are going to
00:43 - represent
00:44 - the indexes that will show the section
00:47 - of the array that we want to sort
00:49 - so for example if you're given this
00:52 - array
00:53 - and if l happens to be 4
00:56 - the index of this element right here and
00:59 - r happens to be
01:00 - 6 the index of this element right here
01:04 - then after running this function with
01:06 - these particular arguments
01:08 - this array will be like this so
01:12 - the section of the array that's between
01:15 - l and r
01:16 - will be sorted just like that so if you
01:19 - want to sort the entire
01:20 - array using qs you just need to give the
01:23 - same array
01:24 - with l being 0 the index of the first
01:27 - element
01:28 - and r being 6 in this particular case
01:31 - the index of the last element and to
01:34 - implement this recursive function qs
01:38 - we'll first take care of the base case
01:41 - that's when
01:42 - l is greater than or equal to r
01:45 - if l is equal to r if they are pointing
01:49 - to the same element for example this one
01:52 - then that will mean that the section of
01:55 - the
01:56 - array that we want to sort has only one
01:58 - element
01:59 - that's already sorted so there's nothing
02:00 - to do and if
02:02 - l is greater than r
02:06 - it's sort of the same thing the section
02:09 - of the
02:09 - array that we want to sort has no
02:11 - elements so there's nothing to do
02:14 - and that means we can just return from
02:16 - this function
02:17 - okay so that's the base case but what
02:19 - about the recursive case
02:21 - for that let's take a look at this
02:23 - example here
02:24 - where we're given this particular array
02:26 - with l being 0
02:28 - and r being 6 or the index of the last
02:31 - element of this array
02:33 - in a recursive case we're going to do
02:36 - what's called
02:37 - partition i'm going to explain what it
02:40 - is in a second
02:41 - but for that we're going to use this
02:43 - function called partition
02:44 - that takes three arguments just like qs
02:48 - it's going to take r l and r
02:51 - and this is gonna do what's called
02:53 - partition
02:54 - for the array for the section between l
02:57 - and r
02:58 - so let me explain what it means exactly
03:00 - the first step
03:02 - for partitioning is to pick what's
03:04 - called
03:05 - a pivot i'm going to explain what it is
03:07 - in a second
03:08 - and there are different ways of choosing
03:10 - your pivot
03:11 - but one simple approach is to pick the
03:14 - last
03:15 - element as your pivot so that's this
03:17 - number right here in this particular
03:19 - case
03:20 - then the goal of this partition function
03:23 - is to divide this array into two
03:27 - groups the first group is going to be
03:29 - all the numbers that are less than the
03:32 - pivot
03:33 - so in this particular case that's these
03:35 - three numbers
03:36 - minus two minus one and zero
03:40 - and those numbers should come to the
03:42 - left
03:43 - of the pivot and the second group of
03:46 - the numbers that we're going to examine
03:49 - is going to be the numbers
03:50 - greater than the pivot so those are
03:53 - these three numbers
03:54 - 3 2 and 4 in this particular case
03:58 - and these three numbers should come
04:02 - to the right of the pivots
04:05 - and obviously the pivot should come in
04:07 - between
04:08 - those two groups of numbers so in this
04:11 - particular case
04:13 - after running the partition function the
04:15 - array
04:16 - should look like this as you can see
04:19 - after running the partition function
04:23 - the pivot will come to the center of the
04:26 - array and
04:28 - all the numbers less than the pivot are
04:31 - to the left of it
04:32 - and all the numbers greater or equal
04:35 - to the pivot are to the right of it
04:38 - and we don't care about the ordering of
04:41 - the numbers within each group
04:43 - these numbers happen to be sorted but as
04:46 - you can see these numbers
04:48 - in this group are not sorted either way
04:52 - another thing to note here
04:53 - is that we're going to write this
04:55 - partition function so that it's going to
04:58 - do the partitioning and then it's going
05:01 - to return
05:02 - the new index of the pivot
05:05 - so in this particular case that's
05:08 - right here and so it's going to return
05:12 - 3 or the index of the pivots
05:16 - and then we can store it in a new
05:18 - variable
05:19 - which we're going to call p here and i'm
05:22 - going to show you how to implement
05:23 - partition
05:25 - later but let's just here for now say
05:27 - that we already have this function
05:30 - so after partitioning the given section
05:34 - of the array we'll already know that the
05:37 - position
05:38 - of the pivot right here is correct
05:41 - so that means that this position isn't
05:44 - going to change
05:45 - after sorting this entire array so all
05:48 - we need to take
05:49 - care of after partitioning is this
05:52 - group of numbers and this group of
05:56 - numbers
05:57 - we need to sort this section and then
06:00 - this section
06:01 - and we can do that by calling qs on this
06:04 - section
06:04 - and then qs on this section we can do
06:07 - that
06:08 - with qs of r l and p minus 1.
06:12 - so here we're saying we're going to sort
06:16 - the section of the array between l
06:19 - which is right here and p minus 1
06:24 - which is right here and then we're going
06:27 - to do the same thing for the other
06:28 - section
06:30 - with q s of r p plus 1 and r
06:33 - so we're saying we're gonna sort the
06:36 - section over the array
06:37 - between p plus one and r
06:41 - and by repeating this process uh
06:43 - recursively we'll be able to
06:45 - sort the entire array now let's take a
06:47 - look at how
06:48 - partition might be implemented but
06:51 - before i show you some code
06:53 - i'm going to give you an overview of how
06:55 - it works
06:57 - and for that i'm going to use an example
07:00 - where we have an array of 11 elements
07:03 - just like this one
07:04 - and to explain it actually i'm going to
07:07 - jump into
07:08 - the middle of running this algorithm
07:10 - instead of at the beginning
07:13 - and i'm doing it that way because i
07:16 - think
07:16 - the middle part is easier to understand
07:19 - and then you know i'm going to explain
07:21 - the beginning part later anyway let's
07:23 - say here that we're trying to partition
07:25 - the entire array
07:27 - and our pivot is the last element
07:30 - 10 right here and to run this algorithm
07:34 - we're going to use two indexes
07:37 - j and i
07:40 - j will keep track of the current number
07:44 - that we're examining and this is going
07:46 - to be part of a for loop
07:48 - that we're going to use so that for loop
07:51 - is going to say
07:52 - move j from the beginning of this array
07:56 - up to the number that's right before
08:00 - the pivots and currently we're examining
08:04 - this number let's say and in each
08:07 - iteration of the for loop
08:09 - we want to make sure that all the
08:11 - numbers we've seen so far
08:13 - are separated into two groups the first
08:16 - group
08:16 - is the numbers that are less than the
08:18 - pivot
08:20 - and the second group is the numbers that
08:23 - are
08:23 - greater than or equal to the pivot
08:27 - and we want to do it in the way that i
08:30 - this index right here
08:31 - will always point to the last
08:35 - number out of the numbers less than
08:39 - the pivots in other words there are two
08:42 - conditions
08:43 - that we want to always satisfy the first
08:46 - one
08:47 - is that all the numbers from the
08:49 - beginning
08:50 - up to i are less than the pivot
08:53 - and the second one is that all the
08:55 - numbers between i and j
08:57 - not including i are greater than or
09:01 - equal to the pivot
09:02 - and like i said earlier we're currently
09:04 - examining this number
09:07 - and those two conditions are already
09:10 - satisfied
09:11 - because 12 is already greater than the
09:13 - pivot
09:14 - so we can move to the next number by
09:16 - incrementing j
09:18 - by 1. and at this point uh
09:22 - one of those conditions is not satisfied
09:24 - anymore
09:25 - and uh we can fix that by doing this
09:29 - we're gonna increment i
09:32 - by one or move i over here and then swap
09:36 - the values at i and j
09:39 - just like that and that way
09:42 - those two conditions are satisfied again
09:45 - so all the numbers
09:47 - up to i are less than the pivot and all
09:50 - the numbers
09:50 - after that up to j are greater than or
09:54 - equal to the pivots
09:56 - so we can keep going move j over here
10:00 - and since this number 16 is already
10:03 - greater than
10:04 - the pivot there is nothing to do so
10:08 - let's move j over here
10:11 - and as you can see the number at j
10:14 - is less than the pivot so we'll need to
10:17 - do the same thing
10:18 - uh increment i by one or move
10:22 - i over here and then swap the values
10:25 - at i and j just like that
10:31 - okay and let's uh finish this up
10:34 - by moving j over here or by
10:38 - incrementing j by one and then
10:41 - uh doing the same thing increment i
10:44 - by 1 and then swap other values at i and
10:47 - j
10:50 - all right and as you can see at this
10:52 - point
10:53 - this array has been grouped
10:56 - into two groups of numbers the number is
10:59 - less than the pivot
11:00 - and the numbers are greater than the
11:02 - pivot
11:03 - but the last thing we need to do is we
11:05 - need to make sure that the pivot
11:07 - is between those two groups we can do
11:10 - that
11:12 - by swapping the pivots
11:15 - with the value at
11:18 - i plus 1 this value right here
11:22 - so let's swap those two values just like
11:24 - that
11:26 - and then we're done partitioning like i
11:28 - said from
11:29 - our partition function we're supposed to
11:32 - return the
11:33 - index of the pivot so we can just return
11:36 - i plus 1 because that's the index of the
11:39 - pivot
11:40 - okay so now that we hopefully understand
11:43 - how this partition algorithm works
11:45 - let's take a look at some suit code uh
11:48 - like i said earlier we're gonna call
11:51 - this function
11:52 - partition and it's gonna take three
11:54 - arguments
11:56 - the given array l and r
11:59 - and this function is going to apply
12:01 - partition
12:02 - to the section of the array between l
12:05 - and
12:05 - r let's say here as an example
12:08 - that we're given this particular array
12:11 - with
12:11 - l being the beginning of the array
12:14 - or zero and r uh being the
12:18 - end of the array or six in this
12:20 - particular case
12:21 - and the first step of this function is
12:24 - going to be define the pivot
12:26 - and that's going to be the value at r or
12:29 - the last element
12:30 - of the section of the array that we are
12:33 - trying to partition
12:34 - and that's going to be 0 in this
12:36 - particular case
12:38 - and then we're going to define i
12:41 - to be o minus 1. in this particular case
12:45 - i will be initialized to minus 1.
12:49 - and then we're going to run a for loop
12:52 - for j from l this element
12:56 - up to r minus 1 the last
13:00 - index before the pivot and in
13:03 - each iteration of this for loop we're
13:06 - going to check
13:07 - if the current number that we're
13:08 - examining or
13:10 - r of j is
13:13 - less than the pivots
13:17 - if that's the case for example the
13:19 - current number
13:20 - we're examining minus 2 is less than the
13:23 - pivot which is 0.
13:25 - if that's the case then we're going to
13:27 - increment
13:29 - i by 1
13:32 - and then we're going to swap
13:35 - r of i and r of j
13:38 - so those two numbers happen to be the
13:41 - same number in this particular case
13:43 - so we're swapping this number by itself
13:46 - and
13:46 - nothing happens but let's continue with
13:49 - this for loop
13:51 - so after that we'll move j over here
13:55 - and since uh the current number that
13:58 - we're examining
13:59 - 3 is greater than or equal to pivot
14:03 - so nothing happens and so we move j
14:07 - over here and at that point
14:10 - this number is less than the pivot so
14:13 - we're going to move i
14:14 - over here and then we're going to swap
14:16 - the numbers at
14:17 - i and j and just like that we can keep
14:20 - going
14:21 - with this for loop until j
14:24 - is right here at that point
14:28 - our array is going to look like this uh
14:30 - j is going to be
14:31 - right here and i is going to be
14:35 - right here uh after that we want the
14:37 - people
14:38 - to be between those two groups of
14:40 - numbers
14:41 - and we can do that by swapping r of i
14:44 - plus 1
14:45 - this number right here 5 and
14:48 - our pivot r of r so
14:51 - that's this number and
14:54 - this number and once it's swapped
14:58 - 0 will come here and 5 will come
15:01 - here we just need to return uh
15:04 - i plus 1 the index of the pivots
15:07 - okay so that's my suit code
15:11 - but you can check my actual
15:13 - implementation in python and java
15:15 - at this url too okay so that's the quick
15:18 - sort algorithm
15:19 - but what about the time complexity to
15:22 - understand this
15:23 - we'll need to consider the best case the
15:26 - worst case
15:26 - as well as the average case so let's
15:29 - start with the
15:30 - worst case that's when the given array
15:33 - is already sorted like this one or
15:37 - when we have a lot of duplicates in the
15:39 - given array
15:40 - like this one and actually the time
15:42 - complexity
15:43 - of these two cases will be the same so
15:46 - let's just consider a case where the
15:49 - given array is already sorted
15:52 - for this particular example uh to sort
15:55 - this array with the qs function that we
15:57 - saw earlier
15:58 - we would call it with the given array 0
16:01 - and 6.
16:02 - so 0 would be right here at the
16:06 - beginning of the array
16:07 - and 6 would be the index of the last
16:09 - element
16:10 - of the array and the pivot will be this
16:13 - one
16:14 - and after running the partition function
16:17 - for the entire array
16:19 - actually what's going to happen is
16:22 - the pivot will stay here and all the
16:24 - elements
16:25 - will stay where they are so nothing is
16:28 - going to happen to this array
16:30 - and after finishing a partition
16:34 - we'll need to call qs for the rest
16:37 - of the array other than the pivots
16:40 - we can do that with qs of
16:43 - r and 0 and 5. and we end up
16:46 - doing the same sort of thing over and
16:48 - over again so we would call
16:50 - qs of r and zero and four after that and
16:53 - so on
16:53 - until we get down to qs of r uh
16:57 - zero and one so the pattern we see
17:00 - here is that the number of elements
17:03 - that we need to examine in the qs
17:05 - function starts at let's say
17:07 - n the number of elements in the entire
17:09 - array
17:10 - and then we get down to n minus 1
17:13 - and so on n minus 2 up until
17:17 - 1. so as i said this is the number of
17:20 - elements
17:21 - that we need to examine in the qs
17:23 - function each of these numbers
17:26 - but it's also the number of iterations
17:29 - that we need to go through
17:30 - in our main for loop to be precise
17:33 - you might say if we have n elements
17:36 - given to the qs function
17:38 - we'll need to go through n minus 1
17:42 - for loops in our partition function but
17:45 - it's roughly
17:46 - n so if you want to add up the total
17:49 - number of
17:50 - for loop iterations that we need to go
17:53 - through for this entire
17:55 - execution of the function then we can
17:58 - just add these numbers
17:59 - up so we get
18:02 - this one n times n plus 1 divided by 2
18:06 - which is o of n squared and that's why
18:09 - we get
18:09 - o n squared as the time complexity of
18:12 - the worst case scenario and what about
18:14 - the best case
18:15 - well the best case is
18:18 - every time we chose our pivot it happens
18:22 - to be
18:22 - the best choice so it means it happens
18:25 - to be
18:25 - at the median or the closest number to
18:28 - the median
18:29 - of the given section of the given array
18:32 - so as you can see in this particular
18:33 - case
18:34 - the number of integers less than
18:38 - the pivot is equivalent to the number of
18:42 - integers greater than the pivot in the
18:45 - best case scenario like that
18:47 - we would start with n elements that we
18:49 - need to deal with
18:50 - in our qs function and then
18:54 - in the subsequent cause of qs we would
18:57 - have to deal with
18:58 - n over two elements in one of the calls
19:00 - and n over two
19:02 - in the other one uh it's going to be
19:03 - slightly less than n over two
19:05 - uh but it's going to be about n over two
19:08 - and
19:09 - in the subsequent cause after that uh we
19:12 - would need to deal with n over
19:14 - four elements and so on uh until we get
19:18 - down to
19:19 - uh single elements and what's
19:22 - interesting here
19:23 - is if you look at each level
19:26 - if you look at the top level for example
19:29 - you can see that we would go through
19:32 - about
19:33 - n for loops in our partition
19:36 - function in this level
19:39 - and if you look at the second level we
19:42 - can do the same kind of analysis
19:44 - for uh this call
19:48 - in the partition function we would need
19:51 - to
19:52 - deal with n over 2 for loops and for
19:55 - this one we need to deal with n over 2
19:59 - for loops as well so the total number of
20:04 - loops that we need to go through for the
20:07 - second
20:08 - level is going to be of n
20:11 - as well or about n uh loops
20:15 - it's going to be the same thing with
20:18 - this level and
20:20 - this level as well
20:24 - and this kind of analysis will show you
20:27 - that
20:27 - uh executing everything on each level
20:30 - will take off and in time and you might
20:34 - say well how many levels do we have
20:37 - in this recursion tree well
20:40 - we can use the same kind of argument uh
20:43 - as the one i used in my binary search
20:47 - video
20:48 - to show that the number of levels here
20:51 - is going to be
20:53 - about log n or log 2 of n
20:56 - so basically what i'm saying here is
20:58 - that we have
20:59 - log n levels here and for each level
21:03 - and the time complexity is of n so
21:06 - to find the total time complexity for
21:08 - the best case scenario
21:10 - we can just multiply them together
21:13 - and we get of n log n
21:16 - so that's the time complexity for the
21:18 - best case scenario
21:20 - you might say what about the average
21:22 - case well it's more
21:24 - tricky to think about but given a few
21:27 - assumptions
21:28 - we can actually show that the time
21:30 - complexity for the average case
21:32 - is also of n log n
21:35 - and by the way those few assumptions are
21:38 - first that there are no duplicates so we
21:41 - don't have a case like this
21:43 - and second that the ordering of the
21:46 - array
21:46 - is random and i saw this proof
21:50 - in a book i used as a reference to make
21:53 - this video
21:54 - so in case you're curious about the
21:56 - proof i'll put a link to the book in the
21:58 - description below as well
22:00 - okay and before i go i wanted to mention
22:02 - a few things
22:03 - to note about the implementation details
22:08 - the first one is how to choose the pivot
22:12 - of course in our implementation we chose
22:14 - the last element
22:16 - but another method is to pick a random
22:19 - element as your pivot or equivalently
22:23 - you can before running our quicksort
22:26 - function
22:27 - you can reach shuffle the given array
22:30 - randomly
22:31 - and then pick the last element as the
22:33 - pivot
22:34 - and another method for choosing the
22:36 - pivot is called median of three
22:39 - the idea of this approach is instead of
22:42 - picking one
22:43 - element you would choose
22:46 - three elements randomly
22:49 - from the given section of the given
22:52 - array
22:53 - and then you would pick the median of
22:56 - those
22:57 - three numbers and that way you'll be
23:00 - able to decrease the probability
23:02 - that you would pick a bad pivot
23:05 - for the given section of the given array
23:08 - okay
23:08 - and the second thing i wanted to discuss
23:12 - is dealing with duplicates
23:15 - because as we saw quicksort doesn't
23:17 - perform well
23:18 - when there are a lot of duplicates in
23:20 - the given array
23:22 - one way to deal with this is called
23:25 - three-way quick sort in case you're
23:28 - curious about it i'm gonna
23:30 - put a link to a page that describes this
23:32 - method
23:33 - but the idea of this method is that
23:37 - instead of dividing the given section of
23:40 - the given array
23:41 - into two groups we divide it into three
23:44 - groups
23:45 - the first group is going to be the
23:47 - numbers less than the pivot
23:50 - the second group is going to be the
23:52 - numbers equal
23:54 - to the pivot and the third group is
23:56 - going to be
23:57 - the numbers greater than the pivot
24:00 - again in case you're curious about it
24:02 - i'm going to put a link to a page
24:04 - with more info about it in the
24:05 - description below anyway
24:08 - that's all i wanted to talk about in
24:10 - this video
24:11 - i hope you enjoyed this video and uh
24:15 - thank you as always for watching my
24:16 - videos i'll see you guys in the next one

Cleaned transcript:

hey everyone in this video i'm gonna give you an introduction to an overview of quick sorts and by the way i recently restarted my patreon page so i would really appreciate it if you could check it out i'm gonna put a link to it in the description below anyway let's get started so suppose you're given an array of integers for example this one and your task is to sort it in the ascending order just like that and one approach you can use for this is quick sort quick sort implements a recursive function which we're going to call qs that takes three arguments the given array l and r l and r will be two integers that are going to represent the indexes that will show the section of the array that we want to sort so for example if you're given this array and if l happens to be 4 the index of this element right here and r happens to be 6 the index of this element right here then after running this function with these particular arguments this array will be like this so the section of the array that's between l and r will be sorted just like that so if you want to sort the entire array using qs you just need to give the same array with l being 0 the index of the first element and r being 6 in this particular case the index of the last element and to implement this recursive function qs we'll first take care of the base case that's when l is greater than or equal to r if l is equal to r if they are pointing to the same element for example this one then that will mean that the section of the array that we want to sort has only one element that's already sorted so there's nothing to do and if l is greater than r it's sort of the same thing the section of the array that we want to sort has no elements so there's nothing to do and that means we can just return from this function okay so that's the base case but what about the recursive case for that let's take a look at this example here where we're given this particular array with l being 0 and r being 6 or the index of the last element of this array in a recursive case we're going to do what's called partition i'm going to explain what it is in a second but for that we're going to use this function called partition that takes three arguments just like qs it's going to take r l and r and this is gonna do what's called partition for the array for the section between l and r so let me explain what it means exactly the first step for partitioning is to pick what's called a pivot i'm going to explain what it is in a second and there are different ways of choosing your pivot but one simple approach is to pick the last element as your pivot so that's this number right here in this particular case then the goal of this partition function is to divide this array into two groups the first group is going to be all the numbers that are less than the pivot so in this particular case that's these three numbers minus two minus one and zero and those numbers should come to the left of the pivot and the second group of the numbers that we're going to examine is going to be the numbers greater than the pivot so those are these three numbers 3 2 and 4 in this particular case and these three numbers should come to the right of the pivots and obviously the pivot should come in between those two groups of numbers so in this particular case after running the partition function the array should look like this as you can see after running the partition function the pivot will come to the center of the array and all the numbers less than the pivot are to the left of it and all the numbers greater or equal to the pivot are to the right of it and we don't care about the ordering of the numbers within each group these numbers happen to be sorted but as you can see these numbers in this group are not sorted either way another thing to note here is that we're going to write this partition function so that it's going to do the partitioning and then it's going to return the new index of the pivot so in this particular case that's right here and so it's going to return 3 or the index of the pivots and then we can store it in a new variable which we're going to call p here and i'm going to show you how to implement partition later but let's just here for now say that we already have this function so after partitioning the given section of the array we'll already know that the position of the pivot right here is correct so that means that this position isn't going to change after sorting this entire array so all we need to take care of after partitioning is this group of numbers and this group of numbers we need to sort this section and then this section and we can do that by calling qs on this section and then qs on this section we can do that with qs of r l and p minus 1. so here we're saying we're going to sort the section of the array between l which is right here and p minus 1 which is right here and then we're going to do the same thing for the other section with q s of r p plus 1 and r so we're saying we're gonna sort the section over the array between p plus one and r and by repeating this process uh recursively we'll be able to sort the entire array now let's take a look at how partition might be implemented but before i show you some code i'm going to give you an overview of how it works and for that i'm going to use an example where we have an array of 11 elements just like this one and to explain it actually i'm going to jump into the middle of running this algorithm instead of at the beginning and i'm doing it that way because i think the middle part is easier to understand and then you know i'm going to explain the beginning part later anyway let's say here that we're trying to partition the entire array and our pivot is the last element 10 right here and to run this algorithm we're going to use two indexes j and i j will keep track of the current number that we're examining and this is going to be part of a for loop that we're going to use so that for loop is going to say move j from the beginning of this array up to the number that's right before the pivots and currently we're examining this number let's say and in each iteration of the for loop we want to make sure that all the numbers we've seen so far are separated into two groups the first group is the numbers that are less than the pivot and the second group is the numbers that are greater than or equal to the pivot and we want to do it in the way that i this index right here will always point to the last number out of the numbers less than the pivots in other words there are two conditions that we want to always satisfy the first one is that all the numbers from the beginning up to i are less than the pivot and the second one is that all the numbers between i and j not including i are greater than or equal to the pivot and like i said earlier we're currently examining this number and those two conditions are already satisfied because 12 is already greater than the pivot so we can move to the next number by incrementing j by 1. and at this point uh one of those conditions is not satisfied anymore and uh we can fix that by doing this we're gonna increment i by one or move i over here and then swap the values at i and j just like that and that way those two conditions are satisfied again so all the numbers up to i are less than the pivot and all the numbers after that up to j are greater than or equal to the pivots so we can keep going move j over here and since this number 16 is already greater than the pivot there is nothing to do so let's move j over here and as you can see the number at j is less than the pivot so we'll need to do the same thing uh increment i by one or move i over here and then swap the values at i and j just like that okay and let's uh finish this up by moving j over here or by incrementing j by one and then uh doing the same thing increment i by 1 and then swap other values at i and j all right and as you can see at this point this array has been grouped into two groups of numbers the number is less than the pivot and the numbers are greater than the pivot but the last thing we need to do is we need to make sure that the pivot is between those two groups we can do that by swapping the pivots with the value at i plus 1 this value right here so let's swap those two values just like that and then we're done partitioning like i said from our partition function we're supposed to return the index of the pivot so we can just return i plus 1 because that's the index of the pivot okay so now that we hopefully understand how this partition algorithm works let's take a look at some suit code uh like i said earlier we're gonna call this function partition and it's gonna take three arguments the given array l and r and this function is going to apply partition to the section of the array between l and r let's say here as an example that we're given this particular array with l being the beginning of the array or zero and r uh being the end of the array or six in this particular case and the first step of this function is going to be define the pivot and that's going to be the value at r or the last element of the section of the array that we are trying to partition and that's going to be 0 in this particular case and then we're going to define i to be o minus 1. in this particular case i will be initialized to minus 1. and then we're going to run a for loop for j from l this element up to r minus 1 the last index before the pivot and in each iteration of this for loop we're going to check if the current number that we're examining or r of j is less than the pivots if that's the case for example the current number we're examining minus 2 is less than the pivot which is 0. if that's the case then we're going to increment i by 1 and then we're going to swap r of i and r of j so those two numbers happen to be the same number in this particular case so we're swapping this number by itself and nothing happens but let's continue with this for loop so after that we'll move j over here and since uh the current number that we're examining 3 is greater than or equal to pivot so nothing happens and so we move j over here and at that point this number is less than the pivot so we're going to move i over here and then we're going to swap the numbers at i and j and just like that we can keep going with this for loop until j is right here at that point our array is going to look like this uh j is going to be right here and i is going to be right here uh after that we want the people to be between those two groups of numbers and we can do that by swapping r of i plus 1 this number right here 5 and our pivot r of r so that's this number and this number and once it's swapped 0 will come here and 5 will come here we just need to return uh i plus 1 the index of the pivots okay so that's my suit code but you can check my actual implementation in python and java at this url too okay so that's the quick sort algorithm but what about the time complexity to understand this we'll need to consider the best case the worst case as well as the average case so let's start with the worst case that's when the given array is already sorted like this one or when we have a lot of duplicates in the given array like this one and actually the time complexity of these two cases will be the same so let's just consider a case where the given array is already sorted for this particular example uh to sort this array with the qs function that we saw earlier we would call it with the given array 0 and 6. so 0 would be right here at the beginning of the array and 6 would be the index of the last element of the array and the pivot will be this one and after running the partition function for the entire array actually what's going to happen is the pivot will stay here and all the elements will stay where they are so nothing is going to happen to this array and after finishing a partition we'll need to call qs for the rest of the array other than the pivots we can do that with qs of r and 0 and 5. and we end up doing the same sort of thing over and over again so we would call qs of r and zero and four after that and so on until we get down to qs of r uh zero and one so the pattern we see here is that the number of elements that we need to examine in the qs function starts at let's say n the number of elements in the entire array and then we get down to n minus 1 and so on n minus 2 up until 1. so as i said this is the number of elements that we need to examine in the qs function each of these numbers but it's also the number of iterations that we need to go through in our main for loop to be precise you might say if we have n elements given to the qs function we'll need to go through n minus 1 for loops in our partition function but it's roughly n so if you want to add up the total number of for loop iterations that we need to go through for this entire execution of the function then we can just add these numbers up so we get this one n times n plus 1 divided by 2 which is o of n squared and that's why we get o n squared as the time complexity of the worst case scenario and what about the best case well the best case is every time we chose our pivot it happens to be the best choice so it means it happens to be at the median or the closest number to the median of the given section of the given array so as you can see in this particular case the number of integers less than the pivot is equivalent to the number of integers greater than the pivot in the best case scenario like that we would start with n elements that we need to deal with in our qs function and then in the subsequent cause of qs we would have to deal with n over two elements in one of the calls and n over two in the other one uh it's going to be slightly less than n over two uh but it's going to be about n over two and in the subsequent cause after that uh we would need to deal with n over four elements and so on uh until we get down to uh single elements and what's interesting here is if you look at each level if you look at the top level for example you can see that we would go through about n for loops in our partition function in this level and if you look at the second level we can do the same kind of analysis for uh this call in the partition function we would need to deal with n over 2 for loops and for this one we need to deal with n over 2 for loops as well so the total number of loops that we need to go through for the second level is going to be of n as well or about n uh loops it's going to be the same thing with this level and this level as well and this kind of analysis will show you that uh executing everything on each level will take off and in time and you might say well how many levels do we have in this recursion tree well we can use the same kind of argument uh as the one i used in my binary search video to show that the number of levels here is going to be about log n or log 2 of n so basically what i'm saying here is that we have log n levels here and for each level and the time complexity is of n so to find the total time complexity for the best case scenario we can just multiply them together and we get of n log n so that's the time complexity for the best case scenario you might say what about the average case well it's more tricky to think about but given a few assumptions we can actually show that the time complexity for the average case is also of n log n and by the way those few assumptions are first that there are no duplicates so we don't have a case like this and second that the ordering of the array is random and i saw this proof in a book i used as a reference to make this video so in case you're curious about the proof i'll put a link to the book in the description below as well okay and before i go i wanted to mention a few things to note about the implementation details the first one is how to choose the pivot of course in our implementation we chose the last element but another method is to pick a random element as your pivot or equivalently you can before running our quicksort function you can reach shuffle the given array randomly and then pick the last element as the pivot and another method for choosing the pivot is called median of three the idea of this approach is instead of picking one element you would choose three elements randomly from the given section of the given array and then you would pick the median of those three numbers and that way you'll be able to decrease the probability that you would pick a bad pivot for the given section of the given array okay and the second thing i wanted to discuss is dealing with duplicates because as we saw quicksort doesn't perform well when there are a lot of duplicates in the given array one way to deal with this is called threeway quick sort in case you're curious about it i'm gonna put a link to a page that describes this method but the idea of this method is that instead of dividing the given section of the given array into two groups we divide it into three groups the first group is going to be the numbers less than the pivot the second group is going to be the numbers equal to the pivot and the third group is going to be the numbers greater than the pivot again in case you're curious about it i'm going to put a link to a page with more info about it in the description below anyway that's all i wanted to talk about in this video i hope you enjoyed this video and uh thank you as always for watching my videos i'll see you guys in the next one
