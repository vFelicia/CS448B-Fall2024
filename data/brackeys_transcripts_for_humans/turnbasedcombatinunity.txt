With timestamps:

00:00 - - In this video we'll
have a look at creating
00:01 - one of the classics of gaming.
00:03 - Turn-based combat.
00:04 - Turn-based battle systems
have been part of gaming
00:07 - since the very beginning.
00:08 - And games like Civilization,
Pokemon, and Final Fantasy,
00:12 - are known for this
particular style of combat.
00:14 - So let's try creating a
simple, yet solid turn-based
00:17 - combat system in Unity.
00:19 - But first,
00:20 - special thanks to InfinityPBR
for his support on Patreon.
00:23 - And this video is sponsored by Milanote.
00:25 - Milanote is a tool for
organising your creative projects
00:28 - into free-form visual boards.
00:30 - It can be used for any creative project,
00:32 - but it's particularly
well suited for the messy,
00:35 - early stages of video game development.
00:37 - It's just a perfect
place to store your ideas
00:39 - and make sense of them as they grow.
00:41 - You can get started
with Milanote for free.
00:43 - And I've actually used it to plan out
00:45 - the turn-based battle system
we're going to be making
00:47 - in this video.
00:48 - In fact, let me just jump
right in and show you.
00:50 - So as you can see,
00:51 - I've gone ahead and set
up this board in Milanote
00:52 - on creating a turn-based battle system.
00:54 - And I've gone ahead and
created four columns.
00:57 - One for the UI.
00:58 - As you can see this links
to a separate board.
01:01 - And in here we have a bunch
of concept art for the UI.
01:05 - And I've been really inspired by Pokemon,
01:07 - especially some of the newer
versions with a bit more colour.
01:10 - And of course the old Final Fantasy games.
01:12 - Also I have a to do list for the UI.
01:14 - And as you can see,
01:15 - I've gone ahead and
crossed all of them out.
01:17 - And that's actually because
I prepared the UI beforehand.
01:20 - It's really, really simple.
01:21 - In fact, let me just go into
Unity here and show you.
01:24 - All I have here
01:25 - is just the main camera
with the green background.
01:27 - And then I have a UI canvas.
01:29 - And in here we have an enemy battle HUD.
01:32 - Which is just an image with
a name text, a LevelText,
01:36 - as well as a UI slider for the HP.
01:40 - And I've simply copied that
for the player battle HUD.
01:43 - As well as created a dialogue panel.
01:45 - Which again is just an image
with a dialogue text object.
01:49 - As well as two buttons,
01:50 - one for attacking, and one for healing.
01:53 - If you've never worked
with UI in Unity before,
01:55 - don't worry we of course
have plenty of videos
01:57 - on the subject that will teach you
01:58 - how to create simple UI like this.
02:00 - I've gone ahead and put one of them
02:02 - inside of the board here actually,
02:03 - and we'll have links to
plenty in the description.
02:06 - I also have a column for the environment.
02:08 - I want to keep it simple.
02:09 - Just have two units,
a player and an enemy.
02:12 - And remember you can always add more
02:14 - to the system afterwards.
02:16 - So I've gone ahead and created
a simple background already,
02:18 - as you can see.
02:19 - We just need to add two battle stations.
02:21 - Which is what I've chosen to call
02:23 - these two patches of grass here.
02:25 - So inside of Unity,
02:26 - all we need to do is just
find a sprite that we like.
02:29 - I've gone ahead and created
02:30 - a simple grass patch sprite here.
02:32 - And I'll of course include all sprites
02:34 - along with the finished project
in the description as well.
02:37 - So let's just go ahead and drag this in.
02:38 - And as you can see, that
creates a sprite renderer.
02:41 - I don't want this to be UI,
02:42 - I want it to be an actual game object.
02:45 - And let's just place it
right above our HUD here.
02:48 - And let's duplicate it and
move one down here as well.
02:51 - I'm also just going to select these two
02:53 - and set their order in layer to minus 10.
02:54 - This way when we place in units,
02:57 - they're actually going to appear on top.
03:00 - Let's rename the first battle station
03:01 - to EnemyBattleStation.
03:03 - And the second one to PlayerBattleStation.
03:07 - And if we have a look in our game view,
03:08 - that looks really cool.
03:10 - The only thing that I'll note
03:11 - about the way that I've set up the UI
03:13 - is that if we select our canvas.
03:15 - As you can see,
03:16 - I've set the UI scale mode
to scale with screen size.
03:19 - And this just means that
if we resize our game view,
03:22 - our UI is going to scale with it.
03:24 - Which is really nice in this case.
03:26 - So we have now added
our two battle stations
03:28 - and we can check that off as well.
03:30 - And I've also gone ahead
and created a column
03:33 - for gameplay.
03:34 - Our combat is of course,
going to be turn-based.
03:36 - And what this means is that we're handling
03:39 - one turn at a time.
03:40 - In other words,
03:41 - we can introduce the
concept of a game state.
03:44 - So in my game I want to have five states.
03:47 - You can easily add more
for increased complexity,
03:50 - but I think these five are
pretty good starting point.
03:53 - We have a start state.
03:54 - This initialises to combat
and sets up all the units.
03:58 - We'll then have a player turn,
03:59 - where the player can choose
between different actions.
04:02 - After that we'll have an enemy turn,
04:04 - where the enemy chooses their actions.
04:06 - And we'll loop between these two
04:08 - until the game is either won or lost.
04:11 - We also make sure that whenever
we transition from one state
04:14 - to another, for example
the player takes its turn.
04:16 - We then want to make sure
to leave plenty of time
04:18 - for the player to take in what's happening
04:20 - before we transition to the next state.
04:23 - So that is kind of the basis
04:24 - of how our gameplay should work.
04:25 - In fact, we can see it in
action in this GIF from Pokemon.
04:28 - So that is kind of the basics
04:30 - of how we want our gameplay to work.
04:32 - Now how do we lay this out with logic?
04:34 - Well, if we have a look
at the core systems
04:36 - that we're going to need,
04:37 - we're definitely going to
need some kind of unit script
04:39 - that we can put on the enemy
04:41 - and the player.
04:42 - That has information about their stats,
04:44 - such as HP and damage.
04:46 - As well as name and level and so on.
04:48 - We'll also have a battle system script,
04:51 - which handles all of our game states.
04:53 - And finally,
04:54 - we'll have a battle HUD script
04:55 - that is responsible for
updating our unit UI.
04:58 - In this example,
04:59 - we give the player two actions.
05:00 - An attack action and a heal action,
05:02 - but you can of course add more.
05:04 - All right so with that explanation,
05:05 - that's jump right into it.
05:07 - And let's have a look at
creating our first core system,
05:09 - which is the unit.
05:10 - So inside of Unity,
05:11 - let's start by creating our enemy.
05:13 - Let's right- click and go Create Empty
05:15 - to create a new object.
05:16 - Let's call it Enemy.
05:18 - Let's reset the transform.
05:19 - And if we just have a look
in our scene view here,
05:22 - we can now see that
this is an empty object.
05:24 - I'm just going to go
ahead and place it on top
05:26 - of the battle station so that we can see
05:28 - what it's going to look like.
05:29 - Let's then add a sprite to our enemy.
05:31 - So I'm going to go under Sprites,
05:33 - and I have one here called Dwayne.
05:35 - And I'm simply going to take Dwayne
05:36 - and drag him under the enemy object.
05:38 - As you can see,
05:39 - we'll need to reset the
transform again here.
05:41 - And I want to move him up to make sure
05:42 - that he's kind of standing on
top of the pivot point here.
05:46 - So that once we spawn him in
05:48 - on top of the battle station,
05:50 - he's going to be actually standing on it.
05:52 - And it's not just going to
snap to the centre of him,
05:55 - which would look really weird.
05:57 - Remember when doing this
to always be in pivot mode.
05:59 - If you're in centre,
06:00 - you won't be able to see the difference.
06:02 - We then go ahead and create
a unit script on our enemy.
06:05 - Let's hit Add Component.
06:06 - Let's type Unit and hit Create and Add.
06:09 - And let's double-click to
open this up in Visual Studio.
06:12 - And this script is actually
going to be really simple.
06:14 - We can go ahead and remove
our two functions here.
06:16 - We don't need those.
06:18 - Instead what we want
are a bunch of variables
06:20 - describing our unit.
06:22 - So let's create a public
string with the unit name.
06:25 - Let's have a public int
with the unit level.
06:29 - And let's also add in damage.
06:30 - So we'll create a public int
with the amount of damage
06:33 - our unit we'll be able to do.
06:35 - As was a public int for the max HP.
06:39 - And let's also have
one for our current HP.
06:42 - This way we can keep track
of our HP during the fight.
06:45 - And if our unit is maybe already damaged
06:47 - when it enters the fight,
06:48 - we'll be able to control that as well.
06:51 - So let's save that.
06:52 - Go back into Unity.
06:53 - And right away we can
fill out these variables.
06:55 - So the unit name here
is going to be The Rock.
06:58 - Let's give it a level of say two.
07:01 - A damage of five.
07:02 - Let's set the max HP to 30,
07:05 - and the current HP to 30 as well.
07:08 - All right so now that
we've created our enemy,
07:10 - we can go out and turn him into a prefab.
07:12 - So let's just drag him
into the project panel.
07:15 - And there we go,
07:16 - we've now made a prefab out of him.
07:17 - And we can go ahead and
remove him from the scene.
07:20 - The reason we're doing this
is that we want to be able
07:22 - to load in different units
07:24 - depending on who we're fighting.
07:25 - And let's actually go ahead
and do the exact same thing
07:28 - with our player.
07:29 - In fact,
07:30 - we can just use the enemy here as a base.
07:31 - So let's go ahead and
rename him to Player.
07:34 - Let's move him down
here to where the player
07:36 - is supposed to stand.
07:37 - Let's drag him into the
project panel as well.
07:40 - And this way we can create
a new original prefab.
07:43 - There we go.
07:44 - So we now have both an
enemy and a player prefab.
07:46 - And in fact, we can double-click
on this player prefab
07:48 - to go into prefab editing mode,
07:50 - which is pretty cool.
07:51 - And here we can remove the Dwayne graphic
07:54 - and let's instead dragging a rock.
07:56 - I think the players should be a rock.
07:58 - That's just inherently cool.
07:59 - And let's reset that transform here.
08:02 - Let's drag it up and place it
08:03 - so that it kind of aligns
with the centre of our object.
08:07 - There we go.
08:07 - And let's go ahead and
rename the unit here
08:10 - to Actual Rock.
08:12 - Let's set the unit level 999.
08:14 - This is a beefy rock.
08:16 - We'll set the damage to 10.
08:18 - The max HP to 25.
08:21 - And let's say our current HP is only 20.
08:23 - So we've taken five damage
before this fight started.
08:26 - And let's exit prefab mode up here.
08:28 - And we can now remove this
prefab from the scene as well.
08:32 - Awesome.
08:33 - So with that,
08:33 - we've actually gone in
and created both our enemy
08:35 - and our player units.
08:37 - We'll add a tiny bit more
to the unit script itself,
08:40 - but the base of it is there.
08:42 - And we can now move on
to our battle system
08:44 - and defining all of our game states.
08:47 - So let's go into Unity.
08:49 - Let's create a new empty object.
08:51 - Let's reset the transform
08:52 - and let's name this Battle System.
08:55 - Let's drag it to the top here
08:57 - so we can always see it.
08:58 - And let's add a new component
08:59 - and call it Battle System.
09:02 - We'll hit Create and Add
09:03 - and open it up in Visual Studio.
09:04 - And we're going to need
our Start function,
09:06 - but we can definitely get rid of Update.
09:08 - Now before we get started
on an actual logic here,
09:11 - we need to define the different states
09:13 - that our game can be in.
09:14 - And to do this
09:15 - we'll use something called
enums or enumerations.
09:18 - These are perfect because they allow us
09:20 - to define different states,
09:21 - and then create a variable
09:23 - that can always be only
one of those states.
09:25 - So we'll start by defining them.
09:27 - We'll create a public enum up here.
09:29 - Notice that I'm doing
this outside of the class.
09:32 - And let's call it BattleState.
09:34 - We'll then open and close
some curly brackets.
09:37 - And a lot of people put a semi-colon here.
09:39 - You should not do that
09:41 - because we are not
calling a function here.
09:43 - We're defining an enum.
09:44 - And in here we'll put a START state.
09:47 - We'll put a PLAYERTURN state.
09:49 - An ENEMYTURN.
09:50 - A WON and a LOST state.
09:52 - And now inside of our battle system,
09:54 - what we can do is now create
a public battle state,
09:58 - and just call it state.
10:00 - And now we can set this state
equal to whatever we want.
10:02 - So inside of our Start,
10:04 - once we load up the battle scene here.
10:06 - We're simply going to set
state equal to BattleState.
10:10 - And here we get all the states.
10:12 - And we of course want
to choose START here.
10:14 - So you can see how easy
it is to keep track
10:16 - of our states this way.
10:17 - And in fact, if we save this
script and go into Unity,
10:20 - we'll even be able to
preview our different states
10:23 - and see what state we're currently in
10:25 - inside the inspector.
10:26 - Really, really cool.
10:28 - So now that we are in our start state,
10:30 - we can go ahead and set up the battle.
10:31 - So let's create a SetupBattle function.
10:35 - And let's create that down here.
10:37 - Void.
10:38 - SetupBattle.
10:39 - And in here we of course
want to spawn in our units.
10:41 - So we'll create a reference to them.
10:43 - We'll create a public game object.
10:45 - Let's call it player prefab.
10:48 - And we'll create a public game object,
10:50 - enemyPrefab.
10:52 - And where do we want to spawn these in?
10:53 - Well we want to spawn them
in on our battle stations.
10:56 - So we'll create references to those too.
10:58 - We'll create a public transform.
11:00 - And this is just a
transform, not a game object.
11:02 - Because we just need the location
of these battle stations,
11:05 - not the entire object.
11:07 - And this is going to be
the player battle station.
11:09 - And we'll of course also have one
11:10 - for the enemy battle station.
11:13 - Then when we set up the battle,
11:14 - we can go ahead and instantiate
11:16 - or spawn in a player prefab.
11:20 - As child of, and on top of,
11:22 - the player battle station.
11:24 - There we go.
11:25 - And we can do the same
thing with our enemy prefab
11:28 - on top of the enemy battle station.
11:31 - And if we save that and go into Unity,
11:33 - we can drag in our player prefab,
11:36 - our enemy prefab,
11:37 - as well as our player battle station,
11:39 - and our enemy battle station.
11:41 - And on our prefabs here
11:42 - we want to to make sure
that their position
11:44 - is set to see zero, zero, zero.
11:46 - We'll do that with the enemy as well.
11:48 - Just so that when we spawn them in,
11:49 - they'll be right at the
centre of our battle stations.
11:52 - And if we now hit play,
11:53 - as you can see, we're now
spawning in our units.
11:56 - Awesome.
11:57 - Of course currently we don't know anything
11:59 - about our units through script.
12:01 - We're just spawning in the objects
12:03 - and nothing is really happening on the UI.
12:05 - So let's go ahead and change that.
12:07 - So, first of all,
12:08 - we can get a reference
12:09 - to what we're spawning in
12:10 - by creating a game object variable here.
12:13 - We'll call it the playerGO
12:14 - or player game object
12:15 - and set it equal to the game
object that we spawn in.
12:18 - And what we can then do
12:20 - is actually get the unit
component on that game object.
12:23 - So we'll do playerGO.GetComponent
12:27 - of type Unit.
12:28 - And we want to go ahead and
store this in a variable
12:30 - because we'll be referencing the unit
12:32 - a bunch of times whenever
we need information
12:34 - about health and so on.
12:36 - So let's go to the top here
and create two variables.
12:38 - These don't need to be public.
12:39 - We don't need to see
them in the inspector.
12:41 - We'll just create a Unit, playerUnit.
12:43 - And a Unit, enemyUnit.
12:46 - And then down here we
can simply set playerUnit
12:50 - equal to player game
object.Getcomponent Unit.
12:53 - And we'll do the exact
same thing with our enemy.
12:55 - So game object,
12:56 - enemyGO equals the instantiated object.
12:59 - And we'll set enemyUnit
13:02 - equal to enemyGO.getComponent
of type Unit.
13:06 - There we go.
13:07 - And what this allows us to do
13:08 - is now get information about our units.
13:10 - In fact, let's go ahead and
display the enemy unit name
13:12 - to the player.
13:13 - We access this by simply
going enemyUnit.unitName.
13:17 - So let's go ahead and put this unit name
13:19 - inside of our dialogue text right here.
13:22 - Of course to do that,
13:23 - we need a reference to
this text object here.
13:27 - So inside of our script, we go to the top.
13:30 - And because this is UI,
13:31 - we need to include the
UnityEngine.UI namespace.
13:34 - And we can then create
a public text variable
13:38 - called dialogue text.
13:40 - Then down here, we can simply set
13:41 - dialogueText.text
13:44 - equal to enemyUnit.unitName.
13:47 - And let's just add a tiny bit to this.
13:49 - Let's just say a wild.
13:51 - And then we'll insert the enemy unit name,
13:54 - approaches.
13:55 - There we go.
13:56 - So if we save this now and go into Unity,
13:59 - select our battle system
14:01 - and remember to drag in our dialogue text.
14:03 - And hit play.
14:04 - A wild The Rock approaches.
14:07 - Awesome so we're now
gathering all this information
14:09 - about the units that we're loading in.
14:11 - And we have total control
or where we place it.
14:14 - So let's go ahead and
place this information
14:15 - on the HUD overlays.
14:17 - And we could do all this
through the BattleSystem script,
14:20 - but that would get very long.
14:21 - So let's go ahead and split
it into a separate one
14:23 - that we place on our battle
HUD objects themselves.
14:26 - So I'm assuming you're going
to select like these two.
14:28 - And that's create a battle HUD script.
14:31 - Again let's double-click it to open it up.
14:33 - Again, we can go ahead and
remove the two functions here.
14:36 - Let's create a public Text.
14:39 - And again, remember this is UI
14:41 - so we need to use UnityEngine.UI.
14:44 - And this is going to
reference our nameText object
14:47 - on the UI.
14:48 - We'll do the same thing
with our levelText.
14:51 - And we'll also create a public slider
14:53 - to control our HP slider.
14:55 - We then create a function
14:56 - that is going to update these UI elements.
14:58 - So let's create a public void.
15:00 - And we're making this public
15:01 - so that we can call it from
within our BattleSystem script.
15:05 - And it's just name it
something like SetHUD.
15:07 - Of course we need some information
15:08 - about what we should set it to.
15:09 - So let's just take in a
unit and call it unit.
15:13 - This way we have access to
all the information we need.
15:15 - And here we can then
just set nameText.text
15:19 - equal to Unit.unitName.
15:21 - We can set levelText.text
equal to let's put level.
15:26 - And then plus the unit.unitLevel.
15:29 - For the HP slider,
15:30 - we can set the maxValue
equal to the unit.maxHP.
15:36 - And hpSlider.value we'll set equal
15:40 - to unit.current HP.
15:42 - There you go.
15:43 - Of course,
15:44 - we probably want to update the HP
15:45 - a bunch of times every time
someone attacks or heals.
15:48 - And so let's just create
a quick function for that
15:50 - that only updates the HP.
15:52 - So let's do a public void.
15:55 - SetHP.
15:56 - This is simply going to take in an int
15:57 - with the HP.
15:59 - And here we can just set hpSlider.value
16:02 - equal to that value.
16:04 - Cool.
16:04 - So that's actually it for a battle HUD.
16:06 - All we need to do now is
go into our BattleSystem.
16:09 - And in here we need to create a reference
16:11 - to each of the battle HUDs.
16:13 - One for the player HUD
and one for the enemy HUD.
16:16 - So we'll just create a public BattleHUD,
16:19 - call it playerHUD.
16:21 - And a public BattleHUD called enemyHUD.
16:24 - And inside of our SetupBattle function,
16:26 - we then say playerHUD.SetHUD,
16:30 - and we'll pass in the playerUnit.
16:33 - And we'll do the same thing for the enemy.
16:34 - So enemyHUD.SetHUD enemyUnit.
16:38 - There we go.
16:39 - Let's save this, go into Unity.
16:40 - And you can see both of the battle HUDs
16:42 - now have some variables
that we need to fill out.
16:43 - So for the enemy battle HUD
16:45 - let's drag in the NameText.
16:46 - LevelText.
16:48 - And the slider.
16:49 - And we'll do the same thing
for the PlayerBattleHUD.
16:52 - And for our battle system
16:53 - we just need to drag into two battle HUDs.
16:56 - Awesome.
16:57 - If we now hit Play,
16:57 - we can see immediately our HUD updates
17:00 - to show the names of our two units,
17:02 - the level, as well as our current HP.
17:04 - Awesome.
17:06 - So we can check off our battle HUD here.
17:08 - And I think it's time
17:09 - to dig into some of the player actions.
17:11 - So inside of our script
here in our battle system,
17:15 - let's have a look at what should happen
17:16 - when we're done setting up our battle.
17:18 - Well, at this point,
17:19 - I think we should go ahead and transition
17:21 - to the player's turn.
17:22 - So we'll simply add a line at the end here
17:24 - that says state equals
BattleState.PLAYERTURN.
17:29 - And we can call a function
called PlayerTurn.
17:32 - And let's go ahead and create that.
17:33 - So we'll create a void PlayerTurn.
17:36 - And for now all we want to do here
17:37 - is just make it clear to the player
17:39 - that he can choose an action.
17:40 - So let's set our dialogueText
17:43 - equal to something that suggests that.
17:45 - Let's just put choose an action.
17:48 - There we go.
17:48 - Of course currently we're
calling the SetupBattle,
17:51 - and we're saying that a
wild enemy approaches.
17:54 - We're then updating our HUD
17:55 - and straight after that
we're calling our PlayerTurn.
17:57 - And all of this is going to happen
17:58 - inside the Start method.
18:00 - And that's not really something we want.
18:02 - We want to add a bit of delay
here as we talked about.
18:05 - So how do we do this?
18:07 - Well to wait in code,
18:08 - we use coroutines.
18:10 - Now we use coroutines quite
often here in the channel,
18:12 - but if you've never seen one before,
18:14 - the syntax is a bit frightening.
18:16 - But just think of them as functions
18:18 - that are running separately
from everything else,
18:20 - which allows us to pass
them whenever we want.
18:23 - So to turn this SetupBattle
here into a coroutine,
18:26 - we replace the void with IEnumerator.
18:29 - Again, I know the syntax is weird.
18:31 - And now before we go ahead
and change to the player turn
18:34 - we can put in yield return new.
18:37 - WaitForSeconds.
18:40 - And here we can input
the amount of seconds
18:41 - we would like to pass.
18:42 - So I'm just going to
to put in two seconds.
18:44 - Now whenever we are calling a coroutine
18:46 - we need to add a tiny bit of code.
18:48 - We need to add StartCoroutine.
18:51 - And then wrap our entire
function call in that.
18:54 - So that's all the syntax we need.
18:56 - I know it's a bit weird, but
it's always the same way.
18:58 - So you can just have a look
at what I'm doing here.
19:00 - We're just calling StartCoroutine.
19:02 - Then the name of the function.
19:04 - We're replacing void with IEnumerator.
19:06 - And then we're putting in a yield
19:08 - that waits for two seconds.
19:10 - So with that,
19:11 - if we save and go into Unity
19:13 - and hit play.
19:14 - As you can see a wild The Rock approaches.
19:17 - And after two seconds,
it says choose an action.
19:19 - And we now either press Attack or Heal.
19:22 - Of course, currently nothing happens.
19:24 - So let's go ahead and add
some logic for the buttons.
19:26 - Let's start with the Attack button.
19:28 - So to do that, we go into our script.
19:30 - And we'll create a new function here
19:32 - called OnAttackButton.
19:36 - And we want to trigger this function
19:37 - whenever the OnAttackButton is pressed.
19:40 - However in order to do
this through the UI,
19:42 - we need to mark it as public.
19:44 - And what we want to do here is to check
19:46 - if it's currently the player's turn.
19:47 - So if state is not equal
to BattleState.PlayerTurn,
19:53 - then we'll simply go ahead and
return out of this function.
19:55 - We don't want to do anything more.
19:57 - But if it is.
19:59 - Well then we'll continue down here.
20:00 - And then we'll call some kind
of PlayerAttack function.
20:05 - In fact let's make this a coroutine
20:07 - so that we can pause during our attack.
20:09 - So we'll do StartCoroutine
around that function call.
20:13 - And let's go ahead and
create the function as well.
20:14 - So we'll create an Ienumerator.
20:17 - We'll call it PlayerAttack.
20:21 - And here we want to damage the enemy.
20:24 - We then want to wait for a few seconds.
20:26 - So yield return new.
20:28 - WaitForSeconds.
20:29 - I'll put in two again.
20:31 - And then we want to check
if the enemy is dead
20:34 - and change state based on what happened.
20:38 - So we'll do that in a sec.
20:40 - But for now,
20:40 - let's just make sure that
this function is triggering.
20:43 - So if we save this
script and go into Unity.
20:45 - we now navigate to our UI.
20:47 - Let's find the dialogue panel,
20:49 - and here have the combat buttons.
20:51 - I'm going to select the AttackButton.
20:53 - And under any UI button
there is an OnClick event.
20:56 - Here we can choose what happens
20:58 - when this button is clicked.
21:00 - I'm going to hit plus.
21:01 - I'm going to drag in the Battle System.
21:03 - And let's go under the
BattleSystem script.
21:05 - And here we can now call
the OnAttackButton function
21:08 - that we just made.
21:10 - Awesome, that is now going
to trigger that function
21:12 - whenever we press this button.
21:14 - Of course we probably want
to make our PlayerAttack
21:16 - actually do something
21:17 - other than just wait two seconds.
21:19 - So let's have a look
at damaging the enemy.
21:21 - Well this is actually fairly easy.
21:23 - We have a reference to the enemyUnit.
21:25 - And so we can simply go in here
21:27 - and we could actually
modify the HP directly,
21:30 - but it's better practise
to create a function
21:32 - that does this.
21:33 - So let's create some kind
of TakeDamage function
21:36 - that takes our player unit's damage.
21:38 - So playerUnit.damage.
21:41 - Let's go ahead and create
this function here.
21:43 - So let's go into our Unit script.
21:45 - And in here let's create
a public void TakeDamage.
21:50 - This is going to take in an
int with the amount of damage.
21:53 - And it's then going to
subtract that damage
21:55 - from our current HP.
21:56 - So minus equals.
21:58 - And in the case that our
current HP reaches zero,
22:01 - we want to let our battle system know
22:03 - that this unit has died.
22:06 - So we want to go ahead
and say if our current HP
22:09 - is less than or equal to zero
22:12 - after we subtract this damage,
22:14 - well then we want to return
either true or false.
22:17 - So true if the unit has died,
22:19 - and false if it hasn't.
22:21 - So we'll go ahead and
change the return type
22:22 - of this function from void to bool.
22:25 - And we can now return true.
22:28 - And if not, then we can return false.
22:32 - So this function is going
to subtract it the damage,
22:34 - check if this unit has died
and return true if it has,
22:37 - or false if it hasn't.
22:39 - And this way inside of our battle system,
22:41 - we can now gather this
information in a boolean.
22:43 - So we'll create a boolean called isDead
22:45 - and set it equal to the
result of this function.
22:48 - And then down here when we
check if the enemy is dead,
22:50 - we can simply go if isDead.
22:53 - Well then we want to end the battle.
22:56 - And if it's not,
22:57 - well then it's the enemy's turn.
23:00 - There we go.
23:01 - We also just damaged the enemy
23:03 - so we need to update the enemy HUD.
23:04 - So we'll go enemyHUD.SetHP.
23:07 - and we'll pass in the enemyUnit.currentHP.
23:12 - And let's also update the dialogue text.
23:14 - So let's go with dialogueText.text
23:16 - equals the attack is successful.
23:20 - Then if we die,
23:21 - we'll change the state
23:23 - to BattleState.WON.
23:26 - Because we just killed the enemy unit.
23:28 - And we'll call some kind
of EndBattle function.
23:32 - Create this in a sec.
23:33 - And if the enemy isn't dead,
23:34 - we'll go ahead and set state
23:35 - equal to BattleState.ENEMYTURN.
23:39 - And we'll start a coroutine
23:42 - with some kind of EnemyTurnFunction.
23:45 - That we'll also create in a sec.
23:46 - So let's start by creating
the EndBattle function.
23:48 - Void EndBattle.
23:51 - Again you could turn this into
a coroutine if you want to.
23:53 - But I don't need to here
23:54 - because I'm simply going to
update the dialogue text.
23:57 - So if state is equal to BattleState.one.
24:01 - Well then we'll go ahead
and set dialogueText.text
24:04 - equal to you won the battle.
24:06 - And if not,
24:08 - and the state is equal
to BattleState.LOST.
24:12 - Well then we'll display you were defeated.
24:15 - And then I'd probably load
out of the battle screen
24:18 - and so on, and so on.
24:19 - So that's it for our EndBattle function.
24:21 - Now let's do our EnemyTurn.
24:22 - Again this is a coroutine
so let's do an IEnumerator.
24:27 - Call it any EnemyTurn.
24:28 - And now in here you can
definitely add some kind of AI
24:31 - to determine what the enemy does.
24:33 - If he also has an attack and a heal,
24:34 - you might want to attack
24:35 - if he has a chance of killing the player.
24:37 - Or heal a few times he loses health.
24:40 - You can put in what every
logic you want here.
24:42 - For now we can just make
him attack every time.
24:44 - So to do that let's
create some dialogue text
24:48 - that says that the
enemy unit is attacking.
24:50 - So enemyUnit.unitName attacks.
24:54 - We'll then wait one second.
24:56 - And that will damage the player.
24:58 - So playerUnit.TakeDamage
25:00 - based on the enemy unit's damage.
25:02 - Again, we want to check
if the player has died.
25:05 - So bool isDead.
25:06 - We want to update the player HUD.
25:08 - So plaerHUD.SetHP.
25:11 - Based on playerUnit.currentHP.
25:14 - Let's wait one more second.
25:15 - We can just copy this line here.
25:17 - And then let's determine whether
or not the player's dead.
25:19 - So if he is dead,
25:22 - then we can set state
equal to BattleState.LOST.
25:26 - And again, call the EndBattle function.
25:28 - And if not, then we'll set state
25:31 - equal to BattleState.PLAYERTURN.
25:33 - And called the PlayerTurn function.
25:35 - There we go.
25:36 - That's an enemy turn.
25:37 - So we display in the
dialogue that he's attacking.
25:39 - We wait one sec.
25:41 - Then we damage the player.
25:42 - You wait one more second.
25:43 - And then we determine if he's dead or not
25:46 - and change states.
25:47 - And with that,
25:48 - we should actually be able to
go into Unity and hit play.
25:52 - A wild The Rock approaches.
25:53 - We'll choose the attack action.
25:55 - The attack is successful.
25:56 - And as we can see the rock
loses health, it attacks.
25:59 - We lose health and we're
back to the player turn.
26:02 - And we'll be able to continue like this
26:04 - until either we or the enemy dies.
26:07 - So we'll go ahead and
attack it one more time.
26:09 - And we won the battle
26:11 - because its HP is now zero.
26:13 - Awesome.
26:14 - So that was the battle system
and all the game states.
26:18 - That was it for the unit
and the attack action.
26:21 - And we can just go ahead and
add a heal action real quick,
26:24 - just for fun.
26:24 - So doing this is much easier.
26:26 - We simply need to duplicate
26:27 - the OnAttackButton function here.
26:28 - And let's call it OnHealButton instead.
26:32 - We only do this if it's our turn
26:34 - and it's going to start a
coroutine called PlayerHeal.
26:37 - And all this is going to
do is be an IEnumerator
26:40 - called PlayerHeal.
26:42 - And of course we need to heal the players.
26:44 - That's go into our unit
26:45 - and create a heal function.
26:47 - Public void heal.
26:50 - It's going to take in an amount.
26:52 - And it's just going to increase
26:54 - our currentHP by that amount.
26:56 - And if the currentHP gets
greater than the maxHP,
27:00 - well then we'll simply set currentHP
27:02 - equal to the max HP.
27:04 - Then inside of our battle system,
27:06 - we can call the playerUnit.heal.
27:09 - Let's just heal by five points.
27:12 - We'll update the UI.
27:13 - So playerHUD.SetHP.
27:16 - PlayerUnit.currentHP.
27:19 - We'll update the dialogue text.
27:21 - You feel renewed strength.
27:22 - Wait two seconds and
change to the enemy's turn.
27:26 - And that's it.
27:27 - We can now save that, go into Unity.
27:29 - And here we of course want to make sure
27:31 - to select the heal button
and add an OnClick event
27:33 - to that as well.
27:35 - We'll find our BattleSystem
27:37 - OnHealButton function.
27:38 - And if we now play.
27:40 - And it's maximised the game view here.
27:42 - We can choose, of course
the attack action,
27:44 - that still works.
27:45 - We take some damage from
the attack, from the rock.
27:48 - We'll press Heal.
27:49 - And we immediately regain some HP
27:52 - and we feel renewed strength.
27:53 - And there we go we've now
created turn-based combat
27:56 - with different actions and an enemy.
27:58 - And it's all working.
27:59 - Awesome.
28:00 - That of course means that we
can check off the last thing
28:02 - that we needed to do here.
28:03 - And there of course a bunch of ways
28:05 - that you can expand upon this.
28:07 - You can change the UI based on game state.
28:10 - In fact, let me just go ahead
and add some of those here.
28:12 - So I'll just drag in a column.
28:14 - Let's call it making it cooler.
28:15 - I'm just going to add in some bullets
28:17 - that you could add.
28:18 - You could change the UI
based on the game state,
28:19 - similar to what they do here in Pokemon.
28:22 - You could add animations
to units and health bars.
28:25 - I think a good example of this
is definitely Final Fantasy,
28:28 - where you can see that there's
all these kinds of animations
28:31 - going on whenever someone attacks.
28:33 - In fact, let's just go ahead
and drag that right in here.
28:36 - You could add more actions
for the player and enemy.
28:39 - Add more units
28:40 - by adding some kind of
unit select game state.
28:43 - And of course you can integrate it further
28:45 - into your main game.
28:47 - If you're not sure about
where to go from here,
28:49 - you can always take out
this really cool video
28:50 - I found by Code Monkey
28:52 - that shows a lot of the animation stuff
28:54 - and even has some UI
overlays for showing damage
28:56 - which I think is really cool.
28:59 - So I'm just going to to go ahead
29:00 - and add that in here as well.
29:02 - So anyway, there's plenty
opportunity for you
29:04 - to go nuts with it from here.
29:06 - That's pretty much it, this video.
29:07 - If you enjoyed it,
29:08 - make sure it's subscribe and
ring their notification bell
29:10 - so you don't miss the next one.
29:12 - Also, don't forget to check out Milanote.
29:13 - Simply click the link in the
description to get started.
29:16 - On that, thanks for watching.
29:17 - And I'll see you in the next video.
29:19 - Thanks to all of the
awesome Patreon supporters
29:20 - who donated in October.
29:22 - And a special thanks to InfinityPBR.
29:23 - Lost to Violence, Loved Forever.
29:25 - Ruonan, Chris.
29:26 - Jacob Sanford, faisal marafie.
29:28 - Peter Schwendimann, Leo Lesetre.
29:29 - Dennis Sullivan, Alison the Fierce.
29:31 - Stig Christensen,
29:32 - Kirill Svidersky,
29:33 - Gregory Pierce,
29:34 - Naoki Iwasaki,
29:35 - TheMightyZeus,
29:36 - Daniel Dusanic,
29:37 - and Erasmus.
29:38 - You guys rock.

Cleaned transcript:

In this video we'll have a look at creating one of the classics of gaming. Turnbased combat. Turnbased battle systems have been part of gaming since the very beginning. And games like Civilization, Pokemon, and Final Fantasy, are known for this particular style of combat. So let's try creating a simple, yet solid turnbased combat system in Unity. But first, special thanks to InfinityPBR for his support on Patreon. And this video is sponsored by Milanote. Milanote is a tool for organising your creative projects into freeform visual boards. It can be used for any creative project, but it's particularly well suited for the messy, early stages of video game development. It's just a perfect place to store your ideas and make sense of them as they grow. You can get started with Milanote for free. And I've actually used it to plan out the turnbased battle system we're going to be making in this video. In fact, let me just jump right in and show you. So as you can see, I've gone ahead and set up this board in Milanote on creating a turnbased battle system. And I've gone ahead and created four columns. One for the UI. As you can see this links to a separate board. And in here we have a bunch of concept art for the UI. And I've been really inspired by Pokemon, especially some of the newer versions with a bit more colour. And of course the old Final Fantasy games. Also I have a to do list for the UI. And as you can see, I've gone ahead and crossed all of them out. And that's actually because I prepared the UI beforehand. It's really, really simple. In fact, let me just go into Unity here and show you. All I have here is just the main camera with the green background. And then I have a UI canvas. And in here we have an enemy battle HUD. Which is just an image with a name text, a LevelText, as well as a UI slider for the HP. And I've simply copied that for the player battle HUD. As well as created a dialogue panel. Which again is just an image with a dialogue text object. As well as two buttons, one for attacking, and one for healing. If you've never worked with UI in Unity before, don't worry we of course have plenty of videos on the subject that will teach you how to create simple UI like this. I've gone ahead and put one of them inside of the board here actually, and we'll have links to plenty in the description. I also have a column for the environment. I want to keep it simple. Just have two units, a player and an enemy. And remember you can always add more to the system afterwards. So I've gone ahead and created a simple background already, as you can see. We just need to add two battle stations. Which is what I've chosen to call these two patches of grass here. So inside of Unity, all we need to do is just find a sprite that we like. I've gone ahead and created a simple grass patch sprite here. And I'll of course include all sprites along with the finished project in the description as well. So let's just go ahead and drag this in. And as you can see, that creates a sprite renderer. I don't want this to be UI, I want it to be an actual game object. And let's just place it right above our HUD here. And let's duplicate it and move one down here as well. I'm also just going to select these two and set their order in layer to minus 10. This way when we place in units, they're actually going to appear on top. Let's rename the first battle station to EnemyBattleStation. And the second one to PlayerBattleStation. And if we have a look in our game view, that looks really cool. The only thing that I'll note about the way that I've set up the UI is that if we select our canvas. As you can see, I've set the UI scale mode to scale with screen size. And this just means that if we resize our game view, our UI is going to scale with it. Which is really nice in this case. So we have now added our two battle stations and we can check that off as well. And I've also gone ahead and created a column for gameplay. Our combat is of course, going to be turnbased. And what this means is that we're handling one turn at a time. In other words, we can introduce the concept of a game state. So in my game I want to have five states. You can easily add more for increased complexity, but I think these five are pretty good starting point. We have a start state. This initialises to combat and sets up all the units. We'll then have a player turn, where the player can choose between different actions. After that we'll have an enemy turn, where the enemy chooses their actions. And we'll loop between these two until the game is either won or lost. We also make sure that whenever we transition from one state to another, for example the player takes its turn. We then want to make sure to leave plenty of time for the player to take in what's happening before we transition to the next state. So that is kind of the basis of how our gameplay should work. In fact, we can see it in action in this GIF from Pokemon. So that is kind of the basics of how we want our gameplay to work. Now how do we lay this out with logic? Well, if we have a look at the core systems that we're going to need, we're definitely going to need some kind of unit script that we can put on the enemy and the player. That has information about their stats, such as HP and damage. As well as name and level and so on. We'll also have a battle system script, which handles all of our game states. And finally, we'll have a battle HUD script that is responsible for updating our unit UI. In this example, we give the player two actions. An attack action and a heal action, but you can of course add more. All right so with that explanation, that's jump right into it. And let's have a look at creating our first core system, which is the unit. So inside of Unity, let's start by creating our enemy. Let's right click and go Create Empty to create a new object. Let's call it Enemy. Let's reset the transform. And if we just have a look in our scene view here, we can now see that this is an empty object. I'm just going to go ahead and place it on top of the battle station so that we can see what it's going to look like. Let's then add a sprite to our enemy. So I'm going to go under Sprites, and I have one here called Dwayne. And I'm simply going to take Dwayne and drag him under the enemy object. As you can see, we'll need to reset the transform again here. And I want to move him up to make sure that he's kind of standing on top of the pivot point here. So that once we spawn him in on top of the battle station, he's going to be actually standing on it. And it's not just going to snap to the centre of him, which would look really weird. Remember when doing this to always be in pivot mode. If you're in centre, you won't be able to see the difference. We then go ahead and create a unit script on our enemy. Let's hit Add Component. Let's type Unit and hit Create and Add. And let's doubleclick to open this up in Visual Studio. And this script is actually going to be really simple. We can go ahead and remove our two functions here. We don't need those. Instead what we want are a bunch of variables describing our unit. So let's create a public string with the unit name. Let's have a public int with the unit level. And let's also add in damage. So we'll create a public int with the amount of damage our unit we'll be able to do. As was a public int for the max HP. And let's also have one for our current HP. This way we can keep track of our HP during the fight. And if our unit is maybe already damaged when it enters the fight, we'll be able to control that as well. So let's save that. Go back into Unity. And right away we can fill out these variables. So the unit name here is going to be The Rock. Let's give it a level of say two. A damage of five. Let's set the max HP to 30, and the current HP to 30 as well. All right so now that we've created our enemy, we can go out and turn him into a prefab. So let's just drag him into the project panel. And there we go, we've now made a prefab out of him. And we can go ahead and remove him from the scene. The reason we're doing this is that we want to be able to load in different units depending on who we're fighting. And let's actually go ahead and do the exact same thing with our player. In fact, we can just use the enemy here as a base. So let's go ahead and rename him to Player. Let's move him down here to where the player is supposed to stand. Let's drag him into the project panel as well. And this way we can create a new original prefab. There we go. So we now have both an enemy and a player prefab. And in fact, we can doubleclick on this player prefab to go into prefab editing mode, which is pretty cool. And here we can remove the Dwayne graphic and let's instead dragging a rock. I think the players should be a rock. That's just inherently cool. And let's reset that transform here. Let's drag it up and place it so that it kind of aligns with the centre of our object. There we go. And let's go ahead and rename the unit here to Actual Rock. Let's set the unit level 999. This is a beefy rock. We'll set the damage to 10. The max HP to 25. And let's say our current HP is only 20. So we've taken five damage before this fight started. And let's exit prefab mode up here. And we can now remove this prefab from the scene as well. Awesome. So with that, we've actually gone in and created both our enemy and our player units. We'll add a tiny bit more to the unit script itself, but the base of it is there. And we can now move on to our battle system and defining all of our game states. So let's go into Unity. Let's create a new empty object. Let's reset the transform and let's name this Battle System. Let's drag it to the top here so we can always see it. And let's add a new component and call it Battle System. We'll hit Create and Add and open it up in Visual Studio. And we're going to need our Start function, but we can definitely get rid of Update. Now before we get started on an actual logic here, we need to define the different states that our game can be in. And to do this we'll use something called enums or enumerations. These are perfect because they allow us to define different states, and then create a variable that can always be only one of those states. So we'll start by defining them. We'll create a public enum up here. Notice that I'm doing this outside of the class. And let's call it BattleState. We'll then open and close some curly brackets. And a lot of people put a semicolon here. You should not do that because we are not calling a function here. We're defining an enum. And in here we'll put a START state. We'll put a PLAYERTURN state. An ENEMYTURN. A WON and a LOST state. And now inside of our battle system, what we can do is now create a public battle state, and just call it state. And now we can set this state equal to whatever we want. So inside of our Start, once we load up the battle scene here. We're simply going to set state equal to BattleState. And here we get all the states. And we of course want to choose START here. So you can see how easy it is to keep track of our states this way. And in fact, if we save this script and go into Unity, we'll even be able to preview our different states and see what state we're currently in inside the inspector. Really, really cool. So now that we are in our start state, we can go ahead and set up the battle. So let's create a SetupBattle function. And let's create that down here. Void. SetupBattle. And in here we of course want to spawn in our units. So we'll create a reference to them. We'll create a public game object. Let's call it player prefab. And we'll create a public game object, enemyPrefab. And where do we want to spawn these in? Well we want to spawn them in on our battle stations. So we'll create references to those too. We'll create a public transform. And this is just a transform, not a game object. Because we just need the location of these battle stations, not the entire object. And this is going to be the player battle station. And we'll of course also have one for the enemy battle station. Then when we set up the battle, we can go ahead and instantiate or spawn in a player prefab. As child of, and on top of, the player battle station. There we go. And we can do the same thing with our enemy prefab on top of the enemy battle station. And if we save that and go into Unity, we can drag in our player prefab, our enemy prefab, as well as our player battle station, and our enemy battle station. And on our prefabs here we want to to make sure that their position is set to see zero, zero, zero. We'll do that with the enemy as well. Just so that when we spawn them in, they'll be right at the centre of our battle stations. And if we now hit play, as you can see, we're now spawning in our units. Awesome. Of course currently we don't know anything about our units through script. We're just spawning in the objects and nothing is really happening on the UI. So let's go ahead and change that. So, first of all, we can get a reference to what we're spawning in by creating a game object variable here. We'll call it the playerGO or player game object and set it equal to the game object that we spawn in. And what we can then do is actually get the unit component on that game object. So we'll do playerGO.GetComponent of type Unit. And we want to go ahead and store this in a variable because we'll be referencing the unit a bunch of times whenever we need information about health and so on. So let's go to the top here and create two variables. These don't need to be public. We don't need to see them in the inspector. We'll just create a Unit, playerUnit. And a Unit, enemyUnit. And then down here we can simply set playerUnit equal to player game object.Getcomponent Unit. And we'll do the exact same thing with our enemy. So game object, enemyGO equals the instantiated object. And we'll set enemyUnit equal to enemyGO.getComponent of type Unit. There we go. And what this allows us to do is now get information about our units. In fact, let's go ahead and display the enemy unit name to the player. We access this by simply going enemyUnit.unitName. So let's go ahead and put this unit name inside of our dialogue text right here. Of course to do that, we need a reference to this text object here. So inside of our script, we go to the top. And because this is UI, we need to include the UnityEngine.UI namespace. And we can then create a public text variable called dialogue text. Then down here, we can simply set dialogueText.text equal to enemyUnit.unitName. And let's just add a tiny bit to this. Let's just say a wild. And then we'll insert the enemy unit name, approaches. There we go. So if we save this now and go into Unity, select our battle system and remember to drag in our dialogue text. And hit play. A wild The Rock approaches. Awesome so we're now gathering all this information about the units that we're loading in. And we have total control or where we place it. So let's go ahead and place this information on the HUD overlays. And we could do all this through the BattleSystem script, but that would get very long. So let's go ahead and split it into a separate one that we place on our battle HUD objects themselves. So I'm assuming you're going to select like these two. And that's create a battle HUD script. Again let's doubleclick it to open it up. Again, we can go ahead and remove the two functions here. Let's create a public Text. And again, remember this is UI so we need to use UnityEngine.UI. And this is going to reference our nameText object on the UI. We'll do the same thing with our levelText. And we'll also create a public slider to control our HP slider. We then create a function that is going to update these UI elements. So let's create a public void. And we're making this public so that we can call it from within our BattleSystem script. And it's just name it something like SetHUD. Of course we need some information about what we should set it to. So let's just take in a unit and call it unit. This way we have access to all the information we need. And here we can then just set nameText.text equal to Unit.unitName. We can set levelText.text equal to let's put level. And then plus the unit.unitLevel. For the HP slider, we can set the maxValue equal to the unit.maxHP. And hpSlider.value we'll set equal to unit.current HP. There you go. Of course, we probably want to update the HP a bunch of times every time someone attacks or heals. And so let's just create a quick function for that that only updates the HP. So let's do a public void. SetHP. This is simply going to take in an int with the HP. And here we can just set hpSlider.value equal to that value. Cool. So that's actually it for a battle HUD. All we need to do now is go into our BattleSystem. And in here we need to create a reference to each of the battle HUDs. One for the player HUD and one for the enemy HUD. So we'll just create a public BattleHUD, call it playerHUD. And a public BattleHUD called enemyHUD. And inside of our SetupBattle function, we then say playerHUD.SetHUD, and we'll pass in the playerUnit. And we'll do the same thing for the enemy. So enemyHUD.SetHUD enemyUnit. There we go. Let's save this, go into Unity. And you can see both of the battle HUDs now have some variables that we need to fill out. So for the enemy battle HUD let's drag in the NameText. LevelText. And the slider. And we'll do the same thing for the PlayerBattleHUD. And for our battle system we just need to drag into two battle HUDs. Awesome. If we now hit Play, we can see immediately our HUD updates to show the names of our two units, the level, as well as our current HP. Awesome. So we can check off our battle HUD here. And I think it's time to dig into some of the player actions. So inside of our script here in our battle system, let's have a look at what should happen when we're done setting up our battle. Well, at this point, I think we should go ahead and transition to the player's turn. So we'll simply add a line at the end here that says state equals BattleState.PLAYERTURN. And we can call a function called PlayerTurn. And let's go ahead and create that. So we'll create a void PlayerTurn. And for now all we want to do here is just make it clear to the player that he can choose an action. So let's set our dialogueText equal to something that suggests that. Let's just put choose an action. There we go. Of course currently we're calling the SetupBattle, and we're saying that a wild enemy approaches. We're then updating our HUD and straight after that we're calling our PlayerTurn. And all of this is going to happen inside the Start method. And that's not really something we want. We want to add a bit of delay here as we talked about. So how do we do this? Well to wait in code, we use coroutines. Now we use coroutines quite often here in the channel, but if you've never seen one before, the syntax is a bit frightening. But just think of them as functions that are running separately from everything else, which allows us to pass them whenever we want. So to turn this SetupBattle here into a coroutine, we replace the void with IEnumerator. Again, I know the syntax is weird. And now before we go ahead and change to the player turn we can put in yield return new. WaitForSeconds. And here we can input the amount of seconds we would like to pass. So I'm just going to to put in two seconds. Now whenever we are calling a coroutine we need to add a tiny bit of code. We need to add StartCoroutine. And then wrap our entire function call in that. So that's all the syntax we need. I know it's a bit weird, but it's always the same way. So you can just have a look at what I'm doing here. We're just calling StartCoroutine. Then the name of the function. We're replacing void with IEnumerator. And then we're putting in a yield that waits for two seconds. So with that, if we save and go into Unity and hit play. As you can see a wild The Rock approaches. And after two seconds, it says choose an action. And we now either press Attack or Heal. Of course, currently nothing happens. So let's go ahead and add some logic for the buttons. Let's start with the Attack button. So to do that, we go into our script. And we'll create a new function here called OnAttackButton. And we want to trigger this function whenever the OnAttackButton is pressed. However in order to do this through the UI, we need to mark it as public. And what we want to do here is to check if it's currently the player's turn. So if state is not equal to BattleState.PlayerTurn, then we'll simply go ahead and return out of this function. We don't want to do anything more. But if it is. Well then we'll continue down here. And then we'll call some kind of PlayerAttack function. In fact let's make this a coroutine so that we can pause during our attack. So we'll do StartCoroutine around that function call. And let's go ahead and create the function as well. So we'll create an Ienumerator. We'll call it PlayerAttack. And here we want to damage the enemy. We then want to wait for a few seconds. So yield return new. WaitForSeconds. I'll put in two again. And then we want to check if the enemy is dead and change state based on what happened. So we'll do that in a sec. But for now, let's just make sure that this function is triggering. So if we save this script and go into Unity. we now navigate to our UI. Let's find the dialogue panel, and here have the combat buttons. I'm going to select the AttackButton. And under any UI button there is an OnClick event. Here we can choose what happens when this button is clicked. I'm going to hit plus. I'm going to drag in the Battle System. And let's go under the BattleSystem script. And here we can now call the OnAttackButton function that we just made. Awesome, that is now going to trigger that function whenever we press this button. Of course we probably want to make our PlayerAttack actually do something other than just wait two seconds. So let's have a look at damaging the enemy. Well this is actually fairly easy. We have a reference to the enemyUnit. And so we can simply go in here and we could actually modify the HP directly, but it's better practise to create a function that does this. So let's create some kind of TakeDamage function that takes our player unit's damage. So playerUnit.damage. Let's go ahead and create this function here. So let's go into our Unit script. And in here let's create a public void TakeDamage. This is going to take in an int with the amount of damage. And it's then going to subtract that damage from our current HP. So minus equals. And in the case that our current HP reaches zero, we want to let our battle system know that this unit has died. So we want to go ahead and say if our current HP is less than or equal to zero after we subtract this damage, well then we want to return either true or false. So true if the unit has died, and false if it hasn't. So we'll go ahead and change the return type of this function from void to bool. And we can now return true. And if not, then we can return false. So this function is going to subtract it the damage, check if this unit has died and return true if it has, or false if it hasn't. And this way inside of our battle system, we can now gather this information in a boolean. So we'll create a boolean called isDead and set it equal to the result of this function. And then down here when we check if the enemy is dead, we can simply go if isDead. Well then we want to end the battle. And if it's not, well then it's the enemy's turn. There we go. We also just damaged the enemy so we need to update the enemy HUD. So we'll go enemyHUD.SetHP. and we'll pass in the enemyUnit.currentHP. And let's also update the dialogue text. So let's go with dialogueText.text equals the attack is successful. Then if we die, we'll change the state to BattleState.WON. Because we just killed the enemy unit. And we'll call some kind of EndBattle function. Create this in a sec. And if the enemy isn't dead, we'll go ahead and set state equal to BattleState.ENEMYTURN. And we'll start a coroutine with some kind of EnemyTurnFunction. That we'll also create in a sec. So let's start by creating the EndBattle function. Void EndBattle. Again you could turn this into a coroutine if you want to. But I don't need to here because I'm simply going to update the dialogue text. So if state is equal to BattleState.one. Well then we'll go ahead and set dialogueText.text equal to you won the battle. And if not, and the state is equal to BattleState.LOST. Well then we'll display you were defeated. And then I'd probably load out of the battle screen and so on, and so on. So that's it for our EndBattle function. Now let's do our EnemyTurn. Again this is a coroutine so let's do an IEnumerator. Call it any EnemyTurn. And now in here you can definitely add some kind of AI to determine what the enemy does. If he also has an attack and a heal, you might want to attack if he has a chance of killing the player. Or heal a few times he loses health. You can put in what every logic you want here. For now we can just make him attack every time. So to do that let's create some dialogue text that says that the enemy unit is attacking. So enemyUnit.unitName attacks. We'll then wait one second. And that will damage the player. So playerUnit.TakeDamage based on the enemy unit's damage. Again, we want to check if the player has died. So bool isDead. We want to update the player HUD. So plaerHUD.SetHP. Based on playerUnit.currentHP. Let's wait one more second. We can just copy this line here. And then let's determine whether or not the player's dead. So if he is dead, then we can set state equal to BattleState.LOST. And again, call the EndBattle function. And if not, then we'll set state equal to BattleState.PLAYERTURN. And called the PlayerTurn function. There we go. That's an enemy turn. So we display in the dialogue that he's attacking. We wait one sec. Then we damage the player. You wait one more second. And then we determine if he's dead or not and change states. And with that, we should actually be able to go into Unity and hit play. A wild The Rock approaches. We'll choose the attack action. The attack is successful. And as we can see the rock loses health, it attacks. We lose health and we're back to the player turn. And we'll be able to continue like this until either we or the enemy dies. So we'll go ahead and attack it one more time. And we won the battle because its HP is now zero. Awesome. So that was the battle system and all the game states. That was it for the unit and the attack action. And we can just go ahead and add a heal action real quick, just for fun. So doing this is much easier. We simply need to duplicate the OnAttackButton function here. And let's call it OnHealButton instead. We only do this if it's our turn and it's going to start a coroutine called PlayerHeal. And all this is going to do is be an IEnumerator called PlayerHeal. And of course we need to heal the players. That's go into our unit and create a heal function. Public void heal. It's going to take in an amount. And it's just going to increase our currentHP by that amount. And if the currentHP gets greater than the maxHP, well then we'll simply set currentHP equal to the max HP. Then inside of our battle system, we can call the playerUnit.heal. Let's just heal by five points. We'll update the UI. So playerHUD.SetHP. PlayerUnit.currentHP. We'll update the dialogue text. You feel renewed strength. Wait two seconds and change to the enemy's turn. And that's it. We can now save that, go into Unity. And here we of course want to make sure to select the heal button and add an OnClick event to that as well. We'll find our BattleSystem OnHealButton function. And if we now play. And it's maximised the game view here. We can choose, of course the attack action, that still works. We take some damage from the attack, from the rock. We'll press Heal. And we immediately regain some HP and we feel renewed strength. And there we go we've now created turnbased combat with different actions and an enemy. And it's all working. Awesome. That of course means that we can check off the last thing that we needed to do here. And there of course a bunch of ways that you can expand upon this. You can change the UI based on game state. In fact, let me just go ahead and add some of those here. So I'll just drag in a column. Let's call it making it cooler. I'm just going to add in some bullets that you could add. You could change the UI based on the game state, similar to what they do here in Pokemon. You could add animations to units and health bars. I think a good example of this is definitely Final Fantasy, where you can see that there's all these kinds of animations going on whenever someone attacks. In fact, let's just go ahead and drag that right in here. You could add more actions for the player and enemy. Add more units by adding some kind of unit select game state. And of course you can integrate it further into your main game. If you're not sure about where to go from here, you can always take out this really cool video I found by Code Monkey that shows a lot of the animation stuff and even has some UI overlays for showing damage which I think is really cool. So I'm just going to to go ahead and add that in here as well. So anyway, there's plenty opportunity for you to go nuts with it from here. That's pretty much it, this video. If you enjoyed it, make sure it's subscribe and ring their notification bell so you don't miss the next one. Also, don't forget to check out Milanote. Simply click the link in the description to get started. On that, thanks for watching. And I'll see you in the next video. Thanks to all of the awesome Patreon supporters who donated in October. And a special thanks to InfinityPBR. Lost to Violence, Loved Forever. Ruonan, Chris. Jacob Sanford, faisal marafie. Peter Schwendimann, Leo Lesetre. Dennis Sullivan, Alison the Fierce. Stig Christensen, Kirill Svidersky, Gregory Pierce, Naoki Iwasaki, TheMightyZeus, Daniel Dusanic, and Erasmus. You guys rock.
