With timestamps:

00:00 - GD script A highlevel object-oriented
00:03 - imperative and gradually typed
00:04 - programming language with syntax a lot
00:06 - like python build specifically for good
00:09 - do I know that sounds like a lot but
00:11 - today we're going to learn it while it's
00:13 - of course impossible to cover everything
00:15 - and entire programming language has to
00:17 - offer in just one video will certainly
00:20 - try in fact we'll cover everything from
00:22 - variables and conditionals to getting
00:24 - input inheritance dictionaries signals
00:27 - and the list goes on and who knows
00:30 - perhaps we'll even figure out what GD
00:31 - stands for candle
00:34 - script Green Day script gadolinium we
00:38 - might never know we'll start with the
00:40 - things that I consider to be most
00:41 - important for beginners and then move on
00:43 - to more abstract programming Concepts as
00:46 - we progress it's not as much a follow
00:48 - along as it is an overview so if you're
00:50 - a beginner lean back and know that you
00:52 - don't have to understand everything the
00:54 - first time also it's totally okay to
00:56 - stop the video and try some of these
00:58 - things out you can always come back to
01:00 - it at a later time we've made sure to
01:02 - split everything into clearly named
01:03 - sections so hopefully you'll be able to
01:05 - use this as a reference manual going
01:07 - forward and if you're a season
01:09 - programmer transitioning to GD script
01:11 - this video should provide you with a
01:13 - nice overview of the tools at your
01:15 - disposal and how to approach doing
01:17 - different things keep in mind that this
01:18 - is a video on GD script not an
01:20 - introduction to gdau so if you've never
01:22 - opened up gdau before I suggest you
01:24 - begin with our video on making your very
01:26 - first game in gdau all right without
01:28 - further Ado let's learn G P script but
01:30 - first this video is sponsored by codec
01:33 - Crafters if you've been writing software
01:35 - for a while and are looking to take your
01:36 - skills to a whole new level code
01:38 - Crafters is the place to be code
01:40 - Crafters allows you to practice writing
01:42 - complex software by challenging yourself
01:44 - with real world projects you get to
01:46 - build your own git implementation your
01:48 - own HTTP server or even your own bit T
01:51 - client along the way you will practice
01:53 - Advanced system design and gain a
01:55 - greater understanding of lower level
01:56 - programming Concepts such as networking
01:58 - OS interaction and performance and when
02:01 - you're done you'll have a really
02:02 - impressive project to add to your
02:04 - portfolio on top of this you get to try
02:06 - new languages like python C C++ and many
02:10 - many more also new challenges are
02:12 - constantly being added I for one voted
02:14 - for the compiler challenge to be next so
02:16 - become a better software engineer today
02:18 - by signing up for code Crafters use the
02:20 - link below to get one week free and 40%
02:23 - off on all membership plans hello world
02:26 - so here we are in an mty kodo project
02:29 - it's really ious in here as it is custom
02:32 - let's begin by making a script and
02:33 - adding some code to print a message to
02:36 - do that we need a test scene so let's go
02:38 - and hit the plus I'll add in a node
02:41 - rename it to Main and let's save this as
02:44 - a scene so I'll hit control s hit save
02:47 - let's add a script by pressing the
02:49 - scroll we'll use the default template
02:51 - and the name of the script should be
02:52 - main as well with a non capital M this
02:55 - creates a script with two functions
02:57 - we'll start by focusing on the top one
02:59 - named ready think of this as the start
03:02 - of our game as it says here this
03:04 - function is called when the node enters
03:06 - the scene tree for the first time which
03:08 - happens right when we play our game so
03:10 - we can put code in here that we want to
03:12 - happen immediately I'll get rid of the
03:14 - other function for now you can zoom in
03:16 - by holding down control while scrolling
03:18 - now right now the only thing in our
03:20 - ready function is the pass keyword pass
03:23 - basically means do nothing and it will
03:25 - appear in functions we haven't filled
03:27 - out yet so let's replace it with some
03:29 - code that our message we'll write print
03:32 - and inside of the parenthesis we'll put
03:33 - our message in quotation marks hello
03:37 - world we can then run the game by
03:39 - pressing this button here or hitting F5
03:42 - it's going to ask us which scene we are
03:44 - going to run we'll hit select current
03:46 - and while our game isn't very exciting
03:48 - yet we can now see that the console
03:50 - prints our message the output window
03:52 - here or the console is where it will
03:54 - display prints and it's also where we
03:56 - check for errors now to stop our game
03:58 - from running we press the sub button
04:00 - here or press f8
04:02 - syntax now this might have worked for
04:05 - you and it might not that's because
04:07 - there are a few things to be aware of
04:09 - when writing GD script the first is that
04:12 - statements like print here terminate
04:14 - with a new line there's no need to add a
04:17 - semicolon at the end like in many
04:19 - c-based languages and GD script similar
04:21 - to a language like python uses
04:23 - indentation to determine the structure
04:25 - of your code this means that you use
04:27 - tabs to tell TD script where your code
04:29 - belongs belongs in our example here I'm
04:31 - using a tab to tell kodo that our print
04:34 - line belongs to the ready function if I
04:36 - delete this tab I get an error also GD
04:39 - script is case sensitive so if I write
04:42 - print with a capital P I will also get
04:44 - an error so just a couple of things to
04:46 - look out for there now printing to the
04:48 - console is cool or I mean maybe not as
04:51 - cool as backflips but well I can teach
04:53 - you to do those but I can teach you how
04:55 - to display text in the game window
04:57 - instead to do that we'll need to modify
04:59 - a through script modifying nodes 1.0
05:04 - first we need a node to modify let's use
05:06 - a label so I'll add a new node choose
05:08 - label I'll zoom in Center it on the
05:12 - screen make some more room let's add a
05:15 - default text this is a label I'll Center
05:18 - it and overwrite the font size now to
05:22 - edit the text of this label through
05:24 - script we need two things we need a
05:26 - reference to the label and we need to
05:28 - access the property in this label that
05:30 - we want to change in this case the text
05:33 - if we hover over text we can see the
05:35 - name of the property through script
05:37 - which is text with a non capital T so in
05:39 - our main script we'll first get a
05:41 - reference and we can actually do this by
05:43 - simply taking the label and dragging it
05:45 - into our ready function then we can
05:47 - access the property by going Dot and
05:49 - we'll type in text and set it equal to
05:52 - hello world and now when we play our
05:55 - label changes to hello world and we can
05:57 - use this exact method to change other
05:59 - things as well such as the color of the
06:01 - text in fact there's a property called
06:03 - modulate which allows us to tint Sprites
06:06 - and UI elements in the inspector you can
06:08 - find it all the way down here under
06:10 - visibility let's change it to Green so
06:12 - again we'll click and drag to create a
06:14 - reference to the label write. modulate
06:17 - and set it equal to color dot here we
06:19 - have a bunch of different colors we'll
06:21 - choose green and voila our label is now
06:24 - green so this is how we can make changes
06:26 - to nodes when our game is running but
06:28 - right now not much is happening during
06:29 - our game so let's see how we can use
06:31 - input to make our game respond to our
06:33 - actions input let's say we want to turn
06:36 - this label red when we press the space
06:38 - bar to do this we first need to set up
06:40 - an input action we'll go project project
06:43 - settings input map here we can add
06:46 - actions actions allow us to bind keys to
06:49 - something that we want to happen common
06:51 - actions would be shoot jump or so on in
06:54 - our case we wanted to change a color
06:56 - I'll just go ahead and call it my action
06:58 - so we can use it later for other things
07:00 - now let's hit add and here is our action
07:02 - let's find the key to it by pressing
07:04 - plus it's now listening for input I'm
07:06 - going to press this space bar and hit
07:08 - okay and now our space bar is bound to
07:11 - my action then in our script we need to
07:13 - create an input function we'll write
07:15 - funk for function underscore input and
07:18 - let's hit enter to autoc
07:20 - complete now just like ready this is one
07:23 - of the build-in functions of gdo but
07:25 - instead of being called at the start of
07:27 - the game it runs every time the game
07:29 - receives any input such as when we press
07:31 - a button event is what we call the
07:33 - information about what triggered the
07:34 - function was it a movement of the mouse
07:36 - or the Press of a key we need to check
07:38 - if the event that triggered the input
07:40 - was our action being pressed so we'll
07:43 - write if event. is action pressed and as
07:47 - you can see our action shows up here my
07:50 - action then we'll put in a colon and if
07:53 - we pressed my action well then we'll
07:55 - change the color so we'll drag in the
07:57 - label write modulate and set it equal to
08:00 - color do red and we can just as easily
08:03 - check if the action was released we'll
08:05 - go if event do is action released this
08:08 - time my action well then we'll take the
08:11 - exact same line and change it back to
08:14 - green so now when we play and I press
08:16 - the space bar it turns red and when I
08:19 - release it it turns back to green that's
08:21 - right we made a party he disco
08:24 - [Music]
08:27 - party now this is just one out of many
08:29 - ways to handle input in gudo but since
08:31 - we're focusing on the GD script language
08:33 - I'm not going to go further into it here
08:35 - I'll make sure to provide a link to
08:36 - where I can learn more about input if
08:38 - you're interested variables 1.0
08:41 - variables are essentially containers
08:43 - that hold information in the case of a
08:45 - player character we could use variables
08:47 - for information like the player's name
08:49 - Health damage and perhaps if the player
08:52 - is alive or not let's make a health
08:54 - variable at the top here I'll write bar
08:56 - for variable the name of our variable
08:59 - and then we'll set it equal to a default
09:01 - value now we can print this variable
09:03 - inside of our ready function we write
09:05 - print health and if we play you can see
09:08 - that it now prints 100 now we can easily
09:11 - change our variable so before printing
09:14 - let's assign a new number Health equal
09:17 - 40 we can also assign a calculation so
09:20 - Health = 20 + 30 we'll set our health to
09:24 - 50 we can also add Health Plus equals
09:28 - and then 20 we'll add 20 to our health
09:32 - and subtract Health minus
09:35 - equals to multiply we do times equals
09:38 - and to divide we do slash equals so if
09:42 - we run this now it will do all of these
09:44 - calculations from top to bottom and then
09:46 - print out the result which turns out to
09:48 - be
09:49 - 120 let's look at an example where our
09:52 - player takes some damage and we want to
09:54 - subtract the damage from our health
09:55 - let's try decreasing our health variable
09:57 - whenever we press the action we made
09:59 - earlier so in the input function we'll
10:02 - check if the action was
10:05 - pressed and then we'll subtract from our
10:08 - health and we can print the result so
10:11 - now every time I press the space bar
10:14 - bound to my action we can see that I
10:16 - reduced the health really cool but as
10:19 - you can see we can currently reduce our
10:21 - health below zero and nothing happens
10:23 - when we do so if we were making a game
10:25 - we'd probably want our player to die and
10:26 - the game to restart luckily we can make
10:28 - our game react to variables by using IF
10:31 - statements if statements or conditionals
10:34 - if statements are the glue that holds
10:36 - all of our logic together we've actually
10:38 - already used if statements to check if
10:40 - our action was pressed but they can do
10:43 - so much more yet they are really simple
10:46 - an if statement is just a condition that
10:48 - needs to be met in order for the code
10:50 - inside to be run let's add an if
10:52 - statement here to check if our health
10:54 - reaches zero so I'll make some room
10:56 - write if health is less than than or
11:00 - equal to Zer well then we'll set our
11:02 - health to zero and we'll print that we
11:07 - died and now when our health gets to
11:10 - zero it prints you died now here we're
11:13 - using less than and equal to to compare
11:15 - our health to the value zero but there
11:17 - are many more comparisons we can make
11:20 - here are all the comparisons we use such
11:22 - as is equal to is not equal to and so on
11:25 - we can also add more conditions to one
11:28 - if statement we use the and keyword to
11:30 - add another condition where both need to
11:32 - be met and the or keyword to add a
11:35 - condition where only one of them needs
11:36 - to be met now one really useful thing
11:39 - about if statements is that we cannot
11:41 - only Define what happens when the
11:43 - condition is true we can also choose
11:44 - what happens when it's false we do this
11:47 - using the else keyword let's add an else
11:49 - to print that we are still alive if our
11:51 - health hasn't reached zero yet so if our
11:53 - health is less than or equal to zero we
11:55 - died
11:57 - else we print
11:59 - you are healthy and even cooler we can
12:02 - chain together if statements using else
12:04 - if or El if for short so we check if our
12:07 - health reaches zero and if not else if
12:10 - El if our health goes below 50 well then
12:14 - we'll print that we are
12:18 - injured and if neither of these two are
12:20 - true we'll go to else and say that we
12:22 - are healthy and if we play we can see
12:24 - that at 80 we are healthy at 60 we are
12:27 - still healthy then we are injured and at
12:29 - zero we die very cool note that the if
12:32 - statement we made here is nested under
12:35 - another if statement you can easily
12:37 - layer if statements to get more and more
12:39 - specific functionality however try not
12:42 - to overdo it you can quickly get lost in
12:44 - the ifs actually a lot of people don't
12:46 - know this but that's why programmers and
12:48 - philosophers have so much in common we
12:50 - both tend to spend a lot of time with
12:52 - the ifs and the wh ifs so if you get
12:55 - frustrated along the way remember that
12:57 - so was Play-Doh
12:59 - anyway that's it for if statements
13:01 - comments we use comments to help explain
13:04 - and remember the what and the why of our
13:06 - code adding a comment is simple and can
13:08 - be done above or after a line so if we
13:11 - have some code we can make a comment
13:14 - above the line and this is a comment
13:16 - about the code that follows or we could
13:19 - make one right after and this is a
13:21 - comment about this line only we can also
13:24 - use comments to temporarily remove parts
13:26 - of our code from being executed here we
13:28 - simp simply put a hashtag in front of
13:30 - the code and it's good practice to emit
13:32 - the space here to indicate that what
13:34 - follows is code we can also select
13:36 - multiple lines of code right click and
13:38 - toggle comment just remember that you
13:40 - can't have a completely empty function
13:42 - we need to add the pass keyword to avoid
13:44 - an error variables 2.0 when creating or
13:49 - declaring a variable we need to think
13:51 - about where we do so if we declare a
13:53 - variable inside of an if statement for
13:55 - example we can only use that variable
13:58 - inside of the if statement M this is
14:00 - called scope and it's something that
14:01 - beginners often make mistakes with if we
14:04 - want to use a variable in many different
14:06 - places in our script we make sure to put
14:08 - it at the top outside of any functions
14:10 - so this is a script wide variable this
14:13 - can be accessed anywhere in your script
14:15 - if you were to declare it inside of a
14:17 - function you would only be able to use
14:19 - it in that function so this is a
14:22 - variable we can only use in ready now a
14:25 - really cool thing about variables in GD
14:27 - script is that you can declare them
14:28 - without thinking about what type of data
14:30 - is inside them here's a variable that is
14:32 - either true or false and here's a
14:34 - variable that stores a number as you can
14:36 - see they're created in the exact same
14:38 - way in fact we can even change the type
14:40 - of data that they hold just by
14:42 - reassigning them so we can actually set
14:44 - our coolness to true and this runs
14:47 - completely fine that being said we still
14:50 - need to be aware of what type of data
14:52 - we're working with because some parts of
14:54 - our game will expect a specific type of
14:56 - data and we will get an error if we try
14:58 - to use another type without converting
15:01 - now in GD script we have the four
15:03 - classic data types Boolean or bull for
15:06 - true and false integer or int for whole
15:09 - numbers float for numbers with decimals
15:12 - and string for text converting from one
15:15 - type to another is called casting for
15:18 - example we can cast an integer into a
15:21 - string so if we have a number that is
15:23 - equal to 42 and we have some text which
15:27 - is a string well then we can add add the
15:29 - number to this text but we convert it
15:32 - into a string by writing Str Str for
15:34 - string and then the variable inside of
15:37 - the parentheses and if we print this it
15:39 - works fine we can do a similar thing to
15:42 - say convert a float into an integer so
15:45 - if we have a variable called Pi that is
15:47 - equal to 3.14 then we can convert this
15:50 - into an integer by going int pi and
15:53 - let's print this and it prints three a
15:56 - whole number note however that this
15:58 - automatically truncates the number it
16:00 - does not round it simply gets rid of the
16:03 - decimals so 3.9 also results in three
16:07 - some other data structures that are
16:08 - really common in GD script are Vector 2
16:10 - and three Vector 2 stores two floats X
16:14 - and Y and Vector 3 stores three floats X
16:18 - Y and Z these are most commonly used for
16:21 - positions so I can create a variable
16:23 - called position with some coordinates I
16:25 - can then modify one of the components so
16:28 - position
16:29 - X plus = 2 adds 2 to the X component and
16:33 - then we can print the whole thing and
16:35 - this gives a vector 3 of 5 - 10 5 Now by
16:39 - default gdscript is what we call
16:41 - dynamically typed this means that we
16:44 - don't Define what type of data a
16:45 - variable can hold when we declare it
16:47 - which we've been using so far this makes
16:49 - it fast to create variables and flexible
16:51 - because we can reassign data of another
16:53 - type at will however it is also more
16:56 - prone to error and less performant than
16:58 - static typing luckily GD script allows
17:01 - us to statically type any variables we
17:03 - want we can pick and choose totally
17:05 - based on preference to statically type a
17:08 - variable we simply add the type when
17:10 - declaring it so here if we have a damage
17:12 - variable we can specify the type and
17:15 - then set the value so now this variable
17:17 - will always stay an integer we can even
17:20 - have gdo automatically determine the
17:22 - data type by simply writing colon equals
17:25 - and then the default value this is
17:26 - called invert typing and the result is
17:28 - exactly the same the type is still
17:30 - static kdo simply recognizes that 15 is
17:33 - a whole number and sets the variable to
17:35 - a type of in this also means that the
17:37 - variable cannot change to another type
17:39 - if we try to set it to a string we get
17:42 - an error now adding export in front of a
17:45 - variable will allow us to set it using
17:47 - the inspector the value that we set in
17:49 - the script will just be a default value
17:52 - so if we save this and select our node
17:54 - we can set a value in the inspector if
17:56 - we print our damage we can see that this
17:59 - updates in our game and we can always
18:01 - press the circular Arrow to revert back
18:03 - to the default now sometimes you want to
18:05 - Define a variable that cannot change for
18:07 - this we use constants so I'll write
18:10 - const for constant we'll call it gravity
18:13 - as you can see it's standard practice to
18:14 - name constants with capital letters and
18:16 - we'll set it equal to
18:18 - 9.81 now we can use this like any other
18:21 - variable but we cannot change it if we
18:24 - try to do that it throws an error and
18:26 - that's it for variables great job
18:30 - functions functions are the bread and B
18:32 - of programming they allow you to bundle
18:35 - up your code in small reusable packages
18:38 - so far we've been using some of gau's
18:39 - build-in functions like ready and input
18:42 - notice how these are prefixed with an
18:44 - underscore this is to show that they are
18:46 - not activated or called by us but by the
18:49 - engine itself but we can actually make
18:51 - our own functions and use them to do
18:54 - really cool things common functions to
18:56 - making games are things like jump die
18:58 - shoot and respawn and making a function
19:01 - is actually really easy let's make a
19:03 - function for jumping so we'll write
19:06 - [Music]
19:07 - Funk then the name of our function open
19:10 - and close parenthesis and a colon then
19:12 - in here we'll put all of our code for
19:14 - jumping so we could add an upwards Force
19:18 - play a funny sound and a jump animation
19:20 - for now we'll just print jump but
19:23 - nothing is currently triggering or
19:25 - calling our function let's call it
19:27 - whenever we press the action we made
19:29 - earlier so Funk input event and if our
19:34 - action was pressed then we call our jump
19:36 - function by writing jump followed by
19:39 - open and close parenthesis and now when
19:41 - I press space it displays jump and at
19:43 - this point I encourage you to add the
19:45 - sound effect
19:47 - [Music]
19:49 - yourself a lot of fun to be had here now
19:52 - this already makes our code more
19:53 - readable and reusable but right now our
19:56 - function is just a simple command we
19:58 - call call it and it does some things
20:00 - however we can actually use functions
20:02 - for much more than this they can have
20:04 - inputs and outputs let me explain I like
20:07 - to think of functions as machines take
20:10 - for example this coffee maker just like
20:12 - the name implies it performs a function
20:14 - to make coffee to do this however it
20:16 - needs some input some water a filter and
20:19 - some ground coffee with this it performs
20:22 - its function and then spills out an
20:24 - output delicious coffee
20:28 - in code we call the input we give our
20:30 - function parameters and the output is
20:33 - called returns so let's make a function
20:35 - that adds together two numbers Funk add
20:39 - and then inside of our parentheses we
20:41 - add the parameters so number one we'll
20:43 - call num one and the second number will
20:46 - call num two then inside our function we
20:49 - can add these together and store them in
20:51 - a result variable so we'll set that
20:53 - equal to num 1 + num 2 and for now let's
20:56 - just print the result then in ready
20:59 - let's try calling this function so we'll
21:01 - call add we'll give it the first number
21:03 - three and the second one let's do eight
21:06 - and let's actually call it again so
21:08 - let's do a harder one let's add 245 with
21:12 - 111 and indeed it prints 3 + 8 which is
21:15 - 11 and 356 which is the result of our
21:18 - second calculation so here we've created
21:20 - a function with two parameters the
21:22 - numbers we want to add together but the
21:25 - function actually doesn't return the
21:26 - result it just prints it this means that
21:29 - we can't actually access the result
21:30 - where we are calling the function up
21:32 - here and ready to return the result we
21:34 - replace print with return so we'll do
21:38 - return result and now up here we can
21:41 - store the result in a variable set it
21:43 - equal to add and we'll add together
21:45 - three and
21:46 - five and we can print that and the
21:49 - result is eight and because we have
21:51 - access to it up here we can do more
21:52 - things I add more numbers to it so we
21:55 - can say result equal to add and pass in
21:58 - the result from before and add 10 and
22:00 - then print it and there you go we now
22:03 - get 18 because 3 + 5 + 10 is 18 really
22:07 - cool and just like when declaring
22:09 - variables we can also statically type
22:11 - parameters and return types to make it
22:12 - clear that the function is made to work
22:14 - with numbers so after num one we'll
22:16 - specify that this is an integer we'll do
22:18 - the same thing with num two and here we
22:21 - can set the return type using an arrow
22:23 - and this is also an integer so now this
22:26 - function will only work with numbers 3 4
22:29 - 6 8 2 1 one and a half random numbers
22:33 - getting random numbers is very easy the
22:36 - function Rand F gives a random number
22:38 - between 0 and one it's great for
22:41 - assigning probabilities to your code say
22:43 - we are deciding what loot to give the
22:45 - player and we want to make some loot
22:46 - more rare than other well in this case
22:49 - we could create a ro variable and set it
22:51 - equal to randf then we could check if
22:54 - the roll is less than or equal to 0.8
22:58 - which means there's an 80% chance that
23:00 - we print you found a common item and if
23:03 - not well then there's a 20% chance that
23:07 - you found a rare item and if we play
23:10 - this most of the time it's going to
23:12 - display that we found a common item but
23:15 - if we keep playing if we keep playing
23:18 - keep playing
23:21 - eventually there's a 20% chance so at
23:25 - some point we'll eventually
23:28 - this is we'll eventually find a rare
23:31 - item that was crazy we can also use Rand
23:35 - F range and Rand I range to get a random
23:38 - float or integer between a minimum and
23:40 - maximum value say to assign a random
23:43 - height to a character so bar character
23:45 - height equals Rand I range for a random
23:49 - integer between 140 and let's doe 210
23:53 - and we'll print that your character is
23:57 - then we'll insert the height remember to
23:59 - convert to a
24:01 - string cm tall and we'll roll a
24:04 - character and apparently I am a giant
24:07 - basketball here I come documentation GD
24:11 - script is actually pretty well
24:12 - documented and one of the really cool
24:14 - things about it is that the
24:15 - documentation is linked with the editor
24:17 - if we hold down control and click on
24:19 - something we would like to know more
24:21 - about such as the randai range function
24:23 - it opens up the documentation right here
24:25 - in the editor this is a really quick and
24:27 - easy way to check if you're using a
24:29 - function correctly it also works for
24:31 - classes which we'll learn about later
24:34 - arrays sometimes you want a variable
24:36 - that can hold more than one thing in
24:39 - fact sometimes you might want to store a
24:40 - whole list of elements for this we use
24:43 - arrays defining an array is very easy
24:46 - let's make one to hold items in an
24:48 - inventory so we'll create a normal
24:50 - variable and set it equal to open and
24:52 - close square brackets this creates an
24:54 - empty array we can then add elements
24:56 - inside the square brackets I'll add a
24:59 - potion string the number three and the
25:01 - number six notice how unlike many other
25:04 - languages GD script has no problem
25:06 - mixing data types within an array but if
25:09 - you want to constrain an array to a
25:10 - specific type we can of course
25:12 - statically type it so here we simply add
25:14 - the type this is an array and the
25:17 - elements inside it are going to be
25:19 - strings so that's the Syntax for that
25:21 - and now we get an error because three is
25:23 - not a string so we'll replace this with
25:25 - feather and six is also not a string
25:27 - we'll replace that with stolen heart now
25:31 - the way that we access elements in an
25:33 - array is by using an index when you add
25:35 - an element to an array it is
25:37 - automatically assigned a number based on
25:39 - its position in the array in this case
25:41 - the first element potion has an index of
25:44 - zero feather has an index of one and the
25:46 - stolen harp has an index of two so to
25:49 - access and print the first element in
25:50 - our array we write print items and then
25:53 - we access the first element which has an
25:56 - index of zero and This spells out potion
25:59 - pretty cool we can just as easily change
26:02 - elements this changes the second element
26:05 - to smelly sck and the third element to
26:07 - staff and arrays also have functions for
26:10 - finding removing or adding new elements
26:13 - so to remove at an index we write remove
26:16 - add and then the index one this removes
26:19 - the smelly sock and to add a new
26:21 - elements we write do append and we'll
26:24 - append an overpowered sword to the end
26:27 - of the array
26:29 - now arrays can quickly become long and
26:31 - difficult to manually go over luckily we
26:33 - can use something called Loops to help
26:35 - out loops loops loops loops allow us to
26:39 - repeat code a number of times with small
26:42 - variations they are perfect for
26:44 - iterating through all the elements in an
26:46 - array if for example we wanted to print
26:48 - out all the items in our array here we
26:50 - can do that easily by using a for Loop
26:53 - so we write four then the name of the
26:55 - item that we're currently looking at
26:57 - we'll just name that it item in the
27:00 - array so in items we will print out the
27:03 - current item we're looking at so print
27:05 - item and as you can see it prints potion
27:08 - feather and stolen harp this is cool
27:10 - because we can have any number of items
27:12 - in our array the code will work just
27:14 - fine we can also add more functionality
27:16 - say to only print items that are more
27:18 - than 6 letter long if item. length so
27:22 - the amount of characters in item is
27:24 - greater than let's say six then we're
27:27 - going to print that item and now it only
27:29 - prints feather and stolen harp because
27:31 - potion is exactly six letters we can
27:34 - also create Loops that run a certain
27:36 - amount of times if we write 4 n in 8 it
27:40 - creates a for Loop where the variable n
27:43 - starts at zero then goes all the way to
27:46 - seven so if we print n we can see that
27:49 - it runs eight times and N starts at zero
27:52 - and ends at 7even we say that n is the
27:56 - current iteration of the loop another
27:58 - type of loop is the while loop this
28:00 - repeats as long as a certain condition
28:02 - is met now I think most people who know
28:05 - me would say that I'm a glass half full
28:07 - kind of person and to those who disagree
28:09 - let me go ahead and prove it by using a
28:11 - while loop to fill up a glass halfway so
28:14 - I'll create a glass variable and default
28:16 - it to 0.0 the glass is currently empty
28:19 - no arguing about that then we'll create
28:21 - a while loop that continues while glass
28:25 - is less than 0.5 so we have haven't
28:28 - filled it up halfway yet in which case
28:31 - we will add a certain amount to our
28:33 - glass we could do a constant amount like
28:35 - this or in real life when I try to pour
28:38 - something into a glass I'm not that
28:39 - precise so let's add a random number
28:42 - instead so we'll add a random float
28:45 - between 0.01 and 0.2 and then we'll
28:49 - print out how much is in the glass at
28:52 - the current time then when the loop is
28:54 - done we get to continue down here in our
28:56 - code and we'll print that the glass is
28:59 - now half full and if we run this we can
29:04 - see that the glass slowly becomes more
29:05 - full with a random amount each time and
29:08 - then it says that the glass is now half
29:09 - full as you can also see it overshoots a
29:12 - bit because we're adding a random amount
29:14 - each time and not claming the value just
29:16 - like when trying to hit exactly half a
29:18 - glass in real life my wife says that I
29:20 - add too much milk when I make her coffee
29:22 - I think I'll refer her to this going
29:24 - forward now we actually have to be
29:26 - really careful when using while Loops
29:29 - that we don't create an infinite Loop
29:31 - these can be tricky to avoid and can
29:33 - very easily crash our program say if I
29:36 - were to remove this line that adds a
29:38 - little bit to our glass every time well
29:40 - then our glass would actually never
29:43 - become half full and we would be stuck
29:45 - in this Loop forever now I don't think
29:48 - this will actually crash Gau indeed it
29:50 - didn't but we get a lot of overflow
29:52 - errors and as you can see our game is
29:54 - definitely not responding not good
29:57 - finally in both for and while Loops we
29:59 - can use the break and continue keywords
30:01 - break as the name suggests breaks out of
30:03 - the loop and moves on to the code after
30:06 - while continue immediately skips to the
30:08 - next iteration of the loop so if we were
30:10 - to write if glass is greater than
30:14 - 0.2 and then break we can see that our
30:17 - while loop ends way early because we
30:19 - exit out of the loop before we even get
30:21 - to print that the glass reached 0.2
30:25 - dictionaries they sound really boring
30:27 - but they're really cool while arrays are
30:29 - great for storing lists of elements it's
30:32 - sometimes confusing to access each
30:34 - element with an index sometimes it makes
30:36 - more sense to use a dictionary
30:38 - dictionaries hold what we call key value
30:41 - pairs let me explain in real life we use
30:43 - a dictionary to look up the definition
30:45 - of words in a language the key in this
30:48 - instance is the word we're looking up
30:50 - and the value is the definition
30:52 - dictionaries and TD script work the
30:54 - exact same way creating an empty
30:56 - dictionary is really easy we write VAR
30:59 - I'll call this one my dict and set it
31:02 - equal to some curly brackets this is an
31:05 - empty dictionary we can then add key
31:07 - value pairs inside the curly brackets
31:09 - say for example that we have multiple
31:11 - players in our game we can use a
31:13 - dictionary to keep track of them each
31:15 - player has a username this will be the
31:17 - key and a level this will be the value
31:19 - so I'll create a player called Crook and
31:22 - this level is going to be one I'll
31:24 - create a another player villain with a
31:28 - level of 35 and finally a player with
31:31 - the username boss with a level of 100 if
31:33 - defining on one line becomes too much
31:35 - you can split it up like
31:38 - this and it's good practice to add a
31:40 - comma to the last entry so you're ready
31:42 - for a new one and let's name this
31:43 - dictionary players then to get the level
31:46 - of a player we simply type in the
31:47 - username let's print the level of our
31:49 - villain so print and we'll write players
31:53 - type in villain and this should print 35
31:57 - and you can just as easily assign a new
31:59 - value or add another entry so we can
32:02 - reassign the villain here to say 50 and
32:05 - add a new entry called
32:07 - Dwayne with a whooping level of
32:11 - 999 and just like with arrays we can
32:14 - Loop over a dictionary with a for Loop
32:16 - when we do this we are actually looping
32:18 - over all the keys in our dictionary so
32:21 - all the usernames and for each username
32:24 - in players we will go ahead and print
32:27 - out the username I'll add a string to
32:30 - separate and then the level so here we
32:34 - access our players dictionary and input
32:36 - the username we're currently looking on
32:38 - to get the value and remember to convert
32:40 - this into a string so Str Str to cast to
32:44 - a string there you go it prints our
32:46 - entire
32:47 - dictionary now just like with arrays you
32:50 - can have multiple data types of keys and
32:53 - values in the same dictionary and even
32:55 - cooler you can actually have arrays or
32:57 - dictionaries inside another dictionary
33:00 - this might sound really abstract but
33:01 - it's actually pretty cool and often
33:03 - comes in handy say for example we don't
33:05 - just want to store the level of each
33:08 - player but also other info like their
33:10 - health well then we simply replace this
33:12 - value with another dictionary so open
33:15 - and close some curly brackets here we'll
33:17 - add a key called level with a value of
33:19 - one and another key called Health with a
33:23 - value of 80 and at this point it's a
33:25 - good idea to use tabs to keep our code
33:27 - clean duplicate
33:29 - this I'll assign some
33:32 - values and now we can access a value by
33:34 - using two keys let's print the health of
33:37 - our boss so print
33:39 - players we go into our boss and we
33:43 - access the health and this prints 500
33:46 - which is correct so this way we can
33:48 - start to think of ways we can structure
33:49 - data about what's going on in our game
33:51 - such as player stats inventory Buffs and
33:54 - so on enums enom are a convenient way to
33:58 - define tags or states in our game say
34:01 - we're making a game with a bunch of
34:03 - units and we want a way to Mark each one
34:05 - as either hostile neutral or Ally in
34:08 - this case we could create an enum that
34:10 - defines these tags so at the top here
34:13 - I'll write enum to create a new enum and
34:16 - then in the curly brackets I'll write
34:18 - Ally neutral and enemy and now we can
34:22 - use these states in our game for example
34:24 - we can create a variable called Unit
34:26 - alignment and set it equal to any one of
34:29 - these states I'll just set it to Ally
34:32 - and this makes it really quick and easy
34:34 - to then check in our code if our unit
34:36 - has a certain alignment Also let's just
34:38 - give our enum a name here to stay
34:40 - organized so I'm going to call this
34:43 - alignment and now whenever we are
34:45 - accessing a state we have to go inside
34:47 - of alignment Dot and here you can see
34:50 - our state so I'll go alignment. Ali by
34:53 - default and then inside of ready we can
34:55 - check if unit alignment
34:57 - is equal to alignment dot let's check
35:00 - for enemy and if it is we will print you
35:04 - are not welcome here and if it's not so
35:08 - it's not an enemy we'll just write
35:11 - welcome and now if we run we can see
35:14 - that our console displays welcome
35:16 - because our unit alignment is currently
35:18 - Ally this is much safer than using say a
35:22 - string or an integer to represent States
35:25 - because K will throw an error if we
35:27 - misspell a state
35:28 - if for example I misspell enemy we can
35:30 - see that Gau throws an error but I think
35:33 - one of the real powers of enums is that
35:35 - we can use them for exported variables
35:38 - to do this we Mark our variable here
35:40 - with
35:42 - export and then set the type to
35:44 - alignment and now we can actually set
35:47 - our unit alignment in the inspector so
35:49 - I'm going to set mine to enemy here and
35:51 - now when we play it prints you are not
35:54 - welcome here really cool now what is
35:57 - actually happening happening behind the
35:58 - scenes here is that Gau is creating a
36:00 - constant for each state in our enum so
36:03 - this code here is actually completely
36:05 - identical to our first line and as you
36:08 - can see the value here increases from 0
36:11 - to 1 to two kind of like an index so an
36:13 - enum is essentially just a bunch of
36:15 - constants with an increasing value which
36:18 - means that if we try to print one of
36:20 - these states say you print alignment do
36:24 - enemy the console simply shows the value
36:26 - of that con
36:28 - which is two because it's the third
36:30 - state this is rarely something you need
36:32 - to take into account but it's nice to
36:34 - know what our code is actually doing and
36:36 - we can even overwrite the default value
36:38 - if we want so we could set Alli equal to
36:41 - 1 neutral equal to0 and enemy equal to
36:45 - minus1 and now our console displays
36:48 - minus one because that's now the value
36:50 - of our enemy constant now something that
36:52 - pairs really nicely with enums are match
36:55 - statements because they allow us to
36:56 - quickly add function it for each state
36:59 - match match is the Gau equivalent of the
37:02 - switch statement from other languages
37:04 - and allows us to execute different code
37:06 - depending on the value of a variable in
37:08 - this case here we can use a match
37:09 - statement to add some code for the
37:11 - different values of our enum so I'll
37:13 - write match then the variable we are
37:15 - matching based on which is my alignment
37:18 - colon and now we add code for each value
37:20 - so in case my alignment is alignment.
37:25 - Ali I'll print hello
37:28 - friend if it is neutral I'll print a
37:33 - common piece if it is enemy taste my
37:38 - wrath and a cool thing here is that we
37:40 - can actually add a default response as
37:43 - well to do that we do underscore colon
37:46 - and so if it isn't any of the cases
37:48 - above we'll
37:50 - print who art thou and if we set my
37:53 - alignment to say enemy taste my wrath
37:58 - modifying nodes 2.0 so far when we need
38:01 - to access a node we've done so by simply
38:03 - dragging it into our script which
38:05 - creates a dollar sign followed by the
38:07 - path to the Noe I've created a few empty
38:10 - noes here to demonstrate a play a note
38:12 - with a graphics and weapon node and an
38:14 - enemy node so if I drag in the weapon
38:17 - node it creates a path that goes into
38:19 - the player and finds the weapon and we
38:21 - can actually store this reference in a
38:23 - variable to do this we simply drag it to
38:26 - the top and hold down scol while
38:28 - releasing this automatically creates a
38:30 - variable with the name of the node and
38:31 - the correct path and as you can see it
38:34 - uses the on ready keyword this is
38:36 - because gdau has a very strict order in
38:38 - which nodes are created and if we open
38:40 - the game and try to find the weapon node
38:42 - before it exists we will get an error on
38:45 - ready simply make sure that Gau Waits
38:47 - until all child nodes have been created
38:49 - so we don't get any issues and just a
38:51 - quick note the doll sign here is
38:53 - actually just shorthand for using the G
38:55 - node function so this is actually
38:57 - identical also you might have noticed
38:59 - that the path is relative our script is
39:02 - on the main node so it starts right
39:04 - after that Noe we can print the absolute
39:06 - path through script we'll print weapon.
39:10 - get path this prints the absolute path
39:12 - starting from the root of our game all
39:14 - the way to weapon now paths are great
39:17 - for many things but sometimes they can
39:19 - be a bit inflexible they break if we
39:22 - rename any of the nodes in the path and
39:24 - it's best to only use paths when the
39:25 - node we want to access is at of the node
39:27 - we're working on we'll talk more about
39:29 - parent child relationships later luckily
39:32 - we can also use the export keyword to
39:34 - reference other nodes so if we write
39:37 - export and create a variable called my
39:39 - node we can set the type to node and
39:42 - then in the inspector we can assign
39:43 - whatever node we want or simply click
39:46 - and drag I'll drag in the player we can
39:49 - also check if the node is a certain type
39:51 - by using the is keyword so in ready
39:53 - we'll check if my node is of type node
39:56 - 2D in which case we'll print is 2D and
40:01 - it is we can even be specific about what
40:04 - type of note we want to be able to
40:05 - reference if for example we only want to
40:07 - reference Sprite nodes we just change
40:10 - the type to Sprite so Sprite 2D I'll
40:13 - reset the variable here and now we can
40:16 - only assign Sprites which in this case
40:19 - are the graphics and weapon nodes now if
40:21 - we play it still prints that this node
40:24 - is a 2d node even though Sprite 2D and
40:27 - no node 2D are two different nodes this
40:30 - is because Sprite 2D inherits from node
40:32 - 2D but we'll get into that in the
40:34 - inheritance chapter signals signals are
40:38 - messages that nodes can send to each
40:39 - other we use them to notify that a
40:42 - certain event occurred it's probably
40:43 - easiest to look at an example gdau has
40:46 - many built-in signals take this UI
40:49 - button if we select it and go to node we
40:52 - can see a list of all the signals on
40:54 - this node I'm going to connect the
40:56 - Pressed signal to our main script so
40:58 - double click it I'm going to select Main
41:01 - and hit connect as you can see this
41:03 - creates a function called on button
41:04 - pressed and over here there's a green
41:06 - arrow pointing to it this means that a
41:09 - signal is currently connected to this
41:10 - function if I click on it we can see the
41:13 - source which is our button let's just
41:15 - add a Quick Print line here and now if
41:18 - we play and press the button it prints
41:21 - money get it now this is because
41:23 - whenever we press the button it emits
41:25 - the Pressed signal and everything
41:27 - connected to it gets called in this case
41:29 - our on button pressed function which
41:31 - indeed prints money we can connect as
41:34 - many functions as we want to a signal
41:36 - they will all be called when it gets
41:37 - emitted this is really cool because it
41:39 - allows us to link together nodes in a
41:41 - way where they don't have to be aware of
41:43 - each other the button has no idea which
41:45 - functions are connected to the signal it
41:47 - just tells it to emit this makes signals
41:49 - great for separating different parts of
41:51 - our game or decoupling say we're playing
41:54 - a character that can level up by getting
41:56 - enough XP whenever we level up there are
41:58 - probably many game systems that need to
42:00 - update the UI our player stats perhaps
42:03 - we have spells or achievements that
42:05 - unlock and updating all of these from
42:07 - the player can quickly become a mess
42:10 - instead we create a leveled up signal
42:12 - that all these systems can connect to
42:14 - then all we need to do is have the
42:16 - player emit the signal when we level up
42:18 - let's try it out instead of a button
42:21 - here I'll create a timer so I'll add a
42:23 - timer node and set it to auto start this
42:26 - will count down from one and when it
42:29 - reaches zero it emits a signal called
42:32 - timeout let's connect that to our script
42:34 - and make it increase our XP so we'll
42:37 - create an XP variable default it to zero
42:41 - then in our function we increase our XP
42:45 - and let's also print it if our XP then
42:48 - reaches say 20 we'll set it back to zero
42:51 - we leveled up and we can start over for
42:53 - the new level and if we then play it's
42:56 - going to increment our XP every second
42:58 - and when we reach 20 it's going to go
43:00 - back to zero now let's create a signal
43:03 - that other nodes can connect to so at
43:05 - the top we'll write signal leveled up
43:07 - and if we save this and select our main
43:09 - node we can actually see that signal we
43:12 - can connect it to other nodes but just
43:14 - for this example we'll connect it back
43:16 - to our main node this creates an
43:17 - unleveled up function which is called
43:19 - when the signal is emitted let's print a
43:21 - message that says ding now we simply
43:24 - have to emit the signal let's do that
43:26 - when we reach 20 XP here we'll write
43:28 - leveled up emit now when we reach 20 XP
43:33 - it emits the signal and we print ding
43:36 - awesome we can also connect signals
43:39 - through code I'll disconnect the signal
43:41 - in the editor and instead in a ready
43:44 - function I'll write leveled up. connect
43:47 - and the name of the function we're
43:49 - connecting to on leveled up careful here
43:52 - this will probably autocomplete with
43:54 - parentheses we don't need those we just
43:56 - want the name of the function and
43:59 - disconnecting is just as easy disconnect
44:02 - we can also pass parameters through
44:04 - signals this could be used to pass the
44:06 - level red or other useful information
44:08 - I'll just add a quick message that we
44:10 - can print so on a signal We'll add a
44:13 - parameter we'll make sure that our
44:15 - function supports this as well and
44:17 - instead of printing ding we'll print
44:18 - whatever message was input and then when
44:21 - we emit the signal we can put in a
44:22 - message let's put in grats and voila it
44:26 - displays is grats and that is signals
44:30 - get set go or just get set Getters and
44:36 - Setters allow us to add code for when a
44:38 - variable is changed this means that we
44:40 - can do things like clamp a value within
44:42 - a certain range or emit a signal letting
44:44 - other parts of our code know that the
44:46 - variable changed the example that is
44:48 - always used for this is health so we'll
44:51 - add a health variable default it to a
44:53 - 100 and then we'll use a colon to go and
44:56 - Define a Setter in the parenthesis we
44:59 - name the value that was passed in so
45:01 - this is the value that we are trying to
45:03 - change our variable to and now we can
45:05 - decide what to do we could for example
45:07 - set our health equal to not the value
45:10 - directly but clamp it first
45:12 - between 0 and 100 so this makes sure
45:16 - that our health does never exceed 100 or
45:19 - go below zero we could also emit a
45:22 - signal here so we can create a
45:25 - signal Health chain and we can actually
45:28 - input the new health as a parameter and
45:31 - then in our Setter we can go Health
45:33 - changed. Emit and put in the new health
45:37 - of course we need to make sure to
45:38 - connect this signal we can do that
45:40 - through the editor and let's just print
45:43 - the value so we'll print the new health
45:46 - then in ready let's try this out by
45:48 - assigning a value to health let's try
45:50 - assigning -150 and now if we play we can
45:54 - see that it prints zero this is because
45:56 - we put in - 150 it clamps this to zero
46:01 - and then it emits the signal the signal
46:03 - then calls the onhealth changed function
46:07 - and we print the new health which is
46:09 - zero so that's a good example of adding
46:11 - a Setter Getters are more commonly use
46:14 - to convert values so let's add two
46:16 - variables we'll have a chance that is
46:17 - equal to2 and then we can have another
46:20 - one which is our chance in percent we'll
46:23 - make this of type int and we will add a
46:26 - getter here whenever we try to get the
46:29 - chance percentage we'll simply return
46:31 - the chance variable times 100 and now if
46:35 - we try to print this variable print
46:37 - chance percentage or change our chance
46:42 - to Let's say6 and print it again we can
46:46 - see that our chance percentage is
46:47 - completely based on whatever our chance
46:49 - is currently equal to and so it starts
46:52 - at 20% and then goes to 60% and for good
46:55 - measure sake We'll add a Setter also so
46:58 - if we set to a new value we will modify
47:01 - our chance and set it equal to the new
47:04 - value divided by 100 and since our
47:07 - chance is a float we'll make sure to
47:09 - cast that value so now instead of
47:12 - changing the chance we can directly
47:14 - change the change percentage to say 40
47:19 - there we go
47:20 - classes this is a good one GD script is
47:23 - an objectoriented programming language
47:25 - this means that we gener try to
47:27 - structure our code inside of contained
47:29 - objects that interact with each other we
47:32 - primarily do this using classes for now
47:35 - try to think of a class as a blueprint
47:38 - say for example we are making an RPG and
47:40 - we need to populate it with a bunch of
47:42 - characters that the player can interact
47:43 - with so we create a character class that
47:46 - has some variables and logic that all
47:48 - characters in the game should have so
47:50 - for variables we could add things like
47:52 - name health and a line of dialogue for
47:54 - when you interact with them for logic we
47:56 - could could add functions like talk and
47:58 - die then we take this class and create
48:01 - instances instances are specific
48:04 - versions of the class so we could create
48:06 - an instance named potion seller that has
48:08 - a health of 50 and a line that says you
48:11 - can't handle my strongest potions and a
48:14 - bunch more instances all of which have
48:15 - the same variables but different values
48:18 - and all of which can talk I used to be
48:20 - an adventurer like you and
48:23 - die so that's the idea of classes in
48:27 - you've actually already encountered a
48:28 - bunch of classes that's because all the
48:30 - built-in noes in Gau are classes which
48:33 - actually makes a lot of sense if you
48:34 - think about it all the nodes are
48:36 - self-contained objects with a bunch of
48:38 - variables and logic that we can create
48:40 - instances of if we add a Sprite node
48:43 - we're instancing the Sprite class so
48:45 - when we create a script we are actually
48:47 - also creating a class I have to put a
48:50 - disclaimer here that we're technically
48:51 - not creating a class but for all intents
48:53 - and purposes it works just like one so
48:56 - let's forget all about that for now so
48:58 - let's abandon our main script here for
48:59 - now and instead create a new node so
49:02 - search for node and let's name this node
49:05 - character and add a script to it now to
49:09 - make it more clear that our script is a
49:11 - class that defines a character let's set
49:13 - the class name to character so right at
49:16 - the top here we'll go class name
49:19 - character with a Capital C and we can
49:22 - now add some variables we'll mark these
49:24 - with export so that we can set them in
49:26 - in the inspector for each character
49:28 - instance so export VAR let's add a
49:32 - profession of type string and give each
49:36 - character a health as well of type
49:39 - integer and so now we can see that our
49:42 - character here has these two properties
49:44 - in the inspector and we can go ahead and
49:46 - fill out the profession this is going to
49:48 - be the potion seller who is going to
49:50 - have a health of let's say 40 and now we
49:53 - can create more instances by duplicating
49:55 - this node so let's duplicate it a few
49:58 - times the second character here will
50:00 - name X
50:01 - Adventurer with a health of 30 and the
50:05 - last character will be our
50:07 - Knight and we'll give him a health of
50:09 - say 150 so now we have these three
50:12 - instances with different properties and
50:14 - we can also give them a function so
50:16 - let's add a die function so I'll write
50:19 - Funk die and this function is going to
50:22 - set our health to zero as well as print
50:25 - our profession and the fact that we died
50:29 - and that's it for our character class
50:31 - but currently nothing is triggering this
50:34 - function so let's go into our main
50:36 - script now and here we can get a
50:39 - reference to one of our characters and
50:41 - call the die function we could simply
50:43 - drag and drop one of these nodes to get
50:45 - a reference but because we have named
50:47 - our class we can actually use an export
50:50 - variable for this instead this way we
50:52 - can set the connection in the editor and
50:54 - we don't have to worry about the path
50:56 - changing so we'll write export VAR and
50:59 - here we'll have a character to kill of
51:02 - type character and now if we save that
51:06 - we can see that our main node now has a
51:08 - slot here for the character to kill and
51:11 - we can either drag in one of these
51:12 - characters or hit assign and select one
51:15 - I'm going to choose character three and
51:17 - now in our ready method we simply go to
51:19 - our character to kill and call the die
51:22 - function and if we run this indeed the
51:26 - die function fun is called on our
51:27 - character three which is our Knight so
51:29 - it says Knight died and if we choose
51:33 - another character say the first one we
51:36 - are instead killing the potion seller
51:39 - really cool inner classes these are
51:42 - classes that exist inside of another
51:44 - class you mostly use these for bundling
51:46 - together variables and maybe add a
51:48 - function or two they can be a good
51:50 - alternative to dictionaries because they
51:51 - are sometimes a bit more safe to use say
51:54 - we have this character class here and we
51:56 - would like to add some equipment we
51:58 - could create an inner class called
52:00 - equipment so I'll write class equipment
52:03 - and then we can give it a couple of
52:05 - variables I'll create an armor variable
52:07 - set it to 10 by default and a weight of
52:11 - five now we can use this class around
52:14 - our script so we could create some
52:15 - variables using it I'll create a chest
52:19 - that is equal to equipment. new calling.
52:23 - new will create an instance of the
52:24 - equipment class so now we have one piece
52:27 - of equipment one instance which is a
52:29 - chest we'll also create legs and again
52:32 - we'll call equipment. new then in the
52:35 - ready
52:36 - function we can access these classes so
52:39 - we can go into our chest and change the
52:41 - armor and set it equal to 20 we then
52:44 - print chest. armor or maybe print legs.
52:50 - weight and this is also where you can
52:51 - see that this is sometimes safer than
52:53 - using a dictionary because GD script
52:55 - will recognize that there is a weight
52:57 - variable inside of the equipment class
52:59 - and if we try to access something that
53:01 - isn't there we'll get an error before
53:02 - playing the game not only when we reach
53:04 - this point in our code this is called
53:07 - being type safe and now if we run this
53:09 - we can see that each of the instances of
53:12 - our character will print these two
53:14 - pieces of equipment and the armor of the
53:16 - chest is 20 and the weight of the legs
53:19 - is five inheritance so we know that all
53:22 - notes in Gau are classes and we can
53:25 - effectively make our own using scripts
53:28 - but there's one more important thing we
53:29 - need to know to understand how Kau is
53:31 - structured inheritance inheritance
53:33 - refers to the ability to derive one
53:36 - class from another we've actually
53:38 - already been doing this notice how our
53:40 - script says extends node so our script
53:43 - deres from the node class this means
53:45 - that all the functions and variables of
53:47 - the node class are also available in
53:50 - rscript gdo actually has a very nice way
53:53 - of visualizing this when adding a new
53:55 - node we can see all the nodes available
53:58 - to us but some of these are organized
54:01 - under other nodes that's because these
54:03 - nodes inherit from the top ones for
54:06 - example both animated Sprite 2D and
54:08 - Camera 2D inherit from note 2D this is
54:12 - because node 2D is a base class for all
54:14 - things that exist in 2D space so since
54:16 - both a camera and a Sprite needs a
54:18 - position in our world they both inherit
54:20 - from it and even cooler we can actually
54:23 - find our character class on this list as
54:26 - well that's because when we create a
54:28 - character class we're essentially
54:29 - defining a new node type and we can see
54:32 - that it inherits from node really cool
54:35 - now all of this Probably sounds a bit
54:38 - abstract because it is but what it means
54:40 - in most cases is simply that we need to
54:42 - make sure we inherit from or extend the
54:45 - right class for what we're working with
54:47 - if for example we are making a script
54:49 - that moves around our player we would
54:51 - create a character body node and add a
54:54 - script to that node we could name it say
54:57 - player and as you can see the script
54:59 - then automatically extends character
55:01 - body 2D and we now have access to all
55:03 - the functionality in it such as the
55:06 - velocity and the move and slide function
55:09 - which moves the node around composition
55:12 - now even though gdau uses inheritance
55:14 - for its nodes there are often better
55:16 - ways to structure your code gdo actually
55:18 - leans itself really well to another way
55:21 - called composition I'm not going to
55:23 - explain that here since there's already
55:24 - a really good video on the subject by a
55:26 - channel called bit liic but I definitely
55:28 - recommend you check that out call down
55:31 - signal up when writing GD script there
55:34 - are of course many best practices that
55:36 - we can choose to adhere to going over
55:38 - all of them is a video on its own but
55:40 - one that is particularly important is
55:42 - call down signal up which we use as a
55:45 - rule of thumb when communicating between
55:47 - nodes every scening Gau is a tree of
55:50 - notes and the beginning of the tree is
55:51 - called the root node which is the
55:53 - highest in the hierarchy when looking at
55:55 - two nodes where one is right above the
55:57 - other we say that they have a parent
55:59 - child relationship the node that is
56:01 - above is the parent and the node that is
56:03 - below is the child and that child might
56:06 - also have a child and so on call down
56:08 - signal up means that notes are fine to
56:10 - call functions on the nodes below them
56:12 - in the hierarchy but not vice versa
56:14 - instead notes below should use signals
56:17 - to communicate that something has
56:18 - happened the notes above can then
56:20 - connect to these signals as they choose
56:22 - and act accordingly think of it like
56:25 - real life parents are allowed to tell
56:27 - their children what to do but children
56:29 - shouldn't directly command their parents
56:30 - to do things instead children signal
56:33 - their needs to the parents and the
56:35 - parents decide the next step now keep in
56:37 - mind that this is a way to remember a
56:38 - good coding practice it is definitely
56:40 - not parenting advice but what if we need
56:42 - to communicate between two nodes that
56:44 - are on the same level you guess that
56:46 - these are called siblings well here the
56:48 - common parent is in charge of connecting
56:50 - the signal from one sibling to the
56:52 - function on the other this is most often
56:55 - done in the ready function right at the
56:57 - beginning so that's the idea of the rule
56:59 - but of course always implementing this
57:01 - concept correctly requires some practice
57:03 - I'll have a link to a good article with
57:05 - some nice examples style during this
57:08 - video I've tried my best to adhere to
57:10 - the official GD script style guide these
57:12 - are the conventions we use for naming
57:14 - and order to keep our code elegant and
57:16 - readable for others I won't go into
57:18 - further detail here but I'll have a link
57:20 - to the official
57:23 - guide that was a lot of code for one
57:25 - video
57:27 - [Laughter]
57:29 - of course I haven't covered everything
57:31 - you are ever going to need in GD script
57:33 - but I hope this served as a nice
57:34 - overview of the most important aspects
57:37 - also don't forget to check out Cod
57:38 - Crafters become a better software
57:40 - engineer today by using the link below
57:42 - and get a free week and 40% off on your
57:44 - code Crafters membership so this is the
57:47 - last video we've prepared for now if you
57:49 - liked our new videos on Gau and have a
57:51 - topic that you would like to see covered
57:52 - please let us know while we don't know
57:54 - what the future holds we've had a blast
57:56 - making these videos and I hope you've
57:58 - enjoyed watching them so until next time
58:01 - stay awesome and funky
58:07 - [Music]

Cleaned transcript:

GD script A highlevel objectoriented imperative and gradually typed programming language with syntax a lot like python build specifically for good do I know that sounds like a lot but today we're going to learn it while it's of course impossible to cover everything and entire programming language has to offer in just one video will certainly try in fact we'll cover everything from variables and conditionals to getting input inheritance dictionaries signals and the list goes on and who knows perhaps we'll even figure out what GD stands for candle script Green Day script gadolinium we might never know we'll start with the things that I consider to be most important for beginners and then move on to more abstract programming Concepts as we progress it's not as much a follow along as it is an overview so if you're a beginner lean back and know that you don't have to understand everything the first time also it's totally okay to stop the video and try some of these things out you can always come back to it at a later time we've made sure to split everything into clearly named sections so hopefully you'll be able to use this as a reference manual going forward and if you're a season programmer transitioning to GD script this video should provide you with a nice overview of the tools at your disposal and how to approach doing different things keep in mind that this is a video on GD script not an introduction to gdau so if you've never opened up gdau before I suggest you begin with our video on making your very first game in gdau all right without further Ado let's learn G P script but first this video is sponsored by codec Crafters if you've been writing software for a while and are looking to take your skills to a whole new level code Crafters is the place to be code Crafters allows you to practice writing complex software by challenging yourself with real world projects you get to build your own git implementation your own HTTP server or even your own bit T client along the way you will practice Advanced system design and gain a greater understanding of lower level programming Concepts such as networking OS interaction and performance and when you're done you'll have a really impressive project to add to your portfolio on top of this you get to try new languages like python C C++ and many many more also new challenges are constantly being added I for one voted for the compiler challenge to be next so become a better software engineer today by signing up for code Crafters use the link below to get one week free and 40% off on all membership plans hello world so here we are in an mty kodo project it's really ious in here as it is custom let's begin by making a script and adding some code to print a message to do that we need a test scene so let's go and hit the plus I'll add in a node rename it to Main and let's save this as a scene so I'll hit control s hit save let's add a script by pressing the scroll we'll use the default template and the name of the script should be main as well with a non capital M this creates a script with two functions we'll start by focusing on the top one named ready think of this as the start of our game as it says here this function is called when the node enters the scene tree for the first time which happens right when we play our game so we can put code in here that we want to happen immediately I'll get rid of the other function for now you can zoom in by holding down control while scrolling now right now the only thing in our ready function is the pass keyword pass basically means do nothing and it will appear in functions we haven't filled out yet so let's replace it with some code that our message we'll write print and inside of the parenthesis we'll put our message in quotation marks hello world we can then run the game by pressing this button here or hitting F5 it's going to ask us which scene we are going to run we'll hit select current and while our game isn't very exciting yet we can now see that the console prints our message the output window here or the console is where it will display prints and it's also where we check for errors now to stop our game from running we press the sub button here or press f8 syntax now this might have worked for you and it might not that's because there are a few things to be aware of when writing GD script the first is that statements like print here terminate with a new line there's no need to add a semicolon at the end like in many cbased languages and GD script similar to a language like python uses indentation to determine the structure of your code this means that you use tabs to tell TD script where your code belongs belongs in our example here I'm using a tab to tell kodo that our print line belongs to the ready function if I delete this tab I get an error also GD script is case sensitive so if I write print with a capital P I will also get an error so just a couple of things to look out for there now printing to the console is cool or I mean maybe not as cool as backflips but well I can teach you to do those but I can teach you how to display text in the game window instead to do that we'll need to modify a through script modifying nodes 1.0 first we need a node to modify let's use a label so I'll add a new node choose label I'll zoom in Center it on the screen make some more room let's add a default text this is a label I'll Center it and overwrite the font size now to edit the text of this label through script we need two things we need a reference to the label and we need to access the property in this label that we want to change in this case the text if we hover over text we can see the name of the property through script which is text with a non capital T so in our main script we'll first get a reference and we can actually do this by simply taking the label and dragging it into our ready function then we can access the property by going Dot and we'll type in text and set it equal to hello world and now when we play our label changes to hello world and we can use this exact method to change other things as well such as the color of the text in fact there's a property called modulate which allows us to tint Sprites and UI elements in the inspector you can find it all the way down here under visibility let's change it to Green so again we'll click and drag to create a reference to the label write. modulate and set it equal to color dot here we have a bunch of different colors we'll choose green and voila our label is now green so this is how we can make changes to nodes when our game is running but right now not much is happening during our game so let's see how we can use input to make our game respond to our actions input let's say we want to turn this label red when we press the space bar to do this we first need to set up an input action we'll go project project settings input map here we can add actions actions allow us to bind keys to something that we want to happen common actions would be shoot jump or so on in our case we wanted to change a color I'll just go ahead and call it my action so we can use it later for other things now let's hit add and here is our action let's find the key to it by pressing plus it's now listening for input I'm going to press this space bar and hit okay and now our space bar is bound to my action then in our script we need to create an input function we'll write funk for function underscore input and let's hit enter to autoc complete now just like ready this is one of the buildin functions of gdo but instead of being called at the start of the game it runs every time the game receives any input such as when we press a button event is what we call the information about what triggered the function was it a movement of the mouse or the Press of a key we need to check if the event that triggered the input was our action being pressed so we'll write if event. is action pressed and as you can see our action shows up here my action then we'll put in a colon and if we pressed my action well then we'll change the color so we'll drag in the label write modulate and set it equal to color do red and we can just as easily check if the action was released we'll go if event do is action released this time my action well then we'll take the exact same line and change it back to green so now when we play and I press the space bar it turns red and when I release it it turns back to green that's right we made a party he disco party now this is just one out of many ways to handle input in gudo but since we're focusing on the GD script language I'm not going to go further into it here I'll make sure to provide a link to where I can learn more about input if you're interested variables 1.0 variables are essentially containers that hold information in the case of a player character we could use variables for information like the player's name Health damage and perhaps if the player is alive or not let's make a health variable at the top here I'll write bar for variable the name of our variable and then we'll set it equal to a default value now we can print this variable inside of our ready function we write print health and if we play you can see that it now prints 100 now we can easily change our variable so before printing let's assign a new number Health equal 40 we can also assign a calculation so Health = 20 + 30 we'll set our health to 50 we can also add Health Plus equals and then 20 we'll add 20 to our health and subtract Health minus equals to multiply we do times equals and to divide we do slash equals so if we run this now it will do all of these calculations from top to bottom and then print out the result which turns out to be 120 let's look at an example where our player takes some damage and we want to subtract the damage from our health let's try decreasing our health variable whenever we press the action we made earlier so in the input function we'll check if the action was pressed and then we'll subtract from our health and we can print the result so now every time I press the space bar bound to my action we can see that I reduced the health really cool but as you can see we can currently reduce our health below zero and nothing happens when we do so if we were making a game we'd probably want our player to die and the game to restart luckily we can make our game react to variables by using IF statements if statements or conditionals if statements are the glue that holds all of our logic together we've actually already used if statements to check if our action was pressed but they can do so much more yet they are really simple an if statement is just a condition that needs to be met in order for the code inside to be run let's add an if statement here to check if our health reaches zero so I'll make some room write if health is less than than or equal to Zer well then we'll set our health to zero and we'll print that we died and now when our health gets to zero it prints you died now here we're using less than and equal to to compare our health to the value zero but there are many more comparisons we can make here are all the comparisons we use such as is equal to is not equal to and so on we can also add more conditions to one if statement we use the and keyword to add another condition where both need to be met and the or keyword to add a condition where only one of them needs to be met now one really useful thing about if statements is that we cannot only Define what happens when the condition is true we can also choose what happens when it's false we do this using the else keyword let's add an else to print that we are still alive if our health hasn't reached zero yet so if our health is less than or equal to zero we died else we print you are healthy and even cooler we can chain together if statements using else if or El if for short so we check if our health reaches zero and if not else if El if our health goes below 50 well then we'll print that we are injured and if neither of these two are true we'll go to else and say that we are healthy and if we play we can see that at 80 we are healthy at 60 we are still healthy then we are injured and at zero we die very cool note that the if statement we made here is nested under another if statement you can easily layer if statements to get more and more specific functionality however try not to overdo it you can quickly get lost in the ifs actually a lot of people don't know this but that's why programmers and philosophers have so much in common we both tend to spend a lot of time with the ifs and the wh ifs so if you get frustrated along the way remember that so was PlayDoh anyway that's it for if statements comments we use comments to help explain and remember the what and the why of our code adding a comment is simple and can be done above or after a line so if we have some code we can make a comment above the line and this is a comment about the code that follows or we could make one right after and this is a comment about this line only we can also use comments to temporarily remove parts of our code from being executed here we simp simply put a hashtag in front of the code and it's good practice to emit the space here to indicate that what follows is code we can also select multiple lines of code right click and toggle comment just remember that you can't have a completely empty function we need to add the pass keyword to avoid an error variables 2.0 when creating or declaring a variable we need to think about where we do so if we declare a variable inside of an if statement for example we can only use that variable inside of the if statement M this is called scope and it's something that beginners often make mistakes with if we want to use a variable in many different places in our script we make sure to put it at the top outside of any functions so this is a script wide variable this can be accessed anywhere in your script if you were to declare it inside of a function you would only be able to use it in that function so this is a variable we can only use in ready now a really cool thing about variables in GD script is that you can declare them without thinking about what type of data is inside them here's a variable that is either true or false and here's a variable that stores a number as you can see they're created in the exact same way in fact we can even change the type of data that they hold just by reassigning them so we can actually set our coolness to true and this runs completely fine that being said we still need to be aware of what type of data we're working with because some parts of our game will expect a specific type of data and we will get an error if we try to use another type without converting now in GD script we have the four classic data types Boolean or bull for true and false integer or int for whole numbers float for numbers with decimals and string for text converting from one type to another is called casting for example we can cast an integer into a string so if we have a number that is equal to 42 and we have some text which is a string well then we can add add the number to this text but we convert it into a string by writing Str Str for string and then the variable inside of the parentheses and if we print this it works fine we can do a similar thing to say convert a float into an integer so if we have a variable called Pi that is equal to 3.14 then we can convert this into an integer by going int pi and let's print this and it prints three a whole number note however that this automatically truncates the number it does not round it simply gets rid of the decimals so 3.9 also results in three some other data structures that are really common in GD script are Vector 2 and three Vector 2 stores two floats X and Y and Vector 3 stores three floats X Y and Z these are most commonly used for positions so I can create a variable called position with some coordinates I can then modify one of the components so position X plus = 2 adds 2 to the X component and then we can print the whole thing and this gives a vector 3 of 5 10 5 Now by default gdscript is what we call dynamically typed this means that we don't Define what type of data a variable can hold when we declare it which we've been using so far this makes it fast to create variables and flexible because we can reassign data of another type at will however it is also more prone to error and less performant than static typing luckily GD script allows us to statically type any variables we want we can pick and choose totally based on preference to statically type a variable we simply add the type when declaring it so here if we have a damage variable we can specify the type and then set the value so now this variable will always stay an integer we can even have gdo automatically determine the data type by simply writing colon equals and then the default value this is called invert typing and the result is exactly the same the type is still static kdo simply recognizes that 15 is a whole number and sets the variable to a type of in this also means that the variable cannot change to another type if we try to set it to a string we get an error now adding export in front of a variable will allow us to set it using the inspector the value that we set in the script will just be a default value so if we save this and select our node we can set a value in the inspector if we print our damage we can see that this updates in our game and we can always press the circular Arrow to revert back to the default now sometimes you want to Define a variable that cannot change for this we use constants so I'll write const for constant we'll call it gravity as you can see it's standard practice to name constants with capital letters and we'll set it equal to 9.81 now we can use this like any other variable but we cannot change it if we try to do that it throws an error and that's it for variables great job functions functions are the bread and B of programming they allow you to bundle up your code in small reusable packages so far we've been using some of gau's buildin functions like ready and input notice how these are prefixed with an underscore this is to show that they are not activated or called by us but by the engine itself but we can actually make our own functions and use them to do really cool things common functions to making games are things like jump die shoot and respawn and making a function is actually really easy let's make a function for jumping so we'll write Funk then the name of our function open and close parenthesis and a colon then in here we'll put all of our code for jumping so we could add an upwards Force play a funny sound and a jump animation for now we'll just print jump but nothing is currently triggering or calling our function let's call it whenever we press the action we made earlier so Funk input event and if our action was pressed then we call our jump function by writing jump followed by open and close parenthesis and now when I press space it displays jump and at this point I encourage you to add the sound effect yourself a lot of fun to be had here now this already makes our code more readable and reusable but right now our function is just a simple command we call call it and it does some things however we can actually use functions for much more than this they can have inputs and outputs let me explain I like to think of functions as machines take for example this coffee maker just like the name implies it performs a function to make coffee to do this however it needs some input some water a filter and some ground coffee with this it performs its function and then spills out an output delicious coffee in code we call the input we give our function parameters and the output is called returns so let's make a function that adds together two numbers Funk add and then inside of our parentheses we add the parameters so number one we'll call num one and the second number will call num two then inside our function we can add these together and store them in a result variable so we'll set that equal to num 1 + num 2 and for now let's just print the result then in ready let's try calling this function so we'll call add we'll give it the first number three and the second one let's do eight and let's actually call it again so let's do a harder one let's add 245 with 111 and indeed it prints 3 + 8 which is 11 and 356 which is the result of our second calculation so here we've created a function with two parameters the numbers we want to add together but the function actually doesn't return the result it just prints it this means that we can't actually access the result where we are calling the function up here and ready to return the result we replace print with return so we'll do return result and now up here we can store the result in a variable set it equal to add and we'll add together three and five and we can print that and the result is eight and because we have access to it up here we can do more things I add more numbers to it so we can say result equal to add and pass in the result from before and add 10 and then print it and there you go we now get 18 because 3 + 5 + 10 is 18 really cool and just like when declaring variables we can also statically type parameters and return types to make it clear that the function is made to work with numbers so after num one we'll specify that this is an integer we'll do the same thing with num two and here we can set the return type using an arrow and this is also an integer so now this function will only work with numbers 3 4 6 8 2 1 one and a half random numbers getting random numbers is very easy the function Rand F gives a random number between 0 and one it's great for assigning probabilities to your code say we are deciding what loot to give the player and we want to make some loot more rare than other well in this case we could create a ro variable and set it equal to randf then we could check if the roll is less than or equal to 0.8 which means there's an 80% chance that we print you found a common item and if not well then there's a 20% chance that you found a rare item and if we play this most of the time it's going to display that we found a common item but if we keep playing if we keep playing keep playing eventually there's a 20% chance so at some point we'll eventually this is we'll eventually find a rare item that was crazy we can also use Rand F range and Rand I range to get a random float or integer between a minimum and maximum value say to assign a random height to a character so bar character height equals Rand I range for a random integer between 140 and let's doe 210 and we'll print that your character is then we'll insert the height remember to convert to a string cm tall and we'll roll a character and apparently I am a giant basketball here I come documentation GD script is actually pretty well documented and one of the really cool things about it is that the documentation is linked with the editor if we hold down control and click on something we would like to know more about such as the randai range function it opens up the documentation right here in the editor this is a really quick and easy way to check if you're using a function correctly it also works for classes which we'll learn about later arrays sometimes you want a variable that can hold more than one thing in fact sometimes you might want to store a whole list of elements for this we use arrays defining an array is very easy let's make one to hold items in an inventory so we'll create a normal variable and set it equal to open and close square brackets this creates an empty array we can then add elements inside the square brackets I'll add a potion string the number three and the number six notice how unlike many other languages GD script has no problem mixing data types within an array but if you want to constrain an array to a specific type we can of course statically type it so here we simply add the type this is an array and the elements inside it are going to be strings so that's the Syntax for that and now we get an error because three is not a string so we'll replace this with feather and six is also not a string we'll replace that with stolen heart now the way that we access elements in an array is by using an index when you add an element to an array it is automatically assigned a number based on its position in the array in this case the first element potion has an index of zero feather has an index of one and the stolen harp has an index of two so to access and print the first element in our array we write print items and then we access the first element which has an index of zero and This spells out potion pretty cool we can just as easily change elements this changes the second element to smelly sck and the third element to staff and arrays also have functions for finding removing or adding new elements so to remove at an index we write remove add and then the index one this removes the smelly sock and to add a new elements we write do append and we'll append an overpowered sword to the end of the array now arrays can quickly become long and difficult to manually go over luckily we can use something called Loops to help out loops loops loops loops allow us to repeat code a number of times with small variations they are perfect for iterating through all the elements in an array if for example we wanted to print out all the items in our array here we can do that easily by using a for Loop so we write four then the name of the item that we're currently looking at we'll just name that it item in the array so in items we will print out the current item we're looking at so print item and as you can see it prints potion feather and stolen harp this is cool because we can have any number of items in our array the code will work just fine we can also add more functionality say to only print items that are more than 6 letter long if item. length so the amount of characters in item is greater than let's say six then we're going to print that item and now it only prints feather and stolen harp because potion is exactly six letters we can also create Loops that run a certain amount of times if we write 4 n in 8 it creates a for Loop where the variable n starts at zero then goes all the way to seven so if we print n we can see that it runs eight times and N starts at zero and ends at 7even we say that n is the current iteration of the loop another type of loop is the while loop this repeats as long as a certain condition is met now I think most people who know me would say that I'm a glass half full kind of person and to those who disagree let me go ahead and prove it by using a while loop to fill up a glass halfway so I'll create a glass variable and default it to 0.0 the glass is currently empty no arguing about that then we'll create a while loop that continues while glass is less than 0.5 so we have haven't filled it up halfway yet in which case we will add a certain amount to our glass we could do a constant amount like this or in real life when I try to pour something into a glass I'm not that precise so let's add a random number instead so we'll add a random float between 0.01 and 0.2 and then we'll print out how much is in the glass at the current time then when the loop is done we get to continue down here in our code and we'll print that the glass is now half full and if we run this we can see that the glass slowly becomes more full with a random amount each time and then it says that the glass is now half full as you can also see it overshoots a bit because we're adding a random amount each time and not claming the value just like when trying to hit exactly half a glass in real life my wife says that I add too much milk when I make her coffee I think I'll refer her to this going forward now we actually have to be really careful when using while Loops that we don't create an infinite Loop these can be tricky to avoid and can very easily crash our program say if I were to remove this line that adds a little bit to our glass every time well then our glass would actually never become half full and we would be stuck in this Loop forever now I don't think this will actually crash Gau indeed it didn't but we get a lot of overflow errors and as you can see our game is definitely not responding not good finally in both for and while Loops we can use the break and continue keywords break as the name suggests breaks out of the loop and moves on to the code after while continue immediately skips to the next iteration of the loop so if we were to write if glass is greater than 0.2 and then break we can see that our while loop ends way early because we exit out of the loop before we even get to print that the glass reached 0.2 dictionaries they sound really boring but they're really cool while arrays are great for storing lists of elements it's sometimes confusing to access each element with an index sometimes it makes more sense to use a dictionary dictionaries hold what we call key value pairs let me explain in real life we use a dictionary to look up the definition of words in a language the key in this instance is the word we're looking up and the value is the definition dictionaries and TD script work the exact same way creating an empty dictionary is really easy we write VAR I'll call this one my dict and set it equal to some curly brackets this is an empty dictionary we can then add key value pairs inside the curly brackets say for example that we have multiple players in our game we can use a dictionary to keep track of them each player has a username this will be the key and a level this will be the value so I'll create a player called Crook and this level is going to be one I'll create a another player villain with a level of 35 and finally a player with the username boss with a level of 100 if defining on one line becomes too much you can split it up like this and it's good practice to add a comma to the last entry so you're ready for a new one and let's name this dictionary players then to get the level of a player we simply type in the username let's print the level of our villain so print and we'll write players type in villain and this should print 35 and you can just as easily assign a new value or add another entry so we can reassign the villain here to say 50 and add a new entry called Dwayne with a whooping level of 999 and just like with arrays we can Loop over a dictionary with a for Loop when we do this we are actually looping over all the keys in our dictionary so all the usernames and for each username in players we will go ahead and print out the username I'll add a string to separate and then the level so here we access our players dictionary and input the username we're currently looking on to get the value and remember to convert this into a string so Str Str to cast to a string there you go it prints our entire dictionary now just like with arrays you can have multiple data types of keys and values in the same dictionary and even cooler you can actually have arrays or dictionaries inside another dictionary this might sound really abstract but it's actually pretty cool and often comes in handy say for example we don't just want to store the level of each player but also other info like their health well then we simply replace this value with another dictionary so open and close some curly brackets here we'll add a key called level with a value of one and another key called Health with a value of 80 and at this point it's a good idea to use tabs to keep our code clean duplicate this I'll assign some values and now we can access a value by using two keys let's print the health of our boss so print players we go into our boss and we access the health and this prints 500 which is correct so this way we can start to think of ways we can structure data about what's going on in our game such as player stats inventory Buffs and so on enums enom are a convenient way to define tags or states in our game say we're making a game with a bunch of units and we want a way to Mark each one as either hostile neutral or Ally in this case we could create an enum that defines these tags so at the top here I'll write enum to create a new enum and then in the curly brackets I'll write Ally neutral and enemy and now we can use these states in our game for example we can create a variable called Unit alignment and set it equal to any one of these states I'll just set it to Ally and this makes it really quick and easy to then check in our code if our unit has a certain alignment Also let's just give our enum a name here to stay organized so I'm going to call this alignment and now whenever we are accessing a state we have to go inside of alignment Dot and here you can see our state so I'll go alignment. Ali by default and then inside of ready we can check if unit alignment is equal to alignment dot let's check for enemy and if it is we will print you are not welcome here and if it's not so it's not an enemy we'll just write welcome and now if we run we can see that our console displays welcome because our unit alignment is currently Ally this is much safer than using say a string or an integer to represent States because K will throw an error if we misspell a state if for example I misspell enemy we can see that Gau throws an error but I think one of the real powers of enums is that we can use them for exported variables to do this we Mark our variable here with export and then set the type to alignment and now we can actually set our unit alignment in the inspector so I'm going to set mine to enemy here and now when we play it prints you are not welcome here really cool now what is actually happening happening behind the scenes here is that Gau is creating a constant for each state in our enum so this code here is actually completely identical to our first line and as you can see the value here increases from 0 to 1 to two kind of like an index so an enum is essentially just a bunch of constants with an increasing value which means that if we try to print one of these states say you print alignment do enemy the console simply shows the value of that con which is two because it's the third state this is rarely something you need to take into account but it's nice to know what our code is actually doing and we can even overwrite the default value if we want so we could set Alli equal to 1 neutral equal to0 and enemy equal to minus1 and now our console displays minus one because that's now the value of our enemy constant now something that pairs really nicely with enums are match statements because they allow us to quickly add function it for each state match match is the Gau equivalent of the switch statement from other languages and allows us to execute different code depending on the value of a variable in this case here we can use a match statement to add some code for the different values of our enum so I'll write match then the variable we are matching based on which is my alignment colon and now we add code for each value so in case my alignment is alignment. Ali I'll print hello friend if it is neutral I'll print a common piece if it is enemy taste my wrath and a cool thing here is that we can actually add a default response as well to do that we do underscore colon and so if it isn't any of the cases above we'll print who art thou and if we set my alignment to say enemy taste my wrath modifying nodes 2.0 so far when we need to access a node we've done so by simply dragging it into our script which creates a dollar sign followed by the path to the Noe I've created a few empty noes here to demonstrate a play a note with a graphics and weapon node and an enemy node so if I drag in the weapon node it creates a path that goes into the player and finds the weapon and we can actually store this reference in a variable to do this we simply drag it to the top and hold down scol while releasing this automatically creates a variable with the name of the node and the correct path and as you can see it uses the on ready keyword this is because gdau has a very strict order in which nodes are created and if we open the game and try to find the weapon node before it exists we will get an error on ready simply make sure that Gau Waits until all child nodes have been created so we don't get any issues and just a quick note the doll sign here is actually just shorthand for using the G node function so this is actually identical also you might have noticed that the path is relative our script is on the main node so it starts right after that Noe we can print the absolute path through script we'll print weapon. get path this prints the absolute path starting from the root of our game all the way to weapon now paths are great for many things but sometimes they can be a bit inflexible they break if we rename any of the nodes in the path and it's best to only use paths when the node we want to access is at of the node we're working on we'll talk more about parent child relationships later luckily we can also use the export keyword to reference other nodes so if we write export and create a variable called my node we can set the type to node and then in the inspector we can assign whatever node we want or simply click and drag I'll drag in the player we can also check if the node is a certain type by using the is keyword so in ready we'll check if my node is of type node 2D in which case we'll print is 2D and it is we can even be specific about what type of note we want to be able to reference if for example we only want to reference Sprite nodes we just change the type to Sprite so Sprite 2D I'll reset the variable here and now we can only assign Sprites which in this case are the graphics and weapon nodes now if we play it still prints that this node is a 2d node even though Sprite 2D and no node 2D are two different nodes this is because Sprite 2D inherits from node 2D but we'll get into that in the inheritance chapter signals signals are messages that nodes can send to each other we use them to notify that a certain event occurred it's probably easiest to look at an example gdau has many builtin signals take this UI button if we select it and go to node we can see a list of all the signals on this node I'm going to connect the Pressed signal to our main script so double click it I'm going to select Main and hit connect as you can see this creates a function called on button pressed and over here there's a green arrow pointing to it this means that a signal is currently connected to this function if I click on it we can see the source which is our button let's just add a Quick Print line here and now if we play and press the button it prints money get it now this is because whenever we press the button it emits the Pressed signal and everything connected to it gets called in this case our on button pressed function which indeed prints money we can connect as many functions as we want to a signal they will all be called when it gets emitted this is really cool because it allows us to link together nodes in a way where they don't have to be aware of each other the button has no idea which functions are connected to the signal it just tells it to emit this makes signals great for separating different parts of our game or decoupling say we're playing a character that can level up by getting enough XP whenever we level up there are probably many game systems that need to update the UI our player stats perhaps we have spells or achievements that unlock and updating all of these from the player can quickly become a mess instead we create a leveled up signal that all these systems can connect to then all we need to do is have the player emit the signal when we level up let's try it out instead of a button here I'll create a timer so I'll add a timer node and set it to auto start this will count down from one and when it reaches zero it emits a signal called timeout let's connect that to our script and make it increase our XP so we'll create an XP variable default it to zero then in our function we increase our XP and let's also print it if our XP then reaches say 20 we'll set it back to zero we leveled up and we can start over for the new level and if we then play it's going to increment our XP every second and when we reach 20 it's going to go back to zero now let's create a signal that other nodes can connect to so at the top we'll write signal leveled up and if we save this and select our main node we can actually see that signal we can connect it to other nodes but just for this example we'll connect it back to our main node this creates an unleveled up function which is called when the signal is emitted let's print a message that says ding now we simply have to emit the signal let's do that when we reach 20 XP here we'll write leveled up emit now when we reach 20 XP it emits the signal and we print ding awesome we can also connect signals through code I'll disconnect the signal in the editor and instead in a ready function I'll write leveled up. connect and the name of the function we're connecting to on leveled up careful here this will probably autocomplete with parentheses we don't need those we just want the name of the function and disconnecting is just as easy disconnect we can also pass parameters through signals this could be used to pass the level red or other useful information I'll just add a quick message that we can print so on a signal We'll add a parameter we'll make sure that our function supports this as well and instead of printing ding we'll print whatever message was input and then when we emit the signal we can put in a message let's put in grats and voila it displays is grats and that is signals get set go or just get set Getters and Setters allow us to add code for when a variable is changed this means that we can do things like clamp a value within a certain range or emit a signal letting other parts of our code know that the variable changed the example that is always used for this is health so we'll add a health variable default it to a 100 and then we'll use a colon to go and Define a Setter in the parenthesis we name the value that was passed in so this is the value that we are trying to change our variable to and now we can decide what to do we could for example set our health equal to not the value directly but clamp it first between 0 and 100 so this makes sure that our health does never exceed 100 or go below zero we could also emit a signal here so we can create a signal Health chain and we can actually input the new health as a parameter and then in our Setter we can go Health changed. Emit and put in the new health of course we need to make sure to connect this signal we can do that through the editor and let's just print the value so we'll print the new health then in ready let's try this out by assigning a value to health let's try assigning 150 and now if we play we can see that it prints zero this is because we put in 150 it clamps this to zero and then it emits the signal the signal then calls the onhealth changed function and we print the new health which is zero so that's a good example of adding a Setter Getters are more commonly use to convert values so let's add two variables we'll have a chance that is equal to2 and then we can have another one which is our chance in percent we'll make this of type int and we will add a getter here whenever we try to get the chance percentage we'll simply return the chance variable times 100 and now if we try to print this variable print chance percentage or change our chance to Let's say6 and print it again we can see that our chance percentage is completely based on whatever our chance is currently equal to and so it starts at 20% and then goes to 60% and for good measure sake We'll add a Setter also so if we set to a new value we will modify our chance and set it equal to the new value divided by 100 and since our chance is a float we'll make sure to cast that value so now instead of changing the chance we can directly change the change percentage to say 40 there we go classes this is a good one GD script is an objectoriented programming language this means that we gener try to structure our code inside of contained objects that interact with each other we primarily do this using classes for now try to think of a class as a blueprint say for example we are making an RPG and we need to populate it with a bunch of characters that the player can interact with so we create a character class that has some variables and logic that all characters in the game should have so for variables we could add things like name health and a line of dialogue for when you interact with them for logic we could could add functions like talk and die then we take this class and create instances instances are specific versions of the class so we could create an instance named potion seller that has a health of 50 and a line that says you can't handle my strongest potions and a bunch more instances all of which have the same variables but different values and all of which can talk I used to be an adventurer like you and die so that's the idea of classes in you've actually already encountered a bunch of classes that's because all the builtin noes in Gau are classes which actually makes a lot of sense if you think about it all the nodes are selfcontained objects with a bunch of variables and logic that we can create instances of if we add a Sprite node we're instancing the Sprite class so when we create a script we are actually also creating a class I have to put a disclaimer here that we're technically not creating a class but for all intents and purposes it works just like one so let's forget all about that for now so let's abandon our main script here for now and instead create a new node so search for node and let's name this node character and add a script to it now to make it more clear that our script is a class that defines a character let's set the class name to character so right at the top here we'll go class name character with a Capital C and we can now add some variables we'll mark these with export so that we can set them in in the inspector for each character instance so export VAR let's add a profession of type string and give each character a health as well of type integer and so now we can see that our character here has these two properties in the inspector and we can go ahead and fill out the profession this is going to be the potion seller who is going to have a health of let's say 40 and now we can create more instances by duplicating this node so let's duplicate it a few times the second character here will name X Adventurer with a health of 30 and the last character will be our Knight and we'll give him a health of say 150 so now we have these three instances with different properties and we can also give them a function so let's add a die function so I'll write Funk die and this function is going to set our health to zero as well as print our profession and the fact that we died and that's it for our character class but currently nothing is triggering this function so let's go into our main script now and here we can get a reference to one of our characters and call the die function we could simply drag and drop one of these nodes to get a reference but because we have named our class we can actually use an export variable for this instead this way we can set the connection in the editor and we don't have to worry about the path changing so we'll write export VAR and here we'll have a character to kill of type character and now if we save that we can see that our main node now has a slot here for the character to kill and we can either drag in one of these characters or hit assign and select one I'm going to choose character three and now in our ready method we simply go to our character to kill and call the die function and if we run this indeed the die function fun is called on our character three which is our Knight so it says Knight died and if we choose another character say the first one we are instead killing the potion seller really cool inner classes these are classes that exist inside of another class you mostly use these for bundling together variables and maybe add a function or two they can be a good alternative to dictionaries because they are sometimes a bit more safe to use say we have this character class here and we would like to add some equipment we could create an inner class called equipment so I'll write class equipment and then we can give it a couple of variables I'll create an armor variable set it to 10 by default and a weight of five now we can use this class around our script so we could create some variables using it I'll create a chest that is equal to equipment. new calling. new will create an instance of the equipment class so now we have one piece of equipment one instance which is a chest we'll also create legs and again we'll call equipment. new then in the ready function we can access these classes so we can go into our chest and change the armor and set it equal to 20 we then print chest. armor or maybe print legs. weight and this is also where you can see that this is sometimes safer than using a dictionary because GD script will recognize that there is a weight variable inside of the equipment class and if we try to access something that isn't there we'll get an error before playing the game not only when we reach this point in our code this is called being type safe and now if we run this we can see that each of the instances of our character will print these two pieces of equipment and the armor of the chest is 20 and the weight of the legs is five inheritance so we know that all notes in Gau are classes and we can effectively make our own using scripts but there's one more important thing we need to know to understand how Kau is structured inheritance inheritance refers to the ability to derive one class from another we've actually already been doing this notice how our script says extends node so our script deres from the node class this means that all the functions and variables of the node class are also available in rscript gdo actually has a very nice way of visualizing this when adding a new node we can see all the nodes available to us but some of these are organized under other nodes that's because these nodes inherit from the top ones for example both animated Sprite 2D and Camera 2D inherit from note 2D this is because node 2D is a base class for all things that exist in 2D space so since both a camera and a Sprite needs a position in our world they both inherit from it and even cooler we can actually find our character class on this list as well that's because when we create a character class we're essentially defining a new node type and we can see that it inherits from node really cool now all of this Probably sounds a bit abstract because it is but what it means in most cases is simply that we need to make sure we inherit from or extend the right class for what we're working with if for example we are making a script that moves around our player we would create a character body node and add a script to that node we could name it say player and as you can see the script then automatically extends character body 2D and we now have access to all the functionality in it such as the velocity and the move and slide function which moves the node around composition now even though gdau uses inheritance for its nodes there are often better ways to structure your code gdo actually leans itself really well to another way called composition I'm not going to explain that here since there's already a really good video on the subject by a channel called bit liic but I definitely recommend you check that out call down signal up when writing GD script there are of course many best practices that we can choose to adhere to going over all of them is a video on its own but one that is particularly important is call down signal up which we use as a rule of thumb when communicating between nodes every scening Gau is a tree of notes and the beginning of the tree is called the root node which is the highest in the hierarchy when looking at two nodes where one is right above the other we say that they have a parent child relationship the node that is above is the parent and the node that is below is the child and that child might also have a child and so on call down signal up means that notes are fine to call functions on the nodes below them in the hierarchy but not vice versa instead notes below should use signals to communicate that something has happened the notes above can then connect to these signals as they choose and act accordingly think of it like real life parents are allowed to tell their children what to do but children shouldn't directly command their parents to do things instead children signal their needs to the parents and the parents decide the next step now keep in mind that this is a way to remember a good coding practice it is definitely not parenting advice but what if we need to communicate between two nodes that are on the same level you guess that these are called siblings well here the common parent is in charge of connecting the signal from one sibling to the function on the other this is most often done in the ready function right at the beginning so that's the idea of the rule but of course always implementing this concept correctly requires some practice I'll have a link to a good article with some nice examples style during this video I've tried my best to adhere to the official GD script style guide these are the conventions we use for naming and order to keep our code elegant and readable for others I won't go into further detail here but I'll have a link to the official guide that was a lot of code for one video [Laughter] of course I haven't covered everything you are ever going to need in GD script but I hope this served as a nice overview of the most important aspects also don't forget to check out Cod Crafters become a better software engineer today by using the link below and get a free week and 40% off on your code Crafters membership so this is the last video we've prepared for now if you liked our new videos on Gau and have a topic that you would like to see covered please let us know while we don't know what the future holds we've had a blast making these videos and I hope you've enjoyed watching them so until next time stay awesome and funky
