With timestamps:

00:00 - good do God dot godo whichever you
00:04 - prefer if you want to use it to make a
00:06 - game you've come to the right place I've
00:08 - been making video games for more than 14
00:10 - years now and recently I've fallen in
00:12 - love with Gau Gau is a great choice for
00:15 - many developers and pretty beginner
00:17 - friendly also it's open source and
00:19 - completely free to use now you probably
00:22 - have a bunch of ideas of games that
00:24 - would be cool to make but no matter if
00:26 - you're dreaming of making an FPS a 2d
00:28 - platformer or any anything in between
00:30 - using gdau the first step is of course
00:32 - to install it now this process might be
00:35 - a bit tedious but bear with me now we go
00:37 - to g.org press download latest gdo
00:42 - engine and we're done this is a huge
00:45 - advantage of gdau it's extremely
00:47 - lightweight and can even run in the
00:49 - browser now you might want to unzip this
00:52 - folder and place it somewhere you
00:54 - remember but other than that we're ready
00:57 - to open up gdau so let's double click it
01:00 - and it's going to ask us if we want to
01:01 - look at some examle projects I'll just
01:03 - press cancel then we can press new name
01:06 - our project say first game I'm going to
01:09 - place mine on my desktop under my games
01:12 - folder let's create a separate folder
01:14 - for first game so hit create folder and
01:16 - create an edit and here we are a clean
01:20 - slate a blank canvas oh I am so ready to
01:24 - make this game about well this might be
01:26 - a good time to decide what our game will
01:27 - be about but first this video is
01:29 - sponsored by Zena if you're excited
01:31 - about gdau 4 make sure to check out Zena
01:33 - Academy they offer comprehensive
01:35 - beginner and intermediate courses
01:37 - including a fantastic free introductory
01:39 - course on Gau what's really cool about
01:41 - SBA is how they combine fun and
01:43 - practical learning through professional
01:44 - video tutorials written lessons and
01:46 - interactive quizzes plus you'll be
01:48 - building real projects across various
01:50 - genres from RPGs to Bullet Hills zenva
01:53 - also has a wide range of courses on
01:55 - python Unity unreal and other essential
01:57 - tools with a single subscription which
01:59 - includes would say 7-Day free trial you
02:01 - unlock over 250 courses use the coupon
02:04 - code below to get an extra 20% off the
02:06 - first year of your s subscription on top
02:09 - of any existing side wide discounts the
02:11 - offer is valid for the first 50
02:12 - subscribers so make sure to use your
02:14 - coupon today to start your Game Dev
02:16 - Adventure so in the spirit of learning
02:18 - the basics of the engine and giving you
02:20 - an overview of how you can start using
02:22 - it to make things I've put together the
02:24 - most basic game I could imagine think of
02:26 - it like food without salt it doesn't
02:28 - have much flavor but it does have a
02:30 - player enemies moving platforms
02:33 - collectible coins and most importantly
02:35 - it should get you familiar with the
02:37 - engine in no time also will be working
02:39 - in 2D but another really cool thing
02:41 - about gdau is that it's very easy to
02:43 - transfer 2D Concepts to 3D so don't
02:46 - worry if your dream game is in 3D most
02:49 - of what you learned here is going to
02:50 - directly apply as for programming Gau
02:53 - uses its own scripting language called
02:55 - GD script it's pretty fast and easy to
02:57 - use but still quite powerful we'll do a
03:00 - bit of programming in this video to get
03:01 - you started but the main focus is really
03:04 - to get familiar with gdau as a whole and
03:06 - to quickly get a game up and running
03:08 - because of this I don't expect you to
03:09 - fully understand all the code you see
03:11 - feel free to write after me or just lean
03:13 - back and observe our next video will be
03:16 - about learning to program in GD script
03:18 - all right I promised you food without
03:20 - salt so let's get cooking
03:26 - [Music]
03:40 - now to make our delicious game we need
03:42 - ingredients we need things like Sprites
03:45 - models textures and sounds these are
03:48 - called aets and a game engine like Gau
03:50 - is not so much made for creating these
03:52 - from scratch but more for putting
03:54 - everything together it's really the
03:56 - stirring part of making a game now since
04:00 - I can't expect you to go shopping for
04:02 - assets at your local supermarket I've
04:04 - used a bit of TV magic to prepare some
04:06 - beforehand you can download them for
04:08 - free using the link below I've bundled
04:10 - together Sprites from The Amazing analog
04:12 - Studios and modified them a bit along
04:14 - with a pixel font some Custom Sounds and
04:18 - a cute little music track it's also
04:20 - perfectly fine to use other assets you
04:21 - find on the internet there are many
04:23 - great resources for free assets just
04:25 - make sure you check the license and give
04:27 - proper credit to the author CC Z means
04:29 - means that the asset is completely free
04:31 - to use and there's no requirement to
04:32 - credit that being said making your own
04:34 - assets is one of the places where you
04:36 - can really get creative and I highly
04:38 - recommend you try it out as soon as you
04:39 - feel comfortable remember you can always
04:41 - use these assets as placeholders and
04:43 - then modify or replace them later all
04:45 - right let's get our assets into
04:49 - gdau importing Assets in Gau is
04:51 - extremely simple the file system window
04:54 - is where we have all the files we use in
04:56 - our game by default the only thing in
04:58 - here is the Gau icon so let's create a
05:00 - folder where we can put our assets let's
05:03 - right click new folder and name it
05:05 - assets let's also make one for
05:08 - scripts and scenes that we can use later
05:12 - now we can simply drag and drop our
05:14 - assets into the asset folder so I'll
05:16 - select the assets folder open up my
05:18 - assets here I'm going to select all the
05:20 - subfolders and click and drag them into
05:23 - gdau and voila we can now see and use
05:26 - all of our assets in Gau so now we're
05:29 - ready to make our game so let's talk
05:31 - about how we do that to make anything in
05:33 - gdau we use nodes if you want to make a
05:36 - player character we do so by putting
05:38 - together a bunch of notes if you want to
05:40 - make an enemy we do so by putting
05:42 - together notes if we want to make a main
05:43 - menu you guessed it we use nodes so
05:46 - nodes are the fundamental building
05:48 - blocks of your game and nodes come in
05:50 - many types some display an image others
05:53 - play a sound or add physics and we can
05:55 - even extend existing nodes to build more
05:58 - powerful ones so in its Essence making a
06:01 - game in Gau is combining and extending
06:03 - nodes to get the result we're looking
06:05 - for it's a super creative and fun
06:07 - process but building everything in one
06:10 - big world with noes for the player
06:12 - enemies UI and a bunch of levels all in
06:14 - one place would quickly become
06:16 - completely unmanageable and confusing
06:19 - instead we use scenes scenes allow us to
06:23 - bundle together nodes into reusable
06:25 - packages a scene can be a character a
06:27 - weapon a menu there can be a as small as
06:30 - a single collectible coin or an entire
06:32 - level scenes make it really easy to
06:35 - focus on building one part of our game
06:36 - at a time and then slowly combining them
06:39 - to make our game larger and larger this
06:41 - is because we can put scenes inside of
06:44 - other scenes which is called nesting and
06:46 - allows us to take say a player scene a
06:49 - platform scene and a collectible coin
06:51 - scene and put them all inside of another
06:53 - scene say a level one scene and even
06:56 - cooler since scenes are reusable we can
06:58 - make a scene on only once and then use
07:00 - it all over our game we can make many
07:03 - levels that all use the same collectible
07:05 - coin scene and if we want to change
07:07 - something about our coin we simply edit
07:09 - the scene and it automatically updates
07:11 - everywhere else as you can see all the
07:14 - nodes and scenes in our game start to
07:16 - resemble a tree like structure and
07:18 - that's exactly what we call it the scene
07:20 - tree and fittingly we call the node at
07:22 - the very beginning of the tree the root
07:25 - so now that we know a bit about how kdo
07:27 - Works let's start by making the most
07:28 - essential part part of our game the
07:30 - player character player 1.0 so let's
07:33 - create a scene where we'll put
07:35 - everything together this is going to be
07:37 - a 2d game so let's select 2D scene and
07:40 - let's rename this from node 2D to game
07:44 - and even though it's empty let's go
07:45 - ahead and save it so hit contrl s go
07:48 - under scenes and let's save it here and
07:50 - now we can actually play our game it's
07:53 - not going to be very exciting but let's
07:54 - try it out so let's hit play up here or
07:56 - simply press F5 it's going to tell us
07:59 - that we have haven't selected a main
08:00 - scene we need to T good do which scene
08:02 - to run I'm just going to press select
08:04 - current and you can see that our game
08:06 - scene becomes blue to let us know that
08:08 - this is now our main scene and as you
08:10 - can see not much is happening here so
08:13 - let's stop playing by hitting the stop
08:14 - icon here or pressing f8 and let's put
08:17 - in a player to make it more exciting so
08:19 - first off let's create a new Scene by
08:21 - hitting the plus sign up here and this
08:23 - will be our player scene and the root
08:25 - note for our player is going to be what
08:28 - is called a character body 2D so let's
08:31 - add a new note by pressing the plus here
08:33 - or hitting CR a and let's search for
08:35 - character body 2D as you can see this is
08:39 - a 2d physics body that is specialized
08:41 - for characters moved by script so it's
08:43 - perfect for a player character that we
08:45 - want to be able to collide with the
08:47 - environment so let's hit create and now
08:49 - we can see our node here but we can
08:52 - actually see our player in the scene so
08:54 - let's add some graphics let's add
08:57 - another node I'm going to hit contr a
08:59 - and let's let's search for sprite and as
09:01 - you can see we can choose a single
09:02 - Sprite or in our case we want to create
09:05 - an animated character so let's choose
09:07 - the animated Sprite 2D Sprites are just
09:10 - what we call images in our 2D world now
09:13 - with this node selected we can use the
09:16 - inspector here on the right to change
09:18 - properties on that node if we select a
09:20 - different node say our character body 2D
09:23 - we can now see the properties on that
09:25 - node instead so our inspector allows us
09:27 - to change things about a node
09:29 - in our animated Sprite 2D we want to add
09:32 - some animations and we want to give it
09:34 - some Sprite frames the individual frames
09:36 - that will make up our animation let's
09:38 - click here and add a new Sprite frames
09:41 - and now with this selected we can see
09:43 - that it will open up the Sprite frames
09:45 - window at the bottom and in this window
09:47 - we're going to press this tiny icon here
09:50 - that lets us add frames from a Sprite
09:52 - sheet so let's click that go into our
09:54 - assets under our Sprites let's find our
09:57 - knight.png
09:59 - and as you can see I've gone ahead and
10:01 - packed all the different Sprite frames
10:02 - of the nights animation into a single
10:05 - image this is called a Sprite sheet it's
10:08 - a very efficient way of working with
10:09 - lots of Sprites such as when doing
10:11 - animation otherwise we would have to
10:13 - create an image for each single frame
10:15 - which would quickly become an
10:17 - unmanageable amount of files now to
10:19 - start adding these frames in we first
10:21 - need to configure the grid here
10:23 - currently it's set to 4x4 let's go ahead
10:26 - and increase this I've created an 8x8
10:29 - grid here and as you can see each frame
10:31 - now has its own grid cell and let's just
10:34 - start by adding the idle animation to do
10:37 - this we simply click the frames in the
10:38 - order that we would like so I'm going to
10:40 - go from the left hand side here and
10:42 - click as you can see it says this to
10:44 - zero the first frame then I'm going to
10:46 - click the next one and the next one and
10:48 - the next one and now it goes from0 to
10:50 - three and we'll play from left to right
10:53 - we can always click again to remove and
10:55 - this is how you can quickly build an
10:57 - animation from different parts of your
10:59 - Sprite sheet so I'll select these four
11:01 - frames and hit add frames now let's hit
11:03 - F to Center our character on the screen
11:06 - and I'm going to use the scroll wheel to
11:08 - zoom in we can also click and drag with
11:10 - the middle Mouse button to pan now our
11:13 - character looks weirdly blurry that's
11:15 - because we're working with pixel art
11:17 - which requires really hard edges by
11:20 - default Gau is going to try to do some
11:22 - texture smoothing to make textures look
11:24 - better but applied to pixel art that is
11:26 - definitely not the case so let's simply
11:28 - disable this so let's go to project
11:31 - project settings let's go under
11:33 - rendering to textures and here on the
11:35 - default texture filter let's change this
11:37 - from linear to nearest which will
11:40 - immediately make our pixel art look
11:42 - crisp then we can select our animated
11:44 - Sprite and let's try playing the
11:46 - animation that looks great I'm going to
11:48 - increase the FPS here to 10 to make it
11:51 - go a bit faster I'm also going to rename
11:53 - the animation here to idle I'm going to
11:57 - enable autop play to make sure it play
11:59 - place right when we start the game and
12:01 - finally I'm going to take this Sprite
12:02 - here and move it up to make it kind of
12:04 - stand on this line and that's it for our
12:07 - graphics for now we'll add more
12:08 - animations later but as you can see
12:10 - we're currently getting this warning
12:12 - here in the scene View and if I hover
12:14 - over it it's going to say that this node
12:16 - has no shape so it can't Collide or
12:18 - interact with other objects and this is
12:21 - because a character body 2D is a physics
12:24 - node and whenever we're working with
12:26 - physics we need to define a shape that
12:28 - the physics engine can work with so
12:31 - let's add a new node I'm going to press
12:32 - the plus sign here I'm going to search
12:34 - for Collision shape 2D hit create and
12:38 - here in the inspector we can now Define
12:40 - a new shape I'm going to add a circle
12:43 - shape I'm going to make this a bit
12:45 - smaller and drag it up somewhere around
12:47 - there looks fine now you're probably
12:50 - thinking well this is pretty far from
12:52 - our actual Graphics but that's totally
12:54 - fine colliders rarely need to be very
12:56 - precise and it's a good rule of thumb to
12:58 - make them a bit smaller than the
13:00 - graphics if you need to having colliders
13:03 - that are too large is simply going to be
13:04 - frustrating when playing so let's now
13:07 - rename the top node here to player and
13:11 - let's save the scene contrl S as player
13:14 - hit save and now we can go into our game
13:17 - scene and simply drag our player in here
13:20 - so I'm going to go to the top here and
13:22 - drag in the player we also need to
13:24 - create a camera so that we can control
13:26 - what is currently being shown so let's
13:28 - add a new node hit crl a search for
13:31 - camera 2D hit create and now if we press
13:34 - F we can see that we have this huge
13:37 - camera viewport this is definitely
13:39 - currently too large so let's zoom in on
13:41 - our camera I'm going to set the zoom
13:43 - here to 4x4 and simply click and drag
13:46 - our camera to be on top of the player
13:49 - and now we can try playing our game and
13:51 - there you go we now have a player that
13:53 - is playing an idle animation and nothing
13:57 - else is happening that's because we need
13:58 - to add a script that allows us to move
14:01 - around so let's close our game go into
14:03 - our player scene and with our player
14:05 - node selected let's press this add
14:07 - script button here we can choose a
14:09 - template of course we're going to do
14:11 - some programming in this video but
14:13 - writing player movement can quickly
14:14 - become a bit overwhelming so for now
14:17 - we'll use the basic movement template
14:19 - provided by Gau then later we'll go in
14:22 - and modify to play different animations
14:24 - and rebind input to the Keys we'd like
14:26 - to use as for the path here I'm going to
14:28 - make sure that we put this inside of our
14:30 - scripts folder and let's just name it
14:32 - player let's hit create and as you can
14:35 - see this creates a script that will move
14:37 - around our character I know that this
14:39 - might look really confusing at first but
14:41 - don't worry we'll have a look at what
14:43 - all this means later for now let's just
14:45 - try
14:46 - playing and our player immediately falls
14:49 - off the screen that's because we need to
14:51 - give him a collider to stand on right
14:53 - now our player has a collider but it
14:55 - doesn't have anything to collide with so
14:57 - in our game I'm going to go go back to
14:59 - the 2D View at the top here this is
15:01 - where we can change from script view to
15:03 - 2D let's add a new node so let's hit the
15:07 - plus sign let's add a static body 2D and
15:11 - this is another type of physics body
15:13 - it's the one we use for things that
15:14 - don't need to move that's why it's
15:16 - called Static so it's perfect for
15:18 - creating some ground let's hit create
15:20 - and again this is going to give us this
15:22 - warning here that it needs a shape so
15:25 - let's add a collision shape so I'm going
15:27 - to hitr a search for for Collision shape
15:30 - and for the shape here we're going to
15:32 - create a new world boundary shape the
15:35 - world boundary is a type of collider
15:37 - that is perfect for stuff like well
15:39 - World boundaries because it's going to
15:41 - extend infinitely on the horizontal axis
15:44 - here so as you can see it's currently
15:46 - pointing up we could also point it to
15:47 - the side here and now it's going to
15:49 - extend infinitely on the vertical I'm
15:52 - going to hit control Z to undo that
15:54 - instead I'm going to select the entire
15:56 - static body here I'm going to change to
15:58 - the move tool by pressing this icon here
16:01 - or simply W on the keyboard and I'm
16:04 - going to move it down under our
16:06 - character then I'm going to go back to
16:08 - our select tool which is here or simply
16:10 - press q and while our collider doesn't
16:13 - have any graphics it's going to be
16:14 - invisible we can now play and there we
16:17 - go our player now gently lands on the
16:19 - collider and we can move around using
16:20 - the arrow keys and jump with the space
16:23 - bar now our player is currently a bit
16:25 - too fast and I think his jump is a bit
16:27 - too high so let's modify our script to
16:30 - change that let's close our game go into
16:32 - our script and at the top here there are
16:35 - two constants that we can modify our
16:37 - speed as well as our jump velocity so
16:40 - I'm going to set the speed to something
16:42 - less like 130 and the jump velocity to
16:44 - say -300 and now when we play it looks
16:48 - and feels a lot better so our player is
16:51 - moving around for currently there's not
16:54 - much to look at so let's build a world
16:56 - to explore World building 1.0 so to
17:00 - build a world let's begin by removing
17:02 - our collider here we're going to build
17:04 - an actual ground for him to stand on and
17:06 - let's instead add a tilemap node so
17:09 - let's press new node and search for til
17:12 - map now the most common way to create
17:14 - levels in 2D is by using tiles in other
17:17 - words we build our game World by drawing
17:20 - different tiles onto a grid this is a
17:22 - great way to work because we can create
17:24 - a lot of varied levels using just a few
17:27 - tiles the tile as sets we used to paint
17:29 - are normally packed together into one
17:31 - big image just like our player was this
17:34 - is called the tile set so the tile set
17:36 - is a collection of tiles that we can use
17:38 - to paint from and the tile map that we
17:40 - just created is the node we use to paint
17:43 - these tiles into our world so to start
17:45 - painting on our tile map we need to add
17:47 - a tile set so in our inspector on the
17:49 - tile set we'll create a new tile set and
17:52 - if we press it here we get to configure
17:55 - some things about it the main thing you
17:57 - want to make sure is set correctly is
17:58 - the tile size the tile set in our asset
18:01 - does indeed have 16x 16 pixel tiles so
18:03 - we'll just leave that as is now at the
18:06 - bottom here you can see that we have two
18:08 - tabs we have the tile set and tile map
18:10 - so before we can start painting with our
18:12 - tile map let's go into our tile set and
18:15 - configure this property the main thing
18:17 - we want to do is drag in our tet asset
18:19 - so let's go into our assets folder undo
18:22 - Sprites and drag in the world tet.png
18:25 - it's going to ask us if we would like to
18:28 - automatically create tiles in the atlas
18:30 - we do so let's press yes and now let's
18:33 - make some more room here and we can zoom
18:35 - in to view it and as you can see it's
18:37 - actually gone ahead and automatically
18:38 - detected the grid cells that have tiles
18:41 - if for some reason it's made an error we
18:43 - can always use our eraser here to remove
18:46 - tiles in this case here it thinks that
18:48 - the top of the palm tree is a bunch of
18:51 - different tiles I'm going to use the
18:53 - Eraser to get rid of these and instead
18:55 - go out of the erase mode and then hold
18:57 - down shift while clicking and dragging
18:59 - to turn this into one big tile it's also
19:03 - split up the trees into three different
19:05 - tiles but in this case it's actually
19:07 - something that we want because it allows
19:08 - us to create trees of varying Heights
19:11 - I'll show you this once we start
19:12 - painting other than that I think it
19:14 - looks good so with this TI set set up we
19:16 - can now go to our to map and start
19:19 - painting make sure that the scene has
19:21 - the select tool and that the ti map has
19:24 - the paint tool enabled and now let's
19:26 - simply select a TI and start painting
19:28 - painting it in if you make a mistake you
19:30 - can always right click to remove so I'm
19:33 - just going to fast forward through me
19:34 - drawing out the level here as you can
19:36 - see I begin by blocking out the most
19:37 - essential game Parts leaving in room for
19:40 - gameplay objects like moving platforms
19:42 - and enemies and then only once I'm
19:45 - finished with that I start decorating
19:47 - and ify trick here is that you can
19:49 - select multiple Tiles at once to paint
19:51 - in more than one and you can always go
19:54 - into select mode in order to select
19:56 - large chunks and move them
20:08 - now once I'm ready to start decorating
20:09 - let me just show you the cool trick with
20:11 - the trees here let's say we want to add
20:13 - a tree here at the top well then we can
20:15 - actually just paint the bottom and
20:18 - choose how tall we want the tree to be
20:20 - and then paint the top so that's one of
20:22 - the advantages of working with tiles is
20:24 - that we can also make individual
20:26 - elements really really flexible so once
20:28 - you're happy with the level let's just
20:30 - go ahead and press play and our player
20:33 - is going to fall right off that's
20:35 - because we need to add a physic layer to
20:37 - our tiles to do this we go to our tile
20:39 - map go under our tile set physics layers
20:43 - and add a new layer then with this layer
20:46 - we can go under our tile set and here we
20:48 - need to choose what tiles belong to the
20:50 - physics layer because we don't want to
20:52 - collide with everything in our to map
20:55 - the trees and bushes we just want to
20:57 - pass right through so let's go to paint
21:00 - here and the property that we want to
21:02 - paint is the physics layer zero we just
21:05 - created and now we can actually go ahead
21:07 - and paint onto our Tils these physics
21:09 - settings so I'm simply going to paint
21:11 - this onto all the different solid tiles
21:15 - and if you make a mistake and want to
21:16 - remove a tile we go here select clear
21:20 - and now we can paint with no physics or
21:22 - we can go back to the default tile shape
21:25 - which is the entire tile and paint with
21:28 - that or simply hit F to do that so C and
21:31 - F are the shortcuts here now there are
21:34 - also some tiles that we do want physics
21:36 - on but where we need the collider to
21:38 - only be on part of the tile such as our
21:40 - Bridge here so if I zoom in on our
21:43 - Bridge we can see that if I just paint
21:46 - physics onto these it doesn't look right
21:49 - instead we need to go in and only paint
21:51 - a partial collider so over here on the
21:53 - left we can actually modify these
21:55 - colliders to exactly suit our need we
21:59 - can even add and remove points by
22:01 - clicking and right clicking but in this
22:03 - case Four Points will do just fine and
22:06 - that's a good shape for our collider
22:08 - then we can paint these onto the three
22:10 - different tiles and then for the next
22:12 - one here we can configure it this Slants
22:15 - up a bit I'm going to paint that on as
22:17 - well and then for the final one here
22:19 - let's go ahead and make that go in the
22:21 - opposite direction and here you actually
22:23 - want to be pretty precise whenever you
22:25 - have an overlap of the colliders here I
22:28 - think that looks pretty good this helps
22:29 - avoid that our character gets stuck I'm
22:32 - also going to take the T map and drag it
22:34 - to the very top so that we can always
22:36 - find it and now when we play we are
22:38 - indeed colliding with our environment
22:41 - awesome now we probably want our camera
22:43 - to follow the player because he's
22:45 - currently just running off the screen so
22:48 - I'm going to make some room here I'm
22:49 - going to take the camera 2D and simply
22:52 - drag it under the player making it a
22:54 - child of the player means that it will
22:55 - just automatically follow the player
22:57 - node I'm also going to make sure that
23:00 - the camera is still positioned right on
23:02 - top of the player and we can even turn
23:03 - on position smoothing to really smooth
23:06 - out our camera follow so I'm going to
23:08 - enable position smoothing on the camera
23:10 - with a default speed of 5 pixels and now
23:13 - when we play as you can see our camera
23:15 - smoothly follows our player awesome so
23:19 - now we have a first draft of our game
23:21 - world but so far everything is stuck to
23:23 - the grid let's start adding some Dynamic
23:25 - and moving elements such as platforms
23:29 - platforms some that move and some that
23:31 - don't so whenever we are creating a new
23:33 - element of our game We Begin by making a
23:35 - new scene and for the root node here I'm
23:37 - going to hit add and search for the
23:39 - animatable body 2D this is a physics
23:43 - body that we use whenever we want to
23:44 - animate a node and still have it collide
23:47 - properly with other nodes in its path
23:49 - which is perfect for moving platforms
23:51 - that should still Collide properly with
23:53 - our player so let's hit create and let's
23:56 - add some graphics so crl a we we search
23:58 - for sprite and select the Sprite 2D and
24:02 - now we can drag in the texture we want
24:04 - so let's go under our assets Sprites and
24:07 - drag in the platforms. PNG let's hit F
24:10 - and zoom in and as you can see this is
24:12 - also a Sprite sheet and it's currently
24:14 - just displaying all of them so let's go
24:16 - in and Define exactly which one we want
24:18 - to show we can do this under region
24:20 - enabled and hit edit region and so we
24:23 - can kind of crop out the element that we
24:25 - want to show I'm going to change the
24:27 - snap mode here to Pi pixel snap and I'm
24:29 - just going to go for a default grass
24:31 - platform that looks good and now when we
24:34 - close it we can see our Sprite perfectly
24:36 - cropped out again we have the warning
24:38 - here so let's go ahead and add a Collis
24:40 - shape 2D for the shape I'm going to add
24:43 - a rectangle shape and now we can simply
24:45 - click and drag this to configure it then
24:48 - let's rename our top node here to
24:51 - platform and save the scene so crl s in
24:54 - our scenes folder hit save we've
24:56 - actually created our platform so in our
24:58 - game scene we can drag it in go on
25:01 - scenes find the platform drag it into
25:03 - wherever we'd like and let's hit play
25:07 - and as you can see it works however one
25:09 - problem right now is that we can't
25:11 - actually jump onto the platform from
25:13 - underneath to fix this we turn it into a
25:15 - one-way platform so in our platform
25:18 - scene let's select our Collision shape
25:20 - and enable oneway collation and now when
25:23 - we play we can jump onto platforms from
25:27 - underneath however the player is
25:29 - currently passing behind the platform
25:32 - this is because the platform is
25:33 - currently after the player in the tree
25:36 - this means that each frame the player is
25:38 - drawn first and then the platform is
25:40 - drawn on top we could just move the
25:43 - player in the tree but I don't want to
25:45 - depend on that instead we fix the draw
25:47 - order by changing the zindex of the
25:50 - player so in our player scene we go
25:53 - under ordering and set the zindex to
25:55 - something higher like five by default
25:58 - all visible nodes have a zindex of zero
26:01 - because they all have the same index
26:03 - they are drawn according to their order
26:05 - in the tree so by setting the zindex to
26:07 - a higher value like five we ensure that
26:09 - our player will always appear on top and
26:12 - now if we play we can see that our
26:15 - player passes in front of the platform
26:17 - so our platform is working but it's
26:19 - currently just hovering there we might
26:21 - want some platforms to move around to
26:23 - increase difficulty so let's use
26:25 - animation to do that I'm going to leave
26:28 - this platform here as kind of a static
26:30 - platform I'm just going to place it
26:32 - there then I'm going to place another
26:34 - platform over here by simply dragging it
26:36 - in this is the platform that I would
26:38 - like to move back and forth in fact let
26:40 - me just go into the to map and make this
26:43 - Gap even larger there we go so to add
26:46 - animation to this platform only we
26:49 - simply select it add a new node and we
26:51 - want to use an animation player let's
26:54 - hit create and now we can add a new
26:57 - animation and let's name that move
27:00 - animation players in Gau are extremely
27:02 - powerful because they allow us to
27:04 - animate pretty much anything in this
27:06 - case we just want to do something really
27:08 - simple we want to go to our platform and
27:11 - make a key frame under transform for the
27:13 - position so I'll hit the key right here
27:16 - and hit create then we can go forward in
27:19 - our timeline here to say 1 second move
27:22 - our platform to the right so I'm going
27:24 - to click and drag I'm also going to hold
27:26 - down shift to kind of snap it to one
27:27 - axis this let's move it to there and
27:30 - let's add another key frame and now we
27:33 - can see that if we play the animation
27:35 - plays we also want this to Loop so I'm
27:38 - going to select Loop here however this
27:40 - is going to Loop in a way that it snaps
27:42 - back to the original key frame instead
27:44 - let's press it again and now you can see
27:46 - that it's going to start Ping ponging
27:48 - back and forth if this is currently too
27:51 - fast we can simply increase the length
27:53 - of our animation so here's the length
27:55 - let's set it to 1.5 instead and drag our
27:58 - last key frame to the end and there we
28:01 - go we now have a moving platform let's
28:03 - just make sure that we set it to
28:05 - autoplay and now when we play the game
28:08 - and go to the place where we made our
28:09 - platform we can see that it's moving
28:11 - back and forth and if we jump onto it
28:14 - the player will smoothly follow it
28:16 - really cool and there's already so much
28:18 - you can do with this next up pickups now
28:22 - let's add a coin that we can pick up
28:24 - again we start by creating a new scene
28:26 - let's create a new node CDE and let's
28:29 - this time search for area 2D this is a
28:32 - type of node that we use whenever we
28:34 - don't want to collide with other objects
28:36 - but instead we just want to Define an
28:38 - area in which we can detect collisions
28:41 - so we simply use this to detect if
28:43 - another body enters such as the player
28:45 - character let's create an area 2D let's
28:48 - also add some graphics so contr a search
28:51 - for sprite and we'll select the animated
28:53 - Sprite under animation let's add some
28:56 - new Sprite frames select did and let's
28:59 - load in from a Sprite sheet here I'm
29:01 - going to use the coin.png zoom in on
29:04 - this and this only has one grid cell on
29:07 - the vertical and horizontally it has 12
29:11 - and now we can click from left to right
29:13 - or simply click and drag and add the
29:15 - frames let's hit F and zoom in set the
29:18 - fps to 10 and hit play and that's our Co
29:22 - animation let's make sure that this Auto
29:24 - plays and just like a normal physics
29:27 - body and area 2D also needs a collision
29:30 - shape so let's add a collision shape 2D
29:33 - and then for the shape let's just choose
29:35 - a circle shape decrease the radius a bit
29:39 - and that's actually all we need so let's
29:41 - select our area and rename it to coin
29:44 - and save the scene and now we can simply
29:46 - drag it into our game so under scenes
29:50 - I'll take the coin and place it around
29:52 - the level you can always use contrl D to
29:56 - duplicate and now if we play
29:59 - we can see that the coin is here but
30:01 - nothing happens if we enter the area so
30:05 - it's time to make our first script so in
30:07 - our coin scene we select the coin node
30:10 - and hit add script this time for the
30:12 - template let's just choose the default
30:14 - template and for the path let's make
30:16 - sure that this goes under the scripts
30:18 - folder I'll create and this is what it
30:21 - looks like when we create a default
30:23 - script in gdo we can see that we've
30:25 - created the script on an area 2D node
30:27 - and that it's automatically made to
30:29 - function for us that we often use ready
30:32 - and process currently both of them only
30:35 - have the pass keyword which means do
30:38 - nothing so this script if we run it will
30:40 - do absolutely nothing now the ready
30:43 - function is called right when our node
30:46 - enters the scene tree which is just at
30:48 - the start of the game so we can put code
30:50 - here that we want to happen immediately
30:53 - let's try it out by printing a quick
30:54 - message to see if it's working so I'm
30:56 - going to write print then in in
30:58 - parenthesis and quotes I'm going to put
31:01 - I'm a coin and if we play now the print
31:05 - doesn't do anything in our game but it
31:07 - does show our message I'm a coin in the
31:10 - output window this is also referred to
31:12 - as the console and is where we see
31:14 - messages such as prints and errors
31:17 - however you might also notice that the
31:19 - message displays multiple times that's
31:21 - because we currently have multiple coins
31:23 - around our game and the script runs for
31:26 - each and every one so since we we have
31:28 - five coins it displays I'm a coin five
31:31 - times but we don't want anything to
31:33 - happen when we start the game so I'm
31:35 - actually just going to remove these two
31:37 - functions instead we only want to do
31:39 - something once our player enters the
31:41 - coin area and for this we use a signal
31:45 - signals allow us to trigger code based
31:46 - on events that happen in our game gdau
31:49 - has many built-in signals we can use if
31:51 - we select our area 2D node and go to the
31:54 - node tab we can see all the signals on
31:58 - this Noe we want to use the body entered
32:01 - signal which is triggered whenever a
32:03 - physics body enters the area since our
32:05 - player has a character body to D Noe
32:08 - this is going to trigger the signal so
32:11 - to connect it we simply double click it
32:14 - and hit connect as you can see this
32:16 - creates a new function in our script
32:18 - called on body entered with a green
32:20 - arrow that shows that this is triggered
32:22 - by a signal so let's here try writing a
32:25 - print function that says something like
32:28 - + one coin now when we play and into the
32:31 - coin area it's going to print plus one
32:34 - coin however this message will actually
32:37 - display no matter which body enters the
32:40 - area if we take one of these coins here
32:42 - and put it in the way of a moving
32:44 - platform for example this will also
32:46 - trigger the message so now right when we
32:48 - play we can see that it starts
32:51 - displaying the message and we'll do so
32:53 - every time the platform passes through
32:55 - the area to change this we can either
32:57 - use code to check what body enters the
33:00 - area or we can simply put our player on
33:02 - a separate physics layer let's try that
33:05 - out so under our player we'll go to the
33:08 - inspector go to Collision and here we
33:10 - can change the physics layer from layer
33:12 - one to two let's h control s to save and
33:16 - then in our coin we can also go under
33:18 - Collision we can actually have the coin
33:21 - itself stay on layer one we don't need a
33:24 - separate layer for that yet but we want
33:26 - to make sure that it only detects
33:27 - colliders in Layer Two for this we use
33:30 - the mask the mask defines what layers a
33:33 - node collides with so let's set that to
33:36 - Layer Two because that's the layer that
33:38 - our player is on that should actually do
33:40 - it now our coin will only detect
33:42 - collisions from our player and instead
33:45 - of just displaying a message let's also
33:47 - remove the coin from our scene when we
33:48 - pick it up so in our script after
33:51 - printing one coin let's add a new line
33:53 - we'll call the Q free function which is
33:57 - simp going to remove the entire coin
33:59 - scene from our game and indeed it does
34:03 - and our Knight can now start Gathering
34:05 - some coin now depending on what type of
34:07 - loot we pick up we want different things
34:09 - to happen in this case I want to display
34:11 - a score that increases when we pick up a
34:14 - coin but we'll look at that when we get
34:15 - to text first I think something a bit
34:18 - more pressing is dying and restarting
34:20 - our game dying 1.0 so we happily move
34:24 - along in our world until suddenly we
34:26 - miss a jump and fall into the abyss and
34:29 - then nothing happens let's change that
34:32 - the first thing we want to do is limit
34:34 - our camera so that it doesn't follow our
34:36 - player when we fall down luckily this is
34:38 - really easy to do we simply select our
34:41 - camera under the player go under limit
34:44 - and here we can set a position limit for
34:46 - the left top right and bottom part of
34:48 - our camera in our case we need to set a
34:50 - limit for the bottom position to do this
34:53 - we can use the ruler tool here at the
34:56 - top or simply press R and measure from
34:59 - this Baseline here to where we would
35:01 - like the limit of our camera to be I
35:04 - think a good value would be somewhere
35:05 - around say 120 so I'll simply go back to
35:08 - select mode and put in 120 pixels on the
35:12 - bottom I'm also going to enable
35:14 - smoothing and now when we play we can
35:17 - see that our camera will follow the
35:19 - player but whenever we fall off it
35:21 - simply going to stay put next we need to
35:24 - detect that our player has entered a
35:26 - dangerous area and restart the game in
35:28 - other words we need to create a Kill
35:30 - Zone I'll show you a really cool way to
35:33 - do this that allows us to reuse the same
35:35 - kill zone for more than just falling off
35:37 - the map such as for spike traps enemies
35:39 - all kinds of elements of danger and when
35:41 - we want to create a reusable element we
35:44 - start by making a c then to detect if we
35:47 - enter an area we again use the area 2D
35:50 - node and let's make sure to set the
35:52 - Collision mask here to two we only want
35:54 - to check for the player which is on
35:56 - Layer Two and and we want add a
35:59 - collision shape here that's because we
36:01 - want to be able to reuse this for all
36:03 - kinds of elements that might have
36:05 - different shapes instead let's simply go
36:08 - ahead and rename this now to Killzone
36:11 - and save it as a new scene then in our
36:14 - game scene we can add it by dragging it
36:16 - in or simply pressing the link button
36:18 - here and selecting the Kill Zone and
36:21 - then in here we'll add the Collision
36:23 - shape so I'm going to hit crl a
36:25 - collision shape and for for the shape
36:28 - we'll use the same W boundary shape that
36:30 - we used earlier for the ground now let's
36:32 - make sure to select the Kill Zone node
36:35 - itself go into move and use the move
36:38 - tool to position it down here at the
36:40 - bottom I'm going to place it pretty far
36:42 - down so we're sure we don't hit this by
36:44 - accident or I mean we're going to be
36:46 - hitting it by accident so let's make
36:48 - sure we don't hit it on purpose or I
36:51 - mean I don't know anyways I'm going to
36:54 - place it down here a good bit away from
36:56 - our level and now we can add a script to
36:58 - make something happen when we enter the
37:00 - area so in our Kill Zone let's select it
37:04 - add a new script for the template here
37:06 - I'm just going to select empty and the
37:08 - path that's put it under the scripts
37:10 - folder and now we have this empty script
37:12 - to play with I'm going to connect a
37:14 - signal so go node make sure we have the
37:18 - killstone node selected and again we'll
37:20 - use the body entered signal so let's
37:23 - double click it hit connect and it's
37:25 - going to create a new function on body
37:27 - body entered in which case we can go
37:29 - ahead and
37:31 - print that you died and now if we play
37:37 - and jump down it's going to print that
37:39 - we died now instead of immediately
37:42 - restarting the game let's add a small
37:45 - delay we do this using another node
37:48 - called the timer node so let's add a new
37:50 - node search for timer and under the
37:53 - inspector here we can choose some
37:55 - different things about it let's set the
37:57 - weight time to something like 6 seconds
38:00 - let's also make it a one shot to make
38:02 - sure that it doesn't Loop we can then
38:04 - start this timer in our code to do that
38:07 - however we first need a reference to it
38:09 - luckily that's as simple as going to the
38:11 - top of our code clicking and dragging
38:13 - the timer node and holding down control
38:16 - while releasing this creates a variable
38:19 - called timer that automatically finds
38:21 - the node using this path now if you
38:24 - haven't worked with paths before they
38:26 - are actually quite simp symbol they
38:28 - specify a way to get from one node to
38:30 - another in the tree so if we look at
38:32 - this example tree to get from the game
38:35 - node to the camera the path looks like
38:38 - this it goes through the player and ends
38:40 - with the camera and in our case where we
38:42 - just want to get from the Kill Zone to
38:44 - the timer right underneath we don't have
38:46 - to go through any other nodes so the
38:48 - path is simply timer again right now
38:51 - we're brushing over Concepts such as
38:52 - variables and functions pretty briefly
38:55 - but you can learn more about programming
38:57 - and what all this really means in our
38:59 - upcoming video on GD script for now just
39:01 - know that using this click and drag
39:03 - method we can now access our timer node
39:06 - using the name timer so to start our
39:09 - timer we make a new line and write timer
39:12 - do start of course we now need to
39:15 - trigger some code when our timer runs
39:17 - out and again we can use a signal for
39:19 - this so with our timer node selected
39:22 - let's go under node and here's the
39:24 - timeout signal so let's double click
39:26 - that and and hit connect and this
39:28 - creates a new function called ontimer
39:31 - timeout that runs when the timer ends
39:34 - and then in here we can simply restart
39:36 - our game to do this we first access the
39:39 - scene tree so get tree and tell it to
39:43 - reload so reload current scene so our
39:47 - player enters the Kill Zone and triggers
39:48 - the onbody entered function this prints
39:51 - a message that we died and starts the
39:53 - timer when the timer runs out it
39:55 - triggers the ontimer timeout function
39:58 - which then reloads our scene and
40:00 - restarts the game and indeed when we
40:02 - play and jump off the map we fall down
40:06 - and the scene restarts
40:09 - great it's an infinite Loop help me I'm
40:14 - stuck World building 2.0 let's expand on
40:18 - our game World a bit now that we have
40:20 - more elements to work with first of all
40:22 - I want to make sure that we stay
40:23 - organized so let's take some of these
40:25 - nodes and categorize them the easiest
40:27 - way to do this is by simply adding a new
40:29 - node for this one I'm just going to
40:31 - select the base node here hit create and
40:33 - now we can rename this I'll make one for
40:36 - say coins and simply take all of the
40:39 - coins and drag them under that node we
40:42 - can do the same thing for
40:44 - platforms and any other elements that
40:46 - are cluttering up your scene now I'm
40:49 - going to paint in a bit more level and
40:50 - change the things that I don't like
41:01 - and I'll put in some more gameplay
41:04 - elements I'll also paint in some
41:06 - background tiles but to do this we need
41:08 - to add another layer to our tile map so
41:11 - not under our tile set but under the T
41:13 - map itself we have this layers and this
41:16 - is the one we've been painting in let's
41:18 - just call this mid for midg ground and
41:21 - add another one that we can call
41:23 - Background let's move this to the top to
41:26 - make sure that it's drawn first and now
41:28 - when painting we need to select the
41:29 - right layer to paint on so let's select
41:32 - the background and then we can start
41:33 - painting in some background
41:36 - tiles a nice trick here is to use the
41:39 - rectangle tool to paint in a lot of
41:41 - tiles at
41:46 - once and now our game looks a lot better
41:49 - it has a background and a whole new part
41:51 - of the level that we can explore and of
41:54 - course this process is just about trying
41:56 - things out and making Chang es until
41:57 - you're
41:58 - satisfied enemy a proper Hero Of course
42:02 - needs a good enemy so let's make one
42:04 - let's create a new scene and since this
42:06 - enemy doesn't need to collide with
42:08 - anything we can just go ahead and use a
42:10 - note 2D as the base let's also add an
42:13 - animated Sprite so I'll search for
42:15 - animated Sprite 2D let's go to animation
42:18 - and some new Sprite frames select them
42:20 - and let's load in from the Sprite sheet
42:22 - here in the pack there's both a green
42:24 - and a purple version of the enemy I'm
42:26 - just going to choose the green one and
42:28 - this is a 4x3 and I've included three
42:31 - animations here one for the enemy kind
42:33 - of waking up an aggressive idle
42:36 - animation as well as one where the enemy
42:37 - takes damage so I'll use the idle
42:40 - animation here let's add these four
42:41 - frames let's hit F and zoom in I'm also
42:44 - going to move this up set the animation
42:47 - to autoplay and the fps to 10 and now if
42:50 - we preview we have an animated slime and
42:53 - this is where things get really cool
42:55 - because we made our Kill Zone into
42:57 - reusable scene we can simply use it for
42:59 - our enemy as well so at the top here
43:02 - I'll add in a new scene I'm going to
43:03 - select the Kill Zone and now all we need
43:05 - to do is give this a collider so crl a
43:08 - search for Collision shape let's add in
43:11 - a rectangle fit it to fit our enemy by
43:14 - the way I'm holding down alt to scale
43:16 - uniformly and with that we can simply
43:18 - rename our top node here to slime and
43:22 - save it as a scene now in our game we
43:25 - can drag it in I'm going to place it
43:27 - over here and if we play now and move to
43:30 - the enemy we can see that just by
43:32 - throwing together a couple of nodes and
43:34 - reusing our Kill Zone we've successfully
43:36 - added a new element of danger to our
43:39 - game if we enter the enemy we can see
43:41 - that indeed our game restarts of course
43:44 - currently dying doesn't look very
43:45 - exciting we'll fix that in the next
43:47 - chapter but first let's make our enemy
43:49 - move back and forth we could of course
43:52 - do this using an animation player just
43:54 - like we did for our platforms however I
43:56 - think it would be cooler to make a
43:57 - script that moves our enemy to the right
43:59 - until we get close to a wall in which
44:02 - case it changes Direction and starts
44:04 - moving left this way we can simply drag
44:06 - and drop the enemy between any two walls
44:08 - in our game and our script will do the
44:10 - rest so let's start by making our enemy
44:12 - move to the right so go into the Slime
44:15 - add a new script use the default
44:17 - template and place it under the scripts
44:19 - folder and hit create let's get rid of
44:22 - the ready function and instead we're
44:25 - going to be using process
44:27 - just like movies video games display
44:29 - motion by drawing frames and showing
44:31 - them in quick succession while movies
44:34 - show frames at a fixed rate most often
44:36 - 24 frames per second video games
44:38 - generally try to draw as many frames as
44:41 - possible to get a smooth result how
44:43 - often this happens will depend on the
44:44 - system the game is running on and what
44:46 - is happening in the game but unless the
44:48 - game is lagging it should draw a new
44:50 - frame at least 60 times per second and
44:53 - often much more before the computer can
44:55 - draw a new frame however it first has to
44:58 - update the state of the game what has
45:00 - happened since the last frame it does
45:02 - this for all the notes in our game then
45:04 - it draws the new frame this is referred
45:07 - to as the game Loop because it happens
45:09 - over and over again and it is really the
45:12 - driving force of our game gdo of course
45:14 - does this automatically but we can add
45:16 - functionality to the game Loop using the
45:18 - other function in the template process
45:21 - unlike ready which only runs once
45:23 - process runs every frame this makes it
45:26 - perfect for doing things over time such
45:28 - as moving an enemy we simply make sure
45:30 - to change the position of the enemy a
45:32 - tiny bit each frame so in our script we
45:35 - can simply remove the pass keyword and
45:38 - instead access the position of our slime
45:40 - more specifically the x coordinate of
45:43 - our position and add one pixel to this
45:46 - every frame then in our game let's go
45:48 - ahead and place a slime close to our
45:50 - player so that we can see this happening
45:52 - and
45:53 - play and as you can see the enemy just
45:55 - shoots past us on the screen
45:57 - now one problem with this that might not
45:59 - be obvious Al than it's moving way too
46:01 - quickly is that we are increasing the X
46:03 - position every frame by a fixed amount
46:06 - and because our frame rate can vary this
46:09 - means that the enemy will sometimes move
46:11 - faster than others which is not very
46:13 - good to fix this we use this little
46:15 - thing here called Delta Delta is the
46:19 - amount of time that has gone by since
46:20 - the last frame if we are drawing many
46:22 - frames per second Delta gets really
46:24 - small and if we lag out a bit and are
46:27 - not drawing as many frames Delta becomes
46:29 - bigger because of this we can use Delta
46:31 - to compensate for variations in frame
46:34 - rate if we have a high frame rate we
46:36 - want to only move our enemy a little
46:38 - each frame and if we have a low frame
46:40 - rate we want to move it a lot in other
46:43 - words we can multiply our Movement by
46:45 - Delta to make it independent of the
46:47 - frame rate now Delta can be a bit hard
46:50 - to wrap your head around at first but
46:52 - don't worry you'll get the hang of it A
46:54 - good rule of thumb is that whenever we
46:56 - have a a speed value that we can adjust
46:58 - such as our one here we should probably
47:01 - multiply it with Delta so in our script
47:03 - we simply go plus equal 1 multiplied
47:06 - with Delta now what this essentially
47:09 - means is that we are going to be moving
47:11 - 1 pixel per second which is not very
47:14 - fast so let's instead change this to
47:16 - something like 60 and we can actually
47:18 - store this speed in a constant at the
47:21 - top of our script just like in the
47:22 - movement script so here I'll write const
47:25 - speed and set it equal to 60 then we can
47:28 - simply use speed here instead of
47:31 - hardcoding the value this makes it easy
47:33 - to change constants right at the top of
47:35 - your script and now if we play we can
47:38 - see that our enemy is moving at a
47:40 - reasonable rate and we know that this
47:42 - speed won't change from system to system
47:45 - so let's get rid of this extra slime
47:47 - here and instead make this one actually
47:49 - change direction whenever we Face a wall
47:53 - to do this we need a way to control the
47:54 - direction we're currently moving in so
47:56 - that's create a variable that does this
47:58 - we create a bar call it Direction and
48:02 - set it equal to one by default then if
48:05 - we need to go in the opposite direction
48:07 - we'll set it to -1 instead and to
48:10 - actually apply this all we need to do is
48:12 - multiply it into our speed so we'll go
48:14 - Direction time speed time Delta this is
48:17 - a really standard way of doing Movement
48:20 - we simply add onto our position in a
48:22 - direction multiplied by speed and Delta
48:24 - so now all we need to do is check if the
48:26 - enemy gets close to a wall and for this
48:29 - we'll use a new type of node the raycast
48:32 - node raycasts are invisible rays that we
48:35 - can shoot out to detect collisions so
48:38 - inside of our slime here let's add a new
48:40 - node of type raycast 2D and as you can
48:43 - see it draws an arrow to represent this
48:46 - let's move the starting point here to
48:48 - the center of our enemy and let's have
48:49 - it shoot out to around here I'm going to
48:53 - rename this to raycast right I'm then
48:57 - going to press contrl D to duplicate I'm
49:00 - going to have this shoot out in the
49:01 - opposite direction and rename this to
49:04 - raycast
49:06 - left now in our script we can reference
49:09 - these nodes just like we did with our
49:11 - timer we simply select them both click
49:13 - and drag and hold down control while
49:16 - releasing as you can see this creates
49:18 - two variables one raycast right and a
49:21 - raycast left then every frame before we
49:24 - move our slime we will go ahead and
49:26 - check if if we're currently colliding to
49:28 - the right or to the left if
49:30 - raycast right dot is colliding if this
49:35 - raycast is hitting something well then
49:37 - colon and then make sure to indent here
49:39 - with a tab we will set our direction to
49:42 - be ne1 if we are colliding on the right
49:45 - we want to move to the left and we'll
49:47 - add another one of these if statements
49:48 - so if Ray cast you guessed it left do is
49:53 - colliding well then we'll set our
49:55 - Direction back to one and that's it our
49:58 - enemy is now ping ponging back and forth
50:00 - between the two walls and this is
50:02 - happening completely automatically
50:04 - through script really cool now the only
50:07 - thing that is left is to flip the enemy
50:09 - Sprite when it changes Direction luckily
50:11 - if we go inspect our animated Sprite
50:13 - here under offset we have this flip AG
50:17 - property which will simply flip the
50:19 - Sprite so let's control this through our
50:21 - script in our script we'll get a
50:23 - reference to our animated Sprite 2D this
50:25 - creates a variable called animated
50:27 - Sprite 2D I'm just going to get rid of
50:29 - the 2D here to make the name a bit
50:31 - shorter and then whenever we are
50:33 - colliding on the right here and we
50:35 - change direction to move towards the
50:37 - left we will also go to our animated
50:40 - Sprite and set the flip H property to
50:44 - true and when we are colliding on the
50:46 - left and we're changing direction again
50:48 - well then we'll go to our animated
50:50 - Sprite and set flip H back to false and
50:53 - that's it that's our entire script let's
50:56 - find find our enemy here and hooray
50:59 - we've made an enemy and a slimy one at
51:01 - that but of course dying to the enemy
51:04 - could definitely look cooler so let's
51:05 - fix that dying
51:07 - 2.0 let's start by adding a slow motion
51:10 - effect when we die we can do this by
51:12 - changing the time scale of the entire
51:15 - game so inside of our Kill Zone we'll
51:17 - open up the script here and right after
51:19 - we print U died let's modify our time
51:22 - scale so I'll go engine do time scale
51:26 - and set it equal to 0.5 this means that
51:29 - we will go at half speed then when our
51:31 - timer runs out let's set this back to
51:33 - default because otherwise we will
51:35 - actually still be slowed down when our
51:37 - scene reloads so we'll go engine do time
51:40 - scale and set it back to the default one
51:44 - and if we play this now this is actually
51:46 - already much better notice that it also
51:49 - takes twice as long before the game
51:51 - restarts because everything in our game
51:53 - slows down including our timer but I
51:56 - think could be even cooler if we remove
51:58 - the player's collider to make him simply
52:01 - fall off the map to do this we need a
52:03 - reference to the player we actually
52:05 - already have this here you'll notice
52:08 - that after the on body entered here
52:10 - there's a variable called body this
52:12 - refers to the body that entered the area
52:15 - and since the only thing that enters the
52:16 - kill zone is our player body is our
52:19 - player so we can actually add a new line
52:22 - here that goes to our body and then we
52:24 - simply need to get the Collision shape
52:26 - node under our player so we'll do dot
52:29 - get node and we'll search for the Collis
52:32 - shape 2D and we can remove it so call do
52:36 - Q free on that node again Q free means
52:41 - to remove that node so here we're
52:43 - accessing our player getting the
52:45 - Collision shape node and removing it and
52:48 - now if we find our way to some danger
52:50 - boom we are hit and we fall off the map
52:53 - cure the sound effect
52:55 - [Music]
52:57 - player 2.0 so far we've been using the
53:00 - character movement template pretty much
53:02 - as is but we need to modify it in order
53:05 - to add animation to our player as well
53:08 - as change the key Bindings that we use
53:10 - to move so what are we looking at here
53:14 - well the top two lines Define two
53:15 - constants with our speed and jump
53:18 - velocity there's also a variable here
53:20 - that defines the gravity based on our
53:22 - project settings by default this is a
53:24 - value of 98
53:27 - so we have these three values but the
53:29 - meat of the script is really inside of
53:31 - this physics process function physics
53:34 - process is very similar to the process
53:36 - function we used for our enemy however
53:38 - while process is great for a lot of
53:40 - things there is one part of the game
53:42 - engine that really struggles with not
53:44 - knowing how many times per second it is
53:46 - going to be run that is the physics
53:48 - engine physics in general need to update
53:51 - at fixed intervals to avoid janky
53:53 - Behavior luckily physics process solves
53:56 - this problem because it runs at a fixed
53:58 - rate 60 times per second by default this
54:01 - is independent of your game's actual
54:03 - frame rate and helps physics run
54:04 - smoothly we use it for anything that
54:07 - involves the physics engine like moving
54:09 - something that should collide with its
54:10 - environment such as a player character
54:13 - so in this function a few things are
54:15 - happening if the player is not standing
54:18 - on a Surface we add gravity if we press
54:21 - the space bar and the player is on the
54:23 - surface we jump and then we get the
54:25 - direction we need to move in based on
54:27 - what arrow keys are pressed and move
54:29 - accordingly now let's start by rebinding
54:32 - some input keys for this sco uses an
54:35 - action system we create actions for
54:37 - anything we want to do in the game jump
54:39 - is an action so it's move left or move
54:41 - right we can then bind keys to these
54:44 - actions let's try it out so let's go to
54:46 - project project settings input map and
54:49 - here we can add some actions I'm going
54:51 - to add a jump action as well as a move
54:53 - left and a move right then we can use
54:56 - the plus sign over here to bind a key so
54:59 - to my jump here I'm going to hit plus
55:01 - and then it's listening for input so I'm
55:03 - going to press the space bar and hit
55:05 - okay and as you can see space is now
55:08 - bound to jump for a move left I'm going
55:10 - to bind the left Arrow key and I'm also
55:13 - going to bind the a key so we can use
55:16 - vast for movement as well as you can see
55:18 - there's no problem binding multiple keys
55:20 - to the same action which is really handy
55:23 - I'm also going to bind right arrow to
55:25 - move right as well as the D key and now
55:28 - we can use these actions in our script
55:31 - by default gdau uses some buil-in
55:33 - actions that are meant for navigating UI
55:36 - this is why it says things like UI
55:38 - accept here let's replace these with our
55:41 - own actions instead and as you can see
55:43 - it will actually help us by autoc
55:45 - completing here so I'm going to put in
55:47 - Jump for my jump action and then for
55:50 - moving left here I'm going to change to
55:52 - move left and for moving right I'm going
55:55 - to change to move right and now we can
55:58 - use the keys bound to our actions to
56:00 - move around which in my case are both
56:02 - the vast keys and the arrow keys awesome
56:05 - the next thing we need to do is to
56:07 - update our player Graphics to face the
56:09 - direction we are moving in and to play
56:11 - the right animation let's start by
56:13 - flipping our Sprite based on Direction
56:15 - so just like with our enemy we first
56:17 - need a reference to the animated Sprite
56:19 - node again here we can simply click and
56:22 - drag and hold down control again I'm
56:24 - going to remove the 2D from the name to
56:25 - make it sure order and then we'll add
56:27 - some extra code to our function now this
56:30 - line here defines a variable called
56:32 - direction that is based on our input if
56:35 - we don't press any buttons direction
56:37 - will be zero if we press move right
56:40 - direction will be one and if we press
56:42 - move left Direction becomes minus one so
56:45 - we can use this variable to check if we
56:46 - are moving left or right I'm going to
56:48 - make some space in the code here and
56:50 - make my own comments as well so use a
56:53 - hashtag for a comment this here gets the
56:56 - input
56:57 - Direction which can either be minus one
57:00 - 0 or 1 and this down here actually
57:03 - applies the movement so in between we
57:06 - can add a section that flips the Sprite
57:09 - to do this we check if our Direction
57:12 - variable is greater than zero well that
57:16 - means we are moving to the right and we
57:18 - can set animated Sprite dot flip
57:20 - horizontally to false if this is not the
57:23 - case well then we want to check if our
57:25 - direction is less than zero for this we
57:27 - can use the El if or E if keyword so
57:30 - else if our direction is less than zero
57:34 - well then we'll set animated sprite.
57:36 - flip AG to true and now if we play this
57:41 - we can see that our play a Sprite indeed
57:43 - faces the right direction now let's add
57:45 - some animation so let's go to 2D view
57:48 - select our animated Sprite and let's add
57:51 - two new animations one called run and
57:54 - one for jumping
57:56 - in our run animation I'll add some new
57:58 - Sprite frames select our KN remember
58:02 - this is 8x8 and I'll simply add all of
58:05 - the frames in the Run animation which
58:07 - stretches over two lines here I'll add
58:10 - those frames set the fps to 10 and play
58:14 - looks good then for the jump animation
58:17 - I'll also add a Sprite frame and there
58:20 - are bunch of different ways to go about
58:21 - this but in our case here I think we
58:23 - should actually play our jump animation
58:25 - when whenever we're just in the air this
58:28 - means that this will also play when
58:29 - we're just falling off a platform and
58:31 - for this we could use a very quick
58:33 - looping animation or simply a single
58:36 - frame I actually like this one from the
58:38 - roll animation so I'm just going to use
58:41 - that then in our script we can of course
58:43 - play these animations so after we get
58:45 - the input Direction and flip the Sprite
58:48 - let's add a new segment which is going
58:50 - to play animations and here we also need
58:53 - to check our Direction variable more
58:56 - specifically if our direction is equal
58:59 - to zero well then we're standing still
59:02 - and we can go ahead and play animated
59:04 - sprite. playay the animation called idle
59:08 - if this is not the case so else well
59:11 - then we want to play animated sprite.
59:14 - playay the Run animation and that's
59:17 - actually it if we now start running we
59:19 - can see our run animation being played
59:21 - finally we just need to add our jump
59:23 - animation and here we can use a buildin
59:25 - function fun of our character body 2D
59:28 - which is to check if we standing on the
59:30 - floor so at the top here we'll check if
59:33 - we're currently on the floor is on floor
59:37 - well then we want to go ahead and play
59:39 - our idle or run so I'll cut this using
59:42 - contr X paste it in here make sure you
59:44 - tab in and if we are not standing on the
59:46 - floor well then we're in the air and we
59:49 - can go and play animated sprite. playay
59:52 - our jump animation instead so if we're
59:55 - on on the floor and our direction is
59:57 - zero well then we're playing idle if
60:00 - it's not zero well then we're playing
60:02 - run and if we are not on the floor we
60:04 - aren't doing any of those things we're
60:05 - just playing the jump animation and
60:08 - that's it now if we
60:10 - play we have a fully animated Knight I
60:14 - like to think that she's a former
60:16 - princess who got so tired of waiting to
60:18 - be saved from the big bad dragon that
60:21 - she took matters into her own hands who
60:23 - better to save some princesses from a
60:25 - dragon that someone who knows dragons
60:27 - like her own back pocket but feel free
60:30 - to make up your own story and that
60:32 - reminds me story we need a good way of
60:35 - communicating story hints and other
60:37 - valuable information to the player and
60:39 - to do this we need text so let's add
60:42 - some text elements to our game text
60:45 - there are multiple ways of working with
60:47 - text in good do as part of a larger UI
60:49 - or as an integrated part of the game
60:51 - world for this game I decided to try
60:54 - making the text part of our world
60:56 - in Gau a text node is called a label so
60:59 - let's add one let's hit CR a and search
61:01 - for a label let's focus on it and as you
61:04 - can see this creates kind of a bounding
61:06 - box for our text so I'm going to put it
61:08 - over here and scale it up a bit and
61:10 - let's add some text in the field here
61:13 - I'm going to put in a gameplay hint and
61:15 - as you can see the text looks really
61:18 - blurry that's because since we're using
61:20 - pixel art we actually zoomed in really
61:23 - really far which makes the otherwise
61:25 - smooth text appear blurry so we can fix
61:28 - this by using a pixelated font with hard
61:30 - edges to match our style I've of course
61:33 - included some in the assets so let's go
61:35 - under theme overwrites on our label
61:38 - fonts and here we can drag in the pixel
61:40 - operator font we can also change the
61:43 - font size on do font sizes here enable
61:45 - that and I'm going to set mine to eight
61:48 - note that we have to use multiples of
61:50 - eight in order for the text to appear
61:52 - crisp so you can see if I change this to
61:54 - nine it becomes blurry again but we can
61:57 - use 16 24 32 and so on I'm also going to
62:02 - go to the colors here and change the
62:04 - font color using the Color Picker and
62:07 - now we can place these text elements
62:09 - around our game to provide story or
62:10 - gameplay
62:12 - tips once we're happy we can categorize
62:15 - all of them under a node so let's create
62:17 - a node call it labels and drag all of
62:20 - them under that and now when we play as
62:22 - you can see they appear as a natural
62:24 - part of our game world and just like
62:27 - with Sprites because the player
62:28 - character has a greater Z index it will
62:30 - draw on top so let's use one of these
62:33 - text elements to display our current
62:35 - score score and points to create a score
62:39 - or coin counter for our game we need two
62:41 - things a script that keeps track of our
62:43 - current score and a label to display it
62:46 - it's common practice to place game-wide
62:48 - variables such as a score inside some
62:50 - kind of game manager so let's make one
62:53 - we'll hit contr a to add a new node
62:55 - let's rename it game manager and I'll
62:58 - place it right at the top here the
63:00 - reason why we are using a regular node
63:03 - and not a node 2D is because we don't
63:05 - need our game manager to have a
63:07 - transform in other words a position
63:09 - rotation and scale now let's add a
63:12 - script to our game manager we'll use the
63:14 - empty template and for the path here
63:16 - let's put it inside of our scripts
63:18 - folder and let's also rename it with non
63:20 - capital
63:21 - letters create and let's create a
63:24 - variable for our current SC score so
63:26 - we'll write VAR for a variable name it
63:28 - score and default it to zero now so far
63:31 - in our code we've only used the building
63:33 - functions of gdau and some that we made
63:36 - with signals in this case here we want
63:38 - to create our own function that adds a
63:40 - point to our score and displace it so
63:43 - I'll write funk for a function we'll
63:45 - name it add Point open and close some
63:48 - parentheses and put a colon then on a
63:50 - new line we'll write score plus equal 1
63:53 - to increase our score by one and print
63:56 - our current score now unlike ready which
63:59 - runs at the start of our game and our
64:01 - signal functions which run when a signal
64:04 - gets triggered this function currently
64:05 - has nothing that calls it so right now
64:08 - our function is here but it isn't being
64:10 - run to change this we need to go into
64:13 - our coin script and tell it to call this
64:15 - function whenever a coin is picked up so
64:17 - inside of our coin script we need a
64:20 - reference to our game manager but if we
64:23 - just click and drag while holding down
64:24 - control we get this really weird looking
64:28 - path this is because the game manager is
64:31 - higher up in the tree than the coins and
64:34 - it's generally bad practice to use paths
64:36 - like this that try to access nodes at
64:38 - the same level or higher in the tree
64:41 - luckily because our game manager is a
64:43 - one-of a kind and we are sure that there
64:45 - will always be only one game manager we
64:48 - can solve this by marking it as unique
64:50 - so let's right click our game manager
64:52 - and select access as unique name as you
64:55 - can see this creates a percentage iccon
64:57 - next to the game manager letting us know
64:59 - that it's a unique node this makes it
65:02 - much easier and safer to get a reference
65:04 - to the game manager because now when we
65:06 - drag it in instead of a dollar sign with
65:09 - a weird and unpredictable path we get a
65:11 - percentage sign which means that Gau
65:14 - quickly finds the node via its unique
65:16 - name instead of using a path one
65:18 - limitation of this is that you can only
65:20 - access unique nodes from within the same
65:22 - scene if the game manager and the coins
65:24 - were in different scen means this
65:26 - wouldn't work now in our function we can
65:28 - replace the print line here with game
65:31 - manager access our game manager and call
65:34 - the function add point And now when a
65:37 - body enters our coin it's going to go to
65:39 - the game manager and run our add Point
65:42 - function and if we play we can see that
65:44 - every time we pick up a coin it
65:47 - increases and prints our score in the
65:49 - output
65:50 - window finally we can use what we
65:52 - learned about labels in the previous
65:54 - chapter to create one for dis displaying
65:56 - our coins I'm going to make a little
65:57 - place for this in our
66:04 - level for now I'll just put in some text
66:06 - that says you collected x amount of
66:08 - coins I'm also going to change the auto
66:11 - wrap mode to word now we can wrap our
66:14 - text and the horizontal alignment to
66:16 - Center finally I'll use a boulder
66:20 - font now we can take this label and
66:23 - rename it to something like score label
66:26 - and since we want to change it from our
66:28 - game manager let's drag it right under
66:30 - our game manager now in our script we
66:34 - get a reference by clicking and dragging
66:36 - holding down control and instead of
66:38 - printing our score we'll go into our
66:40 - score label and access the text property
66:44 - and change it to you
66:46 - collected and then here I'm going to add
66:49 - the number add the score onto that
66:53 - amount of coins notice how make sure to
66:56 - add spaces between the words and while
66:58 - this looks good it's actually going to
66:59 - give us an error and that's because we
67:01 - need to change this score here from a
67:04 - whole number variable called an integer
67:06 - into a text variable called a string
67:09 - again we'll talk much more about
67:10 - variables in our video on GD script but
67:12 - for now we can cast this using Str Str
67:15 - for string and then wrapping it in
67:18 - parentheses and now when we play and
67:21 - pick up some coins along the way
67:23 - here once we get to the end it says
67:26 - great job you collected six coins and if
67:29 - I pick up another one it's going to
67:31 - update to seven awesome and I don't know
67:35 - about you this is great and all but I
67:36 - think it's distinctly lacking a bling
67:39 - sound when we pick up a coin
67:45 - blinging bling audio one of the things
67:48 - that often get overlooked when making a
67:50 - game is audio but music and sound
67:53 - effects are a huge part of building the
67:55 - movie of your game this is of course a
67:57 - beginners tutorial but let's at least
67:59 - get our feet wet or should I say our
68:01 - ears wet nope I shouldn't let's at least
68:04 - add a music track and a pickup sound for
68:06 - our coins now in the assets I've
68:08 - included a music track as well as a few
68:11 - sounds and to play these we need a new
68:13 - type of node the audio stream player so
68:16 - let's add a new node search for audio
68:18 - stream player 2D let's rename this to
68:23 - music then we can take our music track
68:25 - here time for adventure and drag it into
68:28 - the stream slot we're also going to set
68:30 - it to autoplay and by default this is
68:32 - not going to Loop to change that let's
68:34 - double click it this is going to open up
68:36 - our audio importer here we can preview
68:39 - our music
68:41 - track groovy anyways we can Loop so
68:45 - let's enable Loop here and hit repport
68:48 - now by default all sounds are played
68:50 - fairly loud and since this is background
68:52 - music we probably want to turn it down a
68:54 - bit we can do this by by adjusting the
68:56 - volume on each individual audo stream
68:58 - player or we can use the audio tab here
69:01 - at the bottom this is actually a fully
69:03 - functioning audio mixer and we can add
69:05 - different buses to control our audio
69:08 - let's add two one for our music as well
69:11 - as one for sound effects and then we can
69:13 - simply route our music here into our
69:16 - music bus so now we can control the
69:18 - volume of our music using this slider
69:20 - I'm just going to set it to -12 and we
69:23 - have music unfortunately it's going to
69:26 - restart whenever our scene is reloaded a
69:29 - quick fix for this is to take our music
69:31 - node and make it into a scene so click
69:33 - and drag it into our scenes folder hit
69:36 - save and then we can add this scene as
69:39 - an autoload auto loads are Global scenes
69:42 - and scripts that we want to persist
69:44 - throughout our entire game no matter
69:46 - which scene is currently loaded so let's
69:48 - remove music here from our game scene
69:51 - and instead go to project project
69:53 - settings autoload we'll click the little
69:56 - folder here and navigate to our music
69:59 - scene and hit add we've now registered
70:02 - our music scene as an autoload which
70:05 - means that if we now play even though
70:08 - our music scene isn't in our game it
70:10 - automatically loads and start playing
70:12 - our track and even better it doesn't
70:15 - reset when our game restarts now to add
70:17 - a pickup sound we go to our coin and add
70:20 - an audio stream player let's rename this
70:23 - to pick up sound
70:26 - drag in our coin sound and set the bus
70:29 - here to sound effects and now we can
70:31 - actually play this sound through script
70:33 - but since we're removing the coin
70:35 - immediately by calling the Q free
70:37 - function the sound won't actually get a
70:40 - chance to play we can of course fix this
70:42 - by adding code that Waits until the
70:44 - sound has finished playing but then we
70:46 - might get weird functionality where we
70:47 - try to pick up the coin multiple times
70:50 - while it's playing and it will still be
70:52 - visible until the sound is finished so
70:54 - that me show you a really cool trick to
70:56 - get around tricky timing things like
70:58 - this without writing any code that is
71:01 - using an animation player so let's add
71:04 - an animation
71:05 - player and here we'll create a new
71:08 - pickup
71:09 - animation and the first thing that we
71:10 - want to do when we pick up the coin is
71:13 - to hide the coin Sprite so I'll go into
71:15 - the animated Sprite 2D and this will
71:17 - change the window so I'll go back to
71:19 - animation Here and Now under visibility
71:22 - I get to key frame the visible property
71:25 - now when working with animations that
71:27 - don't need to play until later in the
71:28 - game it's nice to be able to go back to
71:31 - the default values after animating by
71:33 - default here our coin should be visible
71:36 - now this is pretty cool if I just create
71:37 - a key frame here for the default value G
71:41 - is going to ask to create a reset track
71:44 - if we say yes to this gdor is
71:45 - automatically going to create another
71:47 - animation track called reset that will
71:50 - simply reset this value to its default
71:52 - state so now in our pickup animation we
71:54 - can key frame it to whatever we want in
71:56 - our case when we pick up the coin we
71:58 - want it not to be visible so I'll
72:00 - disable that key frame it and then if we
72:02 - want to go back to our default values we
72:04 - simply go to our reset track and there
72:06 - it is it goes back to default so let's
72:09 - go to our pickup let's also modify our
72:12 - Collis shape we don't want to be able to
72:13 - collide with it while it's playing the
72:15 - sound so let's simply go ahead and add a
72:18 - default key here for the disabled
72:20 - property hit create and now we can set
72:23 - disabled to true and add a new key
72:25 - we can also go into our pickup sound
72:27 - here and let's add a default key for the
72:31 - playing property let's hit create and
72:33 - now since the sound plays pretty quickly
72:35 - I I can actually reach the key in time
72:39 - so we can go down here instead I'm just
72:41 - going to scale this up a bit go down
72:43 - here to the value the key frame here and
72:46 - change it to on so we can actually
72:48 - modify the key frames here as well so
72:51 - now we have our pickup animation and if
72:53 - we go to reset we can see that
72:55 - everything goes back to default so
72:57 - that's just a nice way of working with
72:59 - animation so now we play the sound
73:01 - disable the collider and hide the Sprite
73:03 - after 1 second though we can go ahead
73:06 - and remove the coin from our scene so
73:08 - all of these key frames here are on
73:10 - second one let's put them over to right
73:13 - at the beginning of our animation at
73:15 - second Z and then after 1 second here we
73:18 - want to remove our coin and this is a
73:21 - really cool part about the animation
73:23 - system is that we can actually add
73:24 - another track here a call method track
73:27 - that is used to calling functions so on
73:30 - our coin we want to call a function and
73:33 - I'll right click right where we want to
73:35 - do that insert key and the function that
73:38 - we want to call is the Q free method
73:40 - which is right here and so now after 1
73:43 - second it's going to call the Q free
73:45 - method on our coin without us writing
73:48 - any code and voila all the things we
73:50 - could have done through code are all
73:51 - inside this animation and again to get
73:54 - back we simply choose
73:55 - reset now all that is left is playing
73:57 - the animation through script so in our
74:00 - script we'll get a reference to our
74:01 - animation player and then instead of
74:04 - directly calling Q free we'll go
74:06 - animation player. playay pickup and if
74:09 - we play now we can hear our music and we
74:12 - can hear our pickup sound when we run
74:14 - into the
74:15 - coins awesome export finally we are
74:19 - ready to export really incredible that
74:22 - you made it this far you can feel very
74:24 - proud so let's get our game out of Gau
74:27 - so we can share it with others Gau can
74:29 - of course export to many different
74:31 - platforms but I'm on a Windows computer
74:33 - here so let's go ahead and make a quick
74:35 - Windows build the first time we are
74:37 - exporting our game we need to download
74:38 - the export templates these are a little
74:41 - large so to keep good old lightweight
74:42 - they aren't included by default to
74:45 - install them we go to editor manage
74:47 - export templates and hit download and
74:50 - install and the export templates are
74:52 - installed and ready to be used so we'll
74:54 - close close go to project and export in
74:58 - this window we'll add a build platform
75:00 - so let's go add Windows desktop we'll
75:02 - enable embed pck which will export it
75:05 - into a single file then we scroll down
75:07 - as for the product name here I'm going
75:09 - to type in Princess Dragon Slayer and we
75:13 - can hit export project I'm simply going
75:15 - to put this on my desktop uncheck export
75:18 - with debug and hit save this warning is
75:21 - not a problem we'll hit okay and now on
75:23 - the desktop we have this first game.exe
75:25 - we can open that up and
75:28 - voila we made a
75:31 - [Music]
75:40 - game woohoo and that's it
75:43 - congratulations on making your first
75:44 - dish or I mean game in Gau if you don't
75:48 - understand everything or unsure about
75:50 - where to go from here don't worry that's
75:52 - totally normal it takes a little while
75:54 - to become familiar enough with the tools
75:56 - to feel really free with them never
75:58 - hesitate to use the documentation
76:00 - tutorials or code examples you find
76:01 - online when I started out I spend a lot
76:04 - of time remixing other people's scripts
76:06 - before I started to write my own now
76:08 - where do you go from here well that's
76:10 - totally up to you but if you want to
76:12 - continue adding to this game here's a
76:14 - list of things that you can try out
76:16 - expand the level see how far you can get
76:18 - using just what you know now I think
76:20 - you'd be surprised with how much fun
76:22 - gameplay you can get out of just these
76:24 - simple elements add effects like an
76:26 - animation or particles when picking up a
76:28 - coin or more Sound and Music add more
76:31 - danger elements like spikes or traps
76:33 - that turn on and off most of these are
76:35 - just variations on the Kill Zone we've
76:37 - already made add a main menu more
76:39 - enemies give the player a weapon or add
76:42 - powerups you can also expand on the game
76:44 - manager for example to use it to switch
76:46 - scenes a common way to do this is by
76:47 - turning it into an autoload just like we
76:50 - did with our music track or perhaps you
76:52 - want to improve player Movement by
76:53 - adding coyote time and double jumps the
76:55 - possibilities are endless also don't
76:58 - forget to check out Zena Academy be
77:00 - among the first 50 people to use the
77:02 - coupon code below to get 20% off the
77:04 - first year of your zenva subscription
77:06 - and that's it for making your first game
77:07 - in Gau and I wish you the best of luck
77:10 - on making your second one

Cleaned transcript:

good do God dot godo whichever you prefer if you want to use it to make a game you've come to the right place I've been making video games for more than 14 years now and recently I've fallen in love with Gau Gau is a great choice for many developers and pretty beginner friendly also it's open source and completely free to use now you probably have a bunch of ideas of games that would be cool to make but no matter if you're dreaming of making an FPS a 2d platformer or any anything in between using gdau the first step is of course to install it now this process might be a bit tedious but bear with me now we go to g.org press download latest gdo engine and we're done this is a huge advantage of gdau it's extremely lightweight and can even run in the browser now you might want to unzip this folder and place it somewhere you remember but other than that we're ready to open up gdau so let's double click it and it's going to ask us if we want to look at some examle projects I'll just press cancel then we can press new name our project say first game I'm going to place mine on my desktop under my games folder let's create a separate folder for first game so hit create folder and create an edit and here we are a clean slate a blank canvas oh I am so ready to make this game about well this might be a good time to decide what our game will be about but first this video is sponsored by Zena if you're excited about gdau 4 make sure to check out Zena Academy they offer comprehensive beginner and intermediate courses including a fantastic free introductory course on Gau what's really cool about SBA is how they combine fun and practical learning through professional video tutorials written lessons and interactive quizzes plus you'll be building real projects across various genres from RPGs to Bullet Hills zenva also has a wide range of courses on python Unity unreal and other essential tools with a single subscription which includes would say 7Day free trial you unlock over 250 courses use the coupon code below to get an extra 20% off the first year of your s subscription on top of any existing side wide discounts the offer is valid for the first 50 subscribers so make sure to use your coupon today to start your Game Dev Adventure so in the spirit of learning the basics of the engine and giving you an overview of how you can start using it to make things I've put together the most basic game I could imagine think of it like food without salt it doesn't have much flavor but it does have a player enemies moving platforms collectible coins and most importantly it should get you familiar with the engine in no time also will be working in 2D but another really cool thing about gdau is that it's very easy to transfer 2D Concepts to 3D so don't worry if your dream game is in 3D most of what you learned here is going to directly apply as for programming Gau uses its own scripting language called GD script it's pretty fast and easy to use but still quite powerful we'll do a bit of programming in this video to get you started but the main focus is really to get familiar with gdau as a whole and to quickly get a game up and running because of this I don't expect you to fully understand all the code you see feel free to write after me or just lean back and observe our next video will be about learning to program in GD script all right I promised you food without salt so let's get cooking now to make our delicious game we need ingredients we need things like Sprites models textures and sounds these are called aets and a game engine like Gau is not so much made for creating these from scratch but more for putting everything together it's really the stirring part of making a game now since I can't expect you to go shopping for assets at your local supermarket I've used a bit of TV magic to prepare some beforehand you can download them for free using the link below I've bundled together Sprites from The Amazing analog Studios and modified them a bit along with a pixel font some Custom Sounds and a cute little music track it's also perfectly fine to use other assets you find on the internet there are many great resources for free assets just make sure you check the license and give proper credit to the author CC Z means means that the asset is completely free to use and there's no requirement to credit that being said making your own assets is one of the places where you can really get creative and I highly recommend you try it out as soon as you feel comfortable remember you can always use these assets as placeholders and then modify or replace them later all right let's get our assets into gdau importing Assets in Gau is extremely simple the file system window is where we have all the files we use in our game by default the only thing in here is the Gau icon so let's create a folder where we can put our assets let's right click new folder and name it assets let's also make one for scripts and scenes that we can use later now we can simply drag and drop our assets into the asset folder so I'll select the assets folder open up my assets here I'm going to select all the subfolders and click and drag them into gdau and voila we can now see and use all of our assets in Gau so now we're ready to make our game so let's talk about how we do that to make anything in gdau we use nodes if you want to make a player character we do so by putting together a bunch of notes if you want to make an enemy we do so by putting together notes if we want to make a main menu you guessed it we use nodes so nodes are the fundamental building blocks of your game and nodes come in many types some display an image others play a sound or add physics and we can even extend existing nodes to build more powerful ones so in its Essence making a game in Gau is combining and extending nodes to get the result we're looking for it's a super creative and fun process but building everything in one big world with noes for the player enemies UI and a bunch of levels all in one place would quickly become completely unmanageable and confusing instead we use scenes scenes allow us to bundle together nodes into reusable packages a scene can be a character a weapon a menu there can be a as small as a single collectible coin or an entire level scenes make it really easy to focus on building one part of our game at a time and then slowly combining them to make our game larger and larger this is because we can put scenes inside of other scenes which is called nesting and allows us to take say a player scene a platform scene and a collectible coin scene and put them all inside of another scene say a level one scene and even cooler since scenes are reusable we can make a scene on only once and then use it all over our game we can make many levels that all use the same collectible coin scene and if we want to change something about our coin we simply edit the scene and it automatically updates everywhere else as you can see all the nodes and scenes in our game start to resemble a tree like structure and that's exactly what we call it the scene tree and fittingly we call the node at the very beginning of the tree the root so now that we know a bit about how kdo Works let's start by making the most essential part part of our game the player character player 1.0 so let's create a scene where we'll put everything together this is going to be a 2d game so let's select 2D scene and let's rename this from node 2D to game and even though it's empty let's go ahead and save it so hit contrl s go under scenes and let's save it here and now we can actually play our game it's not going to be very exciting but let's try it out so let's hit play up here or simply press F5 it's going to tell us that we have haven't selected a main scene we need to T good do which scene to run I'm just going to press select current and you can see that our game scene becomes blue to let us know that this is now our main scene and as you can see not much is happening here so let's stop playing by hitting the stop icon here or pressing f8 and let's put in a player to make it more exciting so first off let's create a new Scene by hitting the plus sign up here and this will be our player scene and the root note for our player is going to be what is called a character body 2D so let's add a new note by pressing the plus here or hitting CR a and let's search for character body 2D as you can see this is a 2d physics body that is specialized for characters moved by script so it's perfect for a player character that we want to be able to collide with the environment so let's hit create and now we can see our node here but we can actually see our player in the scene so let's add some graphics let's add another node I'm going to hit contr a and let's let's search for sprite and as you can see we can choose a single Sprite or in our case we want to create an animated character so let's choose the animated Sprite 2D Sprites are just what we call images in our 2D world now with this node selected we can use the inspector here on the right to change properties on that node if we select a different node say our character body 2D we can now see the properties on that node instead so our inspector allows us to change things about a node in our animated Sprite 2D we want to add some animations and we want to give it some Sprite frames the individual frames that will make up our animation let's click here and add a new Sprite frames and now with this selected we can see that it will open up the Sprite frames window at the bottom and in this window we're going to press this tiny icon here that lets us add frames from a Sprite sheet so let's click that go into our assets under our Sprites let's find our knight.png and as you can see I've gone ahead and packed all the different Sprite frames of the nights animation into a single image this is called a Sprite sheet it's a very efficient way of working with lots of Sprites such as when doing animation otherwise we would have to create an image for each single frame which would quickly become an unmanageable amount of files now to start adding these frames in we first need to configure the grid here currently it's set to 4x4 let's go ahead and increase this I've created an 8x8 grid here and as you can see each frame now has its own grid cell and let's just start by adding the idle animation to do this we simply click the frames in the order that we would like so I'm going to go from the left hand side here and click as you can see it says this to zero the first frame then I'm going to click the next one and the next one and the next one and now it goes from0 to three and we'll play from left to right we can always click again to remove and this is how you can quickly build an animation from different parts of your Sprite sheet so I'll select these four frames and hit add frames now let's hit F to Center our character on the screen and I'm going to use the scroll wheel to zoom in we can also click and drag with the middle Mouse button to pan now our character looks weirdly blurry that's because we're working with pixel art which requires really hard edges by default Gau is going to try to do some texture smoothing to make textures look better but applied to pixel art that is definitely not the case so let's simply disable this so let's go to project project settings let's go under rendering to textures and here on the default texture filter let's change this from linear to nearest which will immediately make our pixel art look crisp then we can select our animated Sprite and let's try playing the animation that looks great I'm going to increase the FPS here to 10 to make it go a bit faster I'm also going to rename the animation here to idle I'm going to enable autop play to make sure it play place right when we start the game and finally I'm going to take this Sprite here and move it up to make it kind of stand on this line and that's it for our graphics for now we'll add more animations later but as you can see we're currently getting this warning here in the scene View and if I hover over it it's going to say that this node has no shape so it can't Collide or interact with other objects and this is because a character body 2D is a physics node and whenever we're working with physics we need to define a shape that the physics engine can work with so let's add a new node I'm going to press the plus sign here I'm going to search for Collision shape 2D hit create and here in the inspector we can now Define a new shape I'm going to add a circle shape I'm going to make this a bit smaller and drag it up somewhere around there looks fine now you're probably thinking well this is pretty far from our actual Graphics but that's totally fine colliders rarely need to be very precise and it's a good rule of thumb to make them a bit smaller than the graphics if you need to having colliders that are too large is simply going to be frustrating when playing so let's now rename the top node here to player and let's save the scene contrl S as player hit save and now we can go into our game scene and simply drag our player in here so I'm going to go to the top here and drag in the player we also need to create a camera so that we can control what is currently being shown so let's add a new node hit crl a search for camera 2D hit create and now if we press F we can see that we have this huge camera viewport this is definitely currently too large so let's zoom in on our camera I'm going to set the zoom here to 4x4 and simply click and drag our camera to be on top of the player and now we can try playing our game and there you go we now have a player that is playing an idle animation and nothing else is happening that's because we need to add a script that allows us to move around so let's close our game go into our player scene and with our player node selected let's press this add script button here we can choose a template of course we're going to do some programming in this video but writing player movement can quickly become a bit overwhelming so for now we'll use the basic movement template provided by Gau then later we'll go in and modify to play different animations and rebind input to the Keys we'd like to use as for the path here I'm going to make sure that we put this inside of our scripts folder and let's just name it player let's hit create and as you can see this creates a script that will move around our character I know that this might look really confusing at first but don't worry we'll have a look at what all this means later for now let's just try playing and our player immediately falls off the screen that's because we need to give him a collider to stand on right now our player has a collider but it doesn't have anything to collide with so in our game I'm going to go go back to the 2D View at the top here this is where we can change from script view to 2D let's add a new node so let's hit the plus sign let's add a static body 2D and this is another type of physics body it's the one we use for things that don't need to move that's why it's called Static so it's perfect for creating some ground let's hit create and again this is going to give us this warning here that it needs a shape so let's add a collision shape so I'm going to hitr a search for for Collision shape and for the shape here we're going to create a new world boundary shape the world boundary is a type of collider that is perfect for stuff like well World boundaries because it's going to extend infinitely on the horizontal axis here so as you can see it's currently pointing up we could also point it to the side here and now it's going to extend infinitely on the vertical I'm going to hit control Z to undo that instead I'm going to select the entire static body here I'm going to change to the move tool by pressing this icon here or simply W on the keyboard and I'm going to move it down under our character then I'm going to go back to our select tool which is here or simply press q and while our collider doesn't have any graphics it's going to be invisible we can now play and there we go our player now gently lands on the collider and we can move around using the arrow keys and jump with the space bar now our player is currently a bit too fast and I think his jump is a bit too high so let's modify our script to change that let's close our game go into our script and at the top here there are two constants that we can modify our speed as well as our jump velocity so I'm going to set the speed to something less like 130 and the jump velocity to say 300 and now when we play it looks and feels a lot better so our player is moving around for currently there's not much to look at so let's build a world to explore World building 1.0 so to build a world let's begin by removing our collider here we're going to build an actual ground for him to stand on and let's instead add a tilemap node so let's press new node and search for til map now the most common way to create levels in 2D is by using tiles in other words we build our game World by drawing different tiles onto a grid this is a great way to work because we can create a lot of varied levels using just a few tiles the tile as sets we used to paint are normally packed together into one big image just like our player was this is called the tile set so the tile set is a collection of tiles that we can use to paint from and the tile map that we just created is the node we use to paint these tiles into our world so to start painting on our tile map we need to add a tile set so in our inspector on the tile set we'll create a new tile set and if we press it here we get to configure some things about it the main thing you want to make sure is set correctly is the tile size the tile set in our asset does indeed have 16x 16 pixel tiles so we'll just leave that as is now at the bottom here you can see that we have two tabs we have the tile set and tile map so before we can start painting with our tile map let's go into our tile set and configure this property the main thing we want to do is drag in our tet asset so let's go into our assets folder undo Sprites and drag in the world tet.png it's going to ask us if we would like to automatically create tiles in the atlas we do so let's press yes and now let's make some more room here and we can zoom in to view it and as you can see it's actually gone ahead and automatically detected the grid cells that have tiles if for some reason it's made an error we can always use our eraser here to remove tiles in this case here it thinks that the top of the palm tree is a bunch of different tiles I'm going to use the Eraser to get rid of these and instead go out of the erase mode and then hold down shift while clicking and dragging to turn this into one big tile it's also split up the trees into three different tiles but in this case it's actually something that we want because it allows us to create trees of varying Heights I'll show you this once we start painting other than that I think it looks good so with this TI set set up we can now go to our to map and start painting make sure that the scene has the select tool and that the ti map has the paint tool enabled and now let's simply select a TI and start painting painting it in if you make a mistake you can always right click to remove so I'm just going to fast forward through me drawing out the level here as you can see I begin by blocking out the most essential game Parts leaving in room for gameplay objects like moving platforms and enemies and then only once I'm finished with that I start decorating and ify trick here is that you can select multiple Tiles at once to paint in more than one and you can always go into select mode in order to select large chunks and move them now once I'm ready to start decorating let me just show you the cool trick with the trees here let's say we want to add a tree here at the top well then we can actually just paint the bottom and choose how tall we want the tree to be and then paint the top so that's one of the advantages of working with tiles is that we can also make individual elements really really flexible so once you're happy with the level let's just go ahead and press play and our player is going to fall right off that's because we need to add a physic layer to our tiles to do this we go to our tile map go under our tile set physics layers and add a new layer then with this layer we can go under our tile set and here we need to choose what tiles belong to the physics layer because we don't want to collide with everything in our to map the trees and bushes we just want to pass right through so let's go to paint here and the property that we want to paint is the physics layer zero we just created and now we can actually go ahead and paint onto our Tils these physics settings so I'm simply going to paint this onto all the different solid tiles and if you make a mistake and want to remove a tile we go here select clear and now we can paint with no physics or we can go back to the default tile shape which is the entire tile and paint with that or simply hit F to do that so C and F are the shortcuts here now there are also some tiles that we do want physics on but where we need the collider to only be on part of the tile such as our Bridge here so if I zoom in on our Bridge we can see that if I just paint physics onto these it doesn't look right instead we need to go in and only paint a partial collider so over here on the left we can actually modify these colliders to exactly suit our need we can even add and remove points by clicking and right clicking but in this case Four Points will do just fine and that's a good shape for our collider then we can paint these onto the three different tiles and then for the next one here we can configure it this Slants up a bit I'm going to paint that on as well and then for the final one here let's go ahead and make that go in the opposite direction and here you actually want to be pretty precise whenever you have an overlap of the colliders here I think that looks pretty good this helps avoid that our character gets stuck I'm also going to take the T map and drag it to the very top so that we can always find it and now when we play we are indeed colliding with our environment awesome now we probably want our camera to follow the player because he's currently just running off the screen so I'm going to make some room here I'm going to take the camera 2D and simply drag it under the player making it a child of the player means that it will just automatically follow the player node I'm also going to make sure that the camera is still positioned right on top of the player and we can even turn on position smoothing to really smooth out our camera follow so I'm going to enable position smoothing on the camera with a default speed of 5 pixels and now when we play as you can see our camera smoothly follows our player awesome so now we have a first draft of our game world but so far everything is stuck to the grid let's start adding some Dynamic and moving elements such as platforms platforms some that move and some that don't so whenever we are creating a new element of our game We Begin by making a new scene and for the root node here I'm going to hit add and search for the animatable body 2D this is a physics body that we use whenever we want to animate a node and still have it collide properly with other nodes in its path which is perfect for moving platforms that should still Collide properly with our player so let's hit create and let's add some graphics so crl a we we search for sprite and select the Sprite 2D and now we can drag in the texture we want so let's go under our assets Sprites and drag in the platforms. PNG let's hit F and zoom in and as you can see this is also a Sprite sheet and it's currently just displaying all of them so let's go in and Define exactly which one we want to show we can do this under region enabled and hit edit region and so we can kind of crop out the element that we want to show I'm going to change the snap mode here to Pi pixel snap and I'm just going to go for a default grass platform that looks good and now when we close it we can see our Sprite perfectly cropped out again we have the warning here so let's go ahead and add a Collis shape 2D for the shape I'm going to add a rectangle shape and now we can simply click and drag this to configure it then let's rename our top node here to platform and save the scene so crl s in our scenes folder hit save we've actually created our platform so in our game scene we can drag it in go on scenes find the platform drag it into wherever we'd like and let's hit play and as you can see it works however one problem right now is that we can't actually jump onto the platform from underneath to fix this we turn it into a oneway platform so in our platform scene let's select our Collision shape and enable oneway collation and now when we play we can jump onto platforms from underneath however the player is currently passing behind the platform this is because the platform is currently after the player in the tree this means that each frame the player is drawn first and then the platform is drawn on top we could just move the player in the tree but I don't want to depend on that instead we fix the draw order by changing the zindex of the player so in our player scene we go under ordering and set the zindex to something higher like five by default all visible nodes have a zindex of zero because they all have the same index they are drawn according to their order in the tree so by setting the zindex to a higher value like five we ensure that our player will always appear on top and now if we play we can see that our player passes in front of the platform so our platform is working but it's currently just hovering there we might want some platforms to move around to increase difficulty so let's use animation to do that I'm going to leave this platform here as kind of a static platform I'm just going to place it there then I'm going to place another platform over here by simply dragging it in this is the platform that I would like to move back and forth in fact let me just go into the to map and make this Gap even larger there we go so to add animation to this platform only we simply select it add a new node and we want to use an animation player let's hit create and now we can add a new animation and let's name that move animation players in Gau are extremely powerful because they allow us to animate pretty much anything in this case we just want to do something really simple we want to go to our platform and make a key frame under transform for the position so I'll hit the key right here and hit create then we can go forward in our timeline here to say 1 second move our platform to the right so I'm going to click and drag I'm also going to hold down shift to kind of snap it to one axis this let's move it to there and let's add another key frame and now we can see that if we play the animation plays we also want this to Loop so I'm going to select Loop here however this is going to Loop in a way that it snaps back to the original key frame instead let's press it again and now you can see that it's going to start Ping ponging back and forth if this is currently too fast we can simply increase the length of our animation so here's the length let's set it to 1.5 instead and drag our last key frame to the end and there we go we now have a moving platform let's just make sure that we set it to autoplay and now when we play the game and go to the place where we made our platform we can see that it's moving back and forth and if we jump onto it the player will smoothly follow it really cool and there's already so much you can do with this next up pickups now let's add a coin that we can pick up again we start by creating a new scene let's create a new node CDE and let's this time search for area 2D this is a type of node that we use whenever we don't want to collide with other objects but instead we just want to Define an area in which we can detect collisions so we simply use this to detect if another body enters such as the player character let's create an area 2D let's also add some graphics so contr a search for sprite and we'll select the animated Sprite under animation let's add some new Sprite frames select did and let's load in from a Sprite sheet here I'm going to use the coin.png zoom in on this and this only has one grid cell on the vertical and horizontally it has 12 and now we can click from left to right or simply click and drag and add the frames let's hit F and zoom in set the fps to 10 and hit play and that's our Co animation let's make sure that this Auto plays and just like a normal physics body and area 2D also needs a collision shape so let's add a collision shape 2D and then for the shape let's just choose a circle shape decrease the radius a bit and that's actually all we need so let's select our area and rename it to coin and save the scene and now we can simply drag it into our game so under scenes I'll take the coin and place it around the level you can always use contrl D to duplicate and now if we play we can see that the coin is here but nothing happens if we enter the area so it's time to make our first script so in our coin scene we select the coin node and hit add script this time for the template let's just choose the default template and for the path let's make sure that this goes under the scripts folder I'll create and this is what it looks like when we create a default script in gdo we can see that we've created the script on an area 2D node and that it's automatically made to function for us that we often use ready and process currently both of them only have the pass keyword which means do nothing so this script if we run it will do absolutely nothing now the ready function is called right when our node enters the scene tree which is just at the start of the game so we can put code here that we want to happen immediately let's try it out by printing a quick message to see if it's working so I'm going to write print then in in parenthesis and quotes I'm going to put I'm a coin and if we play now the print doesn't do anything in our game but it does show our message I'm a coin in the output window this is also referred to as the console and is where we see messages such as prints and errors however you might also notice that the message displays multiple times that's because we currently have multiple coins around our game and the script runs for each and every one so since we we have five coins it displays I'm a coin five times but we don't want anything to happen when we start the game so I'm actually just going to remove these two functions instead we only want to do something once our player enters the coin area and for this we use a signal signals allow us to trigger code based on events that happen in our game gdau has many builtin signals we can use if we select our area 2D node and go to the node tab we can see all the signals on this Noe we want to use the body entered signal which is triggered whenever a physics body enters the area since our player has a character body to D Noe this is going to trigger the signal so to connect it we simply double click it and hit connect as you can see this creates a new function in our script called on body entered with a green arrow that shows that this is triggered by a signal so let's here try writing a print function that says something like + one coin now when we play and into the coin area it's going to print plus one coin however this message will actually display no matter which body enters the area if we take one of these coins here and put it in the way of a moving platform for example this will also trigger the message so now right when we play we can see that it starts displaying the message and we'll do so every time the platform passes through the area to change this we can either use code to check what body enters the area or we can simply put our player on a separate physics layer let's try that out so under our player we'll go to the inspector go to Collision and here we can change the physics layer from layer one to two let's h control s to save and then in our coin we can also go under Collision we can actually have the coin itself stay on layer one we don't need a separate layer for that yet but we want to make sure that it only detects colliders in Layer Two for this we use the mask the mask defines what layers a node collides with so let's set that to Layer Two because that's the layer that our player is on that should actually do it now our coin will only detect collisions from our player and instead of just displaying a message let's also remove the coin from our scene when we pick it up so in our script after printing one coin let's add a new line we'll call the Q free function which is simp going to remove the entire coin scene from our game and indeed it does and our Knight can now start Gathering some coin now depending on what type of loot we pick up we want different things to happen in this case I want to display a score that increases when we pick up a coin but we'll look at that when we get to text first I think something a bit more pressing is dying and restarting our game dying 1.0 so we happily move along in our world until suddenly we miss a jump and fall into the abyss and then nothing happens let's change that the first thing we want to do is limit our camera so that it doesn't follow our player when we fall down luckily this is really easy to do we simply select our camera under the player go under limit and here we can set a position limit for the left top right and bottom part of our camera in our case we need to set a limit for the bottom position to do this we can use the ruler tool here at the top or simply press R and measure from this Baseline here to where we would like the limit of our camera to be I think a good value would be somewhere around say 120 so I'll simply go back to select mode and put in 120 pixels on the bottom I'm also going to enable smoothing and now when we play we can see that our camera will follow the player but whenever we fall off it simply going to stay put next we need to detect that our player has entered a dangerous area and restart the game in other words we need to create a Kill Zone I'll show you a really cool way to do this that allows us to reuse the same kill zone for more than just falling off the map such as for spike traps enemies all kinds of elements of danger and when we want to create a reusable element we start by making a c then to detect if we enter an area we again use the area 2D node and let's make sure to set the Collision mask here to two we only want to check for the player which is on Layer Two and and we want add a collision shape here that's because we want to be able to reuse this for all kinds of elements that might have different shapes instead let's simply go ahead and rename this now to Killzone and save it as a new scene then in our game scene we can add it by dragging it in or simply pressing the link button here and selecting the Kill Zone and then in here we'll add the Collision shape so I'm going to hit crl a collision shape and for for the shape we'll use the same W boundary shape that we used earlier for the ground now let's make sure to select the Kill Zone node itself go into move and use the move tool to position it down here at the bottom I'm going to place it pretty far down so we're sure we don't hit this by accident or I mean we're going to be hitting it by accident so let's make sure we don't hit it on purpose or I mean I don't know anyways I'm going to place it down here a good bit away from our level and now we can add a script to make something happen when we enter the area so in our Kill Zone let's select it add a new script for the template here I'm just going to select empty and the path that's put it under the scripts folder and now we have this empty script to play with I'm going to connect a signal so go node make sure we have the killstone node selected and again we'll use the body entered signal so let's double click it hit connect and it's going to create a new function on body body entered in which case we can go ahead and print that you died and now if we play and jump down it's going to print that we died now instead of immediately restarting the game let's add a small delay we do this using another node called the timer node so let's add a new node search for timer and under the inspector here we can choose some different things about it let's set the weight time to something like 6 seconds let's also make it a one shot to make sure that it doesn't Loop we can then start this timer in our code to do that however we first need a reference to it luckily that's as simple as going to the top of our code clicking and dragging the timer node and holding down control while releasing this creates a variable called timer that automatically finds the node using this path now if you haven't worked with paths before they are actually quite simp symbol they specify a way to get from one node to another in the tree so if we look at this example tree to get from the game node to the camera the path looks like this it goes through the player and ends with the camera and in our case where we just want to get from the Kill Zone to the timer right underneath we don't have to go through any other nodes so the path is simply timer again right now we're brushing over Concepts such as variables and functions pretty briefly but you can learn more about programming and what all this really means in our upcoming video on GD script for now just know that using this click and drag method we can now access our timer node using the name timer so to start our timer we make a new line and write timer do start of course we now need to trigger some code when our timer runs out and again we can use a signal for this so with our timer node selected let's go under node and here's the timeout signal so let's double click that and and hit connect and this creates a new function called ontimer timeout that runs when the timer ends and then in here we can simply restart our game to do this we first access the scene tree so get tree and tell it to reload so reload current scene so our player enters the Kill Zone and triggers the onbody entered function this prints a message that we died and starts the timer when the timer runs out it triggers the ontimer timeout function which then reloads our scene and restarts the game and indeed when we play and jump off the map we fall down and the scene restarts great it's an infinite Loop help me I'm stuck World building 2.0 let's expand on our game World a bit now that we have more elements to work with first of all I want to make sure that we stay organized so let's take some of these nodes and categorize them the easiest way to do this is by simply adding a new node for this one I'm just going to select the base node here hit create and now we can rename this I'll make one for say coins and simply take all of the coins and drag them under that node we can do the same thing for platforms and any other elements that are cluttering up your scene now I'm going to paint in a bit more level and change the things that I don't like and I'll put in some more gameplay elements I'll also paint in some background tiles but to do this we need to add another layer to our tile map so not under our tile set but under the T map itself we have this layers and this is the one we've been painting in let's just call this mid for midg ground and add another one that we can call Background let's move this to the top to make sure that it's drawn first and now when painting we need to select the right layer to paint on so let's select the background and then we can start painting in some background tiles a nice trick here is to use the rectangle tool to paint in a lot of tiles at once and now our game looks a lot better it has a background and a whole new part of the level that we can explore and of course this process is just about trying things out and making Chang es until you're satisfied enemy a proper Hero Of course needs a good enemy so let's make one let's create a new scene and since this enemy doesn't need to collide with anything we can just go ahead and use a note 2D as the base let's also add an animated Sprite so I'll search for animated Sprite 2D let's go to animation and some new Sprite frames select them and let's load in from the Sprite sheet here in the pack there's both a green and a purple version of the enemy I'm just going to choose the green one and this is a 4x3 and I've included three animations here one for the enemy kind of waking up an aggressive idle animation as well as one where the enemy takes damage so I'll use the idle animation here let's add these four frames let's hit F and zoom in I'm also going to move this up set the animation to autoplay and the fps to 10 and now if we preview we have an animated slime and this is where things get really cool because we made our Kill Zone into reusable scene we can simply use it for our enemy as well so at the top here I'll add in a new scene I'm going to select the Kill Zone and now all we need to do is give this a collider so crl a search for Collision shape let's add in a rectangle fit it to fit our enemy by the way I'm holding down alt to scale uniformly and with that we can simply rename our top node here to slime and save it as a scene now in our game we can drag it in I'm going to place it over here and if we play now and move to the enemy we can see that just by throwing together a couple of nodes and reusing our Kill Zone we've successfully added a new element of danger to our game if we enter the enemy we can see that indeed our game restarts of course currently dying doesn't look very exciting we'll fix that in the next chapter but first let's make our enemy move back and forth we could of course do this using an animation player just like we did for our platforms however I think it would be cooler to make a script that moves our enemy to the right until we get close to a wall in which case it changes Direction and starts moving left this way we can simply drag and drop the enemy between any two walls in our game and our script will do the rest so let's start by making our enemy move to the right so go into the Slime add a new script use the default template and place it under the scripts folder and hit create let's get rid of the ready function and instead we're going to be using process just like movies video games display motion by drawing frames and showing them in quick succession while movies show frames at a fixed rate most often 24 frames per second video games generally try to draw as many frames as possible to get a smooth result how often this happens will depend on the system the game is running on and what is happening in the game but unless the game is lagging it should draw a new frame at least 60 times per second and often much more before the computer can draw a new frame however it first has to update the state of the game what has happened since the last frame it does this for all the notes in our game then it draws the new frame this is referred to as the game Loop because it happens over and over again and it is really the driving force of our game gdo of course does this automatically but we can add functionality to the game Loop using the other function in the template process unlike ready which only runs once process runs every frame this makes it perfect for doing things over time such as moving an enemy we simply make sure to change the position of the enemy a tiny bit each frame so in our script we can simply remove the pass keyword and instead access the position of our slime more specifically the x coordinate of our position and add one pixel to this every frame then in our game let's go ahead and place a slime close to our player so that we can see this happening and play and as you can see the enemy just shoots past us on the screen now one problem with this that might not be obvious Al than it's moving way too quickly is that we are increasing the X position every frame by a fixed amount and because our frame rate can vary this means that the enemy will sometimes move faster than others which is not very good to fix this we use this little thing here called Delta Delta is the amount of time that has gone by since the last frame if we are drawing many frames per second Delta gets really small and if we lag out a bit and are not drawing as many frames Delta becomes bigger because of this we can use Delta to compensate for variations in frame rate if we have a high frame rate we want to only move our enemy a little each frame and if we have a low frame rate we want to move it a lot in other words we can multiply our Movement by Delta to make it independent of the frame rate now Delta can be a bit hard to wrap your head around at first but don't worry you'll get the hang of it A good rule of thumb is that whenever we have a a speed value that we can adjust such as our one here we should probably multiply it with Delta so in our script we simply go plus equal 1 multiplied with Delta now what this essentially means is that we are going to be moving 1 pixel per second which is not very fast so let's instead change this to something like 60 and we can actually store this speed in a constant at the top of our script just like in the movement script so here I'll write const speed and set it equal to 60 then we can simply use speed here instead of hardcoding the value this makes it easy to change constants right at the top of your script and now if we play we can see that our enemy is moving at a reasonable rate and we know that this speed won't change from system to system so let's get rid of this extra slime here and instead make this one actually change direction whenever we Face a wall to do this we need a way to control the direction we're currently moving in so that's create a variable that does this we create a bar call it Direction and set it equal to one by default then if we need to go in the opposite direction we'll set it to 1 instead and to actually apply this all we need to do is multiply it into our speed so we'll go Direction time speed time Delta this is a really standard way of doing Movement we simply add onto our position in a direction multiplied by speed and Delta so now all we need to do is check if the enemy gets close to a wall and for this we'll use a new type of node the raycast node raycasts are invisible rays that we can shoot out to detect collisions so inside of our slime here let's add a new node of type raycast 2D and as you can see it draws an arrow to represent this let's move the starting point here to the center of our enemy and let's have it shoot out to around here I'm going to rename this to raycast right I'm then going to press contrl D to duplicate I'm going to have this shoot out in the opposite direction and rename this to raycast left now in our script we can reference these nodes just like we did with our timer we simply select them both click and drag and hold down control while releasing as you can see this creates two variables one raycast right and a raycast left then every frame before we move our slime we will go ahead and check if if we're currently colliding to the right or to the left if raycast right dot is colliding if this raycast is hitting something well then colon and then make sure to indent here with a tab we will set our direction to be ne1 if we are colliding on the right we want to move to the left and we'll add another one of these if statements so if Ray cast you guessed it left do is colliding well then we'll set our Direction back to one and that's it our enemy is now ping ponging back and forth between the two walls and this is happening completely automatically through script really cool now the only thing that is left is to flip the enemy Sprite when it changes Direction luckily if we go inspect our animated Sprite here under offset we have this flip AG property which will simply flip the Sprite so let's control this through our script in our script we'll get a reference to our animated Sprite 2D this creates a variable called animated Sprite 2D I'm just going to get rid of the 2D here to make the name a bit shorter and then whenever we are colliding on the right here and we change direction to move towards the left we will also go to our animated Sprite and set the flip H property to true and when we are colliding on the left and we're changing direction again well then we'll go to our animated Sprite and set flip H back to false and that's it that's our entire script let's find find our enemy here and hooray we've made an enemy and a slimy one at that but of course dying to the enemy could definitely look cooler so let's fix that dying 2.0 let's start by adding a slow motion effect when we die we can do this by changing the time scale of the entire game so inside of our Kill Zone we'll open up the script here and right after we print U died let's modify our time scale so I'll go engine do time scale and set it equal to 0.5 this means that we will go at half speed then when our timer runs out let's set this back to default because otherwise we will actually still be slowed down when our scene reloads so we'll go engine do time scale and set it back to the default one and if we play this now this is actually already much better notice that it also takes twice as long before the game restarts because everything in our game slows down including our timer but I think could be even cooler if we remove the player's collider to make him simply fall off the map to do this we need a reference to the player we actually already have this here you'll notice that after the on body entered here there's a variable called body this refers to the body that entered the area and since the only thing that enters the kill zone is our player body is our player so we can actually add a new line here that goes to our body and then we simply need to get the Collision shape node under our player so we'll do dot get node and we'll search for the Collis shape 2D and we can remove it so call do Q free on that node again Q free means to remove that node so here we're accessing our player getting the Collision shape node and removing it and now if we find our way to some danger boom we are hit and we fall off the map cure the sound effect player 2.0 so far we've been using the character movement template pretty much as is but we need to modify it in order to add animation to our player as well as change the key Bindings that we use to move so what are we looking at here well the top two lines Define two constants with our speed and jump velocity there's also a variable here that defines the gravity based on our project settings by default this is a value of 98 so we have these three values but the meat of the script is really inside of this physics process function physics process is very similar to the process function we used for our enemy however while process is great for a lot of things there is one part of the game engine that really struggles with not knowing how many times per second it is going to be run that is the physics engine physics in general need to update at fixed intervals to avoid janky Behavior luckily physics process solves this problem because it runs at a fixed rate 60 times per second by default this is independent of your game's actual frame rate and helps physics run smoothly we use it for anything that involves the physics engine like moving something that should collide with its environment such as a player character so in this function a few things are happening if the player is not standing on a Surface we add gravity if we press the space bar and the player is on the surface we jump and then we get the direction we need to move in based on what arrow keys are pressed and move accordingly now let's start by rebinding some input keys for this sco uses an action system we create actions for anything we want to do in the game jump is an action so it's move left or move right we can then bind keys to these actions let's try it out so let's go to project project settings input map and here we can add some actions I'm going to add a jump action as well as a move left and a move right then we can use the plus sign over here to bind a key so to my jump here I'm going to hit plus and then it's listening for input so I'm going to press the space bar and hit okay and as you can see space is now bound to jump for a move left I'm going to bind the left Arrow key and I'm also going to bind the a key so we can use vast for movement as well as you can see there's no problem binding multiple keys to the same action which is really handy I'm also going to bind right arrow to move right as well as the D key and now we can use these actions in our script by default gdau uses some builin actions that are meant for navigating UI this is why it says things like UI accept here let's replace these with our own actions instead and as you can see it will actually help us by autoc completing here so I'm going to put in Jump for my jump action and then for moving left here I'm going to change to move left and for moving right I'm going to change to move right and now we can use the keys bound to our actions to move around which in my case are both the vast keys and the arrow keys awesome the next thing we need to do is to update our player Graphics to face the direction we are moving in and to play the right animation let's start by flipping our Sprite based on Direction so just like with our enemy we first need a reference to the animated Sprite node again here we can simply click and drag and hold down control again I'm going to remove the 2D from the name to make it sure order and then we'll add some extra code to our function now this line here defines a variable called direction that is based on our input if we don't press any buttons direction will be zero if we press move right direction will be one and if we press move left Direction becomes minus one so we can use this variable to check if we are moving left or right I'm going to make some space in the code here and make my own comments as well so use a hashtag for a comment this here gets the input Direction which can either be minus one 0 or 1 and this down here actually applies the movement so in between we can add a section that flips the Sprite to do this we check if our Direction variable is greater than zero well that means we are moving to the right and we can set animated Sprite dot flip horizontally to false if this is not the case well then we want to check if our direction is less than zero for this we can use the El if or E if keyword so else if our direction is less than zero well then we'll set animated sprite. flip AG to true and now if we play this we can see that our play a Sprite indeed faces the right direction now let's add some animation so let's go to 2D view select our animated Sprite and let's add two new animations one called run and one for jumping in our run animation I'll add some new Sprite frames select our KN remember this is 8x8 and I'll simply add all of the frames in the Run animation which stretches over two lines here I'll add those frames set the fps to 10 and play looks good then for the jump animation I'll also add a Sprite frame and there are bunch of different ways to go about this but in our case here I think we should actually play our jump animation when whenever we're just in the air this means that this will also play when we're just falling off a platform and for this we could use a very quick looping animation or simply a single frame I actually like this one from the roll animation so I'm just going to use that then in our script we can of course play these animations so after we get the input Direction and flip the Sprite let's add a new segment which is going to play animations and here we also need to check our Direction variable more specifically if our direction is equal to zero well then we're standing still and we can go ahead and play animated sprite. playay the animation called idle if this is not the case so else well then we want to play animated sprite. playay the Run animation and that's actually it if we now start running we can see our run animation being played finally we just need to add our jump animation and here we can use a buildin function fun of our character body 2D which is to check if we standing on the floor so at the top here we'll check if we're currently on the floor is on floor well then we want to go ahead and play our idle or run so I'll cut this using contr X paste it in here make sure you tab in and if we are not standing on the floor well then we're in the air and we can go and play animated sprite. playay our jump animation instead so if we're on on the floor and our direction is zero well then we're playing idle if it's not zero well then we're playing run and if we are not on the floor we aren't doing any of those things we're just playing the jump animation and that's it now if we play we have a fully animated Knight I like to think that she's a former princess who got so tired of waiting to be saved from the big bad dragon that she took matters into her own hands who better to save some princesses from a dragon that someone who knows dragons like her own back pocket but feel free to make up your own story and that reminds me story we need a good way of communicating story hints and other valuable information to the player and to do this we need text so let's add some text elements to our game text there are multiple ways of working with text in good do as part of a larger UI or as an integrated part of the game world for this game I decided to try making the text part of our world in Gau a text node is called a label so let's add one let's hit CR a and search for a label let's focus on it and as you can see this creates kind of a bounding box for our text so I'm going to put it over here and scale it up a bit and let's add some text in the field here I'm going to put in a gameplay hint and as you can see the text looks really blurry that's because since we're using pixel art we actually zoomed in really really far which makes the otherwise smooth text appear blurry so we can fix this by using a pixelated font with hard edges to match our style I've of course included some in the assets so let's go under theme overwrites on our label fonts and here we can drag in the pixel operator font we can also change the font size on do font sizes here enable that and I'm going to set mine to eight note that we have to use multiples of eight in order for the text to appear crisp so you can see if I change this to nine it becomes blurry again but we can use 16 24 32 and so on I'm also going to go to the colors here and change the font color using the Color Picker and now we can place these text elements around our game to provide story or gameplay tips once we're happy we can categorize all of them under a node so let's create a node call it labels and drag all of them under that and now when we play as you can see they appear as a natural part of our game world and just like with Sprites because the player character has a greater Z index it will draw on top so let's use one of these text elements to display our current score score and points to create a score or coin counter for our game we need two things a script that keeps track of our current score and a label to display it it's common practice to place gamewide variables such as a score inside some kind of game manager so let's make one we'll hit contr a to add a new node let's rename it game manager and I'll place it right at the top here the reason why we are using a regular node and not a node 2D is because we don't need our game manager to have a transform in other words a position rotation and scale now let's add a script to our game manager we'll use the empty template and for the path here let's put it inside of our scripts folder and let's also rename it with non capital letters create and let's create a variable for our current SC score so we'll write VAR for a variable name it score and default it to zero now so far in our code we've only used the building functions of gdau and some that we made with signals in this case here we want to create our own function that adds a point to our score and displace it so I'll write funk for a function we'll name it add Point open and close some parentheses and put a colon then on a new line we'll write score plus equal 1 to increase our score by one and print our current score now unlike ready which runs at the start of our game and our signal functions which run when a signal gets triggered this function currently has nothing that calls it so right now our function is here but it isn't being run to change this we need to go into our coin script and tell it to call this function whenever a coin is picked up so inside of our coin script we need a reference to our game manager but if we just click and drag while holding down control we get this really weird looking path this is because the game manager is higher up in the tree than the coins and it's generally bad practice to use paths like this that try to access nodes at the same level or higher in the tree luckily because our game manager is a oneof a kind and we are sure that there will always be only one game manager we can solve this by marking it as unique so let's right click our game manager and select access as unique name as you can see this creates a percentage iccon next to the game manager letting us know that it's a unique node this makes it much easier and safer to get a reference to the game manager because now when we drag it in instead of a dollar sign with a weird and unpredictable path we get a percentage sign which means that Gau quickly finds the node via its unique name instead of using a path one limitation of this is that you can only access unique nodes from within the same scene if the game manager and the coins were in different scen means this wouldn't work now in our function we can replace the print line here with game manager access our game manager and call the function add point And now when a body enters our coin it's going to go to the game manager and run our add Point function and if we play we can see that every time we pick up a coin it increases and prints our score in the output window finally we can use what we learned about labels in the previous chapter to create one for dis displaying our coins I'm going to make a little place for this in our level for now I'll just put in some text that says you collected x amount of coins I'm also going to change the auto wrap mode to word now we can wrap our text and the horizontal alignment to Center finally I'll use a boulder font now we can take this label and rename it to something like score label and since we want to change it from our game manager let's drag it right under our game manager now in our script we get a reference by clicking and dragging holding down control and instead of printing our score we'll go into our score label and access the text property and change it to you collected and then here I'm going to add the number add the score onto that amount of coins notice how make sure to add spaces between the words and while this looks good it's actually going to give us an error and that's because we need to change this score here from a whole number variable called an integer into a text variable called a string again we'll talk much more about variables in our video on GD script but for now we can cast this using Str Str for string and then wrapping it in parentheses and now when we play and pick up some coins along the way here once we get to the end it says great job you collected six coins and if I pick up another one it's going to update to seven awesome and I don't know about you this is great and all but I think it's distinctly lacking a bling sound when we pick up a coin blinging bling audio one of the things that often get overlooked when making a game is audio but music and sound effects are a huge part of building the movie of your game this is of course a beginners tutorial but let's at least get our feet wet or should I say our ears wet nope I shouldn't let's at least add a music track and a pickup sound for our coins now in the assets I've included a music track as well as a few sounds and to play these we need a new type of node the audio stream player so let's add a new node search for audio stream player 2D let's rename this to music then we can take our music track here time for adventure and drag it into the stream slot we're also going to set it to autoplay and by default this is not going to Loop to change that let's double click it this is going to open up our audio importer here we can preview our music track groovy anyways we can Loop so let's enable Loop here and hit repport now by default all sounds are played fairly loud and since this is background music we probably want to turn it down a bit we can do this by by adjusting the volume on each individual audo stream player or we can use the audio tab here at the bottom this is actually a fully functioning audio mixer and we can add different buses to control our audio let's add two one for our music as well as one for sound effects and then we can simply route our music here into our music bus so now we can control the volume of our music using this slider I'm just going to set it to 12 and we have music unfortunately it's going to restart whenever our scene is reloaded a quick fix for this is to take our music node and make it into a scene so click and drag it into our scenes folder hit save and then we can add this scene as an autoload auto loads are Global scenes and scripts that we want to persist throughout our entire game no matter which scene is currently loaded so let's remove music here from our game scene and instead go to project project settings autoload we'll click the little folder here and navigate to our music scene and hit add we've now registered our music scene as an autoload which means that if we now play even though our music scene isn't in our game it automatically loads and start playing our track and even better it doesn't reset when our game restarts now to add a pickup sound we go to our coin and add an audio stream player let's rename this to pick up sound drag in our coin sound and set the bus here to sound effects and now we can actually play this sound through script but since we're removing the coin immediately by calling the Q free function the sound won't actually get a chance to play we can of course fix this by adding code that Waits until the sound has finished playing but then we might get weird functionality where we try to pick up the coin multiple times while it's playing and it will still be visible until the sound is finished so that me show you a really cool trick to get around tricky timing things like this without writing any code that is using an animation player so let's add an animation player and here we'll create a new pickup animation and the first thing that we want to do when we pick up the coin is to hide the coin Sprite so I'll go into the animated Sprite 2D and this will change the window so I'll go back to animation Here and Now under visibility I get to key frame the visible property now when working with animations that don't need to play until later in the game it's nice to be able to go back to the default values after animating by default here our coin should be visible now this is pretty cool if I just create a key frame here for the default value G is going to ask to create a reset track if we say yes to this gdor is automatically going to create another animation track called reset that will simply reset this value to its default state so now in our pickup animation we can key frame it to whatever we want in our case when we pick up the coin we want it not to be visible so I'll disable that key frame it and then if we want to go back to our default values we simply go to our reset track and there it is it goes back to default so let's go to our pickup let's also modify our Collis shape we don't want to be able to collide with it while it's playing the sound so let's simply go ahead and add a default key here for the disabled property hit create and now we can set disabled to true and add a new key we can also go into our pickup sound here and let's add a default key for the playing property let's hit create and now since the sound plays pretty quickly I I can actually reach the key in time so we can go down here instead I'm just going to scale this up a bit go down here to the value the key frame here and change it to on so we can actually modify the key frames here as well so now we have our pickup animation and if we go to reset we can see that everything goes back to default so that's just a nice way of working with animation so now we play the sound disable the collider and hide the Sprite after 1 second though we can go ahead and remove the coin from our scene so all of these key frames here are on second one let's put them over to right at the beginning of our animation at second Z and then after 1 second here we want to remove our coin and this is a really cool part about the animation system is that we can actually add another track here a call method track that is used to calling functions so on our coin we want to call a function and I'll right click right where we want to do that insert key and the function that we want to call is the Q free method which is right here and so now after 1 second it's going to call the Q free method on our coin without us writing any code and voila all the things we could have done through code are all inside this animation and again to get back we simply choose reset now all that is left is playing the animation through script so in our script we'll get a reference to our animation player and then instead of directly calling Q free we'll go animation player. playay pickup and if we play now we can hear our music and we can hear our pickup sound when we run into the coins awesome export finally we are ready to export really incredible that you made it this far you can feel very proud so let's get our game out of Gau so we can share it with others Gau can of course export to many different platforms but I'm on a Windows computer here so let's go ahead and make a quick Windows build the first time we are exporting our game we need to download the export templates these are a little large so to keep good old lightweight they aren't included by default to install them we go to editor manage export templates and hit download and install and the export templates are installed and ready to be used so we'll close close go to project and export in this window we'll add a build platform so let's go add Windows desktop we'll enable embed pck which will export it into a single file then we scroll down as for the product name here I'm going to type in Princess Dragon Slayer and we can hit export project I'm simply going to put this on my desktop uncheck export with debug and hit save this warning is not a problem we'll hit okay and now on the desktop we have this first game.exe we can open that up and voila we made a game woohoo and that's it congratulations on making your first dish or I mean game in Gau if you don't understand everything or unsure about where to go from here don't worry that's totally normal it takes a little while to become familiar enough with the tools to feel really free with them never hesitate to use the documentation tutorials or code examples you find online when I started out I spend a lot of time remixing other people's scripts before I started to write my own now where do you go from here well that's totally up to you but if you want to continue adding to this game here's a list of things that you can try out expand the level see how far you can get using just what you know now I think you'd be surprised with how much fun gameplay you can get out of just these simple elements add effects like an animation or particles when picking up a coin or more Sound and Music add more danger elements like spikes or traps that turn on and off most of these are just variations on the Kill Zone we've already made add a main menu more enemies give the player a weapon or add powerups you can also expand on the game manager for example to use it to switch scenes a common way to do this is by turning it into an autoload just like we did with our music track or perhaps you want to improve player Movement by adding coyote time and double jumps the possibilities are endless also don't forget to check out Zena Academy be among the first 50 people to use the coupon code below to get 20% off the first year of your zenva subscription and that's it for making your first game in Gau and I wish you the best of luck on making your second one
