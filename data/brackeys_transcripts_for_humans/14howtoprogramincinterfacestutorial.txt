With timestamps:

00:00 - thanks for tuning in at
00:03 - brais hello everyone and welcome to
00:05 - video number 14 in how to program cab
00:08 - course in today's video we're going to
00:10 - have a look at interfaces so an
00:13 - interface is basically like a contract
00:16 - that you uh can sign with a class uh
00:19 - saying what needs to be in that class so
00:23 - uh if you look at an interface it's very
00:25 - much like a structure of what methods
00:29 - and properties
00:30 - needs uh need to be in that
00:34 - class uh so that sounds maybe a bit
00:36 - abstract to you uh but uh basically you
00:39 - don't have to get very far in
00:41 - programming before interfaces become
00:44 - very useful uh for making things simpler
00:48 - uh safer and a whole lot
00:50 - cooler uh so that's going to be awesome
00:53 - and uh we are uh a pretty good uh way
00:56 - into the series here so I quickly want
00:59 - to mention mention that if you go to
01:01 - bre.com I do have a donate button here
01:04 - where you can support Brees uh so you
01:06 - can simply click on that and it will
01:08 - take you to PayPal and you can donate
01:11 - any amount that you want to uh all of
01:13 - the uh stuff that I uh upload is is free
01:17 - all of the assets on the unity asset
01:18 - store is free and the assets packs uh so
01:21 - if you want me uh to keep doing this for
01:24 - free uh you can of course help me out by
01:27 - uh donating so I quickly wanted to
01:29 - mention that it's of course not
01:31 - something that you need to do and I
01:33 - don't expect you uh to either uh but if
01:37 - it's something that you feel like uh
01:39 - would uh would feel would be a good idea
01:42 - um I I'm not going to stop you cool so
01:46 - let's dig right into today's video so
01:48 - I've opened up Samaran Studio here and
01:52 - uh if we take a look at implementing a
01:54 - symol interface uh we can basically
01:59 - describe an interface as uh kind of
02:02 - saying what should be in a class and
02:05 - then the class itself describes uh how
02:09 - each method is implemented so uh an
02:12 - example of an
02:14 - interface uh we're going to create one
02:16 - here could be uh let's say an item so we
02:20 - wanted to have an item system and we
02:22 - wanted to define the structure of all
02:25 - items well then we create an instant
02:27 - interface for those items and I'd like
02:30 - to begin all of my interfaces with an i
02:32 - so here's going to be I item just so we
02:35 - can identify them as
02:37 - interfaces and then we open and uh close
02:40 - some brackets here and uh inside of uh
02:44 - the interface itself the syntax is
02:47 - actually really simple uh we don't need
02:50 - to do any uh kind of uh availability
02:53 - layers so we can avoid the public and
02:56 - private and all that and uh basically we
02:59 - just need to define the data type for
03:02 - the property so we're going to have a
03:04 - string um with the name of the item and
03:08 - uh you can't just close this off this
03:10 - has to be uh marked as a property
03:12 - meaning that we have to do uh get and
03:17 - set that's just a formality but it's
03:20 - something you're going to have to do and
03:22 - then we can also maybe make an integer
03:24 - with uh the uh gold
03:28 - value of uh this item and that's also
03:30 - going to be a property so we do the get
03:33 - set here and uh then we can maybe make
03:36 - uh a couple of methods so first off
03:38 - we're going to have void and this should
03:41 - of course be pool or float depending on
03:43 - what you want to return so we'll just
03:46 - say say void here and uh we'll um make
03:50 - this uh equip so we can equip our item
03:54 - and another one for selling it and none
03:58 - of these are going to taking any
04:00 - parameters either that's also something
04:02 - you'll have to uh think about here so
04:06 - that's a very simple interface and if we
04:08 - wanted to implement this uh we could go
04:11 - in here and Define uh a class and we
04:15 - could call this
04:17 - sword and uh of course open and close
04:20 - some curly brackets and uh in here we
04:23 - could create a uh
04:27 - public uh string
04:30 - name and again just simply let's use the
04:33 - C uh default get
04:36 - set and a public
04:39 - integer gold
04:41 - value and again use get
04:45 - set cool and then we could go in and
04:48 - create a Constructor so we'll make this
04:50 - a public
04:52 - sword and uh we're going to take in as
04:55 - an argument uh the uh name so string
04:59 - name so we can give it a name once we
05:01 - create a
05:03 - sword and uh we're going to set name
05:06 - equal to underscore name the name passed
05:08 - in and we're going to set gold value
05:10 - equal to 100 so we'll just say that all
05:12 - sorts uh in our game has a a gold value
05:16 - of$ 100 imaginary
05:19 - dollar and uh cool so you can see here
05:22 - that we've now implemented the two
05:24 - properties and we haven't yet
05:26 - implemented the methods and uh the
05:29 - program is going to notify us of this so
05:32 - if we save this and hit play you can uh
05:35 - who this actually runs oh I know why
05:38 - it's because we need to implement the
05:40 - interface stupid me so this is very uh
05:44 - Central right now we just have a class
05:46 - definition and an interface definition
05:49 - but if we go ahead and actually inherit
05:52 - from this interface just like we've
05:53 - inherited from other classes before so
05:56 - we can inherit from I item here then you
05:59 - can see that when we hit play it's going
06:01 - to say that uh it doesn't Implement uh
06:05 - the uh interface member equip and if we
06:08 - click on this you can see that it
06:10 - doesn't either implement the interface
06:12 - member cell and if we didn't have these
06:16 - values or properties here it will notify
06:19 - us to implement those
06:22 - too cool so and you might be thinking
06:25 - right now well why don't we just use a
06:27 - base class and uh the reason for this is
06:31 - that we can use multiple
06:33 - interfaces uh that we can derive from
06:36 - multiple interfaces and also this uh
06:39 - allows us to Define how we uh how the
06:43 - actual methods and properties are going
06:45 - to work in uh the uh derived class
06:49 - itself so now we can simply uh go ahead
06:52 - and make a some fairly simple um methods
06:55 - here and equip method and of course we
06:58 - don't have any logic for
07:00 - um equipp equipping items here so we'll
07:04 - just write out that um the name of the
07:07 - item and then has been
07:14 - equipped and uh actually we'll just say
07:22 - equp shorter and uh then we'll have
07:27 - another uh method called cell and uh
07:31 - this one is just going to say
07:33 - that uh cons R line the name of the item
07:37 - plus uh sold
07:39 - for plus the gold Value Plus
07:45 - imaginary
07:48 - dollar cool and now when we hit play
07:51 - here nothing is going to happen but we
07:53 - don't get any errors so now down here we
07:56 - can go ahead and
07:57 - create a um
08:00 - uh a new sword we can create a sword and
08:02 - we'll just call this sword as a
08:04 - reference and we'll equal it to a new
08:07 - sword oops not a Nite a new sword and
08:10 - we'll give it the name sword of
08:16 - Destiny and then we can call uh methods
08:18 - on this so we can say that we want to
08:21 - equip this
08:22 - sword and then we want to sell the
08:26 - sword so now when we hit play you can
08:29 - see that uh sword of Destiny was
08:31 - equipped and sword of Destiny was sold
08:33 - for 100 imaginary
08:36 - dollar cool so that's the simplest use
08:40 - of an interface that I can come up with
08:42 - and this works uh just fine already but
08:45 - let's take this a step further so I've
08:49 - drawn this thing in paint I know it's
08:52 - the most beautiful thing I've ever seen
08:55 - in my life too but bear with me so if we
08:59 - look at interfaces as like tags that we
09:03 - can apply to our objects because right
09:05 - now we've tabed uh tag this class as an
09:09 - item well we could also tag it as a
09:12 - quality so we we could basically say
09:15 - that this item has some kind of uh
09:18 - quality level and therefore should be
09:20 - able to be damaged so we can add that
09:22 - kind of Dimension onto the class we
09:24 - could also tag it as part of a quest so
09:27 - we could create another interface for
09:29 - for that and then we can basically have
09:31 - different items so we can have an sword
09:33 - and an Axe and both The Sword and the
09:35 - axe maybe has is are attacked as an item
09:39 - of course and we both want them to have
09:42 - some kind of quality level and be able
09:44 - to be destroyed when
09:46 - used and uh but maybe only the sword is
09:51 - uh really important for one of the
09:53 - quests the ax is just something we P
09:55 - picked up and therefore something we can
09:57 - just sell no matter what so this is you
10:01 - see some a piece of logic that is
10:04 - available in pretty much any RPG that
10:08 - I've played at least uh because it
10:10 - allows us to very dynamically use our
10:13 - code uh throughout our game and uh then
10:17 - if we even go further with this we can
10:19 - have an inventory uh with all of these
10:23 - items so we can have an array of items
10:27 - and then we can Loop through that array
10:29 - and check what items are marked as part
10:32 - of a quest and those that are that are
10:34 - we can call a method on those items that
10:37 - only those items have that we want to
10:40 - turn in the quest uh turn in the quest
10:43 - items
10:45 - so this might sound complicated but I
10:48 - think we'll go ahead and implement this
10:50 - so first off let's create the quality
10:51 - layer and that's going or the quality
10:54 - tag and that's going to act pretty much
10:56 - the same as our item tag so we're going
10:58 - to have an interface is here I
11:01 - quality uh and I know the name here is
11:03 - not perfect but we'll we'll just go with
11:06 - I quality and uh this one is going to
11:10 - have some kind of uh integer uh and
11:13 - we'll call this quality level no uh
11:19 - we'll call this
11:22 - durability
11:25 - uh actually instead of quality let's
11:27 - call this damageable
11:31 - I like that a lot better I should have
11:33 - thought of that so long ago okay um so
11:39 - interface I damageable and uh it's going
11:41 - to have an in uh
11:44 - durability and uh it's going to uh of
11:47 - course have a getter and a
11:51 - Setter and uh then we can create a
11:54 - method that will uh here that will uh
11:58 - say take damage
12:00 - and it's going to take in an integer
12:06 - amount and uh it's simply going to say
12:09 - that durability minus equals and then
12:11 - we'll say uh
12:13 - 20 oh no of course amount amount cool so
12:19 - and uh the name of this argument uh
12:22 - basically doesn't matter uh that's uh
12:25 - completely irrelevant and of course this
12:28 - is on the impl M mentation side we just
12:30 - want to finish this off I don't know I
12:32 - got confused there sorry uh but
12:34 - basically we we do this structure where
12:36 - we want to have a void that takes damage
12:38 - and uh we want to uh put in the amount
12:41 - as an integer and it doesn't matter what
12:43 - you name this here because uh we can
12:45 - just rename it or name it something
12:48 - different down here and it's not going
12:49 - to throw any kind of errors or anything
12:51 - so uh now we have this uh damageable tag
12:55 - which um forces our object or our class
12:58 - to include a dur durability variable and
13:02 - a take damage me damage method so let's
13:05 - now tag this with um I
13:10 - damageable and uh now we can uh create a
13:14 - public void take
13:17 - damage and it's going to take in the
13:20 - amount or I could call this damage uh
13:22 - just to show you that that will work I'm
13:24 - going to do that and then we uh do the
13:27 - logic here and of course of course uh
13:29 - now we want to name this damage and we
13:32 - also want to implement the durability so
13:35 - we can say public integer and uh uh this
13:40 - is going to be called
13:42 - durability and uh simply implement the c
13:45 - a normal uh get
13:48 - sit and we could do something here again
13:51 - with a private variable uh underscore
13:53 - durability uh that will make sure that
13:56 - durability doesn't go below zero and all
13:58 - that which you've seen in previous
14:00 - videos so again we have complete control
14:02 - over what this durability variable
14:05 - actually does what its value is and uh
14:08 - how we change
14:10 - it cool and uh now down here we'll be
14:13 - able to uh will say that uh we want to
14:16 - equip the sword and then we want to
14:20 - damage the sword by 20 and uh whenever
14:24 - it takes
14:25 - damage let's also print out
14:29 - uh that the name of the item and then uh
14:34 - took uh Dam or let's just say
14:38 - damaged
14:40 - uh
14:41 - by and then we'll put in the damage
14:47 - amount and then we say it
14:51 - now has a
14:53 - durability of and then put in the
14:57 - durability cool
15:04 - yeah awesome so let's save that and hit
15:07 - play
15:09 - whoops uh expected a colon am I missing
15:13 - I'm missing a plus sign
15:17 - there hit play cool and it says sword of
15:20 - Destiny equipped sword of Destiny damage
15:22 - by 20 it now has a durability of -20
15:26 - sort of Destin so for 100 m imary
15:29 - dollars cool so uh for some reason uh
15:34 - okay so durability of course defaults to
15:37 - zero so up here in our uh Constructor
15:40 - we'll simply say that durability should
15:42 - be equal to 30 uh by default and now we
15:47 - can see that it says that it has a
15:49 - durability of
15:51 - 10 awesome so that's kind of the idea
15:54 - that we can create these tags and Mark
15:57 - our items and uh if we just take this
15:59 - whole sword class here and copy it down
16:03 - here we can very very easily create an
16:06 - axe so um it's again that's going to
16:09 - derive from item and uh damageable and
16:12 - this is also going to be ax it's going
16:15 - to take in a name it's going to start
16:17 - with a gold value of 70 and a durability
16:21 - of 50 and uh all of these
16:24 - implementations are going to be the same
16:27 - and then down here we can create an a
16:29 - called it a set it equal to a new ax and
16:33 - set it its name to Fury
16:37 - a and then we can maybe equip the
16:42 - A and we can uh of course damage the uh
16:46 - damage the A and uh we're going to
16:48 - damage this by 10 and uh finally we can
16:52 - uh sell the
16:54 - [Applause]
16:55 - X so we can do all of the same stuff and
16:58 - and let's just make an empty line
17:02 - between these so simply write out
17:05 - console. R line and you can see that it
17:08 - does all of the stuff for the sword
17:10 - creates an ax and does all of this stuff
17:12 - for that too so that's super cool but
17:15 - that's just adding on to the amount of
17:18 - complexity that we have in our game next
17:21 - up is the actual very very cool part of
17:25 - this and that is marking these uh items
17:29 - as quests and then using that in our
17:32 - actual game logic so if we should go
17:36 - ahead and create create an interface
17:38 - here uh that the idea is very simple we
17:41 - go ahead and create an interface called
17:43 - I part of
17:46 - quest and uh again we do all of the
17:50 - brackets uh we then create
17:53 - an uh let's just create a a void we
17:56 - could have of course some more
17:58 - information like uh the name of the
18:00 - quest and all that but here we'll simply
18:03 - uh force it to include a word called
18:06 - turn in that will turn in the
18:09 - item and that's basically all of the
18:12 - that this interface is going to
18:15 - implement so uh or all the classes
18:18 - deriving from this interface is going to
18:20 - be forced to implement I should say and
18:23 - now we can uh make our sord derived from
18:25 - this but not our a so let's uh do a
18:29 - comma here and uh Implement I part of
18:34 - quest and it's super cool this uh idea
18:37 - that we can see all of the attributes of
18:39 - our sword right here uh it also makes it
18:43 - very easy to read the code once it gets
18:45 - more complicated and very easy to uh add
18:48 - functionality to a class and uh then uh
18:52 - we simply want to include the logic here
18:54 - so we'll make a public void and we'll
18:57 - call this turn in
18:59 - and it's not going to take in any
19:00 - arguments we're simply going to say that
19:03 - console. R line uh and then name of the
19:08 - item uh turned
19:12 - in that's it cool so now down here our
19:18 - sword will be able
19:20 - to call the turn in method but our axe
19:24 - won't so if we try here ax. turn in you
19:27 - can see it doesn't autocomplete and we
19:30 - would get an error if we tried that so
19:33 - now let's see what we can actually do
19:36 - with this so down here we can create an
19:40 - inventory and uh we simply need to mark
19:44 - this uh we we need to make the type of I
19:47 - item so this is an array of items uh
19:51 - meaning an array of classes that derive
19:53 - from the I item uh interface
19:59 - and uh this is simply going to be called
20:01 - inventory or
20:02 - items uh and we're going to set that
20:05 - equal to a new I item array which is
20:07 - going to take be able to store two
20:10 - elements and uh in the first element so
20:13 - index Zer we're going to set it equal to
20:17 - the sword that we've created and the
20:21 - second index uh or the second uh spot in
20:26 - our array meaning index one is going to
20:28 - be equal to a so both both of these or
20:34 - these are different classes but they
20:37 - derive from the same interface and
20:40 - therefore we can add them into our
20:44 - array and then we can Loop
20:49 - through and uh turn in all Quest items
20:55 - so we can say 4 in IAL = z i is less
21:00 - than
21:01 - inventory. length I ++ so this is a
21:04 - simple for loop I hope you remember
21:07 - those if not go back and watch the
21:11 - video because uh for Loops are kind of
21:16 - essential and uh then we simply want to
21:19 - say that uh then we want to create an uh
21:25 - I part of quest uh and this is going to
21:28 - store the quest item and we're going to
21:31 - set it equal to inventory and then the
21:34 - index and uh it's okay so let me just
21:38 - explain what we're doing here so uh
21:40 - we're creating an inventory and that's
21:43 - going to act as an uh array of I
21:47 - items and it's going to have a uh total
21:51 - capacity of two the first inventory item
21:55 - we set equal to our sword because that
21:57 - derives from I items
21:59 - and uh the second spot we set equal to X
22:02 - and that also derives from I item then
22:05 - we Loop through all of the elements and
22:08 - uh the element that we're currently
22:10 - looking at is called inventory to I so
22:14 - uh when we uh go through the first time
22:17 - this is going to be the first element
22:19 - which is the sword it's going to say
22:21 - inventory zero here and the second time
22:24 - it's going to be inventory one which is
22:26 - the
22:27 - ax and and uh then we try and put this
22:30 - into a variable of type I part of quest
22:34 - and we call this the quest item uh so if
22:37 - we just do this it's going to uh give us
22:40 - an error because right now the inventory
22:42 - item is of type I item and the uh Quest
22:46 - item is of type iPod of quest but we can
22:50 - cast this object into a i part of quest
22:54 - by simply adding an as I part of quest
22:57 - so now this is red as create a variable
23:00 - of type I part of quest and fill it with
23:04 - uh the inventory item of index I as as
23:08 - an i part of quest
23:11 - object
23:13 - so what this does is basically if the
23:17 - inventory is marked with uh the IOD of
23:22 - quest tag if it derives from the
23:24 - interface well then it's simply going to
23:27 - uh be trans formed into the quest item
23:31 - variable but if it doesn't which our a
23:34 - doesn't well then uh this is not going
23:37 - to work and Quest item is going to be
23:39 - equal to zero because the ax is not a
23:42 - quest item and therefore uh Quest item
23:45 - will be null so now we can write if
23:48 - Quest item is not equal to null meaning
23:52 - if the object that we are looking at
23:55 - indeed is marked as a quest item well
23:58 - then we can go ahead and make sure uh
24:01 - then well then we are sure that it has a
24:03 - Turnin method and therefore we can call
24:06 - it so now we can say that we want to uh
24:09 - call the Turnin method on Quest item so
24:14 - that is
24:15 - completely uh uh right and uh this
24:19 - should work for any number of items that
24:23 - we decide to create so uh let's try and
24:27 - run this and see if it's actually
24:30 - working so let's hit
24:31 - play and whoops I just want to quickly
24:35 - make some more room here and uh now hit
24:37 - play again and you can see that we
24:40 - create a sword and uh we equip it and it
24:44 - says that it was equipped then we take
24:46 - some damage and it was damaged then we
24:49 - sell it and it says it was sold then we
24:52 - create an axe we equip it damage it and
24:55 - sell it and then we create an inventory
24:58 - array uh which is basically an array of
25:01 - ey items then we fill in the two items
25:04 - that we have then we Loop through it and
25:08 - we check and we try and force these
25:11 - items into an a a variable Called Quest
25:15 - item of type I part of quest and then we
25:18 - check if that succeeded and if it did
25:21 - meaning it wasn't equal to null then we
25:23 - turn it in and you can see here that it
25:26 - says sort of Destiny turned in because
25:29 - that is indeed marked as a quest item if
25:32 - we were to go up here and mark the a
25:35 - also so I quest part of quest item uh
25:40 - and uh we were to create a method called
25:44 - turn in again we could just copy and
25:46 - paste the method here or we could make
25:48 - this completely uh different we can say
25:51 - that uh name here turned in and then we
25:54 - can say it was
25:58 - it was an
26:01 - axe you can see we can change this uh
26:04 - however we would like so now when we hit
26:06 - uh play here it's going to go through
26:09 - and turn both of the items in so when we
26:11 - play it says sword of Destiny turned in
26:13 - and fury a turned in
26:16 - parentheses it was an
26:18 - ax cool so that is basically all I
26:21 - wanted to show you with interfaces both
26:24 - the really simple way of looking at it
26:26 - as as basically a a a way of um making
26:30 - your code look uh cleaner and uh easier
26:33 - to follow and the other way which is
26:36 - using the inventory uh to uh kind of uh
26:40 - Define how objects uh objects should uh
26:45 - interact cool so thanks for watching I
26:49 - hope you enjoyed this video I hope you
26:50 - could you were able to follow it uh even
26:53 - though uh some of the stuff showed here
26:55 - is actually fairly complex um I'm very
26:58 - proud if you've gotten this far into
27:01 - this series so again thanks for watching
27:03 - and I'll see you in the next video
27:12 - [Music]

Cleaned transcript:

thanks for tuning in at brais hello everyone and welcome to video number 14 in how to program cab course in today's video we're going to have a look at interfaces so an interface is basically like a contract that you uh can sign with a class uh saying what needs to be in that class so uh if you look at an interface it's very much like a structure of what methods and properties needs uh need to be in that class uh so that sounds maybe a bit abstract to you uh but uh basically you don't have to get very far in programming before interfaces become very useful uh for making things simpler uh safer and a whole lot cooler uh so that's going to be awesome and uh we are uh a pretty good uh way into the series here so I quickly want to mention mention that if you go to bre.com I do have a donate button here where you can support Brees uh so you can simply click on that and it will take you to PayPal and you can donate any amount that you want to uh all of the uh stuff that I uh upload is is free all of the assets on the unity asset store is free and the assets packs uh so if you want me uh to keep doing this for free uh you can of course help me out by uh donating so I quickly wanted to mention that it's of course not something that you need to do and I don't expect you uh to either uh but if it's something that you feel like uh would uh would feel would be a good idea um I I'm not going to stop you cool so let's dig right into today's video so I've opened up Samaran Studio here and uh if we take a look at implementing a symol interface uh we can basically describe an interface as uh kind of saying what should be in a class and then the class itself describes uh how each method is implemented so uh an example of an interface uh we're going to create one here could be uh let's say an item so we wanted to have an item system and we wanted to define the structure of all items well then we create an instant interface for those items and I'd like to begin all of my interfaces with an i so here's going to be I item just so we can identify them as interfaces and then we open and uh close some brackets here and uh inside of uh the interface itself the syntax is actually really simple uh we don't need to do any uh kind of uh availability layers so we can avoid the public and private and all that and uh basically we just need to define the data type for the property so we're going to have a string um with the name of the item and uh you can't just close this off this has to be uh marked as a property meaning that we have to do uh get and set that's just a formality but it's something you're going to have to do and then we can also maybe make an integer with uh the uh gold value of uh this item and that's also going to be a property so we do the get set here and uh then we can maybe make uh a couple of methods so first off we're going to have void and this should of course be pool or float depending on what you want to return so we'll just say say void here and uh we'll um make this uh equip so we can equip our item and another one for selling it and none of these are going to taking any parameters either that's also something you'll have to uh think about here so that's a very simple interface and if we wanted to implement this uh we could go in here and Define uh a class and we could call this sword and uh of course open and close some curly brackets and uh in here we could create a uh public uh string name and again just simply let's use the C uh default get set and a public integer gold value and again use get set cool and then we could go in and create a Constructor so we'll make this a public sword and uh we're going to take in as an argument uh the uh name so string name so we can give it a name once we create a sword and uh we're going to set name equal to underscore name the name passed in and we're going to set gold value equal to 100 so we'll just say that all sorts uh in our game has a a gold value of$ 100 imaginary dollar and uh cool so you can see here that we've now implemented the two properties and we haven't yet implemented the methods and uh the program is going to notify us of this so if we save this and hit play you can uh who this actually runs oh I know why it's because we need to implement the interface stupid me so this is very uh Central right now we just have a class definition and an interface definition but if we go ahead and actually inherit from this interface just like we've inherited from other classes before so we can inherit from I item here then you can see that when we hit play it's going to say that uh it doesn't Implement uh the uh interface member equip and if we click on this you can see that it doesn't either implement the interface member cell and if we didn't have these values or properties here it will notify us to implement those too cool so and you might be thinking right now well why don't we just use a base class and uh the reason for this is that we can use multiple interfaces uh that we can derive from multiple interfaces and also this uh allows us to Define how we uh how the actual methods and properties are going to work in uh the uh derived class itself so now we can simply uh go ahead and make a some fairly simple um methods here and equip method and of course we don't have any logic for um equipp equipping items here so we'll just write out that um the name of the item and then has been equipped and uh actually we'll just say equp shorter and uh then we'll have another uh method called cell and uh this one is just going to say that uh cons R line the name of the item plus uh sold for plus the gold Value Plus imaginary dollar cool and now when we hit play here nothing is going to happen but we don't get any errors so now down here we can go ahead and create a um uh a new sword we can create a sword and we'll just call this sword as a reference and we'll equal it to a new sword oops not a Nite a new sword and we'll give it the name sword of Destiny and then we can call uh methods on this so we can say that we want to equip this sword and then we want to sell the sword so now when we hit play you can see that uh sword of Destiny was equipped and sword of Destiny was sold for 100 imaginary dollar cool so that's the simplest use of an interface that I can come up with and this works uh just fine already but let's take this a step further so I've drawn this thing in paint I know it's the most beautiful thing I've ever seen in my life too but bear with me so if we look at interfaces as like tags that we can apply to our objects because right now we've tabed uh tag this class as an item well we could also tag it as a quality so we we could basically say that this item has some kind of uh quality level and therefore should be able to be damaged so we can add that kind of Dimension onto the class we could also tag it as part of a quest so we could create another interface for for that and then we can basically have different items so we can have an sword and an Axe and both The Sword and the axe maybe has is are attacked as an item of course and we both want them to have some kind of quality level and be able to be destroyed when used and uh but maybe only the sword is uh really important for one of the quests the ax is just something we P picked up and therefore something we can just sell no matter what so this is you see some a piece of logic that is available in pretty much any RPG that I've played at least uh because it allows us to very dynamically use our code uh throughout our game and uh then if we even go further with this we can have an inventory uh with all of these items so we can have an array of items and then we can Loop through that array and check what items are marked as part of a quest and those that are that are we can call a method on those items that only those items have that we want to turn in the quest uh turn in the quest items so this might sound complicated but I think we'll go ahead and implement this so first off let's create the quality layer and that's going or the quality tag and that's going to act pretty much the same as our item tag so we're going to have an interface is here I quality uh and I know the name here is not perfect but we'll we'll just go with I quality and uh this one is going to have some kind of uh integer uh and we'll call this quality level no uh we'll call this durability uh actually instead of quality let's call this damageable I like that a lot better I should have thought of that so long ago okay um so interface I damageable and uh it's going to have an in uh durability and uh it's going to uh of course have a getter and a Setter and uh then we can create a method that will uh here that will uh say take damage and it's going to take in an integer amount and uh it's simply going to say that durability minus equals and then we'll say uh 20 oh no of course amount amount cool so and uh the name of this argument uh basically doesn't matter uh that's uh completely irrelevant and of course this is on the impl M mentation side we just want to finish this off I don't know I got confused there sorry uh but basically we we do this structure where we want to have a void that takes damage and uh we want to uh put in the amount as an integer and it doesn't matter what you name this here because uh we can just rename it or name it something different down here and it's not going to throw any kind of errors or anything so uh now we have this uh damageable tag which um forces our object or our class to include a dur durability variable and a take damage me damage method so let's now tag this with um I damageable and uh now we can uh create a public void take damage and it's going to take in the amount or I could call this damage uh just to show you that that will work I'm going to do that and then we uh do the logic here and of course of course uh now we want to name this damage and we also want to implement the durability so we can say public integer and uh uh this is going to be called durability and uh simply implement the c a normal uh get sit and we could do something here again with a private variable uh underscore durability uh that will make sure that durability doesn't go below zero and all that which you've seen in previous videos so again we have complete control over what this durability variable actually does what its value is and uh how we change it cool and uh now down here we'll be able to uh will say that uh we want to equip the sword and then we want to damage the sword by 20 and uh whenever it takes damage let's also print out uh that the name of the item and then uh took uh Dam or let's just say damaged uh by and then we'll put in the damage amount and then we say it now has a durability of and then put in the durability cool yeah awesome so let's save that and hit play whoops uh expected a colon am I missing I'm missing a plus sign there hit play cool and it says sword of Destiny equipped sword of Destiny damage by 20 it now has a durability of 20 sort of Destin so for 100 m imary dollars cool so uh for some reason uh okay so durability of course defaults to zero so up here in our uh Constructor we'll simply say that durability should be equal to 30 uh by default and now we can see that it says that it has a durability of 10 awesome so that's kind of the idea that we can create these tags and Mark our items and uh if we just take this whole sword class here and copy it down here we can very very easily create an axe so um it's again that's going to derive from item and uh damageable and this is also going to be ax it's going to take in a name it's going to start with a gold value of 70 and a durability of 50 and uh all of these implementations are going to be the same and then down here we can create an a called it a set it equal to a new ax and set it its name to Fury a and then we can maybe equip the A and we can uh of course damage the uh damage the A and uh we're going to damage this by 10 and uh finally we can uh sell the X so we can do all of the same stuff and and let's just make an empty line between these so simply write out console. R line and you can see that it does all of the stuff for the sword creates an ax and does all of this stuff for that too so that's super cool but that's just adding on to the amount of complexity that we have in our game next up is the actual very very cool part of this and that is marking these uh items as quests and then using that in our actual game logic so if we should go ahead and create create an interface here uh that the idea is very simple we go ahead and create an interface called I part of quest and uh again we do all of the brackets uh we then create an uh let's just create a a void we could have of course some more information like uh the name of the quest and all that but here we'll simply uh force it to include a word called turn in that will turn in the item and that's basically all of the that this interface is going to implement so uh or all the classes deriving from this interface is going to be forced to implement I should say and now we can uh make our sord derived from this but not our a so let's uh do a comma here and uh Implement I part of quest and it's super cool this uh idea that we can see all of the attributes of our sword right here uh it also makes it very easy to read the code once it gets more complicated and very easy to uh add functionality to a class and uh then uh we simply want to include the logic here so we'll make a public void and we'll call this turn in and it's not going to take in any arguments we're simply going to say that console. R line uh and then name of the item uh turned in that's it cool so now down here our sword will be able to call the turn in method but our axe won't so if we try here ax. turn in you can see it doesn't autocomplete and we would get an error if we tried that so now let's see what we can actually do with this so down here we can create an inventory and uh we simply need to mark this uh we we need to make the type of I item so this is an array of items uh meaning an array of classes that derive from the I item uh interface and uh this is simply going to be called inventory or items uh and we're going to set that equal to a new I item array which is going to take be able to store two elements and uh in the first element so index Zer we're going to set it equal to the sword that we've created and the second index uh or the second uh spot in our array meaning index one is going to be equal to a so both both of these or these are different classes but they derive from the same interface and therefore we can add them into our array and then we can Loop through and uh turn in all Quest items so we can say 4 in IAL = z i is less than inventory. length I ++ so this is a simple for loop I hope you remember those if not go back and watch the video because uh for Loops are kind of essential and uh then we simply want to say that uh then we want to create an uh I part of quest uh and this is going to store the quest item and we're going to set it equal to inventory and then the index and uh it's okay so let me just explain what we're doing here so uh we're creating an inventory and that's going to act as an uh array of I items and it's going to have a uh total capacity of two the first inventory item we set equal to our sword because that derives from I items and uh the second spot we set equal to X and that also derives from I item then we Loop through all of the elements and uh the element that we're currently looking at is called inventory to I so uh when we uh go through the first time this is going to be the first element which is the sword it's going to say inventory zero here and the second time it's going to be inventory one which is the ax and and uh then we try and put this into a variable of type I part of quest and we call this the quest item uh so if we just do this it's going to uh give us an error because right now the inventory item is of type I item and the uh Quest item is of type iPod of quest but we can cast this object into a i part of quest by simply adding an as I part of quest so now this is red as create a variable of type I part of quest and fill it with uh the inventory item of index I as as an i part of quest object so what this does is basically if the inventory is marked with uh the IOD of quest tag if it derives from the interface well then it's simply going to uh be trans formed into the quest item variable but if it doesn't which our a doesn't well then uh this is not going to work and Quest item is going to be equal to zero because the ax is not a quest item and therefore uh Quest item will be null so now we can write if Quest item is not equal to null meaning if the object that we are looking at indeed is marked as a quest item well then we can go ahead and make sure uh then well then we are sure that it has a Turnin method and therefore we can call it so now we can say that we want to uh call the Turnin method on Quest item so that is completely uh uh right and uh this should work for any number of items that we decide to create so uh let's try and run this and see if it's actually working so let's hit play and whoops I just want to quickly make some more room here and uh now hit play again and you can see that we create a sword and uh we equip it and it says that it was equipped then we take some damage and it was damaged then we sell it and it says it was sold then we create an axe we equip it damage it and sell it and then we create an inventory array uh which is basically an array of ey items then we fill in the two items that we have then we Loop through it and we check and we try and force these items into an a a variable Called Quest item of type I part of quest and then we check if that succeeded and if it did meaning it wasn't equal to null then we turn it in and you can see here that it says sort of Destiny turned in because that is indeed marked as a quest item if we were to go up here and mark the a also so I quest part of quest item uh and uh we were to create a method called turn in again we could just copy and paste the method here or we could make this completely uh different we can say that uh name here turned in and then we can say it was it was an axe you can see we can change this uh however we would like so now when we hit uh play here it's going to go through and turn both of the items in so when we play it says sword of Destiny turned in and fury a turned in parentheses it was an ax cool so that is basically all I wanted to show you with interfaces both the really simple way of looking at it as as basically a a a way of um making your code look uh cleaner and uh easier to follow and the other way which is using the inventory uh to uh kind of uh Define how objects uh objects should uh interact cool so thanks for watching I hope you enjoyed this video I hope you could you were able to follow it uh even though uh some of the stuff showed here is actually fairly complex um I'm very proud if you've gotten this far into this series so again thanks for watching and I'll see you in the next video
