hello this is John from Cave of programming. comom I wanted to add a video to this course just explaining a bit about um C++ design considerations in particular in the context of the program that we've developed in this course which is this particle fire simulation type thing so um as as I went along I kind of uh explained how the various classes worked but I didn't really explain why I implemented them in the way that I did which is a bit of an Omission so I wanted to talk just a little bit about designing C++ um I I've never been a big fan of Designing everything up front and then trying to code what you've already written because uh I think even the best software developer in the world is going to discover new things and get new ideas while they're actually implementing something and indeed we've seen historically that if you do upfront design uh where you design everything in advance and then try to implement it we we pretty much usually expect to get time overruns schedule overruns or budget overruns if you have to pay for the development so I I'm much prefer an iterative approach where you you try firstly to get some sort of very basic prototype together or at least you try to demonstrate some of the key things that your software is going to have to do like making a sound or um creating a window and writing pixels on it and then you kind of add bits to that software and you continuously build the software at every stage uh just build it like crazy if you've got a huge program that might have to be overnight every night but with a a smaller program like this we can afford to just add little bits of code and then immediately build it to to check that the code we've added uh makes sense and uh personally I'm a big fan of that approach so I won't talk about upfront design uh because it's not something I'm a fan of and and I'm I'm not good at it I'm just going to talk about um kind of um the thought process I had to go through to put this program together so as you've seen if you if you watched the other videos uh the first thing I did was put together an sdl demo program and that kind of did all the um basic sdl initialization code I don't have that stuff in my head I just looked at various bits of example code and sdl documentation and gradually put together a little demo program because I think it's important to um to test anything in your program that might be contentious that might not work on your system or whatever and here we wanted to create a screen and write pixels to it using a library that we hadn't seen before so it makes sense to kind of get a little demo program together just a really small program to test all this stuff with renderers and pixels and everything creating windows and check that it works and that we understand how to do it so that that was the first stage and then the second stag is once I once I got all this code which initialized sdl just drew some pixels and then um closed down XL um closed down sdl then I kind of looked at it and said well okay this is a good candidate for putting in its own class cuz originally we had all this all this kind of code initialization and destruction uh in the main program but uh it it's it's all related to one function it's all basically aimed at drawing at the screen so it seemed like a good idea to put that all in a separate class get it out of the main function so it's not cluttering up our main program encapsulate it in its own class and for that reason I created this screen class that does all that now there was a bit of code that U wasn't directly related to um to actually the the the business of drawing things on the screen and that was this code that processed our event so it checks what the users pressed if anything and takes an appropriate response and here that was a very very that's you can see that's a very very small amount of code so I figured okay this isn't going to expand let's just put it in the screen class arguably um processing events is also related to um to your window this is kind of a class that deals with window related stuff like drawing so arguably that's not a bad place to put it but if I'd had um a lot of event processing going on and it was complex then I might well have created a separate class uh called handle input or something that is just related to um to handling input but in this case I I put it in a screen class with the drawing code now once I've got that um it was clear that we we were going to need to deal with particles we don't want to if we're dealing with some distinct entity like a particle that bounces around the screen that's a that's a kind of obvious candidate for putting in its own class uh so um I I I created a particle class and that that was pretty straightforward uh we don't want to um sort of have separate bits of code dealing with the same thing the same pixel that's moving around you know okay it's it's actually different pixels being illuminated but conceptually we're thinking of this as being a particle that's moving around so it makes sense to encapsulate that in its own class and we don't want to kind of splatter different bits of code related to the same function throughout the software we don't want some code in one place that um that uh that kind of um moves particles and another bit of code somewhere else that changes the color or whatever we we want to encapsulate that in the class so just kind of looking at it and thinking about it um the a particle class seemed like a good idea if if we had a game and we had um let's say a spaceship in that game then of course that that's that's just conceptually from a human point of view that's a distinct object and so would probably want to represent that by some sort of spaceship object in our class and of course that could be a part of a hierarchy of classes where we could have a a Bas a base class that uh draws something on the screen and then we could add different kinds of behavior and get different subclasses to use different Graphics or whatever just as necessary uh so we could create different objects in our game like that but it's a it's clearly a good candidate for its own class and when I when I had the particle class um it was it was pretty clear that we were going to have to deal with big groups of particles and we've got to put that code somewhere uh we don't really want to put it in the screen class because the thing is that the screen class is uh it's a pretty pretty reusable class we could take this screen class which just deals with setting up XL setting up sdl closing it down minimal event handling and um drawing stuff to the screen from a buffer we could use that in any program so it's it's really reusable and if we started putting stuff specific to our program in this class like code relating to particles we can't reuse it anymore it's it's then forever tied to dealing with particles so once I got my screen class I wanted to keep it separate from other classes with with the idea in mind that um it's it's reusable and we also don't want to tangle it up unnecessarily with other code that really has nothing to do with this basic business of creating a window and um enabling drawing on that window uh so I needed some class that was going to organize particles um that was clear I didn't want to put that in my screen class I wanted to keep that as it is so it's nicely reusable and selfcontained and I didn't want to clutter up my my main. CPP here with um code that has to manage a whole swarm of particles so for that reason I created this class swarm and the point of this is just to deal with a whole collection of particles Al together so that that also uh kind of makes sense if you just think about this program you know just just conceptually clearly we've got individual particles here and clearly we've got we're dealing with a swarm of them there so just by thinking about what's in that uh program from a human point of view it kind of Clues Us in to what classes we might consider creating so I created this swarm class that can manage our a whole bunch of particles it doesn't do very much uh it's it's really just um creating particles deleting them later on which we can handily do in the um in the Constructor and D structor here respectively and I've also given it an update method because we need to update the positions of particles and since we've put the game Loop in main.cpp we're going to have to update them in this Loop but if if we've got a class that deals with a whole collection of particles um then it makes sense to get that class to do the business of visiting each particle in turn and updating its motion so rather than again if if the whole purpose of this class is to deal with an an aggregate of particles a whole load of particles so we want to try not to have code anywhere else that's dealing with individual particles otherwise that's kind of defeating the purpose of this class so I I created this update method and then that that deals with each of the particles in turn in the whole swarm and uh in main. CPP we only need to call the Swarm update method method to update each of the particles now a key design consideration here is to keep the Swarm and the screen class separate for the reasons I've mentioned we've got a nice reusable screen class then we've got um a very specific swarm particle swarm class that's really only for this program we can't well having said that even the Swarm uh class potentially could be reusable um inevitably cuz we're using sdl I've ended up splattering sdl code slightly uh throughout much of the program but if we look at um swarm Doh here swarm do CPP uh let's see swarm CPP there we go uh there's there's I don't think there's actually anything stdl specific in here which is really good actually which is what I wanted um because although yeah inevitably this the screen class is going to have have to make uh a lot of use of STL by implementing the Swarm class as separate from the screen class this also means potentially that we could even use the Swarm class in a different program so we could use a screen class in other STL programs we could also use the Swarm class in a different program that uses a different Graphics library to STL so I'm always thinking when I create these classes um can I write them in such a way that they don't depend on other classes or they have minimal dependence on other classes in my program so that they could be taken into another program that works differently and reuse there now of course somehow the the somehow we have to connect the Swarm and the uh and the screen and what what I could have done here was was I could have um given uh the I could have given the screen class some sort of method that accepts a reference to a swarm class but then I'm tying it to the Swarm class neither of them are so easy to reuse anymore well the screen class is not so easy to reuse anymore I suppose I could still reuse the Swarm class but what I did instead was um I I made swarm we turn nothing but a pointer to a load of particles and I thought well it's nice if we don't even have to have the screen class referring to particles so I made it so the screen class just has this set pixel method and then all we need is some code that Loops through the um the buffer of particles and then cause screen do set pixel so we managed to completely completely separate the Swarm class from the screen class there's there's no connection uh between them they're both reusable swarm has to know about particles cuz its whole task is to manage the particles but there's no no connection between that and the screen class there is U there is quite a lot of code in main.cpp uh if you've got a very big program you might want to try to aim for a main. CPP that's cleaner than this then we could have perhaps some sort of separate class that um that does know about swarm and does know about scream and brings those two together somehow that's just going to be a little class with with kind of this kind of kind of code in it um but and that class clear is not going to be very reusable but it's just going to be a small class containing this kind of code here so that's not so bad we've still got uh swarm and Screen are still very reusable classes uh but because it's quite a small program I I opted just to put that in the in the main function it's not too bad you can see pretty much at a almost at a glance with a bit of practice um what's what's going on here the Box blur um algorithm that was something that um that I kind of thought about and in the end I decided to put it into screen we could have had some sort of separate box box blur class or some sort of blur class that implements various blurs and uh somehow we could have tried to separate that from the screen class but I figured if I reuse the screen class it's nice to have the option of blurring the screen anyway I'm not sure there's a huge advantage in this case to separating out the blur from the screen but that's also Al something that we could have thought of instead of implementing the blur code the blur code in the screen class okay so so so that's basically it and and the kind of basic message is try to make your classes depend on each other as little as possible try to encapsulate them and try to always think could I use this class in a different program that maybe uses you know different different apis or um that works very different to the one I've got try to make your classes reusable and selfcontained with minimal dependence on other classes and inevitably you can't do that all the time but we've managed to do it somewhat at least in this program okay that's it for this tutorial I hope you enjoyed the course uh until next time oh one more thing actually yeah I've started working on an advanced C++ course and if you want um more information about that uh do go to Cave of programming. comom so until next time um happy coding