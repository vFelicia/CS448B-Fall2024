hello this is John from cave of programming calm this is a tutorial on recursion in Java several people have asked me to make a tutorial on recursion and at first I didn't want to because it's sort of an algorithm rather than in a way being anything to do with Java as such but then I reflected and I realized that in fact recursion is is considered something basic that all programmers are supposed to learn so if you're learning Java you want to learn recursion along with it so let's take a look at it here I've got a main method set up in my application in Eclipse here and let's just put a sisal in there cello works and I'll run this and it says hello now I'll define another method here I'm going to make this this other method also static I might as well make it private so I'm only going to call it from within this class in main I'll say private static void and I'll call it let's see let's just call it for a moment calculate like like this now the reason I made this static this has static has nothing implicitly to do with recursion it's just that I haven't got an object of this app class and I just want to use a method here directly from within main and if you want to call a method of a class then it needs to be static so rather than do new app and then say app top calculate or something I'm going to just make this method static here and we've covered that before of course so I can call calculate from within main of course let's put calculate in there and sis out hello and run that and this is all completely standard ordinary Java now supposing I pass a value to calculate like let's say here let's say an int value equals 4 but four and then I'll make calculate take an int value and I'll display the value here and I'll pass pass in here let's run that check it works says for now it's important to realize for the purposes of this tutorial especially that whatever we do to end value within these brackets will not affect its value here this is because this is a primitive type it's like we're slashing the value for from this variable here into this variable here which is only as a scope at these two brackets here so if I say something like value equals value minus one or something like that and then I run this yeah it'll be three within this method but down here it's still going to be four so let's run that that's an important thing to grasp now as far as recursion goes we can do something kind of interesting here which is we can make this method call itself that's what recursion is is where you call a method recursively or to put it another way a subroutine calls the subroutine so here I could say let's say well it's a sub this is out in there actually what value I can now call calculate like that again and there's no real actually need to have this inner an int here I can just put it literally there I just did that to show that it wasn't changed when we change it within the function it's not changed within this method so in called calculate and let's pass value to it so the method is now calling itself recursively and this this code is actually problematic and if we run it what will happen this will get an error and let's see if I can scroll to the top of this error it's gonna be here somewhere there it was then it says stack overflow error and what this is is when you call a method from within another method like here we are calling calculate from within main there's a special area of memory in the Java Virtual Machine called the stack and the stack is used for local variables and for remembering which method called which method so we know where to return after the method is we call this use after the matter this call is used for stuff like that that's distinct from the heap and the heap is an area of memory which is where objects are allocated when you use the new operator so the stack is a relatively small area of memory that remembers function calls and local variables and stuff like that and here we're getting a stack overflow error because we called this function infinitely we call this within this this calls this which is this and it's calling self again and it kind of goes round and round in an infinite recursive loop until we get this stack overflow error so that's no good but we can this is legitimate if we provide some way of this this method to stop calling yourself at some point so a problem with recursion in a reason why it's not advisable to use it too much is precisely the danger of stack overflow errors if you call a method from within a method too many times I don't know how many I'm guessing tens of thousands then you'll get a stack overflow error and for that reason it's better to avoid recursion but are some situations which we'll look at in which it's very very useful to use a recursive method so and what we can do it here is we could put an if in here like say if well actually actually before I do that let's let's do something slightly more interesting let's call calculate on value minus one instead and what's going to happen now is you see we've got the same error again unsurprisingly but every time it printed out one less than a previous value until we got about 10,000 of them before we got the we got down to minus 10,000 before getting the stack overflow error so calculate initially has the value forty displays and then it calls calculate with the value and minus 1 which is 3 so then we end up coming in here again and the second time it prints 3 and so on but now the interesting thing is it's possible to stop the recursion because I can say something like if value equals 1 then or maybe even it's yeah let's just do that actually if value equals 1 then we can say we turn 1 like that oh yeah we're not returning anything at the moment let's just say return like that and then if we run that now prints 4 3 2 1 so we're coming in fine and it's calling calculate for values greater than 1 but when it gets to 1 it just returns so we've got one method calling another method what's this for 4 times I suppose yeah because we call calculate initially with 4 and we get this and calculate calls itself 1 2 I guess three times now we could we can do useful stuff with this and one classic example is to calculate a factorial value a factorial value is if you take for example e top let's say example eg the factorial of 4 which we write like this four exclamation mark that's not programming terminology or anything that sir that's some mathematics terminology for factorial I think you're right it like that or is it is it like this I think it's like that it doesn't matter anyway 4 factorial is equal to 4 times 3 times 2 times 1 or little 1 obviously doesn't matter so the factorial of any number is equal to the number multiplied by all the numbers below it so to speak leaving out 0 because if we multiplied it by 0 at the end we just get 0 of course and this is this is very useful in probability theory example so this is called the factorial factorial for in this case so the factorial of any number is just this now we can calculate that using a recursive function because what I can do is here and say let's our return value let's make this int and here I'll say if the value is 1 we'll stop by just returning 1 but otherwise if the value is something greater than 1 we'll say we'll call calculate itself on value minus 1 but we'll multiply the return value of that by value itself and we'll return this this is getting a little bit more complicated now and you'll have to think about this probably a little bit unless you're cleverer than me to get your head around it let's listen excuse me let's run this again and now what I can do is I can print out return value actually here so here and let's run this and now the factorial of 4 is 24 and I can let's I can also rename this to factorial which might be might be handy by like this so now we've got a function that calculates the factorial its rename this as well of any number passed to it factorial 5 or whatever and to see how this works it's um it's probably going to help if you just think through what it does for small values so if we call this this method here I'm using my function and method interchangeably it's a method because it's part of an object but you could also call it a functional subroutine if you like I'm so routing programming lingo function is more a mathematics lingo but it's all good so function takes in usually a number and returns a number and and let's say we pass in one what would happen is we'd come in here and it would say is value 1 yes return 1 so this would display 1 we pass in one here we just get one like this if we pass in two what happens is we come in here with the value two and says is the value one no it's not so it doesn't do this it comes down here and it calls factorial on one in other words 2 minus 1 which is 1 times 2 so we're taking 2 here and multiplying it by factorial 1 2 times 1 is of course 2 and so that this the factorial of 1 will just return here we'll just get 1 so if we call it with 2 here it's 2 and doesn't execute that execute this that's 2 this will end up being 1 so 2 times 1 and is why is returned in the end from that from the function and that's factorial 2 is 2 I don't if I sounded hideously confusing or helpful but either way I'd advise just going through this logic for yourself imagine what this will do for the value 1 and n value 2 and and so on I'm not sure what factorial 0 is actually are probably it's defined as 0 we might want to think about how to define factorial 0 but this will do to all these stray recursion and if we pass in 3 it's going to do 3 times 2 times 1 so we've got an extra step to it comes in here and it says ok 3 times whatever factorial 3 minus 1 is Miller is factorial of 2 and then it so it's coming in here at second time saying ok we'll do 2 times whatever factorial of 2 is and all these values get stored basically on there on the stag and the end result is you're calculating factorial 3 I think once you once you've got your head around what's going on when you passing 1 and when you pass in two it starts to become fairly clear what will happen for 3 and 4 and 5 and so on and you get the idea you could spend days thinking about this until you you're understanding is as great as your understanding is of you know pulling out a chair from underneath the table but it's probably not worth it that degree of clarity you'll get the idea if you just look at a few small values of this and so this this is a classic example where you use recursion the important thing to remember with recursion is always always make sure that it's going to stop somewhere and don't try to make it recurse thousands of times stick with small numbers otherwise you could get a stack overflow error another classic example where we use recursion is let's take a look is if you look up the towers of Hanoi puzzle towers of Hanoi there's a there's an explanation of this on Wikipedia this simple game which looks complex and intimidating at first was actually relatively simple and the towers of Hanoi puzzle is you have these disks on these rods and you've got to move the disks by moving one disk at a time onto another rod and you're only allowed in you're not allowed to ever put a bigger disk on a smaller disk and their puzzle is to move the tower from move the entire stack to another rod one disk at a time obeying these these rules and if you look down here somewhere we've got an explanation of the recursive solution and although this looks a bit intimidating it's actually in some ways easier to understand in calculating factorial I find and work where recursive algorithms really shine is if you can see what to do for one step of this puzzle then you can use a recursive solution that applies that step over and over again and solves the whole whole puzzle in a very elegant manner with surprisingly little code it's better to loops in general than recursion but in this case using a loop would be actually quite hard to figure out mentally where is the recursive solution that turns out to be pretty simple you're kind of looking at the end result and saying okay what would I have to do to get to one step before that end result whether all that all the tower is being moved and create a writer method that does that and then say okay we can use the same method to get to one step before the the solution that's one step before the final step if you see what I mean there if you can solve there the second to last step or I guess it will be the last step then you can solve the second to last step in the same way and the third to last step and so on just by using a recursive method so if you want practice with recursive methods try to calculate a factorial and then I would say come to this Wikipedia page and see if you can implement a recursive solution for the towers of Hanoi puzzle and actually that you also need some way of representing these disks using maybe a Java collection class or something or if that's too complicated don't worry about it because the most basic thing that you need to grasp first is just calculating a factorial or something like that and when you can do that you basically grasped recursion so and that's it for this tutorial I'll put this code as always on cave of programming comm and if you go to WWE for programming comm there you can find lots of free videos and simply articles as well and some free courses and lots of other courses that include free videos you can just click on this and ghosts look straighter some free videos and the source code for this is going to be if you scroll down to the YouTube videos section you'll find it under the appropriate and while this is actually going to be in the basic Java video tutorials and you'll be down here somewhere when I get around to adding this source code click on a page in this section and you'll find the source code so that's it for this tutorial and until next time happy coding