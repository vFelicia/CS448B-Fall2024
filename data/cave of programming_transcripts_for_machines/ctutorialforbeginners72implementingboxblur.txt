hi this is John from Kenya of program comm and this tutorial can take a lot at blaring the screen and a particle explosion program so if we run this in a moment we've got an explosion and it's circular and it should happen at a similar speed on any computer although on slow computer is going to be jerky and in this tutorial we're going to look at adding a blur effect which will make you look a lot nicer and a lot more like some kind of weird natural phenomenon than it does at the moment if you are finding that this program is already jerky on your computer one thing to do is make sure that you compile the release target so in Eclipse that's project build configuration set active release because the release versions of programs which are not set up to use the Eclipse debugger or Visual C++ debugger which we're not using anyway and we haven't used a they run faster than debug programs if you've got a really old slow complete computer then you might get very jerky results with this very expensive blur algorithm expensive in terms of CPU time but let's have a go at it anyway and see see how it looks so I'm going to go to my main dot CPP and in main dot CPP we were actually at one point clearing the screen and I'm not going to clear the screen anymore I'm gonna get rid of this what we're gonna do is blur the particles out every time this loop iterates we're going to apply a blur so a particle will leave a blurred trace behind it and at the moment now if I run this which is see all the positions of all the parts of course as they go along I'm not going to be a race so it was quite horrendous but it's going to look good when we apply the blur I stopped going to implement a method which were going to call before updating the screen before displaying the results of that plotting the particles which are called screen dot blur let's call it Fox blur there are various ways of blurring the screen doing glare algorithms or so on photographs from that matter in photo editing software you can use that Gaussian blur which is a kind of naturallooking blur but we're going to use a thing called a box blur which is very simple to implement and this is going to be the most difficult bit in some ways so the whole tutorial is going to take a while to explain this but it will give some really beautiful effect at least if your computer is fast enough to display it reasonably quickly yeah box box blur there are various ways of implementing it and I'm gonna just implement it in a kind of common sense sort of way I'm gonna explain what you want to achieve I'm gonna just coat that but if you after seen this video if you do long internet you can find various ways of optimizing box blur to make it run faster so if you don't have if you do experience speed issues with this blurring algorithm there are ways of optimizing it and making it faster and you can find that by searching on Google quite easily there's a number of pages that I explain that let's go to screen door age and add this the prototype for box blur as a public function yeah and public a third go to scream dot cpp and somewhere in here and let's go ahead and implement this let's say void scream box blow now what i want to do here is instead of drawing the screen directly i want to look at look at the screens it is with pixels on it and in calculate a new screen with blurred values for all the pixels so i can't apply this algorithm to the screen pixel by pixel because we'd end up confusing the value calculated for one pixel with the volume is calculated for the last pixel we we can't mix up our workings as we're going along what we need to do is create a whole new scream and pixels and put our calculations in this second screen and then draw that second screen so in screen knowledge we've got a we've got a buffer somewhere here so we've got this buffer and i'm gonna create a second buffer so that we can look at one buffer and put our calculated blur results in the second buffer so let's let's copy this line and i'm going to call this buffer 1 now the buffer two so now we need to go to screen lock cpp look at the syntax errors now and wherever we got buffer m under Scott buffer we need to have buffer 1 and buffer too so here I've got buffer 1 and we also need to initialize M underscore buffer to norm and scrolling down here this is where we're actually allocating the buffer so I'm going to copy that line and we're going to allocate but for one and got four to hear what clearing the buffer getting rid of any garbage in the memory verse so now we want to do with buffer 1 and what for this is the screen play function which we're actually not going to use but just for the sake of completeness let's add buffer warning before yeah I actually since we're not gonna use this function that since I'm not sure anymore exactly what it should probably do we probably better off just getting rid of this let's get rid of the screen clear function because I'm no longer sure what bit you would want to clear or why in this program so let's clear it let's get rid of it continuing in screen dot CPP this is where we're at in set pixel this is well at plotting pixels so I don't want to plot the pixels to the second buffer only to the two buffer one so I'm going to change this to buffer 1 and similarly when we update the text here with the results of the pixels in the buffer I'm gonna just use buffer 1 now and finally we need to remember to delete the buffers so let's delete buffer one until you before now if we go back to the box blur implementation so I want a copy from one buffer and write to another and the buffer that I want to write to is buffer one because it's buffer 1 that were then going on to draw on the screen but at the moment all the pixels are stored in buffer 1 what I'm going to do is is I'm going to stop and I'm going to swap the pointers so buffer 2 points at work before one originally pointed out and then we're going to copy from buffer into buffer 1 now a naive way of doing that would be to say and underscore buffer 1 equals M underscore buffer to a spot common yeah it's what the buffers so big solve info is in prefer to and we are drawing to M underscore buffer 1 so a naive way of swapping this would say mmm Scott before 1 equals M under scope of the 2 and M on Scott before 2 equals M underscore before 1 the object here is to point before to at whatever memory buffer 1 was pointing at and to point before 2 or whatever memory but for one was pointing at how I set back the right way around well hopefully you understand what I mean but problem is this isn't gonna work as we directed but for once pointed or for to I known was setting buffer to 2 pointer the redirected or for long so these now both point to the memory that's pointed at by buffer to what we need to do is have a temporary variable in here so these buffers are of type you int pointer you in 32 points up I need a very book called tempio such a pointer and I'm gonna say 10 equals M on the scope are for 1 so we've stored the location that buffer 1 was pointing out then I'm gonna change before Wang 2 pointer the buffer to memory then I can change before to 2 points at the stored original value of before Wang which is now intended this is very common the thought designing pattern in computer programs where you use a temporary variable and use it to swap two values and in fact I think we've even seen it before in this course when we were reversing a string we've seen a similar probably we've seen a similar idea I can't quite remember so let's check this we've got temp at buffer one before one is then pointing it before too but for two points of ten so we've swapped the areas of memory around now what we want to do is iterate through all the pixels look at buffer two which now contains the pixel information that's been written into it and do some calculations to create the blur effect and copy it into the buffer one which is now a clean buffer and then we can plot those values on the screen and we're not gonna erase any of the buffers in between iterations of the game loop here what we're gonna do is were we're gonna keep blurring the same screen more and more so when we when we draw a screen will blur whatever was on the screen previously and then well we'll take one of us on the screen previously draw the pit new pixel on it and then blur it so every time we draw the screen and the stuff that was on it previously will get more and more blurred only the new stuff will be comparatively sharp and that's going to give us some beautiful trails on our pixels that will blare out more and more as a pixel moves along a bit like sort of comment training it's sort of fighting tail that sort of expands as a comment goes by or I imagine it does so now that's iterate over all the pixels so let's have a loop here for int y equals not y less than screen screen height y plus plus and within that we're going to go over all the pixels in this particular row so 4 into X because naught X less than screen width X plus plus and by the way I was thinking of implementing a get pixel function but the trouble is we've got this problem that we have to get the pixel from one buffer after and sort of right into a second buffer so it's not like we're getting set in pixels on the same buffer so I'm just gonna implement the get pixel stuff using a bit shifting stuff that we've seen previously in this function here directly in here to get the colors of pixels from what is now buffer to and then right and using set pixel into before one now within this we've we've got we've got particularly side enta pfizer particular pixel so we've got a particular pixel but surrounding that pixels are eight other pixels so you can even think of them as lesson zeros they look a bit like this so we're looking at this pixel in the middle here but around it are a bunch of other pixels and we want to what we want to do is we want to add up the color values the red green and blue values in each of these pixels that's a total of nine pixels then divide the results by nine and plot that result back into the pixel we're interested in setting here so the color values of this central pixel which which is a location X Y will become an average of the color values that all of the pixels around it including itself and that's what creates the box blur effect so to iterate through all these nine pixels we're going to have yet another nested loop in here so for int coal or I could use a short or something by I use int because we've got enough memory here for int let's say I say Rome put into Rho equals minus 1 Rho less than so we'll do this loop while the Rho is less than plus 1 Rho plus plus and we're going to add this value which ranges from minus 1 through 0 up to plus 1 we're going to add that to our X&Y actually to the Y position for the row and that will give us this row 4 minus 1 this row 4 0 and this row 4 plus 1 and within that we'll have another nested loop for int Col equals minus 1 while Col is less than Walton sorry I should have said they're less than or equal to 1 because we want this to go minus 1 naught 1 Michael is less than or equal to 1 call plus plus and now we can calculate and develop the coordinates each of these pixels in this grid let's call this int we can call it like pixel X or new X or current X or something let's call it current x equals x plus cold and in current y equals y plus Rho so if you think about it and what we'll end up with here are well n we'll end up with for every pixel that we look at every single pixel on the screen will end up examining will ever iterating through all of the pixels in this grid of mine pixels that surround it including the actual pixel itself crop for when Rowen collar both 0 sis current ex is done a range over all of these pixels one by one if you think about it now we want to get the that color values on these pixels and add them all together so I'm gonna have outside of these this inner loop that iterates over the grid of pixels here but within these outer loops that iterate through each of the pixels in the screen I need to have some color values that can tote a lot and these color values are going to end up being more than you could store in an unsigned char because we're adding up the values from nine pixels so I'm gonna have here at int let's call it red total I'll set it equal to naught in green total equals naught an int blue total equals naught now we need to get the color of the pixel at this location and add up all the separate components but because we're iterating over all the pixels in the screen is possible that this pixel could be off the edge of the screen because if we start with pixel x equals north y equals north then we try to get pixel that's to thee let's take to the upper left of it for example that pixels not on the screen so we need some way of ignoring pixels he about off the edge of the screen so let's say here if current X is greater than or equal to 0 and so we want a logical honor to C++ use to an science and also we need to say that the current X must be less than the screen width because the maximum interest we can have is one less than the screen width because we start numbering in zero and we've got screen with number pixels this is an array so we need to make sure that X is between these two values and also we must have currents Y is greater than or equal to naught and as well currents y must be less than screen height and if so we can go ahead and get the color value of that pixel and by the way in C++ the way these fans function or ORS for example is that the computer will go through each of these clauses and for animals for example each of all of these must be true to make the condition as a whole true when to execute the Earth Day they have to all be true because we've handed them all together and so if it goes through it or stop checking them from the left and as soon as it finds one that's false it will stop going through all of these and it won't bother doing the rest because this is no need as soon as you find the false one it's going to check all of these and it's only going to do that if if every one of these conditions in the air that we've handed together are true as because we've used the logical animal let's get the pics of Conover so I'm going to say I'll use the STL type new in 32 which means that unsigned integer that is guaranteed to be 32 bits normally it means is 32 bits but it's not guaranteed can be different on your machine as possible so you in 32 color equals and now we need to access the buffer that contains a pixel information which is now but for 2 because we swapped it with baka one so we need to say off an underscore buffer to and formula is it's why sorry not why but current y x screen with that's the number of rows down that we're going plus current X this is how we get from x and ycoordinates to an index within this array which again you have to think about it a little bit the first time and see it but then you see that this does work so that guess is the color and now we need to get the red green and blue components out of that color so that we can sum them all together so you wouldn't be any good to summing up all the colors and then dividing by nine to get the average color because well if you think if you just think about it carefully you realize that it wouldn't work it takes a bit of thinking about but in fact that just doesn't do the trick at all we need to we need to actually go to the trouble of getting out of the individual red green and blue components stunning them separately and dividing them by nine separately so let's take a look the screamed I know not scream let's take a look at set pixel actually because in that we see other color information maps to an integer we see that when we valley red here and then shifted red a byte along to the left and then green in and blue so the way it works is we've got a alpha value I think yeah because I know that blue is also shifted right at the end though so I think the format here is we've got red here green blue and then alpha which is a transparency that we're not using so the red if I've got this right is shifted three bytes along to the left in this and this thing here so as we start off putting it right there and then by the time we finish we've done one two three shifts which is 24 bits three bikes to move it three bikes over whoops to the to the right hand side there do we do my typing there there we go so to get the red value out what we can do is let's go back to the box blur we can say here what again we use the STL type u int 8 which is an 8bit unsigned 8bit int or we could use on sign char it's the same red equals color and we need to write shift the color by 24 bits to get the red value if I've got this right and this is this is tricky to get right every time i implement it I do something wrong and then have to think very carefully over what I've done putting in see out statements to check that all the different values are what they expect or what I expect them to be but I'm hoping that I can get it right this time so now to get the ewings 8 green value that was only shifted by 16 bits in the color and he wins ADEs blue is just shifted by 8 bits and the last value minute color is the red value so he I just shifted 8 after I put the blue on I only shifted it by 1 by 8 bits to the left so if we shift the color by 8 it's this way and then take the last two digits of it and in fact in hexadecimal we've got a blue value as we saw in in a previous tutorial now we can say here if we get if we get a valid pixel that we can get color values out of it we're gonna say red total plus equals red green total plus equals green blue total plus equals blue now we've summed up all these values for a box surrounding this pixel here at X&Y and we're going to go after this loop that iterates over that grid at nine pixels and now we can say you int 30 you in eight this is going to be the actual color that was set pixel to red because red total divided by nine is there in nine pixels in that grid you insane green equals green total divided by nine you in eight blue equals blue total divided by nine we've used red up here but there's no problem using it here as well because remember variables scoped to the innermost pair of brackets where they're defined so yeah these these colors they only exist between these two brackets here these variables then we use them and then we discard them basically similarly these totals here they're stoves to these brackets that actually define the business of checking one pixel think you should be there I've got that right yeah so that they're defined to the inner most set of brackets belonging to the four loops that actually check one individual pixel and then from the next pixel these are really close so that completely reset okay so now we've got that we can use our septic so which remember sets in to buffer one but we copied the the last lot of pixel information on the screen to buffer to we're reading from that and plot and banked but for one with set pixel which will plot the results of their on the screen and next time you go round round the game moved in main dot CPP will blur that same buffer again after plotting the new pixel on it so it'll get more and more blurred as it goes along for any given particular pixel trail which is what we want so let's say set pixel XY red green blue now if I've got this right it will work and if I haven't it won't and let's try this let's run it I don't know if I've forgotten anything yeah so yes it works now this doesn't look too great at a moment when it expands a bit like this starts to look kind of cool especially if you look at the pixels on the outer edge the reason it doesn't look as good as it does in the final program is because we still need to tweak the behavior of the pixels we've got big sort of solid white bunch of pixels there it won't load a solid color and we want to do some things like making them move in a more interesting way and trying to make this circle more ragged as well which we can also do so we're going to look at that in future tutorials but I leave it there for now so again I'd encourage you to have a go at that if you really get stuck and you can't get it to work and can always copy my source code here and try to examine what you've got different to my code um I'll make this code available wherever the lectures available on my website on YouTube I can't attach the source code it will be on my website if you're watching on udemy.com it'll be attached to the lecture if there's some other system I have this video on that only allows you to attach source code at the end of all the lectures than out attach it to the final lecture but it will be there somewhere except on YouTube where you can attach files but it's this is this is very tricky but if you can get your head around this or even 90% of this and if you can get it working more to the point then you've really done something quite amazing took me a long time before I could get the hang of blur algorithms like this this is pretty advanced C++ really you have to think hard to get this to work so I miss challenge but it's a it's worth having having it go out so we'll look at probably changing pixel motion a bit more in the next tutorial but we've almost come to the end of this now we've almost got a final program pass them until next time happy coding you