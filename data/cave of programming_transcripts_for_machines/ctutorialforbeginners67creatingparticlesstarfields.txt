hello this is John from Cave of programming. comom in this tutorial we're going to take a look at creating particles um represented by pixels that we can plot on our screen so at the moment I've got this uh window which just displays a block of color and slowly Cycles through um different possible colors uh so I'm going to use that later on I'm going to save that code um for a while but what I want to do now is Define a particle class and display those particles on the screen so let's let's go to eclipse and um let's create a new class CL here so I'll right click project go to new class and I'll call this particle and I I'll keep it in this Cave of programming namespace um I I don't know if I'll need a Constructor and Destructor but let's let's define them because there certainly no harm in having them let's click finish um I'm also going to Define another class here which I'm going to call swarm and swarm is going to manage a collection of particles so let's um again I'll give it a constructed Destructor I'll call it swarm and put it in this Cav programming Nam space again so we've got two new classes here now let's go to particle and let's start thinking about what kind of properties a particle will have so we're going to Define some private instance variables here and um I suppose the most fundamental uh thing about the state of a particle is that it needs an X and Y position on the screen and now I'm going to make these double so let's say double and I'll call this mcore x m to say mcore to say that it's um a member variable just to make that clear although that's that's certainly not um absolutely necessary and let's have a Double mcore Y now the reason I'm making the double is because even though on on the screen um we're dealing with individual pixels so the X and Y location are always uh always integers I want to be able to change these values gradually and um then just sort of round them off to the nearest pixel position so if if I want to change for example the x value gradually by adding some small number to it like .01 every time the screen refreshes of course I can't do that if it's an integer so although we have to display it at kind of an integral position at a particular pixel it's its position um may be um maybe somewhere between two pixels we just kind of round it off uh to the nearest pixel when we actually display it but having a double position allows us to move it conceptually bit by bit so and that avoids having to move it by an entire pixel every time we move it um so we can achieve more of an illusion of smooth movement uh so we've got um X and Y that's that's probably all we really need to to start with just an X and Y position for the particle as far as I can think um at the moment let's go to the particle Constructor here and um in the Constructor I could initialize the X and Y values really so yeah let's let's maybe do that what I'm going to do is I'm going to include standard libh standard li. because I want to use a function called Rand like that and uh Rand returns a random number between not and a constant called randor Max so uh this this returns an integer and this is an integer I believe so this division would wouldn't really make any sense but if I multiply Rand by a double or if I cast it to a double like that this will then return as a random number between note and one now what I'd really like to do is um i' I'd like to have the particles kind of move within some um some virtual space but I don't want that virtual space to be tied to the screen dimensions because then if I change the time the if I change the size of the screen or something then um the way our our program works has fundamentally changed I want to have the particles move around in some space of a fixed size some mathematical space and then we'll map that later onto the screen so I'm going to initialize the exposition of the particle to somewhere between let's say arbitrarily minus1 to + one so we can imagine that the particle inhabits a plane with uh cartisian coordinates if you've ever done any maths were um the X minimum X and Y coordinates are both minus one and the maximum possible X and Y coordinates are both plus one and if if you've never studied C cian coordinates you might want to just have a look at a page on them you know just for uh sort of 10 minutes or something just to get the idea but they they're relatively simple so um if I set um this is going to set x equal from equal to something from n to one but I want it to be from um minus one to + one so let's let's firstly maybe work on the Range there so if I multiply Rand by 2. not so now we don't need the cast a double because this bit is is a double now let's we could put brackets around that just to be doubly short so to speak uh so this should give us a number in the range not to plus 2. not and if I then subtract one from that I think I'm right in saying that we've now got um a range of minus1 to plus one so for first firstly I increased the range there so that instead of being not to one it was not to two then I subtracted one which gives us minus one to+ one if I've if I've got this correct what's the U warning there bad character sequence sometimes I find this happens and I think I'm somehow typing um invisible characters that it doesn't like I'm not sure how but yeah that that's fix that I just had to delete sort of underlined the space there and I just had to delete it and and put the space back in again maybe I hit the ALT key by mistake or something but it doesn't seem to stop it compiling though let's let's do the same with um with Y as well so let's set y equal to some random number from minus one to + one so that's our particle covered now usually what I do is I would um Supply like a get method for X and Y but we're going to have to deal with lot of particles and we're going to have to get X and Y values over and over again every time the screen refreshes for a huge number of particles so perhaps it's better to Simply um to Simply make these values public and access them directly that breaks encapsulation but um we're forced in games and simulations and things like that often to uh adopt a programming style that's not ideal for the sake of efficiency so it might be better to make this public an alternative thing that you you often see done is instead of explicitly declaring this as public what we could do is by default in a class if I write it like this these will be private by default but there's also a thing called a struct in C++ and if I just change this from a class to a struct the only difference between a class and a struct is that the members are public by default so um if I do this then we know that the intention is to access these directly and that they are now public so maybe I'll do that so that's the only difference between a class and a stru and that's the sort of thing they ask you on interviews as well is that by default in a class member variables are private if you don't specify an access modifier and instruct they're public by default and I'm just making them public for the sake of efficiency although ideally we wouldn't do that so that's my particle covered um I also need to initialize this random number generator because I I think it return as far as I know it Returns the same random numbers in sequence every time and I'd like it to return different ones every time we can do that by going um for example to main here and um if I include here include standard lip again standard li. H and um using namespace standard um I've missed out there D there then I can call a function here called srand and uh srand seeds the random number generator with a number uh which makes it produce a different sequence of random numbers every time and uh to for the seed number so I need to supply it with some number to seed it with I can use a function called time which is found in time. H I think but it's probably already included so we've got stlh there's no harm in including time. H if it exists it does kind of change its name from uh implementation to implementation uh let's just check what the error is here so um there's something there it doesn't like I'm just going to check um the program that I implemented previously in case I've got this slightly wrong somehow let's just check where I seeded my time so somewhere in here I should have seeded my um random number generator oh yes there we go ah yes so time the time function takes null um it it can return the time into a struct that you pass it if I remember rightly and this this might be wrong so don't take this as gospel uh but we don't want it to do that we just want to we don't want it to return anything other than um the number of um milliseconds I think it is since 1974 or whatever it is something like that to be honest this is one thing that I've got so used to typing that that I've um stopped wondering what it actually does let's let's close some of these no but um you can certainly Google for that if you're interested but basically this formula here seats our random number generator okay so let's let's leave that um and go back to our our program okay I'm going to close everything actually so that I don't get confused and open them again here so that's that's not even the right program here we go so particle. H um Okay so we've got our particle now and um now I want to class that organizes the particles because we're going to have to deal with a massive load of particles and um I I'd like some class that can organize them all so um I've got my swarm here that I've created and uh I'm going to give this a private member variable here let's say that it's uh well if I include here if I include um uh double quotes because it's a local include file particle. H and I'm I'm I'm using this C programming namespace then I can say in here particle pointer let's call this mcore P particles uh M because it's a instance variable p because it's a pointer then in my Constructor here let's go to swarm dot um CPP probably this is a reasonable place to initialize this let's set that equal to new um new particle array and how many particles do we want well I can define a constant let's call the constant n particles and uh let's go to swan. H and make that a I'll make it public just in case we need to use it outside of swarm yes we probably will in fact let's say n particles and let's make that a con static int and set it equal to some number like um 5,000 you might want to make this lower if your pro if your computer's a bit slow but if it is you'll find out later on but let's let's try um 5,000 to start with so we're going to have 5,000 different particles and now we mustn't forget in swan. CPP in the destructor here we have to delete mcore P particles and because it's an array we need these square brackets so mcore P particles so now we've got a load of particles there so this is this is going to all at memory and also fill that memory with a bunch of particle objects and when the particle Constructor for each particle runs it's going to assign a different like random location to itself now I I also want to be able to get particles from my swarm so I'm going to go to swarm Doh here and create a public method which returns a particle pointer and we'll call it um I could call it get particles or even just particles sometimes it's nice to emit the get um but perhaps get particles would be clearer let's call it get particles and I'll actually implement it here in line because it's only going to be a small function so I'll implement it in the header and we'll just say return mope P particles now we should think about conate here um this particle's pointer we don't want to point it to anywhere else ever once we've U once we've set it equal to something in our Constructor so why not make it a const pointer to a particle and when when we actually return it we we want to make sure that um the the the when we actually get this pointer outside of this class we want to make sure that it it can't the particles that it points at can't be changed we only want to change them uh possibly within this class or within the particle class itself so let let's say that this returns a cons pointer in other words a pointer that can't be made to point anywhere else to a particle that's const so a con pointer to a particle that's const so the particle can't be changed either using this pointer that's returned let's try that let's just build this thing um and see if it builds so I've got um an error here oh yes because um I um signed this in the in the Constructor um maybe I can't really make it const because I I have to change it at least here so yeah that's that's a shame but I don't really see a clear way around that so let's get rid of this const actually because sorry not that one this one because otherwise we can't even assign it in the Constructor okay let's let's try this so I think I think that looks good now let's see if we can actually draw these particles um so let's let's go to main.cpp and uh in main.cpp I'm going to declare a swarm somewhere here uh let's declare a swarm swarm I'll call it swarm so that the class has an uppercase s that's the convention I'm following and I'll make the actual object the same name with a lowercase s some people hate this uh convention but I quite like it we've only got one swarm here and my classes all have an uppercase letter so uh the object can just have a lowercase letter there then uh in my in my while loop here I need to get a pointer to all the particles I want to draw before I do that let's let's comment out and some code here let's comment out the stuff that displays that um um puts the colored block on the screen we're going to use that later so I just comment it out for the moment with a multiline comment here SL star star slash uh and we'll use it later now that should hopefully give us a black screen and hopefully it shouldn't crash or anything um let's not continue cuz we've got an error there so I've got unused variable elapse but that's um that's just a warning we can include that in the comment we've also got a error unknown time unkknown type swarm and that's just cuz I got I forgot the header so let's include here swarm Doh let's try building it again see if it builds this time whoops build project and yeah it looks it looks fine now let's run it and we get a nice black screen okay so now let's see if we can plot that collection of particles with their random positions so they won't move at the moment we can maybe do that in the next tutorial quite exciting but we can at least plot them so we have something that looks like um sort of like stars so what we need to do is um we need to Loop through all the particles let's say for in I equals n i less than swarm colon colon n particle that's the number of particles I ++ uh before we do that actually we need to say uh particle well it's actually const particle pointer const So reading this backwards con pointer to a particle that's con um call this let's call this P particles equals swarm doget particles I don't use the class name here by stake we need the the object that we created there need to put that that semicolon in the right place then we can we can get each particle so we can say particle particle particle let's call it equals um P particles brackets I we could call that P particle to EMP emphasize it's a pointer um but um um I'll just call it particle I think so we've got we're getting the individual particles one by one and now we need to just plot them on the screen using that position how can we do that well we're going to have to map the particle space um which goes from minus one to plus one on both X and Y to the actual screen space so if we get um let's say n uh let's call this x equals particle dox now what what do we have to do to X the particle X from minus1 to + one to map it to a location on the screen well the first thing is we we don't want it to be negative so let's add one to it um because that will make it range instead of from minus1 to+ one now it'll be from n to two uh and let's let's surround that with brackets and then if we multiply this by um so if it's ranging from n to two if we if we multiply it by half of the width of the screen it's going to range from not to the screen width it has to be half because we're going from not to two uh so if we multiply two by half of the screen width we get the screen width so let's try this let's say multiply it by um I think we can use the constant from screen screen width I I think that that should should that should work um yeah so we we we add oh yes it's actually not X but mcore X so we add add one so that the x is from not to two and multiply by the screen width I think they should do the trick that the disadvantage of this actually would be that um position note for the particle so note + one would be yeah multiply by half the screen WID sorry if if the position is at particle not we'd like that to be in the center of the screen but does that actually work so um the EXP position of the particle is not add one it's one multiply it by half the screen width yes I think it actually does work I think this might actually work let's let's try it let's also get y in the same way so int y y equals particle. mcore y plus plus one to make it go from n to two instead of minus1 to + one multiply it by half of the screen height so screen height divide by oops screen height divide by divide by two and then hopefully we you'll have we'll have the Y ranging from not up to the screen height now one question in my mind is here um could the if if if the particles act actually at one then isn't it going to end up actually at um the screen width if the screen width is 600 it's going to be actually at 600 we don't we don't want that because that's actually off the screen because um the the pixels in the screen start numbering at zero so if you go up to um screen width let's say then it's actually off the screen but for for our purposes here um it doesn't matter too much because we've implemented a set pixel function in screen. CPP which actually checks let's see set pixel is in here oh yes we we haven't actually done any checking but we could make this check and make sure that it doesn't plot a pixel that's off the edges of the screen um I I think this wouldn't plot pixels off the edges of the screen because um Rand divided by rammax would have to actually return one for that to happen well yes that probably could happen actually let's take care of this problem uh rather than agonizing over the exact possible pi pixel values of particles let's simply make set pixel refuse to plot a pixel off the edge of the screen so we can put a check here this is in screen. CPP and set pixel let's say if x is less than not or X is um greater than or equal to um screen width or Y is less than n or Y is greater than or equal to screen height then instead of plotting a pixel we'll just return like that so we'll only plot a pixel if it's within not screen width minus one including screen width minus one or Y is y y also has to be um greater than not and it has to be less than screen height so I think I think that's good now this this is inefficient if you if you really needed to squeeze a lot of processing power out of your computer then you would uh maybe want to think more carefully about exactly what you were plotting on the screen and possibly not do this but um this used to be something that people bothered about more in the early days of games programming when computers really struggled to produce uh anything that looked good at all um but now it's it's a lot more common to have some kind of clipping as we call it on the screen just to make sure that if you try to plot something over the edge of the screen um that it just it won't plot because otherwise if we didn't do something like this plotting a pixel off the edge of the screen could easily crash your program so although this is very inefficient checking this for every single pixel that we plot um maybe uh it's not a bad idea here I think our program will probably still run fast enough well I know it will on this computer and it saves us having to really agonize about the exact values of pixels that were're plotting so um let's let's go back now to main.cpp so now we've calculated the positions of the particles they might be slightly off the edge of the screen one pixel off the edge but we don't have to worry about that anymore now we can use screen do set pixel and we can put the X and Y positions in there and for the colors for the moment Let's uh well we could use these rather nice colors that we've calculated here let's just make them white for the moment though to maximum 255 for red green and blue so that it's easy to see them and let's finally run this and see if it works here's the moment of truth and then indeed it works and we've got sort of star field it doesn't really look like a Starfield it's a bit ugly but we're going to make it look a lot nicer later on one last little thing that we could do here which might be nice would be to uncomment these colors get rid of the stuff that draws uh that fills in the entire screen here and move this above where we're plotting the particles format the code and then use those colors to red green and blue to draw the pixels let's try this and see how this looks so it's not going to look very pretty but you can see we've got a load of stars if you got a good imagination and you might be able to tell uh from this video that they are in fact slowly changing color okay so that's it for this tutorial very long tutorial uh but I wanted to get to the point where you could actually see something new in the next tutorial what we're going to do is we're going to animate these particles uh so even more exciting and we're going to get them moving around the screen so until next time happy coding