hello this is John from Cave of programming. comom in this tutorial we're going to take our um very minimal sdl application here and we're going to set it up so that it produces a window um just a blank empty window on the screen which you can close by clicking the cross in the corner so the way the way I put this together originally was by searching for sample code on Google I searched for stuff like sdl tutorial and I found a tutorial that did the beginnings of what I want I found several tutorials actually which was to create an sdl program that runs in a window and does uh pixel a um actually accesses the pixels does pixel manipulation pixel access and uh then I I took out the the basic bits of that tutorial bit by bit so first I worked on getting a window on the screen and then I worked on um setting pixels on that window and so on and I proceeded from there so uh that's the strategy I'd recommend to you and especially uh if you've got if you got if you want to create a program that does something that you're not sure if you're going to be able to do like create a sound for example then it's it's really good to look at some tutorials some first put together and really minimal tutorial that makes a sound so let's let's get started with this the first thing I need to do here once I've initialized my program correctly is um use a a function called sdl create window to create a window let's get rid of this init succeeded thing so um I'm going to type here uh we need a an object of Type sdl window pointer which I'll call window and we're going to create that by using a function called sdl uncore create window paying careful attention to the capitalization there now the first argument to this by the way if you're using a newer version of stdl this could have changed but you can easily look up information about these functions or flat matter look for more recent tutorials for example um if I hover over this uh we actually get some documentation at least in this version of eclipse about the function uh we get we get more if we actually don't have a syntax error there um and you can also just paste it into Google and you'll find the official sdl documentation plus a load of tutorials as well so um it's it's really handy to do that so the first the first argument here is um it's the string it's just the title of the window so let's call this particle fire explosion second argument um if I remember rightly the second and third arguments enable you to position the window and I'm going to use a special constant from stlh called sdl window PA undefined so hopefully I've remembered that correctly and if not I'm going to have to check when we failed to compile this let see if I can format that now the next arguments are the screen width and the screen height and I'm going to have to refer refer to those again later in my program so I'm going to create constants with those values let's put these at the top of main variables you try to declare as close as possible to where you need them but often with constants um you'll put them uh somewhere near the top of a function or perhaps more often you'll make them um static public me of a class because you need to use them in multiple places uh so let's let's say here um const int screen width I'll set that equal to 600 this is actually going to be the size of the window actually let's make it 800 um but I'm calling it screen width and Screen height just because um I may well change this at some point in the future to run full screen uh but it will will in this program actually be the the window size so I'm going to paste that in here uh I've chosen 8600 um because well it probably doesn't matter what size we create the window but um there are certain standard screen resolutions that computers used to use historically and that modern computers are usually capable of switching into if you do decide to create a full screen program you've actually got to get your computer to switch it's Graphics mode and there's only certain modes that it can switch into and those are um things like 800 by 600 which is a standard sort of mode um so I'm going to I'm going to just pick that just CU it's kind of traditional and because if we made this run full screen it's likely that our computer could support this particular resolution and the final uh the final um argument that we have to supply here to s sdl window is going to be sdl window shown and this is um at this point in crate window if we hover over it here we can see that we can supply various flags for the last item that um that alter the window in various ways and although it doesn't seem to say here as far as I can see if you look at the oh it does actually yeah no it doesn't if you look at the um API document which I just searched for uh you can actually find the STL window shown basically means don't alter the window just create a normal sort of window so that's that's what I want here so I didn't put this together I didn't figure this out by looking at the API document I I figured it out by looking at tutorials but the API document will often help you it'll help you to understand what you're typing and it's really really useful when you do this um if you look at tutorials to type line lines out by yourself cuz even if you don't completely understand what you're typing it really helps hugely to um to get it into your mind and it's it's kind of a way of um pushing yourself to gradually understand the code if you actually type it out yourself so that's why I always type stuff out myself rather than just copy and paste it whale from tutorials especially like the second or third time I do it first time I may be tempted to copy and paste but typing out is really good so now uh we need to check to see if that window is null or not because if sdl window can't create a window for some reason it will return null so I'm going to say if window is equal to null null is a constant which is often used in C++ it's defined in uh standard libh stdlib.h which sd. probably includes or else if not um then uh it probably defines it um itself but it's common to use this um with a lot of different apis so let's say if the window is null we're going to call sdl quit and we're going to return let's say two so usually if your program runs okay you return n and otherwise you usually return an like a positive integer to indicate sort of what's happened and you will only see this return code if you if you run your program in some fancy way in your operating system that enables you to get the return code from the program so it's not really that useful but um the main thing is just um it's just kind of traditional to return a nonzero integer if your program fails but it would still work if you just did return n and we're probably never going to you're probably never going to actually examine that Eric but you could um now if you look at the API document you find that you can get more information about what went wrong if STL doesn't initialize properly using stdl get error so we could output that using seal this I presume returns a string here it's being output using print F print f is a stands for print format and that's actually an old C function but um old habits die hard and C++ plus programmers often use print F when they probably should be using SE out in some ways print f is nicer than SE out I have to say um SE out can sometimes be a little bit cumbersome so um this is actually worth learning about but you can just copy this line and paste it in to your program um if you want to and you have to include uh STD stdio.h standard input output. as well if you want to use print F or you could just use C out with sdl get error but if your program isn't created that will enable you to get more information about what what went wrong and potentially you can type that information into Google and try to find other people who've got that same problem so if we initialize the window correctly before we quit a program we have to call sdore destroy window um paying close attention as always to capitalization because C++ is case sensitive and we Supply it with the pointer to the window object and we should call that as well actually yeah if if we I was going to say we should call it here but that's wrong if we can't create the window of course we don't need to destroy it that would be um a very bad idea probably um it may even crash if you try to if you pass a null pointer to this function I don't know but if the window is created successfully and we don't return here we want to destroy it which I guess close closes it and cleans up maybe cleans up some resources and call stdl quit which again will clean up any resources that um the stdl is using now uh this isn't quite enough to put a window on our screen uh because at the moment um we just we will just be creating the window and immediately destroying it immediately going on to end the program so I doubt that we'd see a window if we run this what we need now next is we need our game Loop um so in games and you have a a similar Concept in graphical user interface goey programs as well in games you have a thing called a game Loop uh which will be a a loop that will run for as long as the the game is running and it it will do stuff like um well in in a case of this program where we're going to deal with a load of particles we're going to update the position i s or states of particles the color or whatever we're going to draw our particles and we're going to check for um messages or events you could say what messages and events are are um if the user clicks a window or presses a button when a window program is active or does anything involving the window clicks a button on the window or something we say that raises an event and uh some sort of data structure will be filled in with information about what's happened we need to call some sort of function that checks if any events are waiting to be processed and we can then examine those events and see what they are so an event is something that we say is raised by the user doing something uh most of the time or by something happening involving a window we'll see how that works in a minute in um GUI programs uh you have a similar idea called the event Loop which again has to it has to run a loop which processes your events things that are happening in the window as well as give the the kind of subsystem a chance to update the window if it's like hidden by another window or something it has to be re redrawn appropriately and so on um now this is an infinite Loop the way I've written this at the moment uh what I'm actually going to do is create a Boolean variable which I'll call quit and I'll set that equal to uh fults and I'm going to do this Loop while quit is false in other words while not quit or I could say while quit equals equals false or while quit equals equal uh while quit is not equal to true and that those are all kind of the same thing so while not quit while quit is false I'll do the loop and that means that if I set quit to True anywhere in this Loop then that's going to make the loop quit which is what I want because the next thing I have to do is um this is going to execute as rapidly as possible because we want to be able to update the positions of particles and redraw them as quickly as possible to create a smooth animation uh so um what I need to do every time the loop runs is is not only update the positions of particles and redraw them I also need to process the event queue so in between one on iteration of this Loop and the next it's possible uh even though it's going to hopefully execute really quickly like 30 times a second or something um it's possible that multiple things could have happened and sdl provides us with a way of checking multiple events uh one after the other and we're going to do that in a loop which is going to be nested within the game Loop what we're going to do here is we're going to say while sdl uncore pole events so Paul events here um it's not it's not being resolved at the moment because this is actually going to fetch the latest event or um I guess it fetches the first event in the Quee of possible events that have built up since the last time we called it and it fills in information uh in a in an object of type sdl event let's declare that so normally if I want to use something here which I do um if I want to supply an argument to sdl pole events which has to be a the address of a variable normally I would declare it as close as possible to this Loop but because I don't want to be um constantly redeclaring this variable in effect when the loop executes I'm going to declare it outside of this Loop uh just because I suspect although I'm not sure that that make may make my program more efficient rather than if I declared this within the loop um and uh and C++ will be forced to constantly like destroy this variable and recreate it every time Loop iterated so we need to supply the address of this whatever it is to sdl pole events um so sdl pole events will fill in information about what events have happened since last time it was called into this variable uh so for that reason it needs its address so we're going to say addess event there um I'm getting an error here it's possible it's called poll event there we go now see it may appear like I have an encyclopedic U knowledge of stdl but I really don't the only reason I can remember this is because I've typed it over and over again um in the course of writing programs recently especially and in the course of uh making these tutorials I think this is the fourth time I've recorded this video something something went horribly wrong each previous time this time I'm keeping my fingers crossed so now it's like stuck in my head but um as a as a programmer you're not expected to remember an a particular API unless you're working with it day in day out for months or years or something and indeed I don't remember STL that well but I've somehow got this in my head now without even meaning to cuz I've typed it so many times okay so this is going to this Loop is going to is going to keep iterating waiting as long as sdl Paul event returns true and it's going to do that as long as there's an event um waiting to be processed uh so um when it finds an event that um can be processed it returns true which keeps the loop going and it fills in information about that event and this event variable so every time we do the main game Loop game Loop which we hope will execute something like 30 times a second or even more we're going to also Loop through all the waiting events and process them but the only one we're actually going to use in this tutorial is um we're going to um well we're going to access the type member which is some sort of public um member variable of this event um uh I think it's technically a union which we haven't looked at um uh but we can think of this as a struct we haven't looked to structs either but a struct is the same as a class it's just that in a struct it's member variables are public by default whereas if you don't if you don't um specify public or private in a class the member variables or methods are private by default but sometimes for the sake of efficiency you want to be able to access directly member variables of a class or struct um even though that breaks encapsulations sometimes especially in games this is something that you do for the sake of efficiency and that's what we're doing here um I meant to type EV I meant to put event. type here actually and we're going to see if that's equal to s dlore quit now the the quit event is raised if you click whatever decoration on your window closes the window so when Windows um if you click the cross in the corner of the window that raises an sdl quit event which we put into the event queue which this will then retrieve and we can then check and see oh yeah we've got an sdl quit event it's time to quit the program and we'll do that just by setting quit equals true which will then terminate at alter Loop and then we'll go through to um to wind down the program let's see if this works so let's build this and um I've done something something slightly wrong here what did I do redefinition of um screen width oh yeah I didn't spot that I should have put screen height here apologies if you spotted that and we wondering what on Earth I was doing well it's hard to get through this without making some mistake but hopefully I'll get there in the end sorry about that um yes so I meant to um I have this um 600 by um 800 by 600 pixels okay this window now let's check if this finally runs so I'm going to click run here and it doesn't seem to like that let's make sure I built it and we can run it wow so that's a little strange one thing you can do um if your bill gets into a tangle is go to Project Clean that will delete your final program and all of your compiled object files and sometimes that helps and then you can build it again let's go to build all just to make sure it really is building everything and let's just to be doubly sure we we're trying to run the right project let's right click it and go to run as local C++ application and now finally we've got our window so I don't know what the problem was there but um it's good that it came up because I meant to show you this um clean build thing so it's just a blank screen which I actually find quite exciting because it's full of potential now now we can begin to manipulate the pixels in this window um and you may hear my computer working a bit that's because unlike a normal graphical user interface program which will spend a lot of time honestly idling uh so not using up CPU a game like this let's click the cross in the corner of the window here so it quits a game like this will will as I say it will try to update everything as often as possible so we've got this Loop executing frantically in here and that's why even though we're not doing anything you hear the perhaps my computer's fan struggling a bit so um I think that's it for this tutorial uh yeah as I say that Project Clean we talk about cleaning a build or doing a clean build and that means deleting all your compiled objects and your final program youro files and then recompiling so you need to clean it and then go to build project and sometimes that will help you get out of various Tangles so that's it for this tutorial and uh in the next tutorial we'll look we hopefully we'll get actually something drawn on this window like uh at least some pixels or maybe solid a solid block of color or something like that so until next time happy coding