hello this is John from Cave of programming. comom in this tutorial we're going to start looking at the new operator in C++ and I'm going to split this into several tutorials CU there going to be quite a lot to cover here so I've got an object I've got a class that I created in a previous tutorial but I've also given it a Destructor so our animal class it has a name instance variable which is private it's got a Constructor and a copy Constructor uh a Destructor it's got a set name method and a speak method that just outputs the name and for the constructors and destructors I've just put some text in there uh in a see out so that we can actually see that they're running uh let's get rid of this for a moment I'm going to show you that um probably in the next tutorial so um this is how we've been creating an object from a class so far we declare a variable of the type class and we can call methods on it like this so if I run this now we get animal created that's the Constructor running up here we say animal. set name um animal.pak it's cat cat dops I called it cat but it's a type animal and then we get my name is Freddy that's coming from here then it says Destructor called because when we have a local variable like this it goes out of scope so it's no longer relevant no longer usable when we hit the closing curly bracket and when that happens with a uh with a variable of of a object with a variable of a class type so an object the memory associ with the object is deallocated uh that's true for any kind of variable type actually and with objects the destructor will be called like this so when we hit that closing bracket the variable goes out of scope just before the object is destroyed and a memory associated with it is deallocated the destructor runs and we've seen this before now there's another way of uh instantiating an object from a class and that is to use um the new operator so I'm going to change this to a pointer let's say animal pointer Pat one and I'm going to say equals new animal like this round brackets and I'm going to change these variables as well although this isn't going to work yet so the new operator allocates memory explicitly so this is memory that you actually manage yourself in this case it's ating memory for a single object here although as we'll see in future tutorials new is very flexible if I had arguments to the Constructor I could put them in these round brackets here but if if we are calling a Constructor that takes no parameters those round brackets are actually optional so we can put them in or not put them in but I will put them in just uh um CU this is probably the more common syntax now we can't call set name on a pointer we can only call it on an object so we can't do this dot thing even if we put um D reference syntax in here then um this isn't going to work so if I save this and go to project build project this is still not going to work because the dot operator has higher precedence than the star operator so C++ is going to do all this stuff and then try to dreference the return value of set name which makes no sense here we could get this work by putting round brackets around the dreference bit like this so if we dreference the pointer first to get the object then we can use the normal dot syntax with the object if we build this it works but because this is such a horribly unwieldy syntax with these brackets and the Stars there's a special syntax just for working with pointers to objects in C++ let's get rid of these and that looks like this instead of a DOT we use an arrow That's The Hyphen and a right angle bracket and we've seen that before with the this pointer so now this will compile but it's missing something very important uh let's just run this we shouldn't really run this because it's not a good program we'll see why in a minute so it says animal created my name is Freddy but there's no Destructor called and when you allocate memory with new you must always always remember to to destroy that um object you must when you allocate memory with new you must always remember to deallocate the memory explicitly because C++ won't do it for you and in fact that bit of memory that I've just taken up with new is now probably hanging around in my operating system uh taking up Ram completely unnecessarily uh so what we have to do is we have to call delete and then the pointer very like that and when you call delete that will deallocate the memory that this pointer points at so if we run this now this works we get Destructor called so always call delete if you call new uh a common source of bugs in C++ programs is that new sorry is that delete is not called for every call of new and that causes memory leaks in your program another source of bugs is that you might call delete on a pointer that hasn't been um set to point at anything with new in which case your program is liable to crash randomly uh also it's quite common to actually set pointers let's say like this pointer P Cat 2 to set them equal to null so null in uppercase letters as far as I know this is basically a synonym for zero we could use zero um I think it is anyway yeah but anyway this this is common thing to do yeah we see it's just the same as zero it actually tells us down here um and that is a way of saying look this pointer is not pointing at anything and then you can check to see if your pointer is null in your program and um respond accordingly so this is just a way of keeping note for yourself in your program and the fact that this point is not pointing anywhere at the moment but if you try to call delete on a null pointer again you're pretty certain to get a horrific crash when your program runs and that's another big source of bugs in your C++ program so you have to be very careful not to do that uh so there are special tools and also special programming techniques to try to help deal with these situations but for the moment you just need to make sure that wherever you call new you must call delete um so uh one one last thing I want to mention in this tutorial is just that uh I mentioned in a previous tutorial that if you subtract two pointers one from the other you should store the result in a long and that's because um on this platform at least and on most platforms the size of a pointer is actually the same as a long it's going to be 8 bytes in this case that's not necessarily going to be the same on all platforms but in this case a pointer has the same size as a long it's worth check cheing out on your platform just to see what if you do get eight so if you subtract one from the other you need to store it in a a long variable but anyway I'm going to I'm going to leave it there for this tutorial and we've got quite a lot more to look at with this but I've decided to split it up into several tutorials so um for this um tutorial just to practice this I'd recommend create a class that has a Constructor and a Destructor that outputs some text and just practice using using new and delete to create objects instead of using the syntax that we've seen before just practice using new and delete and this Arrow syntax to refer to the methods so that's it for this tutorial and until next time happy coding