hello this is john from caveofprogramming.com in this tutorial we're going to take a look at actually animating particles making a move around the screen and a lot of the principles that we're going to look at here we'll um in this tutorial in the next few tutorials would also apply to animating everything so in sdl um at the moment we're doing pixel access we're putting a load of particles on the screen which are just individual pixels but sdl also allows you to put images on the screen which we won't look at in this tutorial but you can animate images in the same way that you can animate particles so at the moment what's what's happening in our main program here is we've got a game loop uh so even though at the moment that the particles are not changing position although they are changing color we're redrawing them as often as possible and uh usually for a game or a simulation like this you hope that uh your game loop will execute at least sort of 25 times a second i i guess here we're getting more than that i don't know how many 30 or 40 um redraws a second probably on on my computer here and i think i'm building a debug target as well which will always run more slowly than the release target actually since we're not going to do any debugging i can probably go to project and build configurations set active and go to release because that will compile a version without debug symbols in and i haven't shown you how to use the debugger and we're probably not going to get onto that in this tutorial on basic c plus so we'll build a release one because without the debug symbols in it which we're not using anyway it will typically execute quite a lot faster so now just just to get us started with animation let's see if we can make the particles bounce around the screen sort of randomly which is not the final effect that we want to achieve but it would certainly be a bit more interesting than having them just sit there so since since we're redrawing the screen at least probably 30 times a second all we have to do is move the particles in in between redraws well actually we'll need to clear the screen and then move the particles every time we um every time we redraw the screen and that will give the illusion of movement so let's go to particle let's go to particle.h here actually because i want to give particle a method which i'll call update let's make it initially let's make it void update like that and this is going to update the position of the particle and ultimately probably the color as well but we'll leave that for the moment and then we'll go to particle.cpp and create that method here so we've got void particle column colon update so in here we can change the positions of the particles and let's just check what this error is here did i put that in the wrong place or something so we've got void update and particle.h and i'm editing the right particle.h and it's for some reason complaining that's not right let's try just building it maybe i've got the wrong particle.cpp yeah for some reason i put that in the wrong particle.cpp let's cut that from there save everything quit that and try putting it in the right file i should already close these projects as i go along so it does get confusing okay that's better so um what we can do in here is uh let's let's um let's create a constant here let's say constant uh double speed um yeah let's let's just have a speed and set it equal to some um some like quite small value like 0.01 and every time we call update which i need to call somewhere i'm going to add speed to the x and y coordinates let's say m underscore x plus equals speed and m underscore y plus equals speed now this isn't very good because they're all going to move in in the same direction but let's see what what effect this actually has let's go to um let's go to our main file here and before we draw the particles let's call update on each of them so um maybe i should do that yeah what i can do is i could call updates on each particle at this point after this but in fact what i'll do is i'll go to swarm.h and i also give swarm a void of date method i won't make it virtual because i'm not planning to override it and go to swarm.cpp let's have a void swarm column colon update and in there i can loop through all of the particles with a loop like this so it would be more efficient i suppose to update each of the particles positions in this loop but because i at least this computer doesn't particularly struggle with this i'm going to um go to the root of more elegant coding rather than greater efficiency and create a separate loop to do this so i've copied that loop where we loop through all the particles in the main uh sort of thing and here i can say for each particle m on m on the scope p particles and the array brackets here i dot update so i'm calling update on each particle um it's complaining about that for some reason i'm not sure why method update could not be resolved but i have added it to particle oh dear i think i'm editing the wrong swarm.cpp as well this is really a disaster let's cut this out of here put it in the right place and um save that and let's check my swann.h yes i also edited the wrong one there let's save that go back to swan.h and um put that in if i do this again i think i'm going to rerecord the video but sometimes i like to leave these mistakes in just so that you can see what kind of thing typically goes wrong at least with me because i'm sure you'll make many of the same mistakes but let's close that project now okay so we've got swarm.cpp here the error has gone away now we're updating each particle and now in main.cpp when i do each of these loops i can call i'm going to put it down here for reasons that i'll show you in a bit let's call swarm dot update to update the positions of all of the particles so we've got our update code in our particle particle.update here and let's let's see what happens now when we run this so let's check it out so now all the particles have shot off in the same direction we're not getting any errors because we've made sure that we're not drawing pixels uh if they go out off the edge of the screen otherwise this would crash our program but we've taken care of that already and you can see it's leaving these trails because we're not clearing the screen in between drawing these particles so let's let's think about clearing the screen if we go to screen.cpp we've got a we've got an update method here and that's that's clearing the render up it's not clearing the particle buffer where we're drawing the particles so if you remember um when we when we draw our particles um we're actually using screen.set pixel and if we look at that that's drawing into this buffer which we're not clearing so the thing to do is um that we need to clear this buffer somewhere so if we look at main first we're doing set pixel and then we're doing screen.update probably the the right thing to do here is to create a screen dot clear method let's try that and see if see if that works i think that might do the trick and because there's there's nothing else here that we can really clear i don't think so let's try that let's go to um let's go to screen dot h and add here avoid clear method i'll go to screen.cpp and implement that doesn't matter too much where we put it so screen clear and in there i'm going to do mem set we're going to mem set the buffer that holds the particles so we're going to mem set each bite in there to naught to sort of clear it and the number of bytes is going to be the number of bytes of the buffer which in fact actually we've already got exactly what we want here so we did clear it when we initialized it so it's the screen width times the screen height because it holds um holds actually four bytes for each pixel in the screen times size of uint32 which is four bytes let's just let's just copy this line in fact it's going to be a bit quicker paste that in there and then if we go to main.cpp before we draw the particles here we can clear the screen so we can say um screen dot clear somewhere up here now let's see what that does so let's run this and now we can see that we've cleared the screen we've just got a massive load of particles that just all shuffle off to the lower um the lower right there so the reason they're doing that is because if we go to particle.cpp now we can see that where we've got this speed and we're just adding that value to the x and y so if you increase x it will move the particle to the left let's just demonstrate that for example we run this and we see the particles moving sorry to the right and if we increase y it actually moves them down because y increases uh from the top down to the bottom of the screen which is how the string is actually redrawn hopefully you can see that on your on this video and if we do them both at the same time then the effect is to move them diagonally down to the to the right and to the bottom well that's not very good what would really like is um would like them sort of moving uh randomly around a bit so what we could do is um we could have a let's say cons double x speed and we need to set this to some random value let's use rand divided by rand max to get a random number between naught and one and this um remember rand max is rand returns a random number from naught up to rand max and rand max is some big uh some big constant here it's this in fact ox7 and a bunch of f's in hexadecimal and remember that these are two integers so this would this would give us something not useful at all that would give us naught probably i suppose usually and but if we multiply this by a double if we multiply run by a double then we'll we'll get some we'll do double division instead of integer division and we'll get some useful result so let's let's try this and we can do the same to create a y speed as well so again we'll get another random number from there multiply it by a double i meant to put these brackets just around the top bit here because we want to make sure that we're dividing a double by an integer because um as long as we do this bit of a calculation first we've got a double and then when we divide by this integer we will still do double division as long as either the numerator or the denominator or a double you get floating point division which is what we want so now we can add x speed to x and y speed to y let's see how that looks so um we're still getting them in fact they are they even moving at different speeds i'm not completely sure they should be but they're still shuffling off to the bottom right which is not really that interesting um so we should be getting different speeds here though what we can do is what we really want is yeah you can see they're jiggling about as they move but on on average they end up moving with a sort of similar sort of average speed to make them move in different directions we want to make sure that x speed and y speed can be negative as well as positive so ra rand divided by around maps that's giving us a random number between um between naught and one what we really want is a random number between minus one and plus one so to do that we we can increase the range of this by multiplying it by two that's a random number from um from naught to two and then subtract one from it so subtract one so we want to get this in the right order let's just cut this down a bit so we want to multiply two by run two point naught that's very important to turn this into a double divide it by run max so that will give us the random number from naught to two and then subtract one which will give us a random number from minus one to plus one and that's what we want and once we've got that let's put more brackets around this we can multiply it by some speed constant that can determine for us um basically roughly how kind of fast that we want them to move so let's paste this in for y as well and we've got some sort of warning here this is just this bad character sequence which plagues me but i can see that there's a space underlined so there's obviously some weird nonprinting character instead of a space so i just deleted that and put space in now let's let's run this again so now what we're seeing jiggling around in um in quite random ways now um they're behaving like flies the kind of the average speed of them is zero because um we recalculate the average speed every time we draw the particle what would make it more interesting is if we gave the particle its speed its direction when we initialize the particle and if that particular each particular particle then stuck to having the same speed and direction for its entire life so what we can do is take these out here let's cut them from there let's go to particle.h and paste them in here let's call them m m underscore x speed m underscore y speed i can't initialize these here so i'm going to get rid of the const here i'm going to copy this into the constructor of the particle so get rid of the declaration from the constructor like that and um get rid of the assignment from the header so get rid of this bit which we can't put where we declare the variable so i've declared the variables as well they're public variables but it doesn't doesn't matter for the moment in part in the particle class and in the implementation in the constructor then i assign the speeds to random speeds and then we can simply use them in this update method here so now if i run this we see something much more interesting particles are buzzing around and they're gradually all going to move off the edge of the screen and get lost now this isn't the final movement algorithm that i want to show you because it's a kind of a bit boring for our purposes here but i wanted to show you some of the basic principles of animation one last thing that i want to show you is we can make sure in this update method that the particles don't move off the edge so let's say here if m underscore x is less than naught or if m underscore x is greater than screen width really we should say is greater than or equal to screen width then we'll make the x speed equal to the negative of itself so that we reverse the direction in the x direction of the particle so um if the uh i'm sorry that's actually one because we've said that the particle is bouncing around in a box that goes from and this should be minus one come to think of it yeah so we we're making the particle bounce around in a box from minus one to plus one so if it exceeds those bounds then um then we're going to change the speed we're going to reverse the speed so we reverse the the x direction by taking the negative of itself and we don't have to worry too much about whether it could go off the edge of the screen because you know if the particle's already off the edge and we change the speed then it's still off the edge because the speed will only affect it next time update is called but we don't have to worry too much about that because we've made sure that pixels can't be set off the edge of the screen which could cause the program to crash so we don't have to worry let's do the same thing for y as well so if y is outside of this box of minus one to plus one then we can change the y speed to the negative whatever it is currently so if it's positive we make it negative if it's negative we make it positive and if we run this now we can see that now the particles stay within the screen and they're all just bouncing around randomly might be nicer if there was less of them and they're a bit slower actually let's go to where we initialize the speed here and make it slower and i'm also going to go to uh swarm.h and change the number of particles to a thousand so now we'll run this so as i say this isn't the final algorithm that we're going to use but it shows you the basic principles of animation and you can use this kind of thing for making a ball bounce around the screen for example so i'll leave it there for now and we've got some more things to do including blurring the screen and making the particles move in a much more interesting way so we'll tackle one of those in the next tutorial that's it for this tutorial and until next time happy coding you