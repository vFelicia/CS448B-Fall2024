hello this is John from cave of programming calm and in this tutorial we're going to look at not casting and down casting in Java so I'm going to start by creating a couple of classes here I'm going to create a class called machine and I'm going to give this one method public void start and I'm going to put some implementation in there I'm just going to put this out with machine started like that and then I'm going to create a child class class camera and I'm going to say camera extends machine because the camera is a kind of machine and I'm going to override this method such as copy it and paste it in here and change this to camera started and I'll get camera another method of its own public void snap and let's say yes I sell photo taken now let's let's create a couple of objects of the type camera and machine so machine I can say machine one equals new machine and I can say camera camera 1 equals new camera and of course I can call the methods on the second say machine one dot start and camera one dot start and camera 1 dot snap let's just run all that stuff and make sure it works as expected which is always good so there we go and now let's take a look first at hop casting which is the simpler case in some ways so I'll put a comment here about casting now up casting and down casting or custody in general it's a thing to do with variables basically once you've created an object like an object of sight machine or camera in this case those objects are always going to be whatever they are to start with and the machine will always be a machine the camera will always be a camera but you can change the variables that refer to them from one side to another so as an example we saw in there the tutorial on polymorphism that you can always use an object of a child class type where you would expect a object of a parent class type so machine is the parent class and if I say machine machine I could set that equal to a new camera quite happily and this is polymorphism and we know that's going to work but what I could also do more subtly is we see here that camera 1 points at a camera so I could set in a machine to variable to refer to the same object that the camera 1 variable variable refers to which is this object here so I could say machine 2 equals camera 1 and what I've done here in effect is well I've taken a variable of type camera that refers to a camera object and I've made this variable of time machine refer to that object so then we say that I've upper castes or I custard this reference this variable to this variable type and it's up because we've got up the class hierarchy from camera to machine so this this was this is referring to a camera and I've taken a camera object that made the variable of type machine further up the class hierarchy refer to it and now I can say machine to not start and if I do that which start method is going to be invoked well the answer is it depends on whatever object that Machine 2 refers to because the methods and the implementation the guts of the actual code actually does stuff is not stored in the variable it's stored in the object and the variable the reference variable mainly refers to our object so if I thought that this was going to call the start method in machine it would be like having a label that I've stuck on my car that says my car and then expecting to be able to drive the label because if the card actually does stuff it's the object actually does stuff so when I call machine to dot star then it's gonna call this camera method because the actual object referred to by machine 2 is a camera object so if I run that now we can see here it says camera started that's up casting and now you notice her okay camera has this method snap but I can't say machine to snap so the autocomplete isn't helping me and now I'm getting an error here and it's saying the method snap is undefined for the time machine and the reason for that is that it's the actual variable that decides what methods you can call the variable knows what methods are available further for that variable type and the variable here a machine is a type machine and a machine only has a star method so this variable will only let me call the star method it won't let me call camera methods even though it is referring to a camera but we'll see in a minute that there's a way around that and it's the important thing to remember here is that the variable declares the type of the variable determines what methods you can call what's the type of the object that that variable refers to that determines which actual methods like what which actually implementations will actually be called when you call that method so let's take a look now at the converse of this down casting top are common here down casting and let's again have a variable of type machine let's call this machine 3 and again let's make it refer to a camera like this so I can't call machine 3 dots now that won't work but I know that machine 3 is referring to a camera and that camera does have a method called snap so of course I could think well there must be a way of calling that snap method and there is because I can say here I can declare a variable of type camera let's call it camera now and I can set that equal to machine 3 in other words I can set that equal except camera 2 to refer to whatever object machine 3 refers to which is this camera object here and now I'm getting an error here and spam it's saying cannot convert from machine to camera and the reason for that is when you downcast Jarboe wants confirmation that you actually know what you're doing for reasons that we'll see in a minute and to give it at confirmation you need to put the type of the variable you're casting to in brackets before the variable that you're casting from so I'm casting a variable of time machine to a variable of type camera and so I have to put camera here in front of machine to match this and now I can say camera to dots now like that and of course if I say camera two darts start of course that's going to call the method in camera because the object all along was a camera so they've got photo taken and camera started now the reason that Java wants this conformation here is because unlike pod casting down casting is inherently unsafe because I could say here machine machine machine 4 equals new machine ok that's fine I could think okay I could forget that that's a machine object and I could say camera camera 3 equals and I could try to cast this to a camera let's put some brackets in that camera and I'll put machine for here and now I'm not going to get syntax error there I'm skipping me an unused variable warning let's try to use it camera three dot star and that what's going to happen when I actually run this code so I run it and I've got an exception and it's saying class cast exception machine cannot be cuts to camera and if I click on the error line here you should always read exceptions from top down and the first line if I the only line that the line number on here is this and here's where the problem occurred so I can't do that because this is this is like saying basically I could also have tried this court camera three dot start and I would work either I'm sorry not not start with snap and the reason for that fallacy is that that the actual objects here is a machine so I can't just change the Machine objects or camera objects all one they are they don't change and when I start trying to call the camera version of starts using a machine object or when I start trying to call camera methods which machine doesn't have then I've got a problem and you only see the problem at runtime so this doesn't work say run time error and just come in this out so that if you look at this code on cave on programming comm you'll find that there the program at least runs well I don't need to comment this out as well that's where it is there we go so you can't do this and so here I've seen podcasting is safe that's guaranteed by polymorphism and you don't need a caster but you don't need an explicit cast in brackets but down casting is inherently unsafe and you have to really think when you're doing down casting and you want to be really sure that the variable you're down casting really does refer to an object of the pipe down casting and by the way you can't dunk us between unrelated types again for the same reason that you can't down cast a machine object to her to a camera because you can't change one object to another object or you can do is change the references and the references that depend on the underlying object which doesn't change to invoke the correct code so that's up casting and down casting it's a tricky subject they can take a little while to get your head around but it's really important to know especially since you often find methods that return an object there have a return type of object but the real object underneath is some specific child object and then you need to cast that object into the right type to actually use it but I don't if it's really worth looking at that here probably not so I'll leave that but be aware of since this is quite common in Java to cast an object which is a parent of all objects in Java or the grandparents or whatever it's really common to cast objects to objects further down the hierarchy but you have to be sure that the object variable that you're casting really does refer to the kind of object that you're trying to down cast to otherwise you will get an error at runtime so that's up casting and down casting and as far as I can think we've now covered everything that we need to look at using generics so probably in the next tutorial we're gonna look at generics in Java so join me again then and you'll find this code on cave of Programming and to next you