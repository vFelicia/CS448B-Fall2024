hello this is John from cave of programming calm in this tutorial we're going to look at copy constructors in C++ so I've got this class here which I used in the last tutorial and very simply it's got it's got one instance member here string name it's got a method called set name sets that name and it's also got a method called speak which just uses C out to output the name of this object so I'm going to use this here let's create a animal object let's say animal animal one yeah I'll just do that and let's do animal one but set name Freddy and I'm going to declare another animal variable here let's say animal animal I'm going to set that equal to animal one and let's do let's do animal one dot speak and animal two dot speak and let's see what we've got here so our second animal just uses the equals operator to assign animal one to animal too so if I run this we should see that we've got two animals named Freddy here and we do if I change the name of the second animal animal to dot set name two Bob and we run this then we find that we can set this the name of the second animal independently because this is a genuinely new animal let's let's add a constructor here to shed a bit more light on what's actually going on here in detail so if I add a constructor that's called an animal and let's implement it in line here just so we can easily see it I'm going to put in here just to see out see out animal created so if we run this then we get one animal created and yet as you can see here we do have two animals we are able to set name on the second animal it didn't affect the first animal so we genuinely have two separate animal objects here and yet constructors only being call for one of them and we saw that the constructor normally it's called whenever an object is is instantiated so why are we not getting the second constructor being called here and the answer to that is that were implicitly invoking a different constructor called the copy constructor when we assign this animal one animal so we do have two objects but this is using a different constructor and that constructor is actually setting the fields found in animal one at setting the fields in animal two whatever is found in animal one or it's doing the best job it can so C++ has implicitly created a special constructor for it's called the copy constructor whose job is to copy the settings from one object to another but we can explicitly define that ourselves and if you're going to copy your objects you're going to assign them with equals like this that is a very good thing to do let's let's define a copy constructor explicitly so copy constructor looks like this we've got animal and then we have a Monst animal reference like this I need the ampersand the const animal reference and let's call this other and let's put in the implementation again here so this is our own copy constructor let's do see out here animal created by copying endler so now if we run this we find that we've got one animal created using this constructor and one animal created here using this constructor now the the purpose of this constructor is to copy the fields of this other animal which will actually be the one on the right hand side of this equals sign to the present animal here that were actually creating so now because I've created my own copy constructor the original one would no longer work so if I look at animal two now immediately after creating it if I call speak on it after I've created it by copying from animal one we say that it's got a blank my name is because we've overridden the default we've kind of blanked out if you like the default copy constructor and created our own but I knew one is in copying any fields so we can nevertheless some assured in our own copy constructor initialize the fields of the present object using this objects passed in this object here is going to be this one here on the right right hand side of the equals sign so we can do for example in this constructor something like name that's the name of the present object equals other name so even though name is private we can refer to it in the copy constructor because we're still in the same class and private means you can't access fields outside outside of the class but even though this is another object it's still at the same class and so we can access private fields here in the copy constructor let's check there this works and we hope to see that my name is will now be filled in with Freddy right here after we've created the second animal by copying at first so if we run this as my name is Freddy later we change it to bolt now a better way to deal with this is to use the constructor initialization list so let's do that let's put here we've seen this before and let's say name and in round brackets we can supply other dot name and then we can get rid of this here that's a more efficient way of doing that and now if you run this we should see see the same thing again it was successfully copying name so however many fields you have in your in your class when you create the copy constructor you need to copy them all over to your to the new object that you'll be creating using this kind of syntax to create a copy of this other object which is this here and the syntax of the copy constructor you must have this constan amour reference so we pass in or there is a reference that means is it's not a pointer so we don't need special syntax to refer to its fields or methods which is good it's it's a reference so we can refer to it exactly as though we really got the object here but it's a Const reference and that actually means that we can't change this other object which is what we want it will be very strange if we if we did this and this which is invoking the copy constructor somehow changed this other animal on the righthand side of equals that's not something that we would want to happen and that's why the copy constructor has to be particular can't slice otherwise I suppose it wouldn't work at all the Const here actually means that we can't call even any methods on this they're not declared Const because if you think about it you've seen the previous tutorials you'll know that if we could call non concerts on this other animal here then potentially those could modify this that our animal and again would end up with this kind of statement being able to modify that the object on the right hand side of the equals sign it's not what we want so just just to prove that point we can we can't call here other dot speak or we can't call any method that's not Const well this is cons that just get rid of Const and say there and that's do project build project and we get an error but if we put comps back in here we can call Const methods within the copy constructor even though the object is constant object is constant and that does allow us to still call Const methods so now we put that back in say this method is constant doesn't modify any of the instance variables now we can call speak because speak is the globe Const and the reference is to a Const object so now it works and if we run this and we've got animal other dot speak being called at at this point is getting a bit confusing to see what is which but that we can see that we can't call that now let's just delete that because because we we don't need it so I'll get rid of that and save this another way to explicitly invoke the copy constructor will be like this so animal animal animal 3 and that's passing animal 1 so again that's the valid way of calling the copy constructor let's just run this seal it works so there we go so fact when you use equals equals is it's an operator that is again it's implicitly defined for objects you get like a default implementation of equals it calls the copy constructor so here were in effect were calling equals which calls the copy constructor whereas here we're using the copy constructor directly so that I think is is it for this tutorial and and again to practice this define a class and give it let's say give it at least two fields and then try seeing what happens when you try playing around just with assigning your object to another object at the same type like that and then define the copy constructor and getting a copy constructor to work and put C out in it to cheder it is being vote when you expect it to be invoked so get this working using your own copy constructor and try this as well and also you can verify them you can't call non comps methods in your copy constructor because of this consti is worth actually checking that and checking that you do get an error if you try to call a non con smeb or flat matter modify and a field of other here we can't we can't do this either because again that violates the fact that we this references to a comp table J so if I put that in there that's also not going to work so have a go if you have a go yourself if you've got that energy inclination and motivation try defining your own copy constructor and again this is something that's used quite a lot in C++ and as always you won't feel comfortable with it until you've used it quite a bit in your own programs but if you even just go through this here typed it out and get it working then that's a really big important step forward so until next time happy coding you you