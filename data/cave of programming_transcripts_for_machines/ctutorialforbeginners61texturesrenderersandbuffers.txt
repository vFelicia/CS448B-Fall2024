hello this is John from cave of program common in this tutorial we're gonna send color of our window to white and although that may not sound like much but we're actually going to enable pixel access effectively in this window which at the moment is black and we're gonna just make sure that the things basically working by setting the window to white oh here we go so we've got a black window at the moment I've just that externally started three copies of this and we're going to enable pixel access here and then just make the whole thing turn white which is quite easy to do before we go on to setting individual pixels so of course this isn't strictly speaking and speaking and SDLT tutorial it's a c++ tutorial on just using SDL as an example of a graphics API because we need some kind of API and I don't have all the details of the STL API in my head so for that reason I'm going to refer to a finished project that I created by as I explained in a previous tutorial looking up tutorials on the Internet relating to STL and then changing a few things by consulting the API official API documents by searching for function names so I'm gonna kind of cannibalize my own code here and copying bit by bit in fact I'll I'll type it out and I'll explain as much as I can as we go along but my knowledge of STL is thought is not very indepth I just figured out enough to get this working so I hope you'll forgive me effort actually copying my own code rather than just speaking from the top of my head I could have memorized this stuff but it would have been a little bit sort of fake because I certainly don't know STL all that well and by the way I hope that you'll follow along and after each video implement your own version of this program either exactly the same or even slightly different but that's a really good thing to do to get the most out of these videos otherwise if you're just watching them this this will kind of never sink into your head unfortunately so let's let's take a look at the program that I actually finished it's particle explosion program which is down here I've called a STL test and if we go to my I've got an object a class in here called screen which we're going to construct later on but first I want to get just a basic main function that just illustrates that the kind of basic elements of what we need here and later on I'm going to refactor it and make it more objectoriented so that we don't get into a tangle when we add more and more code to this so in my screen class here I've got an init method and in here we are creating a thing called a renderer and a thing called a texture so my understanding here is that the renderer is something we use in STL to actually draw on the window we've got a window but we need a renderer to render stuff in other words draw stuff on it and we also need a texture which is gonna that is like a bitmap that we can draw directly to so we'll be creating the renderer doing stuff with a texture and then passing the texture to the renderer and then telling the renderer to display in the window basically let's take a look at the header file here because I need the types for the renderer and the texture and we've also I've also created here what I've called a buffer and what this is is just an area of memory where we're going to get inset information that's going to relate to pixels and we're going to actually then use that memory to to write to the texture which will pass to the renderer which will display on the window so it's like a chain of three different things here there may be a simpler and better we're doing this but this this is a way that definitely works and it seems reasonably efficient so this is where I've kind of settled on but you may find a better way of doing this as possible so let's go to screen dot H yeah and in screen dot H somewhere this is still screen dot CPP so we need to go down here here's my renderer texture and buffer so so let's let's create those objects in in our main file first of all so I need to go to the right project here that I've just created main dot CPP and somewhere before we actually use these I'm gonna have to create a relevant objects let's maybe do it here so I need a SDL underscore render pointer and let's call that renderer and we need to set that equal to the return value of crate renderer function which is somewhere down here let's take a look so here we are STL crate renderer let's type that out so SDL underscore create renderer and what what what arguments do we need to pass to this well let's take a look so that the first document is the window that the render is going to render into that's like that so we've called that just window to point it to the window the next argument is minus one which if we look at the documentation well let's start doing a seconds at the moment we've got a syntax error that prevents the documentation showing or you could just paste this into Google and the last argument I figured out by looking at the API document that's STL renderer present vsync so I'm gonna copy that and what this does is it ensures that I render is synchronized with the vertical refresh of the screen so your computer screen is gonna refresh a certain number of times a second like I don't actually know how many let's say it's 30 times a second 50 times I'm not sure and it refreshes from the top left hand corner it goes across the rows and moves downwards so it redraws the screen from the top left goes right across to there to the top right and then it does the next row a bit further down the screen going from left to right again and if you try to draw something to the screen when a render is in progress like this half way down you see something called shearing where this kind of effect where you see sort of flickering on the screen and there's a visible line that flickers somewhere across the screen horizontally we want to we want that not to happen so you want to make sure that I rendering is synchronized with that refresh so that we don't try to render to the window when the screens actually refreshing and at least on my machine adding this flag here to Crane renderer synchronize seems to sync rise properly and it prevents shearing if we look at the crate renderer documentation yeah then we see the first argument is our window the second one this is minus one just to say that we want to just initialize the first rendering driver available whatever that is I'm not really sure and but it's basically a kind of default option there and the last one as I say found out by looking at the API document by googling by pulling this function name into Google so that that's our renderer created and let's let's go back and see if we can create texture here so now we need STL STL underscore I think it's texture text text your pointer I quite like having that asterisk next to the actual variables so I'll put it there so I pointed to an STL texture which I'll call texture so this is the thing that the renderer is gonna render and which were gonna write our pixel information to if we take a look at that then again quite complicated arguments ball go through them bit by bit so we've got STL on the score crate texture STL on the score creates texture spot the semicolon and the brackets in there first document is our renderer so let's put that in render the second argument here is this can be a number of possible arguments a number of possible constants depending on how many bits how many bytes basically you want to represent one pixel so I'm going to use this STL pixel format RGB a 8 8 8 8 which uses 1 byte for each pixel so that means for each pixel we've got we can select one of 0 to 255 different shades of each color so each pixel actually uses it actually uses 32 bits or 4 bytes three of those bytes are going to represent the color information of the pixel red green and blue and each red green and blue value can have 0 up to 255 different possible values 255 is the maximum value we can fit in one bite if we flip all the bits to one the other value here AAA's stands for alpha which is basically a transparency we won't be using that and I've read lots of reports that doesn't work in STL and that seems to be my experience but actually I think that you can set various flags here in there to various functions to get up working but I'm not going to make use of it in this tutorial in any case let's let's take a look at what's next so now we've got STL texture access static now this this has to do with the way that we're writing to the texture I can't really remember the details of this but basically we want to take a load of memory containing values for each pixel the right and directly to the texture every time we go around this loop and that flag enables us to do that so let's put that in and finally we've got screen width from the screen height so let's just copy those we've already gotten these constants defined in our program up here so we can put those in because their texture needs to know how big it's going to be and it's format that so we've got our texture and I renderer we also need to remember to deallocate a resources allocated to those so I've done that in my final program in a method called close so they were using STL destroy texture an STL destroy rendering so let's go ahead and put that in we destroy the text at first because it's using the renderer so we probably should destroy that first otherwise we're gonna have if we destroyed a renderer then we're still gonna have a texture that's using that that destroyed renderer I'm not sure if that matters but it's prudent to get them in the appropriate order let's say STL destroy renderer renderer and after that we can do s STL destroy texture texture passing texture hopefully that should do the trick it's probably a good idea to check if these are null let's take a look at the documentation and see if it says anything about returning null so I'll just search google for the function name here and so it returns null if there was an error and we can call SD I'll get error as well so we could we could check that it's probably prudent to do so let's say if renderer is equal to null then if you don't check it on your programs basically just gonna crash if this doesn't work properly let's say C out could not create render endler and let's just return some nonzero integers to signal an error and a say gif texture equals null well just gone the caps lock on here then C out could not create texture pendler and then i'll return some other value could just return north here it as I said previously it doesn't really matter if we could create the window but not the renderer we we probably that in either case we we should probably call STL quit like this if we if we could create the window and so by the stage we have crate to the window so we should probably put destroy window in here as well let's put destroy window before we call STL quit if we are able to create the renderer but not the texture we should probably destroy at least the the renderer so at this point by this point we've created the renderer but not the texture so let's destroy the renderer now this is a lot of repetition of code we could refactor this and perhaps I will in a final tutorial so I don't really like or like in a later tutorial because I don't really like having multiple calls to the same functions in here we could have something that sort of checks if any of those are null and destroys them if they're not nor later on rather than repeating all this stuff but we'll leave it from the moment because the object for the moment is just to get a basic program working even if it's ugly that demonstrates the basic principle and then we can refactor it and make it more elegant so we've got our render and our text you others there's another thing that we need now which is we need some sort of area of memory that could there's big enough to hold the information for all the pixels on the screen because we're going to take that that memory and we're going to basically write it to the texture so we're going to update the texture with that information and what I'm going to use is this type you in 32 so I'm gonna say here you in 32 pointer now what what is you in 32 this is a type declared by STL which on most systems will be equivalent to an int + int is usually 32 bits but it's possible that on some systems because C++ is not absolutely standardized that a an int might not be 32 bits could be something else so for that reason SDL of have defined this type which is guaranteed to be 32 bits but it's basically an int can we want to allocate enough enough of these for all the pixels on the screen because if you think about it here so we've got for each pixel we've got four values red green blue and alpha each of those is one byte so for every pixel we've got four bytes which is 32 bits 4 times 8 is 32 so for every pixel we need a in size of 32 bit bit of memory to represent all the information that's going to be in that pixel or the colors of it basically so we're going to allocate enough memory for all the pixels on the screen and each one's going to require 32 bits so let's say here I'll call it buffer buffer just means an area of memory basically equals new you int 32 and the amount of memory that I have to allocate is gonna be screen width screen width times the screen height because it is just screen just a rectangle which is screen width pixels wide and screen Heights pixels high so that's that buffer and we must remember to free this later on as well so let's go down here and say delete and we need the array brackets because it's it's an array that we've allocated there delete buffer okay so that looks good now you might wonder what happens if memory allocation fails some C++ systems new will return null at that point and we can we can actually configure new to make it do that but by default on most systems it will raise an exception we haven't looked at exceptions I'm saving that for my intermediate C++ course which I which is probably coming next but the bottom line is your program will crash possibly with an error message but it will crash we're not really gracefully but so hopefully somewhat gracefully if we can't allocate memory at that point the trouble is because we're not doing anything with this exception we then wouldn't be able to call these functions but I'm not gonna worry about this for this program by dearly we would check for that but you're this is gonna succeed unless your computer's incredibly tight on memory if it's so tight on memory that we can't allocate being like 32 bits for each pixel on the screen then probably a lot of programs are going to be crashing anyway so this is kind of a justification of why I'm not checking this but ideally in a kind of professional program ideally you'd probably check to see if memory could be successfully allocated although I be willing to bet that very many programs that are on sale do not check but to be perfect we really should so I've I've allocated that I've located a render and a texture and a buffer that we need to contain all the information for the pixels and I've freed all those resources as well down here now what we need to do is we need to update the texture with the information contained in this buffer which at the moment is just garbage and I then need to tell the renderer to render in other words draw the texture so let's look at how we do that I really can't remember but I'm gonna consult my final program again so if we look at I think is screened update here yeah here we go so we need this stuff so the first thing we needs SDL update texture and I've got our eventually I'm gonna move this into this loop so they were updating the texture every time this loop occurs but for the moment I'm just gonna put it above this loop let's say s DL on the Scott updates texture let's check what we do with that so the first argument is the texture so we pass in our texture second argument is null or take a look at what this is in the moment then we pass in our buffer that we actually starts containing the information that we want to update the texture with or it will do once we set that up and then we pass the pitch and the pitch is the number of memory allocated to one row of pixels so if you think about what that is it's gonna be screen width that's the number of pixels multiply it by size of new int 32 which is 4 bytes or we could just pass in screen width times 4 so on seems to be soaring something in the background I apologize for that but anyway I carry on so if we look at the documentation yeah so we've got a texture is the first argument that we need and the next argument is no if we want to update the whole thing and then we've got the raw pixel data that we want to update it with and finally we've got the pitch which is the number of bytes it says between rows that pixel data so in other words that the number of bytes per row of pixels I'm not sure I says between but if you want to go from one row to the next this is how many bytes you have to add on it's possible if we're allocated some really strange sighs for the window that we might have extra bytes at the end of a a row of pixels that aren't actually use of a rendering and then maybe the pixar will be different to the number of pixels in a row but that's not the case here so this this seems to work fine so we update the texture with the pixel information contained in this buffer and the next stage is we clear the renderer so let's call STL on the score render render Ecklie up I think it is all render clear and pass in the renderer something wrong there maybe it's rendered there okay there we go then we copy the texture to the renderer so let's do that so SDL on the score Ren render copy first document is the renderer then the texture then all know and know from what are these I don't know well the renderer and the texture obviously ah to render and the texture and then we've got null and that's the first mall is specified and we want to use the entire texture and Seconal is to specify that we want to use the entire renderer finally I think we've got render present so we've got STL underscore render present and this is basically it's just actually doing the render its presenting a render to the window it's actually rendering it so were copying the pixels to our buffer then passing the buffer to the renderer after after clearing it and then we're presenting the was to render on the screen now if if I run this there is also going to be a bit random let's try let's try running it see what happens whoops that's the wrong that's the wrong thing that's my final program let's try this so go to project build project and we'll run it so it's just black it wouldn't it would not have surprised me if we'd seen a load of garbage in that because when we allocate this memory it's gonna contain just whatever happens to be in that memory that was allocated and it seems that for me this time at least there's nothing in that memory so it's just blank but the reason it could be something in that memory what we want to do now is we want to write something in write some pixel information into this buffer so that we can see something happening on the screen I'm gonna use a very very very useful function which everyone should know about called memset memset allows you to set a block of memory with a particular value so the first argument is the buffer the second argument is the value that we're going to write into every bite of that memory so it's got 255 because we want to try to get every bite cycle to its maximum value red green blue and alpha and actually give us a white color and then if I remember rightly we need the number of bytes that we want to set which is gonna be is gonna be screen width times scream pipes number of pixels times size of invites you into 32 so hopefully I've got this right we're going to write the maximum value that we can put in a byte in every byte in all of these bites and memset is a very quick function which is one of the reasons it's very very useful so let's let's try that see what we get now so we've now we've got a wide screen which is what we wanted now another way of representing 255 which I'm going to be using in this tutorial rather than 255 probably for the most part is we can write this in hexadecimal so hexadecimal is it's another number system like binary like the familiar decimal where we use each digit can have one of sixteen possible values starting in naught and going up through 1 2 3 4 5 6 7 8 9 and then we supplement some extra values by going ABCDE and F so in hexadecimal 255 is 0xff the reason this is particularly useful but by the way Oh X is just a prefix in C++ to say this is a hexadecimal value and the reason this is really useful is because if we well we'll see later on that if we want to pack multiple bytes into one into one single U and 32 value a 30 to the end then we end up with just two digits per byte in hexadecimal system which means it's easy to see which byte represents what's in the final integer that represents the color of that pixel on the screen I'll go into that later on but that's basically the advantage of it we need exactly two digits here to specify one byte and if you're packing bytes into an int value Dan it works out that it's very easy to see which by corresponding in our case to which color but we'll get onto that later so 255 in hexadecimal is FF line art let's just run it again channel it still works so that looks that looks really good probably in the next tutorial what we'll do is well that there are several things to do next but basically we need to deal with pixel access next and we're probably going to do that in a next tutorial we also need to think about colors how we're going to devise what colors to draw on the screen and I might do that in this basic program as well if you look at this program now this is a big main function and we could carry on like adding stuff to this but it by the end it would be really huge and not easy to understand we could split this up into multiple different functions that's kind of C style programming but what we're going to be doing is splitting this up into classes but we're going to continue working with this for a moment because before I want to refactor into classes I want to just make sure we've got a little demo program and it is still quite little really that just demonstrates all the basic things that we need to do and then we can proceed forwards in confidence so we'll probably take a look at pixel access and possibly colors in the next tutorial so until then happy coding you