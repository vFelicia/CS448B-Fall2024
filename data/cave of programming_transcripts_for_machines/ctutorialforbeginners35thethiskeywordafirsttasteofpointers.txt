hello this is John from cave of programming calm in this tutorial we're going to look at the disk keyword in C++ this is something that beginners often find very confusing but as we'll see it it's not that confusing really although you won't understand everything about it until you understand pointers which we'll get onto in a later tutorial but this tutorial will give us actually our first glimpse of a pointer so for this tutorial I've created this person class and I've just given it a string name and an int age we've got a default constructor that I've created here which doesn't do anything in the moment and I've also given it a two string method that just outputs it just returns the string some information about the class so let's actually add to the to this constructor here the constructor that takes no parameters which is all we've got here at the moment let's add to this some initialization of age which are set to nought and name which are set to an empty string now in my main function I've declared an object of this class and I can you see out with by calling to string just to output the information that to string returns there's nothing standard in C++ about this to string method it's just what I've chosen to implement and it says name is is blank here an a20 for this object so let's let's create a parameterised constructor a constructor that takes parameters or arguments you can call them let's go to person dot age and declare a new constructor person and this time I'm going to say string name and well yeah let's call it name story let's say string name and int age and now I'm going to copy this prototype and save that and go to person dot CPP and we'll define we'll implement our constructor so person that's the class name and here's the implementation of the constructor now we've got a problem here because I'm passing in arguments as name and age and in person that age the actual variables that we want to set are already called name and age so the question is how could we differentiate these variables which are in scope here between these brackets from the instance variables up here which are also in scope because they exist for any method that belongs to the class how can we differentiate the two names and the two ages here let's first of all write some code that actually uses this before we implement it so I could say here person person 1 well actually let's make this person one I made this person 2 and will supply the name Bob and an age 42 and then we can do a C out on person 2 as well so that constructor doesn't do anything at the moment so we won't see anything new here but the program should run and again with a bit of luck not seeing anything there we go and we've got age 17 why is that that's because if we look at this I've called this constructor here but that constructor doesn't set values for age and name so we just got garbage in them at a moment now to actually refer to the name that's a part of the class and so will be part of the individual objects we can do this we can type this arrow so it's a hyphen and a right angle bracket to form an arrow and autocomplete is helping here let's say name equals name so here if I refer to name without any kind of qualification without anything at the beginning of it it's going to assume that I mean the local parameter name here it's going to assume that I mean the name which is most closely defined that's what we get if we just refer to name without anything before it if I put this arrow before name then C++ will know that I mean this name up here so we can set this name so this arrow name equal to name which is this one here and that's that achieves the same as if I'd call this like you know new name or something like that and I'd written name equals new name so this is the same as that let's get rid of that and move this back to main and we can do the same for age this arrow age equals age this is a very very common and very useful way to define a constructor it it alleviates the need for you to think of new names for these variables which are after all are exactly the same they have the same purpose ultimately as these the meant to correspond to these so just use for setting these values so and normally you get into the habit of creating constructors and also set methods they're very useful there you can use this in set methods and you just say this this arrow name equals name this ro age equals age and so on let's just see that working so I'll just run this and we've got here name Bob age 42 that's coming from this object here where were provoking the constructor that we just used now what actually is this well actually is this well as I said earlier you won't fully understand it until you understand pointers but let's just investigate it a tiny little bit here what this is is yeah it's a variable that contains the memory location of each individual object that you create so we call that a pointer this is a pointer variable and we can actually output the value of that let's try that let's do C out this endler see what we get and let's run now so the constructor runs but back here when I create the object and you can see it it's outputting this here so I'll put on this stuff let's change that a bit so we can say memory memory location of object I should do the trick and if I run this so it says memory location of object o X and this long string so what this is is 0 X as a prefix on a number means it's going to be specified in hexadecimal so we know decimal decimal is but a number system where you have 9 digits from 0 to 9 in each possible in each possible position there are nine patan what you have a one in nine possible digits that you can use we've seen binary where you have one of two possible digits in each position either 0 or 1 this is hexadecimal whereas there are sixteen digits to choose from you can use in each position and then because we've only got 0 to 9 in our normal number system we are the extra digits ABCDE and F into hexadecimal that's why they're F sania but you can use like Google or something quite easily to convert this to to a decimal number if you want to but it is just a number and the X is if the edge is telling you that this is in hexadecimal not decimal or something so it's just a number and it specifies the actual location in a computer's memory the whole memory is numbered somehow and this is specifying where that object what bit of memory was actually allocated to put the this object in because clearly we need some memory for it to store for example the values of variables so when we crane this person object here at that point memory is allocated in the computer's memory at this particular position and that's what is stored in this in this disk variable we could have put this probably in in an int I suppose why not but it's it is a special variable called this but at the end of the days it sort of just stores a number but it also knows that this is a memory address and not simply any number we can actually see that so so here when particular object is created it's going to output its location let's let's create a new object actually let's create a new one here and say su35 or something 25 doesn't matter let's run this of course we'll get like a new object that we've instantiated does something wrong there what did I do let's take a look redefinition oh yeah I've called it the person to again okay that's a person 3 let's run that so that the next object will of course be stored in a different memory location so they're close to each other maybe the next to each other but this is at this ends in 98 this ends in 50 then so we could find the locations of these objects in memory here in the main program if we wanted to and to do that let's say person 1 dot 2 string and let's say some punctuation memo memory location and to get the actual memory location of a person or any object in C++ you just preface it with a an ampersand like that so let's say person absent person one and well I read that and often is a person one it's not actually in that sign but that's often how I read it maybe that's just me but anyway yes probably better to say address person long because it's the memory address of person one let's still have a person too as well so let's just copy all this and paste that in person to actually will be more interesting to do person to in person three because there were running constructors that that actually have that this statement in it that were outputting this so let's do that so we'll look at person to in person three and for those two objects we're running the Constructors that actually output the value of this so let's let's run this what we find is that we've got memory location of object that's coming from here the actual constructor we've got one says it ends in at 98 and we see here from our main function that the address of it was actually person to is 98 so when we created person to think the constructor ran for that object and at that time when this construct around for that particular object and that object resided in this memory location and that's why this I'll put that particular memory location when we created person sorry person 3 here they construct a run again and when it run again this had a different a different memory location because of course the person 3 is not in the same location is person too so then we output this this stuff here and then we output the locations of those two objects which of course we already know because we output it using this but we can see the two locations again down here that has same two locations as these and now I just I wanted to run through this just because it'll kind of sort of soften the blow a bit when you encounter and pointers later on we're going to look at all of this later on we're going to be looking at the this ampersand thing and memory addresses and stuff like that a bit more later on as well as more stuff besides but the thing that I'd recommend practicing for this tutorial is very simply create some classes and give them constructors and also try giving them set methods and give the constructors and set methods and parameters that you've got defined in your for your particular object but then instead of giving them different names in in your actual parameters to your set methods of oil constructors give them the same names as the values that and they use to assign to and then use this to differentiate too so just practice doing what I've done here basically in a set method and in a constructor try typing stuff like this our own name equals name and that will help although it's a small thing that help fix it in your memory and it will also help a lot later on when you encounter pointers just just to already have some familiarity working with this arrow notation and ask for the rest if the stuff about memory locations went a bit over your head then don't worry about it because we're going to revisit this later on but it's good to already be acquainted with it at this stage so that's it for this tutorial and until next time Cody you