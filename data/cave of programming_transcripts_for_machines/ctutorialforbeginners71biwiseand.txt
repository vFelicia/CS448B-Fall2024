hello this is John from Cave of programming. comom in this tutorial we're going to look at the right bit shift and binary bitwise and operators the reason for that is um at the moment we've got this particle explosion that we've been working on in these tutorials um but before we start find tuning the movements of the particles and make it look uh nicer I think it would be good if we could blur this program because without seeing the kind of blur on the particles it's hard to really get a sense of how this is going to look with the final blur applied to it and the blur makes a big difference in um how nice it actually looks now to actually do the blur we need to be able to get pixel values and set new pixel values based on the old ones um after applying some kind of blur algorithm and to get the pixel values that involves um getting a color which will be a 32bit value that looks something like this let's write it out in HEX 1 2 3 4 5 6 7 8 and getting the uh red green and blue values from this so we're we're packing red green blue and Alpha values into a single 32bit color value so this would be red this bite would be green this bite would be blue and this would be Alpha and we're not using Alpha although we have to have it in there because we're working with 32bit values for each pixel so to show you how to do this well let's get rid of the alpha value just because it's simpler to demonstrate this without um a little bit simpler how can we get red green and blue values out of there so the red is 12 in HEX green is 34 in HEX uh each of these is one by and the blue is 56 in XX how can we extract those from this well one thing we can do is use a bitwise and operator if I write int um let's say red equals color now I'm going to use a single and so two and symbols together in uh in C++ is a logical and um it's it's like Boolean logic but if I use a single and this does a bitwise comparison so if I write out now o x and we're going to set if if you imagine this is binary I'm going to set two bytes entirely to one sorry one bite entirely to ones so this is like eight ones FF is like eight ones in binary and then the rest I'm going to have zeros so I've got the same number here but if you look at it in binary it would look like this 1 2 3 4 5 6 7 8 and then 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 and uh what this bitwise and will do will be it will say it will look at each bit in this and this in the color and in and in this my um what we call a mask here and it will say okay if both of the bits are one I'll set the result the bit in a resulting variable to one um but if either of them is zero um then I'll set the bit corresponding bit and resulting value to zero so it means and means um both of both of them the actual value and the mask have got to have um ones set in a particular position so it's got to be one and one together if it's one and zero um then we say that's um that's we're going to set that to a zero in the resulting variable so like here if if I write out um if you imagine this is the mask we call this The Mask which is this and if we say that this is the color so let's let's line them up here if the color look like this then um the result of bitwise and will be like this so if we look at this column we've got one and one so that's one this is one and zero so we make that zero and these are all ones and zeros here we've got a one and a one here's a zero here's a one and a one one and a one one and zero that's zero so that's zero zero and in fact all the rest are going to be zeros because we've got zeros in The Mask so it's going to end up looking like this if I've got this right so youve got to have one in the mask and one in the color now we're we're working with hex but um the way this looks in HEX is if I um use a bitwise and on this color with a mass that has FF here and 0 0 for the rest all of these are going to be set to zero and the the first two here which we do the and operation with the FF which is just um just 8 ones basically this bit is going to remain um what it is currently so let's just see the result R and talking anymore I probably explain this about as well as I can now um so I'm going to I'm going to say here see out we want hex format and uh I'm going to Output um red here let's see how this looks so if I run this now whoops I think I've just run the wrong program I no we've run the right one so we can see that we' picked out the one two and set the rest to zeros all I have to do now is shift this um so if I shift this two bytes along which is 16 bits now we're going to get the red value so we've got red similarly if I copy this and let's say green so let's set the first two to zero and then we want um FF to to mask out the green bit and then 0 0 0 0 for the last value and I want to shift this by one by and let's take a look at that so green here and there's our green value 34 which is picked out from here and finally we've got blue which just is color um bitwise and so single and Ox 000000 FF and if we now look at Blue hopefully this will work whoops yeah yeah H it's good okay yes so we've got the blue value picked out there now this is a solution that I've seen um on the um internet when I've looked for this but I I find that um at least what I can do on this system and I think it would work on all systems but I'm not completely certain is we can do the following just going to write a comment there because I haven't tested this on a range of systems I don't see why it wouldn't work on any any system that you try it on but there's a little doubt in my mind so I'm probably going to stick to using this kind of system in this tutorial now of course we don't want ins here we want unsigned chars because each of our red green and blue values are actually um they can only range from n to 255 like an unsigned Char value uh so this out this is outputting the capital V because it's try to Output it like a character but if we cast that blue to an INT there and then run it we should see that we're still successfully getting blue I don't know what this problem is that I keep seeing every time it comes past maybe just an unused variable warning let's just check let's check the red as well and check that we're picking out um the value one two there let's run this so yeah that still works fine uh but what I find is that I can do something like this unsigned Char red let's call it red again equals uh we take our color and all we have to do is do the shift so if we um shift this by two bytes and then output this value so red again then if I run this again we get one two so because we're using an onside unsigned chart if we just shift this over if we shift this number over two two bytes sorry this number when we shift it we discard all these and then when we pack the int into an unsigned chart when we do a typ cast in effect then we end up with the value that we want so if you're purely getting your result in an unsigned chart I don't think you need to do the mask bit nevertheless I ran through it because I'm not 100 I'm not absolutely 100% sure that there's there's not some Quirk on some system somewhere that would somehow prevent this working with some compiler I don't know and because you see this on the internet a lot and also because it is important to know about the bitwise and operator in C++ is sometimes very useful there's also a bitwise or which I'm not going to cover here except to say that bitwise or would set the one in your resulting value to one if either the The Mask or the um original kind of value were one so it's saying it's got um one of them is got to be one either the first one's one or the second one one whereas the bitwise and says and this one's got to be one and the second one's got to be one as well so the bit wise or um it looks like this let's just write this bitwise or it's that symbol there and remember for a logic C or use um a double bar okay so um it's yeah it might be worth Googling bitwise operators just have a a look at a page there so if if you want some homework I'll give you that as a kind of homework task but apart from that I'd recommend trying this for yourself and check that you can extract extract red green and blue values from a 32bit color like this check that you can do it and then in the next tutorial we can go on to implementing blur I should think which will start to make our program lot really quite lovely so um that's it for this tutorial and until next time happy coding