hello this is John from Cave of programming. comom in this tutorial we're going to look at returning objects from methods in C++ and we're going to get a bit more sort of practice with the new operator so in a previous tutorial I showed you this class animal which very simply has uh Constructor copy Constructor Destructor set name method has a name instance variable and a speak method that outputs name and the constructors and destructors all output some text so we can see what's going on there and uh we've seen this little program before let's get rid of this which just uses the new operator to allocate memory for an animal object and it calls set name speak and then it deletes the um we call delete on the pointer to deallocate the memory associated with this object which means the destructor is called so um supposing you want to return an object from a method and this is a common thing to do in in C++ or let's say from a function um of course a method is just a function it's part of a class but let's create a freestanding function here I'm going to say animal let's call it create animal and um put the kellly brackets in there if I can remember where they are on this keyboard and in there we could we could instantiate a animal object like this let's call it a and a do set name berti and and return a now in our main program here let's say animal um frog equals create animal and of course we can call Frog dope now this this does work so if I run this it says animal created when we do that it says my name is Bertie when we do this and then destruct called when this variable goes out of scope now the funny thing is if if you understand a bit about how this works um we would expect this to be quite inefficient although it seems that on this system with this compiler it it actually isn't so what we'd expect to happen is here we're creating an animal it's a local variable calling set name when we when we return uh an object from a function we actually have to normally create uh normally C++ will create a temporary object just to return that um this object so it would actually copy this you'd expect to a temporary object just to have the return value in there and then when we do this when we assign this new object here to our temporary return value object here we'd expect that another copy would occur so what we would expect would be the Constructor would be called when we do return we create a temporary return object to return into this variable here in effect uh so we'd expect the copy Constructor to be called there and we' expect the copy Constructor to be called here when we do this as well in fact we're not seeing the copy Constructors here and that's because this particular compiler is optimizing out the two copies there so it realizes that we we don't want them we just basically want to have one animal here and it's it's optimizing away the extra copies nevertheless in theory this could be potentially inefficient if that optimization with some compiler or other didn't actually happen now uh we could think about how to make this more efficient and uh one kind of naive way of doing that would be to return a reference so we could change that to a reference and um and then we could think okay when we return it what what will happen is that we'll just return a reference to this animal in other words just an an alias to this variable and then we could maybe we can make this a reference as well like that then we can say okay this is just going to be an alias to this now this works as you'd expect with regard to references but the problem is that well let's just build it we get a load of warnings so I don't think we've got any errors in here it has actually built a program but the program is probably going to crash I'm not going to try running it but it's not a good program the reason for that is this variable here is scoped to these curly brackets when we hit this curly bracket the destructor is going to be called on this we expect and therefore we end up with a reference to an object that no longer exists so that um the if the kind of um sort of instance variables of that object is still present in memory it's purely by chance I imagine they won't be I'm I'm really not sure what would happen if we run this well ah let's just try it what the hell so um it seems to have worked it just say berti but that's really work by chance more than anything else just because I suppose um although this ends up referring to invalid memory that memory just happens to have the right stuff hanging around with it but anyway regardless of what whether this works or not this is a very very bad thing to do returning a reference to a local variable which will go out of scope is not a good idea your program will randomly crash so a common way to get around that is to use a pointer we could say here animal um let's say p animal equals new animal like that we need to put the star in there as well and then we can return a pointer here to that to this animal uh we can do a can do p animal arrow set name using the arrow syntax now cuz it's a pointer and then we can return P animal here in our main program we can say let's say P pointer P frog equal frog equals the return value of create animal and then we can say p frog Arrow Arrow speak like that but the thing that we mustn't forget to do is because this function did a new here we we must do a delete to deallocate the memory associated with this frog so we need to say delete P frog like that so even though new happened in a in a whole other method to this one sorry a whole other function I should say we still need to do the delete because we do have a new and we've got to deallocate in a memory that we allocated with new otherwise we'll have a memory leak let's save that and run it check that it works so now we've got my name is berti Destructor called we've got a Constructor being called and a Destructor and there are no copy Constructors cuz there's no copy um happening of the animal even without without compiler optimization there wouldn't be a copy here we're creating when we when we return the pointer we're creating a copy of the pointer but that's just copying like an 8 by memory address and similarly here when we get that temporary return value into P frog at least this is my understanding of how it works uh we're just copying eight eight bytes did I say bits we're copying eight bytes into um into this pointer variable here so even if even if this some one is huge and occupies you know like I don't know megabytes then we're not copying we're not creating copies of those megabytes even if the compiler doesn't optimize to get rid of the copies we're still not doing it CU all we're doing is passing around a pointer this is a much more efficient way of doing this uh we're returning an object from a function than if we try to do it without pointers and it also avoids the problem that we saw with references because um with if if we didn't have a new here then we'd end up with that animal being um destroyed at this point and we could end up returning a reference to a an animal that doesn't exist anymore or may not exist uh but with a pointer um that memory will not be deallocated until we do delete on it so this with new um you have to do delete to explicitly deallocate that memory and the memory will hang around so associated with this um the object that this pointer points to until we call delete so that's why this is safe to do it's just has the downside that you you don't see a new here in this function but there is a new there and you must do delete so this is not um the nicest thing to do but you see this a lot in actual production C+ Plus Code because sometimes you just need to do this sort of thing so to practice this um just create your own function that uh that returns a pointer to an object and then use the object somehow and delete the memory associated with it and once you've done that that will help to make it stick in your memory uh there's there's one little thing that I should mention here which uh maybe we'll go over in a later tutorial CU it is important but uh there are two basic areas of memory in a C++ program or at least um classically this is how we think of it and as far as I know it's uh it's it's basically true and that is this we have the stack and the Heap and the stack is an area of memory you can think of it like a stack of plates where you can put plates on the top and then take plates off the top except that what we're putting on the stack is memory associated with local variables like the pointer itself is a local variable uh in this case and also we put um the addresses of functions to be called onto the stack so that we know um uh how to call those functions in what order so um local variables and um function calls end up adding memory to the stack and the stack is a small area of memory if you um if you called a if you called a function from within itself over and over again so it ended up calling itself you know millions of times you can end up with a stack Overflow by exceeding the amount of memory that you've got on the stack but there's also an area of memory called the Heap and this is basically all the memory available to your computer and when you do new you're actually allocating memory on the Heap so um let's say you had an array with millions of entries in it you don't want to declare that as a local variable cuz it could overflow the stack you would want to use new to to allocate memory on on the Heap which is much bigger uh for that array and we're going to be looking at that in a future tutorial so I'll leave it there for now just try creating your own uh function if you like that returns a pointer to an object it creates with new and don't forget to delete it's very very important it's worth putting in your Constructors and destructors and put some text in them so you can verify that they are actually called so until next time happy coding