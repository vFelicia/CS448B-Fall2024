hello this is John from cave or programming calm in this tutorial we're going to look at constructor inheritance in C++ the bottom line here is that constructors are not inherited in C++ by subclasses but they are called so let let's take a look at that so I'm going to create a class here called machine to be like a sort of generic superclass and I'll give machine a constructor so let's say machine like this and let's in the constructor let's put C out so we can see it running let's say machine no argument construct tour called and accepts him now we can already create a machine object we can instantiate an object from the machine class like that and if we run this we're gonna see the machine constructor running let's create a subclass of machines let's say class vehicle so a vehicle is a type of machine unless it's a magic flying carpet but usually a vehicle is is a kind of machine let's give this a constructor so I'll just copy this save me some typing and rename machine in here vehicle and let's now create a vehicle so the call I'm giving the the variable the same name as a class here which I can do because my variable has a lower case feed and the class has an upper case fee and some people find this confusing and avoid it but I quite like it if you just got one object of a class because the class because I'm giving it an upper case first letter by my convention that I'm using which is a common convention and I give my variables lower case first letters and and C++ is case sensitive we are allowed to do this so let's let's run this now and what we find is that well actually I had meant to I meant to make this extend machine let's do this so vehicle is a subclass of machine and also I want all this text actually in the constructor let's just change this okay so let's run this now so now when we actually create a vehicle this the constructor of machine is called first so we've only got one object here we've only got a vehicle object but and because vehicle is now based on machine C++ will actually call the constructor of machine in order to construct vehicle and it will call it before it calls the vehicle constructor so C++ will call the default constructors of all the super classes when it creates an object from a subclass and that makes sense if you think about it let's give machine a private int ID and the constructor of machine could initialize the ID let's set ID equal to nor because if we didn't set it equal to something it would just stop garbage in it whatever happen to be in the memory at that point so we'll initialize it with zero and let's also give Machine a a method called info which is just gonna basically output the ID so let's say C out ID and ID and because machine has this info method public info method vehicle will inherit that method so we can say vehicle dot info if we run this now we find that for vehicle ID isn't set is indeed set to zero so in vehicle we can't refer to ID at all it's private to machine so we can't do stuff like this C++ won't letters we're not allowed to refer to ID in vehicle because it's private and machine then that means we can only refer to it within the defining brackets of the machine class so if you run this then we get an error and for that reason it's very handy that the Constructors of super classes are called because our machine constructor can initialize the private data of machine and then the private ID of vehicle that's sorry the idea vehicle will be initialized automatically so let's just build this again guarantee error and run it whoops what they do whoops no I want to do that so I've got an error check the error initializer ID does not name a non static I forgot to save my program that's the problem let's run it ok so there we go right so vehicle does have an ID it does have an ID because it's super class machine had an ID it's just that we we can't refer to the ID anywhere in vehicle we can output it with this method that was inherited from machine that refer to the ID and the constructor of ID can initialize that ID but in vehicle were not able to refer to the ID anywhere Neverland nevertheless we can call a method in a superclass that refers to the private data of that superclass and a vehicle does have an ID because it's inherited it from machine let's take this therapy one level further I'm gonna create specialized type of vehicle which I'll call car a safe public vehicle so car now is a subclass of vehicle and it's an indirect subclass of machine and also give car a constructor so I'll copy the vehicle one just to save some typing and we can type car car car dot info so now if if we run this we find that C++ will call all the constructors of all the super classes above car before called calling the car constructor so first it calls the machine constructor which initializes the ID then it calls the vehicle constructor and we can see that running here finally it calls the car constructor the constructor of the object itself and again car has an ID because it's indirect superclass at the top of the hierarchy here machine had an ID but we couldn't refer to that in car because it's private in machine c++ also allows us to specify which constructor in the superclass at any points in the hierarchy is actually run so let's imagine well that's not imagine if I actually give machine a constructor that takes a int ID and uses that to initialize ID so now we can do this we can do machine machine pass it an ID let's say one two three and of course we can call machine dot info so hopefully I've got this right let's run this and we see that the idea of machine is one two three but we can't call come we can't call that constructor with vehicle so if I change this to vehicle we can't call this parameterised constructor and vehicle because we only defined it in machine here and constructors are not inherited in c++ so they're called the Constructors of superclass's are called but they're not inherited we can't actually use it like this what we can do is we can specify in the vehicle constructor what constructor we want to run in its superclass so let's give vehicle a constructor that takes a parameter let's say int ID and I'm going to say here why I should change this actually so this is the Machine para Ram a terrorised constructor hopefully I've spelled that right and I want a copy Lux is so difficult spell and this is the vehicle parameterised constructor now again we've got a similar problem here to what we saw before that we want we want vehicle to have a constructor that looks like this that accepts some ID parameter to initialize vehicles ID with which it inherits from machine but we can't refer to ID directly in vehicle we can't refer to this ID because it's private to machine but what we can do is we can specify here in the constructor initialization this that this vehicle constructor is going to run the machine constructor that takes a parameter just accept some ID so now we we defined this constructor for vehicle and we've said that this constructor will run the particular constructor and machine that takes a parameter let's try running this see if this works and shall we run it so there we see that the vehicle has got an idea of one two three so this ran this constructor and this constructor now run this constructor here we don't have to call matching constructors in the superclass so here we've got constructor that we've defined for vehicle it takes an ID and that's calling the constructor and machine which takes an ID but we could for example in car here car the superclass of Corey's vehicle the direct superclass and in car we could specify that the no argument constructor calls the vehicle constructor that takes an ID and we could give that an ID like 999 so if we construct a car here car car oh yeah so we're calling the default constructor of car let's call card info and if we run this if I've got this right then it says car no argument constructor called that's correct and the idea quois 999 because now we've said that a no argument constructor of car calls the vehicle constructor that accepts an IDs is running this constructor and the vehicle constructor that accepts some ID in turn is calling the machine constructor that accepts some ID notice that we can't call the indirect superclass constructor of car in the car constructor so we can't do that as an error we can only refer to the Constructors of direct super classes so this list does work as we've just seen and so to sum this all up constructors are not inherited in C++ you can't call the constructor of a superclass when you construct a subclass but C++ will always run one of the constructors that in each of the super classes above a particular class when you instantiate an object from that class if we create a car we're going to run a constructor in vehicle the direct superclass and we're gonna run a constructor in machine but at each step in the hierarchy you are allowed to specify which constructor will be called in the superclass so that's it for this tutorial to practice this try creating a multilevel class hierarchy we'll at least three different classes in it like this getting more and more specialized and I've had some like tests like I see out of each of the constructors so that you can see that when you create an object all of the constructors and the super classes are running and then try for each level in your class hierarchy specifying which constructor of two or more possible constructors that you define will be cold when you construct an object from a particular class so basically have a go at what I've done here and that will that will make it a lot clearer in your mind if it's not clear already which would be completely understandable and of course you'll get more practice with this when you starts write quite complicated programs yourself so that's it for this tutorial until next time happy coding you