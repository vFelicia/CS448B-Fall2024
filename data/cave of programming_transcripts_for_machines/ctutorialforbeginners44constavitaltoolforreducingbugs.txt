hello this is John from Cave of programming. comom in this tutorial we're going to look at const in C++ which is a very important key word um believe me I I'm aware that in this in this course we've gone through a lot of quite dry Concepts uh but um we are going through kind of the minimal Concepts really that we need to do any useful code and const although it might not sound very important uh because all it does is keep things from changing basically it is actually very important and we can't really progress further without it so we better look at it here so um let's declare an INT here let's say int value equal 7 and of course a variable the whole point of it is that it can vary so we can change value to 10 or whatever and let's just do a c out here on value why not and let's just run this by the way I've created a little class up here and I'll go through that in a minute don't worry about that for now let's run this so we get 10 now if I type cons before int then that means that we've now got um a int that is Con in other words it's no longer a variable it's actually a constant it can't change so this line is not going to compile let's just build that and prove it and that's very very useful because sometimes you have got values that don't change and you don't want them to change and if you've got a value that you don't want to change you should always declare it Con so that it can't be changed like this uh it's also quite common practice practice to um make your constants uppercase we could say like Pi let's maybe make this a double cuz Pi is going to be a double and um 3 uh 4 1 5 92 I think that's Pi I always remember it with how I wish I could calculate pi it's the number of letters in each of those words but anyway that's irrelevant so I put this in upper case to SC the fact that it is a constant and not a variable and that's a very common thing to do let's just run that there we go now you can also declare methods constants let's take a look at this animal class that I've created um maybe the easiest way to explain this is to show it you so I'll create an animal here like this and I've given it a method called set name so we can do animal do set name let's set it to Freddy and I've also given it a method called speak so we can do animal dope and that outputs the name so let's just run this and it says my name is Freddy usually most often we declare a class in a header file and we put the implementations of the methods of that class in a separate CPP file separate source file but in this case I put the class here because we can do that and it's easier to read for this tutorial and uh I put the with the implementation right here as well so we've uh we've got inline method implementation here meaning it's declared uh right where we create the class rather than being in a separate file and that's useful for very small methods usually in your class here I'm just doing it for the convenience of this tutorial so um this this method here set name changes um instance variables of the class of of each object in other words changes the name of the objects um but speed doesn't change anything and if we've got a method that doesn't change any instance data of the class uh in other words well strictly speaking a class can't have instance data the objects have instance data but this is like a template for saying that each object is going to have an instance variable called name so each object will have its own separate name variable and if you've got um a method like this that does doesn't change an instance uh any instance data you can declare it const and that will prevent you from changing the instance variables of the objects here in that method and I've typed const after the round brackets of the that follow the method name and before the implementation so now this this is still going to work if I run this it will work just as before my name is Freddy but if I did something in here like I try to change name to something like that then that is now not going to work it's not going to build let's build that and we'll see so we get errors and if you look at the error we'll get something like um well it's a bit cryptic um as um C++ errors tend to be saying no viable overload equals but it's telling us that we there's there's no form of equals that makes any sense here in this context because this is a con method if that wasn't there we'll be able to do that absolutely fine so if I can build this but because we don't want this to be here we don't want this method to change anything it's good practice to declare it Con I and many other programmers are a bit slipshod in declaring things const sometimes especially methods but if you've got a method that you know doesn't change the instance data really you should declare it cons just to reduce bugs to reduce accidentally changing something which is far easier than you might suspect so um now we can't accidentally change anything in this method uh con can get a little bit tricky as can type declarations in general in C++ let's take an example of um a kind of typical uh example of such trickiness so let's create an INT here int value equals um 8 we can declare a pointer to that value by saying int pointer P value and we we can set we can initialize it here if we want already and say it's equal to the address of value then of course we can output that like this we can say see out thing pointed to by P value and that will give us eight this is D referencing the pointer getting the thing that it's pointing at which is going to be the value eight ultimately so we run this and we've got eight there of course if we change this at this point then we get something different here because the pointer is just referring to the memory location of that variable it's a lot like a reference so there we've got nine let's get rid of that now what what I want to show you is if we um we we can do two things things here to actually change this uh let's do it after that c out um we can change the kind of pointer variable in two ways one way is um let's say we have another value let's call it int I don't know I'll just call it number and I I'll set it equal to something um just why not really um so in number equals 11 I can say P value equals address of number Nothing Stops me pointing that value at pointing this pointer at a different int it's fine let's output P value again down here now it's going to say 11 and we got 11 and we can also use the pointer to change the thing that the pointer points at so this is actually changing the pointer itself to point somewhere else but we can use the pointer to change whatever it points at we can say thing. 2x P value equal 12 and we're also allowed to do that so we can change the let's not do that what did I do yeah I've got capital P by mistake so we can change two things associator with the pointer we can change where the pointer points and we can change the value that the pointer points too so now here um sorry here where I where I declare the pointer I can say cont before the int and we can read this backwards so this is now a pointer to an INT that is constant so that means that we can't change the int that the pointer points at using this pointer it's a pointer this is a pointer to an INT that's constant the int is constant as far as this pointer is concerned and we can't change it so that means if we compile this program we're going to get an error here here we're trying to change the int and it and the int is constant so we can't do that so um this gives us an error there const int value let's let's maybe copy that um let's say um error with this what if the const was actually here now if we read it backwards now we've got a constant pointer to an INT and that means um the int isn't constant anymore the pointer is constant we've got a constant pointer to an INT so we can't reassign the pointer to point somewhere else now we get an error on this line let's build this and we'll see so we'll build this and now we've got an error here because we can't reassign this pointer so let's let's copy this and say error with this so if I delete that we're allowed to do both as before let's just run this there we go and you can use both together so if we say this and this now we've got a um constant pointer to an INT that's constant so we can't we can't point the pointer somewhere else and we can't change the int that it points at we could change it using the original variable but we can't change it using the pointer cuz the pointer as far as the pointer is concerned the int is constant so that that's kind of um a good trick there if if we build this we're going to get errors with both of those lines so um let's maybe comment this out cuz I like to leave my programs in a working State and let's get rid of this const and that const so we can so we can build this so that's a kind of a neat trick for interpreting um conss and um interpreting types in general in C++ is to read them backwards because um that gives you a a true reflection of what they mean reading them forwards pointer to an in that's constant okay so I'm going to leave it there for this tutorial um and as always I'd recommend practicing this start with declaring your own constants and verify that you can't then change them try creating a constant method and verify that you can't change instance variables of your class using that method and finally uh experiment with pointers try to declare a pointer to something that's constant and try to declare a constant poter and also try to declare a constant pointer to something that's constant so try all the possibilities that I've gone through in this tutorial and again although you won't feel fluent after doing this it will help fix that in your mind so that when you use it later on um it's going to you're going to understand it much more readily than if you don't do these exercises but of course it's up to you if you just want to watch these videos and try to write programs that's probably what i' do myself if I'm honest cuz I'm so lazy it's just that they they're bound to get very confusing if you don't do any exercises so I'll leave it there and until next time happy coding