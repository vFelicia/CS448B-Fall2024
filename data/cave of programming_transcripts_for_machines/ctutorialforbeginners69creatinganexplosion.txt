hello this is John from cave of programming calm in this tutorial we're gonna start working on creating simulated explosion effect so the moment our particles are all starting random positions and they're wandering around the screen randomly well actually they all have fixed speeds and directions and it bounced off the edges of the screen and just kind of wander around so what I'd like to grate here is an explosion effect where they all start from the middle and they all fire outwards in a sort of circle some jagged circle so let's start putting that together in this tutorial and what we want to get to start with is that circular kind of explosion pattern of the particles so if we look at particle dot CPP now we've got it that were initializing the X&Y coordinates of each particle to a random value when the particle is created let's get rid of that and instead put the particles using the constructor initialization list here let's put them right in the center of the screen which are now in our particle coordinates system is at 0 0 x equals 0 y equals 0 and if we run this now they start from the center of the screen but you'll notice there's a rough rectangular pattern to the explosion that's because we're choosing the x and y values here randomly but using the rectangular coordinate system like that and choosing the x and y speeds of the particle separately is what leads to this rectangular pattern what we really want to do is we want to choose two things for each particle firstly a completely random Direction from naught to 360 degrees and secondly a speed so that we're not introducing any kind of rectangular element in there and if you've done any mathematics you'll recognize this is basically changing from Cartesian coordinates which were using in the moment to polar coordinates but if you haven't done any mathematics don't worry about that because the formulas that I'm going to show you you don't really have to understand them unless you're going to do a lot of detail graphics work you can just use them so instead of having an X speed and Y speed for our particle I'm going to go to particle 2h here get rid of those and instead of those I'm gonna have a double em underscore speed which will just speak how fast the particle is moving in whatever direction it's moving in and a double and on the score direction which will be the angle from north 360 degrees that the particle moves in and then in particle dot cpp let's get rid of the update method because that's now not in the u s anymore and let's get rid of this stuff that initializes the x speed and y speed because we're not using that anymore let's start by picking a random direction for the particle so again we'll use our old friends runs and ran max here we divide rat ran returns a random number from naught to whatever ran maxes which is a big number so if we do this we'll get a number from naught to one point naught except that we have to make sure that either run max or and is converted to a double first or else we'll get integer division which we just give us nor discarding the floating point there and in fact in mathematics in general and in programming as well angles are not measured using degrees but using radians or some people say radians and the Radian measures a full rotation not in 360 degrees blowing two times pi radians so like pi is 3.14159 two roughly so two times pi is going to be something like I suppose 6.3 roughly so we measure the full circle of rotation from as as being not for naught 360 but from north to 6.3 roughly and that has various mathematical advantages so you want to pick an angle here from naught to 2 times pi which is about 6.3 I think radians and we can use a constant pi constant from math page so let's let's use that let's say here two times and the constants called an underscore pie and it's about 3.141592 x runs here you might need to might need to include using namespace standard here but it seems like I I don't need it and so I'll go and put it in seems seems to be fine that we don't need to use the standard namespace to get this M on the scope I at least on this system anyway let's put this in brackets to make sure that we have a double here we're dividing it that numerator is definitely a double before we divide by the integer denominator because we have to have either the top bit numerator or the bottom day of the fraction denominator as a double in order to make c++ do floating point division this is choosing our handle and then we're going to choose the speed so M underscore the speed and again R and divided by R and underscore Max will give us a random number from nought to one point naught and we can multiply that by some constant let's let's try some number so I'm just going to experiment with some some number here and again it's floatingpoint number of course it's very important I tried different bayous I just experimented with different values and fine find found some that the work for one I'm I'm gonna do here so you can experiment too and see what results you get so we've got a direction speed and in updates now I can calculate how much to move the x and y coordinates by let's have a double Evans score Allison I am on score sorry let's call it have a double X speed equals and a formula yeah which you'll recognize if you've done any mathematics but if you haven't don't worry is if you've got a direction and speed like this and you want to calculate a X speed and a wife speed the X speed is the speed times the cosine of the direction and we're using kasam sign from master age and the wife speed here is gonna be an underscore speed times the sine of a an underscore direction these are just functions that basically give us the right values projecting onto the x and y coordinates so now we can add those on to an underscore X plus equals x speed and an underscore y plus equals y speed let's run this and see how it looks so this is very very slow as quitter and that's made this constant smaller for the speed so a bigger speed now it's quite fast actually I want to slow it down a bit try that and we'll also maybe have more particles let's go to screened age no sorry swarm rage and let's strike 5,000 particles which this computer at least can cope with and if yours calm you might want to stick with a lower number of particles but this this looks good on this computer at least go back to particle at CPP and let's run this now we've got an explosion and but it's beginning to look like an explosion but you'll notice is oval and not circle circular so let's at least fix that in this tutorial now that the speed by the way will at the moment it's going to depend on the speed of your system it's gonna the speed that these particles move up is just going to depend on how quickly this loop can iterate in main dot CPP and that's not desirable either would like like it to run the same kind of speed on any system so we need to fix that as well but the last thing I'm going to fix in this tutorial it's just to stop it looking oval the reason it looks oval is because of where we're taking a particle space and mapping it to screen space here in Maine dot CPP but the screen is wider than it is high and because we're trying to fit that minus one to plus one onyx and why kind of box neatly into the screen and because the screens wider than it is high we end up with it with oval we've mapped the particle space in such a way that gives us this oval the key to not having an oval there is to make sure that whatever the coordinate of the particle is we always multiply it by the same value both for x and y so the the range of the particle which is two that's from minus one to plus one is a range of two we then multiply it by half of the screen whipped for example two to get a range of the screen width if a lot gives us a different range for the width and height because we're using the height to multiply the range of particle range of two from minus one to plus one two to map that to the height so let's let's change these so that instead of using screen height here we're using screen width screen width now this is a step in the right direction so this means that the X&Y range of the particle is gonna be the same but the exposures now starts from it's not the center of the screen anymore but you can see that it is circular because the range of it is the same in both the X and y directions to fix that we're gonna have to rethink the height calculation a bit what we'll do is first we'll take the s get rid of some of this first we'll take the y coordinate and multiply it by by this the screen width divided by two because that will extend the range in a particle it will change it from two minus one to plus one that's range of two to the screen width which is which is fine particles are going to go off the edge of the screen off the top and a bottom but it doesn't matter because you know because the width is is bigger than the height but if they go off the top or the bottom it doesn't matter because we've made sure on a set pixel that were we aren't we aren't going to plot any particles that are off the edge of the screen so we can safely do this we don't have to worry about exactly where they are now we need to if once we've got the range right here this the moment if the particle is at position zero that will mean that it will be at zero on the screen which will be right at the top of the screen because I have sorry y starts numbering downwards so there's zero of why's at the top of the screen if we run this now week Atlas is right at the top here what we want to do is add to that half of the height so if we add to this screen colon columns scream Espace screen height let's use the autocomplete that divided by two now if we run this we get get it in the right position because if you think about it when it particles at the zero zero times screen width over two is still zero add half of the screen height and that puts the zero right half way down the screen which is what we want so I think I'm gonna leave it there for this tutorial this is a little bit any fishing because we're recap we're doing this division by two every time we go around this loop and if you want you can you could define a constant above the loop equal to the screen width over to and use that here to avoid having this calculation the division by two to avoid doing it every time you go around a loop which might be a good idea the compiler might optimized stuff anyway but best not to rely on it but I'm just going to leave it as it is for the moment so we'll continue to work on this explosion in the next tutorial we've got a few things to fix here because it's still not what we wanted to be it also looks very rubbish because while we're changing the colors of all the particles at the same time and we haven't more importantly as well we haven't got a blur on the screen we just sing individual pixels and it looks a lot cooler if you blur the screen so we've still got to tackle that but I'll leave it there for this time and until next time happy coding you