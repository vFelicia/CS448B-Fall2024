hello this is John from cave of programming comm and this is a tutorial on serialization in Java to tackle this tutorial it's good if you already know not only lots of basic Java but also how to read and write text files in Java because we're going to kind of build on that here so if you've seen my previous tutorials we've already covered reading or writing text files another thing that I'm going to use here is I'm going to use the try with resources syntax that was introduced in Java 7 so I'm going to read and write files in this tutorial using a Java 7 syntax which I've also covered in a previous tutorial and if you're using Java 6 you'll need to use a slightly different form of exception handling a kind of old version which you can find again in previous tutorials that I've created on reading and writing files so with those caveats let's proceed now I've already created a project in Eclipse here and I've created a few files serialization I should say what it is is if you take an object and you Syria serialize it it means turning that object into a kind of binary form into binary data and if you deserialize an object it means taking binary data and turning it back into an object and what we're going to look at here is serializing two files so which is often what people mean when they say serializing in java so we're going to take objects of this person class i've created and we're going to write them to a file and then we're going to see how we can read them back from that file so taking the objects out of the file and turning them back into objects in a java program now normally this would be both of those reading or writing will be part of the same program so if you have a program with let's say a open facility and a save facility then you could implement those if you wanted using serial serialization but rather than create a whole massive GUI program or some kind of menu system here to demonstrate serialization I've got two separate programs I've got one main method here in this read objects class and I've got a different main method in a write objects class so what I'm going to do is I'm going to create one little program that writes objects to a file and another program that reads them from the file but but bear in mind that normally reading and writing will be part of the same program and of course in Java you can happily have more than one main method in your program even though you then got to pick one main method as a starting point for your program when you actually run it but you're allowed to define as many main methods as you want and it's not uncommon to have a Java program that will have more than one main method because you might for example have your normal entry point of your program and you might have like a test main method that tests stuff as well for example so we're going to make use of that here and what I've got here is firstly I've got this person class that I've created and it's just a really simple class again building on previous knowledge though I hope you've observed absorbed by now we've got a simple person class with just some simple data a an ID and a name we've got a constructor that allows us to set that data and I've given it a two string method so that if we call system dot out dot println and pass it a person object of this class it will display in a kind of nice way I've got a right objects program here and what this is doing at the moment is it just says writing objects it creates an object what it creates two objects of the person class with different IDs and different names and then it's just using sysout to display those objects so if I run that we get this down here and I've got this read objects program and all this is doing at the moment is it just displays the text reading objects but doesn't do anything more so first let's concentrate on writing our objects to a file so I'm going to take these two object cr2 little simple objects with some data in them and write them out to a file now to do that I'm going to use a class Corp called file output stream let's call that FS and set that equal to a new file output stream and this class that's a stream data to a file as you might expect streaming just means kind of sending data sequentially to a file so we need to supply an argument to the constructor here which is the name of the file to stream to and I could supply full file path here but what I'll do is I'll just give it a simple name let's call it people bin the extension doesn't matter you can call it what you what you want but bin or data are typical for binary files it could be anything and although and if I just give a name without a full path then we'll write that to the working directory of this program and the working directory if I run it in Eclipse here will be the project folder here so I'll be able to see it down here in fact here's one I created whoops is one I created earlier let's go back to eclipse and I'm just going to delete that now because I wanna create it from scratch okay so let's import file output stream so I'll click this warning this error here and go to import file output stream now the second thing we've got to do is handle the exceptions and at this point you could go to surround with trycatch or even add throws declaration and throw the exception out of your main method what I'm going to do is use Java 7 syntax that try with resources that I described in a previous tutorial I'm going to type try here and surround the whole thing getting rid of the semicolon with brackets and then put the curly brackets in and then if I click the warning I can go to add catch Clause and we can catch the exceptions that this throws and the advantage as I described previously in a previous tutorial of try with resources is that this syntax will automatically call the close method at this object so it's going to call FS closed if you use a kind of Java six or before type trycatch block you need to remember to call FS closed later on in your program it's really important but here it will be called automatically if I put it all in a try block like that it's just that this is only possible in Java 7 or later okay so now this will cut a file not found exception which I guess will be called if we can't create this file and i/o exception can be thrown as well and that is going to be thrown if we can't write to this file for some reason so if you're going to write a robust program to distribute to endusers you need to of course handle these exceptions gracefully by popping up an alert or about putting a message or something but here I'll just leave the stack trace in because I just want to demonstrate the principle here so we've got a file output stream and the next thing we need is object output stream which are called OS I'll set that equal to a new object output stream and we need to pass to the constructor of that the file output stream object that we're going to use to allow this object output stream to stream data to our file here let's add the import by clicking the arrow I'm going to import up your stream now here I need to call a closed method myself say OS close of this object output stream otherwise I'll get a warning there I feel that there must be a more elegant way of dealing with this dealing with the exceptions here and closing things but this is the most elegant way that I can figure out so we'll stick with it here at least it it works but it's just kind of annoys me that this is being closed automatically and this isn't but I don't want to start nesting exceptions I personally really hate that looks so ugly so at least we've not got any nested exceptions here we just have to call closed ourselves on this even though the close method is being called automatically for this one but anyway so pretty simple and if you if you're used to writing text files you'll recognize this syntax we're just kind of taking some kind of output stream and passing it some kind of file output stream and using that to write to a file kind of a Russian doll type thing with one object being passed to another now we can use this object output stream to write these objects to a file so in between obviously in between opening and closing it so here we can say OS dot right and if I type right you can see in the autocomplete that we've got methods for writing all kinds of stuff here all kinds of data like right char and right double and so on you can write whatever data and objects you like to your file you can serialize whatever date you want you just do it sequentially and here what I'm going to do is I'm just going to serialize these two objects one after the other but there's no problem in mixing different objects or you could write objects and your own custom objects and write integers or strings or whatever you like you just do it one after the other so you can serialize whatever you like here let's say because I want to write an object of a type I've declared I'm going to use the right object method here and I'm going to pass it one of my objects so I got this object the variables called Mike and it contains the data this ID and this name and and once we've written that let's write another one let's say OS dot right object and let's write my sous object so this one here and that is enough to serialize the object to a file except for one important thing if I run this now what we'll get is a not serializable exception and it's mentioning my class here which I call person now there's this kind of classic interview question or job interview question or exam question how do you make a class serializable in java and the answer is very simple in a way so I'll go to my class here I want to make this class serializable in other words I want to make it possible to serialize this class just like I can serialize strings and doubles and all that sort of thing all I have to do is implement this serializable interface so how do you make an object how do you make a class serializable implement the serializable interface so I just need to type here implements serial is double and whoops I need either and I need to import serializable capital S because it's the name of an interface and interfaces in classes always start with a capital letter in Java and now hey presto we can hopefully do this let's run it so notice the interface doesn't have any methods in it all we've got to do is just say that we implement it and we don't have to do anything else there and if I run this let's select write objects and click run and now hopefully well we haven't got an error so hopefully we've written that file and because I wrote it to my working directory of my program just with a simple file name now if I click on a project right click and go to refresh in Eclipse it should appear down here he's peopled up in don't know what that is I think that's something that was created earlier maybe I'm not really sure but I'll delete it anyway because this is what we're interested in so we've written that file we've written two objects to that file and now let's write some code that can read those objects so I'll go to this read objects little program here and now we want to file input stream instead of a file output stream so file input stream I'll call it f I equals new file input stream so again I need to pass it the name of the file that I want to read from now which is again people dot bin and that's surround with try again using this Java 7 try with resources syntax which will close this automatically and I'll import the class and add the catch clauses here we go so again the file not found if the file isn't found an IO exception inputoutput exception for if there's a problem reading from the file and again if you do if you use a different exception handling syntax an olderstyle you must call fi dot close don't forget to do that and now I'm going to create a object input stream as you might guess object input stream instead of object output stream like we have previously let's call that OS and set that equal to a new object input stream and pass in the file input stream there don't forget to call OS close like that and let's add the import and let's save that so this this looks fine and now I can read from my file so let's we're going to have a purse we know that we wrote two people objects so we're going to read to two person objects one after the other let's say person person 1 equals OS stop read object and because this returns a object the kind of grunt parent object class I need to cast this to the actual particular object that it is a particular type of object which is person and this also if we look at this error now this throws another exception let's click on that and go to add catch Clause so we'll catch another exception down here and what this is is as you can see you can read your object in a different program to the one that talked to the one that wrote it if you want to although that's not typical but we are doing here and that means that read object might read a object of a class that doesn't even exist in this program and if that happens it's going to throw class not found exception as it happens here we do have the person class defined in this program it's sir it's I've got my main methods all in the same default package here so there's no problem but this will be thrown if you try to read something from a file and you don't even have that class defined in your program let's read our second object so person person to equals but the typecasting and n OS read object and save that and to show that we've read those correctly let's go down here and put into this out person 1 and this out person 2 and say this and let's run it so let's go to make sure on read objects and click run and now we can see it says reading objects and then we've displayed our people and we've got the objects that we wrote might consume and of course we've got them we've read them in the same order that we originally wrote them in here so you can use this to implement saving and loading functionality in your in your programs which is which is quite handy I'm just going to I want to show you one other little thing you may have noticed if you've been doing some lot of programming in Java sometimes you get this warning in Eclipse and I'm not sure whether this is coming from Eclipse or from the Java compiler but it says the serializable class person in this case does not declare a static final serial version UID field of type long and to get that warning to go away and click on it and you could go to our default serial version UID but let's go to our generated serial version UID and what it does is it just adds this static long field is set to basically some random number and if you just want at wanting to go away then you can just do that and forget about it but what actually is this well let's let's take a look if I go to write objects and we'll run it so I'm writing objects and writing my person objects to this file actually I'm overwriting the original objects now so I'm writing them again and they've got this serial version UID now let's change this serial version UID to like I just changed it for two or three at the beginning say there and let's run read objects here so I run this and it says gives me an error it says invalid class exception and we've got some stuff complaining about how we try to read with this serial version UID but they were written with this serial version UID and indeed if I change this back to a for now and run my read program again read objects then it reads fine so all this is is it's an ID that in order to deserialize objects that you've previously serialized in order in other words in order to read objects from a file that you've previously written to the file if they've got this defined then it must match the class that you wrote with must match the class that you read with or vice versa I should say you must read with a class as the same serial version UID if it was defined to start with and all that is is a way of checking that you're reading with the exact same class that you wrote with so you could write to a file and then years later you try to use a different version of the program to read from that file and if the class has changed a lot if it's changed significantly at all in fact since since the last version you would change this serial version UID and that's one way of saying that this class is different you can't read this file with this version of the program anymore so by changing that you mean it means that you can no longer use the new version of the class to read from the file because it's just changed too much so if you added more ID or deleted these or something you could change this to stop people trying to read with that new version of your class as far as I know that's really all it's for maybe not a tremendous lot of use but it gives you a way of checking that your reading with the same class that you wrote with and that's all there is to it so I'll leave it out for this tutorial a lot of stuff in one tutorial and if you're a bit lost then you might want to go back and check some other basics like this try with resources reading and writing files and possibly defining classes and stuff like that but if you followed it congratulations and this is one of the most complicated things that you'll find in like the really sort of core of Java and it's a popular topic on exams and job interviews as well you can find more videos from me on wwk the program comm so if you go to WWE of programming comm you can find more free courses there as well as premium courses which include free videos that you can also view for free on Android and jsps Java swing and Perl as well at the moment actually spring I'm working on now so that's in the pipeline and yes so check that out and until next time happy coding