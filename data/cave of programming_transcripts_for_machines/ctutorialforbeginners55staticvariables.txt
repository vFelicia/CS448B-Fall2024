hello this is John from kof programming. comom in this tutorial we're going to look at static class members in C++ now at the moment this is the last really important topic that we need to cover before we can go ahead and uh start coding a real program so unless I think of something else which I might in the next tutorial we can get on to real programs so um let's let's take a an example here I'm going to create a class and um I'll call it test and I'll I'll just Define it here in the same file as um as the main function although normally you put class in their own header and CPP source file but for convenience in this tutorial I'll just Define it right here uh the the actual Eclipse has put in uh a semicolon after the class definition for me as well as the closing bracket there which is which is very handy so we've seen that if if we gave this uh Class A an instance variable um like int um let's call I'm going to call it count for reasons that we'll see later on then every every in every particular object we create from this class in other words every time we instantiate the class every time we create an object from it because the class is just a kind of like a template a blueprint every single object would have its own count so every object would have it its own version of that count variable which can be set separately for every object and we've covered that so far in these tutorials but if you declare a variable static it means that um there's one version of that variable that's shared for all the objects so so the variable becomes associated with the class not the object so to to see that um let's let's make this public so normally you don't make most of the time you don't make variables public but to make this clearer let's make this public and I'm going to declare it static to mean that shared with all objects of this class It's associated with the class not with particular objects now when we create a static variable like this we have to initialize it somewhere because remember normally this variable will be um memory will be allocated for it and a value will be probably given to it as well when we create particular objects but because it's static we need to do that separately somewhere else so see normally this this will be in the H header file and then we'd have a cppp file and um we would normally initialize the static member variables in that CPP file so I'll normally you put this in the CPP file a bit that follows and what would what would type is U we need the type of the variable and we need to specify the class that associated with we put two colons like that and then the variable name and here we should assign a value so let's set it equal to seven now we don't need an object to access this variable because it's not associated with objects it's shared for all objects and associated with the class so we could do stuff like see out test and again we need double colons now to access it count and endler so we're using the class here not an object of this class let's run this and we find that we we get seven now you can you can also create uh static methods and um most often you would access static variables in static methods and again static methods are associated with the class not with particular objects so um let's let's create a public section here and let's make this private let's call this static void show info so static methods are access via the class and they can only access static variables uh if you think about it you can't access a instance variable a nonstatic variable from a static method because the um the static methods as well as the static variables are associated with the class so there's not necessarily um it's not necessarily true that any instance variables are actually in existence there's not necessarily any objects of this class there could be but in this case there aren't they don't have to be so because this is static we can access it in a static method and we can say see out count so we don't need any pref prefix referring to either static or nonstatic variables um when we're actually within the class itself so now we can call that method via the class because it's static the actual method is static so we say test colon colon and I can use the autoc complete control space here show info let's take a look at that and we'll run that and we get seven so St static um static methods are great um for example for um if you've just got some um some function that needs to take in some data and return some data but doesn't actually do anything with any instance variables then you might choose to make it static a classic or I show I'll show you a couple of classic uses of um static variables here so one use is you can you can Define constants with them so let's say that we want to Define um a constant called Max for some reason whatever Max is or it could be Pi or something you know uh we can say static int and now it's it's traditional with constants to put them in uppercase you don't have to but it's a traditional thing to do to make it clear it's a constant let's create a constant called Max and I'm going to make that cons so I need the cons keyword in there as well and because it's const we can now assign a value to it directly so we don't have to um do this initialization here for constants you have to give them a value when they're actually declared and then you don't need to do this bit down here so now we could say for example see out well let's make this public because um if we want to access it from outside the class and it is it is um quite common to Define um static constants that are public that's that's not a problem they can't be changed anyway because they're constant so there's no there's no drawback to making them public uh and well often you should make them private if they're only going to be used within the class but often you declare a static constant specifically because you want a constant that you want to be able to access uh just via the class um so let's take a look at this we can say test colum column Max and endler and with a bit of luck that should work so we get now 99 let's just put a note here um initialization initialization of con can be done well must be done must be done right here now um one um one use of a static variable there are lots and lots of uses that they are commonly used but one kind of classic use that you see for example on exams is to count the number of objects you're creating because remember static variables are um static variables not static constants but static variables um are not only shared between all the objects of that class but they can be accessed accessed via all the objects of that class and because they're not constant they can be changed by those objects as well static constants are again can be accessed from all the objects um but um they can't be changed because they're constant so let's look at this static ink count and let's initialize it to zero and let's create a Constructor here so let's say um test it's the Constructor and now we can increment count in that Constructor so um let's let's create some objects from this class so now if I run the show info method so what's happening is um we we're not running the Constructor here because we're not creating any objects we're just using show info with the class and outputting its value and the value that's output is the value we initialize it initialized it to to start with but look at how that Chang is if we create an object let's say test test one that will cause the Constructor to run because Constructors run when you instantiate a class when you create an object from it in other words that will increment count and then when we do show info afterwards we'll get um count equal to one let's run that so we see that um we've um The Constructor incremented this shared shared uh static count remember there's only one static count variable shared between all objects of this class because it's static that's the point of static let's create another one here let's have test two now if you run this we're going to see that now the count is two so we're effectively counting how many objects we're creating which is useful and uh quite a common thing to do is to use that count to initialize ID for your objects so let's create a nonstatic field so in ID so this is going to be perir object it's not static what we can do is we can say ID equals count Plus+ so um we've actually got two kinds of Plus+ operators in C++ if we put Plus+ after the variable its value will be used first so in this case a assigned to ID and then incremented if we put Plus+ at the start it will be incremented first and then used so this version is called the prefix increment operator the version we had before is the postfix increment operator let's let's see that working so I'm going to create a nonstatic method here so um let's say public int get ID and that's going to return the ID of the object which we created by using this count so it's going to be unique because every time we create an object we increment count and we assign the ID based on that oops thinking of java here typing public twice okay yeah we need it like this public is just a kind of a section in C++ right so now we can say here we've got test one let's say um see out test 1.g ID and let's do that after test two as well so if we run this now we see that the the test one object whoops I need to also put in um endler there I think I've got everything right here let's let's try it see if it works whoops did something wrong there um yeah I've got the wrong kind of um put to operator okay so um what we're getting now I I should put some text in to make that clearer um object one ID and let's put that down here as well so down here object 2 ID so if we run this now we see that object one has id1 object two has id2 so what's happening is when the when the class is defined we initialize count to zero when we create an object from the class which we we do here what happens is um count is first incremented from 0 to one and it's assigned to ID so that object will have always have ID of one and that's what we're seeing here when we create the second object count is incremented again to two and then assigned to um the ID of the second object so the second object's ID is going to be two if we use the postfix increment operator that would first assign the value of count and then increment it so count would be zero and the first time it's used it would be signed to ID then incremented and now our IDs would go from zero upwards so the ID of object one is zero ID of object object two is one so as always uh this seems very complicated when you just watch a video on it but if you try it yourself you'll see it's it's not that bad um and at the very least even if even if you feel that you don't fully understand it if you after coding this yourself you'll definitely increase your understanding of this a lot it's not rock ET science but it does take a bit of practice to get it into your head so what I'd recommend um is first try defining an object and give it a public static um constant variable and check that you can access that via the class and when you've done that try to implement the stuff that I've done here and I'd suggest going through it the way I've gone through it um give it give your class a static in count and then check that you can output count make it public to start with try defining a static method that accesses count and access the count via the static method then try incrementing it in a Constructor and then try defining an ID and give assign the value of that ID based on count also try to postfix and prefix increment operators as I've done in this video so if you if you try all those things and you get them work then you'll be well on your way to having a really good understanding of this so just just for a really quick um summary of that so um let's let's say ex exercises so Define and output a public static constant try that Define and output a nonstatic field um output a static field with a static method um try incrementing um static int field with postfix and prefix operators increment operators so that's that's like um e do e e dog dot that's like count postfix is Plus+ and prefix is Plus+ at the beginning and also try assigning object ID based on count let's say static count incremented in Constructor so that'll give you a pretty good um workout to get you going with this and of course if you feel like experimenting that's even better so don't forget that normally you put your class in a header file so it's it's worth doing that and um put the definition of the methods in a source file as I showed you to do earlier in this course if you just do it like this it does work but it's just not um not the usual way to do it let's say and don't forget that your nonstatic U sorry don't forget that your static nonconstant variables in other words your your static variables they have to be initialized somewhere usually in your CPP source file like this okay so that's it for this tutorial we're going to go on to look at a particle explosion program starting in the next tutorial so until next time happy coding