hello fellow scratchers today we are going to unravel the mysteries of word wrapping specifically how to extend our text engine to wrap any length of text neatly within a specified rectangular boundary but how are we going to get scratched to break up our text at the right points or to handle extra long text that overflows an entire line well stay tuned to find out as we continue this awesome series coding a text engine in scratch so as we begin load up your episode 2 projects and let's save them as a new copy but this is episode um oh okay you got me this is episode 3 i promise anyhow guys let's get scratching so word wrapping this will look cool if we have some kind of page or dialogue to write upon to create a new sprite named page for the costume i'm going to draw a simple rectangle in pastel yellow like a postit i'm making sure it's nice and central now we can spend lots of time later making this look awesome but for now this will do when you run the project you may find that the text has moved behind the new page sprite no problem click into the font sprite and for the time being under the when i receive test script just drop in a go to front right away the text springs to the front great so we have a nice page but we don't want our text flowing right up to the costumes edges no indeed so we'll try to define our actual text bounds as a rectangle within this page giving us a simple margin a rectangle can be defined by its top left and bottom right points we'll call these x1 y1 and x2 y2 let's make a new custom block to make this easy to define set page left with an input of x1 the label top with an input of y1 and then a label right with an input of x2 and the bottom label with an input of y2 click to run without screen refresh and we are ready now these values we will store in four new variables first one page l for page left setting it to x1 and page t for page top setting it to y1 page r for page right setting it to you guessed it x2 and lastly page b for page bottom setting it to y2 so let's set up the page dimensions now under our when i receive test script drop in the new set page block so how can we tell what screen location the top left corner should be set to hmm tricky in scratch 3 well if you have scratch addons then actually it's not i just hover my mouse at the location i want and the mouse location addon shows me where i am it's like negative 150 by 90. no need to be super accurate and type the value in but if you have not got scratch addons then how can we find out our location well how about this when space key pressed ask mousex and we can ask mouse y2 then hover over the position we want to know and press the space so that's an x of 159 but of course we want the margins to be symmetrical so i'm actually going to put in an x of 150 and then i'll reposition again and it's a y of negative 31. i just pressed enter to find out okay brilliant so we have our page bounds defined next up we need to make sure when we write to the screen the text will appear at the top of the page rather than at our mouse cursor that was so episode 2. so we make our way over to the define right block when our text is left aligned the position of the text is set here set xx to the input x well no longer these inputs are going to go in favor of using the page bounds and for the left align text that will be page l the left edge of the page now before i forget we also want to remove the set y block here we will assume the y position is already set before we begin to write to the screen that's a bit of a change but don't worry about that right yet now what about the other alignments let's look at the right align text that will want to be offset relative now to the right hand edge of the page so we enter page r page right and subtract the width of the text and that's it centering takes a little more thought we need to find the center of the page bounds to calculate this we need to take the average of the left and right edges of the page that is the sum of page l and page r and then we'll need to divide by two but hold on because then we subtract with divided by two well if these are all being divided by two we can simplify this by subtracting the width from page r plus page l and then divide the whole thing by 2 afterwards got that excellent but now the x and y inputs are completely unused within this custom block but also the sprite's y position is never set what we'll do is come back over to the when i receive test script and drop in a set y position right before setting the pages dimensions setting y2 of course page top now our text will begin at the top of the page let's slap that green flag and see what we've got well yes the good news is that our text has appeared somewhere near where we wanted it to begin the downside is that both lines of text are located one on top of the other not surprising considering the y position of our right block is no longer used easy to fix scroll back to the define right block and down to the bottom and once we've written out a line of text we want to advance to the next line so change y by and we are moving downwards so use a zero subtract and drop in the line height variable there we go looking much better i'm glad we set up that variable so every use of the right will advance the text to the next line so what is the point of keeping this y position input now well absolutely no point at all let them be gone edit the write block and delete the x and y labels and inputs wow i hope you did make a copy of your project because it's a hard journey back from these changes i'll just tidy up these orphaned variables and as you can see running the project shows no ill effects from the changes since those inputs really weren't used any longer and if i duplicate the last right block you can see that the auto advancement of the y position works a treat without any further work required really like how that is working let's also check out the center alignment so that now is centered on the page rather than our mouse cursor and the writer line is likewise now aligned to the righthand edge of the page bounce very cool so then this is where it gets exciting we've mastered positioning and aligning to the page bounds but if we enter a longer line of text in here the text is still allowed to overflow the page bounce and this looks as ugly as an ugly thing and that's very ugly indeed it's obvious what our next job must be the most obvious fix might be to place a limit on the x position in the right script check if xx is greater than page r the right hand edge of the page and then set it back to the left edge page l then of course make sure to change y by the negative line height to move the cursor down to the next line so if we were to drop this in after changing xx then not bad right looks to me like we have some rudimentary wrapping going on and yes we do but this is not word wrapping no this is word break wrapping see how the word mostly has been split into midword this is not how we want our wrapping to work no word should be split unless it's absolutely necessary so what do we do now well we really want to treat an entire word as a single unit and therefore move any word that does not fit on the page onto the next line as a whole to detect a word all we need to do is look back for the last space before we overflowed the page but hang on if we've already been cloning or stamping letters to the screen then it's already too late the deed has been done so we must detect spaces before we hit the page bounds and before we draw anything to the screen the process should look something like this work out the page width the text length must not exceed this we already have a variable i that as before represents the index of the letter to be written to the screen one is the first letter to the next etc but this stays right where it is while we look ahead to find out what text will fit on the line so we have a new variable wrap i used to trace forward looking for spaces but as we go we will also sum up the letter widths in the variable width as before now this is new if we find a space character then we make a note of where it is storing the last found index in safe i and the width in safe width this keeps a record of the last safe wrapable position if at any point the width becomes too wide to fit on the page we have the safe variables to go back to for drawing our text but otherwise if all the text does fit then we just use the wrap eye and width as they are does that make sense i think so cool then delete the little experimental if and before we add any more code i note this right block is getting really rather long so it's a good time to try to split it up with some custom blocks a prime candidate being this alliance scripts here from the if align equals c to the set i to zero yeah make a new custom block naming it calculate alignment and it will need an input named align just tick run without screen refresh and ok we'll attach this define to the alignment scripts and make use of the new align block here where we took the scripts from we just need to make sure to pass through the align variable so it knows what alignment we are using brilliant join that all back up and i'll move my scripts into some free space if i can find some and a quick tap on the green flag to ensure things are still working tickety boo and yes no changes good change um good news uh yeah so moving quickly on let's get those new variables made so that we can start processing our first line of text so we need a wrap i and for this sprite only safe i for this sprite only save width again for this sprite only and one more i'll name c this one is for storing a single character that is a letter of the text we are processing again make it for this sprite only i'm going to hide them for now okay so because the text will be processed a line at a time we can no longer use a repeat length text here for this reason i'm going to start i at 1 instead of 0 and then we can use a repeat until i is greater than the length of text instead move all the contained scripts over into the new loop not forgetting the change y from the end and we can replace that old repeat with this new one great of course since we start i at one instead of zero the change i by one needs to move down to be the last block in the repeat do you see how this works we start at letter one and check each time that the letter index has not gone past the end of the text string again we can give it a test and it still is working but no magic wrapping yet oh no this is what we'll start work on now you know what make one more variable that i forgot name it page width for this sprite only we want to know the maximum width of text that can fit on the page we get that by setting page width to a subtract operator and subtract page left page l from page r page right stick that at the top of the write script now let's set up the wrap i variable ready to start scanning across the text set wrap i to and this time yes we do set it to zero this will make comparing the i variable to the rapid variable that little bit easier you'll see and here we go make a custom block naming it find text wrap index and definitely tick that run without screen refresh we'll make use of it right away sticking it in after we've set wrap eye to zero but before we calculate the alignment that makes sense as we will need to align whatever length of text comes back from using this new block okay so this new defined block it's going to initially have a very similar function than our old get width of text block in fact it is destined to replace it altogether however we don't need to set txt as this has already been done in the right script before we get here what we do need is to set width to zero the loop again can't use a repeat length as we can't say how many letters we will need to repeat for so let's instead use a forever loop we'll find other ways to break out of it so don't worry it won't be forever really now duplicate the scripts from the previous get width of text loop into our forever loop this too wants to check along the text calculating the combined width however it's using the wrong variables switch the i variables or wrap i variables including the one in the switch costume here great that's right but we will need to check the value of this letter to look out for spaces so rather than use the letter of block more than once to get the same letter again we'll set the variable c before we switch costumes to the letter wrap i of text and then pop that c variable in the second switch costume so now we are free to check if c is equal to but for starters don't put a space on the right hand side no instead have the empty value we get this result when we've reached the end of the string the text and there's no more letters so we should stop this script drop that in right after setting c to stop this forever loop and drop back to the main write script nice we can test this now by coming back to the right script and switching out the length of text for a wrap i this will stop the text from writing any more than the fine text wrap block asks us to write out how much is that though run the project and of course it's still everything so don't panic we've not done anything wrong this is all good news now i don't know if you had your alignment set to left like me or we're using center or right aligned at this point but we have a little change to make in there before i forget find that define calculate align script now see how it's getting the width of text well we can scrap that now the width will already have been found by our new find text wrap script remove those blocks they're no longer needed so looking at our running project what we should do next is start looking for the gaps between words the space letters find the define find text to index script to begin with just duplicate the ifc equals check and this time we will enter a space in the right hand side comparing c to space stuff that under the other if and why are we stopping the script when we hit a space simple it's a great way to check that the script is working run the project the how oh yeah i love it both lines of text have been cut off just after one word exactly what we would have expected so we can move on if you can remember the plan of action when we find a space we don't want to stop no we want to record where the space was by setting safe i to the current index that's wrap i and also we want to record in safe width the current width that's better but this is only useful once we also detect that our text has become too long to fit on the page so at the bottom of our forever loop after changing x by the width of the last letter check if greater than width is greater than our page width and if it is then we will stop here but before we do we reset the wrap i back to the last recorded safe i and likewise resetting the width to the last recorded safe width before finally stopping this script oh yeah that sounds perfect we gotta give this a test smash the green flag okay now what have we got here the rain in spain certainly does fall but no longer mainly in the plane mainly didn't fit on the line and has been cut off and we would expect it now to wrap onto the next line instead but we haven't coded up it yet now i'm really excited to get this fully working and we're so close now so find with me the define write script once more once we've written out all the text that fits on a single line we need to be able to continue processing the same text string looping back up to the top of this script again to find the next text wrap index okay so in that case let's wrap this repeat loop up in a custom block create a new block naming it write letter feed run without screen refresh put the whole of that repeat script into there so the find index and calculate size blocks will need to be repeated but the set eye definitely needs to go above these then outside any loop we'll use another repeat until block after setting i repeating until yes bring back the i is greater than length of text check once more we can pop in the two custom blocks to get them to run until all the text has been processed split and then written to the screen by dropping in the new right letter feed block there now it doesn't make a difference but i'll move the final change y block up into this repeat loop just so we can see it oh my goodness guys if everything has gone right then we are ready to run this baby smashing the green flag and oh yes look at that perfect wrapping text at least it looks like it we'd better do some more tests try changing the alignment right aligned check centered yes check so cool how it aligns to this box now of course to really see this wrapping in action how about we cheekily pop a mousex into the set page left input now the left margin is controlled by our mouse and we get this so cool dynamic wrapping isn't that crazy it's so buttery smooth and it works just as well with other alignments man it's cool seeing this wrapping working like this i've just got one more test case to try and that's to see what happens when we try to write a single word longer than the width of our page oh no that didn't work out well at all did it so why didn't this break onto a new line do you think the answer is obvious it doesn't have any spaces in it to split at this unfortunate fact means we'll need a special case to handle it scroll over to the define find text wrap index script and go down to the bottom we know that for long words this width will indeed be longer than the page we just need to handle the special case of no spaces with an if else check we check if safe i is greater than the empty value safe i is only set when we found a space we should ensure it does start blank though by setting safe i to the empty value before we begin our forever loop so now if safe is set then we did find a space and we can revert back to using the safe i and the safe width values as planned hey move this stop this script under the if else because both branches are still going to break out of the loop so then if no space was found in this else block then this must have been a long line of unbroken text like those w's just now well then we need to just break right here only because we did overflow we should backtrack by only one letter to the left change wrap i by negative one the width is a little tricky to fix we need to subtract the width of the last letter added we can duplicate the change width line and use a subtract block to change the width by zero subtract the letter width cool run the project oh yes i am really really pleased with this the wrapping is working exactly as it should to a very professional level indeed we are right on track to getting this to function as a scratch dialogue system or gosh why not even try creating a functioning word processor what do you think could you do it well we still have a good number of features to cover but if you're enjoying these episodes please please smash that like button i spend a lot of time making these videos for you and to keep them free i need as many people to love the project and subscribe to my channel as possible thanks guys i appreciate it now the final stage of this tutorial will be to bring back the option to slowly display text but perhaps with a cool animation if you like that the real trick though is how to also allow for fast skipping through without accidentally skipping too much text we also want to allow paging of the text for when it overflows the bottom of a page love that little animating continue option then we can consider the entrance and exit animations for our dialogue page and whether to add a cool hero icon to highlight who's talking and all this operated through a simple yet powerful list language really oh gosh wow i'm dead excited to wrap this all up and share it with you but i'm afraid that's all we've got time for today that just leads me to say thank you for watching have a great week ahead and scratch on guys