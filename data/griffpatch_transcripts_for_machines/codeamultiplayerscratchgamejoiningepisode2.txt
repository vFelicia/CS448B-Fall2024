foreign ERS welcome back to part two of our online multiplayer scratch game tutorial today we'll be pushing past scratch's Cloud available limits looking at how to smooth out our Cloud player's motion beginning to add the exciting online code ready to handle that large influx of players waiting to join your game now you know once this series is done we'll have to organize some official dates and times so that we can jump on scratch together to play through the best of your shared online projects that will be fun but where were we ah yes before we begin coding let's take a look at why our player movement isn't yet smooth and what can be done about it if you remember from episode 1 our player moves enough forever loop at 30 frames per second nice and we diligently set our Cloud available one to the position after every move the problem is scratch's cloud rule number two states that scratch will not send Cloud billable updates faster than 10 each second therefore two out of every three updates are being lost in the post the end result is shopping movement at a mere 10 frames per second well two solutions spring to mind we smooth out the missing animation frames in code using position tweening this can work well for some game styles like Slither IO but in a platformer it leads to a rather unnatural floaty movement that doesn't follow our players movements exactly so instead we will use motion buffering this doesn't rely on any guesswork instead recording our players exact movements in a buffer hey scratch list then this data is packaged up every three to four frames and sent in a single Cloud variable update well since no position data is now lost we are able to play back each player's movements exactly as they were recorded Perfecto the other feature we're going to be working on today is extending our multiplayer code support player joining so no more of that pressing two key ah nice one so load up your projects from where we left off in episode one and now is a good time to save it as a new copy for this is episode 2. guys let's get scratching as our project grows it will be best for us to separate the player sprite from the multiplayer Sprite this will make it simpler and easy to backpack into other scratch projects so name our first Sprite my player and then duplicate it naming the copy as Cloud Player this will become our backpackable Cloud engines right but we'll Begin by tidying up the my player Sprite click back in there now all we want to keep is the simplest player position script so we can delete the when 2 key press script goodbye then read numbers custom block be gone the set encoded string and following blocks thank you for your service and lastly the right number script ah so we sure cut that down time to start building it back up we always begin with initialization scripts to set things up broadcast and wait with a new message cloud setup now we want to record The Player's motion this will now be as we just talked about into a scratch list name the new list my values to send leaving it for all Sprites so it can also be accessed by our Cloud Sprite and we add the current sprite's exposition and Y position to that list the result if we smash the green flag is our list get flooded with new X and Y positions at a rate of 30 per second and yes it's currently growing out of control but once we start sending this data over the cloud we'll also be removing items on the list to keep it under control so broadcast a new message Cloud tick and we'll let the Cloud Player Sprite take on the rest of the work this way our main game code could stay in this Sprite but all the cloud related work gets done in the cloud player Sprite great we'll move on to the Cloud Player Sprite now and first things first we can strip out any unnecessary scripts deleting the green flag script and yes even the when to key pressed script that only leaves our beautiful encoding and decoding scripts make sure not to delete these but you can scroll them off screen to give more space to work in when I receive Cloud setup make sure we hide this Sprite as we begin with no visible Cloud layers then delete all all of my values we don't want any previous game movements being included in a new game we'll add more to this setup script as we go but for now we'll move on to the when I receive Cloud tick this will trigger 30 times a second once after every player movement but this time we only want to encode and send the player movements once every three or four broadcasts now to keep track of this make a new variable naming it Cloud tick for all Sprites and we'll change it by one each tick of our game next to prevent triggering until the third or fourth frame will use a mod block if Cloud tick mod some number of frames is greater than zero then stop this script now if we were to place a 4 in here the modlock would cycle the cloud tick around in counts of four resulting in this guard condition only letting our code below execute every fourth frame okay to make this extra clear I'm going to wrap this in a custom block name it send my cloud data after with a number input named count and another label to take one without screen refresh we can make use of this block here and fill out the number of frames to wait for frames for now then plug the count input into the right side of the modblock like so it would be nice to test this as indeed counting off four frames correctly so how about we delete all from my values only temporarily as that will help us to see things are working now smash that green flag and there we go our my values list is only filling as far as the first four pairs of X and Y values before it is being reset by our delete script ready to be refilled once again over the next four frames great test but rather than simply deleting these buffered X and Y positions our goal is to First encode and then send all that data to the other players of our game with a single Cloud update start by removing that delete all and instead prepare to encode our values by setting encoder string to the empty value we want every item in our list to be encoded so repeat for the length of the my values list then simply write out the first item using our beautiful custom block write number item one of my values two in the encoded string after it's written we can delete that first item from the list what I love about this trick is that any remaining items in the list will move up to take its place so we can continue looping around processing the first item until there are no more items left and every item has been encoded well hoorah all that's left to do is set our Cloud variable Cloud one to our fully encoded string and it must be testing time smash that green flag okay this is cooler than it looks the my values buffered list is filling up in cycle to four frames as before but this time when it fills we can see that cloud one is then set to a much longer encoded value that looks very promising indeed obviously what we'd love to see next are these values decoded in other browser windows then we can finally see that smooth player motion that I promised you in action well we are having to start over with our player 2 scripts so let's piece together what we will need to do we'd load the project and notice that the cloud available is already set to some value probably left over from another game so we just ignore it meanwhile in another window another player is already moving around and boom they have recorded all frames of motion and updated the cloud variable this causes the cloud variable in our first window to also change and this is our trigger point it's this change of value that we need look out for as it tells us another player is active and playing the game how do we know if a cloud available has changed naha we keep a record of the previous value of that cloud variable in a list then if any Cloud variable is different from our recorded values then someone must have changed it so scroll up to our setup script and oh talking of setup we should have initialized Cloud tick to zero right we'll make that new list Cloud values false Sprites this will record the last known values of all the cloud variables and we delete all of cloud values before we begin now we are only using one Cloud variable at present so add that to the cloud values list cloud 1. if we run the project we can confirm that it appears and as the cloud variable subsequently changes we can now tell in Code by comparing these values ah except there is one slight complication when it comes to scratch and comparing very long numbers here is a script I prepared earlier I'm setting Val to a number that is 250 digits long just shy of the 256 digit Cloud length limit tell me does Val equal Val in this case well I should hope so too and as you might expect it doesn't equal this other random number but and this is where it gets a bit weird does Val equal itself plus one well of course not except apparently it does her to understand why you'd have to know that when scratch Compares values it assumes you are doing a numeric comparison on two numbers oh which we are and so scratch tries to do the math but these numbers are so big that in doing so it loses some of the Precision and the result is that the two numbers appear the same the only safe work around is to force scratch to compare the values as text strings instead by cunningly joining a letter onto the start these are no longer pure numbers so scratch treats them as text values and a comparison is all good so let's do that and join the letter c with the cloud one variable as we begin using more Cloud variables we'll have to come back and add them to this list too okay so we know another player has sent this message but how do we know which player it was gosh it could even have been US changing it right a valid option would be to encode each player's username in with the rest of their cloud value but remember how we are testing our game multiple windows with the same user logged into each note we need a unique identifier for each scratch window even when the username is the same not a problem make a new available named My Player uid for Sprites this will hold the player's unique ID then at setup set my player uid to a pick random lock with a random number between one and nine million 999 999 that should be large enough to make it practically impossible for two players to be assigned the same number every time we run the project we get a brand new ID brilliant we just need to tag this on to the start of every cloud methods that we send down in the send my cloud data script pop in a right number block immediately after the encoded string is first cleared and pop in the my player uid variable sweet now we can begin to watch for changes to our Cloud variables scroll up to the when I received Cloud tick script and we'll add in a new custom block process Cloud item with a number input which then another label value and a second number input new value remembering to take the run without screen refresh block okay so we'll use it before we try to send our own cloud data that way we can check for changes before we overwrite the cloud value with our own player data we'll start with the only Cloud variable we are using Cloud variable number one and pass in its current value but remembering to also join it with the letter c so it can be accurately compared cool and we'll do that now if the new value of the cloud variable is still equal to the last recorded value which is stored in item which of cloud values that will be item one then if they are the same then we can ignore it this is not a new Cloud communication so stop this script but if it was changed well then that's more exciting I wonder who changed it but don't jump the gun if the cloud value has changed we should update the cloud values list so it too has the latest value replace which of cloud values with the new value we can see this in action by running a project and now the cloud values list is also being updated as the cloud variable changes cool so the cloud variable has been updated and we want to know who updated it let's decode it and find out set encoded string to the new value of the cloud variable and then set encoded index ah not the first letter of the encoded string this time but the second do you know why because we have to skip the first letter C of course therefore we start on the second letter Val equals read number from encoded string this will pull out the first encoded value and that will now be the sending players unique ID yes that's exactly what we wanted now there are two cases where we might want to ignore a new communication if Val happens to be less than one then this is not a valid ID and something has gone terribly wrong but otherwise this is the second case if uid is equal to my player uid yes we also will be detecting our own cloud messages since we share these Cloud variables so in both of these cases we stop this script otherwise we'll end up seeing another copy of ourselves walking around the game funky but not what we want here it would be nice to give this a test at this point so to allow us to see another player's uid make a new variable naming it player hash for this Sprite only and just for the time being set player hash to the Val the other players uid before we test go back to the setup script and set player hash to that empty value right do you remember how to test the Project's side by side we have to make sure the project is saved and then load up two browser windows for the same project and run them both what you should find is that the left Windows Mario player uid my unique player ID is now showing up in the right window under the player hash variable and vice versa for the right hand window well this is excellent this shows that each player is able to send their unique ID across the web and the other projects are able to decode and display it ignoring their own cloud updates yes they are both aware of each other's presence the next step is to be able to identify if this is an existing or a new Cloud Player in other words have we seen this player uid before to keep track of players we'll have a new list named player uids as we decode a cloud message if this contains a uid we've not seen before this is a new player and we add them to the list not only that but we also introduce a second paired list player data in which we stuff the full Cloud message this ties the player uid to their latest posted data ready for processing later on and the technical name for this pairing is a data dictionary if on the other hand the decoded uid does exist in the list of players and all we need to do is update the player's data with the uptodate Cloud message for that player job done shall we code that make that new list player uids and leave it for all Sprites then to check if we've seen the uid before we will use the not item one of list no but the very funky item hash of list block and the available vowel contains the player's uid that we just decoded ah a result of xero indicates that the uid isn't yet in the list indeed it starts empty talking of which we should ensure it does start empty by scrolling up to the setup script and deleting all of the player uids list okay so now we can use that player hash variable correctly and that is to set player hash to the value given by the item hashing list so like I said if this player hash is equal to zero then this is a new player we haven't seen before we add them to the list add Val to player uids and now we need our second list make a new one naming it player data also for all Sprites whenever we add to the player uid list we also add to the player data list to ensure that they have the same number of values we add the full cloud data value from the new value input variable now to handle existing players player hash will be set to the item number of the matching player's uid so we just need to replace the actual cloud data over here replace item of player data again popping in the new value cloud data and it's for item number player hash but hmm when we have a new player we are setting the player data to the same value twice here and here we can simplify that initially let's set it to blank instead and then ensure we set player hash to reference the last item in the list that's the length of player data the row we just added now the replace below handles both new and existing player data updates cool a final cleanup set player hash to an empty value at the end of this script this will be important going forward and I'll explain more on that later so just before we test make sure to reset the player data list in the setup script delete all of player data and it's testing time I'd recommend making the data list larger so that we can see the full content and then save the project and bring up two windows side by side don't forget to reload that right hand project if you kept it open from last time okay what do we see each player's unique ID has been shared with the opposite window and added as a single new player to the uid list as we move our Mouse around their cloud data is finding its way into the player data list too if I bring my mouse over to control the second window we see the player data now being updated in the left window Instead This is excellent and shows these scripts are coded correctly of course if you are curious like me then you might be tempted to see what happens when a third player joins the game just open a third browser window and then I'll stop all three and click the green flags wallet at a time there did you see that every player is aware that there are two other players communicating with them now as I move over each window the other two correctly identify which player is communicating and updates their players player data the crazy thing is this will work to scale way up to tracking over 100 players believe it or not but man don't try to open 100 windows on your own PC even running two or three Windows puts a lot more pressure on your PC than just a single player alone and it might result in your game running just a little bit slower something to bear in mind while you're testing now then it's quite exciting seeing these data values flying around but not half as exciting as it will be to see the players actually moving around on our screens yeah but I'm sorry to say that will have to wait until our next exciting episode where we will be implementing the Cloud Player clones and handling their buffered move that's when all our hard work will finally come together well I do hope you're enjoying a series and if you are then please do smash the like button and don't forget to subscribe and click the Bell icon so as not to miss the next video the moment it drops we can have so much fun I'm telling you let me know in the comments how you're getting on and what you're going to use is multiplayer engine 4. and I'll see you next time thanks for watching have a great week ahead and scratch on guys thank you