foreign scratchers and welcome back to our RPG series our worlds are looking fantastic but limited in size so in this episode I will introduce the concept of saving and loading multiple scenes this is the basis for creating larger interconnected world maps and for entering buildings and much anticipated feature I know so the active scene is stored in a list named grid containing around 30 000 tiles this doesn't want to change as it's fast and efficient to allow us to store many other scenes we will introduce two new sets store name containing each scene's name and the list store data that will contain the scene itself in computer science this setup is called a key value pair or a data dictionary and is super common so just like how in scratch we can switch Sprite costumes by name so we'll be able to switch to an RPG scene by name two very cool but before we can do this we need a way of storing a scene all 30 000 tiles of it into one row of this new stored data list hmm well luckily my last tutorial named save my game data serialization and escaping and scratch has the answer Orvis if you haven't followed that tutorial yet then please do that now and there's a link to the tutorial here and here it is then these are the two custom blocks that we are after and I'm going to open my backpack and drop the entire Sprite in there these two scripts let us take lots of data and serialize them into a long single value and then deserialize that back again into the original state exactly what we need okay so open up our RPG episode nine projects and before we proceed any further do not forget to save them as a new copy it's very important this time as any mistakes could mess up our beautiful levels guys this is episode 10 let's get scratching we need to copy the two scripts from the backpack to save game Sprite into the existing level store Sprite that's where we'll code up the saving and loading of levels cool all our coding today is going to take part in the level store Sprite and those two helpful scripts can be moved well out of the way here we go we'll Begin by serializing that is saving the existing scene into a safe code a new custom block save scene will do this adding a text input to give the scene a name and then run without screen refresh start with a blank save code and then we'll write out the first value RPG you see it's common practice to begin any serialized data with a header such that when we load this data back we can then check the first item and confirm it matches the header we were expecting RPG a safeguard if you will we can see that in action by clicking the save scene and save code reports RPG great we've begun next we want to add the contents of the grid list itself we will call this a data module as there may be more types of data to store in the future let's create a custom block for this named write module grid drop that in right after writing the RPG header here and now each module will like the save code itself have a header value this one named grid.1 this means it's the first version of our grid save module saving the scene shows RPG bar grid 1 bar so good so far next we write gmax that's the width of the 2D grid 100 tiles across and for completeness we'll also write the height also G Max since our tile map is square but let's not assume that won't change in the future and the Safeguard is getting longer love it right guys this is where things get a little more fun the grid list we want to serialize contains a lot of data and it'd be preferable if we could shrink it down a lot as we save it away the technique we are going to use is called run length encoding it's useful because our grid list contains long runs of the same value now rather than storing 79 79 79 79 10 times we instead store just 179 and before that the count of how many there were 10 79 that's a run of 10 79s see how much smaller that is and that's run thin coding let's do it we need a variable G idx for this Sprite to keep track of where we are in the grid list and set that initially to 1 the first item and then we need a variable tile or this Sprite that keeps track of the actual tile in the list at this position from item gidx of grid finally a variable count for this Sprite so we can keep track of how many tiles of the same type we found and right now that's just one the first tile we can use a repeat to Loop through each item in the grid list repeating for the length of grid except subtract one since we've already got the first item now changing GI DX by 1 to move us on to the second item and then with an if else block compare the next grid item with the previous tile if it's the same tile again we change count by one now that's two tiles of the same type great we'll repeat around again and check the next tile until finally boom we hit a different tile number and then we need to take action first we write out the previous count how many tiles we found followed by the previous tile number and then set tile to the new tile type item jdx of grid and reset count back to one the first of a new run of tiles okay so that is pretty much the shape of it we loop around counting up runs of tiles and record results when we find the next tile type but be careful because when the repeat Loop ends we still have a tile an account to record so pop in a final right count and right tile down below the loop as well perfect lastly we'll terminate this grid module with a single right end and then I think this is a great time to give this another test don't you save scene oh yeah wow so as expected this is now much longer just how long though length of save code oh my almost 11 000 letters that's still pretty large but then my scene is pretty complex but comparing this to the uncompressed grid list at 34 000 well we've managed to shrink it by a third of its original size so good job let's scroll back to the save scene custom block with the save code complete now we want to store it away in our scene dictionary which we haven't yet created so make a list named store name for this Sprite first thing to ask is whether this cname is actually in the list use the item hash of list block this gives us the item number of the input variable name if it is found in the store name list would do well to keep track of this number so make a new variable store hash for this Sprite and pop the item Block in there now if we didn't find the name then item hash will be zero in that case this is the first time we've tried to save this scene no problem we just add it now and then ensure store hash is also updated to the same new row number we could use the item hash to find it again but why waste time when we know it's the last item in the list test that with a save scene with the name cake nice a new item for cake has appeared and storehash is one importantly no matter how many times we click save we only get the one item added to the list now saving under another name is a different story but that adds a new row and updates storehash to two one last test now though try saving as cake again perfect store hash goes back to one the first scene exactly right so that's the name stored what about the scene data itself we need another list store data or this Sprite to keep them in sync whenever we add an item to the name list we also add an item to the data list as well a blank value at first before we can test this out we must first manually delete all the values from the store name list very nice a matching value data pair but the data is very empty let's stuff in the safe code replace item in the store data list at position store hash and push in that serialized save code value exciting stuff running the save scene again and now the save code is indeed showing up in our data store that is so cool you can try saving under different names and this should all work ticketyboo of course cake and fish are not the most suitable names for our scene I'll delete all those for a fresh start to keep track of the active scene we are viewing make a new variable scene name for all Sprites this first scene can be named over short for Overworld but tack on the end colon 0 colon zero this will allow us to have multiple Overworld scenes in an XY grid the scene to the right of this one would be named over colon 1 colon 0. click to set the variable and save the scene officially now under the correct scene name brilliant we are making serious progress and now for the second part of this episode where our tension turns to the loading of scenes if we look back at the first script in this Sprite we have a when I receive store load scene we set this up yons ago and it's called right at the start as our game begins to run originally we were generating a new map each time well now we are going to load a new scene with a given input name instead run without screen refresh as the game begins make use of that block and drop in the current scene name to be loaded I'll Define the new block over here next to the save scene so we can compare indeed as we want to load the save code from the level store we use the same set store hash and if check that we used in the save scene only when the scene doesn't exist we'll instead generate a fresh new map and just stop here but if this scene does exist then yay set the save code to the item in the store data that matches the name we just found it's at item storehash2 before we can start reading values out of this save code we must set save index to 1. this is the start of the save code and is used by the read value custom block and so we read our first value from the recovered save code do you know what value we are expecting well it should be the save code header RPG right we can test that easy enough with a load scene scene name click that and then check out the value of our value variable RPG perfect but if this wasn't RPG then we should not continue to load the save code we'll also pop in an Ask block to pop up an error loading level message and then stop this script the next value we'll read out of the save code is the module name grid 1. but don't assume this will always be the case modules may be in any order in the future so we'll use a forever Loop to read through the modules and check if the value the module name contains the word grid Dot so any version of the grid will be accepted here one two three Etc let's make a new custom block to load this module read module grid and we'll make use of it right away the else is run if the module was not a grid in that case we check to see if this is actually a module at all if blank then we are at the end of the save code and we can simply stop this script all is done the last case is that we found an unexpected module so another error I'm afraid unexpected safecoat module and we can join that to the module name we just found so we can tell why it went wrong and then stop all now let's go back to the read module script and move it to line up with the right module grid script firstly we won't have to worry about reading in the module name as that's already been read for us to get this far so the next thing to read will be the grid with gmax so set gmax to value but I'm going to round this value to ensure it's stored as a number and this can improve performance just a little bit if the variable is used a lot the next value is the grid height and we can just read it in and throw it away for now as our level Grid is a square right next up is the Run length encoded grid data itself before we begin reading we do well to delete all of the grid to start afresh now we'll loop around reading the Run length count and tile type values however by reading the first value outside of the loop we can repeat until the value equals end that means we've reached the end of this module otherwise we Loop setting count to Value so we can read another value from the Save code this being the tile type so we use these variables to add a run of count tiles adding the tile type stored in the value variable to the grid list finally before we loop back around we need to read another value again this will be a count or the end value brilliant the module is loaded let's nip back to the load scene custom block then and once our grid module is loaded we'll loop back around for another module and should find a blank value as there are no more modules to be read in at this time so back to the when I receive store load scene and well that's it that's all it does so job done this is where things get a little bit dangerous we need to test our loading code but as soon as we try to load a scene if it fails then it's quite possible we'll mess up the current level you may like to save the project as a new copy right now to ensure you can go back to the previous one or you can export your grid list to a file which again can be reimported if things go wrong okay enough warnings here we go I'm clicking the new map block this will clear our active scene so say goodbye if we want to see this blank scene then separate off the load scene block temporarily and then run the project yep yep it's gone my wonderful level has been reset but if all has gone well then it's still stored safely away in our scene data list so fingers crossed and smash that load scene block and yes few we did it the level has been restored we can have a walk around and make sure it all looks exactly as it did before this is great the load team block can be hooked back up to the event receiver so that we can set the scene name to any name we want and when the game runs we'll begin with a fresh new map the new scene is not added to the data store until we manually hit the save scene block like so but this is great as we can then save and load these scenes at will of course it won't be perfect until we can do this directly in the game and form the level editor so in the next episode we will be integrating this with the level editor and we'll introduce scene transitions as we move off the edge of one scene and enter another I'm really looking forward to that are you well guys I hope you enjoyed this tutorial if you did you can show your appreciation by Smashing that like button and do comment under the video if you have any ideas or just to say hi also if you haven't already now is a great time subscribe to the channel so you get notified as soon as the next exciting video drops that's it for today thanks for watching have a great week ahead and scratch on guys thank you