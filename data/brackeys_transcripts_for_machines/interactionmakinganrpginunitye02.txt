in this video we'll start building everything that we can interact with in the world we'll be laying the foundation for items enemies chests stores pretty much anything that you can think of we also make sure that we can focus an object and follow it around let's get started so the first thing that we want to do is go to our scripts folder and Define some kind of interactable object let's create a new script called interactable and let's open it up now the idea is that this will be a base class that all objects the player can interact with Will derive from and so we need to think about what are interactable objects such as I items chests and enemies will have in common so let's start by deleting our two using tags at the top and let's also delete our two methods instead I want to go ahead and add a public float which we will call the radius and we can default this to say three units this is going to be the distance that specifies how close our player needs to get to the object in order to interact with it whether that be picking up an item or attacking an enemy and a cool little trick here is that we can actually visualize this in the editor all we need to do is create a function called on draw gizmos selected and you need to write this in the exact same way because it's a callback function used by unity and in here we can draw Graphics in the scene first off let's set our color to a color. yellow and let's then use gizmos do draw wire sphere here we need a center for our sphere which is just going to be our current position so transform. position and a radius and for that we'll just use our radius so now when we save this and head into Unity we can go ahead and and create an interactable object let's right click in our hierar key go 3D object and let's create a sphere let's then snap to the top here and go into orthographic View and let's place this somewhere on our Bridge let's also look at it from the side in order to place it just above the bridge let's now add the interactable component to this object and you can see now in the scene view that this wire sphere appears and it will update as we change our radius so now we have to find a way to turn an object into an interactable object and that means that we can actually go inside of our player controller in here we can go to the update method and at the bottom of that we check for a right Mouse button click we want to check if we hit an interactable and we can now do that we can use hit. collider doget component and the component that we want to check for is our new interactable component we can then store this in a variable so let's make an interactable let's just call it interactable as well and set it equal to our get component call and then here if we did hit an interactable we want to set it as our Focus well we can check if we hit an interactable by going if interactable is not equal to no meaning if we actually found an interactable component on what we hit well then we want to set it as our Focus so let's create some kind of method that will allow us to do that let's put in a set Focus method and let's feed our interactable into that then below our update method we can go void set focus and as an argument will take in an interactable let's call it our new focus and how do we set our Focus well first let's go to the top here and let's Define a variable that will keep track of what we currently have focused so let's create a public interactable and let's call this our Focus then when we set our Focus we can simply set Focus equal to the new focus in the same way we also want to be able to defocus from objects we'll do that whenever we press the left Mouse button that's up here when we press left Mouse we want to move to a certain point and stop focusing in the objects and so let's call another function here called remove focus and we can go ahead and create that as well void remove focus and here we'll just set our Focus equal to null so let's go into Unity hit play and let's focus on our player and you can see by default we have no Focus if we now rightclick on our sphere you can see our sphere is set as the focus and if we then start moving it's set back to null but whenever we focus something we also want to move our player towards it to do that we'll have to tell our player motor where to move now you might think that we can go in here and call motor. move to point and then move to the point of our new Focus however this will only move our player once if our focus is an enemy he might be moving as well and so we can't just move to a single point instead let's go into our motor and add support for tracking a Target let's create a public void called follow Target we'll take in an interactable which is going to be our new Target we'll also create another public void this one will be called stop follow blowing Target so let's now go to the top and add a variable for the current Target let's make this of type transform and call it Target whenever we want to follow a Target we'll Now set our Target equal to the new target. transform and when we stop following it we want to set Target equal to null so now we should be changing this variable to whatever our focus is but we need to also update our destination on our agent if you want to be very performant you could do that in a co routine and so only update the position a few times a second I'll have a link for using Co routines in the description in this example we'll just use the update method here we'll check if our Target is not equal to null and so if we have a Target we want to access our agent set the destination for that agent and the point that we want to use is our Target's current position so now our player motor should have the functionality needed we simply need to go into our player controller and when we set a new Focus we want to call motor do follow Target and the Target that we want to follow is our new focus and inside of remove Focus we can go motor do stop following Target now if we save these scripts go into unity and hit play we should be able to right click on a sphere to focus it and our player will move to it and if we take our sphere and move it our player will follow you will see however that our player only stops once he's inside the sphere to get rid of this error inside of our player motor once we start following a Target we'll access the agent aent agent Dot and here we can set the stopping distance so we'll set stopping distance equal to our new Target's radius and here we want to make sure that we always get inside of the radius not just on the border so we'll just multiply this with something like8 when we then stop following the target will set our stoping distance back to zero let's now save that go into unity and hit play we should see that we still move accurately when moving around and when we then move to the sphere our player stops at the appropriate distance there is one slight problem with this however and that is we can still move our sphere inside of the stopping distance and our player will not change rotation until we get outside a certain radius to fix this let's handle rotation ourself whenever we are following a Target we can do that by going to the agent and setting update rotation equal to false then when we stop following the target we can set update rotation back to true then inside of our update method whenever we set the destination for our agent we'll also go ahead and phas the Target and this of course involves a tiny bit of math let's create a method called phase Target here we want to get the direction from our position to the target's position we'll create a vector 3 called Direction and we'll set it equal to our Target's position minus our current position if this is confusing to you I have a video on Vector math that I suggest you check out we then want to normalize this Vector then we'll turn the direction into a rotation we'll store this rotation in a queral called look rotation and set it equal to quion DOL rotation look rotation takes a vector with a direction and looks in that direction we could just pass in Direction here but I don't want our player to look up and down to avoid that we'll create a new Vector 3 where we pass it our Direction dox then on the Y we'll leave it at zero and on the Z we'll pass in direction do Z then finally we can set transform. rotation equal to our look rotation directly or if you want to smooth this out we can use querian do slurp slurp allows us to spherically interpolate between two points we want to go between our current rotation and our look rotation and we'll do this using time. Delta time multiply with a speed and I'm just going to hardcode in A5 here again this part is fairly math heavy we get a direction towards our Target we find out how we should rotate ourselves in order to look in that direction and we make sure to avoid any changes in Direction on the Y and we then smoothly interpolate towards that rotation let's now save this go into unity and hit play and you should now see that when I focus our sphere voila it will always face our sphere even though we aren't outside of our stopping distance and it will also make sure to do these changes in rotation smoothly so now we can move towards our interactable but we don't have much interaction going to do that let's go inside of our interactable script and in here we want to know whether or not we're currently being focused this way we can check if the player that's focusing this object is close enough to interact with it so let's create a bow let's call it is focus and set it to false by default let's also create a transform called player then we can create two methods first a public void this is going to be the on focused and here we'll take in a transform which is going to be the player transform inside of this method we'll set is focus to true and we'll set the player equal to our player transform similarly will create a public void called On defocused and Here will of course say is focused to false and our player variable to null then we'll create a update method and here we can check if we are currently being focused if we are well then we can check for the distance to the player so let's create a float called distance set it equal to Vector 3. distance this Returns the distance between two points the first point is going to be our player's position the second one is going to be our current position so transform. position we can then check if our players inside of the radius by going if distance is less than or equal to our radius and if it is well then we want to go ahead and interact so let's write out debug.log interact let's save this going to the player controller and here when we set the focus we want to go new Focus do on focused and we'll also make sure to pass in all players transform when we then remove the focus we'll go Focus do on defocused however there's one thing that we need to remember and that is when when we set the focus we might already have a focus and so we need to make sure to defocus the previous one to do that we'll go in here and write if new focus is not equal to our current Focus well then we'll call on defocused on the previous one and we actually only need to update all these different things if our Focus has changed one thing I do want to leave out of this if statement is calling the unfocused method that's because I want to notify our interactable every time we click on it and just in case our previous focus is null we want to go in here and say if focus is not equal to null well then we want to defocus it and we actually want to make the same check down here so if focus is not equal to null well then we want to defocus it let's save that now go into unity and hit play We Should now be able to focus our sphere and once we get close enough start interacting and when we then move away we can see that it stops of course we don't want an interaction to happen a bunch of times a frame to fix this let's go to our interactable script let's add a new bull here called has interacted and set this equal to false then in our update method once we go ahead and interact we'll set has interacted equal to true and we actually only want to do this distance check if we are currently in focus and we haven't already interacted we'll also make sure to set has interacted to false inside of our unfocused method so every time we focus an object we'll make sure to interact once and just for good measure let's do the same in the on defocused method meod let's now save this go into Unity hit play Focus that sphere and you will see now that once we reach the stoping distance it prints out one interact the fun thing that we need in our interact script is an actual method for interacting so at the very top here let's create a public virtual void called interact and down here we'll simply call it so let's call interact now what is a virtual method and why are we using it here well remember the gr plan for this script is to have all objects such as items and enemies derived from it whenever we do that we inherit all of the fields and all of the methods but one thing that we don't want to be uniform across all of them is how we interact with the object in fact we want that to be different for each one that's why we've marked this method as virtual that means that we can call it from within this base class in other words we can trigger this method but inside of our enemy or item script we will be able to overwrite it and so we can put in our own functionality for each type of interactable so I'll just write here that this method is meant to be overwritten and by default we can just write out a message saying debug log interacting with and then the name of our transform if we would play you will see that this works in the exact same way as it did before but we've now laid the solid foundation for all interactables in the game finally at some point Sebastian is going to be adding some cool graphics for items and when he does he might want control over where we stand and look towards these items for example if we have a chest in the game we only want to be able to open it from the front of the chest to do this let's go in here let's create another public variable this one is going to be of type transform and let's just call it the interaction transform we'll then insert this in all the places that we're currently using transform so here where we check for distance instead of using transform. position we'll use interaction transform. position we'll also place it inside of our on draal Gizmo selected and we also make sure to go inside of player motor and here when we start following a new Target we want to use the new targets interaction transform instead now instead of unity we can simply select our sphere and it might throw you a single error because we currently have no interaction transform if you want you can use the transform of the same object or we could go in here and create a new Mt and we could call this the interaction point we then say move this forward from the object and then when we select the sphere we can drag in the interaction transform you can now see that we can control the point of interaction for our sphere so if you were creating a chest you would do something like this and when we play our player will try and go to that point but for this object I'm just going to get rid of it and set all the settings back to theault to wrap everything up let's rename our sphere to interactable yay we made it through that's pretty much it for this video Sebastian will be doing the next one in this series where he'll be implementing a player character also if you want to support these videos you can do so at patreon.com bra here you can donate a monthly amount of your choosing it's cancelable at any time on that thanks for watching and I will see you in the next video thanks to all the awesome Patron supporters who donated in July and a special thanks to Hans huun Cole cabal Will goat Yesa melson Thomas vley stone gamer cybor mummy Jason latio Derek Heir facal marifi Robert Bund and Peter lock if your name's not on the list I we make sure to include you in videos later this month and the next month as well thanks a lot guys