thanks for tuning in at brackets hello and welcome to the second video on creating a multiplayer FPS in unity today we finish what we started in the last video which is creating the character controls for our player so if you haven't watched that yet I recommend you do so by clicking the screen now and if you have well enjoy so now we can jump over to a player motor and actually make this happen so if we look over here and we are going to have a private vector3 called velocity and we are going to just default this to vector 3.0 you can just leave this that's what it's going to default to anyways I'm also going to have some kind of private reference to our rigidbody so rigid body and we'll just call this RB then in our start method just as before just as we did with the player mode here we can say our B equals get component and of type rigidbody and again we are requiring the component dump here so that's completely legit and then here we can make some kind of method for setting our velocity variable because what basically what we want to do is we want to have this player controller control this variable and then we want to have a fixed update loop here that uses this variable to move the player so the kind of method that we want to control this variable it's simply going to be called move and it takes in a vector3 velocity and I'm using underscore velocity here and this is why it's important because we want to differentiate between this velocity and this velocity and then we simply say that we want velocity to be equal to the velocity passed in so this here takes or gets a movement lecture and then we want to have some kind of fixed update loop void fixed update run every physics iteration so this runs on a fixed time and basically we want in here to perform our movement so we want to call some kind of method that will actually do this movement so let's create that now so perform movement based on velocity variable and we'll just make this a private method so void perform movement and this is going to check if velocity it's not equal to vector 3.0 so if we actually want to move well then we want to set or then we want to say that we can call a method called move position on a rigid body and this is a super useful method this takes in the position that we want to move to and this is different from transform to translate because this will actually stop the rigid body from moving there if it collides with something on the way so this does all of the physics checks and the collision checks and all that but is much easier to control than the add force method so in here we want to pass in our current position so we either say transform the position or rigid body back position that's going to be completely the same and then we want to add on to that our velocity multiplied with time dot fixed Delta time and we'll just close that off so this will actually this will move our rigid body our player to the position of our player plus the velocity vector so on that actually once the movement and that's all we have to do in order to get this working so let's go ahead and try this out now and we should be able to move in the game let's it play and you can see that we are indeed now moving we can't jump and we can look around but that's a start of course okay so next up we want to have some kind of rotation so in our playercontroller we want to now calculate calculate rotation as a 3d vector and we do this by first getting some input so our Y rotation is going to be equal to input dot get access raw and this is very similar to what we were doing up here and the input that we want to get is called Mouse X and you want to of course build this completely as I've done here remember the space remember the capital M and X and again that's something set up in the unity input section and then we want to create a vector here which is going to store our rotation and it's going to be equal to a new vector and it's going to be 0 comma Y rotation comma 0 and we'll multiply this by some kind of sensitivity variable so we just like we have the speed up here we also want some kind of look speed or mouse sensitivity or whatever you want to call this I'm going to make this a private float called look sensitivity and we'll just default that to oh I don't know three cool so we'll simply multiply that down here look times look sensitivity so you will notice here that I'm only using our Y rotation which will be when we move mouse to left or to the right side and that means our xvalue from the mouse so that's kind of weird when you think about it but when we move our mouse on the X we want to rotate around the Y and I'm only doing this here because the Y rotation is the only thing we won't affect want to affect our player the the rotation around the x axis meaning tilting up and down well that's something we want to only affect our camera because we don't want the entire speed to rate rotate up and down that would mess up our movement so when doing this know that this is just for turning so calculate rotation as a 3d vector and we could just say this applies or let's just do this turning around that's what we're doing here and then we want to apply this so we want to apply camera rotation oh not camera rotation we want to reply rotation I was thinking about the camera now and we simply do a motor route motor dot rotate and this is another method that we're going to be creating so and we then pass in the rotation vector there and let's go ahead and create that in the character motor now with the player motor and in here we then want to go up and make a variable and we call this a or we make this a private vector3 again called rotation and we'll default it to vector 3.0 and then we want to make some kind of a method that will change this so that's the rotate method and we'll take in a rotation and we'll simply set rotation equal to underscore rotation and this gets a rotation no vector in there and then in the fixed update we want to actually perform the rotation and we do this by creating a new method of course so we want to perform rotation Void perform rotation this doesn't take in any arguments just like our perform movement method and we simply want to say RP dot move rotation and whenever it comes to rotation there is some there are some weird stuff basically because rotations in unity goes through what is called the a continuance system if you will so quantonium are basically just like vector threes but with an imaginary component and what this means I will leave to our mathematician to explain because quaternions are quite difficult to understand but we of course have some really cool functions in unity that takes care of all of this weird calculation stuff for us so just like when we are moving moving our player we want to get our rotation just love here we get our position and we add on the velocity well here we get our rotation and then we add on or we multiply that with quaternion this is what I'm talking about quaternion dot Euler and Euler angles are the angles that we know that's the x y&z rotation that's it takes in a simple vector three so in here we can simply input our rotation so our B dot rotation is a quaternion and quaternion Euler will take in our vector 3 and may get into a quaternion so that make sure that we don't have to understand what's going on we can simply do this calculation and that's really awesome so let's simply save that now head into unity here and we should be able to look around on the xaxis or around the yaxis so now we can actually walk around but we can really aim so let's let's make the tilting of the camera let's go back in here find our playercontroller and add another segment so this one is going to be calculating camera rotation so I'm just going to duplicate this entire section and we'll just call this calculate camera rotation as a 3d vector and this is not going to be y rot but instead be oops it's going to be X rod and it's going to equal get access raw of miles Y now and this is not going to be called rotation but camera rotation and it's not going to rotate around the Y but instead rotate around the X and then we apply it by using another function which is going to be called rotate camera and we're going to input our camera rotation instead of the rotation there so apply camera rotation so this is again around the xaxis and then we jump into the player motor then us of course starting to notice a pattern here so we then create a private camera private vector3 camera rotation equals vector 3.0 we jump we jump down here and create create a method for gets a rotational vector for the camera rotate camera and it's going to take in the rotation or you could call this a camera rotation and it's simply going to set camera rotation equal to underscore camera rotation just like we've done with all of the other methods and then down here when we perform the rotation we can do this in the same function call we of course want to apply this to the camera so we need a reference to our camera and even better we can make this reference optional so if we don't have a camera that we want to be controlled we can make a game that only our kind of moves around the Y or rotates around the wine lots of games have a fixed tilt if you will and only allows you to turn so let's just make this optional first off we want to create this reference and agains I want to use a serialized field private camera and we'll just name this cam you won't be able to name this camera because that's a method or that's a member that is included in monobehaviour so um we have the cam and then down here we can simply check if cam is not equal to null meaning we've put in a camera well then we want to say that cam transform God rotate so here we don't need to do any rigid body calculation we can simply rotate using the transformed and rotate method and how do we want to rotate we want to rotate using camera rotation and this might be in the wrong direction so we'll check this now I am boobs of course we need to put in the camera here player you'll see we didn't get an error here just nothing happened really so that makes it optional so we want to drag in our camera and now hit play and now I'm moving up and I'm moving down so you can see that's inwards so the only thing we need to do to fix this is simply put a small there that will make this the opposite a vector so that will inverse it and now we can look around just like we want to so that feels pretty nice actually and you can of course adjust both your movement speed ooh this is fast and your look sensitivity even while the game is running cool so that's the very base of our movement and I think I'm going to leave the tutorial here then we'll create all of the spring functionality and the flying stuff in a later video just so this won't get crazy long so this was already a really long tutorial and I've probably also have to split it up into two parts but I hope you enjoyed it and that you were able to follow along if you have any great suggestions for where this series might go and what you want to see in this course but then of course leave them down below or on the brakus forum and again thanks for watching and I'll see you in the next video