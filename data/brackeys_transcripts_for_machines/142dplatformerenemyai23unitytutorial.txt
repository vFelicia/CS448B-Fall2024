thanks for tuning in at brakus hello everyone and welcome back to enemy AI inside of unity this is part two or Part B I haven't decided yet in the 2d platformer course under AI and today we are going to be using the navigation mesh that we set up in the last video to get something moving inside our first scene so as you can see I'm here back in unity and I've I have my a star path finding object right here where we set up a great graph that looks like this but this graph is pretty boring if we have nothing that can actually move inside it so this video here is gonna be pretty scripting heavy so if you have a hard time following along I just want to skip ahead what you can do is you can simply download the 2d assets pack available at brackish comm to get the final script we have sprites and scripts and audio and GUI elements and all kinds of cool stuff inside of this pack cool so let's get started with the video so what we're going to do here is we're going to go under the 2d assets pack then under sprites on the 2d platformer and we're going to import my symbol agent spaceship here the reason why there's so much empty space is because I've made some room if we want to say make variations inside of the same sprite sheet or if we wanted to make animations now let's drag this inside of unity and let's set it up so we're gonna set the sprite mode to multiple we're going to change the pixels per unit to let's try 10 and the filter mode we're gonna set to point now go into the sprite editor and we're gonna simply slice automatically here and it's gonna slice it up pretty fine now we can hit apply and we can exit out of the sprite editor and it should have applied our import settings by now if not hit apply cool now we can open this up and we can see that we have enemy which can simply be dragged into the scene so I'm gonna head back into 2d mode zoom in a bit and drag him in here I think his size is pretty fine maybe a bit too large for our current needs this is gonna be a pretty small enemy I think we can maybe compare his size to our players so if we go under sprites and select the astronaut sprite sheet there those pixels per unit are set to 18 so I think I'm gonna set try at least setting the enemy to the same here mmm that's too small I think we're gonna do something like 13 and we're gonna leave it at that for now then I'm also going to drag this alien spaceship under the sprites folder come so our alien spaceship we are simply gonna name this rename this without the underscore oh and what we are going to do is a hit add component and we are going to add a nother pipe pathfinding script this is also included with the astar pathfinding project so again you will need a star so if you haven't watched the previous video you should go ahead and do that now so go into pathfinding and we're gonna find this seeker any AI you do inside of a star path finding it's going to need the secret component attached to it but we're not going to be messing around with any settings so we can simply collapse this then let's hit add component and we're going to add a rigidbody 2d there are many ways of actually moving your character I mean a star takes care of all of the path finding in that it's going to know where you want your character to move but it's not going to actually move your character so a simple way to do that is using the rigidbody2d component provided by unity you could also use some kind of custom made character controller or maybe find a plucking on the asset store but a symbol and pretty nice way is using the input building physics so let's hit the rigidbody2d add component and the mass we are going to leave at 1 and we're gonna mess around with a few of the other settings later but first off I just want to set the gravity scale to zero so he doesn't fall down as soon as we try playtesting now let's hit add component let's create a new script let's call this enemy AI you might want to be more specific if you want more enemies but I think I'm just gonna create this huge master script that does it all basically so let's hit create an ad and this guy here is gonna be relatively simple to start out with he's simply going to be kind of behaving like a zombie would in that he will just find the nearest path to us and then just fly over there and that's it and when he reaches our destination we might make him stop at some point I don't know how much time we're going to have in this tutorial so we'll see about that but we're definitely going to make him follow us so let's doubleclick this enemy AI and then maybe we can make him shoot and all that stuff later and I'm just going to zoom in here and what we want to do is get rid of this using system data collection that is pretty rarely used actually I hate the fact that it it imports it automatically and instead we're gonna say using pathfinding and this basically is the link between our script right here and the astar pathfinding projects AI engine so this right here will import a start path finding the namespace into our project so we can access the classes that we need in order to create nice path winding then we're going to delete the Istana methods and we're going to start out by requiring some components just to make sure that we don't add this to a game object that doesn't have a rigidbody and a seek so we're gonna type required component type of rigidbody2d and we can simply duplicate this down here and stuff rigidbody2d we are going to write seeker then inside of the monobehaviour class we are going to write or the enemy AI class we are going to write public transform we want this to show up in the inspector so we can assign it and we're gonna call this target then next up we are going to have a public float which we are going to call update delay and we're gonna T for this to about 1 actually let's just call this update rate and we're gonna set this to maybe 2 times a second that's better I like the rate better than the delay that just confuses people that you have to do smaller values to get it high and all that was simply gonna divide this number never mind that we're gonna continue we're gonna need two private variables the first one is going to be our seeker which we are going to reference um we're simply gonna call that Seager and the other one is going to be our 2d rigidbody so recently gonna call that RB it's pretty common in the forums to call it our B so I'm gonna stick to that naming convention then we are going to store a reference to the cat or a store the calculated path public path path and also we are going to have the a ice speed and this is going to be per second so it's not framerate dependent and it's going to be a public float and we're gonna call it speed and we are going to fold it to maybe 300 then we're gonna have a public forced mode to D and we're simply kind of called this if mode and basically basically what a force mode is is it's just a way to change force and impulse so it's just a way to control the way the force is applied to our rigid body and it just gives up some control in the editor as to how we want our enemy to behave so it's it's a very simple enum that we can just change between in the inspector then next up you're gonna want a private pool and that is going to tell us whether or not a path ascended and actually I want this to be public because then we can access it later if we want like to see if our if our AI is moving or if it's currently searching for something and we're gonna set it to false but I don't want it to show up in the inspector oops public boom so right before I'm gonna do these square brackets and inside of those I'm gonna type hide in inspecting that will make sure that it's public but it won't show up in the inspector pretty cool next up is our max distance from the AI to a waypoint foot to continue to the next Waypoint so we're gonna call this we're gonna store it in a public float and we're going to call it next Waypoint distance we're gonna set it to equal to three so this is basically how close do we need to get to a waypoint before it says okay we've reached that point and it can continue on so the max distance from the AI to a waypoint for it to continue to the next Waypoint cool I'm simply gonna do caching up here and this is going to be how many times a second each second we will update our path we simply want to do this a limited number of times just so we don't clutter the computer unnecessarily and this is of course gonna be what to chase and we're almost done with creating variables here I know it's quite a lot and it it probably looks scary but but it really is and I will walk slowly through this and hopefully you will follow along if not it's completely understandable ai is something that frightens many developers and frankly it's it's it's a job that has tried to be made intuitive over the years and I think that now we've reached the point where there are many good solutions to AI but it's still it's still it's still a whole category that you have to get in the mindset of and this Waypoint thing and path finding and OneNote connects to the other and all that so please bear with me here it might be confusing in the beginning so I think we're just gonna skip the rest of the variables and then expand onto this later this is basically the core of what we're gonna need and this should be work really nicely so what we want to do here is create a start method so let's type void start and inside of this myth method we are going to first off assign our seeker so we're simply gonna say seeker equals get component type seeker and then we will assign our rigidbody so our B equals get component of type rigidbody 2d oops capital R there or it's gonna try and access our local rigidbody but you don't want then we're gonna check if our target is equal to null so if we haven't assigned a target I think we're simply gonna add debug that lock we can input some kind of target searching here and we are going to do that later so if we doesn't don't have a target we're gonna search for one but for now we assembly can make it spit out an errand and the world would burn so we're gonna say no player found panic and then we're going to return there and down here then we can use our target and we're going to say that seeker we are going to access the stat path method and this is part of the astar project and this is going to take a few parameters first off is the our current current position which is transform dot position that's our start point and then we're gonna put in our target position which is target that position and then we are going to put in on path complete and what this will do here I'm gonna write it out as a comment is start a new path to the target position and return the result to the on path complete function method gonna call it a method and this might be weird the fact that we are inputting a function as an argument and I get why but it's actually very very useful in this case so I'm gonna write some more here write some more I'm not done with this method I'm just gonna remind myself and then I'm quickly gonna show you what we can do with this so what we can do is we can make a function here which is going to be public I think we're gonna of type void and we are going to call it on path complete we could have called it anything we liked as long as we changed it up here also and as an argument we're gonna take path I mean it's certainly gonna short this with P and this is pretty much the hardest part of this inside of this we are simply going to maybe debunk that lay lock we got a path did it have an arrow and then we can put in P dot error then down here we can say if we didn't have an arrow so if not P dot error it's just a bool then we can oops then we can say that path equals P and we can set our current waypoint to zero whoops Hammond I created the current weight point variable oops nope I skipped one so here private this is going to be private int oh yes int current Waypoint excuse me yeah I just confused myself way too much this is was not necessary but I'll explain in a sec so Ambria the description for this is simply the Waypoint we are currently moving towards and this is referenced with an index that's why it's an integer so um sorry here okay so what we are doing here is we are saying that it should start a path and it should start it from our current position to the target position and when it's done creating this path it's going to call the on path complete function this is down here it's going to put in the path that it's just made then we check and write out a large saying if it had an error so this P dot error is basically just a way to check if our path was successful and if it didn't have an arrow so if it it found the correct path we're gonna set our current path to the path that it found so we can simply update our calculated path up here and we are going to set the way our current Waypoint to zero so the Waypoint that we will start at on this path is simply going to be zero so that we don't start on the mid in the middle of the path or at the end if that makes any sense awesome if not bear with me we'll continue here you