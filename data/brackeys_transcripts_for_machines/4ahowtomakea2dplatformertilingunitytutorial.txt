thanks for tuning in at braies hello everyone and welcome to the fourth video in the how to make a 2d platformer course today we're going to be taking a look at making our background and foreground elements tile as the player progresses it will allow us to create very small levels but still the player will be able to infinitely explore them so that's going to be really awesome we're going to talk about a lot of cool calcul ations with the camera to World position we're going to do um some performance optimization it's going to be really awesome so yeah let's get started and of course if you don't want to do all of the scripting which is understandable uh though I think it's wise if you do uh please go to bra.com uh where you can go to the 2D platformer page and uh download the all the scripts and assets and everything else right here for free uh so if you have errors that's a good place to go awesome so let's open up unity and uh it's just as we left it the last time one thing I do want to go ahead and tweak though is that I want to get a little bit more parallaxing on the foreground uh right now the effect is a bit too subtle so what I realized is because we have an autographic camera we can simply just move it forward so so let's just drag out the blue background so we won't affect it and let's just uh move the back uh main camera backward is what I meant to say so let's just move move it a bit back here uh you can move it as far as you want as long as it's inside of this rectangle uh but let's just move it like there and uh then let's drag the blue background back on the main camera then we can simply take our foreground and uh we can just move it over so right about here I think it's going to going to be good yeah that's just now the parallaxing is more apparent and it looks like the ground is closer to the camera which is nice cool so let's let's go ahead and actually create the script uh but before we start writing it let me just explain what it's going to do so I've made this drawing uh this explanation drawing here and uh I of course excuse my drawing skills I am not so practiced in the odd of drawing with a computer the mouse but uh what I've drawn here is uh the player in the center which can uh he can move to the uh left and the right up and down won't matter for this tutorial we are going to focus on the xaxis and uh this rectangle here represents what the camera sees this red line down here is the foreground element which is going to work just like the background uh and what we're going to do is we're going to take point a here which is the exposition of the um of the extend of the foreground here so we're going to take the edge here and we're going to take the EXP position of that and then we're going to take the uh B Point here which is going to be um the um extent of the camera so in World points what is the camera seeing and then we're going to ask ourselves is a bigger than b so is this ground further out than b if it's not then we're going to go ahead and instantiate a new one and we're going to do the same over here so it's C lar uh smaller than d uh and if not then we want to uh go ahead and spawn something and the uh the things we're going to spawn are just the same element which we're going to repeat uh and the forground I've made repeatable but the background I have not so we're going to do a cool trick with that uh where we revert its uh size so that we won't get uh weird um clipping issues so we're going to look into that uh but basically we're going to instantiate uh what we're going to refer to as a Budd um which is basically just a clone of the uh the element and then we're going to position it so it just aligns with the element itself and to take care of performance we're going to uh have some variables saying that do we have a left body and do we have a right body and if we have both uh we are not going to do these calculations at all so that's the basics of what we're going to be doing today uh so let's Del right into it so I'll keep that open in case we need it and uh let's go ahead and select our foreground dirt here and uh let's create a new script actually before that let's disable parallaxing in our GM object because uh that will uh interfere with the um with the instantiation of of new grounds uh I have a trick for that and we're going to fix it uh soon but when when we're debugging we're just going to disable that cool so let's select the foreground dirt let's hit add component new script and let's call this tiling let's keep it simple let's double click this to open it up in my develop awesome so this script is going to be pretty long uh but it's not too complicated uh it just has many parts first thing we're going to do is we're going to uh require a component and this is a really awesome feature oops let me zoom in here so you can see what's going on oh man it's good that I didn't forget that um we we're going to require a component uh meaning that once we attach this script uh Unity is automatically going to check if a component is attached to the game object and if not it's going to create one so that's really awesome because we're going to uh only use this script with Sprite renderers so we're going to require a Sprite renderer to do this type two square brackets and inside of those type require component then open up some parentheses where we're going to type type of and then open up another set of parentheses where we're going to do sprad Sprite renderer this is a good way to make sure that we always have a Sprite renderer attached so we won't get errors in our code awesome uh wow I said that like five times already but it's awesome we're going to declare some variables the first one is going to be a public int and this is going to store our offset uh we want to offset this uh just a tiny bit uh because if we check um uh the camera's position versus the grounds uh edge here if you check A and B uh on the exact point it is pretty prone to errors so we are just going to um make sure that b is like maybe two units to the left so that we will uh or to the right so that we will always um make sure uh be sure that a body is instantiated before we get there so we're just going to offset the calculations a tiny bed so we're going to do offset x equals let's just do two it's not that important just a tiny bit then we're going to do uh public bu and aoan is a true or false value and we're going to see uh name this has a right body and we are going to default this to false then we're going to create another one which is also so going to be a public po has a left bud and we're going to also going to default this to false so these two are what we're going to check whenever we instantiating does it already have a body do we even need to do the calculations and such then we're going to do public bull reverse scale and this is also going to be equal to false by default this is what we're going to use for the background elements that I've not made tilable then we're going to do private float and in here we're going to uh store the width of our Sprite so that we know how um how long the element is so we can actually check these positions so we're going to do Sprite width equals z f actually let me comment out some of these so this is going to be the the offset so that we don't get any weird errors uh these are used for checking if we need to instantiate stuff then we have the reverse scale used if uh the object is not tileable and then we have the Sprite width uh which is uh the width of our texture of our element let's call it that our element awesome and then right below this we're going to do private camera so we're just going to store a short reference to our camera just as we did in the last tutorial for performance reasons and because it's awesome uh and then private transform my transform and this is for performance reason that we storing the objects transform in a variable uh it's just faster and gener good practice cool let's now create a new function so let's do void awake and again a WG is where you want to do all of the referencing uhing between scripts so we're going to do cam equals camera. Main and we're going to do my transform equals transform uh yeah and the void start in here we're going to assign the Sprite renderer and we're going to check the width so we're going to do Sprite renderer uh and let's just call this s renderer it's not something that we're going to use frequently equals get component and then this is the syntax and then inside of these two signs we're going to write Sprite render us so that's the type of component that we want to get and I don't remember I'm pretty sure that you can only have one Sprite renderer that would make sense so but this is just going to grab the first t uh component of the type you insert so if there's multiple it's just going to um going to return the first one and then uh we're going to do Sprite width equals s renderer so our Sprite renderer do Sprite bounds do size do X okay so that will give us the width of our element uh no matter how we size it so that's that's a really great feature cool then in the update function and this is where it gets uh kind of exciting what we're going to do here is first we're going to make an if statement and inside of this we're going to do has a right uh yeah let's do left first has a left body is equal to false uh or um has and the these two signs are used for or the reason why I copy pasted them is because my keyboard is being annoying right now with certain symbols um just have to configure that these are called vertical bars if you cannot figure out how to make them on your keyboard just uh write how to make vertical bar on Google and you'll figure it out many people have asked me this so I just thought I wanted to say but these basically means or so whenever you're checking for something you can check um does it have a left body or does it have a right body cool so then we're going to check has a right bu and this is going uh equal to false and then close it off and let's do the parentheses so open and close these yeah uh so here we're just checking does it still need uh buddies if not do nothing cool so now we're going to calculate the camera's extent meaning half the width of what the camera can see in World coordinates so if we look at our drawing here we're going to calculate the uh uh the position B over here here so we're going to calculate the length from the center of the camera to the point B so we do this by doing float cam horizontal extent is what we're going to call it and it's going to be equal to cam do autographic size times screen. width divided by screen do height so this will return uh this will equal to the uh the um length from the center of the camera to its right bar and uh let's just common this out also so we're going to do calculate the cameras extent meaning half the width of what the camera can see and it's going to be in World coordinates versus pixels coordinates great so now right below this we're going to calculate the EXP position where the camera can see the edge of the Sprite so we're going to take this into consideration we're going to use the Sprite width and the current uh position of our object and we're going to calculate at what position the camera can see uh the edge of the ground so we're going to do uh calculate the X position where the camera can see the edge of the Sprite Which is the element and we are going to write float Edge visible position right so we're going to split it up into the right position and the left position and this one is going to be equal to my transform. position. X so our current X position plus Sprite width divided by two because we we want to only get half of it um because it's it's this distance here and uh then we're going to do uh close off the parentheses and then we're going to do minus cam horizontal extend so we are factoring in our own position then we adding on half the Sprite width which is basically the Sprite extend and then we're subtracting the cam horizontal extend to figure out the position where we would intersect then we're going to do this uh same calcul for the left position so we're going to do Edge visible position left equals my transform. position. X and then this time we're going to do minus Sprite width divided by two plus cam horizontal extend so we are just inverting the calculations basically for