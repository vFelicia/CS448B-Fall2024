thanks for tuning in at brakus hello everyone and welcome to video number five on making a multiplayer FPS in unity in this video we take a look at adding some really cool spring physics to our movement and also we're going to add a camera rotation limit which a lot of you have has been requesting and which is definitely something you need to do before release and finally we are going to add some thrusters to our players so that we can actually fly so we're going to script all of this and it's going to be a lot of coding and some physics stuff and it's going to be a lot of fun so let's go ahead and get started so let's start by adding these cool spring physics to our player in order to do this let's just hit play and go on the land host in order to get our player in the game now in the scene view let's select our player and have a look at his components we need to add a new component and you can see I've already searched for joined in here but if we go under physics and scroll down you can see the configurable joint which is the one that we are going to be using the effect that we want kind of resembles the spring joint effect but we need to tweak a few things that are only configurable in well the configurable joint so let's click that and you can see just why it is called what it is I mean we can pretty much change anything from in here and create any kind of joint effect so therefore it also looks very frightening but don't worry we're only going to use a few of the settings and I'll explain everything along the way so the tab that we kind of want to look under here is the wide drive tab and in here we can set a mode and we want to set this to position and that means that our ball will now try and reach a certain position and the position that it tries to reach is what it's spawned at up here so you can see our cube was at position 1 when it was spawned a Y position of 1 and therefore this becomes kind of the anchor point the point that this object will apply forces in order to reach so therefore the point of the spawn position suddenly becomes very important and this is something that we are going to need to change later in order for our ball to be able to land on all the objects and have that as kind of the position that it wants to reach so that it doesn't stand on a cube and applies a lot of force in order to get down to the ground plane well we want that to become the new ground plane but that's something that we're going to add in the future for now we are just going to have him float at the one point so if we now that we know that that's the position that we're going to strive for well then we would think that if we drag this up he's just going to bump down there but he stays the same and the reason why we need to bump up this position spring amount and this is the amount of force that we want to apply to our spring so if we set this to something like 20 you can see that now we get this spring effect however at the moment it's a very loose string a spring and it's it's very bouncy and the bounciness is definitely something we want but we want to limit this a bit then you would think that we would use the precision damper but this has absolutely no effect so we leave that at zero instead we go up and take a look at our rigid body settings under here we have a property called drag drag is different from mass because if we increase the drag we are going to slow down quicker but it doesn't actually make our object heavier I like to think of drag as air resistance so how much much resistance do we need and therefore how quickly do wish slow down after force has been applied so if I change this to something like 10 you can see just how effective this will be we slow down very quickly and this takes away all bounciness and that's way too high instead I found something like for it to be a fairly reasonable amount you can see we still get that bounce but it's nowhere is nowhere near as crazy so I think that kind of resembles this thrust the force that we want to be applied under our object you will also notice now that when I do this we don't collide with the ground and the reason why is fairly simple there is no real collider on the ground at the moment so we are going to add that so let's just copy our actually let's add that in a second because we have one last thing that we want to set under your configurable joint and that's the maximum force because right now if I drag this cube up really high you can see just how much force is applied this is not very realistic with gravity as gravity is a constant force of negative 9.81 and therefore we need to set a maximum force so that our it doesn't act like a spring but instead acts like gravity's pulling it down therefore we set this to something like I don't know 30 or 40 and this is not the same as gravity we don't set it to negative 9.81 nor ATU but still trust me this is normally a pretty good numbers now you can see when I drag this up it's much more reasonable speed it's falling down with so that becomes much much more realistic and now it looks like a constant force so now that we have these settings what we want to do is we want to copy this component exit play mode and remember we've been playing mode this entire time go down here click here and hit paste component a sneer so now we've added it to the prefab and it's going to spawn with these settings you can see under why Drive these position size set in a moment we're going to set these through a script but firstly I want to go to the environment and add a box Collider to a ground plane so let's just enter box Collider there and that's pretty much all we need to do now when we hit play it's like land host and go in here to mess with our player there is we can see that if we dragon up very far enough and let go is simply going to collide with the ground there cool so now that we have these proper physics working I think it's time to add some kind of flying mechanic so we in order to do this we're going to edit our player motor and play a controller script so first off let's lick look at the player motor so let's double click that and open it up in visual studio and we're going to open up the player controller too so I'm just going to double click that so actually let's start with the player controller now that it's already open so you can see in here we have a few variables we have the speed and the look sensitivity well of course we want to create a new one for the thruster speed so let's also make this side serialize field in order to be able to keep it private and still view it in the inspector and we'll call this thruster force I will default that to a fairly high number and that's going to be a thousand now in the start method I actually want to do something but let's just stay away from that for now and let's just implement the thruster force and then I'll talk about how we can make sure that the spring ignores or that the player ignores the spring when we are using a thruster because when we have the both applied at the same time it's hard to get cool results but we'll talk about that in second so that's just how look applying applying this first a force so down here we can say that we want to apply the thruster force and if we look at our movement script we can kind of see where we're going so we have this velocity variable that we put into a move method down here and that basically takes care of everything well we can do something similar here so we can say that if we get an input dot get button so if the button jump is rest and this is again one of those inputs defined in the unity editor well then we want to kind of set our thruster force variable on the player motor to the thruster force variable defined here so let's start out by making a vector3 and we are going to call this underscore thruster force so this is going to be our local thruster force and we want to default that to vector 3.0 so unless we get this jump button we are going to apply a force of zero comma zero comma zero meaning that we are not going to do a thing if we then get that button well then we want to set underscore thruster force equal to vector three dot up that's going to be a vector of 0 comma 1 comma zero and then multiply that with our thruster force as defined above so that's kind of the logic that we need here and then we want to call something on the motor that will apply this force for us so I'm just going to move this down apply the thruster force down here and we simply want to say motor dot apply thrusters and in here we want to set or we want to input our underscore thruster force so again this is going to be zero comma zero comma zero if we don't get a new input and if we do it's going to be zero comma thruster for is come as zero cone so here we calculate the thruster force based on player input awesome so let's save that and let's head into the player motor and in here we want to go up here and create a new private variable that will store our thruster force vector three and we'll just call this thruster force again and then it's going to default to vector three that's zero because unless we get any input we wanted to have a serosa root of zero value and then down here we we use some kind of get of setter so public void and let's just call this thruster force and it's going to take in a vector or what we we call this apply thrusters what we call this so apply thruster and it's going to take in a vector three thruster force and remember the underscore there and it's simply going to set our thruster force variable equal to the value passed in to underscore thruster force there just as we've done with anything else and this is going to get a force vector for our thruster thrusters cool and now under our perform movement I think it's fine if we do our thruster force in here sense it is actually movement we are simply going to check just like we do with velocity if thruster force is not equal to vector 3.0 because we can save ourselves the the move position call if we don't need to do anything at all and of course this is not going to be moved position this is going to be add force and we do this because we actually want this to behave as a force not just a rigid movement we want this to calculate or to slowly speed up and all that so add force and it's going to take in a vector3 force and this is of course going to be our thruster force and we want to multiply with that with time that fixed Delta times just as we do up here and then in order for this to stay constant no matter our mass because I I want us to be able to change the mass of our player without having to tweak this value all the time well then we can set force mode equal to force mode on acceleration so we can simply put that in as a second argument and you can see if I just hover over this it says adds a continuous acceleration to the rigid the ignoring its mass so that's simply all we have to do in order to make mass or take mass out of this calculation so now it's actually going to perform this calculation for us and it should apply it to the rigid body you can see that we have this thruster variable so if we were to go into play land host we can actually apply some thruster force however you will notice that the spring quickly forces us down and a solution to this would be going under the configurable joint and setting the maximum force to something smaller than the force that we are applying and therefore and our this will have to be really small maximum force of 5 maybe we are almost there of two you can see we can go further now but it's still forcing us down so instead what we are going to do and we're going to set this back to 40 what we're going to do is we're going to disable the configurable joint while we are using our thrusters but as you can see the configurable joint can't just be disabled and there are many reasons for these for this not something I'm going to go into but I'm going to show you how we can work around this well basically we want to control our precision spring so it equals zero Y we have our first two supplied and where we are not using them well then we want to go back to the amount that we've set and in order to do this let's actually strain away from setting anything in the configurable joint and then have some variables inside of the controller instead or our motor now let's have them inside of our controller that will configure the joint so instead of setting all the values down here let's simply require that component and then set all of the stuff in here I think that works way smoother especially if other people want use the same script or we want to use it on other objects well we don't have to set any custom settings we simply add the script that adds to configure the Joan giant a component and sets it up all right so let's integrate this configurable joined into our script so let's open up the player controller script here let's just expand that and up here let's make a reference to it first of all and if we make a reference well then we want to require it also because we are not going to do any kind of component checking so I require a component type off and then configurable joint and we want to add the reference down here so that's going to be a private configurable joint I'm just going to call this joint and in the stat method we simply want to set joint equal to get component of type configurable joint awesome and now down here all we need to do ah is right okay so I just had something there for a moment well basically we want to set up this configurable giant with some different options and the first thing we have to do is well make these options available in the inspector so under the thrusted force here I want to create a new section and in order to organize this properly in the inspector we can create a header for this so in here we'll simply type on joint options or something like you could also do spring settings whatever you want to do now we'll just do spring settings now and a colon and that will just make if we save this and hit into unity and wait for this to update we actually have to have some variables below it looks like so let's just make some we have a serialized field and this is going to be a private and this is going to be a joint our mode gende DriveMode there and we just want this to be called the mode we also want another serialize field and this is going to be a private float and this is going to be our joint spring and that's actually called this joint mode and a third serialized field because we don't want to change our dampening effect because then dampening amount because that has no effect so this is going to be our joint max force and we are going to default that to let's say 40 and the joint spring to 20 cool so now when we say that and hit into unity we should be able to see this in the inspector and you can see the header that the spring settings and then we have these different settings here and the join mode we want to set that to position and we can also maybe set that to a default value so we'll say joined drive mode that position is going to be the default value there cool so now we have the different settings but then we want to apply them to our joint component and let's do this through a function so let's make a private method down here because we only want to access it from within our controller and we are simply going to call this set joint settings and in here because the join settings is a struct which which we haven't talked much about this we need to use a certain syntax and the syntax looks like this so we access our joint and then we go to the Y Drive because that is the drive settings that we want to control so and you configure the joint you can see the Y Drive here and that is the settings that we've made so the Y Drive is a struct called a new joint Drive so the joint Drive struct contains information about the mode the spring effect the max force and all that and we want to input that there you can't actually access these individually you cannot set position spring like this if we try and do that you can see that it throws an error here because of the way that this is programmed so we actually have to make this a new joint drive and then we can fill that with information so normally here we would put an open and close parenthesis well now we use these curly brackets and in here we can then set first off we can set mode equal to joint mode comma and then we can set position spring equal to joint spring and we can finally set maximum force equal to joint Max force there we go and I don't want this on one line so we're just going to make some room here to kind of organize the code a little bit there we go that looks much cleaner and maybe actually also move this down there and that looks really nice and private void this is going to be we don't want to return anything and we want to actually be able to input a parameter here because the thing that we are going to be changing dynamically is the joint spring so let's create a flow float here and let's do underscore joint spring and let's set that into there so instead of just using the value up here we're going to use the value passed in and now I've been this start method all we need to do is we want to say set joint settings and we want to input our joint our string so just the default amount that we've said in the inspector then down here when we are applying thruster force so if we get this button jump and we applying the force well then we want to set joint settings and then we want to set a spring amount of 0 we don't want the spring to affect anything at all and if we are not getting this button down bow then we want to set some giant settings and we want them to set set the giant spring to the giant spring passed in okay so if that makes sense to you great if not please just copy my settings here and pick up on what makes sense I mean the reason this might seem a bit clunky but that's because it's programmed as a struct and there are so many settings so selling them individually can be kind of clumsy but once we have this set up here it's just going to work fine and I don't think we're going to have any need to change it awesome so now that we have that in place we should be able to go into unity check if all of this is still working it looks like it and now hit play and select LAN host and now if we go into now if we try and use our thrusters here you can see that they actually completely ignore the joint there so we can continue a far above as we want to but we want to also set our drag here so I forgot about that before so we want to set that to 4 and we can also adjust the thruster force and maybe the spring amount 20 is maybe a bit too much so let's try 15 instead and let's jump in here and we can see what that looks like and that looks a lot better I think so we get this much more smooth effect and I think we actually want to set our thrust of force to something like 1200 that feels a lot better but again this is something you can play around with just as you want to so I'm going to set that back up to 20 and maybe try 1300 here now oops 1300 hit play land host and yeah this feels much more snappy and and cold so that's basically all for this spring effect so the last thing that we're going to be doing here is clamping the camera rotation so that we cannot look well what is behind us so right now if we go in here and look down you can see we have an issue here we just want that to stop add something like negative 85 degrees and the same if we look upwards you can do the same there we want to clamp that too so in order to do this let's open visual studio and let's look at the player motor because we want to do this where we are actually performing the rotation here so first up let's create a variable and I actually want to change how we are doing the camera rotation just a bit so first off let's just create a serialize field here and that's going to be a private float and this is going to be the camera rotation limit and we're going to default that to 85 F because we want that to be a float and we want to apply that but demo at the moment we are using this camera rotation which is basically our input multiplied with our look sensitivity and we're using camera transform rotate to apply this rotation to our current rotation but I want to kind of do this manually instead so we have control over how the rotation is applied and therefore we can clamp the rotation correctly so if we just scroll up here and change this from a vector3 to a float that will allow us to use this as an X rotation only and we are just going to default that to zero and we want to change this down here too and we're changing this to a float because that's going to make it a lot easier for us to apply the rotation we're not having to think about all of the Rd axes so you will see what I mean in a second so we want to change that to an X that to an X that to an X and down here we want to completely replace our rotation code so new rotational calculation and then in our playercontroller we want to change this a bit to account for this change so instead of making a vector3 call camera rotation here I'm going to make a float called camera rotation and you can do an X there which we're going to do I think and instead of making a vector3 here we simply do underscore X rotation multiplied with Luke sensitivity and that's basically all we have to change in here so back in the player motor now we can take a look at actually setting this so basically we want to kind of track our current rotation on the x axis and in order to do this we want to make a new private variable up here and that's also going to be a float and it's going to store our current camera rotation on the X and that's going to also default to 0 and then down here under the perform rotation we want to set let me just think about this we want to say that our current camera rotation plus equals our camera rotation on the X so whatever rotational value we get we want to add that onto our current rotation and I've done this before so I know that this is going to be a minus equals but this will basically inverse the rotation so if you get a weirdness in basically the camera being inverted but then you just need to change this from a plus to a minus or a minus to a plus so that's what you're just there and then we basically want to set camera current camera rotation X equal to math dot clamp and we want to clamp the current camera rotation X between a minimum and a maximum value and that's going to be our minimum camera rotation limit comma camera rotation limit there so a negative camera rotation limit come at the positive camera rotation limit so in our case negative 85 degrees 285 degrees and then we simply want to apply this to our transform so we simply say cam that transform that local Euler angles equals a new vector3 and this is where it becomes really easy that we've only actually taken into account the rotation on the xaxis because I camera itself is not is a child of the player and therefore it's always going to have a rotation of whatever X amount and then comma 0 comma 0 and therefore we can simply put in here our current camera rotation comma 0 comma 0 and we don't need to do any advanced calculations with cut unions or anything like that we can simply input it into the local angles after doing the clamp and that will do the trick so if we just want to kind of comment this out well we set our rotation and clamp it and then we apply our rotation to the to the transform of our camera so if we save this now and collapse that and look at our player we should see the camera mode has a camera rotation limit and we now press play land host and you can see that there's a limit when we look down and there's a limit when we look up so that's basically all we have to do we can now fly we have this spring bouncing s effect we have working fixed physics now because we've added the rigidbody and I'm just going to end this video with showing you that and we have this rotational clamp so just for fun let me actually play the game again here let's let me go into the scene and spawn a 3d cube let me just move this up right above the player and let me add a rigidbody to this cube and let me show you how cool it is when these interact so add a rigidbody and you can see that the physics here are working perfectly so that must be did for this video I hope you enjoyed it and I'll see you in the next one