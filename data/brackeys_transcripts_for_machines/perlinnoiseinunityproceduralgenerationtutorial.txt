this video will have a look at something you guys have been requesting for such a long time it's procedural generation this video will have a look at Perlin noise so this is a large subject and can be approached from a variety of different ways from generating textures on the fly creating procedural animation making terrains and then this pretty much goes on so without further ado let's get into it when generating textures the terrains from scratch you normally want to apply some kind of randomness however using completely random numbers to generate a texture looks chaotic and well random instead we use a noise function such as Perlin noise where values aren't totally random but have some relation to each other which allows changes to occur gradually refer to these types of noise as pseudo random Perlin noise is often used because it gives a more organic feel without being too computationally expensive and luckily unity has a function for generating twodimensional Perlin noise builtin so we're starting with a blank project here the only thing I've done is change the background color to black under the main camera the first thing we need is an object to display our texture on let's rightclick in the hierarchy go 3d object and select quad we can now reset the transform on this set the scale to something like 8 by 8 we can remove the mesh Collider we won't be needing that and let's now add a new component this component is going to be our script where we'll generate our noise so we could go ahead and call it something like Perlin noise that's it new script and create an ad and let's double click it to open it up in visual studio we can go ahead and remove the two using tags at the top and let's also remove the two methods so the first thing we need to specify is the resolution for our texture we've already chosen the size of the texture on the screen that's the scale of the quad this only determines the quality meaning the number of pixels in our texture and we want to do this both for width and height so let's go ahead and create a public integer this is going to be the width and let's to fold it to something like 256 and now we'll do the same for the height so our text it will be 256 by 256 pixels now let's go ahead and create a start method and in here we first want to get a reference to our current renderer that's because in order to change the texture on our default material we have to first access the mesh renderer component then access the material and then change the texture so that's right getcomponent the type of the component we want to get is renderer and we can go ahead and store this in a variable let's write render up the type I'm also called it renderer with a non capital R as the name so now when we want to change our texture we write renderer dot material dot main texture and we set this equal to the texture that we now generate let's set this equal to a function called generate texture so let's now construct this method first off we'll need it to return a texture so we'll set the return type to texture 2d we'll name the function generate texture we don't need any arguments and then let's open and close some curly brackets now in here we are creating a texture from scratch let's start by making a texture variable it's going to be a type texture 2d let's call it texture and set it equal to a new texture 2d and the texture 2d here takes in a width and a height luckily we've already specified those up here so we simply input our width and our height of 256 pixels then we want to go ahead and generate a purlin noise map for the texture and then we'll send this texture back into the main texture variable up here so we'll say return texture so in order to generate the Perlin noise map we have to loop through all of the different pixels in our texture to do that we either use a four or a while loop in this example we'll use four loops so first let's write four and we'll begin by looping through all of the x coordinates so we'll say int x equals zero we'll create a variable called X and set it equal to zero and we want this loop to continue as long as X is less than the width of our texture and every time we go through an iteration of the loop we add one on to the X variable so now this for loop should run 256 times but our texture map is set up in such a way that each time we go one forward on the X there are 256 pixels on the Y so for each of these iterations we also want to iterate through all of the Y pixels so in here we'll say for int y equals 0 and we want to continue as long as Y is less than the height and each time we'll add one onto the Y so now our first folder will run 256 times and for each of those times the second for loop going through all the Y pixels will also run 256 times and so we'll make sure to go over all of our pixels which are and I actually have to bring our my calculator here over sixty five and a half thousand pixels but this is also the reason why there's a lot of optimization when it comes to procedural generation because we are often dealing with really really large values but that's not important for now for now let's just try and get this to work so for each of these times we want to set the pixel we're currently looking at equal to a color determined by a billion noise in other words we want to call texture set pixel and the pixel we want to set is that with the current x coordinate and the current y coordinate and then we want to insert some kind of color here and we'll go ahead and create that color right above let's create a variable of type color and we'll call it color as well and this is why our Perlin noise comes in because we are going to set this equal to a value generated by our Perlin noise function what i want to do that we need to do a tiny bit of math let's wrap that in another function we'll call that function calculate color and we'll give it our x and y coordinates so now we can scroll down and we can create another function this one is going to return a color and we'll call it calculate color it's going to take in an integer X and an integer Y now we can get the value of our purlins function add a certain X&Y coordinate by going math Perlin noise then inserting the X and inserting the Y and that's it this will return a float with the value of the function at these coordinates so we can store that in a float called say sample and then we can create a new color where both the red green and blue coordinates are all set equal to sample this way if sambal is equal to zero we'll get a black color if it's equal to one we'll get a white color and if it's some way in between we get various shades of gray so we can go ahead and just return this new color and we've now written our calculated colored function however there is one huge problem with this and it's the most common mistake I see when people are first dealing with Perlin noise and that is we are currently inputting our x and y and pixel coordinates and pixel coordinates are of course whole numbers either pixel this lid or it is not we're not dealing with 1/2 or 0.3 pixels and that's not too fortunate for our Perlin noise function because Perlin noise actually repeats at whole numbers so what we instead want to do is turn these into decimal place numbers instead of having them go from zero to 256 we could have them go from zero to one in order to do that we create two new floats here the first one is going to be our X and I'm just going to put court here so we know that we're not talking about pixel coordinates but pearling coordinates and we'll set that equal to X divided by our width so the smaller the X the closer we get to 0 and the greater the X the closer we get to 1 and we do the same thing with our y axis here so Y chord equals y divided by height remember whenever we divide two integers and are expecting some kind of float number we need to also cast this into a float during the calculation so we'll write a float in front of both of these and now we'll make sure to get a decimal place number then we'll replace the x value here with X chord and the Y value with Y chord and that's actually one more trap that I see a lot of people falling into and that is whenever we create a texture like this and then change around some colored data we need to also apply that data and to do that we call texture apply that will take care of everything for you it's just something that is so easy to miss remember to write that in here so if we now save this script and hit into unity we into the Aprilia nice script now has a width and height resolution and if we hit play we should see voila we've got noise now this looks super non interesting and very great now a few reasons for this the first one is that we are currently using the default material which is set up to work with lighting and I have serial lights in my scene so let's just go ahead and right click in the project panel go create material it's called it unlit under the shader instead of standard will choose unlit texture and we can I'll just drag that on top of the quad so we should now see the texture much more clearly the second thing is that we are currently very assumed in to change that we create a scale variable so at the very top here we'll create a public float we'll call this one scale and we can default it to something like 20 then down where we calculate our color after we do our division we write multiplied with scale so this is just going to scale our entire coordinate number up or down and if our scale is 20 it means that our coordinates are going to be bigger and therefore will cram more of our pilla noise into a texture which will give the effect of us zooming out so if we save this and they play we can now see the texture much more clearly let's also go to a purlin no script and change this from start to update now of course there are a few things you can do here to optimize it for example we don't need to get the renderer each frame but it just allows us to very quickly update settings while the game is running you can see what happens when I change the scale finally also want to add the opportunity to pan around in our noise map we do that by adding to offset variables we'll add a public float and call this one offset X and we can default it to say 100 and we'll also create a public float offset Y which will also default to 100 then we again scroll down to our calculate color method and after we multiply with our scale we simply add our offset onto that so here we'll write offset X and here we write offset Y and in our game we can now adjust these offsets in order to scroll along the surface this is also how you make the texture random if we were to create a terrain using Perlin noise and wanting it to be different each time we would simply go and pick random numbers for the offset in fact let's do that now let's go in here and create a start method above the update method and in here we'll set off set X equal to random range and want this to go between zero and a huge number and we want to do the same thing on the Y so now in unity when we hit play it's going to be different every time cool right that's pretty much it for this video I'm planning on doing another one on procedural generation this time we're going to have a look at generating a landscape using Perlin noise so make sure to subscribe so you get notified when that comes out on that thanks for watching and I will see you in the next video thanks to all the awesome patreon supporters who donated in April and a special thanks to Derek Hughes Kirk face will mattify James Calhoun Sybok Nami Cole Cabral and Jason Lotito if you want to become a picture in yourself you can do so a pinch ENCOM slash correctly