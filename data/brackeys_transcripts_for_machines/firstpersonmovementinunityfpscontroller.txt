first person games of course extremely common and that's actually a surprising lack of information when it comes to creating solid firstperson movement so in this video we'll have a look at creating a character controller the theory behind it and how to make it perfectly fit your game but first this video is sponsored by AB City one thing that has always been very difficult when publishing a mobile game is getting it onto the Chinese market which is the biggest mobile game marketplace in the world with up duty this has never been easier they offer several different publishing package solutions with the basic plan that take care of publication to three Chinese app stores and translation of the first thousand words for free they monitor the application each step of the way and can help with IP certificate and Chinese publishing license application they're stupid SDK allows you to use the same build for a multistory publication which is just extremely convenient get started by clicking the link in the description and use the coupon code break he's 2019 for a 40% discount on upgrading from their basic plan to is PP plus for access to more stores also special thanks to infinity PBR for his support on patreon and with that let's get our move on but before we actually start creating the controller in unity I think it's a good idea to have a look at some of the theory some general movement and unity can be done in two ways using the character controller component or using the rigidbody component and both definitely have their advantages depending on what you want to do now the main problem with creating a universal character controller that works for everyone is that what you want your character controller to do completely depends on your game of course everyone wants movement but there's also gravity jumping drag in air movement handling slopes handling steps sprinting crouching and interacting with physics objects just to name a few and some of these are easier to do with the character controller approach while others are much easier with the rigidbody approach in fact there's also quite a few things that you don't necessarily think about but are pretty important for the movement such as adding a ground check to know if the player is currently standing on the ground and adding logic to make sure that the player doesn't get stuck on walls now over the years I've tried hundreds of different ways to create character controls so for the sake of this video I think we should boil it down to the most simple way of some really nice controls that can still handle movement gravity ground checking jumping in air movement steps slopes and that doesn't get stuck on walls and without a doubt the simplest way to do this is using the character controller component since much of this stuff is already built in this way you can also easily add more things such as crouching or sprinting the only real restriction is that the character control it doesn't interact with physics objects of course there are ways to get around this for most cases but again that is for the future so let's jump into unity and before we start with the movement let's add a player with a camera that can look around so the first thing that we're gonna do is create an empty object so let's go to the hierarchy and hit create adds that create empty let's name this object first person player and let's drag it into the center of our scene next up we want to add a character controller component so that's it a component search for a character controller and hit enter and if we now hit F and turn on gizmos we can see the green outline of our character controller now I'm gonna go ahead and set the radius of this 2.6 to make it a tiny bit wider and I'm gonna set the height to 3.8 to make it taller as well of course this isn't very visible so let's go ahead and create some graphics for us so that we can easily see it within our scene to do this that's right click on our first person player let's go 3d object and let's create a cylinder I'm going to set the scale of this to 1.2 by 1.8 by 1.2 I'm also going to go ahead and remove the capsule Collider the reason for this is that the character controller itself also acts as a Collider and it's also add a material to this that isn't just a power in grade so in our project that's create a material let's call it player material and let's just make it a bright red and drag it onto our player awesome so now that we have our player in place it's time to add a camera so that we can have a look around if you don't have a camera in your scene already you can of course right click and simply create one or to make sure that you don't have multiple cameras you can simply take the one that you already have in my case I have a main camera here and drag it under our first person player I'm gonna reach set the transform here and then I'm gonna move it up on the Y so that it's almost at the top but still leave a tiny bit of space here the reason for this is that if you go ahead and jump into a ceiling I don't want my camera to clip through and also we wanted to stay inside of our graphics object here so that it's not visible to the camera itself and with that a player is set up and we're ready to start adding logic and the first thing that we want to do is create a player look script that is of course responsible for our ability to look around now looking around is actually fairly simple of course everything is controlled with the mouse and the mouse can be moved unto axis Mouse X and mouse Y if we move our mouse on the X or from side to side we want to rotate our entire player around the y axis this allows us to turn around if we move our mouse on the Y or up and down we don't want to rotate our entire player we just want to rotate our camera on the x axis this allows us to look up and down now it's a good idea to limit the rotation of our camera to 180 degrees so that it doesn't flip to point behind the player this is called clamping all right with that in place we can go ahead and select our camera and here we want to add a new component and let's call it Mouse look let's hit new script and create an ADD and let's double click it to open it up in visual studio now the first thing that we want to do here is go into our update function and gather some input based on our mouse movement so go ahead and create a float called Mouse X and set this equal to input dot get access and the access that we want to get is the mouse x axis now this is of course a preprogrammed axis inside of unity that is going to change based on our mouse movement if you want to see this for yourself you can always go into unity go edit project settings input and here you can see the mouse x axis now unity is currently redoing the entire input system this year should work for a long time but if you're getting issues definitely check out our video on the new input system so we'll go ahead and gather that input here we'll also do the same for the yaxis so we'll create a mouse y and so the equal to input that get access Mouse Wow of course it would be nice if we could control the speed of our mouse so let's go up here let's create a public float called mouse sensitivity and let's just defaulted to 100 then when we gather the input we can simply multiply with our mouse sensitivity and because we're doing this inside the update function we want to make sure that we rotate independent of our current framerate to do that we also want to multiply with time.deltatime remember time that delta time is the amount of time that has gone by since the last time the update function was called and so we can multiply with this value to make sure that if our frame rate is high we're not going to be rotating quickly than if our frame rate is low and let's just do the exact same thing for a mouse Y awesome so let's start by having our mouse X or our mouse movement from side to side rotate the entire body of our player of course in order to do this we need a reference from our main camera to our entire firstperson player object so that we can rotate it around to do this we'll simply create a public transform let's call it player body then inside of our update method we can now access player body dot rotate and here we can specify an axis that we want to rotate around so we're going to rotate around vector three dot up so our y axis and let's multiply that based on our mouse X and if we save that and go into unity and linkup our play body we now look around using our mouse X movement so next up let's implement our mouse Y which means that we want to move up and down and this of course means that we have to rotate around the x axis so let's go ahead and create a private variable up here let's make it a float and let's call it X rotation and by default we'll set this to zero then down here in our update we can say X rotation equals our mouse why so I refrain we are going to decrease our X rotation based on mouse Y now why are we decreasing here instead of increasing that's simply because I've tried this before and when I increased it the rotation was flipped so simply go ahead and put a minus here and what we can then do is down here we can apply this rotation so we can say transform that local rotation equals quaternion and remember quaternions are responsible for rotation in unity and we want to input some Euler angles so we'll do a jeweler and here we can simply give it an X Y and the rotation so in our case we want to put in our X rotation for the X 0 on Y and 0 on Z and there we go and the reason why we're keeping track of our X rotation in this way instead of just rotating it by calling dot rotate is so that we can go ahead and add just one more step and that is of course clamping this rotation so we'll set X rotation equal two math clamp and here we'll say that the value we want to clamp is our X rotation we want to clamp it between negative 90 degrees and 90 degrees this way we make sure that we can never over rotate and look behind the player finally I'm just gonna add a single line of code up here in this start function and this is just going to go ahead and hide and lock our cursor to the center of the screen so that when looking around our cursor won't be visible and just leave the screen and we'll click outside the window that's extremely annoying so we'll just set cursor to lock state equal to cursor lock mode dot locked and with that we can save this script head into unity and hit play and as you can see we can now also look up and down which means that we have a working mouse Dirk script and if we go ahead and try and look very far upwards as you can see we cannot look further than the 90 degrees and the same thing when looking down so next up we're ready to create some player movement to move our player we can want to gather some input remember this is using the current input system so this might change in the future but for now we can do this by getting some input on the horizontal and vertical axis just like with the mouse X and mouse Y in unity these are preprogrammed to map to the keyboard so that if we hold down W vertical will be 1 if we hold down s vertical will be minus one the same thing applies to horizontal but with the a and D keys and the cool thing is that these axes also set up to automatically work with controllers so based on this input we can move the player to the sides along the X and forwards and backwards along the Z we also want to make sure that we do this locally so that we are always moving relative to the direction the player is facing so terms amend this in practice let's go ahead and select our player let's add a new component and this is going to be our player movement script let's say create an ad and open it up in Visual Studio and of course the first thing that we want to do here again is get some input so let's create a float called X and so equal to input that get axis of horizontal let's do the same thing with the Z so equal to input that get access vertical and now we've got some input now let's go ahead and take this input and turn it into a direction that we want to move so let's create a vector3 called move and you can simply consider this an arrow that points in the direction that we want to move so we'll set this equal to u and here you would think that we just needed to create a vector three and input our X than zero and then our set value however this would be global coordinates and so we would always move in the same direction no matter what way our player is facing and that's not what we want to do instead when we are moving left and right we want to use transform dot write which takes the direction that the player is facing and then goes to the right and we'll multiply that with X on top of that we'll add transform dot forward which again takes the direction the play is facing and goes forward and we'll multiply that with Z and so we've now created a direction that we want to move based on our X and the movement and the way the player is facing and we can go ahead and simply move with this of course in order to move we need a reference to our character controller because this is kind of the motor that drives our player so to do that we'll go up here and let's create a public character controller let's just call it controller in fact let's also get rid of our start method we don't need it and now down here we can simply call controller dot move which is a function on this character controller that takes in as you can see a vector3 with a motion and here we'd simply put in our move vector three and that should actually work of course it would be really nice if we could control the speed of this movement so let's go ahead and create a public float called speed and set it equal to twelve by default then down here where we move our player we can simply multiply on move motion by our speed and again because we're doing this inside the update method we want to make sure to multiply with time.deltatime this way we make it frame rate independent and that should actually be it for our basic movement if we now go ahead and save this and go into unity remember to reference the character controller and we hit play we should be able to move around and indeed we are and notice how when I turn the camera the direction that I am moving is also turning so that means that we are correctly applying our movement based on the local coordinates of our player awesome now you will also notice that I currently cannot step up the stairs the reason for this is that we need to change the step offset of our character controller I'm gonna increase this to something like 0.7 and that should definitely allow me to climb these stairs you can also see that there's a slope limit here that defines how steep an angle your character controller can climb currently this is set to 45 which i think is just fine so let's go ahead and hit play and you should now see that we can go ahead and walk up these stairs of course we currently have no gravity applied so we're not gonna fall again but you'll also notice that we can walk up this slope so now that we have that working we can go ahead and work on the gravity now applying gravity is actually pretty simple all we need to do is try to move the player down a little bit each frame however one thing about gravity is that it's a force being applied over time and because of this the velocity or speed of the fall is going to gradually ink so to properly simulate this we add a velocity variable this way we can increase our velocity based on our gravity each frame and then apply that velocity to our player of course this also means that we have to reset our velocity when we are on the ground and so we have to add a way to check if we're currently grounded so let's start by implementing our velocity let's go up here to the top and let's create a vector3 that is going to store our current velocity now inside of our update method let's simply go ahead and increase velocity dot Y so our up and down axis by some gravity number and let's just add this here so that we can control that as well up here let's create a public float with our gravity and it's defaulted to negative 9.81 then down here we can simply add that gravity onto our velocity on the Y and we'll of course go ahead and multiply this with time.deltatime as well then in order to add this velocity to our player we can use controller that move once more and here we simply want to move based on our velocity however as you can see from this equation here the amount that we want to move on the Y is actually going to depend on our gravity multiplied with time squared and because this is squared we actually need to multiply with time.deltatime once more why you may ask well that's just the physics of a freefall so if we save that and go into unity and move our play up and it said play as you can see he's now going to appropriately fall to the ground however if we then go ahead and move up a slope here and drop off the edge you can see just how fast that went and the reason for this is that we're currently constantly building up velocity and not resetting it at any point in fact if we go ahead and go to debug mode in the inspector here we can see our velocity on the Y just rising and rising and rising so to change that we're going to go ahead and add a ground check so I'm gonna zoom in on the player here and I'm gonna right click and create an empty object I'm going to move this to the very bottom of the player I'm gonna rename it to ground check and basically all this object is going to do is be responsible for doing a physics check to see if our play is currently standing on anything and it's going to do that using a method called checks fear white simply going to project an invisible sphere around this point and see what it collides with so to do that through script we first of all need a reference to the object that we just created so we'll create a public transform called ground check we'll also create a public float with the ground distance this is going to be the radius of the sphere that we'll be using to check and finally we'll also create a public layer mask and will call this ground mask and that's just because we want to control what objects the spheres should check for we don't want it to register as standing on the ground just because it collides with the player and finally we'll create another private variable this is going to be a pool and it's simply going to store if we are grounded or not so we'll call it is grounded now inside of our update function at the very top here we can check if we're grounded so both set is grounded equal to the result of our physics check so we'll do physics Todd checks fear and this is going to create a sphere based on the ground check dot position it's going to use the ground distance as a radius and as the layer mask it's going to use the ground mask so I know this looks really scary but it's really that simple it's simply going to create a tiny invisible sphere here at this point with the radius specified and if it collides with anything that is in our ground mask well then is grounded is going to be true if not is grounded it's going to be false then we can simply check if is grounded and our velocity dot Y is less than zero well then we can set velocity dot y equal to and here we could put in zero that would make sense since we're not moving down we're standing on the ground however since this might register before we are totally completely on the ground I found that setting this to something like negative to a fairly small number but still there just to force our player down on the ground actually works a bit better so there we go we are now resetting our velocity accordingly and we can now save this go into unity select our player here we want to drag in our ground check and we also want to go to our ground mask and as you can see here we can now see all of the layers currently in our scene as you can see I've already gone ahead and added a layer for ground here if you don't have this already you can go to layers here hit add layer and simply type one in you can go to ground mask and simply select the layers you want I'm just gonna press ground that also means that I want to go ahead and take my environment and I want to change all the objects under here to be of layer ground something we're gonna hit ground here and hit yes change children and now we should see that if we play and fall down here we're gonna land on the ground and if we now walk off of this slope we're just going to fall as normal and it works with slopes it works with stairs and everything is good I definitely think that the fall is currently a bit too slow for my taste so I'm gonna go ahead and multiply our gravity with two just to make that a bit quicker but that's of course completely going to depend on the game and start your going for now with a ground check implemented jumping is extremely simple all we need to do is check if we're currently grounded and if the player is pressing the jump button and if that's true we can simply set our Y velocity to some number depending on how high we want to jump in fact we can use this neat little physics equation to calculate the amount of velocity needed to jump a certain height we simply take the square root of our decide jump height multiply it by minus 2 multiplied by our gravity I love physics so inside of our script before we apply our gravity wins my co if input dot get button down jump this is another default input that automatically maps to the space key and we're kind of grounded well then we can set velocity dot y equal to the square roots of math that square root of our decide Haight and here we need to go up here and create a public float without jump height and I'm just gonna default that to three units and so we can put our jump height here mode supplied by minus 2 multiply it by gravity and that's all we need to do we can now just save that go into unity let's move our first person player down so he doesn't fall every time let's hit play and maximize our game view here and as you can see our player can now jump as well and that means that we now have a working firstperson controller that you can easily expand upon awesome that's pretty much it for this video so from here it's up to you to expand on the character controller and add in the features that are right for your game and if that seems too complicated I really recommend picking up an acidlike ultimate FPS on the unity asset store it's an amazing really solid character controller with pretty much all the features you can imagine and of course if you liked this video make sure to subscribe so you don't miss the next one and for example check out our video on shooting which will naturally take you one step closer to a finished FPS also don't forget to check out AB to D simply click the link in the description to get started publishing your game in China and use the coupon code practice 2019 for a 40 percent discount when upgrading your service on that thanks for watching and I will see you in the next video thanks to have the awesome patreon supporters who donated in September and the special thanks to kill sweet escy infinity PPR Dennis Sullivan Peter schwendemann lost a violent love forever Chris face Tamara fine Lear Lissette Ronan Daniel sonic stick Heston Jacob Stanford no he was sake gregory pierced the midis news Edison the fears and Erasmus you guys Rock