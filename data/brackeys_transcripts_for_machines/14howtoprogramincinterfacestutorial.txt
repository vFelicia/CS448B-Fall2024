thanks for tuning in at brais hello everyone and welcome to video number 14 in how to program cab course in today's video we're going to have a look at interfaces so an interface is basically like a contract that you uh can sign with a class uh saying what needs to be in that class so uh if you look at an interface it's very much like a structure of what methods and properties needs uh need to be in that class uh so that sounds maybe a bit abstract to you uh but uh basically you don't have to get very far in programming before interfaces become very useful uh for making things simpler uh safer and a whole lot cooler uh so that's going to be awesome and uh we are uh a pretty good uh way into the series here so I quickly want to mention mention that if you go to bre.com I do have a donate button here where you can support Brees uh so you can simply click on that and it will take you to PayPal and you can donate any amount that you want to uh all of the uh stuff that I uh upload is is free all of the assets on the unity asset store is free and the assets packs uh so if you want me uh to keep doing this for free uh you can of course help me out by uh donating so I quickly wanted to mention that it's of course not something that you need to do and I don't expect you uh to either uh but if it's something that you feel like uh would uh would feel would be a good idea um I I'm not going to stop you cool so let's dig right into today's video so I've opened up Samaran Studio here and uh if we take a look at implementing a symol interface uh we can basically describe an interface as uh kind of saying what should be in a class and then the class itself describes uh how each method is implemented so uh an example of an interface uh we're going to create one here could be uh let's say an item so we wanted to have an item system and we wanted to define the structure of all items well then we create an instant interface for those items and I'd like to begin all of my interfaces with an i so here's going to be I item just so we can identify them as interfaces and then we open and uh close some brackets here and uh inside of uh the interface itself the syntax is actually really simple uh we don't need to do any uh kind of uh availability layers so we can avoid the public and private and all that and uh basically we just need to define the data type for the property so we're going to have a string um with the name of the item and uh you can't just close this off this has to be uh marked as a property meaning that we have to do uh get and set that's just a formality but it's something you're going to have to do and then we can also maybe make an integer with uh the uh gold value of uh this item and that's also going to be a property so we do the get set here and uh then we can maybe make uh a couple of methods so first off we're going to have void and this should of course be pool or float depending on what you want to return so we'll just say say void here and uh we'll um make this uh equip so we can equip our item and another one for selling it and none of these are going to taking any parameters either that's also something you'll have to uh think about here so that's a very simple interface and if we wanted to implement this uh we could go in here and Define uh a class and we could call this sword and uh of course open and close some curly brackets and uh in here we could create a uh public uh string name and again just simply let's use the C uh default get set and a public integer gold value and again use get set cool and then we could go in and create a Constructor so we'll make this a public sword and uh we're going to take in as an argument uh the uh name so string name so we can give it a name once we create a sword and uh we're going to set name equal to underscore name the name passed in and we're going to set gold value equal to 100 so we'll just say that all sorts uh in our game has a a gold value of$ 100 imaginary dollar and uh cool so you can see here that we've now implemented the two properties and we haven't yet implemented the methods and uh the program is going to notify us of this so if we save this and hit play you can uh who this actually runs oh I know why it's because we need to implement the interface stupid me so this is very uh Central right now we just have a class definition and an interface definition but if we go ahead and actually inherit from this interface just like we've inherited from other classes before so we can inherit from I item here then you can see that when we hit play it's going to say that uh it doesn't Implement uh the uh interface member equip and if we click on this you can see that it doesn't either implement the interface member cell and if we didn't have these values or properties here it will notify us to implement those too cool so and you might be thinking right now well why don't we just use a base class and uh the reason for this is that we can use multiple interfaces uh that we can derive from multiple interfaces and also this uh allows us to Define how we uh how the actual methods and properties are going to work in uh the uh derived class itself so now we can simply uh go ahead and make a some fairly simple um methods here and equip method and of course we don't have any logic for um equipp equipping items here so we'll just write out that um the name of the item and then has been equipped and uh actually we'll just say equp shorter and uh then we'll have another uh method called cell and uh this one is just going to say that uh cons R line the name of the item plus uh sold for plus the gold Value Plus imaginary dollar cool and now when we hit play here nothing is going to happen but we don't get any errors so now down here we can go ahead and create a um uh a new sword we can create a sword and we'll just call this sword as a reference and we'll equal it to a new sword oops not a Nite a new sword and we'll give it the name sword of Destiny and then we can call uh methods on this so we can say that we want to equip this sword and then we want to sell the sword so now when we hit play you can see that uh sword of Destiny was equipped and sword of Destiny was sold for 100 imaginary dollar cool so that's the simplest use of an interface that I can come up with and this works uh just fine already but let's take this a step further so I've drawn this thing in paint I know it's the most beautiful thing I've ever seen in my life too but bear with me so if we look at interfaces as like tags that we can apply to our objects because right now we've tabed uh tag this class as an item well we could also tag it as a quality so we we could basically say that this item has some kind of uh quality level and therefore should be able to be damaged so we can add that kind of Dimension onto the class we could also tag it as part of a quest so we could create another interface for for that and then we can basically have different items so we can have an sword and an Axe and both The Sword and the axe maybe has is are attacked as an item of course and we both want them to have some kind of quality level and be able to be destroyed when used and uh but maybe only the sword is uh really important for one of the quests the ax is just something we P picked up and therefore something we can just sell no matter what so this is you see some a piece of logic that is available in pretty much any RPG that I've played at least uh because it allows us to very dynamically use our code uh throughout our game and uh then if we even go further with this we can have an inventory uh with all of these items so we can have an array of items and then we can Loop through that array and check what items are marked as part of a quest and those that are that are we can call a method on those items that only those items have that we want to turn in the quest uh turn in the quest items so this might sound complicated but I think we'll go ahead and implement this so first off let's create the quality layer and that's going or the quality tag and that's going to act pretty much the same as our item tag so we're going to have an interface is here I quality uh and I know the name here is not perfect but we'll we'll just go with I quality and uh this one is going to have some kind of uh integer uh and we'll call this quality level no uh we'll call this durability uh actually instead of quality let's call this damageable I like that a lot better I should have thought of that so long ago okay um so interface I damageable and uh it's going to have an in uh durability and uh it's going to uh of course have a getter and a Setter and uh then we can create a method that will uh here that will uh say take damage and it's going to take in an integer amount and uh it's simply going to say that durability minus equals and then we'll say uh 20 oh no of course amount amount cool so and uh the name of this argument uh basically doesn't matter uh that's uh completely irrelevant and of course this is on the impl M mentation side we just want to finish this off I don't know I got confused there sorry uh but basically we we do this structure where we want to have a void that takes damage and uh we want to uh put in the amount as an integer and it doesn't matter what you name this here because uh we can just rename it or name it something different down here and it's not going to throw any kind of errors or anything so uh now we have this uh damageable tag which um forces our object or our class to include a dur durability variable and a take damage me damage method so let's now tag this with um I damageable and uh now we can uh create a public void take damage and it's going to take in the amount or I could call this damage uh just to show you that that will work I'm going to do that and then we uh do the logic here and of course of course uh now we want to name this damage and we also want to implement the durability so we can say public integer and uh uh this is going to be called durability and uh simply implement the c a normal uh get sit and we could do something here again with a private variable uh underscore durability uh that will make sure that durability doesn't go below zero and all that which you've seen in previous videos so again we have complete control over what this durability variable actually does what its value is and uh how we change it cool and uh now down here we'll be able to uh will say that uh we want to equip the sword and then we want to damage the sword by 20 and uh whenever it takes damage let's also print out uh that the name of the item and then uh took uh Dam or let's just say damaged uh by and then we'll put in the damage amount and then we say it now has a durability of and then put in the durability cool yeah awesome so let's save that and hit play whoops uh expected a colon am I missing I'm missing a plus sign there hit play cool and it says sword of Destiny equipped sword of Destiny damage by 20 it now has a durability of 20 sort of Destin so for 100 m imary dollars cool so uh for some reason uh okay so durability of course defaults to zero so up here in our uh Constructor we'll simply say that durability should be equal to 30 uh by default and now we can see that it says that it has a durability of 10 awesome so that's kind of the idea that we can create these tags and Mark our items and uh if we just take this whole sword class here and copy it down here we can very very easily create an axe so um it's again that's going to derive from item and uh damageable and this is also going to be ax it's going to take in a name it's going to start with a gold value of 70 and a durability of 50 and uh all of these implementations are going to be the same and then down here we can create an a called it a set it equal to a new ax and set it its name to Fury a and then we can maybe equip the A and we can uh of course damage the uh damage the A and uh we're going to damage this by 10 and uh finally we can uh sell the X so we can do all of the same stuff and and let's just make an empty line between these so simply write out console. R line and you can see that it does all of the stuff for the sword creates an ax and does all of this stuff for that too so that's super cool but that's just adding on to the amount of complexity that we have in our game next up is the actual very very cool part of this and that is marking these uh items as quests and then using that in our actual game logic so if we should go ahead and create create an interface here uh that the idea is very simple we go ahead and create an interface called I part of quest and uh again we do all of the brackets uh we then create an uh let's just create a a void we could have of course some more information like uh the name of the quest and all that but here we'll simply uh force it to include a word called turn in that will turn in the item and that's basically all of the that this interface is going to implement so uh or all the classes deriving from this interface is going to be forced to implement I should say and now we can uh make our sord derived from this but not our a so let's uh do a comma here and uh Implement I part of quest and it's super cool this uh idea that we can see all of the attributes of our sword right here uh it also makes it very easy to read the code once it gets more complicated and very easy to uh add functionality to a class and uh then uh we simply want to include the logic here so we'll make a public void and we'll call this turn in and it's not going to take in any arguments we're simply going to say that console. R line uh and then name of the item uh turned in that's it cool so now down here our sword will be able to call the turn in method but our axe won't so if we try here ax. turn in you can see it doesn't autocomplete and we would get an error if we tried that so now let's see what we can actually do with this so down here we can create an inventory and uh we simply need to mark this uh we we need to make the type of I item so this is an array of items uh meaning an array of classes that derive from the I item uh interface and uh this is simply going to be called inventory or items uh and we're going to set that equal to a new I item array which is going to take be able to store two elements and uh in the first element so index Zer we're going to set it equal to the sword that we've created and the second index uh or the second uh spot in our array meaning index one is going to be equal to a so both both of these or these are different classes but they derive from the same interface and therefore we can add them into our array and then we can Loop through and uh turn in all Quest items so we can say 4 in IAL = z i is less than inventory. length I ++ so this is a simple for loop I hope you remember those if not go back and watch the video because uh for Loops are kind of essential and uh then we simply want to say that uh then we want to create an uh I part of quest uh and this is going to store the quest item and we're going to set it equal to inventory and then the index and uh it's okay so let me just explain what we're doing here so uh we're creating an inventory and that's going to act as an uh array of I items and it's going to have a uh total capacity of two the first inventory item we set equal to our sword because that derives from I items and uh the second spot we set equal to X and that also derives from I item then we Loop through all of the elements and uh the element that we're currently looking at is called inventory to I so uh when we uh go through the first time this is going to be the first element which is the sword it's going to say inventory zero here and the second time it's going to be inventory one which is the ax and and uh then we try and put this into a variable of type I part of quest and we call this the quest item uh so if we just do this it's going to uh give us an error because right now the inventory item is of type I item and the uh Quest item is of type iPod of quest but we can cast this object into a i part of quest by simply adding an as I part of quest so now this is red as create a variable of type I part of quest and fill it with uh the inventory item of index I as as an i part of quest object so what this does is basically if the inventory is marked with uh the IOD of quest tag if it derives from the interface well then it's simply going to uh be trans formed into the quest item variable but if it doesn't which our a doesn't well then uh this is not going to work and Quest item is going to be equal to zero because the ax is not a quest item and therefore uh Quest item will be null so now we can write if Quest item is not equal to null meaning if the object that we are looking at indeed is marked as a quest item well then we can go ahead and make sure uh then well then we are sure that it has a Turnin method and therefore we can call it so now we can say that we want to uh call the Turnin method on Quest item so that is completely uh uh right and uh this should work for any number of items that we decide to create so uh let's try and run this and see if it's actually working so let's hit play and whoops I just want to quickly make some more room here and uh now hit play again and you can see that we create a sword and uh we equip it and it says that it was equipped then we take some damage and it was damaged then we sell it and it says it was sold then we create an axe we equip it damage it and sell it and then we create an inventory array uh which is basically an array of ey items then we fill in the two items that we have then we Loop through it and we check and we try and force these items into an a a variable Called Quest item of type I part of quest and then we check if that succeeded and if it did meaning it wasn't equal to null then we turn it in and you can see here that it says sort of Destiny turned in because that is indeed marked as a quest item if we were to go up here and mark the a also so I quest part of quest item uh and uh we were to create a method called turn in again we could just copy and paste the method here or we could make this completely uh different we can say that uh name here turned in and then we can say it was it was an axe you can see we can change this uh however we would like so now when we hit uh play here it's going to go through and turn both of the items in so when we play it says sword of Destiny turned in and fury a turned in parentheses it was an ax cool so that is basically all I wanted to show you with interfaces both the really simple way of looking at it as as basically a a a way of um making your code look uh cleaner and uh easier to follow and the other way which is using the inventory uh to uh kind of uh Define how objects uh objects should uh interact cool so thanks for watching I hope you enjoyed this video I hope you could you were able to follow it uh even though uh some of the stuff showed here is actually fairly complex um I'm very proud if you've gotten this far into this series so again thanks for watching and I'll see you in the next video