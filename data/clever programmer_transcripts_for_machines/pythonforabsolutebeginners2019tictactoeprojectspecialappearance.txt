Hey you. In this video we have put together an amazing app for you with Python, it's the Tic Tac Toe app and we're gonna go through the process of building it from complete scratch all the way to the finish. Something special that we got for you in this video is that we're going to gift you this app at the end. So all it will be is it's gonna be just a link and we're gonna send you that link and you'll be able to use this application on your own, and steal it and also have access to the entire code base just in case for some reason, if you're trying to build it with us, you cannot complete it or you run into any kind of errors. This way you will be error free. So with that said, and before we jump right into it, this video is made by Aaron Bernath, who is our software developer and a new addition to the Clever Programmer team. He's an amazing developer. He's new to the team in terms of making trainings and tutorials. So this is his first app, show him some love and our goal in the future is to get Aaron to make a lot of awesome coding tutorials for this channel. I hope you love it. Please leave a comment and tell him something encouraging. With that said, let's jump right into it. (jingle music) (beeps) [Aaron] Hey, what's up guys? This is Aaron from Clever Programmer and today we are going to be coding a Tic Tac Toe app in Python. So let's jump right into it. (hip hop beats) First, let's go to repl.it, just type that in the URL bar, follow along please so you can learn. Make an account if you haven't already. This is called Repl It. Once you are done with that and click on my repls, you'll be on this page. It'll probably be empty. You want to have this stuff here. Click on the red plus sign, click on Python, which will automatically be Python three and Boom, you will be in an empty repl here. So all this is, is just a nice little environment where you can code on this website. You don't have to worry about any setup or anything. It's just nice and clean and it doesn't break which is very nice because sometimes recording on your own computer, there's a lot of weird edge cases and it's just the. So on left here, we have a little file directory. We're only gonna have one file for this project, so you don't really have to worry about that. Over here we have our one and only file open main.py and over on the right side we have a little Python environment. So let's, check this out. Yoyoyoyoyoyoyo. Okay, yo see so it works. This is where all the game will be played at. This little command line here and let's jump right in. So Tic Tac Toe. Sometimes I attack small problems this just straight in. I just start coding, just kind of hacky, but it's kind of too for these little things. But if you are working on a big code base, you actually want to think about it first. So let's at least do that first. Just have like a little bit of a overarching game logic. So let's think about it. Well, we're gonna need a board. And then we're going to need to be able to display that board. We're also going to need to play a game. So start the game and then have it keep going, alternating turns from X to O to X to O. I'm assuming you guys don't have to play Tic Tac Toe. If you don't, please look it up. All right, welcome back. So we're gonna need a function to play game. We're also gonna need a function to check if there's a win. So check win. We're also gonna need to function for checking if it's a tie. We'd also maybe need a function to flip between players. So flip from player X to player O. Flip player and yeah. And within check win, then we're probably going to do something check rows to see if there's a win and then maybe check columns. To check the whole, all the columns and then also you're gonna have to check diagonals. So to check if there is a win we'll check all these things and then at the end if there's a three in a row in any of these, then we can say, yeah, somebody won and then just return to player and so on and so forth. Checking after the tie and maybe we could just be like, hey, if the entire board is full and then there's no winner, then yeah, then it's a tie. I think maybe something like that. Maybe even one more like play game. Maybe there could be something like handle a turn. I forgot to put a little comment sign here, but yeah, handled a turn like that. Maybe this is a nice general over overview kind of high level idea of the game. So we're gonna need a board. We're getting to a way to display that board, we're gonna need something to run in an overarching game. We're gonna be able to handle turns when somebody takes a turn like taking input, putting it on the board making sure that it's valid input and then after we handle a turn we have to check if there's a win. We can check the rows, columns and diagonals and then we can check if there's a tie as well and then after all that's done, then we can flip to the other player. And then go back and then just repeat the whole process. Something like that. I mean it might change as we go, but just have a general idea of what's going on when you want to code something. If I was actually coding a different game like rock, paper, scissors, maybe I would I'm not gonna type it all, but I'll just tell you guys. If I was trying to pull the rock paper scissors, I would need, okay rock, paper, scissors. I could have the words and then I would need some way to select rock, paper, scissors and then some way for the computer to randomly generate rock, paper, scissors. And then I'll need a way to compare them and then a way to see who wins and so on and so forth. So just thinking, breaking the problem down into its little pieces we did here and then actually start implementing it from there. I it will most likely change. It always changes for me. I mean as long as you have an overarching high level understanding, then you are at least equipped to start coding. So I might delete this but I'll probably just keep it here at the bottom. Why not? So let's just start. So nice and easy. What are we gonna need first? We'll first, we're going to need a board. Very simple. I am just gonna make it list. Let's just do that and I want each one to be, each position on the board to be an empty spot. If it's empty, I just want it to be a minus like that. And then let's just a copy this. Nine times four or five, six, seven, eight, nine. And voila. Our game board was coated in approximately 27 seconds. Awesome. It's just a simple list. I just spread it out like this, so it's easier to see. So now we have our empty game board for Tic Tac Toe. Awesome, right? Let's move on. Next, we are going to need a way to display that board. So, let's get that going because right now when we hit run, absolutely nothing happens. Let's do that first. So what would that look like? We just gonna need a function, define. I don't know, display board just like that and then maybe print board at zero. Yeah, let's do it like this. Print the board at zero plus board at one plus board at two and yeah, let's just do that three times but so position zero one, two, we're gonna need three, four, five there and then six, seven and eight. Boom. All right. Yeah, let's just see how this looks. Run, it didn't work because we didn't call the function of course. So display board just like that. Now let's run it and boom, we have an empty board. Pretty cool, right? All right, so the positioning would be one, two, three. Yeah, so now that we have our board, we can move on. From here, maybe let's try to start a game. So this is the first place to start. Let's just make it a function called play game. Game, just let that. Define, I suck at this you guys. Why am I teaching this? Anyways, so play game. Play game will probably be probably be the function that drives the entire game. So maybe the first thing that we would do is okay, the first thing is display the board because when we're playing a game, the first thing I want to do is display initial board. Just like that. Always put comments in your code guys. If it's really, really simple, you don't need to like actually here, maybe you wouldn't have to because this is so well named by me that you don't actually need a comment, but hey, might as well throw it in there. It makes it easier for other people to understand what the heck you're trying to do. They can't read your mind, okay. I've had some jobs, some internships where that was an issue. I'll stop there. Anyways so let's display the board but now, we are going to need to call play game to actually start the whole function chain. So, when Python's going through this, it will create this board. It'll see this as a function. It'll save all this code somewhere. It'll see this as a function. It will save this code somewhere and then it will see this and they'll say, oh, I want to play game. So it calls this function here and then it'll actually call this, which calls this, which prints all this, which reads from this, which makes it look like this. If you're not watching. If you're looking away from your screen, that made absolutely zero sense. So make sure you rewind and watch the screen because I do a lot of highlighting here. I went to school for highlighting. Yeah I'm filled with a lot of bad jokes. Just ask Qazi. You get used to it. Anyways, where was I? So so display the initial board and then from here, maybe the next thing would have to do is I don't know, like handle a turn. So let's just try to handle the first turn first. So handle turn will be a function. I always like to put things in functions if it's a different concept, so displaying the board, I stuck that on a function. If I want to handle a turn, I'm gonna stick it in a function. Let's just do that here. So define, handle turn, boom. You have a little function coded up. I like two spaces. Two lines between my functions just to be easier to read and hear too. So handle turn. What could we have in handled turn. Well handle turn would need to first, probably get the position from the player that they want to go into. So maybe something like this position equals, what's the function input. I was trying to remember the python function for input. So input will ask for something from the command line over here and then when they enter it and press enter, then that whatever they press enter will actually go into position here as a string. So let's say, I don't know, choose a position from one to nine. And just like that. I chose one to nine because it just makes sense. If this is position one, this is position two, this is position three, so on four, five, six, seven, eight and nine. You can just type in the number and whatever position you choose, that is where your piece will go. So handle turn, how are we doing here so far? Let's just try to run this and see what happens. Boom, so as you can see, this actually gets reached. This input here and then I can just put it in a one and nothing happens because we didn't tell any, we're not doing anything with position here, but actually one went into position here and then from there we can actually deal with the game logic. So now let's actually do something with position. First of all, because position is a string, we are probably going to want it to actually be an integer so that we can index into our list with an integer instead of a string. So let's do that first. Position equals int position. And remember, position is one through nine, but the elements in our array is zero through eight. So actually, if we get position one, what we actually want to zero. So let's subtract one from here just so we get the correct index in here. So now position is correctly cast it and subtract the one from it so that we know where and the board to go. All right, so now that we have our position. Let's just try to put something in the board. So let's just say board at position equals X. Okay, easy enough. And then, just throwing a quick display board here. Let's hit run so we have an empty board printing out, and then it says, choose a position from one to nine. Let's put in one and boom, look. We chose position one which is here. We cast to an int and then we went into the board and we stuck an X in that spot and then we displayed the board again and look, that's what we have. And that's all from what? 20 not even 29, 30 lines of code, not even cause there's because there's a lot of space. 30 lines of code and we already have this whipped up where we have a board, we have a prompt, we input something and then we actually edit the board and display it again. Pretty cool, right? So let's leave this here just like this but now I want to go back up to play game up here and actually work out some of the overarching game logic. So after we display the initial board, what we want to do is we want to have a loop that can loop through turns over and over and over again until the game is over. So it'll keep going. Every single turn, X's turn, O's, turn, X's, turn, O's turn over and over and over again until somebody wins or there's a tie. So this is what it would look like. Usually I kind of have something in here and then by hack I just mean type something that I think might work and then I just try to see if it runs and then just go from there. So just follow along. So while game is still going okay, if the game is still going, then I want to handle a turn. And then after I handle a turn, actually if we're handling turn, we should probably have some way to differentiate if it's X's turn O's turn. So let's go like this. Let's just give it a thing called current player that'll just be an X or O, but later. We'll do that later. So after we handle a turn, X or O goes and takes their turn, then we want to check if the game is over or check of the game if somebody want or if they tied. So I call that check if game over. I don't know how I got there, but yeah, check if game over. And then, after that, then assuming that the game is not over and I don't break out of this loop, then we will want to flip from one player to the other. So I'm just gonna call this flip player from X to O or O to X. And then after that, then we're gonna go back up and then we're gonna go again. We're gonna handle turn with the other player because we flipped it and then we'll check of there's a just the game over and then flip the player again and go back up and then take another player's turn and then check if the game's over and then flip and his so on and so forth until somebody wins or there's a tie. That's pretty much it. So let's make these functions real quick. We already have handle turn. Let me put it down here. So we need check if game over. Check if game over. Well that needs to be a function. And all this is gonna do is actually just call to other functions. Check if win and check if tie. See how that works. See how I'm breaking up the code, the game logic. What are the criteria for a game to be over is if somebody wins, if somebody gets three in a row or if there's a tie, if the entire board is full and nobody has one yet. So those are the two criteria for the game ending. And so that's why I use that up here. I handle a turn and that's because the board state changes. And then I see if there's a game over after they placed a piece. And then depending on that, I will either stop, I'll break out of this loop somehow by maybe sitting this equal to false instead of true and then, break out. But first we need to check if the game is over. So we're gonna do that by checking if there's a win and checking if there's a tie. Next let's code up this one. Check if win. This is also a function, I keep forgetting that. Check if wins. So here I'm just gonna put a return thing just to keep it nice and clean for now, but pretty much we're going to have check rows. Like I said earlier, check columns and check diagonals. So we'll leave that there for now. I'll just put it return here so that it doesn't break when we hit run. I don't want any red things over here popping up any errors because it's just kind of gross. It's inevitable but it's still gross. Also need to check if there's a tie. So define check if tie, just like that and then I'll just return as well. I'll populate these a little bit later but I just want to get the overarching logic done first. So check off when and check if tie. So check if win, check if tie. Those are all right. So check if game over. So that's all taken care of. Check if game over. So I have, this is already made down here. Check if game over is already coded. Now we just need flip player. That's the one I was missing. So now we need one last function called flip player. Just like this and this is just going to flip the player from X to O so that we know which piece to place down and stuff like that pretty much. In the display it is currently X's turn, it is currently O's turn. Please choose a position, something like that. I think I might have most of the functions I need. I just need these three functions, but I will do those later. Let me see. All right, let's actually just see if we're getting any errors. Run it. Yeah, there's an error, of course. Games still going is not defined. So usually errors will happen a lot if you're new to programming. They usually come back and read and they usually say trace back something. Oh my God, my life is over. My parents don't like me. My best friend just left me. Somebody else just left me. Look for the error it'll usually tell you what's wrong. So it says, game's still going is not defined. I think that's here. So this is a Boolean. I'm just going to make this a global variable up here. Actually let's put a comment up here because I like having all of my global variables just like that, nice and tidy there. Game board, boom and then we are going to need, if game is still going. We'll call it game still going and we'll set it equal to true by default because we want that loop to run by default initially. The game is going from the very beginning. This is only gonna be false when there's a game over. So whenever we get a game over, we're gonna set this to false and then automatically, because this is what this relies on, if this is true, it'll run until it's good but then if there's a game over and we get a false and we set this equal to false. Then next time this goes, it'll jump out of it because we know that there's a game over. While we're at it, why don't we just make a couple other ones. I think maybe, who won or tie? Let's just put winner equals none for now. I guess there's one no winner right now. And then maybe we could change winner to X or O when there's a winner so we know who the winner is or if there's a tie, then winner we'll just say none because yeah, there's no winner. It makes sense. And maybe I'll also, I think one last thing we'll probably need is a whose turn is it? We'll just be a current player and let's just have X go first. Yeah like that. So let's try run this and see if you get any errors. We get an error again. A handle turn takes zero position but one was given handle turn I see. So we're trying to give something to handle turn, but we're getting an error. Yeah because we're trying to give something here when it doesn't take anything in the function. So let's just say okay, current player. Now let's see if we run us. Hey, okay. So we got rid of their big or red lines of doom. I just just get used to errors. They happen all the time. It's just a part of coding. I'll read them, definitely read them. They usually tell you what's wrong. They tell you what line number is wrong so you can actually just go into the code to that line, figure out what is wrong, maybe you put a few debugging statements in there and then just keep working out from there. All right, cool. So let's go back to play game. So we have the loop going and then like I said earlier, if the game ever stops from here, if the game is over and this loop jumps out, then we're gonna jump out of this loop. So let's actually put something here. So the game has ended right here. And then we can just say, remember that thing at the beginning, earlier, the global variables? We have a winner. Let's use that here. So let's say if winner equals X or winner equals O, that means X or O won. We don't know who won yet. Then we'll just say, I guess we do know who won because the winner will have who won, X or O. At least that's the idea. I'm gonna put the winner in that once we know if there's a winner. We'll just be like okay. If this person won, then winner equals X, or if X won, then winner equals X. If O won, then winner equals O and then we can just get that global winner variable from here. So we'll just say print winner. So that will be X or O plus space WN. So this'll be com X won or O won. That's an easy. Else if winner equals none, then this will be a tie. So let's just put that in like that, boom. Let's see if anything is broken. Everything's running good. Good practice is actually to unit test which means to keep running your code over and over again and make sure there's no errors and then whenever you do get an error, fix it immediately so that you're not swamped with bugs because sometimes you fix one bug and then it creates 10 others and then this just gets really out of hand. But if you fix every bug one by one as they come and then everything's always working nicely, then you know exactly what caused the error because you just made a small change to the code. So try to do that. Always try to run it. If something's wrong, fix it before you move on. All right, cool. So we have play game. I might not touch it for a little bit. I think this is almost fleshed out because we'll display the initial board and then we'll have the game going, going, going, going, going and then when it ends, then we'll just print if there's a winner or if it was a tie. So that's kind of the overarching idea of play game. So I actually think this function is pretty much done. It might be a little, a few little changes here or there but yeah, let's just put in some comments because good practice. I haven't been doing that. I'm not being a good example. I was never a good example. So my mom always tells me, I have a little sister. Anyways, we're just gonna flip to the other player just like that. Check if the game has ended. You don't really need do this because the names are so descriptive, but hey, I'm a little bit OCD, so why not? Handle a single turn of an arbitrary player? Big words, big words. And while the game is still going. So this will just loop while the game is still going and then once there's a game over, it'll break out because this will be turned to false and then we'll jump out here and print out the stuff. So, yeah. Play a game of Tic Tac Toe. Okay, cool. Why don't we just fill all these in. Display board, I'm so bad at this. I'm actually an English major. And then handle a single turn of an arbitrary player. I also can't spell sometimes or type or do anything for that matter. So let's end that there. So yeah, we are going to move on now. Currently, our current functionality is this. We have it running here and then when we never, we put in a number of valid number from one to nine, it will populate that spot in the board. So if I put two then it'll go on to three and we can keep doing this forever. As you notice, I can put it in every single spot and I can also overwrite old spots. It'll just keep overriding it as X. But that doesn't really seem like correct functionality. I mean nobody's winning, nobody's losing. Where's the O. So at least we have this basic functionality happening, but now we need to actually clean it up so that the right player plays and then if somebody wins or if there's a tie, then the game actually ends and then it notifies us that the game ends. So, I think the place that I want to do, that I want to start, next is actually check if win. I'm actually gonna change this to check for winner. I just prefer that name. Yeah, check for winner, check if tie, check for winner. So if I change this function name, I think I called it somewhere. So let's copy this and go back up. Check if game over. Okay, let's just command F. Check if win. There's only one match. Oh, it's right here. Yeah check if game over. So let's change that. So check for winner and check if tie. I prefer that. You can leave it the other way if you want. It doesn't really matter. This is just personal preference. They will both do but anyways, so this is, the next one that we need to code up. So check for winner. If we get three X's in a row, then we want the game to say, hey X won, somebody won if we get three X's in a row. So how do we check if we have three X's in a row? Well, we can either have three X's in a row in a row, we can have them in a column, going straight down or we can have the diagonals. So, let's just break it up into those three pieces. So check for winner is going to start by. Well actually, do we even have these functions made yet? No, we don't. So actually what we need to do is actually make a function for each of these comments here. So check for let's find, define. Check rows, that'll do. Check rows, return. Define check, columns. Return and the final check diagonals. I like that word. So now we have three functions that will check each of these and all I need these functions to do is if is check the rows in the board or the columns are the diagonals and then whatever, if there's three in a row in any of those rows, then it basically returns true. It flags the wild loop that the game is over and then it returns either X are O. So I want it to return X or O if somebody won and then two flag this up here, game's still going to fall so that the game ends. So return to X or an O and flag this so that it jumps out. And then, if we return X or O, then we can actually know that winner is X or O here. So let's do that. We have these, maybe I'll code these in a bit. Let's, start up here. So let's just fill this out, check rows. We're going to say row winner equals check rows. If we have that column winner equals check columns and I misspelled that and diagonal winner equals check diagonals. Winder, that is not right. Okay, so now we have those going. Let's see if you have any errors. No errors, cool. What next? So I'm assuming that when I call these, then if there's a winner in a row or a winner and a co. I said there was no typos. There's one right there. Okay so if there's a winner in a row or winner in a column or winner in a diagonal, then these will either be returned, true or false. As a Boolean, it'll say there was a winner there. So maybe we can say if row winner then okay. Then there was a win. I don't know quite yet. If there was a column winner, then yeah, there was a win. And then else if diagonal winner, once again there was a win. Else there was no win. So, if there was no win, I think we had a variable. Didn't we set a variable up here? Yeah, winner. So winner equals none. I guess we could utilize this now. Winner equals none. We're gonna have there was no win. Let's just try winner equals none. And then if there was a win, then winner equals diagonal winner. There was no win. Winner equals column winner and then for rows, winner equals real winner. I think that'll work for now. There might be some bugs, but if there is, we'll go back to them and solve them together. All right, cool. One thing I forgot to mention. If you are trying to access any global variables up here, that is outside of a function and you're trying to access it within a function or when the axis you can read it just fine, but if you're trying to write to it, if you're trying to write to a variable outside the function, you actually need to declare that variable within the function as global. So this winner is outside the function. It's considered a global variable as I noted here. So if we're going to try to set winner, that means we're trying to set a global variable. So therefore we actually need to write this here. Let me just show you, it might be a little bit, make me a little bit more sense. So what I'm doing here is I'm saying global winners. So this winner will actually match up to the winner outside here. And then, whenever we set winner down here, when we set these are the winner to a different value, this will allow us to set the global one. So we actually need this if we're gonna access global variables. So set up global variables just like that. That should be good for now. Now let's move on to check rows, check columns, check diagonals and check if tie in these, 'cause I think we need to fill these out still. So check rows. What are we gonna do if you want to check the rows of the game board? Well, very simple. We could probably just pick out each element of the row and then see if they're all equal to each other. And then if they are then return X the winner, X or O, whoever the winner is or return none if there's no three in a row. So let's just try that. Let's see what we can do. Row one, okay. So the board is a list, right? To check for the first row here, we would have to check element zero, element one and element two. So let's just say board at zero. We want to see if board at zero equals board at one, which also equals board at two. So all this is saying is we are checking row one. Row one is these three up here. So we're just seeing if board one, board two. Well board at zero, board at one and board at two are all equal. So if at the same value then this will come out to be true. And then we know that row one is actually a winning row. Maybe we should add one more thing, because I just noticed that if these three are all equal to each other but they're actually dashes, then it'll think this is a win when this is just three empty cells in a row. So let's say these three spots in the row all need to be equal to each other and they also should not be equal to a dash. So if all three are equal and it is not equal to a dash, then this is a winning row. I hope that makes sense. Now we're just going to copy and paste this into row two and row three and we're just going to mirror the same exact logic. So zero one, two, three, four, five is the second row and six, seven, eight is the third row. So now this logic here is if the first row has a winning configuration, then this becomes true. Likewise for row two and three, the same kind of deal happens. Now, if there is, if either of these are true, then that means somebody won and if somebody won then we actually need to end the game. So actually I remember we had this variable up here called game's still going equals true. It is also a global variable. So we're actually going to need to set this to false if somebody wins. So let's set up that global variable down there. Let's do that first. Global game's still going and then, let's put in some comments here. Set up global variables. Here we can see if check if any of the rows have all the same value and is not empty. That's kind of a long comment but at least it's descriptive. And then after we check that, then we can actually say if row one or row two or row three, meaning if there's a win in any of those rows, then we are going to a set game still going to false, which will stop the game, because we know somebody won. So now I felt the comment. If any row does have a match flag that there is a win. So that's what's happening there. So now we know that there has been a win and we actually stopped the game, but now we also need to know who won so we can return and be like okay, X won or O one. So let's just, we don't actually know which row one, so we're gonna have to actually check each one individually. So if row won, then we know that row one has a winning streak, a winning configuration but we don't know what value is in there. So it's as simple as checking board at zero because row one board at zero is within row one. So whatever's there, if it's an X or an O, then we know that that's the value that we want to get. So we can just return board at zero. Same thing for row two. We can just return board at three and then same for row three. If that's the winning row then we want to return whatever player is at row six. I got the zero three six from here. Zero, three, six. I also could to use one for seven or two, five, eight. I just need one of them. I just need to know if it's X or O that won and you can just leave this last return here. That's just like a clean up just in case something happens. let's run this and see if we get any errors. We do not, that is good. So hopefully that made sense. Let me just pop a quick comment in here. Return the winner, X or O. Yeah, hopefully that made sense because I believe check columns and check diagonals are gonna be extremely similar. Let's just actually, let's just copy and paste it straight into here and then just edit it as we go. You can follow me. This is very common to do. If you have code that's very similar, you can just copy and paste it and edit the numbers a little bit. So check columns, obviously we're gonna have to check change all these from rows to column. Check columns. Yeah, we're also getting the game's still going because if there's a win, we need to set that equal to false, which is the same down here. Actually I'm just gonna copy column here, copy, paste, paste, paste. If any column does have a match, then yeah. If column one or column two or column three, actually return statement here. So now this looks pretty much exactly the same as the check rows. Only difference is these numbers are not correct. This is still checking if the first row is a winning configuration. Wat we actually need to check is if foe the first column. So actually it's not gonna be zero one two. It's actually going to be I believe zero. Okay, zero one, two, three and four five six. So zero, three, six is what this should be. Zero, three, six is the first column right here. So we're checking out the first column is good. The second column should be one, four, seven, I believe. One, four, seven and then the last one should be two, five, eight. I just did this by counting here. So if this is a zero and this is one, two, then you can just kind of figure out what numbers should be in each column. You can just check it that way. So, this is actually done now unless I missed something, I don't think I did. Oh, I did here actually. So here we need to all return the first element of the columns, not the rows in case either of these is a winning configuration. So check columns, very similar to check rows. Check diagonals is also gonna be very similar. Let me just copy this into here. Copy and paste. Again, we need game's still going in case there is a win and then we need to set it equal to false. Hopefully, that's making sense to you guys. There's only two diagonals, so we actually only need two. We can get rid of this third one. We can get rid of this third one here just like that but now we need to change all the columns to diagonals. Diagonals, paste that in there. If diagonal one or diagonal two. Diagonal one or diagonal two. So now that all the variable names and comments are changed, now we just need to change the numbers to the correct ones. So let's think about it. What is the first diagonal? The positions in the board? So zero is correct because we need this top left one. And we also need the middle one. So what is the middle one? Zero, one, two, three, four. So this should be four and then the last one is the bottom right, which would be eight, the very last position. Same here, let's start with the bottom left. So zero one, two, three, four, five, six. Should be six and then the middle one, zero, one, two, three, four. That's already correct and then the top right would be zero, one, two. So this shouldn't be two. So now that we have checking if the diagonals equal to each other and checking if the other diagonal is equal to each other. Then this function should also be done, except for down here again. Again, we need to check what value which player won. So this would actually be zero and six. You can just mirror these first here because you already know that these are in the diagonal and these are in the diagonal. So you can just choose anyone you want and throw them here to get the correct value. All right, so now let's try running it again and see what happens. Let's just try to... Number two, let's see if we win. Oh, we get an error. String objects is not callable. Winner equals row winner. Type of string object is not callable. Line 76. Let's go to line 76. What is it complaining about? Here, winner equals row winner So I found a mistake here and the mistake is actually, I'm trying, I have this winner variable here. I'm trying to set it equal to row winner, but row winner is actually a variable, not a function. So these parentheses should not be here. Simple mistake, now let's try to run. All right, cool. So only X is playing right now, but if we get three in a row, it should check in the check rows or check for winner as you go to check for winner and then it'll run check rows and then it'll see if any of these rows is all the same. And then if it is, it'll end the loop and then it'll return X and then up here, it'll print. If when it equals to X, what you just set then X one. So we were about to do that now. Position three, we're about to put an X. Let's put that in here now and see what happens. And there we go, it says X one because it checks that the first row had all the same value, that wasn't dashes and then it returned this, the first one we chose. The first X and then return it and ended loop and then printed this out and say X one. So that's kind of what's going on. Now we fixed that. So that's pretty cool. So we have the winning, checking for winning is set. If they were all O's it would also work because it's just checking if they're equal, not checking if the X's and O's won and you put an O here, it would say, well then it would put an O here and it would say, O won. So let's also get that worked out. The X and O part. So where are we sitting? Here it is. So going back to handle, turn up here. We want to handle a single term for either X or O. So that's why we actually sent in player here because then we know if it's X or O instead of just X. So actually whatever the current player is, that's what we want to put on the board. If you don't just want to put an X automatically, we actually want to put player on the board because this will be X or O depending on whose turn it is. And we'll put that at the position they choose. So that's the first change. Let's see if that broke anything. Well there's no errors, that's good. Let's try winning. Winning still works, awesome. But now we also need to oh yeah flip player, I forgot about this. I put this little function in here so that after X goes, then it'll flip and then this handle term player will be called with the opposite player. So if it was X, then O will be next and if it was O then X will be next. So, I know player will get an input. We do that. Where did I call flip player from up here and game's still going. Current player is X, so I guess, yeah, when we call handle turn here, current player is what we send to the turns. So all we need to do is in foot player is change current player. So let's go down to flip player rates here and pretty much all we need to do is if current player equals X, then current player equals O. There we go. Just be very careful here. This is checking if they're equal and then if they're equal, then you actually want to set current player to O. So this has a double equals and this has a single equals. Very common mistake to make. And then else if current player equals O, then we want current player to become X. And since this is a global variable, the only way we can write to it or change it is to put this here. Current player. So let's just put some comments in here. Global variables we need. If the current player was X or then yeah. Then change it to O and if the current player was O, then change it to X and yeah, see if that broke anything. It did. Sometimes repl it lags a little bit and it gets a little bit screwed up. So sometimes actually just refresh the page. Let me copy all of this just in case. I don't want to lose all this work. So I'll refresh the page. We get brought back here. I'll move this over and then go back down to where we just were. Flip player. Let's hit run and there we go. It's running good again. So now every time X goes, then we'll flip the player to O and then O will go and then I'll flip back to X and so on and so forth. And now we actually have two players playing the game. Cool, right? And boom, X won. X on this diagonal here. So actually we have a working game. So now the only thing we haven't done yet is if they tie. If the board fills up, the game also needs to end. So oops, got an error there. That's another thing we're gonna have to handle is if they put an improper input, we need to handle that to make it more robust so that the game just doesn't break and it prints out all this error messaging here. So let's, first just try to tie. Nine and four. Yeah, so as you can see, we have a draw here, a tie, but nothing happens. It just keeps going. We could just keep putting in more variables and then it'll just keep overriding which is improper, incorrect execution. So we need to actually change that. We can check for tie. The first thing that comes to mind for me is all we can do is just check if there's a dash in the list, in the board. If there is a dash, then there's no tie yet. But if there's no dash, that means every spot has been filled up and a tie needs to happen. Very, very simple. Since board is just a list, we can literally just go like this. If dash is not in board, then we can just say game's still going cool to false. This is the thing that ends the game, remember? Game's still going is false and because it's a global variable, again, we need to declare it as a global variable so we can write to it 'cause we write to it, we read it false here. That is not on board getting the game ends and then also, you can just return. Let's try that for now. Let's see what happens. So putting one, two, three, five, six, seven, eight, nine, four. And there we go, it worked. So if the whole board fills up and nobody has one yet, then it'll just say tie and then the game is over. So that's all we need. That is done, very simple checking for a tie. We're actually getting pretty close to being done now. I think the only thing that we need to do next is to make it so that if we put in improper input, then it doesn't break it. If there's an is improper input, then we just want the game to ask the user again or just pass it and just be like, okay just choose a position again. Choose another position or something like that. So let's actually go up to handle turn, I believe. That's where we actually get the input. Yeah, that's right. So handle turn is where we get the input in and now we're actually going to need to check to make sure that input is correct. So first of all, actually we should notify which player's turn it is. So let's just put a simple print in here. Since we know the player, the player's either X or Y, we can actually putting the string here and go like that. So it will, this will say O's turn or X's turn and then then it'll ask for input from the user just like that. But then we also want to make sure that the input is valid before we cast it because, we can put in any string the input function from Python can take in any string. But then if we try to put that in here and cast it to an int, like if they put something that's not able to be cast to an int, then we're gonna get an error. So let's try that first. If position not in and this is a little trick that I found on Google. We could use regular expressions, if any of you guys know what that is, but that's a little bit advanced. Like it's a whole another thing. So this is actually a quick solution. Basically we just want to make sure that the input the user gives is in this list because we only want a specifically nine different inputs. Then we're only gonna allow these nine inputs. Obviously this wouldn't work if you wanted to allow a million different kinds of inputs, we can't type it all out. But since we only have nine, we can just make it nice and clean and simple. So we can say position, which is the thing that we get from input from the keyboard, it needs to be a string that matches one, matches two matches three or so on and so forth, all the way up to nine. If it doesn't, then we need to ask again. So if it doesn't, then we need to say, hey, position equals and actually let's just copy and paste this. Input invalid input. Choose a position from one to nine. So let's try to run this now. Oops, what is wrong? Oh, the is statement. I forgot to put a semi colon at the end or I mean our regular colon at the end. Syntax errors. That just means that Python, there's something wrong. if I forgot the F in if, that I would get a syntax error. Like what is that? So just keep that in mind. We're gonna run it now, no more error. Actually now we added this it says X's turn. It lets us know who's turn it is which is a very handy. So choose a position from one to nine. One and then we can go but then let's say we put something that's not in one to nine. Let's put z, let's put a 35. Hit enter, it says invalid input. Choose a position from one to nine. Yeah, so it's good that it caught it and then re ask again. Let's try again. Let's put in 55 this time and then we get an error. So the reason this is happening is because let's say they put an invalid input and they say it's invalid and then this catches it and it says the input is not in the correct range of valid inputs. So it asks again and it says, okay, invalid input. Please choose a position from one to nine and then it tries it again and then it gets down here and then it's invalid and it tries to do it anyways. Which means it only checks if you put an invalid input one time. So actually what we need to do is actually put this in a while loop so that it's constantly asking over and over again for valid input until it is valid. So this is a very common thing you do in programming. Instead of using an if statement, you actually use a while loop. So it'll be like while position is not in here, just keep asking over and over and over again. And actually we don't really need an invalid input. We can just ask again. So it'll say, the first it will initially say, okay, X's turn, choose a position from one to nine and then it will, get the position and then it'll say, if position isn't in here, ask for position again. Again, if it isn't in here, ask for position again. And then again, if position isn't in this list over here, if it is in here, then ask for position input again. Over and over again until position is in this range and then it will continue down here. And then since we are only allowing these digits from one to nine, this casting to an int here, if position is in this range from one to nine we put it in this in here, and then we cast it to an int, then it won't throw this ugly error here. Let's try this again. Please choose position from one to nine. We put it into one, that works just fine. Let's put in a 20, error. It asks again. 20, 20 letters, random, nothing at all. Random stuff, anything we put that doesn't exist in this list, it will actually just ignore it and then just keep asking for your position over and over over again until we give it something that works. And as you can see, the O one and right in the middle. So that's working nicely, cool. One of the things that we forgot to implement in this though is what if we put something in a spot where there's already a piece. That's an issue. So let's say we put X in one and O at five. Now, it says it's X's turn and it says choose a position from one to nine. So let's try to overwrite this O by putting a five there. I hit enter and as you can see, the O was actually overwritten. That's a problem because that violates the rules of Tic Tac Toe. So what we need to do is actually put in another check here to see if the position we chose is valid on the board. We could check that here after we pick the position and we've cast it and subtracted one from it to get the right index and the list. We can just check and be like, if board at position equals empty or doesn't equal empty, then print you can't go there. Go again. All right, let's try this. Colon again, there we go. One, five and then let's try to override it again and see what it says. It says you can't go there, go again. So cool. So it actually, this popped up. So it noticed that it was trying to override it, but as you can see it's still overrided. I think that's because we didn't actually implement or ask for the new new input again. It continued to override it. I think it just went on here. It went on to setting the board position to player. Anyways, so actually what we need here is another wire loop. This part gets a little bit tricky but just try to follow along. I'll explain it the very end clearly so that it makes sense. So actually what we're going to do is we're going to add a nother wild loop around this wild loop and just call it and just run it on a Boolean, called valid or while not valid. If the input is not valid, it's just gonna keep asking over and over again and we of course need to create valid originally and we'll just start it as false 'cause we'll assume it's not valid. So while not valid, then we are going to keep asking for input in this range, get it and then check the position and then if it doesn't equal, well actually would it be easier if this makes more sense. Let's do it this way. If we're positioned does equal an empty spot, then that means valid equals true. We can set value equal to true to finally break out of this other loop and then else then we can print this. So now let's try to run it. This should work now. So let's try to put one and then five and then five again. And this says, you can't go there. Go again. Let me try to put five. You can't go there, go again. Five, you can't go there, go again. Over and over again until I choose something that is valid like six and then you can see that it puts the value in position six and leave this one alone. All right, so this is a little bit tricky. Let me explain what's happening. So, we have this wild loop that is running on this Boolean called valid. And then, once we enter this, then we'll make sure that the position inputted is within this range and then after that, then we'll change that to the board position and then we'll check again, is this board position available? And then if it is available, then we set this equal to true so that we can jump out of here and go onto here to actually placing the piece on the board. But if it isn't, then it will say you can't go there and go again. This will stay vulnerable, stay false, it'll come back up here and then it'll run this again. It'll ask for more input over and over again and then once it gets a valid input, it'll check to see if the board is available. And then again, if it's a valid, then it'll go on, but if it's not, then it'll just say you can't go again, it'll loop back up and then continue over and over and over again. So a little bit tricky. Sometimes it's input stuff kind of sucks. But if you're using a lot of other frameworks when you are actually building bigger apps, a lot of this input stuff is taken care of for you already. It's a not too often that you have to actually do it yourself like this. But I mean, it's good exercise to understand the logic that's going around. I think that's actually it. I mean I haven't put comments everywhere, but I think we have a fully functioning Tic Tac Toe app. Pretty cool. So, let's just try to row it one last time and go through this game and then go through all the cases and see if everything's working correctly. So if we put it a valid input in, then yeah, it puts it in the right spot. Put another valve in and put in and puts it in the right spot. If we try to overwrite by putting it in position two it says you can't go there. Okay, let's put it in position three instead. Okay, now it's O's turn again. Let's put it in position five. And then X's turn let's put it in position six and then change position from one to nine. Let's put it here so it's one, two, three, four, five, six, seven, eight. Position eight, so we can put O and an O should win and as you can see, O won, Very cool. Now let's run it again. If O wins, then X can also win but let's try to put in some, let's try to tie. One, two, three. I memorize this little a sequence here quickly. So this looks like a tie and game. If we put this in here then yeah, I'll print tie. So it looks our Tic Tac Toe game is working as expected. Everything is working nicely. It is pretty robust because it only allows for certain inputs. It doesn't allow for overwriting your certain pieces and it out prints everything. Ii lets the players know whose turn it is, it lets them know what the input and everything. So this is a very nice small self contained and robust little application and you guys followed along and you coded it yourself, so good job. I would actually advise you to look at the code. I'm going to upload the code with full comments, probably somewhere maybe in the description of this video or something and then you can click on it and really read it. I'll try to explain everything as best I can in the comments so that you can really trace the entire thing yourself and then things will just be clear. You could also maybe perhaps try do little exercises like change the code See if you can change it instead of having X's and O's as the players. Maybe changes so that it's A and B or something cool like that little challenges. But other than that, good job guys. You created your first Tic Tac Toe app with me and I hope you enjoyed it. I hope you learned a lot. I hope you guys liked me. I'm a new person on this channel right now. Qazi kind of allowed me in here after I begged and begged and begged and begged. But yeah, I'm here now. So expect to hear more from me. Thank you all for listening and I'll get better at this as I go. So if there's anything that'll offer anything, just give me a chance. I'm gonna keep working at this real hard to give all you guys as much value as I can. A lot of free value, any kind of value I can offer and programming and what not. But yeah, again, I am Aaron from Clever Programmer and thank you all for watching. Good bye. (hip hop music)