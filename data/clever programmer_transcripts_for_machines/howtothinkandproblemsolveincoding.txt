[Qazi] Hey you, what is up? How's it going? This is Qazi from cleverprogrammer.com, also known as Papa Python. Today I want to talk to you about the power of how to think and solve problems effectively. Alright, I wanna talk to you about how to think about code, how you actually go about dealing with problems. One of the things that I see with a lot of people that are starting out with code, who are beginners, I was actually just on a call for my Profitable Shortcut program, it's a group coaching program and we have lots of students in there and we have questions like these, it's like, how do I improve in coding, I feel like I'm stuck. Either they find that they're in this tutorial purgatory where they'll spend a year learning something only to then forget it, and then, do it again, and again, and again. And they never feel like it sticks or that they understand it. I made a video, oh by the way this also day four of my video challenge, so I'm doing a 30 days of videos, one video a day. So if you wanna do some kinda challenge do it with me and you can also follow me on Instagram, CLEVERQUAZI, and I am a lot more active on my Instagram and you can also follow me along and see everything that I'm doing including the challenges and my routine. But, back to the video. So how do you think about your problems effectively and how do you actually improve? So in my previous video, I talked about what are the effective tips to learn how to code? Alright, and that was also really amazing, I'm gonna pop that up right here. But, in this video I wanna talk to you about how can you actually think about solving problems. So let's say you have some kind of problem. What do most people do, they just start writing code, especially beginners. They just start writing code and they try and see if something works, if something doesn't work, they just write more code, print more stuff. But they're thinking about the program very, very linearly. It's this one thing. So, let's say you have to make, I'm gonna use a simple example, let's say you have to make a TicTacToe game. If they have to make a TicTacToe game, they'll just start writing it and they will think of everything as just one thing. So this includes, you know, they'll think of the diagonals and the columns and the rows and all that as one thing and they start coding something up. But, what you actually need to do before you start on a project like that is, use frickin' whiteboard. Whiteboards are awesome, so get a whiteboard if you don't have one, invest in one, it's one of the best investments you can make. But, if you don't have a whiteboard just use a piece of paper or something, okay? But you want to think about this problem and coding is thinking and I feel that sometimes people forget that. When they're following tutorials, they're just typing stuff and following along, they're not actually, actively thinking. When they are trying to solve a problem, they're just like typing stuff, running it in the terminal and see if it works. But, if you wanna go about solving a problem you need to think about it. So, if I have to solve a problem like the TicTacToe, right? I'm gonna be thinking about, I'm gonna break it up into different components. So TicTacToe, first of all, TicTacToe I have to come up with a representation of the grid, of the board. So first I'm gonna be like, okay, first, the thing I'm gonna have to do is actually create a board, right? A three by three board. So you know, that might be like this type of board, okay? And whatever, for now, I'm just gonna have all X's in there or all zeroes or ones, doesn't matter. But first I have to represent this, this is my first problem. Then my second thing is that how do you detect a win? So I need to be able to detect a win. So what are some ways you can detect a win? Well, okay. I can detect a win based on rows, so if you have all three in a row you can win, right? And you have to check consecutively. Then I have to detect a win on the columns and then I have to detect win on the diagonals. So that means that I'm gonna create like a function and I'll have one function that'll just be called like check rows. Pretty simple, right? So I'll write one function and all that functions job is to check the rows. That's it. So what I'm doing is I'm taking this giant problem and breaking it into its component parts. Taking this giant problem. It's almost like how do you eat an elephant? How do you eat an elephant? You eat an elephant very slowly in one bite at a time and over the course of days, weeks and months. I never ate elephant but I assume that's how you eat one. Probably can't eat one in one sitting. Most people code like they're trying to eat the elephant in one sitting. It's not gonna happen. You have to break it down. You have to understand all of the component problems that one problem has, right? It's a layer of problems. So I want to be able to check the rows, then I want to create a function called check columns, alright, and then I'll create a function called check diags. So now I'll have three different functions. One function can check a row and tell you whether there's a win, somebody has won or not. Then we have a function called check columns and that can detect if somebody has won on the columns or not, then we can have check diags that can check if somebody's won on the diagonal or not. And then we can have something called check win, alright? So we have all these functions. The check win function, well all this can be, it can just be comprised of all three of these functions, right? Because you can just run check win and then it will run check rows, check columns, check diags, and it will run all three of these functions until it finds a win, alright? So right now we're just trying to think at a high level. We're not trying to get too bogged down in the coding details of how it's gonna work, what data structure we're using, we're trying not to think about all those things. We're just trying to think at a high level of this problem and try to solve it in these basic components. Eventually you'll have this todolist and then all you do then, then the part is easy, you write code, you do research, you figure out technically, but now you have a big goal of what you actually need to do. Because otherwise most of the people, you know, are coding blindly. I have all these functions that can tell me if a win took place, right? And then I have functions that can determine a loss, we can have a function that can detect whose turn it is. Or whether it's nobody's turn, right? So we need some states as well, for this board. We need to have a state where it tells us whether the game is still playing so for example, we can have a still in play or we can have a state that says you know, game over, so I'm meaning somebody won. So what this would do is if we have a while loop, right? And we're running this game over and over and over again, then it would be in this state, it would always check if the game is still in play, but if the game is not still in play and somebody has won and somebody has connected all three in their rows, columns, and diags, it will change the state of the game to game over. And then it'll stop the game, right? And then a new game might start after that. The point is not to solve this TicTacToe problem right here, right now, but my point is to get you to actually think at a higher level about your coding problems. You need to break them down into components and in the start it's gonna require you to understand it in English or whatever language is you know, your mother tongue, but first you're gonna actually need to understand the problem in English and be able to describe it, visually have it somewhere, then you need to break it down into its component parts and know exactly what you need to do. So first I will say understand in English. Two, break it down, okay. So you want to break the problem down into its component parts, that way you know exactly what it is you need to do and then you have a plan of action. So after this once you've broken it down, you know, you have a plan of action. And then it's simply about what order you want to do this in, what it's gonna be. Are you gonna make check rows first, are you gonna make check win first? Are you gonna make check diags first? Or are you gonna make 3D board representation first? So it all is gonna be about you know, what your plan of action is, and then once you get inside of a function, that's when you start needing to worry about what data structure you'll be using, how you'll be actually making it happen. You know, for example, are you going to be using a dictionary or are you gonna be using a list of lists to demonstrate a 2D board, okay? So that, those are the things that you're gonna need to think about later. So hopefully this video has helped you or at least reminded you about some of the things you might have already known, but I encourage you you know, again to do a daily challenge with me because I'm doing a video challenge, you can do a thirty minute or twenty minute video challenge with me. So I'm on day four of this, so you can start tomorrow or the day after and just go with me in this. With that said, I hope this was helpful for you. Thank you so much for watching and leave a comment on how you think you can apply this, alright? I'm now being very engaged on my platform, on Youtube as well, so I'm responding to a lot of people, but if you really want to be able to get in touch with me or you want to see my routine and behind the scenes so you can be inspired. Or pick up a lot of tactics and strategies from me, definitely follow me on Instagram because I am really really active there. I'm putting stuff there every single day so you can see a lot of behind the scenes stuff. Alright, thank you so much for watching, as always, I love your face and I'll see you in the next video. Yo guys, just finished video four day four challenge, got my setup right here, we talked about lots of cool stuff, let's keep going for thirty days and if you have something you want to be accountable for, hit me up or just do it, it's gonna be fun. Alright, peace. (upbeat outro music)