yo what is up guys coach daniel here and today i want to talk to you exactly why you want to use big o notation so that you can crush technical interviews now guys in the past i've actually had the opportunity to interview and get job offers from top tech companies like youtube and microsoft and i have to say it was honestly thanks to what i was able to learn with big old notation because it is an important concept when it comes to software development and if you can get this down you're going to be able to cross your technical interviews but not only that you're gonna be able to create successful algorithms and use data structures properly in the future now we've heard you i did the last data structure video and a little bit high level but you guys wanted me to go deeper so before i start to go deeper into all these other data structures you need to learn about big o notation which is exactly what we're gonna learn today guys this is the foundations the basics what you need to know so that you can make sure you're creating the most optimal algorithm and when you show up to those technical interviews by google or microsoft you absolutely crush it so before we get into it guys please go ahead like this video send this video out there to the world let's beat the youtube algorithm let's pummel it down so that we can share our message with more people and only that don't forget to subscribe and hit that bell notification icon so we could keep on doing deep dive content for you so that you'll know exactly what you could do to land your job as a full stack developer as a web developer but you understand the nuances and the high technicalities of everything so with that being said let's go ahead and get into the video so to start it all off i want to tell you about an analogy a story that really helped me to understand the concept of bigo notation and why it is so useful how it actually allows us to see how something is more optimal compared to something else and this story is very very simple imagine you live somewhere in the united states in the west coast right and you have a friend of yours who lives on the east coast now you want to send your friend an amazing video that you were able to get in beautiful sunset in california and they're all the way in florida now you could send it to them two different ways you could send it by uploading it to the cloud and they download it or you could send it by downloading it to a solid state drive and sending it over the airplane so that when it gets over there to florida he gets it and then he can download it and he gets the video now right off the bat you might be thinking well yeah obviously the video would be faster it would be until some point because let's think about it if this was just a simple one minute video it would probably take that video to send over the cloud maybe just about five to ten minutes at most if you were to send it over an airplane it would take the six hours just to get from la all the way down to jacksonville florida but now let me ask you this what if the video was actually a humongous video what if it was like this 10 hour video what if it was all the clips that would be needed to create one of these amazing movies unedited raw video something like 300 gigabytes some ridiculous amounts well now the story changes because now if you happen to upload it to the cloud that might take around like five to ten hours and if they're downloading it that might take another five to ten hours but think about this downloading it down to your ssd would just take a couple minutes flying it over to florida would take six hours and then downloading it from the ssd will just take a couple more minutes so now if you have this humongous video it would actually be faster for you to send it over the airplane as ridiculous as it sounds and this is exactly why big o notation is so useful when it comes to code when it comes to functions that you're running big o notation is essentially how long a chunk of code takes to run depending on how big the input is and how does that scale over time so again taking it back to the analogy if i just had a small input or a small video then it would be faster to just send it over the cloud but if i had a huge input or a huge video it would actually be faster to send it over the airplane so when we start to look at code and we look at a chunk of code we want to ask depending on the input if the input grows over time how is this code going to execute over time is it going to take longer and longer like uploading and downloading to the cloud or is it going to stay constant like just sending it over the airplane so this epic analogy allowed me to understand why it is that we want to look at the code and start to see where it will be optimal and where it's going to take longer and how it acts over a long period of time and how it scales with the input but now the second question becomes well how do you actually now keep track of this time how do you actually see how something is going to scale with time well it's very simple this is specifically where the big o notation comes whenever you see the o with the parenthesis and you see some function inside all it is is a representation of how long the chunk of code is going to take over a long period of time so quite simply put if i were to ask you if you were to run a mile on the track how many laps would it be you would tell me four laps if i say 3 miles you would tell me 12 laps so it's just a different way of representing how long something takes and this all comes down to just understanding that the computer is going to take x amount of time whether it's milliseconds or microseconds to execute just one line of code so you could come up with the mathematical equations how long something is going to take now in big ol notation these equations don't have to be perfect but they just have to give a good model of how it's going to act over time guys today's sponsor is hostinger and the reason why we decided to partner up with hostinger is because if you really want to start to generate money and make money as a developer whether it's freelancer or whatever that is you're gonna have to learn how to build websites and that could be for either specific clients that you get as a freelancer or even for yourself if you're trying to build your own portfolio where you could showcase your own projects so what i want to do is i want to get into the website builder to show you how simple quick and easy it is to make websites so once you start going to the web builder you could start to build a website from all these different templates that they have available to you when you get the template and you select it you can now go to the website and it makes it easy to be able to modify anything from the website whether that's just changing the pictures or changing the text so again if you do have a client who's looking for a good website that you're able to get from as a freelancer you can then create fast websites for them and again you can make it super beautiful design is easy to use easy to implement and the websites you'll be creating from this you could definitely charge a lot of money for you can start to build your own online portfolio because when you're submitting job applications or when you're trying to get a next contract you're going to want to show them the work that you've done so by creating an amazing website putting your projects on this website this becomes your portfolio this becomes your way of showing yourself and branding yourself so that you can land that sixfigure developer job so if you want to create a website or host your domains what you could do is click the link below and you're gonna get a special seven percent discount from us just make sure to use the coupon code clever programmer that is one word clever programmer so guys make sure to go check out hostinger so that you can start to build beautiful websites or buy your domains very quickly very easily and very effortlessly so let's go ahead and jump into the code so i could give you a better example so simply put if we just look at this function right here all we want to do is we're looking for an item so we have a for loop that's going to loop through an array or a list and it's going to just find for the specific match that we want whenever matches it returns the specific index when it doesn't match it'll just return negative one because it didn't find the index now what you need to understand is each line of code is gonna take some time for the computer to execute it so the minute the computer starts with the function it's going to take milliseconds for it to execute this line of code and it's going to take another fraction of a millisecond to execute this code and it's going to take another fraction of a millisecond to execute this code so on and so forth so now we can start to see why it's important to look at the input so in this case the input would be the items this would be the list of items what we're noticing is this for loop is going to go through every single item just one time if the list of items is of size 20 that means worst case scenario where there is not a match this is going to loop 20 times so now if the the items is 50 it's gonna loop 50 times the items is 1000 it's gonna loop 1 000 times so we start to notice a trend here as the input grows the time is going to grow or the time that it takes is going to grow in the exact same proportion and this starts to represent a line called big o of n or it's linear where n is just some representation of the input where n is just the size of the input now it could be m it could be x it could be whatever variable you want but just it is standardized to start with n as the initial size of an input so now that that's making sense and we understand that each line of code is going to take a fraction of a millisecond to run and if we have to run it x amount of times because of the size of the input now we can start to graph how long something is going to take over a specific period of time now again i said we don't have to be specific so very often it's gonna boil down to just a few different types of functions that we can get so let's dive into it real quick and let me show you what functions these are now here in front of me i have this amazing graph i think it's amazing because it's color coordinated it's going to help you to see what is an optimal algorithm versus what is not an optimal algorithm before we get into that let's observe and see what some of these lines are so if you remember your ti 89 you could just go into the calculator put y equals x and they'll graph something for you so if you were to graph all these functions you would see a very similar thing so here at the very bottom we have big o of one which is just a constant this is very similar to when you have like your y equals five and you just see a straight line this means this is the most optimal type of algorithm because it doesn't matter how big your input gets right or it doesn't matter how many operations you have it's always going to be instantly whenever you ask for that operation right above that we have log of n log of n would be like if you were to divide something by two every single time very similar to binary search you get somewhere really really quick after that we have big o van which is what we just talked about where depending on how large the input is that's probably going to take the same amount of time because you're just scaling those operations linearly and then we have n login which might be hit up by some sort of sorting algorithms like merge sort where you would multiply n times log in and it would start to grow over time and then we have the gross algorithms that nobody likes which is like n squared 2 to the power of n and n factorial now again the color coordination is going to tell you which are the type of algorithms you want to achieve and you want to go for so if you have an algorithm if you have a way of solving something that takes n squared that's probably a horrible way to go about it right they labeled it here red for horrible so you're going to want to try to improve that at least to end login if you can't improve it to n or log in as far as you can but here's the reality there's going to be some things that just cannot get better than n squared there's going to be something that just can't get better than two to the power of n for example the hanoi towers you could look at that problem and see how that's gonna be something that can't really get any faster so the reason i show you this is because these are the different types of time functions that it's going to boil down to most of the time now the reason i say boil down to most of the time is because depending on the function it's always going to change and what your function actually is but there are several rules that allow you to simplify the function because again we don't want the perfect function we we just want the function that can describe how this algorithm is going to act or how this chunk of code is going to act over a long period of time with the bigger input so i want to get into some of these rules that you're gonna encounter whenever you're really trying to understand how this piece of code is gonna function over a long period of time so as you've seen the code before here we have a simple for loop that is gonna take big o of n time so it's gonna be linear and then here we have another for loop that's gonna take n squared because it's two for loops that are nested so the first thing i want you to realize if i was to ask you what is the run time of both of these put together what you're gonna do is you're going to add all of the different steps so if you have one that's going to take big o of n and you have another one that's going to be n squared you're going to create a function that is called big o of n squared plus n they want to make sure that the more dominant parts of the function are put up front the reason n squared is more dominant than n because if we were to refer back to this chart n squared is going to take a lot longer than n over a long period of time so n literally becomes irrelevant and that's the rule for number three whenever you do have a long function like that you can take off all the nondominant factors here and this big o of n squared plus n is literally equivalent to big o of n it gets simplified to big o of n squared because if we look at this graph if we increase the input the operations are going to be way more with big o of n squared to where this is irrelevant the x operations that you add with big o of n are completely irrelevant when you start thinking 10 000 inputs 100 000 inputs 1 million inputs so the first rule is you want to add the steps the second rule is you want to simplify everything by just leaving the most dominant algorithm or the algorithm that's going to take the most amount of time the third thing you want to do is you want to take off constants because in reality they're not going to matter so let me give you the perfect example if we go back to this function that are labeled as big o of n in reality this would be big o of 2n now the reason is because if the size n is 100 we're gonna see this if statement 100 times but we're also going to hit this for loop 100 times and assuming we never see the match then we're finally gonna return right because if you start to see how something acts over hundreds of thousands of inputs millions of inputs that difference with the coefficient in front of the input variable is literally irrelevant so you want to make sure you drop the constant so if you have big o of 2 n it would just become big o of n if you have big o of 3 n squared it would just become big o of n squared and here in line 24 i have the perfect example even if it was 5n even if it was 500 n it would still become just big o of n because the coefficient or the constant is irrelevant to how it's going to act over a long period of time because it's just the constant now finally the last rule is you have to take into account the inputs if you're bringing in two different inputs then you just can't call them both n because again n is just like a variable and it's just representing a specific input but imagine if we were to go to this one where it's n squared this is n squared because this for loop is iterating through items items is input number one and then this for loop inside is iterating through the same thing which is items which is one so that would be like n times n which is why it's n squared but what if the outside loop was iterating through items and then the inside loop was iterating through a different array well now items would be input n and that would just depend on however long n is if it's a thousand variables n is a thousand if it's ten thousand twenty thousand whatever number that is but then input m or a different variable would be representing of the second array so you would get something like big o of n times m but the reality is is this is very similar to n squared because you depend on two different arrays but the reality is worst case scenario they both get really really big and then it's going to take a long time and it would take the same amount of time as big o of n squared so guys that is a deep dive into big o notation again i just want to remind you big o notation isn't about having the exact formula you can come up with the exact formula you can literally count and estimate every single line of code that is going to be executed depending on the size of your input but the point isn't that the point is just to see how your function how your piece of code is going to act when the input grows over time when it goes from an input of size 10 to 100 to 10 000 to 100 000 to 1 million to 10 million how much longer is your function going to take over specific period of time i hope this was able to start to bring some value and solidify some of these ideas because very often people tend to be a little bit scared of big on notation because yes it has to do a little bit of math but if you start to nail down these skills if you start to practice it if you throw yourself into a bunch of different types of for loops nested for loops and all these crazy things you can start to see a lot of different algorithms you can start to see how fast they act you're gonna start to understand how pieces of code are going to act over a long period of time and it's going to become almost second nature for you to be able to get the time complexity of a specific thing now again the reason the time complexity is super important is because you're probably going to be asked these things in technical interviews for one specific reason because if you can understand how a function will act over time you'll be able to solve the right problem with the right data structure with the right algorithm and you become a problem solver because if you don't know these nuances if you don't know these difference of how a piece of code will act over time then you might implement the wrong solution and that is not good especially if you're trying to become a six figure developer right because someone who gets paid six figures wouldn't be making these kinds of mistakes right someone gets paid six figures will be going through those technical interview questions so if you do want to get on that path of becoming a six figure developer not only that we also have a free training for you go ahead click the link below in this training we're going to teach you exactly how you can become a six figure developer give you the exact road map that you need and you can master front end javascript so that you can start to get the right skills in place and become that six figure developer because it's not just about big o notation you also need to have the skill of developing websites you also need to have the skill of creating beautiful software that solves hard problems to solve in the most optimal way so click the link below watch the training get started and get enrolled with profitable javascript so you can become an amazing master of javascript from development and get those interviews for your dream job as a six figure developer and then with everything that we just talked about today you absolutely crush those interviews so guys that is it for this video i hope you got a lot of value i hope that you now understand what big o notation is and time complexity and how you can use it so that when you go out to those interviews you absolutely crush it if you haven't yet already go ahead smash that like button i don't know what you're doing if you haven't and also make sure to subscribe because i am going to be getting on here i'm be dropping more content more of these tips more of these things that allowed me to land job offers from companies such as blue origin google and microsoft i just want to give you guys everything that i've learned everything in this head i'm trying to transfer you so guys give us a like please make sure to subscribe and hit that bell notification icon so you can get notified the minute we drop these fire videos because i'm gonna create a series on data structures so that you could crush those technical interviews you could become a master javascript developer and land that six figure job all right guys that is it for this video i hope to see in the next one this is coach daniel signing out peace