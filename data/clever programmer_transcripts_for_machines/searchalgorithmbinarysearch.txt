yo what is up guys coach daniel here aka data structure papi aka algo daddy whatever else you want to call it and today i'm going to talk to you about algorithms specifically how to make sure that using the optimal search algorithm now these are the things that you really want to dive into so that you can ace technical interviews i was able to interview at youtube microsoft and blue origin and actually get offers from them because i was able to perform well in the technical interview so what i want to do here is i want to teach you guys the things that i learned and the few things that you have to know so that you can make sure you can ace these interviews and absolutely crush it and get that job offer working as a developer at your dream company so with that being said guys make sure you hit that like button so we could push this video out there and beat the youtube algorithm smash that subscribe button hit that bell notification icon so that whenever we drop videos like this you receive them right off the bat you get the notification icon and you can become an expert developer all right guys well with that being said let's go ahead and jump into this video so guys like i mentioned before i want to dive into algorithms in the next couple videos because some of these algorithms are the fundamental algorithms that if you know and you understand you're going to be able to apply and use when it comes to data structures specifically in this video we'll be talking about search algorithms so what a search algorithm really means it's just a different way of trying to find a piece of data from a larger data set sample now this is important because there's lots of different ways they could try to find this data we want to make sure using the most optimal one depending on what data structure using depending on how you're storing the data and if you're able to use the most optimal one then you can make sure that can scale over time so let me give you a simple example imagine that you have a phone book like the old yellow pages thousand pages long and it has all of the addresses of everyone you know around you there now if you're looking for a specific address for example if you're looking for algo daddy so you're looking for the ds then one way you can approach it is you could start to flip the pages through the book one by one by one by one by one until you get to the letters ds and then you start to look for the next one which is the d a d a d so on and so forth until you get to i'll go daddy if it's sorted by the last name another approach you could take is you can look at the side of the book where you see the letter separated you open up the d section and then you partition that or you split that up and then you look at the next letter so now you see d c so you would know that you would have to go to the left so you get a couple more pages and you flip to that point and you keep on doing that until you find the page that's going to show you i'll go daddy that's me now the thing about both of these ways of finding that word that you're looking for are two different approaches they're two different algorithms to finding the word but one of them is going to be much more effective because if you take a word that might be towards the end of the thousand page book it's gonna take you longer to get there now not only that what happens if this thousand page book ends up being a yellow pages of the entire world into ten thousand page book now you're gonna see the scale of how long it's gonna take to go up tremendously so if your book goes from 1 000 pages to 10 000 pages the scale of the input goes up by 10x if you have your algorithm where you go page by page by page by page that is going to take you 10x longer as well and that is what's called linear growth if you look at this graph here i talked about bigoh notation and time complexity before this is gonna become really relevant when you're looking at different algorithms and the most optimal one and if we talk about that linear growth that would be like this line right here which is big o of n so if your input size your elements increase by 1000 your time is going to increase by 1000 and it creates a linear line but if we look at our other example where we're partitioning the book in half every single time until we get to the point if my book is a thousand pages long it's only gonna take me 13 halves to get to the page that i'm looking for so the input size is of size 1000 it would take you about nine to ten times to be able to find the word that you're looking for so the input size is of size 1000 it would take about nine halves nine times of having that input until getting to the page that you are looking for so if we look at this and we grew that input size from 1 000 to 10 000 and we do the algorithm where we cut in half every single time we're not gonna experience such tremendous growth in how long it takes because now we're dealing it's not going to be as slow as the other algorithm as the input grows because what happens is if you look at big o of log n if your input is of size 1000 it'll take you 9 to 10 times to get to the page they're looking for if your book grows from size 1000 to 10 000 it's only going to take you about 14 times to look for the page that you are looking for so it doesn't grow by 10x like the linear growth would it only grows by a small factor which that ends up looking like the curve of big o log n so this is why big o complexity is super important and these are the things that if you don't quite understand you could revisit my previous video where i dive deep into big o notation and time complexity so by now i hope that you understand what we are trying to do with this video because there is different types of searching algorithms they could use to be able to look for things so what i want to talk about now is the one that you want to familiarize with yourself the most the one you want to familiarize yourself with the most and the one that's probably most commonly used and the most optimal in most cases that's lots of most and that is going to be binary search so binary search i already introduced you to the idea but the word binary means you have two options right with binary search what you're going to do is if you have a sorted array or an object that has sorted data it's going to be very simple you're going to go to the middle and if the value is less than what you're looking for you now have a new range which is half of what you had before then you're going to go to the middle of that and if the value is not equal to that and it's less than that then now you have a new range of what you're looking for so each time it's getting hacked and this is very similar to that big o log and curve that we're looking at that is very optimal and very quick so what i want to do next is i want to dive into some code so we can look at what the code would look like that way you can go implement it because the thing is when you're in these technical interviews honestly most of the time they're not going to ask you to implement it but they might ask you questions about it or you might have to solve a problem that requires some sort of searching so if you could point out that you're gonna do some binary search here they're not gonna ask you to implement it they're gonna at least know that you're aware of it that you know about that you understand why binary search would be so important to being able to solve the problem in the least amount of time so let's jump into some code alright guys so what i did here is i got a binary search function from geeksforgeeks this is a simple one that you can implement now i do want to mention there's different ways you can implement this i wanted to show you guys with a while loop you can also do it using recursion i'm doing the loop just because for for some people recursions a little more complicated and loops are easier so it's going to be very very simple the first thing we want to do is we're going to set up a start and an end index so what that looks like is whenever we have our array we just want to know the index of the very first element which is obviously the fir the zero index every time and one of the index of the last element which would be the size minus one this is going to allow us to start to be able to find where the midpoint is of the range that we care about because in the beginning we care about all these numbers but once we start to partition into the half and we know it's in the lesser half we don't care about the rest of these numbers so we could get rid of those now we just focus on half of those numbers and that's why we're having it each and every single time so the important thing to know is our loop is going to keep on going until the start passes the end so again to clarify on that if we have our array we have our start index and we have our n index every time i check for the middle and say that value equals is later than or greater than i'm gonna know where i want to go so if i have i'm looking for the value of 10 and i see that here the value is 5 then i know the 10 is going to be somewhere in the upper half so what i want to do is i want to make this start point to where the middle was and then we're going to choose a new middle one because we don't care about the rest over here so we're going to keep on doing this till this range between the start and the end gets closer and closer and closer until it's on the exact same index and or it's on this exact same index or it passes each other that means we've already searched past the havings that we can so the first thing we need to do is we need to see exactly where the middle index is now this one might seem a little bit tricky because what if the array size is an even number for example if i have four different indexes which one is the middle index is it this one is it this one well the cool thing is it is up to you and how you want to implement it so this array is of size four i know two is halfway there what we could do is we could simply just pick the one spot we could pick the one index or we could pick the two index either is totally fine in this example looks like it might make a huge difference because the small input but think about it if you have an input of size 10 000 then you're not going to really care if you choose between 5000 or 5001 because now we're looking at a bigger input size a bigger scale for the sake of this example what you find is we're gonna go ahead with the the smaller number which is the math.floor so what we do is we get our start index we get our end index we add them up so that gives us all the elements in the range that we're looking for in this case it would be all of it and divided by two and we're going to round that down to the closest number so that's going to get us the index right in the middle or it's going to get us the index if there's two in the middle the lesser index so once we have that middle index the first the next thing we want to do is we want to actually compare that value to the value that we are looking for because in the end we're searching for this data we want to see if this data even exists in this data set in this sorted array if it equals then awesome we could just return true or return the value to let them know that we did find this value inside of this array if it doesn't equal then that's where the binary search comes into play so what is happening here is we've set up our start index we've set up our n index and we found our middle index we saw that the value we are looking for x does not equal the value that is in this middle index so this would be like a y or something that is not an x so in that case we want to see all right the value y is it greater than or is it less than the value x because if the value y is greater than what we're looking for then we know we want to go to the lower half if the value is less than what we're looking for then we know we want to go to the upper half so we want to go to the upper half because the value we're looking for is less because the value we're looking for is greater than what's actually here it's very simple we just need to make this assignment our new start and when this is the new start we're going to run the exact same process but now we're going to find the new middle over here so we look at our new range that has been cut in half because we don't care about all the other stuff because we know it doesn't exist over there and then we're going to do the same thing i cut this in half and see the value in the middle is that the value we're looking for if not then we're going to cut it in half again so these are going to be changing and what that looks like is if the value is less than x just like how we talked about so if the value is less than x then we know x is going to be on the upper half and what it is that we're looking for so in that case we're gonna set start to be at the mid plus one so we do the plus one because we could disregard the index that we just checked which is the current one that we're at which is the mid right and we saw that one's not part of the equation anymore however if the value is greater than x we're going to go to this else we want to push down the end to the middle so we now have our new range and you just keep on doing this partitioning in half and half again until at some point they're gonna cross over or they're gonna be pointing to the same value and that's when we exit the loop by that point since we never saw the value inside the array we know that that value is not exist inside of this array so guys there you have it now you have another tool for your toolbox what i want to do these next couple of videos is i want to go deep into data structures and go deep into algorithms and give you the essential tools because the reality is you don't really need to be aware of all of them you just need to be aware of the core essential foundational data structures and algorithms that are going to help you out with your job interviews they're going to help you out in your actual job if you understand these core fundamental data structures and algorithms the rest you can learn if you need to learn it in the future the rest all derives from this and what you're learning today so what you have now is one of the best most optimal searching algorithms now of course it could be more optimal if you're able to divide by three by four by more than just by two if you're able to get rid of more things like that at something but at least you understand the idea that if you're constantly dividing by a certain number of all your data sets and you're just picking the portion dividing by that again picking the portion dividing by that again you're gonna get to your solution very quick i just want to reemphasize that number again if you were to divide by half every single time and you were trying to get a number between the one and one thousand that would take you just about nine divisions 10 divisions to get to where you want to go if you were to multiply that by 10 so you're at 10 000 you would only add about four more division and you'd be at 13 divisions and that's all i would need to take but you were able to put a larger input so this is why it's such an optimal algorithm because if you keep on bringing that number up it's crazy how small of a number is going to increment in terms of how many divisions you have to make like i said before guys this is binary search this is going to be very crucial to understanding data structures algorithms learning the most optimal way i haven't talked on bigo notation which if you forgot about you could go check out the last video but these are the things that we're going to build on to help you in your foundation to help you crush software developer interviews now if you're in a point where even struggling to get software developer interviews then maybe we need to work on your portfolio what i want you to do is click the link below because we have a special training for you where you're able to build an amazing project that you put into your portfolio start to get these interviews then rewatch these videos so you could crush those interviews and land your job as a sixfigure developer so go ahead click the link below like this video let's beat the youtube algorithm gods go ahead and subscribe hit the bell notification icon so that whenever we drop out more fire content just like this one so you could crush those technical interviews you will be notified alright guys that is it for this video coach daniel data structures papi i'll go daddy is signing out see the next one you