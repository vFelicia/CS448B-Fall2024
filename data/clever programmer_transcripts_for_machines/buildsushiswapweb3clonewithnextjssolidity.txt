in this video you're going to be building Sushi swap in xjs we're gonna be using solidity we're also going to be using infuro to build this app on the ethereum blockchain we're also going to be using rainbow kit to connect our meta mask this is going to be an amazing build let's just get started all right now let's go ahead and get started building these Sushi swap cone so as always we're gonna be using the custom CLI tool that we built for you so just pop in your email name and then just start typing in sushi swap it should show up and hit return on it and then let it do its thing now it will also open up infuria for you so go ahead log in or make an account if you don't have one already and then select web3 API as Network and then just name it Sushi swap or whatever you want to and then in the meantime likely the CLI tool will be done and we'll open the will open vs code for your convenience so it's full screen that and go back to inferior you should be good to go there no need to worry about it so finish setting up your if you're a project and copy or API key and that should be pretty much your first step all right now as your first step we're going to be doing is we're going to be creating a custom token so let's just get started so inside your contract slash custom decks Sol file you can start typing it and just like with any solidity file you will need an spdx license identifier which is going to be MIT and we are going to be working on the 0.8.0 version of solidity so just use that and right the gate we're going to go ahead and import some open Zeppelin contracts and libraries so the first one is going to be the erc20 and we're also going to be importing the safe math Library let's just do that and now we're going to go ahead and actually create the contract the token contract itself so as usual we're going to be building on top of the erc20 library and we're going to have obviously the name and the sale of that talk so let's just build out the contractor with those and then create the minting function so that will be that will look like that you're going to pass in the account and the amount and the amount and that is pretty much it we're just gonna get started with the custom decks in a little bit all right let's build the first step or for the custom decks so we're going to be using safe math in here so let's just import that and now we're gonna do a couple of presteps or whatever they they are called so we're gonna go ahead and create an array of strings and we're just gonna put in the names of the coins so you can rename those coins however you want to I'm just going to call it coin ABC and now I'm going to create a mappings later on this is going to be useful so what we're going to be doing is we're going to be mapping the actual ERC instances to these coin names themselves so mapping string to erc20 and it's going to be public and then we're just gonna name it token instance map these are going to be the conversion values so one custom coin will cost you 0.0001 East and then one coin will cost you one coin so this is just for later for for reference and the dexis Constructor will will be a for Loop so what we're going to be doing is we're going to Loop through the array that contains the names and it's just gonna basically run the coin instructor itself so basically let's generate a new token for you and then we're gonna be minting a bunch of them into the contract address itself so that's what address dot address this means meaning that all the coins that are going to be minted and this step are going to be minted onto the contract itself so nobody's actual wallet it will be minted onto the contract so the contract will own all the tokens and you just want to put in like a big number like a huge number that's because you don't want to run out while you're testing just put in as big of a number as you can think of and then what we want to do is we want to save this token into the token instance map just so we have access to it later and we can access it so once you're done and your contract looks like this you are pretty much good to go okay now for the next step we're gonna be implementing the get balance function so let's just get started with that and that all have two arguments one of them is going to be token name and the other one is going to be underscore address so basically when you call this function you should pass in coin a and then whatever your own wallet address is so this function will return the balance in the given wallet of the given token so this will be a function that will return a number and so the only thing that we will have to implement is returns token instance map passing the token name and then balance off and then the address so if you let's say if you have five coin a tokens and you're passing coin eight and your own wallet address it should return five so that is pretty much the get balance function all right let's test all the functionality that we implemented so far so first of all what you want to do is start your remix server on your in your vs code this is just a free ethereum remix extension and what you want to do is if you don't have ganache installed go ahead obviously install ganache and spin it up and then just make sure that the ports are matching so that it connects and once you're done with that you can go ahead hit compile and then hit Deploy on your custom decks.sol file and there you go you will have the the instance right there and there will be an issue which which I forgot because when you import from open Zeppelin you should import from contracts as a plural so just go ahead fix that redeploy the contract and then you should be good now once you're in there you will see all these functions that you can call so let's just go ahead and start checking out if we have all the tokens so the first item is going to be coin a coin B coin see those so that works and then now if you want to test out get balance like I said a minute ago you can just pass in coin a and then the address which is in case it's going to be the the contract address itself and you should just get back the initial the initial number of coins that you minted onto the contract so you see those bunch of zeros after a one so that means this functionality is working so with that said let's move on all right now let's make a function that actually Returns the address of the coin so function get token address you will pass in a token name and then it will return an address so what we're going to say is return address token instance map and the token name that's literally all it is now let's go ahead and test it so I'm just going to go ahead redeploy the contract and let's try it out so I'm going to pass in coin a in there and there is your address so that is pretty much this function all right now actually let's start swapping eth to these custom tokens so what you want to do is just create a brand new function and we will be passing in token name because now this is where you're gonna pass in coin a b or c or whatever this is going to be a public payable function that will return a number first of all let's create a variable and let's just store however much eth was sent to the contract so input value equals message.value and now what we're gonna say is output value so basically the amount of coins that we'll be sending back to the user will be calculating that by saying input value.div and this is coming from the safe math things so basically we'll divide the input value with the each value now e value you can just create another variable somewhere outside of this function and then just give it a value totally totally doesn't matter just make sure it's in weight and then we're going to be multiplying that by 10 to the power of the token instance map like how are the decimals we have with the token instance map token name dot decimals so these are all things that are coming from the a safe map so just feel free to pause the video check out what's what it is doing exactly and then continue from there and next up we're going to need to require that we are able to actually send that money so that we have that we have the funds in the contract to send the send back the output value to the user so that's going to be a requirement and then where is going to be returning the output value just so the user knows okay this is actually how much you you can go ahead check your wallet now mind you on line 54 I have a typo in the required so just be mindful of that this test will fail but let's go ahead and compile there you go there's the air so hit compile deploy the contract and let's go ahead and test it out so swap beat the token I'm just going to say coin a and then you have to pass in a value there so I'm just going to say ether point zero zero zero one whatever and I should technically I think be getting one coin a so that should be somewhere there so I'm just gonna paste in my wallet address and there it is that's the amount in way so that's literally one piece all right so with that said now let's go ahead and swap tokens to eth alright so now we're going to be swapping tokens back to eth so let's create that function we're going to be passing a token name and the amount and we're going to be returning the obviously the amount of heat the user will get we're gonna need to do some some conversions here first so we're going to say a un256 exact amount and we're going to be dividing the amount that we're sending to the user or the user sends us so basically the user sends Us in way and we will have to convert it to eth so we're going to be doing that there and now we're going to be saying is to be transferred exact amount multiply by each value so the user sends us their coin in the value of way we have we convert it up to eth and then we're going to be multiplying that with the conversion rate so after this once this is done we're going to need to make sure that we are able to cover that a transaction so the contract has to have enough eth balance otherwise this transaction cannot go through if that is if that requirement is met we will just go ahead and transfer the eth that we need to transfer so that will happen through this we're going to say token instance map token name transfer transfer from from the map from the message sender basically the user we're going to be sending the amount that they are sending to the contract and we're going to be storing it and after that we're gonna and we're gonna be sending the you after that we're going to be sending the eth back to the user so with that said we're just going to return the value and that is pretty much this function now mind you this this function will need to be confirmed by the user we'll collect that on the front so now with that said there is only one thing left to do and that is to create a token swap function all right so the last thing we need to implement here in the contract is actually the token token swap so let's create the function and we're going to have to pass in the source token name and the destination token name so basically which token do you want to convert to which token and then obviously the amount now this will be a public func and we will need to make sure that both the source token and the destination token has enough balance in the contract to cover this transaction so once that is done we are pretty much basically good to go and inside the require function we can just get done the transfer immediately and obviously this will need to be approved by the user which again will be done on the front end so with that said now let's go ahead and deploy this contract okay so go into your truffle config and then whatever is inside your networks just go ahead get rid of it it's not really necessary and once you're done just go into our truffle and connect to a network now we'll as I said earlier we're going to be using infuro connect to infuria and your sushi swap project that we created at the very beginning of this tutorial should already show up so once that's there you click it you're good to go it pretty much connects your vs code to that Sushi swap project and now if you if you start deploying the product by you can just say right click and then hit deploy you just select the sushi swap girly Network and then you should be good to go it will get get started everything for you now we'll take a little bit to deploy but just wait for it and you should be pretty much ready soon and there you go if you see your contract address at the end you are good and the project has been successfully deployed and once you're done deploying we're going to be doing a couple things to get our front end ready for for this project so go into your build slash contracts folder and just copy your custom decks.json file we're going to be using it in a little bit and now go inside your Source folder and just create a new folder called utils and then just paste it in there and now we're going to cut go ahead and copy the custom token.json file and paste that there too we're going to be using that in a little bit this is the Abi this is what will help our front end to interact with the contract now once that is done just go ahead create a new file contract.js and we're going to be importing ether because in this project we're actually using ethers and now you're going to go ahead import custom decks ABI the file we just copied and the custom token API the other file was just copied so we're just going to import both of those and now we're going to create a couple of helper functions that we will be taking advantage of later on so we will need to create two functions one for the token and one for the decks itself so we're going to say export cons token contract it'll be an async function and we'll create a provider ethers provider web3 provider and then we're just going to pass in Windows ethereum don't worry about that part that stuff if you have metamask installed the ethereum object will be immediately injected into every single website you visit and now we're gonna deconstruct ethereum out of window and we're going to be working with that now you will need to create a signer which is going to be provider dot get signer and the provider again two lines above that's where it comes from we're going to also create a contract reader now this is something that is only possible with ethers GS so we're going to say new ethers.contract we're gonna pass in the address that will be created with the text and then we're going to pass in custom token API AI because inside your file there is a bunch of things but we need the ABI so that specific part of the object and we're also going to pass in the signer that will help us later on with all the transactions and we're going to go ahead and return the contract reader now we're going to go ahead and repeat this exact same thing for the Dex contract as well so the only difference that's gonna we're gonna have is we're just gonna hard code the contract address so that comes from your output and now we're gonna pass in the custom decks ABI that API and with designer so with that said we are pretty much good with this part let's move on to the next all right so now we're gonna go ahead and set up two conversion functions so inside utils just create a new file ethers Dash utils JS import ethers and we're going to be creating a twoway and a two eth function these are literally just going to convert as the name says export function to way amount decimals and decimals by default is going to be 18. so you're going to pass in the amount you want to convert to a in ethers and then just use the library so ethers.us.parse units and then it will just do the conversion for you so you don't even have to worry about that and then just return the string version of that number and then this is going to be the exact same thing but the other but in the other direction and instead of Parts units we're going to use the format units method from the ethers Library so that's pretty much that function now let's actually set up the metamask wallet connection as well so I'm just going to spin up the app and let's take a look at it so right now this is how the app looks like and there's your connect wallet button not working so far let's take a look at what's happening so inside of app.js that's all you're Imports and wagmeconfig and everything so as you can see it requires infuro to connect to the blockchain so copy your API key and go back now you want to obviously put it in your EnV file and then that will make rainbow kit work perfectly that's literally the only thing you have to do and now let's just render out the connect wall button and as you can see inside of heather.jsx down at the bottom you can just there's a static connect wallet there so let's just go ahead and replace that with metamask we already prebuilt this component for you so you can just use it and that will go ahead and take care of your wallet connection if you and if your wallet address shows up at the top where the button was you are good to go and you can disconnect connect whatever wallets you want to so with that said let's go ahead and implement the conversion functions and we're done let's go ahead and create a new file in the utils folder and this is going to be a queries.js we're going to be importing big number and ethers from ethers and contract and token contract from contracts so this is what we're going to be using by the way to just get the East balance Also let's import to eat from the ether's utils file that we just created so we're going to say export const get balanced this is going to be an async function we're going to pass in the wallet address and the usual trial try catch so if if there's an error let's just console log it and see what's up and then in a try we're going to have a transaction that that's just going to convert the value or whatever amount so we're going to make sure that our wallet is connected meaning the ethers is not undefined after that we're going to go ahead create the provider how we already created multiple times and now we're going to go ahead and get the user's balance so we're going to grab the account so all the accounts that are connected to the app so away provider the list accounts and the user's account is very like the first one that is being connected and that's usually the active one because metamask sorts it like that now next up the balance in way is going to be provider.gap balance and then we're just pass in the user address and now we have to convert that into East so we can use either the two eth function that we created or we can just type it out again and then we're going to be going to returning it however if if you remember this is going to be a big number so later on we'll have to deal with this so let's go back to our index.js and in there we're going to be handling the balance so this is going to be an async function and this is going to be useful later on but basically when you try to swap you will have to select the source in the destination token and so that's what's going to get passed in here so if that if one of the tokens that the user wants to interact with is eth will have to get the each balance of the user and then display it I'll show you show it to you in a little bit so if the first drop down is going to be eth we're gonna need to go ahead and get the balance of that and actually do that let's grab the connected wallet so use account from wagme and then let's just save it so we're just gonna pass it in there and then we're gonna be be setting the first balance to that balance and we're going to convert it to a number and then cut down or I mean like what does it attach to decimals if it's the second drop down that is B that is selected as eth we're gonna get the we're gonna literally just repeat the same exact function but we're going to be saving it in obviously the second balance U state so now what we need to do is pass it into these coin drop downs as you can see we already have it highlighted for you so just find the find those two and then replace the string with the function name itself so just you can remove the apostrophes and then you should be good to go now if you run this app it looks like there is some sort of an error in our contract.js so let's check it out and it looks like that we imported the wrong file so we need to import custom decks.json not custom decks API all right let's see if it it works so I just selected Ethan it doesn't seem like it's working if you see the balance is still zero which is not ideal so let's take a look at what's happening and apparently if we had or apparently when we are selecting anything we are not running the function itself as you can see it's not even like completely white it's like this grayish color which means that vs code is recognizing that we are not calling that function so let's just pass it in there both in the first drop drop drown and then the second drop down as well so with that said now this should work so if I'm selecting it and there you go it updates so as you can see now it shows up as 4.54 eth over there so that looks good let's move on to the next step okay now let's repeat that same process but for the custom token so inside of queries we're going to have another function that will get the custom token balances because we have to handle those differently so we're going to say get token balance and then we're gonna pass in the token name and the wallet address where we're interested in the balance so we will have the contract object which will be coming from the contract file and then we're going to use the get balance function that we actually wrote in the contract and then passing token name and the wallet address after that we're going to go ahead and return the balance and again this is going to be a big number so let's go back to index.js import get token balance from this function or from this and write down at handle ballot let's just add an IFL yeah an a file statement in there let's go into the else statement and another if a statement in there and so if it's the first drop down then we're gonna get it for the first drop down if it's gonna be and set it as the first ballot we're going to be using a different we're going to get the balance using the freshly created function and then because it's coming back in way we'll have to turn it into ethers and then we're going to be set it as the first balance and then we're gonna repeat this same process but for second drop down with second balance now I'm gonna go ahead and cut this out so it's gonna disappear a little bit and then we're gonna may add a try catch function that's that's just good practice to do with blockchain apps so let's test out if it works and it looks like there are some errors that's because the address seems like it's off so that's probably because the use account dot address is how we're gonna get back the address add that there and when we're trying to get it from wag me and now it seems like the ethers package has not been imported so let's do that because that looks like it's going to be useful and as you can see now it works so eth is getting fetched and then we don't have any Bitcoin so it returns zero we don't have any solanos that returns zero as well that looks like it's working now let's work on the swap functionality and we should be good okay so let's actually swap from east to custom token so let's create the function pass in the destination token name and the amount of ethyl one to convert usual try catch and then we're gonna create the transaction value which is we're gonna figure it out by converting the amount from ether to way and then saving it in a object I don't know we're going to create the contract object using the contract function we've already created then we'll get we'll create the data which is going to be await contract objects swap East to token and then pass in token name and the transaction value then that will generate a receipt once we wait for it so let's return that and then this function is essentially done go into back to your index file import this function and now we're going to handle it so handle the whole swap so try catch and and if either of the inputs are empty or if the first input is empty we're just going to return because there's nothing to do then and the transfer coins from value is eth meaning the first value is eth and the second value is not eth we're going to be run this function so we're going to get the receipt from the freshly created function and then we're gonna say transfer coin to backend value and first input these are the these are the arguments we're going to be passing into the function so the first one is going to send the name the second one is going to send the value and there is the function being called and that when you hit that button alright so that should in theory work so I'm just adding numbers but it doesn't work yet now we're going to implement that it automatically calculates how much you will be getting by sending the X amount of eth all right so we're going to say handle output that will return that value so usual try catch and we're going to make sure that the first input is not empty and then we're going to be if the first one the transfer the destination coin is not eth and like we're going to make sure that it is an East to coin transaction and if so we're going to calculate the output value and that will be the we're going to get the first input converted to weight and make sure that we pass in 14 decimal digits and then convert it to eighth and then we're going to convert it to number and add two and no decimal with no decimals and set it as the second input and that should in theory get it all done now we're going to run this same functionality if the values are changed up so if we want to transfer from Custom token to eth otherwise it's literally just the same value so if if it might if it's E3 obviously it's going to be the same value if it's token to token because those their value are equal it's going to be again the same that is good and up there in index we're going to be adding a new use effect that will basically just update the pen the output value every time either we change one of the drop downs or the input input boxes so let's test it out and it looks like that twoway is not defined in index.js so let's go ahead and import it apparently we forgot it and now let's just put in random values let's see if it works and it looks like it's it's looking so if we try to trade it looks like two ways again not being defined so apparently we have to import it into a queries.js as well and now it looks like the conversion from eth to custom token is working perfectly so with that said let's move on to converting back okay so before we are able able to swap back to eth or between tokens we'll need to add something called an allowance and that basically just allows you allows the app to do these sort of transactions so in our queries we're going to need to check for this allowance so we're going to create a function for that and we're going to pass in owner token name and amount usual try catch and then usual contact object get the address of the contract or the token so contract not mentioned get token address pass in token name and we're going to create a contract token contract object it's just the usual drill and for the transaction data we're going to be saying that token contract object allowance passing owner and the contract address and we're going to save the allowance and we're going to generate a big number from the data that's being returned we're going to convert that to way and then we're going to check if it's zero or below the the requirement require required amount if yes then we're going to return false otherwise we're going to return true and now we're going to import that has valid allowance function into our index and in our handle swap we're going to create an else statement and we're going to check if we have allowance for for the transaction to go and by passing in the current account and the with as the owner transfer coin from as in the like the token name and then the value if it returns true then we're good and we can go ahead execute the transaction otherwise we're gonna we're gonna have to just console off no user allowance for now and then in a little bit we're going to increase the allowance so let's see what do we got apparently we wrote that decimal value to the wrong place so let's fix that real quick all right let's see what we got and now it shows that there is no user allowance so that's good because we never increased the allowance so that's how it's supposed to all right now go back to your queries and now we're gonna actually increase the allowance so let's create a function for that and usual try catch pass in token name and the amount and we're going to say contract object in the usual drill import everything create all the objects and instances so we're gonna have the contract object address and then token contract object and then with data we're going to generate the usual stuff so now the transaction data will be generated by calling tokencontract object dot approve pass in the contract address and then the amount in way so now it looks like it's still not running that's because we haven't called it so we will have to import it in our index and where we console like no user allowance we're going to have to call that function that we just created cost receipt equals weight increase allowance pass in the token name and the value and now let's console log what happens and there you go now we have to confirm that we want to increase the allowance and we should be good to go moving forward with converting tokens okay so the last two steps are swapping tokens to eth and then token to token they are going to be very similar so we're just going to blast through these and we're going to be done in a matter of minutes okay so in our aquarius.js we're going to be creating two functions the first one is going to be swept token swap token eth async function we're going to pass in which token do we want to and how much of it do we want to usual try catch and then just create all your objects generate the data however the transaction data is going to be using the swap token to eth function from the contract and then pass in required arguments a token name and the amount in way generating the receipt and we're going to return that receipt we're going to import this function in our index.js and if the user has sufficient allowance where we already wrote the if statement we're going to be calling this so let's remove that console log and we're going to be just saying conspiracy then we're going to save that in a variable or a constant and then passing the required arguments the name and the amount and we also want to run in again once we increase the allowance so there are two scenarios one the allowance is already there we just want to run the transaction otherwise we want to increase the allowance and then run the transaction so the user doesn't have to keep click so that looks good let's go ahead test it out there you go I'm increasing the allowance now and now the swap is going through so that looks amazing now let's go ahead and actually implementing the Tony token swap so for that we're gonna have a very similar function in the queries.js usual stuff now the slight difference is that we are going to have a source token and a destination token so we need three arguments instead of two we're going to generate the usual contract object and then this is going to be a swap token the token method that we're going to be calling we're gonna need to pass in both the source destination token and the amount obviously and we will generate the transaction receipt based on that and return that now we're going to be importing that in our index file and so far we only have two types of transactions one is when it is being converted to not eth and everything else but that's not the reality so let's add another if statement in after the so the second type of transaction that we are handling is the not East to eth type of transactions and and now we're we just implemented the token to token so the custom erc20 token to custom erc20 token type of transactions so we're going to be doing the exact same thing so we're gonna check for a valid allowance based on the required arguments and then if we have enough allowance then we're going to run the function otherwise we're going to increase the allowance and that is basically the application so once again let's just test it out let's just see if everything works we're going to go from a custom token to another custom token we're going to go through the whole transaction flow so now the token spend is approved and now we're going to just reject it because it showed up as a duplicate so we're gonna go ahead confirm it and now the transaction is going through that conversion is working so with that said thank you so much guys for following along this was an amazing build and with that I'll see you the next one peace