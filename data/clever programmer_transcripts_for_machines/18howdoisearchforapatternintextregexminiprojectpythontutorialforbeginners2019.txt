[Aaron] Hey what's up guys, Aaron from Clever Programmer here again. And today, I feel like making an email address text scraper. Just feel like doing something small and simple. So yeah, let's get right to it. (EDM Music) So if I want to be able to search a bunch of texts and pick out some emails from it. I'm gonna need something called regular expressions. In Python this library is just R.E. So I'm just gonna type import R.E just like that. And a quick explanation of regular expressions. It's a way to specify different patterns in string and text, in strings and texts so that you can match those certain patterns and then pick things out. So, an email address follows a very specific pattern right? There's some letters and numbers and what not and then there's an ampersand, and then some more letters and numbers and what not and then a period and then some more letters and numbers. And that's what makes an email address, that's what a human would recognize as an email address. So, things like these, if you can pick apart those little rules, like the structure, the pattern of something, some entity in this case an email address. Then we could specify and describe that pattern with regular expressions. Then once we do that, then we can run the regular expression over the entire text file and basically just pick out everything in there that matches the regular expression. In this case, that would be email addresses. So that was kind of a round about way of explaining it but I hope you got it. I'm gonna go kinda fast but I'm gonna explain like a little bit here and there. Just smoothing my way up to the full complicated regular expression that will actually pick out email addresses. So, let's just start with something simple. First, I'm gonna need some text. So, let's just type out a random string. (keyboard clicks) Literally, a random string. (Scoffs) Okay, and next we are going to create a regular expression pattern. So, we'll call this variable pattern equals call the regular expression library and there's this function or method called compile. And what compile will do, is it will take a string in that describes our pattern, our regular expression pattern. And then it will create an object in it an object from it and put it in pattern. So, the first one I'm gonna do is literally just this, a random string. The reason I'm doing this is because I just want to show you how regular expressions work. So, if I type in something like this, if this is my actual regular expression, what it's gonna search for in the text is this text exactly. So, since I typed these exactly the same this is actually going to match this entire thing. And when I run this pattern, over this text variable, it's going to spit out this match because this this matches this. Or actually I should say, this portion of the text satisfies what this pattern says. So, let's do this real quick. I got the pattern and then I believe I need to call call it result equals pattern dot I believe it's search, yeah yeah search and then text. So, what's happening here is I have my text here, so I wanna search my text using this pattern. So this, using this pattern I'm gonna search for the text and then any results we get back, I'm just gonna stick in this result variable. So, let's run this. I need one more print statement actually. Bare with me I'm doing this on the fly. Alright, print result. So, it will print the results we get. It should print out this, let's see what happens. I could be completely wrong. (Sighs) Sad truth of life but hey look, so we get this object is actually called a match object. If you don't know what an object is, that's okay, if you do though it's usually just an object and one of it's attributes is called match. And the match here is actually a string called a random string because this is what it found in the text string. This is the match it found over here. If you don't know what an object is just forget about it. Basically all you need to look for is it says match equals this. So, anything that is right here, that is in this, like right next to match. That means it found it in the text, so that's pretty cool. Now, let's try something else because that's kinda boring. This is just a static kind of regular expression. Now, let's change it up. So actually what I wanna do is you can also use special characters in regular expression so if I put some brackets here and let's say I put A or actually A, B or C. This is better for explaining it. If I put it like this, this will mean this entire highlighted portion here is looking for a single letter that can be either A, B or C, upper case, it's case sensitive. So, if it can be A, B or C and nothing else then that's what it takes to satisfy it. So, this is going to look for a single letter that is either A, B or C and the very first letter here is a capital A and "A" is A, B or C, so, this is actually going to be the only match when we run it. Let's just try this, it should only have "A" here instead of an entire, a random string. Let's run it and hey, look, it worked. The only match is "A". Now, you can actually put as much as you want in between these brackets. I think you can go as long as you want, I've never actually tried but I mean, if it gets too long it gets kinda messy anyways and it just yeah. It's nicer to try to keep things concise. I could put multiple letters in here like I could also put a lower case "R". A lower case "R" or "D" or "M". So, that's kind of like three letters at random. Let's try run this and see what pop's out. It should just be "R" and I am correct. The reason it's just "R" is because the search function it only searches for the first match, the very first match and then it stops. So, it terminates once it finds it's first match. So, the first match here it can be either an "R" either a "D" or an "M" and this is the first one that matches, an "R". Even though "D" and "M" also match, it found "R" first. And so "R" was considered the match. So, this pattern object got I mean sorry this result object got created and its match attribute was set to "R" because that was the first it found. So, as you can assume, I can really put anything I want in here. This would still return "R" because Actually would it not Yeah there's no capital "A" in here the only thing that's before this is a capital "A". So, the only time it would change is if I put a capital "A" here and then since capital "A" matches here before "R" does then capital "A" would actually be the match, and yup that's exactly what I thought. Let's get rid of all this gibberish Another cool thing you can do is like I said A, B, C You can go like that A, B, C, D, E, F, G. You can also just Instead of A, B, C. You can also just put in a range like "A" to "C". Which is the same as A, B, C. Or "A" to "Z" which is the entire alphabet. In lower case. Also what you can do is actually chain these ranges, so I'm gonna run this and since "R" is the first lower case letter "R" should be the only match again and yup, just as expected. Alright, we can also add upper case just by going like this. Now it will match all lower case and upper case letters. So, since capital "A" comes first and capital "A" is within in this one single letter criteria that we specified here. Then "A" will actually be printed out and yup, right again. Alright, so I've kind of drilled this idea in, I might be droning on, boring you guys. But if you're still listening now it gets a little more interesting because if we add a plus sign after this. What the plus sign does, basically says whatever comes before it, I can have one or more of those. So, instead of only matching a single character like we have now, I can actually match multiple ones. So, I can actually detect an entire word. This time its only gonna be "A" again because it's going to find the first entire string of one or more letters of lower case, upper case and in that case its just "A". Actually, let's delete "A". So, now its just random string. So if this is going to search for one or more lower or upper case letters as long as I want and then it stops at a space because this doesn't count as a upper or lower case letter, this space. So, it's just going to get these six lower case letters and that will be the very first match and then it will stop. So, let's run this and see what happens. And yeah, random pop's out. So, pretty cool, right? I can also put 0,1,2,3,4,5,6,7,8,9 etc. But I'm just gonna put zero through nine. So now, now what this will do is it will find anything that has lower case, upper case or numbers in it. One or more of them until it's not satisfied. So, I could actually put some capital letters in here now, some random ones, some numbers and this will still match because everything in this entire string is either a lower case letter, is either an upper case letter or a digit from zero to nine as we can see here. It's just when we reach this space, it is not satisfied anymore. So this one or more plus sign thingy, that we applied to this whole thing in the brackets doesn't work anymore. So, actually this entire thing will be matched and now what do ya know, pretty cool right? So, now that you understand a little bit of those things, I'm going to move on. Once you have these pieces, let's think about what an email address actually looks like. So an email address is going to have alright, let's just Random string let's just make a random email address so that we can test it out. So, let's just say my name one two three @ website dot com, looks like an email address to me. So, let's just do that and then just add some more random text, cause I am lacking creativity today. But now, we have this entire string here. All this text and we have one single email here and we wanna pick out this entire thing. So, if we ran this, it would just return random again because that's the first match that it gets but we don't want that, we actually want to pick out this email address instead of this random string. So, how could we do that. Well, another thing you can do with regular expressions is actually just use characters. So, if I just put an ampersand here. Just an ampersand, actually it's going to look for the first match of this and since there's one here, it's actually going to pick out this ampersand when I run this. Let's run it and see what happens, yup the match is an ampersand. Let's it's at website, if I put at website it's going to search for that exactly and then it will say at website cause that's the first time it found at website. But since an email address has an ampersand in it. This is very easy to, to build this pattern structure. So, just like before we had all lower case letters, all uppercase letters, all digits, one or more and then after that, that satisfies like this portion here "my name one two three" and then after as many letters or numbers that we like upper case or lower case in any order that we please. It's followed by an ampersand like that's what an email has. Okay? And then after the ampersand what happens again? Yet again we have as many lower case, upper case or numbers we want. So, we can literally just copy and paste this same thing, this chunk and just paste it again. So, you see at this part here and this part here, are exactly the same. See, its auto highlighting for me, cause they're exactly the same. That's really cool. Okay, then what follows this website portion? A period. So, we could just put a period but actually there's this little weird special thing called you need to escape certain, punctuation and symbols when you are coding. If you don't understand, it's a little bit hard to explain I'm not gonna explain it now but just take my word for it. To actually detect the pyramid (Laughs) A pyramid? A period. We have to put a backslash before it and this is called "escaping the period". So, this is actually considered a unit and this will actually be interpreted as just a period because this backslash says treat this period as an actual period, instead of doing something else. We would also have to escape this, if we actually wanted to find a plus sign in our string. We'd actually have to I guess I am explaining escape sequences a little bit. But if you put a backslash here, this would actually search for a plus sign literally in the string, instead of applying this plus sign to these brackets. And the same thing with these brackets if you actually wanted to search for actual brackets instead of having this weird This thing here, where you can have like all the stuff inside. You would actually have to put backslashes before each of these brackets to actually check for these brackets. So that's what that does, that's the reason we need that for the period. So, just take my word for it this will be considered a period. This here is equal to this period here and then again after the period what do we have? I don't actually think you can have numbers, I'm not exactly sure of all the possible email address that you can have but I think its only lower case letters and uppercase letters, alright? One or more of course, don't forget that. So, I think that's the entire regular expression. So, we have as many lower case and upper case letters and digits as we want, one or more, followed by an ampersand, again, oops. Again, same thing and then a period and then just some letters after it. So, that is what I believe an email address should look like. Let's try to run this and see if this gets printed out myname123@website.com, hopefully it does. And run and hey what do you know it actually worked. Stuff rarely works the first time so things are going flawlessly right now. Relatively flawlessly. But, yeah it seems like it's working it picked out this one email address but one thing I wanna try is what if we have multiple email addresses in the same string? So, let's say I'm gonna slide this over so I have a little bit more room. What if we have Okay. Your name eight eight eight at company dot net, something like that. That doesn't make sense cause a company is supposed to have dot com but yeah whatever. So, let's try to run this and see what happens. It should pick out both of these right? It should say match equals this and match equals this. Let's hit run. Hmm, but match only has the first email address. But what happened to the second email address? Well let's try to delete this first email address and see what happens. Delete, delete, delete, delete, delete, delete. Feel's good. Destruction. (Scoffs) And now lets run it and as you can see it actually picked out this email address "yourname888@company.net". Well, what gives? It's seems like the regular expression that we wrote here is picking out this correctly but its not its not picking up both of them. Well the thing is, the search function actually only searches for the first occurrence. Like I said earlier, it only searches for the first occurrence of your match. If you actually wanna find all of them you can actually do that by just calling find all. I really wanna drill this home to you because if you wanna find everything then you need to remember to use this function instead of the other one. It's a mistake I've made before. So, if we do this now, it should actually pick out both email addresses. Let's give it a shot, run and as you can see it returns a nice clean Python list of both matches. Both email addresses. That's cool right? So, it looks like in literally five lines of code we actually have a email address text scraper. Pretty cool man. Some other things we could actually add to this is I believe in email addresses you can actually have periods and underscores and what not. So, that's literally as simple as adding a period or a dash or an underscore in here. And I don't think you have to escape these if it's within the brackets, if it's within the brackets it's already considered, it is what it is. I may be wrong but we'll test it if it works. I'm pretty sure that's how it works. Same thing here, I don't know if you can have that here but let's just try this and let's maybe add like (keyboard clicking) your name is at underscore or actually your dot or your name dot eight dash eight dash eight. Now let's see what matches this time. Let's click run and oh, something went wrong. (Keyboard clicking) (Mouse clicks) Maybe we do have to escape the dash let's try that, yeah that's what it was. I think we do need to escape everything in here. Yup, okay that fixed it. So, you actually do need to escape everything so now it's actually picking out this email address just fine. The entire thing. Let's change it back to what we had before just to make sure its still working as expected. Your name dot eight dash eight dash eight. Run and it looks like it's picking out the entire thing. Pretty cool guys, pretty cool. So, yeah you do need to escape these special symbols even if it's within brackets. You need to put these backslashes before it to actually treat it as a period, actually treat this as a dash and then actually treat this as an underscore. You gotta escape them. For that matter you might even wanna escape the ampersand. Yeah, I guess so. Maybe that too if ampersand is a special character sometimes it's little bit confusing, whether you need to escape or not. But if you're ever getting weird error's where you're dealing with strings and you're trying to parse strings like this. Try escaping the special characters and sometimes that'll fix the problem. Or unescape them, it's a very weird, layered, convoluted kinda thing but yep it's just a part of learning this crazy Aztec language. Yup, I just taught you guys how to speak Aztec. (Scoffs) But yeah guys, seems like we have a fully functioning email scraper now, with this added functionality. So, pretty simple right? Five lines of code, took a little while to get here but yeah that's pretty much it. Just these simple five lines and that just kind of shows the power of regular expression. You are able to detect all different kinds of things with one single line of weird symbols, pretty much. So, that kind of demonstrates the value of it. I'm sure Python's very happy to have it within it's library if it was sentient. But yeah, very useful tool. I'll probably be touching on this more in the future this was only like a general introduction to it. But there's a lot of things you can do more with this there's, just a lot. Perhaps I'll go into it in the future but for now that is all you guys, thanks for watching this video. Still new to this, getting better, slowly. But yeah, hope you guys liked watching it stay tuned for more and yeah, I will see you guys next time. Good Bye. (EDM music)