With timestamps:

00:00 - [Music]
00:05 - hi there my name is Alex Santos and I'm
00:08 - assistant professor of text and
00:10 - computational linguistics in our solo
00:13 - University of Thessaloniki in Greece in
00:15 - this video I combined the content of a
00:18 - series of shorter videos that I uploaded
00:21 - on my YouTube channel related to
00:24 - programming with the our language the r
00:27 - programming language as some of you may
00:28 - have already heard is one of the top
00:31 - programming languages for analyzing
00:33 - modeling and visualizing data so these
00:37 - 15 short videos focus on explaining
00:40 - basic concepts of our programming
00:43 - related to vectors in their sub setting
00:45 - to opening and reading text files in R
00:48 - and they're primarily made for people
00:52 - who would like to learn our from scratch
00:54 - and they have no prior programming
00:56 - background in R and they would like to
00:58 - be able to learn and use our effectively
01:01 - for the data analysis the next video
01:04 - that I will upload on the programming
01:06 - knowledge channel I will again contain
01:08 - the combination of shorter videos on our
01:11 - programming focusing on factors and data
01:14 - frames until then if you'd like to watch
01:17 - these shorter videos as they come out
01:19 - pass by and subscribe to my youtube
01:22 - channel whose link you can find in the
01:23 - description below that's it for now
01:26 - enjoy the videos
01:28 - [Music]
01:46 - before you start learning our you need
01:48 - to first carry out two necessary
01:50 - installations for starters the program
01:53 - in our sure enough you need to have our
01:55 - installed then you will need our studio
01:58 - one of the most well known IDs that will
02:01 - be hosting our our programs ID stands
02:05 - for integrated development environment
02:07 - and by integrated development
02:10 - environment I mean the set of tools
02:12 - provided to you in order to swimmingly
02:15 - develop an our program for instance some
02:18 - basic features include an editor with
02:20 - code coloring that very easily help you
02:22 - spot keywords variables and other types
02:25 - of fire objects that you will be
02:27 - learning in the next videos also code
02:29 - Auto completion and debugging you will
02:32 - be able to acknowledge the power of all
02:34 - of these features as you become more
02:35 - proficient in using our before we begin
02:40 - with installations notice that the order
02:42 - of installations matters you first need
02:44 - to install our before you install our
02:46 - studio our studio will share its foreign
02:49 - our installation on your machine before
02:51 - it is installed first things first
02:53 - though let's install both software
02:56 - programs first for Windows and then for
02:58 - Mac let's first go to our sufficient
03:02 - webpage our - project.org then you
03:06 - follow the download link on the upper
03:08 - part of the page next screen shows the
03:11 - available mirrors from which you can
03:13 - download the software you can choose the
03:16 - mirror of the country you live in
03:17 - or run nearby and follow the respective
03:20 - link
03:21 - let me follow Greece's link since I live
03:24 - in Greece and next step is to choose the
03:27 - operating system of your machine now you
03:30 - choose windows in the next screen click
03:34 - on the base link and then you simply
03:38 - select the download our link at the time
03:41 - of this video recording our latest
03:44 - release version is three point five
03:46 - point two now you save the file and then
03:50 - double click on it to execute the
03:52 - downloaded dot
03:54 - file now a new pop-up window appears
03:57 - that gives us the chance to set the
03:59 - installation language here I choose
04:02 - English next pop-up window is about the
04:05 - terms and conditions of using are under
04:08 - its ganoub public license you simply
04:11 - move on by pressing next as you will do
04:13 - for the next few windows regarding the
04:15 - selection of components the setting of
04:18 - startup options the Start menu folder
04:20 - and the additional tasks
04:28 - our is installed and you are one
04:30 - installation before you are ready to go
04:32 - it's our studio stand now first you need
04:36 - to visit our studios official web page
04:39 - then choose the products tab and select
04:42 - our studio you find the download they
04:45 - are studio desktop link for your laptop
04:48 - or desktop PC in the next window you
04:52 - choose to download the free version and
04:54 - finally you pick the windows installer
04:59 - you choose to save it somewhere on your
05:02 - disk that you can easily access and then
05:04 - wait until it's downloaded after
05:08 - downloading it you simply double click
05:11 - on it and choose next for the remaining
05:13 - screens until the finished button
05:15 - appears
05:23 - you
05:35 - the only thing that remains is to
05:38 - actually find and open our studio you go
05:41 - to the Start menu and then you find our
05:43 - studio and load it now you're in front
05:48 - of our Studios environment where you
05:50 - will be working throughout this series
05:51 - as you can see there are four panels the
05:55 - two ones on the Left above and below
05:57 - will concern us most of the time
05:59 - since these are the places where you
06:01 - will be writing your our code for the
06:04 - first few videos you will be working on
06:06 - the lower left panel the so called
06:08 - our console and after you start feeling
06:11 - a bit more comfortable with the language
06:13 - we will start with writing our first our
06:15 - programs on the upper left panel and run
06:18 - them from there I will prepare a video
06:20 - for explaining how to use the upper left
06:23 - panel when the time is right the
06:25 - remaining two panels have special
06:27 - functionality that you don't have to
06:29 - worry about right now but just keep in
06:32 - mind that as we move along the series I
06:34 - will help you discover some of the
06:36 - benefits of using them while programming
06:38 - so far with Windows let's head to Mac's
06:42 - installations installing our for Mac
06:45 - does not make much of a difference you
06:47 - go to ours official page you follow the
06:50 - same download link and then you choose
06:52 - the mirror you want to download the
06:54 - software from you would usually want to
06:56 - find a mirror from your country or a
06:58 - neighbor one I chose the Greek mirror in
07:01 - Crete as I live in Greece in the next
07:04 - screen I choose the download R for Mac
07:07 - link after that I pick the latest
07:10 - release package at the day of recording
07:13 - this would be our three point five point
07:17 - two
07:27 - now our is downloaded the next step is
07:30 - to install it
07:31 - press Continue then agree to the terms
07:35 - of the license agreement
07:36 - choose your disk if you are the only
07:38 - user of your Mac and install insert your
07:43 - password to allow the installation by
07:45 - entering your password and then the
07:47 - installation begins you wait a couple of
07:50 - minutes until the window with a
07:52 - successful installation pops up lastly
07:56 - let's install our studio for Mac you
07:58 - first need to go to our Studios web page
08:01 - choose our studio from the products tab
08:04 - then our studio desktop and download
08:08 - finally you click on the free version
08:10 - link
08:15 - and then on the corresponding Installer
08:18 - installer for Mac
08:22 - after having downloaded the dmg file you
08:26 - simply click on it and let it do the
08:28 - installation
08:33 - finally you drag their studio icon on
08:36 - the Applications folder and you're ready
08:37 - to go now to open our studio you click
08:41 - on its icon and you are in front of ours
08:43 - to the environment that is identical for
08:45 - both Windows and Mac as you can see
08:48 - there are four panels the two panels on
08:50 - the left above and below will be the
08:53 - ones that you will be working on since
08:55 - these are the places where you will be
08:57 - writing your art code for the first few
09:00 - videos you will be working on the lower
09:01 - left panel the so called our console and
09:04 - after you start feeling a bit more
09:06 - comfortable with the language we will
09:09 - start writing our first our programs
09:11 - from the upper left panel and run them
09:13 - from there I will prepare a video for
09:15 - explaining how to use the upper left
09:17 - panel when the time is right there are
09:20 - two panels included a number of useful
09:22 - features that you will discover as we
09:24 - move along the videos of the playlist
09:26 - now you are set to go and enter your
09:29 - first our code chunks
09:31 - [Music]
09:41 - hi there as I mentioned in the first
09:44 - video of this playlist throughout this
09:47 - series you will see the common steps
09:49 - obstacles and advances that are provides
09:51 - in handling analyzing and modeling
09:54 - language data to that end the GLC dot
09:57 - sample data package a package that I
10:00 - created and now distribute through my
10:02 - github account will often serve as the
10:05 - basis for explicating the new concepts
10:07 - as we move along but what is in our
10:10 - package in our package is a set of
10:13 - programs written in our or datasets in
10:15 - spreadsheet like form that are can
10:17 - understand accompanied by detailed
10:20 - documentation as to how to use them for
10:22 - efficient data analysis in our case the
10:26 - GLC dot sample is a plain data package
10:29 - that and that means that it includes
10:31 - only data and is accompanied by
10:33 - documentation as to what these data
10:36 - represent particularly the GLC dot
10:39 - sample package includes metadata such as
10:42 - the first language the communication
10:44 - skills level in the proficiency test
10:47 - scores in the listening and writing
10:48 - tasks of 100 students of greatest second
10:52 - language recorded for the compilation of
10:55 - the Greek learner corpus abbreviated as
10:58 - GLC jill sees an error annotated learner
11:01 - corpus that you can download from the
11:03 - link I will include in the video
11:05 - description below there are two steps
11:08 - that you need to always have in mind
11:09 - when it comes to using in our package
11:12 - first you need to have the package
11:14 - installed in your machine in case it's
11:16 - not included in besar namely when you
11:20 - installed R in our studio if it is not
11:23 - installed you need to install it with a
11:26 - couple of specific commands that you
11:28 - will learn here the installation is done
11:30 - only once so you don't have to do that
11:33 - again next time you open our studio you
11:37 - then only need to load the package in
11:40 - order to use it so after installing an
11:43 - external package the second step is just
11:45 - that namely to load it before you are
11:48 - able to use its commands
11:51 - but GL seedot sample package is an
11:53 - external package meaning that it is not
11:55 - available immediately after you open our
11:57 - studio as I just said and needs to be
12:00 - separately installed the GLC dot sample
12:03 - package is distributed through github a
12:05 - well known online repository of our
12:08 - packages used mostly by programmers all
12:11 - over the world there are three steps for
12:14 - installing the GLC the sample package
12:16 - first step is to access the jillsy dot
12:19 - sample packets in github and for that
12:22 - you need to first install the dev tools
12:24 - package that provides access to github
12:27 - so you first write the line of code that
12:30 - you see right now on console on the
12:33 - bottom left panel of our studio the
12:36 - install that packages command or
12:38 - function as I will more often call the
12:40 - chunk of code that includes a name
12:42 - followed by opening and closing brackets
12:44 - will install the dev tools package then
12:48 - after successfully installing dev tools
12:50 - you need to load it so that you can use
12:53 - its commands or else functions to access
12:57 - a GL c dot sample for a slightly more
13:01 - advanced tutorial with information on
13:03 - the distinct categories of our packages
13:05 - on how to install and browse through
13:07 - them
13:08 - check out my earlier video on our
13:10 - packages and I provide a link in the
13:12 - video description below now you simply
13:15 - need to load the dev tools package with
13:17 - the library function after loading it
13:21 - you need to use the installers called
13:23 - github function are provided by the
13:25 - loaded package dev tools what you see
13:28 - inside the parentheses is a string
13:31 - signified by the surrounding single
13:33 - quotes with the address of the resource
13:35 - the deals with all sample packets in the
13:37 - github address inventory what this means
13:41 - is that the function install a
13:43 - underscore github searches through the
13:46 - available online github accounts and
13:48 - goes to my account that is the Atlantis
13:51 - part and then to the repository with a
13:54 - package GL C dot sample after finding it
13:58 - it's job is to simply install it on your
14:00 - machine while installing the GOC
14:05 - you'll see dot sample package a message
14:07 - appears on the screen waiting for your
14:09 - input ignore it by pressing the enter
14:11 - key as it does not make any difference
14:13 - for you right now next step is to load
14:17 - the package with the library function
14:19 - before we are able to use it and now we
14:23 - are ready to use the loaded data offered
14:25 - by the package from now on you can use
14:28 - any of the death data of the package for
14:31 - your packages for taking a brief
14:33 - overview or GLC dot samples vectors you
14:36 - need to use the data function for the
14:39 - time being you're not equipped to
14:40 - understand exactly what goes on in this
14:42 - code Chang don't worry about that you
14:45 - will soon be able to do so just type in
14:47 - what you see in the console for now what
14:51 - this function does is that it asks are
14:53 - to provide information about the content
14:56 - of the data sets in the GLC dot sample
14:58 - package the output will be displayed on
15:01 - the upper left our studio panel there
15:06 - you will see the names of the distinct
15:08 - data sets jillsy underscore part one to
15:11 - GLC underscore part four that
15:14 - corresponds to the four distinct areas
15:16 - tested within the standard language
15:18 - language proficiency assessment test
15:20 - used for the compilation of the Greek
15:22 - learner corpus and they include the
15:25 - learners scores namely scores on
15:28 - listening reading speaking and writing
15:31 - tasks also g gr underscore communication
15:36 - underscore skill records the levels of
15:39 - l2 great learners communication skills
15:41 - in Greek while jillsy a no score l1 the
15:44 - students l1 profiles you can browse
15:48 - through a more detailed documentation
15:50 - for each of the data sets by simply
15:53 - preceding the name of the data set with
15:55 - the with a question mark as I did here
15:58 - with the question mark GLC underscore
16:00 - part one data set wrapping up on the
16:04 - code of this short tutorial you'll learn
16:06 - to install load and explore the GLC dot
16:09 - sample package with the install
16:11 - underscore github library and data
16:14 - functions correspondingly
16:18 - now that you installed the GLC tooth
16:20 - sample package and know how to load and
16:22 - browse through its content it is high
16:24 - time you start getting your hands dirty
16:26 - with real language data analysis in the
16:28 - next videos
16:30 - hi there most of the times you will need
16:33 - a way to store and access values that
16:35 - describe a single aspect or feature of
16:37 - the collected data a vector is a
16:40 - one-dimensional data structure in R that
16:43 - you can use to do that by one
16:45 - dimensional I mean that its members are
16:48 - of the same type and represent a single
16:50 - feature for instance the response time
16:53 - measurements of a single experiment the
16:55 - recorded first language of a set of
16:58 - students as in the vector jillsy
17:00 - underscore l one of the GLC dot sample
17:03 - package that we will see in a minute or
17:05 - even responses to a single questionnaire
17:08 - item in this and the next couple of
17:11 - videos you will learn how to explore and
17:13 - handle character vectors namely vectors
17:16 - whose members sure enough are of
17:18 - character type after watching this video
17:23 - you will be able to use our code for
17:25 - getting the length of a character vector
17:27 - for obtaining its first or last n items
17:30 - and also for extracting its unique
17:33 - elements let's jump directly on GL c
17:37 - underscore l1 a character vector
17:39 - included in the GL c dot sample package
17:41 - that reports the first language or l1 of
17:44 - a sample of 100 students who's written
17:47 - productions were recorded during the
17:50 - compilation of the Greek learner corpus
17:52 - for more information on the package and
17:54 - the Greek Lerner corpus visit the
17:56 - earlier video in this playlist recall
18:00 - from the previous video that before
18:01 - using any of the date of an externally
18:04 - installed our package such as the GLC
18:06 - underscore l1 vector you need to load
18:09 - the GLC dot sample package that contains
18:12 - it that means you need to use the
18:14 - library function
18:22 - now you can choose to either display the
18:25 - content of the GLC underscore l1 vector
18:27 - on the console by calling its name as I
18:30 - just did here or to display it
18:33 - separately on the upper left our studio
18:35 - panel with the view function as you can
18:39 - see most of the l1 entries of the vector
18:41 - are Albanian this is interesting to
18:44 - observe as the collected data come from
18:46 - Greece its neighbor country moreover
18:49 - soon you will see that you will be able
18:51 - to quantify this intuitive first
18:53 - observation the first you are going to
18:57 - want to know when you have a character
18:59 - vector is the check its length namely
19:02 - the number of elements it contains this
19:05 - will reveal whether all the recorded
19:07 - values have also been included in a
19:09 - vector you can achieve this with the
19:12 - length function here as expected the
19:15 - length of the vector is 100 since the
19:17 - number of students is 100
19:22 - getting an overview of a vector can be
19:25 - done with a head function this function
19:27 - takes a vector as its argument and
19:29 - outputs its first six entries by default
19:32 - for those who wonder what an argument is
19:35 - just look at what inside the parentheses
19:38 - that follow the name of a function is if
19:41 - a function has more than one arguments
19:43 - these must be separated by a comma the
19:46 - function head requires at least on
19:48 - argument the vector or the variable that
19:51 - represents it GLC underscore l1 in our
19:54 - case but can also take optional
19:56 - arguments that enhance its functionality
19:59 - here I use an external america argument
20:02 - T is 25 that will overcome the number 6
20:05 - that by default is defined when no
20:07 - second additional argument is added in
20:11 - other words as you can see our returns
20:13 - the first 25 entries of GLC underscore
20:16 - at 1 the function tail returns the last
20:21 - six entries and as with head if you
20:24 - enter the number 25 as an additional
20:26 - argument the last 25 entries will be
20:29 - returned in a vector with various
20:33 - language profiles such as GL c
20:36 - underscore l1 you might also simply want
20:38 - to get a first feeling of the
20:40 - variability of the data in our case the
20:43 - variability translates to the number of
20:45 - distinct recorded l ones in a vector
20:48 - with 100 pretty recurrent l ones it is
20:51 - not so hard to monitor the different
20:53 - languages although not very easy either
20:56 - however imagine if you had a vector with
20:59 - entries of greater variability and much
21:01 - bigger in size for simply getting the
21:04 - different languages of a vector you can
21:06 - use the unique function what unique does
21:09 - is that it eliminates duplicate elements
21:11 - from a vector that is given as its
21:14 - argument and returns a new vector that
21:16 - keeps only one of its type let's say so
21:20 - the resulting vector includes the nine
21:22 - languages that appear in GLC underscore
21:25 - l1 one time or more notice that the
21:28 - resultant na entry which means that
21:31 - there are some missing data for at least
21:33 - one of the 100 students
21:35 - in other words for some of the students
21:37 - the l1 has not been recorded and there
21:40 - can be many external reasons for this to
21:43 - have happened you will see how to handle
21:45 - this type of data in a later video the
21:48 - vector is as diverse as including
21:51 - languages such as Punjabi Arabic
21:53 - Romanian Bulgarian and Georgia gamma
21:56 - gathers wrapping up on the code of this
22:00 - short tutorial you'll learn to ask for
22:02 - the length of a character vector with
22:04 - the length function to browse through
22:06 - its first and last n items with the head
22:09 - and tail functions correspondingly and
22:11 - to remove duplicate entries with a
22:13 - unique function so that you can have a
22:16 - first insight of the variability of the
22:17 - data
22:20 - [Music]
22:29 - one of the fundamental concepts in our
22:32 - and in programming in general is that of
22:34 - a variable conceptually you can think of
22:37 - a variable as a name that stands for a
22:39 - value and it works much in the same way
22:42 - a post address does namely a post
22:45 - address is a conventional name followed
22:47 - by a number that everybody shares to
22:50 - refer to a specific building so you can
22:53 - think of a variable as an address that
22:55 - you first a constant value or object as
22:57 - we call it a in our here the variable
23:01 - name refers to the string Alex since all
23:05 - our values have a specific data type
23:07 - think of the analogy of a specific
23:09 - building that belongs to the type of
23:11 - buildings a variable does not belong to
23:14 - specific data type but it refers the
23:17 - value that has its own data type in our
23:20 - case the value Alex assigned to the
23:23 - variable name is of type string but the
23:26 - variable name does not belong to any
23:28 - type only its value does in other words
23:32 - variables can also be thought of as
23:34 - typeless names that refer to objects
23:37 - both of these definitions I just
23:39 - mentioned are identical okay now how do
23:44 - we create a variable or else how do we
23:47 - assign a value to a variable the answer
23:50 - is by using the left direction arrow
23:52 - which is a combination of the less than
23:54 - symbol with a hyphen on its left side
23:57 - you use the variables name with no
24:00 - quotes around it and on the right side
24:02 - of the arrow
24:03 - you place the assign value the arrow is
24:06 - also called the assignment operator here
24:10 - I assigned the value of first string to
24:12 - the variable called first underscore
24:14 - variable
24:15 - lastly the assignment is completed as
24:18 - any other command that you add it on the
24:20 - console by pressing the enter key
24:22 - then the ars interpreter is called to
24:25 - evaluate the assignment statement notice
24:28 - that after pressing the enter key
24:30 - nothing shows up on the console that
24:32 - doesn't mean that something is wrong it
24:34 - just means that R has done its job and
24:36 - now
24:37 - variable and its values have been
24:38 - recorded in the memory you can then use
24:42 - this variables name to easily access the
24:44 - value assigned to this variable and you
24:46 - can do that by simply type in the name
24:48 - of the variable and then pressing the
24:50 - enter key as I did here you can also
24:53 - change the value of a variable by
24:55 - assigning it a different one
24:56 - the first underscore variable is now
24:59 - assigned the string not really
25:04 - now let's see the kinds of restrictions
25:07 - are puts in naming variables I could
25:10 - name a variable human underscore being
25:12 - underscore 1 2 3 dot world and assign it
25:16 - the string with my name
25:23 - but I could not name a variable starting
25:26 - with a number as you can see here with
25:28 - the one two three underscore human
25:31 - underscore being dot world also you
25:34 - cannot have variables starting with an
25:36 - underscore let's try a dot add in the
25:39 - beginning of the name followed by the
25:41 - sequence of digits one two three as you
25:45 - can see it does not work either however
25:48 - if a name started with dot was followed
25:50 - by a character the variable is created
25:53 - successfully lastly I cannot use
25:56 - reserved words in our to name a variable
25:59 - reserved words are keywords in our that
26:02 - have a special meaning for instance I
26:05 - could not use the word for as a variable
26:07 - name for is a keyword especially
26:10 - reserved for starting a for loop as you
26:13 - will see in later tutorials
26:15 - summing up on the naming conventions
26:17 - variable names can be a combination of
26:20 - letters digits period and underscore it
26:23 - must begin with a letter or a period if
26:26 - it starts with a period it cannot be
26:28 - followed by a digit and reserved words
26:31 - in R cannot be used as variable names
26:35 - our variables resemble the variables
26:37 - used for language data research this
26:40 - means that they both stand for a value
26:42 - and express a single feature for
26:45 - instance jillsy underscore l1 is a
26:47 - variable that stands for a vector of the
26:50 - GLC dot sample package and then codes
26:53 - your language data variable namely the
26:55 - first language of 100 students GLC
26:59 - underscore l1 is then an our variable
27:02 - that links the concept of a first
27:04 - language with the actual collected
27:06 - student data the process of linking
27:09 - scientific concepts with a collected
27:11 - data through variables is often called
27:14 - operationalization the variable jillsy
27:17 - underscore l1 is a result of
27:19 - operationalizing the concept of a first
27:21 - language recorded in the collected
27:23 - sample before finishing this tutorial
27:26 - make sure you take one more walkthrough
27:29 - of the code on variable assignments and
27:31 - the hours of variable naming conventions
27:34 - [Music]
27:44 - let's practice the functions that you
27:46 - learned in the previous video on a
27:48 - different vector of the GLC dot sample
27:51 - package on gr underscore communication
27:54 - underscore skill before that you need to
27:57 - load the package GL C dot sample that
27:59 - contains it with the library function as
28:02 - usual now you can browse through the gr
28:06 - underscore communication underscore
28:08 - skill vector with the our studious view
28:10 - function the members of this vector
28:13 - represent the 100 students communication
28:16 - skills level in Greek passing an eye
28:19 - over the vectors elements you can
28:21 - observe that the students communication
28:23 - performance Greek is very good now let's
28:28 - ask for the length of the vector no
28:30 - surprise it is 100
28:36 - next step is to get the first n items of
28:39 - the vector
28:39 - I chose its first 30 members and for the
28:43 - last 30 members you need the tail
28:45 - function
28:53 - you
28:57 - what about the unique elements of the
28:59 - vector or else how many assessment
29:02 - levels have been recorded for this you
29:05 - can use the unique function that outputs
29:08 - a vector with five members in our case
29:12 - although the number of unique elements
29:15 - is small you will often deal with
29:17 - character vectors that contain a big
29:19 - number of unique members in order to get
29:22 - the number of the distinct members of
29:23 - the vector you can use the unique
29:25 - function in combination with the length
29:27 - function that accepts as its argument
29:30 - the vector returned by the unique
29:31 - function as you can see the unique
29:35 - function is placed inside the
29:36 - parenthesis of the length function this
29:39 - is possible to do since R evaluates the
29:42 - expression in a from inside out fashion
29:45 - what I mean by that is that when R deals
29:48 - with nested expressions such as this one
29:51 - it first evaluates the most deeply
29:53 - nested expression the one that is inside
29:56 - the parenthesis then it gets the
29:59 - returning value a vector in the case of
30:01 - unique and passes it back as the
30:04 - argument to the length function that is
30:06 - why the length function takes as its
30:09 - argument the vector with the unique
30:10 - elements of G R underscore communication
30:13 - underscore skill and returns its length
30:16 - of course you could achieve the exact
30:19 - same thing in two steps you could first
30:22 - assign the resulting vector of the
30:24 - unique function to a variable as I did
30:26 - here with a unique underscore
30:28 - communication variable and then insert
30:31 - the variable as argument to the length
30:33 - function if you are feeling shaky as to
30:36 - what an our variable is check out the
30:38 - earlier video that explains the concept
30:40 - in detail here is the code summary so
30:43 - far feel free to pause the video you
30:46 - like and take a look at it until now we
30:49 - worked with character vectors loaded
30:51 - from the GLC dot sample package what if
30:54 - you wanted to create your own vector
30:56 - that would be the case if you had a
30:58 - small data set or if you wanted it to
31:00 - test some hypotheses on a sample of data
31:03 - and for that you need it to hard-code it
31:06 - into an R character vector
31:08 - so combining some character values into
31:12 - a vector can be achieved with a c
31:14 - function here i combined the three
31:17 - strings Greek English and German into a
31:21 - new character vector r's interpreter
31:24 - evaluates the expression and displays
31:26 - the resulting vector of course you can
31:30 - assign the vector to a new variable so
31:32 - that you can access it later as i just
31:35 - did here with a variable called
31:36 - languages
31:44 - so let's bring it all together and see
31:48 - how we could do something more creative
31:49 - with our data and with the freshly
31:51 - acquired knowledge let's assume that we
31:54 - would like to create a new vector with
31:56 - two elements the numbers of unique
31:58 - elements in the two character vectors
32:00 - GLC underscore l1 + gr underscore
32:04 - communication underscore skill the first
32:07 - step is to think of how to get the
32:09 - unique elements of the two vectors that
32:11 - is something you already know how to do
32:13 - and you saw it in this in the last video
32:16 - next step is to think of how you could
32:18 - get the lengths of the vectors returned
32:20 - by the unique function that you also
32:24 - know and just saw a minute ago each of
32:27 - the values returned by the last two
32:29 - statements will be an entry in the new
32:31 - vector so what remains to be done is to
32:34 - put these two code chunks together in
32:36 - the same vector and you can do that by
32:39 - using the C function that constructs a
32:42 - vector its arguments will be the members
32:45 - of the new vector that means we put the
32:48 - two earlier code chunks inside the
32:50 - parenthesis of the C function and
32:52 - separate them with comma as we do to a
32:55 - function that accepts more than one
32:56 - arguments finally we store the resulting
33:00 - vector to the variable lengths so that
33:03 - we can access it later by calling it you
33:06 - can see that it has two numbers as its
33:08 - elements 5 and 10 for the number of
33:11 - distinct languages and the number of
33:13 - distinct assessment levels of the GLC
33:16 - underscore l1 and the gr underscore
33:19 - communication underscores kill vectors
33:21 - correspondingly there is nothing special
33:24 - about this seemingly complex code chunk
33:27 - rewind what I said a minute ago about
33:29 - the way our deals with nested
33:31 - expressions namely by evaluating from
33:34 - inside out any complex code expression
33:37 - and you will see how the complexity
33:39 - vanishes now is your time to do
33:42 - something with the data so here are 2
33:46 - coach ank's I prepared for you I would
33:49 - like you to tell me which of them number
33:51 - 1 or number 2 returns the length of
33:54 - unique elements of the first 50 members
33:56 - of GLC underscore
33:58 - one feel free to pause the video run
34:02 - both coach ankhs and think about the
34:04 - output you get I'm looking forward to
34:07 - receiving your answers or any question
34:10 - that may have come up in the comment
34:12 - section below I'll come back to the
34:14 - solution of this short exercise in the
34:16 - next video decoding mentally the way
34:19 - that our evaluates nested expressions is
34:22 - definitely the first and decisive step
34:25 - to understanding our code and creating
34:27 - your own art programs in the last video
34:41 - you were assigned a short code exercise
34:43 - there you were asked to check which of
34:46 - the two lines of code one or two could
34:50 - produce the length of the vector of
34:52 - unique elements for the first 50 members
34:54 - of GLC underscore l1 let's first take
34:59 - option number one
35:00 - when writing nested code in our recall
35:03 - that by a nested I mean that one
35:05 - function is placed as argument within
35:07 - another function the most important
35:10 - thing to remember is the order of
35:11 - opening and closing brackets that
35:14 - indicates the arguments of a function
35:16 - and the commas that separate the
35:18 - arguments of a function in other words
35:21 - you aren't puzzled the code by looking
35:24 - at parentheses and commas and that is
35:26 - exactly what you need to do here in
35:28 - order to interpret what this line of
35:30 - code does recall also from last video
35:33 - that our evaluates expressions in and
35:36 - from inside out fashion so starting with
35:40 - the innermost expression we know that R
35:42 - will evaluate it and return the first 50
35:45 - members of the vector GLC honest world 1
35:48 - or else the first 50 languages of
35:51 - students of Greek as a Second Language
35:54 - the next level up is unique that takes
35:57 - the output of head and gives back the
35:59 - number of unique members it contains
36:02 - which is 5 let's head to the second
36:05 - option
36:11 - here the inside function head has only
36:15 - one argument and returns the first six
36:18 - members of TLC underscore l1 whereas the
36:21 - unique function has two arguments namely
36:23 - the head function and numbered fifty
36:26 - finally the outermost function is length
36:30 - that has only one argument the output of
36:33 - the unique function R starts to evaluate
36:36 - the innermost function head and as you
36:39 - already know by default when no second
36:42 - argument is given it outputs the first
36:44 - six members of the vector Jill siano
36:47 - squirrel one at the next level uniq has
36:50 - two arguments however when you learned
36:53 - about the unique function you may recall
36:56 - that it accepts one argument and not to
36:59 - let me explain what happens here the
37:02 - first argument we think the parentheses
37:04 - is the required one it is a vector whose
37:07 - unique members will be returned in our
37:10 - case this is the vector with the first
37:12 - six members of GLC underscore l1
37:15 - returned by head and the second argument
37:18 - is number 50 apart from the first
37:21 - required argument unique allows for
37:23 - further arguments that for the time
37:25 - being are not functional meaning that
37:28 - they are not processed in any way in a
37:31 - later video when you will be learning
37:33 - about functions I will explain you type
37:35 - of argument called the three dots
37:37 - argument for now you simply need to keep
37:41 - in mind that although we said unique
37:43 - requires a single argument it also
37:46 - allows for further arguments that do not
37:48 - play some additional role in this case
37:50 - in other words what the code of the
37:52 - second option does is that it returns
37:55 - the unique elements of the first six
37:57 - members of TLC underscore l1 that is why
38:00 - option number one is the correct choice
38:02 - for spawning two the code exercise
38:06 - [Music]
38:16 - karthick vectors are valuable data
38:19 - structures that store one or more
38:21 - strings as you saw earlier in this
38:23 - series in this tutorial you will dig a
38:25 - bit deeper in the building blocks of a
38:27 - character vector namely its members
38:30 - strings you will learn what an our
38:33 - string is how it is defined and lastly
38:36 - you will see some of the basic tool
38:38 - tools our provides you to handle and
38:40 - explore textual data stored in character
38:43 - vectors so let's zoom in on strings a
38:48 - string is a piece of text represented as
38:51 - a sequence of characters B that letters
38:53 - numbers and symbols let's have a look at
38:57 - some strings in our studio I have
38:59 - written a string here our gives people
39:02 - the heebie-jeebies and by pressing enter
39:05 - our console returns back the same string
39:07 - with its quotes showing you that it
39:10 - evaluates the string that you gave it
39:12 - correctly namely as a string a string as
39:16 - you can see is not identified with an
39:18 - actual word a single string may contain
39:21 - a whole natural language text or even
39:24 - more than one texts what matters for a
39:26 - string to be evaluated as such is that a
39:28 - sequence of one or more letters numbers
39:31 - or symbols is enclosed within either
39:34 - double or single quotes that delimit is
39:37 - bounders moreover the quotation must be
39:40 - done consistently what does consistently
39:43 - mean in this context though it means
39:45 - that when you are creating a string you
39:48 - need to pay attention to end the string
39:50 - in a consistent manner with the same
39:52 - type of code you started with in this
39:54 - string I created the second go I chose
39:57 - double quotes to put around the string
39:59 - so I use this type of code in both its
40:02 - beginning and end the same applies to
40:04 - single quotes if the string started with
40:07 - a single code as this one it should end
40:09 - with a single quote if the string
40:13 - contains quotes in it as in the case of
40:16 - having quoted words then the pairs of
40:18 - quotes inside should differ from the
40:20 - ones outside
40:22 - here let's try to replace the single
40:25 - quotes in the string with double ones
40:26 - and see what happens
40:35 - in this case I got an error message that
40:38 - indicates that there is a problem with
40:40 - the sequence of symbols within our
40:42 - string let's try to understand why this
40:44 - happens following the quotation syntax
40:47 - rule I just mentioned namely that the
40:50 - type of quotes is a means for marking
40:52 - the start and end boundaries of a string
40:54 - and that the ones inside should differ
40:57 - from the ones that mark the borders of
40:59 - the string then the sequence I just
41:01 - wrote consists of two strings with some
41:04 - symbols in the middle that do not belong
41:06 - to either strings so there are two
41:09 - problems here first I declared two
41:12 - strings on a single line and there are
41:14 - also some symbols the people part that
41:17 - do not belong to the string and that
41:20 - also do not represent any variable or
41:22 - function and hence cannot be evaluated
41:25 - by our
41:27 - the same applies if you chose to mark
41:30 - the boundaries of a string with single
41:32 - quote
41:39 - okay so let's put aside strings for a
41:43 - moment and let's head on to character
41:45 - vectors again recall that character
41:47 - vectors are sequences of strings and
41:49 - you're going to learn some very basic
41:52 - functions or commands if you like but I
41:54 - suggest that you get used to the term
41:56 - function instead of command since that
41:59 - is the right term to use and these
42:01 - functions you will see will allow you to
42:03 - handle character vectors and take some
42:05 - basic information about them let's
42:08 - assume that you would like to get the
42:09 - number of characters of each of the
42:11 - strings within a character vector let's
42:14 - further assume that each member of the
42:16 - character vector is a word string namely
42:19 - a string that corresponds to an English
42:21 - word followed by punctuation for example
42:24 - the exclamation mark is in the following
42:27 - vector that contains has its members the
42:29 - words of the previous string
42:35 - notice that I assigned the character
42:37 - vector as a value to the variable
42:39 - sentence to achieve this the end char
42:43 - function is useful what n char does is
42:46 - that it takes as its argument a
42:48 - character vector and for each of its
42:50 - strings it calculates the number of
42:53 - characters then it returns a new vector
42:56 - with the counts of characters of each
42:58 - string on the preowned the positions
43:00 - they were in the initial vector let's
43:02 - see it in practice the first position of
43:06 - the new vector is the number one the
43:08 - number of characters of the first word
43:10 - are of the vector assigned to the
43:12 - variable sentence on the second position
43:15 - five for the following member of
43:17 - sentence the verb gives on the third
43:19 - position in the outputs three for the
43:22 - article there and so on and so forth
43:24 - within char you can get a good first
43:27 - overview of the vector sentence imagine
43:30 - you had a vector with its members being
43:32 - word strings of a whole text then n char
43:36 - would give you the lengths of four words
43:38 - in the text this might be considered a
43:41 - valid factor for measure in sentence
43:43 - complexity in terms of both
43:44 - comprehending and skimming through a
43:46 - text in fact the number of characters in
43:49 - a text is already considered as a factor
43:52 - by researchers of the field of
43:54 - psycholinguistics the next crucial step
43:58 - is to see how you could arrive at the
44:01 - character vector with word units as
44:03 - members such as the vector sentence this
44:06 - is an important step to know how to do
44:08 - since if you have a character vector
44:10 - with words as its members you could
44:12 - employ are to obtain insights from the
44:14 - textual data so how do we get from a row
44:18 - text to a character vector that has word
44:20 - strings as its members our provides
44:23 - numerous functions from different
44:25 - packages but to that end I will use here
44:28 - the base our function STR split as I
44:31 - mentioned in an earlier video on our
44:33 - packages functions that belong to base
44:36 - our are considered inbuilt functions
44:38 - which means that they can be used from
44:40 - the very beginning of any our session
44:42 - and do not belong to an external
44:44 - installed package so the library
44:48 - function
44:48 - does not need to be used you already
44:51 - learned some other bizarre functions and
44:53 - these are they see or the length
44:55 - functions that you saw examples of other
44:59 - basic functions that you already learned
45:01 - in previous tutorials are the C function
45:03 - for creating vectors in the length
45:06 - function for getting the size of a
45:08 - vector okay starting with a row string R
45:12 - gives people the heebie jeebies i will
45:15 - first have to assign it to a variable
45:16 - and here i choose to call it row dot txt
45:20 - the STR split function takes two
45:23 - arguments the first argument is the
45:26 - string to be segmented represented here
45:29 - by the variable loaded text and the
45:32 - second argument is the segmentation
45:34 - criterion namely the criterion for
45:36 - splitting a string I use the empty
45:39 - whitespace character for that
45:41 - notice that the whitespace character is
45:44 - surrounded by quotes to signify that it
45:46 - is a string keep in mind that even
45:49 - though it signifies the emptiness it
45:51 - still has length one and by using the
45:55 - whitespace character as a segmentation
45:57 - criterion I mean that the whitespace
46:00 - character is used to mark the boundaries
46:01 - of the members of the new resulting
46:03 - object or in other words the places in
46:06 - the string that the new members will be
46:08 - cut this will become clear to you when
46:11 - you see it in a minute in order to get
46:14 - the character vector there is one last
46:16 - step though STR split segment strings
46:20 - into sequences of word strings but does
46:22 - not return a character vector instead it
46:26 - returns a list signified by the double
46:28 - square brackets you haven't seen list
46:31 - yet and there will be separate videos on
46:33 - lists dealing with how to define and
46:35 - manipulate them but they won't bother us
46:38 - now for now you simply need to know how
46:41 - to convert the list return from the STR
46:43 - split function in the character vector
46:46 - that you know for this you need to use
46:50 - the unlist
46:51 - function the unlist function takes a
46:54 - list as its argument and as its name
46:56 - suggests it returns a vector in this
46:59 - case it takes the returns list
47:02 - of the sto split function recall that in
47:06 - the case of applying a function on the
47:08 - output of another function you could
47:10 - either do it in a single step by putting
47:12 - the STR split function within the
47:15 - parentheses of the analyst function or
47:18 - in two steps where you first assign the
47:21 - returned list of STR split to a variable
47:24 - and then put the variable into the
47:26 - parentheses of an list I suggest you go
47:30 - the indirect way so that you get used to
47:32 - defining and using variables here the
47:37 - word that lists variable is assigned the
47:39 - value of the list returned from the STR
47:42 - split function and the work that vector
47:44 - variable stands for the converted
47:46 - character vector let's check on word
47:50 - that vector as you can see the result is
47:53 - a character vector that consists of word
47:56 - strings by the way the process of
47:58 - segmenting a piece of text into a
48:01 - sequence of natural language word
48:02 - strings is also called tokenization now
48:07 - you are in a position to use the
48:08 - familiar by now functions for handling
48:11 - character vectors and to get some basic
48:13 - insights of the text for instance you
48:16 - can ask for the length of the vector or
48:18 - in other words for the length of a text
48:21 - in terms of word units as you can see
48:24 - the text consists of six words or you
48:27 - could ask for all the distinct words of
48:29 - a text with a unique function
48:34 - again they were unique words are six
48:37 - since no word is repeated
48:41 - [Music]
48:52 - most of the times euro textual data will
48:55 - be stored in files in your computer and
48:58 - you will need to import them in R this
49:01 - means that in order for you to be able
49:03 - to further process your text files in
49:05 - our studio you should first convert them
49:08 - into our objects namely character
49:11 - vectors and strings that are can
49:13 - understand and allow you to use
49:15 - functions for handling strings and
49:17 - character vectors such as the ones you
49:19 - learned in the last couple of tutorials
49:21 - in this short tutorial you will learn to
49:24 - do that
49:25 - namely to open and read text files into
49:27 - R objects into that end I will use the
49:31 - three different options that are
49:32 - provides us they reach our the read
49:35 - lines and they read file underscore file
49:37 - functions so first things first let's
49:40 - take the text file lorem underscore
49:43 - ipsum dot txt that you will be importing
49:46 - in R that contains a big part of the
49:49 - lorem ipsum text here it is
49:52 - I opened the text file with an editor
49:54 - called sublime text but you could have
49:56 - opened it with any plain editor such as
49:59 - notepad for those not familiar with the
50:02 - lorem ipsum text this is a specific
50:05 - blind or dummy
50:06 - latin like text used very often by the
50:09 - desktop publishing industry as
50:12 - replacement text for testing purposes
50:15 - essentially the lorem ipsum text is
50:17 - there when the text content is not the
50:19 - issue at hand as in our case so here we
50:23 - don't really care what the content of
50:25 - the text file would be I already saved
50:27 - the text content of lorem ipsum to this
50:30 - file in the folder YouTube within my
50:33 - home folder for using the same text file
50:37 - to practice what you see in this
50:38 - tutorial you can go to this link that I
50:41 - also added on the video description
50:42 - below then copy the lorem ipsum text
50:45 - open your favorite text editor and paste
50:49 - and save it as a txt file in a folder
50:52 - that you will set as your
50:53 - working directory in the way that I will
50:55 - show you right now it is crucial to
50:57 - understand at this point that in order
51:00 - for art to open this text file you need
51:02 - to show are exactly where the text file
51:04 - is placed within your machines file
51:06 - system although we'll prepare separate
51:09 - videos specifically on how our navigates
51:12 - through your file system via file paths
51:14 - for now keep in mind that you only need
51:17 - to set the folder with a text file or
51:19 - Aman description dot txt leaves as your
51:22 - working directory briefly the working
51:25 - directory is the folder whose files will
51:27 - be directly available to our to do that
51:31 - you go to one of the right panels that
51:32 - displays the file system of your machine
51:35 - the panel that you see right now placed
51:37 - on the top right will probably be shown
51:39 - on the bottom right side of our study on
51:42 - your screen but apart from the
51:45 - positioning of the panel's nothing else
51:46 - is different in my art studio settings
51:49 - so you go to the folder that contains
51:52 - the text file that you would like to
51:53 - load in our in my case it is the YouTube
51:56 - folder in my home directory and double
51:59 - click on it now you simply go to the tab
52:02 - more open it and select the set as
52:05 - working directory and from that moment
52:08 - on every file that you will put in this
52:10 - folder will be available to our for
52:12 - reading it there are three options for
52:16 - opening and reading row texts in our the
52:18 - first option is to use the read lines
52:20 - function that opens a text file and
52:23 - reads or converts its content into a
52:26 - character vector whose members are the
52:28 - distinct lines of the text I saved the
52:31 - output to the variable called lorem
52:33 - ipsum the argument of read lines is the
52:37 - string with the name of the text file
52:39 - that is why it is surrounded by quotes
52:41 - as you can see each member of the vector
52:45 - lorem ipsum maps the separate line of
52:48 - the original text the end of the line in
52:51 - the original text file is marked with
52:53 - the newline character as you will see in
52:56 - a minute the new line is the criterion
52:59 - for segmenting the original text and
53:01 - creating each member of the new
53:03 - character vector lorem ipsum
53:07 - also note that some members consist of
53:09 - the empty character that means that
53:12 - there were some blank lines in the
53:14 - original text file until now in this
53:18 - series you met some methods for handling
53:20 - character vectors but you did not learn
53:23 - how to retrieve a specific member or a
53:25 - range of members of any character vector
53:28 - you'll learn how to do that in the next
53:30 - follow up tutorial for now let's use the
53:34 - length function that you already saw to
53:37 - find the number of lines in the text as
53:39 - you can see there are ten lines recall
53:43 - that in the last tutorial you show how
53:46 - to use the STR split function on a
53:48 - single string and then the length
53:50 - function to find the number of words in
53:52 - that string the output of red lines
53:55 - though is a character vector and not a
53:57 - single string for which you could use
53:59 - STR split to segment it into words for
54:03 - reading a text file directly into a
54:06 - single string you could use the second
54:08 - option of using the read char function
54:11 - the read char function takes two
54:13 - arguments the first of which is the
54:15 - string with the name of the text file
54:17 - and the second argument declares the
54:19 - number of bytes that should be read by R
54:22 - for declaring the number of bytes you
54:25 - can use the file dot info function
54:27 - you're not equipped yet to understand
54:29 - what goes on in this chunk of code but
54:32 - you will soon be able to do that let's
54:35 - have a look at the variable lorem ipsum
54:37 - dot string that stands for the content
54:39 - of the original text file as you can see
54:42 - the line boarders of the original text
54:44 - file are marked with the newline
54:47 - character signified with a backslash
54:49 - followed by in the text between the
54:52 - newline characters were separate lines
54:54 - in the original text now you could use
54:57 - the code demonstrated in the last video
54:59 - tutorial to segment the string into a
55:02 - character vector with words of the lorem
55:04 - ipsum text as its members using the STR
55:08 - split function and the unlist function
55:18 - you
55:21 - now you can ask for the size of the text
55:24 - in terms of words with a length function
55:26 - which is 543 the last option is to use
55:31 - the read underscore file function of the
55:34 - external package radar which is
55:36 - available in cran recall that to install
55:39 - any external cran package you use the
55:42 - install that packages function if you
55:45 - need to brush up on our packages and on
55:48 - how to install one go ahead and visit my
55:51 - earlier video on the subject
55:52 - apart from the card that you see right
55:54 - now in the top right side of this video
55:56 - I will also add the youtube link on the
55:58 - description below after loading the
56:01 - package radar you can use the read
56:04 - underscore file function that does
56:05 - exactly the same thing with the read
56:08 - char function namely treats and converts
56:11 - the text content of the file into a
56:14 - single or string the difference with red
56:17 - char is that it only needs a single
56:19 - argument with the name of the text file
56:21 - and you don't have to add a second
56:23 - argument that specifies the suitable
56:25 - memory size to allocate of course since
56:28 - you now have the whole text as a single
56:30 - string again you can do exactly the same
56:33 - thing that I just did with lorem ipsum
56:36 - dot string namely to segment the string
56:39 - stored in lorem ipsum dot string dot
56:42 - radar into a character vector with words
56:46 - of the lorem ipsum text as its members
56:48 - using the combination of str split and
56:51 - unlist lastly as previously you can get
56:55 - the text size in terms of words with a
56:57 - length function which again is 543
57:02 - wrapping up this tutorial make sure you
57:05 - check out the code summary
57:07 - [Music]
57:18 - some tutorials ago you were introduced
57:20 - to the concept of a character vector as
57:23 - a one-dimensional data structure in R
57:26 - that you can use to store values of type
57:28 - string and recall that by one
57:32 - dimensional I mean that its members
57:33 - represent a single feature of the data
57:35 - be that the first language or the
57:38 - country of residence of a speaker or
57:40 - some other theoretically interesting
57:42 - feature that can be encoded as strings
57:46 - in this tutorial it's about time to dig
57:48 - a bit deeper into character vectors and
57:51 - learn about their second defining
57:53 - feature namely that each member in the
57:56 - character vector is implicitly assigned
57:58 - an index or else a numbered position
58:02 - let's take a simple example of a
58:04 - character vector to see how indexing
58:06 - works in R this character vector has
58:10 - four members or indices the two terms
58:12 - can be used interchangeably here that
58:15 - stand for the position of each member in
58:17 - increasing order if we start counting
58:19 - the characters from left to right number
58:23 - 1 is assigned to the string read number
58:26 - 2 to yellow number 3 to blue and number
58:28 - 4 to green as you notice then indexing
58:33 - starts with the number 1 as opposed to
58:35 - other languages such as Python that
58:37 - start counting from 0 and for that
58:40 - reason they are also said to be zero
58:43 - based languages so when you hear that R
58:46 - is a one based indexing language they
58:49 - mean exactly that namely that it's
58:51 - indexing system starts with a number 1
58:54 - now the next natural question to answer
58:57 - is how do you retrieve values out of
58:59 - character vectors or equally
59:01 - equivalently and to use the write our
59:04 - terminology how do you subset a
59:07 - character vector sub setting in our is
59:10 - very powerful and unbelievably efficient
59:13 - among the three ways of sub setting that
59:16 - you see right now on the slide I will
59:18 - focus on the first way in this tutorial
59:20 - the others will be presented in the next
59:23 - tutorials using the indexing of a
59:26 - character vector is the base
59:27 - a tool for subsetting a character vector
59:29 - and secondly you need the subsetting
59:33 - operator of square brackets so let's
59:38 - jump directly on into our first example
59:40 - of subsetting a vector for that I have
59:43 - taken the character vector of the
59:45 - earlier example with the strings of
59:46 - colors as its members and assign it to
59:50 - the variable colors for subsetting the
59:53 - vector colors you need to use these
59:55 - subsetting operators besides the name of
59:57 - the variable that stands for the
59:59 - character vector and between the opening
60:02 - and closing square brackets you insert
60:04 - the index that corresponds to the value
60:06 - you would like to retrieve so if you'd
60:09 - like to retrieve the second value of the
60:11 - vector you simply insert the number 2
60:14 - within the brackets for the fourth
60:16 - member of the vector then you would
60:20 - simply use number 4
60:22 - apart from subsetting a single value
60:25 - with using a single index you can also
60:27 - subset a range of values for that you
60:30 - need to use the arrange operator
60:32 - represented with the colon punctuation
60:34 - mark that needs two numbers on both of
60:37 - its sides left and right the one on the
60:40 - left represents the start of the range
60:42 - and the other one right the end of the
60:44 - range of values you want to subset so by
60:48 - writing this code of chanc
60:49 - you ask art to return you the values of
60:52 - the second the third and the fourth
60:54 - member an important note to have in mind
60:57 - that you can see in the output that our
60:59 - returns after subsetting the vector
61:01 - colors and of any vector for that matter
61:04 - is that the retained output is a new
61:07 - vector a number one on the left of the
61:10 - output signifies that one it's right
61:12 - starts the first member of a new vector
61:14 - the returned vector let's take another
61:17 - pretty often scenario let's suppose you
61:20 - needed to get specific values that are
61:22 - not besides to one another or in other
61:25 - words they are not placed they are
61:27 - placed in various positions within the
61:29 - vector in this case the range operator
61:32 - is of no use to us what you need is
61:36 - instead is to use a vector of indices
61:38 - within the subsetting operator
61:41 - the chunk of code that you see simply
61:43 - says give me the first and third member
61:46 - of the of the character vector colors
61:48 - and this is one more example of nested
61:52 - code the nesting comes from the fact
61:55 - that the vector is placed within the sub
61:57 - setting operator evaluation is done as
62:00 - you already know by now in a from inside
62:03 - out fashion namely the vector with a
62:05 - values one and three is evaluated first
62:08 - and then these two values are given as
62:10 - inputs to the sub setting operator
62:13 - another pretty common scenario is that
62:16 - you might need to extract all values
62:18 - except some specific ones for which you
62:21 - know their index in that case the minus
62:24 - operator is at use you simply put it in
62:27 - front of the index that you want to
62:29 - exclude here assuming you want to
62:32 - exclude the first member of the vector
62:34 - you put minus one inside the square
62:36 - brackets and you are done so all members
62:40 - of colors are returned within we are
62:42 - returned within a new vector except the
62:44 - first one if you would like to subset
62:47 - the second and fourth member and exclude
62:49 - the first and the third you simply get a
62:52 - bit more creative by using the tools you
62:55 - just learned and you create a vector of
62:57 - negative indices that you would like to
63:00 - exclude and put it within the square
63:02 - brackets equivalently you could put the
63:06 - minus in front of the vector with the
63:08 - same effect namely are here interpret
63:11 - this code Chang in the following way
63:13 - give me back all the values of the
63:15 - vector that do not belong to the vector
63:17 - inside the square brackets
63:19 - lastly you can't mix positive and
63:22 - negative integer integers in a single
63:24 - sub setting this line of code simply
63:28 - returns a false message that indicates
63:29 - that a last remark that is that although
63:33 - some of you may not have already thought
63:36 - about it when you learn the basic tools
63:38 - of navigating through an character
63:40 - vector with the head and tail functions
63:43 - you already did the basic sub setting on
63:46 - a character vector however these two
63:49 - functions are limited in the values that
63:51 - they can achieve and the ways they can
63:53 - do that
63:54 - and they cannot by any means substitute
63:56 - the subsetting mechanism that you just
63:59 - started to learn right now just keep in
64:02 - mind that you only scratched the surface
64:04 - of ours flexibility and power to subset
64:07 - vectors wrapping up this tutorial make
64:10 - sure you check out the code summary
64:12 - [Music]
64:23 - last time you were introduced to the
64:25 - concept of subsetting a character vector
64:27 - more specifically you'll learn to use
64:30 - the first of the three different ways of
64:32 - subsetting character vectors namely
64:34 - using indexing and for that I used
64:38 - numbers within the square brackets
64:40 - operator let's turn our attention now to
64:42 - another way of subsetting a vector by
64:45 - using relational or logical operators
64:48 - this method allows to retrieve data that
64:51 - fulfill one or more conditions and
64:53 - therefore it is a very useful tool for
64:56 - powerful explorations in the data that
64:58 - reveal the underlying characteristics of
65:01 - the data set however this powerful
65:04 - technique for exploring vectors and
65:06 - other more complicated our objects as
65:08 - you'll see in the near future comes with
65:10 - a cost
65:11 - namely you need to understand how the
65:13 - underlying logic of using it works and
65:15 - to that end I will spend some time in
65:18 - the following videos to help you grasp
65:20 - the jist of it so in this video you will
65:23 - see how relational operators in our
65:25 - function and as a necessary intermediate
65:28 - step on your path of understanding and
65:30 - using them you get to know the boolean
65:32 - values a new type of data that is
65:35 - retained when you use these operators no
65:39 - worries I will take one concept at a
65:41 - time the first step is to learn how to
65:44 - express yourself in R when asking
65:46 - whether two or more values are the same
65:48 - or differ and in general how to use
65:51 - relational operators as we call them for
65:53 - doing that so lay back and in a couple
65:56 - of minutes you will have understood how
65:58 - you use them in combination with the
65:59 - square brackets for retrieving sets of
66:02 - values out of a character vector so
66:04 - let's dive in the first operator is the
66:08 - Equality operator signified by the
66:09 - double equal sign with the equal
66:13 - operator you can compare two values for
66:15 - equality for instance the following line
66:18 - is about to compare the two strings on
66:20 - the left and on the right of the
66:21 - equality operator notice that since I
66:25 - typed these two strings although their
66:27 - content is the same namely it consists
66:30 - of a number of specific symbols that
66:31 - happen to be
66:32 - same and in the same order they will
66:35 - still be interpreted by our as two
66:37 - strings and not one what we asked it to
66:40 - check is whether these two strings
66:42 - indeed consist of the same symbols and
66:44 - in that exact same order now as it
66:48 - usually happens when you ask something
66:50 - from our it will return you a value in
66:53 - our case when you will be asking it to
66:55 - check for equality between these two
66:57 - strings it will always be returning you
66:59 - one of the two values true or false true
67:02 - if indeed the two values and the
67:04 - comparison are the same in the way I
67:06 - just mentioned and false otherwise
67:09 - let's go directly to the example the two
67:12 - strings here are the same and therefore
67:14 - as expected the return value is true in
67:17 - this second line I get false because
67:20 - apparently the two strings do not
67:22 - consist of the same characters of course
67:25 - you can use the Equality operator if you
67:27 - want to check whether two numeric values
67:30 - are the same as here appreciate that the
67:34 - values true and false are not strings of
67:36 - four in five separate characters they
67:40 - have their own status as values and
67:42 - together these specific two values
67:44 - comprise their own data class or type
67:47 - you can think of these two values as
67:49 - being the only two animals of one
67:51 - species being a type of data as the
67:54 - character symbols in our are called
67:57 - strings this type of data also has its
68:00 - own name and is called the boolean type
68:02 - of value so the values true and false
68:05 - are the two boolean values let's move on
68:09 - to the second operator the opposite
68:11 - relational operator namely that of
68:14 - inequality this one checks whether the
68:17 - two objects are not the same if they are
68:20 - not the same then the true value is
68:23 - returned if they are the same though
68:26 - then false is returned so in the
68:29 - evaluation of the following two lines we
68:31 - expect the exact opposite values namely
68:34 - in the first one the value true since
68:36 - the inequality of the two strings is
68:38 - indeed true and the other way around for
68:41 - the second line of code now these
68:44 - operators can be used for comparing
68:46 - or run to values for instance you can
68:49 - use the equality and inequality
68:50 - operators for comparing two character
68:52 - vectors pairwise let's see an example of
68:55 - how this works I created two different
68:58 - vectors here and assign them to the
69:00 - variables name underscore one and name
69:03 - underscore two if I use the Equality
69:06 - operator the two vectors are compared
69:09 - are compared using their indices namely
69:12 - the positions of the strings within each
69:13 - vector the first string in names
69:16 - underscore one will could be compared
69:18 - with the first string in names
69:22 - underscore two the strings in the second
69:24 - position of both vectors we saw will
69:26 - also be compared for equality and so on
69:29 - and so forth the result is now a vector
69:32 - of boolean values where the index of the
69:34 - vector of this retell parent vector maps
69:38 - to the boolean values of its comparison
69:41 - namely the first member of the vector
69:44 - false is the result of comparing for
69:47 - equality the string election draws from
69:48 - names underscore one and ningke's and
69:51 - Nick four names underscore two the
69:53 - second value true is for comparing the
69:55 - strings in the second position of the
69:57 - two vectors assets may just mentioned
69:59 - namely the two identical ones Georgia in
70:02 - terms of their content moreover you can
70:05 - compare a character string with the
70:07 - whole vector of strings the comparisons
70:11 - are done pairwise again but this time
70:13 - the one side of the comparison always
70:16 - includes the string in this line of code
70:19 - what's compared is the string alexandros
70:22 - with each member of names underscore two
70:25 - a third member of names underscores too
70:28 - as you see is equal to Alexander's and
70:31 - that is why the third member of their
70:33 - tenth effect vector is true the last
70:37 - case we're going to see is when the two
70:39 - sides of comparison are vectors with
70:41 - different sizes and the pairwise
70:43 - comparisons are not done in a one-to-one
70:46 - correspondence some members of the
70:48 - bigger vector are not compared with new
70:51 - members of the other side however the
70:53 - pairwise comparisons are done but this
70:56 - time the comparison starts all over for
70:58 - the smaller vector let's
71:00 - see this example I renamed the vectors
71:03 - name underscore one and name names
71:05 - underscore two into name Santos Co three
71:08 - in name's Andrew score four
71:09 - correspondingly and made one more small
71:12 - change namely I deleted the last two
71:15 - members of names underscore one Zaheer
71:17 - and Ibrahim when the pairwise equality
71:20 - comparisons are done the prey last
71:22 - comparison for Zahir is done with the
71:25 - first member of name Santos code three
71:27 - namely with Alex honors since there are
71:30 - no new members names underscore three
71:32 - and that is why it starts all over four
71:34 - names under school three for Jim of
71:37 - names underscore for the comparison is
71:40 - done with the second member of names and
71:41 - score three Georgia so this might not be
71:45 - a desirable feature if you compare your
71:47 - language data since you care whether the
71:49 - vectors you want to compare have the
71:50 - same size and there are other ways for
71:52 - remedying this short cam of the
71:55 - relational operators as you will learn
71:56 - later now the last and crucial thing to
72:00 - note is that internally our stores
72:03 - boolean values is two numbers 0 & 1 0
72:08 - corresponds to the false boolean value
72:10 - and 1 to true what this means is that
72:13 - when you see the value true you would
72:15 - rather think of it as the number one and
72:18 - the number 0 for the value false let's
72:21 - see why this would be useful for you
72:23 - since the vector of boolean values
72:26 - returned from the comparisons of name
72:28 - Sanskar 1 and name some score 2 are
72:30 - internally represented as a vector of
72:32 - ones and zeros you could sum all these
72:35 - zeros and ones of that vector and you
72:39 - will find the number of pairwise
72:40 - comparisons done with a quality operator
72:42 - for names underscore one in nimes
72:44 - underscore two that have identical
72:46 - strings since false values are simply
72:49 - translated to zeros when you would
72:52 - create the sum of all these internally
72:54 - represented numbers of the retained
72:56 - vector of boolean values they would not
72:59 - contribute anything to the sum of these
73:01 - internal numerical values let's go ahead
73:04 - and find the sum of internal numbers not
73:07 - represent internally the boolean values
73:09 - you can use the sum function that takes
73:12 - all the numerical
73:13 - values of a vector it gives its some in
73:17 - our case it recognizes that the boolean
73:20 - values are translated as numbers and so
73:22 - it proceeds and takes their sum that is
73:25 - why it outputs a number number four
73:28 - which means that the two vectors have
73:30 - identical strings and four in four
73:32 - different positions as you can see I use
73:35 - nested code whereby the relational
73:38 - statement is placed within the sum
73:40 - function which means that the function
73:42 - sum will take as its input the vector of
73:45 - boolean values let's try it to check
73:48 - with the number of times a specific
73:50 - string that we are interested in is
73:52 - identified with any of the strings of
73:54 - names underscore one recall that this is
73:57 - the case of comparing pairwise a single
73:59 - string with each member of a character
74:01 - vector here the sum function outputs one
74:05 - and that means that there is only one
74:07 - successful pairwise comparison for
74:09 - equality let's try the same for the
74:12 - inequality operator as you can see by
74:15 - placing the inequality operator in the
74:17 - same place I get three the number of the
74:19 - rest of the pairwise comparisons when
74:22 - the two members of the two vectors are
74:24 - not equal recall that the size of the
74:27 - two vectors is seven let's check now the
74:30 - inequality comparison between a string
74:32 - at a vector as expected again the number
74:35 - is six that's it for now
74:38 - [Music]
74:48 - last time you were introduced to the
74:51 - concept of a boolean value into how a
74:54 - boolean value is interpreted in the
74:56 - context of comparing two numbers two
74:58 - strings and two vectors for equality or
75:02 - inequality you also learned what happens
75:05 - under the hood when it comes to
75:07 - comparing unequal in size vectors the
75:10 - question now is how does this relate to
75:12 - sub setting values from a vector will
75:15 - hang on in there before you attempt to
75:17 - answer this question since you need to
75:20 - learn a bit more about the rest
75:21 - relational operators in this video so
75:25 - the next complementary relational
75:27 - operators are the greater than and less
75:29 - than
75:30 - operators let's have a look at them when
75:33 - it comes to numbers things are pretty
75:35 - easy for instance here I check whether 4
75:38 - is greater than 5 and sure enough I get
75:41 - the false boolean value back on the
75:44 - contrary when I check whether 5 is
75:46 - greater than 4 I get true if I change
75:50 - the greater than 2 the less than
75:52 - operator I get the exact opposite
75:54 - results as expected as you can see here
75:57 - if you compare two strings with the less
76:00 - than operator our checks the
76:03 - alphabetical order of the initial
76:05 - letters of the two strings in this case
76:08 - a from Aleksandras precedes tea from
76:12 - tantos and we get the true value back so
76:16 - this greater than and less than
76:18 - operators are not such useful operators
76:20 - for comparing two strings after all if
76:22 - you think about it the last two
76:25 - relational operators are the less than
76:28 - or equal to and the greater than or
76:31 - equal to operators this mainly applied
76:34 - to numbers in a short while you'll be
76:37 - able to appreciate their usefulness
76:39 - especially when you will learn how to
76:41 - subset vectors with the help of
76:42 - relational operators so as expected for
76:46 - indeed is less than or equal to 5 and 5
76:50 - and 4 is definitely not greater than or
76:52 - equal to 5 the same applies to strings
76:56 - but as you saw a minute ago
76:58 - our son is done in terms of order in the
77:00 - alphabet so in the first case since a
77:03 - definitely precedes T we still get true
77:07 - whereas in the second case the opposite
77:10 - apart from the simple relational
77:12 - operators assigned specifically for
77:14 - comparing two objects are allows more
77:17 - complex relational operators that
77:19 - combine more than one of the simpler
77:22 - relational operators that you already
77:24 - saw the first one is the so called
77:26 - element wise logical or operator
77:30 - signified with a vertical bar let's go
77:33 - directly to an example with the GLC
77:35 - underscore l1 vector of the GLC dot
77:37 - sample package first you need to load
77:40 - the package as always before you use the
77:43 - GLC underscore l1 vector
77:45 - recall that GLC underscore l1 is a
77:49 - vector with the first language profiles
77:51 - of learners of Greek as a second
77:53 - language
77:57 - assume that you want to check which of
78:00 - the learners in jillsy underscore l1
78:02 - have either Albanian or Russian as their
78:05 - first language this translates to two
78:08 - different comparisons combined with the
78:10 - or operator the first on the Left checks
78:14 - whether each member of jillsy underscore
78:16 - L 1 is equal to Albanian whereas the
78:19 - second on the right checks for equality
78:22 - comparison 4 of each member of jillsy
78:24 - underscore l1 with Russian in the middle
78:27 - of this complex statement is the or
78:29 - operator and the whole can be thought of
78:31 - as the following instruction give me
78:34 - back which of the learners are either
78:36 - speakers of Albanian or Russian the
78:39 - result will be a vector with boolean
78:41 - values depending on whether each of the
78:44 - members satisfies either of the two
78:46 - conditions for instance the first
78:49 - speaker does not have Russian or
78:51 - Albanians here first language where is
78:54 - the second one does let's head to the
78:56 - second complex relational operator the
78:59 - element-wise end operator the end
79:02 - operator returns a boolean vector where
79:05 - the true values represent members that
79:07 - satisfy both conditions on the right and
79:10 - the left side in the context of the
79:13 - previous statement if we replace the
79:15 - vertical bar that stands for or with a
79:18 - ampersand that signifies the end
79:21 - operator it is impossible to take a
79:24 - single true value in the retaining
79:26 - boolean value vector since no member
79:29 - could be both Albanian and Russian the
79:32 - end operator makes much more sense for
79:35 - Strings when it comes to using them for
79:36 - subsetting more complex objects such as
79:39 - data frames as you'll see in the near
79:42 - future for now for using end it makes
79:46 - sense only for numeric vectors let's see
79:49 - what I mean by this with an example on
79:51 - GLC underscore part one I remind you
79:56 - that the vector jillsy underscore part
79:58 - one store's listening task scores of the
80:02 - same 100 students of Greek as a second
80:05 - language let's see which of the students
80:07 - got a score less than 14 and more
80:10 - than 10 if you would like to see which
80:14 - of the students has less than 12 but not
80:16 - 10 you can use a combination of the
80:19 - existing operators for inequality and
80:22 - less than as in the code here along with
80:25 - the logical end essentially the
80:29 - conditions on both sides of the logical
80:31 - end are checked which means that when
80:34 - each member of chilly underscore part 1
80:36 - is less than 12 and also is not equal to
80:39 - 10 then in the new vector a true value
80:42 - is recorded and the false wall and false
80:45 - value otherwise now it's worth noting
80:49 - that you could add one more condition in
80:52 - the previous complex expression as in
80:54 - this code Chang where true values are
80:57 - turning they are returned in the
80:59 - resulting boolean vector for members of
81:02 - GLC underscore part 1 that are less than
81:06 - 12 they are not equal to 10 and they are
81:09 - also greater than 5 recall that by a
81:13 - boolean vector I refer to a vector that
81:16 - solely consists of true and false values
81:18 - so the resulting boolean vector reflects
81:22 - whether the members of a vector satisfy
81:24 - the conditions of a complex expression
81:27 - ok now how do we use this knowledge in
81:30 - subsetting vectors well if we nest these
81:34 - complex expressions within the
81:36 - subsetting operators namely the square
81:39 - brackets then the retained or retrieved
81:43 - values will only be the members of the
81:45 - vector that map to the true values of
81:48 - the boolean vector let's interact what I
81:51 - mean by that let's take the simple
81:54 - expression with the less than operator
81:55 - if I put this expression within the
81:58 - square brackets then the output will be
82:02 - a vector with those values of the GLC
82:04 - underscore part 1 vector that satisfy
82:07 - the condition as you can see here from
82:09 - the retrieved vector similarly if I put
82:13 - within the square brackets the more
82:15 - complex expression with the logical end
82:17 - operator that we saw a minute ago
82:19 - repeated here then I get the values that
82:22 - satisfy both conditions
82:24 - let's try out the logical order this
82:26 - time in this case those members of
82:29 - jillsy underscore part 1 will be
82:31 - retrieved that are either less than 10
82:34 - or more than 12 as you can see our has a
82:38 - very powerful mechanism in retrieving
82:41 - vectors values by allowing you to
82:43 - express for the values you want to
82:45 - retrieve as complex conditions as you
82:47 - like as we move to more complex data
82:50 - structures ours subsetting mechanism
82:53 - becomes even more important in preparing
82:55 - your data before you build your first
82:58 - statistical models
83:00 - [Music]
83:10 - in this short video you will be
83:13 - presented with the last way of
83:14 - subsetting vectors that of using
83:17 - character vectors as selection criterion
83:20 - let's see what I mean by that sometimes
83:23 - you may need to create a character
83:25 - vector whose members have tags or names
83:28 - attached to them that signify an
83:31 - attribute or feature for instance you
83:34 - may have a vector with the first
83:35 - language profiles of some speakers and
83:38 - you may want to attach the name of the
83:40 - language family that each of the
83:42 - languages belong to let's create such a
83:45 - short vector that will serve our
83:47 - purposes and name it a l1 underscore
83:50 - profiles
83:51 - l1 underscore profiles has the names of
83:54 - eight languages some of them pretty
83:56 - common in Europe such as Greek and
83:58 - German and some others as exotic as the
84:01 - Nigerian Congo languages
84:02 - Vanda and jewel for assigning a name to
84:06 - each member of l1 underscore profiles
84:08 - that represents the feature offenders
84:10 - you may use one of the following two
84:12 - ways depending on what you want to do
84:15 - next the first way is to use the names
84:18 - function what this says is that the
84:21 - vector with the language families of
84:23 - each language of l1 underscore profiles
84:26 - on the right of the arrow assignment
84:28 - operator is taking its place as a named
84:31 - vector attached to each member of the l1
84:35 - underscore profiles vector separately
84:37 - let's check now how the resulting vector
84:39 - looks like as you can see the vector l1
84:43 - underscore profiles has the language
84:45 - family name on top of each language what
84:48 - this means is that the vector is the
84:51 - same as earlier but now additionally it
84:53 - contains some more information about its
84:56 - members in other words the language
84:58 - families of the languages in l1
85:00 - underscore profiles are considered
85:02 - metadata let's move on to the second way
85:06 - of creating a named vector for that I
85:09 - will be using the same vector but now
85:11 - stored under the variable name l1
85:13 - underscore profiles underscore 2 to
85:16 - leave l1 underscore profiles and chains
85:18 - and work later with that
85:21 - now the second way is to use the set
85:24 - names function this function takes the
85:27 - l1 underscore profiles underscore two as
85:29 - its first argument and a vector with the
85:32 - names as its second argument the names
85:35 - being the language family names set
85:38 - names outputs a named character vector
85:41 - while it keeps the original vector l1
85:44 - underscore profiles underscore two
85:46 - intact this means that unlike the names
85:50 - function that attaches the names
85:51 - directly 12-1 underscore profiles with
85:54 - set names you need to attach to assign
85:56 - the output separately to a new variable
85:58 - I chose the variable name alone
86:01 - underscore profiles underscore named
86:03 - here as a as a result you now have two
86:07 - vectors the initial unnamed vector l1
86:09 - underscore profiles underscore two and
86:12 - the named vector l1 underscore profiles
86:15 - underscore named so if you want to give
86:19 - both vectors they are named and the
86:21 - named one you can use the set names
86:24 - function otherwise if you simply need to
86:26 - create a named correct named character
86:29 - vector out of an unnamed one use the
86:32 - first way with the names function so far
86:36 - with creating named character vectors
86:38 - let's head on to learn how to subset a
86:41 - named character vector for doing this I
86:44 - will choose the work with the l1
86:45 - underscore profiles vector I created
86:47 - earlier although I could do the exact
86:49 - same things with l1 underscore profiles
86:52 - underscore named vector the reason why
86:55 - named character vectors can be useful is
86:57 - that you may subset members of a
86:59 - character vector based on their own
87:01 - they're attached named attribute in the
87:04 - case of l1 underscore profiles you may
87:07 - want to subset languages that belong to
87:09 - a specific language family for doing
87:12 - this you can use a character vector with
87:14 - language family names within the square
87:16 - brackets operator for instance for
87:20 - picking the first indo-european language
87:22 - you insert the character vector with a
87:24 - string indo-european as its member
87:26 - within the square brackets notice that
87:29 - such a vector does not return all
87:31 - languages of l1 the underscore
87:34 - that belonged to the indo-european
87:36 - language family but only the first one
87:38 - the position of the languages in l1
87:41 - underscore profiles does not play a role
87:43 - you can subset l1 underscore profiles
87:46 - for other language families without
87:48 - caring about the position the respective
87:51 - languages are placed in l1 underscore
87:53 - profiles moreover you don't have to care
87:56 - about the positions of the members
87:58 - within the sub setting vector as you can
88:01 - see in l1 our score profiles the Turkic
88:04 - language Turkish is placed after the
88:07 - japonic language of Okinawan okay it's
88:11 - just mentioned so far the sub setting
88:13 - does not result to all languages of a
88:15 - language family in other words the
88:18 - character vector does not function as a
88:20 - selection criterion in the same way a
88:22 - conditional statement does for doing
88:25 - that namely for sub setting all
88:27 - indo-european languages for instance you
88:30 - could use the familiar by now
88:31 - conditional operator of equality as
88:34 - expected this line of code returns those
88:37 - languages whose name is into European
88:40 - let's see what happens under the hood
88:42 - the quality operator checks whether each
88:46 - of the names of l1 underscore profiles
88:48 - is equal to the string in the European
88:51 - for each comparison it outputs a true or
88:54 - false value the result of all
88:58 - comparisons is a logical vector that
89:00 - contains true and false values the job
89:03 - of the sub setting square bracket
89:05 - operator is to give back those members
89:08 - of l1 underscore profiles that are in
89:10 - the same position with the true values
89:12 - of the logical operators retained by the
89:15 - evaluated relational statement of
89:17 - equality in other words it outputs those
89:21 - members who is assigned name is into
89:24 - European for sub setting both
89:26 - indo-european and japonic languages you
89:29 - can use the logical or signified by the
89:32 - vertical vertical bar as demonstrated in
89:35 - the previous tutorial lastly you can
89:38 - obtain the same result with the in
89:40 - operator that you haven't seen until now
89:42 - the in operator checks whether each of
89:45 - the members
89:46 - vector on its left side belongs to the
89:48 - vector on its right in return it's a
89:51 - logical value for each pair of
89:53 - membership checking let's have a look at
89:56 - the retained logical vector the first
89:58 - false value results from checking
90:02 - whether Niger Congo belongs to the
90:04 - vector that contains the language
90:06 - families that we would like to select
90:08 - namely into European and japonic the
90:12 - next is true since the second member of
90:14 - l1 and the score profiles is assigned
90:16 - the name into European that belongs to
90:19 - the vector on the right of the in
90:21 - operator moving one step forward if you
90:24 - embed the statement within the square
90:26 - brackets the true values of the returned
90:29 - logical vector become now the selection
90:32 - criteria for the members of l1
90:33 - underscore profiles so that's it for now
90:37 - don't forget to freeze the video on this
90:40 - slide
90:40 - [Music]
90:50 - in this video it's your turn to gain
90:53 - some hands-on experience by solving a
90:56 - few subsetting code exercises I admit
90:59 - that the three code exercises I prepared
91:01 - for you may be a bit challenging but I
91:03 - can assure you that if you follow the
91:05 - previous tutorials you have nothing to
91:07 - fear
91:08 - so the initial setting of the data to
91:11 - work on in the exercises is the
91:13 - following suppose you have three vectors
91:16 - whose members describe three features of
91:18 - a group of 50 speakers the first vector
91:20 - has recorded response times from an
91:23 - online conversation experiment for that
91:26 - these 50 speakers participated in the
91:29 - second vector has their scores on a
91:31 - language proficiency test and the third
91:33 - vector has their first languages for
91:36 - constructing the specific scenario I'm
91:38 - going to take advantage of the vectors
91:40 - in the GLC the sample package the first
91:43 - thing we need to do is to load the
91:44 - package ill see the sample with the
91:47 - library function as usual for preparing
91:50 - the first vector I choose the R norm
91:52 - function to create a simple random
91:55 - sample of 50 numbers that supposedly
91:58 - represent response times and follows a
92:00 - normal distribution with a mean of 5 and
92:02 - a standard deviation of 1.5 these
92:06 - numbers are supposed to represent
92:07 - response times in terms of seconds here
92:10 - I also round the numbers of the vector
92:12 - to two digits after the decimal point
92:15 - with the round function after completing
92:18 - the first tutorials that introduce the
92:20 - basic so far I will visit our norm and
92:23 - all the concepts related to the most
92:24 - commonly used probability distributions
92:27 - for language data analysis and explain
92:30 - them from scratch so no worries if you
92:32 - did not understand exactly what I just
92:34 - said for now the important thing to note
92:36 - is that the resulting vector has 50
92:39 - numbers with a mean of 5 seconds
92:41 - and most of the data are around around
92:44 - this number around 5 seconds with an
92:46 - average spread of 1.5 seconds now each
92:50 - time you run the code of this last line
92:52 - you get a different simple random sample
92:54 - from the same distribution which means
92:57 - that if you run it now on your console
92:59 - you will get a different vector of
93:01 - numbers but always with a mean of five
93:04 - and an SD of 1.5 in order to work with
93:08 - the exact same vector I just created go
93:10 - ahead to the link in the description
93:12 - below and after you visit it copy the
93:15 - vectors the vector of numbers you see
93:17 - there paste it on your art studio
93:19 - console and assign it to the variable x
93:22 - underscore sample for creating the
93:26 - second vector you are going to extract
93:27 - the first 15 members of the GLC
93:29 - underscore part one vector which I
93:32 - stored here as test underscore scorers
93:35 - underscore sample we are almost ready to
93:38 - go we need to create the third vector
93:40 - now and we are going to do that by
93:41 - extracting the first 50 l ones from the
93:45 - jillsy underscore L 1 vector and name
93:47 - the vector l1 underscore sample now
93:51 - let's get down to the exercises notice
93:55 - that you you now have three different
93:57 - vectors whose members encode three
93:59 - features for 50 people in the exact same
94:02 - position meaning that the first member
94:05 - of all three vectors are the test score
94:07 - the response time and the first language
94:10 - of one in the same specific speaker the
94:14 - same holds for the second members of all
94:16 - vectors and so on in some sense these
94:19 - vectors could be part of a single
94:21 - three-dimensional data unit since they
94:24 - all describe three different aspects of
94:26 - these 50 people that is why as you will
94:30 - see in the near future table like or
94:32 - spreadsheet like objects that comprise
94:35 - of rows and cones are really useful for
94:38 - encoding language language data
94:40 - information and you can do that with
94:43 - data frames in R for the time being I'm
94:46 - going to say at the exercises of this
94:48 - video let's get on to the first one here
94:51 - you are asked to subset the L ones for
94:54 - the people who have score more than 13
94:56 - and response time less than four seconds
94:59 - lastly you're asked to find how many of
95:02 - these extract these figures are as a
95:04 - hint for completing the exercise you may
95:07 - subset one vector by using another
95:09 - vector within the square brackets since
95:12 - remember
95:13 - the data of all vectors in the same
95:14 - position mapped to the same individual
95:17 - pay attention to the formulation of the
95:20 - exercise it uses the conjunction end
95:22 - twice which means that both conditions
95:25 - must be satisfied the second exercise
95:28 - asks you to return the L ones of the
95:31 - speakers with a response time more than
95:33 - 5.5 seconds or those that have response
95:37 - time less than 4.5 seconds notice that
95:40 - this time you need to choose the set of
95:43 - L ones that either satisfy the first or
95:45 - the second conditions the or here is not
95:49 - exclusive which means that the vector
95:51 - with the desired outcome includes both
95:54 - the L ones of people who had a response
95:56 - time more than 5.5 seconds in the L ones
96:00 - of the people who had response time a
96:02 - time less than 4.5 seconds in the last
96:06 - exercise you need to return the scores
96:08 - of the speakers that have response time
96:11 - greater or less than half standard
96:13 - deviation or SD away from the mean and
96:16 - Albanian as their l1 recall that the SD
96:20 - of times underscore sample is 1.5
96:23 - seconds this exercise is a bit more
96:26 - complicated to solve on the previous
96:28 - ones for completing it you need to think
96:30 - in terms of preparing a stepwise plan
96:33 - the first step is to find how many
96:35 - seconds equals greater or less than half
96:38 - an SD away from the mean of five seconds
96:40 - the second step is to implement the or
96:44 - conjunction for comparing the members of
96:46 - x underscore sample with the specific
96:49 - two numbers that you'll have that you
96:51 - will have found in the previous step the
96:54 - third step is to implement the end part
96:56 - of the exercise namely to choose only
96:59 - the l1 speakers of Albanian so I'm
97:02 - looking forward to receiving your
97:04 - answers or any question that may have
97:06 - come up in the comment section below I
97:08 - will come back to the solution of the
97:10 - exercises in the next video
97:12 - [Music]
97:23 - since by now you already familiarize
97:25 - yourselves with a basic so far it's
97:28 - about time to start thinking of how you
97:30 - can have our find specific files in your
97:33 - machines file system and manipulate them
97:36 - so that in the second step it will be
97:38 - able to import these files as
97:40 - appropriate our objects meaning that it
97:43 - will take these files and then convert
97:45 - or transform them into objects that
97:48 - belong to one of ours data types such as
97:51 - character vectors or objects of a more
97:54 - complex data type such as data frames
97:56 - that we will see in later videos but
97:59 - before being able to import files into
98:01 - our it's essential to understand the
98:04 - concepts of a file system and a file
98:06 - path and also to navigate your file
98:09 - system with some basic art functions and
98:11 - that is what you are going to learn in
98:14 - this video let's start off with some
98:16 - basics and break down the concept of a
98:18 - file system first a file system is a set
98:22 - of files and folders of your machine
98:24 - that respects a certain hierarchical
98:27 - structure and that you come across every
98:29 - day when you open and work on your
98:31 - computer all operating systems have
98:34 - graphical user interfaces that represent
98:37 - folders or directories as envelope icons
98:40 - that you can double click on them and
98:42 - see their contents by the way I use the
98:46 - terms directory and folder
98:48 - interchangeably since both folders and
98:51 - directories essentially mean the same
98:52 - thing
98:53 - they are simply meant to contain one or
98:56 - more files or other folders the folders
99:00 - and the files that live inside a
99:01 - specific folder can be thought of as
99:04 - nodes of a tree is the one that you see
99:07 - here where the folders are colored
99:09 - colored orange and the white colored
99:12 - nodes underneath them are the files that
99:15 - you are used to see when you
99:17 - double-click on a folder files are
99:20 - leaves of the tree meaning that there is
99:22 - no way that you can place any file
99:24 - inside them or else they lead to a dead
99:27 - end
99:27 - the tree that you see right now is also
99:30 - called a file hierarchy
99:32 - and is a valid representation of a part
99:35 - of a hypothetical file system three
99:38 - representations like this one reflect
99:41 - the hierarchical structure of the files
99:43 - and folders in your machine
99:44 - of course the whole file system is much
99:47 - more complex since it includes a big
99:50 - number of branches and has many more
99:53 - files and folders that make its III
99:56 - representation much harder to display on
99:58 - a single slide that is why I simply
100:01 - omitted them and replace them with the
100:03 - three dots so this tree then is a
100:06 - partial representation of the file
100:07 - system a special place on the tree is
100:10 - its top node also called the root folder
100:13 - and is always signified with a forward
100:16 - slash the second important concept that
100:19 - you need to understand is that of a file
100:22 - path a file path is a description of a
100:25 - path that reaches a specific node or
100:27 - branch of the tree from any other place
100:29 - on the tree knowing how to traverse the
100:33 - file system in R is important since it
100:35 - helps us signify the path from and to
100:38 - any specific location on the file system
100:41 - that are should follow in order to find
100:43 - a specific file and read it so in other
100:47 - words through file paths you give our
100:49 - directions edge to where to find a file
100:52 - in your file system let's have a look at
100:55 - two paths the first path starting off
100:58 - from the root folder goes all the way
101:00 - down to sub underscore nesting
101:02 - underscored fear of - through testing
101:06 - underscore deer and sub and ur score
101:08 - testing underscore dr1 and then ends up
101:11 - at this sub underscore testing
101:13 - underscore deer - following the second
101:15 - path here you start from the root
101:17 - directory again and then through the
101:20 - folders testing underscore deer and sub
101:22 - done the score testing underscore dr1
101:24 - you reached the place of the file task
101:27 - and score file 5 now how do you indicate
101:31 - a path to a specific folder or file in R
101:33 - or in any other programming language for
101:36 - that matter there are two ways of doing
101:38 - that through describing the path
101:40 - starting from the uppermost node of the
101:43 - tree the root folder or through describe
101:45 - it's relative to a different location on
101:48 - the tree and not the root folder the
101:50 - first way is implemented with an
101:52 - absolute path and the second one with a
101:55 - relative path so for writing down the
101:59 - absolute path leading to SAP underscore
102:01 - testing underscore d2 you would first
102:03 - need to add the root folder that is
102:05 - always signified with the first forward
102:08 - slash then the folder that is within it
102:11 - while the rest of the folders of the
102:13 - path that lead to stop on his Core
102:15 - testing underscore tier two are
102:17 - separated with more forward slashes
102:19 - notice the two different uses of the
102:22 - forward slash that is the first use in
102:25 - the beginning of the of the absolute
102:28 - path that denotes the root folder and
102:30 - the second use for the noting is
102:33 - separator between the folders for
102:36 - understanding what a relative path is it
102:39 - is better to first answer a very
102:40 - sensible question that a novice our user
102:43 - may have what does it mean to give
102:45 - directions to our when I actually don't
102:48 - know where it's starting point is is it
102:51 - always the root folder or some other
102:53 - place in other words you would need to
102:56 - know where the actual working directory
102:58 - of far is throughout your session or
103:00 - else which place of your filesystem are
103:04 - has my immediate access to let's head to
103:07 - the art studio console and find that out
103:10 - in our you can find the current working
103:12 - directory with the get WD function the
103:17 - returned output is a string that shows
103:19 - the actual folder in the file system
103:21 - whose files are has immediate access to
103:24 - the current working directory as you can
103:27 - see is the folder sub underscore testing
103:30 - underscore dr2 folder so they returned
103:34 - out which is actually in absolute path
103:36 - now let's get back to the second type of
103:39 - paths the relative paths relative paths
103:42 - are passed to specific folders or files
103:44 - written relatively to some location on
103:46 - the filesystem other than the root
103:48 - folder as I just said so you could
103:51 - define a path to a file relative to your
103:54 - current working directory let's have a
103:56 - look at a couple of relative paths on
103:58 - the tree that you saw
104:00 - let's assume that your current working
104:02 - directory is the SAP underscore testing
104:05 - underscore dr2 folder and you would like
104:07 - to describe the relative path to the
104:09 - file test underscore file file in order
104:12 - to do that you simply follow the
104:13 - structure of the tree you first need to
104:16 - go up one level and find the branch SAP
104:19 - runs Core testing underscore dr1 and
104:21 - then go down again to find the file test
104:24 - underscore file 5 the notation for going
104:27 - one level up is a double dot using a
104:30 - double dot in a path automatically
104:32 - transfers you to the folder a bowl
104:35 - namely namely to SAP underscore testing
104:38 - underscore dr1
104:39 - then you again have to use the forward
104:42 - slash to indicate the next step to
104:44 - follow in the path since you already
104:47 - reach the SAP underscore testing
104:48 - underscore zero one folder the only step
104:51 - that remains is to go down to test
104:54 - underscore file 5 and you do that last
104:57 - last step by simply writing down the
104:59 - name of the file you want to reach let's
105:02 - take a second example suppose you are
105:05 - again at the same working directory as
105:06 - previously but now you need to go to
105:09 - test underscore file too this time you
105:12 - know that you need to go to levels up
105:14 - first through a SAP runs core testing
105:17 - underscore dr1 then through testing
105:20 - underscore do and then one level down to
105:23 - test underscore file to from the
105:25 - previous example you already know how to
105:28 - write down the first step going up and
105:30 - no surprise you need that here too the
105:34 - second step is no different from the
105:35 - first one though which means that I need
105:38 - the double dot again the last step is to
105:41 - go one level down after the last forward
105:44 - slash and I simply write down the name
105:47 - of the file I want to reach namely as
105:49 - test underscore file - lets get down to
105:52 - practice now and try to change our
105:54 - current working directory to other
105:56 - locations within our tree using absolute
105:59 - and relative paths to make things easier
106:02 - for you I created the files and folders
106:03 - of the tree you see within my file
106:06 - system and I suggest you also create a
106:08 - file structure similar to our tree
106:10 - within a convenient place in your files
106:13 - them so that you can follow along the
106:15 - code of this tutorial as you saw earlier
106:18 - by using the get WD function we found
106:21 - out that the current working directory
106:23 - is the one we've been using as a
106:25 - starting point for the relative paths
106:27 - examples in order to change the current
106:30 - working working directory you need to
106:33 - use the set WD function the argument
106:36 - that this function takes is a string
106:38 - with the path to a location that you
106:40 - would like your new working directory to
106:42 - be so let's say you would like your new
106:46 - working directory to be testing
106:48 - underscore Deere which means that you
106:50 - would need to go to levels up in the
106:52 - hierarchy for this happen as you know by
106:55 - now you should place two double dots in
106:58 - a row separated by the forward slash
107:00 - that signifies the change in location
107:03 - now let's check out whether our new
107:06 - working directory is where we want it to
107:08 - be with get WD okay good
107:12 - notice that for setting a working
107:14 - directory you need to specify a path to
107:17 - a directory as its name says and not a
107:20 - file if file is not a location that
107:22 - contains other files and cannot be a
107:24 - working directory let's change our
107:27 - current working directory back to the
107:29 - previous location to levels down that
107:32 - means simply that you write down
107:33 - sequentially the folders underneath one
107:36 - after the other and if you want to check
107:39 - out the effect of the change you made
107:41 - you can use the get WD function again
107:44 - for setting your new working directory
107:47 - using an absolute path you simply need
107:49 - to write down all the folders starting
107:52 - from the root folder down to the one
107:54 - you're interested in so for setting the
107:57 - testing underscore D folder as the
107:59 - working directory I would have to write
108:01 - down the following path as the argument
108:03 - to the file to the function set WD the
108:07 - next step for you is to be able to
108:09 - programmatically ask for information
108:11 - related to the working directory for
108:14 - instance for listing the files and
108:16 - folders of your working directory you
108:19 - can use the list dot files function you
108:22 - can also list the contents of a
108:24 - different folder on the tree without
108:26 - change
108:26 - your working directory by simply using
108:29 - relative paths for instance let's say
108:32 - you would like to see what the contents
108:34 - of SAP underscore testing underscore
108:36 - dear one is to do that I write the
108:38 - string with a relative path of the
108:40 - folder I would like to check-ins
108:42 - Condon's going one step down means to
108:44 - simply include the name of the folder
108:46 - sup underscore testing underscore tier
108:48 - one is the argument to list dot files
108:52 - function as I do here if you only need
108:55 - to see which folders your working
108:57 - directory has ignoring the files in it
108:59 - you list them with a list deer's
109:02 - function here as expected the only
109:05 - folder included in testing underscore
109:07 - dear he is sup underscore testing
109:10 - underscore dear one check that out on
109:13 - the tree that we saw earlier the output
109:17 - is a character vector whose members are
109:19 - the paths of the folders it contains
109:21 - notice that the first member of the
109:23 - return vector is a single dot a single
109:26 - dot represents the current working
109:28 - directory you don't need to know more
109:31 - about the single dot since it's related
109:33 - to the way that the file system is
109:35 - handled internally for now make sure to
109:38 - interpret the single dot in the
109:39 - beginning of a path as the current
109:41 - working directory relative to which the
109:44 - rest of the path can be described let's
109:46 - move on to asking for information about
109:48 - specific files within a folder and let's
109:51 - remind ourselves once more the contents
109:54 - of the working directory with the list
109:56 - dot files function now with the file dot
110:00 - info function you can ask for
110:02 - information about specific files as I do
110:04 - here with the test underscore file 6
110:07 - file the output includes lots of useful
110:11 - information let's go ahead and see them
110:14 - one by here on the size indicates the
110:17 - file size and bytes
110:19 - apparently since I created empty files
110:21 - for the purpose of the video test
110:24 - underscore file 6 is empty as high and
110:26 - has size of 0 there is dear column
110:30 - indicates whether it's a folder or a
110:32 - file we got four since it's not a folder
110:35 - the mode is octal is an octal number
110:38 - that indicates the
110:40 - file permissions for all potential users
110:43 - this number specification has its roots
110:47 - to the UNIX operating system and the way
110:49 - that the files have been treated
110:51 - historically in UNIX based systems
110:53 - I suggest you go ahead and look up for
110:56 - the set for how to set file permissions
111:00 - and if you are interested especially if
111:04 - you are working on the team will share
111:05 - the same computer or network of
111:07 - computers the EM time signifies the last
111:11 - modified time stamp meaning the last
111:14 - point in time that the file was modified
111:16 - the seat time indicates the time stamp
111:19 - that the file was created while the
111:22 - eight-time signifies the last time it
111:25 - was opened the last four columns
111:28 - describe information about the owner of
111:30 - the file the group the file belongs to
111:32 - and as said just a minute ago it applies
111:35 - to shared accounts or computer networks
111:39 - [Music]
111:49 - hi there I hope you're fine and enjoy
111:52 - the videos of the playlist so far I
111:54 - haven't posted a new video for a while
111:57 - since I was preparing the animation of
111:59 - this video based on this new astonishing
112:02 - Python animation package called money
112:04 - I'm pretty excited with my name and the
112:07 - animation quality it provides and I hope
112:10 - you share this excitement with me let's
112:11 - see and of course any comment or advice
112:14 - for further improvement one on what you
112:16 - see here is more than welcome so let's
112:20 - move on to the meat of this video before
112:22 - moving on to factors and data frames in
112:25 - the next videos
112:26 - I intend here to present the our code
112:28 - solution to the first exercise of the
112:31 - video number 14 it was called subsetting
112:34 - card two vectors practice and more in
112:36 - this first exercise you were asked to
112:39 - subset the L ones of the students in the
112:41 - vector l1 underscore sample and to
112:44 - remind you l1 and the sample is a vector
112:46 - that includes the first 50 members of
112:49 - the GLC underscore part 1 vector who at
112:53 - the same time have scored 13 or more out
112:56 - of 15 in the language proficiency
112:58 - assessment test in the test scores are
113:01 - stored in the test underscore scorers
113:03 - vectors as you'll see in a minute and
113:05 - also have had a response time less than
113:08 - 4 seconds based on the injuries of the
113:11 - vector x underscore sample recall that x
113:16 - underscore sample is a vector with
113:18 - synthetic data meaning that the injuries
113:20 - of x underscore sample did not come from
113:23 - real recorded data but they were created
113:26 - for the purpose of these videos with the
113:29 - are norm function so x anushka sample
113:33 - contains a simple random sample of 50
113:37 - numbers that represent hypothetical
113:39 - response times of a time measured
113:41 - experiment of the same people in the
113:44 - test underscore scores in the l1
113:47 - underscore sample vector now since each
113:51 - time you create a simple random sample
113:53 - with the are known function naturally
113:56 - you get a different vector with 50
113:58 - different random numbers if you would
114:01 - like to replicate the exact same
114:02 - response times with this in the earlier
114:05 - video feel free to visit the link in the
114:09 - video description below
114:10 - copy its content paste it on your RCA
114:14 - console and store the result two times
114:17 - underscore sample vector a variable name
114:21 - following the same name link you can
114:24 - also copy the two other relevant vectors
114:26 - l1 underscore sample and test underscore
114:29 - sample and test underscore scored sorry
114:32 - create it in video number 14 and used
114:36 - here and follow directly what I do in
114:38 - this video
114:39 - recall also that times underscore sample
114:42 - follows that the data stored in the time
114:45 - Sanders core sample vector follow a
114:48 - normal distribution with a mean of five
114:50 - and a standard deviation of one point
114:52 - five seconds now I assume that the three
114:56 - vectors are are aligned in terms of
114:59 - their members namely the first member of
115:01 - test underscore scores
115:03 - records a score of a student who has had
115:06 - a response time that is the first member
115:09 - of times underscore sample in the first
115:12 - language of that person is also stored
115:14 - in the first position of L underscore
115:17 - sample and so on going back to the
115:21 - exercise the last step for completing
115:23 - the exercise was to obtain the L ones of
115:26 - the speakers with that performance
115:28 - apparently this last part rings a bell
115:31 - for using this subsetting operator on
115:33 - the l1 underscore sample vector but I
115:36 - suggest we take things one step at a
115:37 - time there are two things that need to
115:40 - simultaneously be satisfied students
115:42 - with scores more than 12 and response
115:45 - times less than four seconds translating
115:48 - these two conditions in our code means
115:50 - you simply add the pieces in place as
115:53 - here what is important to understand
115:56 - here is how our proceeds in executing
115:59 - each of the two statements for the left
116:02 - statement are takes each member of the
116:05 - vector test underscore scores and
116:07 - compares it with the score 12 and this
116:12 - is where the left
116:12 - Bart does and the result will be a
116:15 - vector of logical values as you will see
116:25 - you
116:39 - then the same will happen for time
116:42 - underscore samples members each member
116:45 - will be compared with the number four
116:46 - that stands for four seconds and the
116:49 - result will again be a logical vector
116:59 - you
117:14 - for finding those students with both
117:17 - scores more than 12 and response times
117:19 - less than four seconds our proceeds in
117:22 - the same manner as earlier namely it
117:25 - simply compares the resulting logical
117:27 - vectors of the two separate comparisons
117:29 - and outputs a new logical vector with
117:32 - true values in positions that both
117:34 - logical vectors have true values in them
117:37 - and false otherwise the ampersand or
117:41 - logical and operator serves exactly that
117:44 - purpose namely it compares the results
117:47 - of the first comparison with the results
117:50 - of the second comparison and assigns a
117:52 - true value when only when the pairwise
117:55 - results are both true let's see the
117:58 - contents of the final logical vector
118:00 - directly in our studio console as
118:02 - expected here you can see there's the
118:06 - resulting logical vector but what was
118:08 - actually asked was to retrieve the first
118:11 - languages of the people with these
118:13 - performance and that means you need to
118:16 - think in terms of what you have to do to
118:18 - subset the relevant first languages of
118:21 - the l1 our score sample vector actually
118:25 - you're almost there since you already
118:27 - prepared the logical vector that will
118:30 - function as the picking mechanism within
118:32 - al l underscore sample recall that the
118:36 - three values of the resulting logical
118:38 - vector will be translated internally as
118:41 - once by our and the false values as
118:44 - zeros then the subsetting operator
118:47 - represented by the square brackets as we
118:50 - already know will retrieve the languages
118:52 - on the exact same positions that the
118:54 - logical vector had once in it
118:57 - so let's actually do this last step now
119:01 - you enter the complex statement within
119:04 - the square brackets and there you have
119:05 - it the first languages of the people
119:08 - with score results more than 12 and in
119:11 - response time less than four take a
119:15 - moment to think about what one can do
119:17 - with such powerful subsetting mechanism
119:20 - with a single line of code you can
119:22 - perform now this kind of complex sub
119:24 - settings that serve you choose subgroups
119:27 - of yours
119:27 - objects or of your texts if you're
119:29 - working on corpora that meet very
119:32 - complex and specific criteria so that
119:34 - you can focus on that group and test
119:37 - your hypothesis or build your models for
119:39 - your research that's it for now I hope
119:42 - you liked the animation and helped you
119:45 - real clear out the concept of subjective
119:47 - and of course if you liked the content
119:50 - of these videos don't forget to
119:52 - subscribe to the channel to get
119:53 - notifications when new videos are
119:55 - released
119:55 - see you in the next video

Cleaned transcript:

hi there my name is Alex Santos and I'm assistant professor of text and computational linguistics in our solo University of Thessaloniki in Greece in this video I combined the content of a series of shorter videos that I uploaded on my YouTube channel related to programming with the our language the r programming language as some of you may have already heard is one of the top programming languages for analyzing modeling and visualizing data so these 15 short videos focus on explaining basic concepts of our programming related to vectors in their sub setting to opening and reading text files in R and they're primarily made for people who would like to learn our from scratch and they have no prior programming background in R and they would like to be able to learn and use our effectively for the data analysis the next video that I will upload on the programming knowledge channel I will again contain the combination of shorter videos on our programming focusing on factors and data frames until then if you'd like to watch these shorter videos as they come out pass by and subscribe to my youtube channel whose link you can find in the description below that's it for now enjoy the videos before you start learning our you need to first carry out two necessary installations for starters the program in our sure enough you need to have our installed then you will need our studio one of the most well known IDs that will be hosting our our programs ID stands for integrated development environment and by integrated development environment I mean the set of tools provided to you in order to swimmingly develop an our program for instance some basic features include an editor with code coloring that very easily help you spot keywords variables and other types of fire objects that you will be learning in the next videos also code Auto completion and debugging you will be able to acknowledge the power of all of these features as you become more proficient in using our before we begin with installations notice that the order of installations matters you first need to install our before you install our studio our studio will share its foreign our installation on your machine before it is installed first things first though let's install both software programs first for Windows and then for Mac let's first go to our sufficient webpage our project.org then you follow the download link on the upper part of the page next screen shows the available mirrors from which you can download the software you can choose the mirror of the country you live in or run nearby and follow the respective link let me follow Greece's link since I live in Greece and next step is to choose the operating system of your machine now you choose windows in the next screen click on the base link and then you simply select the download our link at the time of this video recording our latest release version is three point five point two now you save the file and then double click on it to execute the downloaded dot file now a new popup window appears that gives us the chance to set the installation language here I choose English next popup window is about the terms and conditions of using are under its ganoub public license you simply move on by pressing next as you will do for the next few windows regarding the selection of components the setting of startup options the Start menu folder and the additional tasks our is installed and you are one installation before you are ready to go it's our studio stand now first you need to visit our studios official web page then choose the products tab and select our studio you find the download they are studio desktop link for your laptop or desktop PC in the next window you choose to download the free version and finally you pick the windows installer you choose to save it somewhere on your disk that you can easily access and then wait until it's downloaded after downloading it you simply double click on it and choose next for the remaining screens until the finished button appears you the only thing that remains is to actually find and open our studio you go to the Start menu and then you find our studio and load it now you're in front of our Studios environment where you will be working throughout this series as you can see there are four panels the two ones on the Left above and below will concern us most of the time since these are the places where you will be writing your our code for the first few videos you will be working on the lower left panel the so called our console and after you start feeling a bit more comfortable with the language we will start with writing our first our programs on the upper left panel and run them from there I will prepare a video for explaining how to use the upper left panel when the time is right the remaining two panels have special functionality that you don't have to worry about right now but just keep in mind that as we move along the series I will help you discover some of the benefits of using them while programming so far with Windows let's head to Mac's installations installing our for Mac does not make much of a difference you go to ours official page you follow the same download link and then you choose the mirror you want to download the software from you would usually want to find a mirror from your country or a neighbor one I chose the Greek mirror in Crete as I live in Greece in the next screen I choose the download R for Mac link after that I pick the latest release package at the day of recording this would be our three point five point two now our is downloaded the next step is to install it press Continue then agree to the terms of the license agreement choose your disk if you are the only user of your Mac and install insert your password to allow the installation by entering your password and then the installation begins you wait a couple of minutes until the window with a successful installation pops up lastly let's install our studio for Mac you first need to go to our Studios web page choose our studio from the products tab then our studio desktop and download finally you click on the free version link and then on the corresponding Installer installer for Mac after having downloaded the dmg file you simply click on it and let it do the installation finally you drag their studio icon on the Applications folder and you're ready to go now to open our studio you click on its icon and you are in front of ours to the environment that is identical for both Windows and Mac as you can see there are four panels the two panels on the left above and below will be the ones that you will be working on since these are the places where you will be writing your art code for the first few videos you will be working on the lower left panel the so called our console and after you start feeling a bit more comfortable with the language we will start writing our first our programs from the upper left panel and run them from there I will prepare a video for explaining how to use the upper left panel when the time is right there are two panels included a number of useful features that you will discover as we move along the videos of the playlist now you are set to go and enter your first our code chunks hi there as I mentioned in the first video of this playlist throughout this series you will see the common steps obstacles and advances that are provides in handling analyzing and modeling language data to that end the GLC dot sample data package a package that I created and now distribute through my github account will often serve as the basis for explicating the new concepts as we move along but what is in our package in our package is a set of programs written in our or datasets in spreadsheet like form that are can understand accompanied by detailed documentation as to how to use them for efficient data analysis in our case the GLC dot sample is a plain data package that and that means that it includes only data and is accompanied by documentation as to what these data represent particularly the GLC dot sample package includes metadata such as the first language the communication skills level in the proficiency test scores in the listening and writing tasks of 100 students of greatest second language recorded for the compilation of the Greek learner corpus abbreviated as GLC jill sees an error annotated learner corpus that you can download from the link I will include in the video description below there are two steps that you need to always have in mind when it comes to using in our package first you need to have the package installed in your machine in case it's not included in besar namely when you installed R in our studio if it is not installed you need to install it with a couple of specific commands that you will learn here the installation is done only once so you don't have to do that again next time you open our studio you then only need to load the package in order to use it so after installing an external package the second step is just that namely to load it before you are able to use its commands but GL seedot sample package is an external package meaning that it is not available immediately after you open our studio as I just said and needs to be separately installed the GLC dot sample package is distributed through github a well known online repository of our packages used mostly by programmers all over the world there are three steps for installing the GLC the sample package first step is to access the jillsy dot sample packets in github and for that you need to first install the dev tools package that provides access to github so you first write the line of code that you see right now on console on the bottom left panel of our studio the install that packages command or function as I will more often call the chunk of code that includes a name followed by opening and closing brackets will install the dev tools package then after successfully installing dev tools you need to load it so that you can use its commands or else functions to access a GL c dot sample for a slightly more advanced tutorial with information on the distinct categories of our packages on how to install and browse through them check out my earlier video on our packages and I provide a link in the video description below now you simply need to load the dev tools package with the library function after loading it you need to use the installers called github function are provided by the loaded package dev tools what you see inside the parentheses is a string signified by the surrounding single quotes with the address of the resource the deals with all sample packets in the github address inventory what this means is that the function install a underscore github searches through the available online github accounts and goes to my account that is the Atlantis part and then to the repository with a package GL C dot sample after finding it it's job is to simply install it on your machine while installing the GOC you'll see dot sample package a message appears on the screen waiting for your input ignore it by pressing the enter key as it does not make any difference for you right now next step is to load the package with the library function before we are able to use it and now we are ready to use the loaded data offered by the package from now on you can use any of the death data of the package for your packages for taking a brief overview or GLC dot samples vectors you need to use the data function for the time being you're not equipped to understand exactly what goes on in this code Chang don't worry about that you will soon be able to do so just type in what you see in the console for now what this function does is that it asks are to provide information about the content of the data sets in the GLC dot sample package the output will be displayed on the upper left our studio panel there you will see the names of the distinct data sets jillsy underscore part one to GLC underscore part four that corresponds to the four distinct areas tested within the standard language language proficiency assessment test used for the compilation of the Greek learner corpus and they include the learners scores namely scores on listening reading speaking and writing tasks also g gr underscore communication underscore skill records the levels of l2 great learners communication skills in Greek while jillsy a no score l1 the students l1 profiles you can browse through a more detailed documentation for each of the data sets by simply preceding the name of the data set with the with a question mark as I did here with the question mark GLC underscore part one data set wrapping up on the code of this short tutorial you'll learn to install load and explore the GLC dot sample package with the install underscore github library and data functions correspondingly now that you installed the GLC tooth sample package and know how to load and browse through its content it is high time you start getting your hands dirty with real language data analysis in the next videos hi there most of the times you will need a way to store and access values that describe a single aspect or feature of the collected data a vector is a onedimensional data structure in R that you can use to do that by one dimensional I mean that its members are of the same type and represent a single feature for instance the response time measurements of a single experiment the recorded first language of a set of students as in the vector jillsy underscore l one of the GLC dot sample package that we will see in a minute or even responses to a single questionnaire item in this and the next couple of videos you will learn how to explore and handle character vectors namely vectors whose members sure enough are of character type after watching this video you will be able to use our code for getting the length of a character vector for obtaining its first or last n items and also for extracting its unique elements let's jump directly on GL c underscore l1 a character vector included in the GL c dot sample package that reports the first language or l1 of a sample of 100 students who's written productions were recorded during the compilation of the Greek learner corpus for more information on the package and the Greek Lerner corpus visit the earlier video in this playlist recall from the previous video that before using any of the date of an externally installed our package such as the GLC underscore l1 vector you need to load the GLC dot sample package that contains it that means you need to use the library function now you can choose to either display the content of the GLC underscore l1 vector on the console by calling its name as I just did here or to display it separately on the upper left our studio panel with the view function as you can see most of the l1 entries of the vector are Albanian this is interesting to observe as the collected data come from Greece its neighbor country moreover soon you will see that you will be able to quantify this intuitive first observation the first you are going to want to know when you have a character vector is the check its length namely the number of elements it contains this will reveal whether all the recorded values have also been included in a vector you can achieve this with the length function here as expected the length of the vector is 100 since the number of students is 100 getting an overview of a vector can be done with a head function this function takes a vector as its argument and outputs its first six entries by default for those who wonder what an argument is just look at what inside the parentheses that follow the name of a function is if a function has more than one arguments these must be separated by a comma the function head requires at least on argument the vector or the variable that represents it GLC underscore l1 in our case but can also take optional arguments that enhance its functionality here I use an external america argument T is 25 that will overcome the number 6 that by default is defined when no second additional argument is added in other words as you can see our returns the first 25 entries of GLC underscore at 1 the function tail returns the last six entries and as with head if you enter the number 25 as an additional argument the last 25 entries will be returned in a vector with various language profiles such as GL c underscore l1 you might also simply want to get a first feeling of the variability of the data in our case the variability translates to the number of distinct recorded l ones in a vector with 100 pretty recurrent l ones it is not so hard to monitor the different languages although not very easy either however imagine if you had a vector with entries of greater variability and much bigger in size for simply getting the different languages of a vector you can use the unique function what unique does is that it eliminates duplicate elements from a vector that is given as its argument and returns a new vector that keeps only one of its type let's say so the resulting vector includes the nine languages that appear in GLC underscore l1 one time or more notice that the resultant na entry which means that there are some missing data for at least one of the 100 students in other words for some of the students the l1 has not been recorded and there can be many external reasons for this to have happened you will see how to handle this type of data in a later video the vector is as diverse as including languages such as Punjabi Arabic Romanian Bulgarian and Georgia gamma gathers wrapping up on the code of this short tutorial you'll learn to ask for the length of a character vector with the length function to browse through its first and last n items with the head and tail functions correspondingly and to remove duplicate entries with a unique function so that you can have a first insight of the variability of the data one of the fundamental concepts in our and in programming in general is that of a variable conceptually you can think of a variable as a name that stands for a value and it works much in the same way a post address does namely a post address is a conventional name followed by a number that everybody shares to refer to a specific building so you can think of a variable as an address that you first a constant value or object as we call it a in our here the variable name refers to the string Alex since all our values have a specific data type think of the analogy of a specific building that belongs to the type of buildings a variable does not belong to specific data type but it refers the value that has its own data type in our case the value Alex assigned to the variable name is of type string but the variable name does not belong to any type only its value does in other words variables can also be thought of as typeless names that refer to objects both of these definitions I just mentioned are identical okay now how do we create a variable or else how do we assign a value to a variable the answer is by using the left direction arrow which is a combination of the less than symbol with a hyphen on its left side you use the variables name with no quotes around it and on the right side of the arrow you place the assign value the arrow is also called the assignment operator here I assigned the value of first string to the variable called first underscore variable lastly the assignment is completed as any other command that you add it on the console by pressing the enter key then the ars interpreter is called to evaluate the assignment statement notice that after pressing the enter key nothing shows up on the console that doesn't mean that something is wrong it just means that R has done its job and now variable and its values have been recorded in the memory you can then use this variables name to easily access the value assigned to this variable and you can do that by simply type in the name of the variable and then pressing the enter key as I did here you can also change the value of a variable by assigning it a different one the first underscore variable is now assigned the string not really now let's see the kinds of restrictions are puts in naming variables I could name a variable human underscore being underscore 1 2 3 dot world and assign it the string with my name but I could not name a variable starting with a number as you can see here with the one two three underscore human underscore being dot world also you cannot have variables starting with an underscore let's try a dot add in the beginning of the name followed by the sequence of digits one two three as you can see it does not work either however if a name started with dot was followed by a character the variable is created successfully lastly I cannot use reserved words in our to name a variable reserved words are keywords in our that have a special meaning for instance I could not use the word for as a variable name for is a keyword especially reserved for starting a for loop as you will see in later tutorials summing up on the naming conventions variable names can be a combination of letters digits period and underscore it must begin with a letter or a period if it starts with a period it cannot be followed by a digit and reserved words in R cannot be used as variable names our variables resemble the variables used for language data research this means that they both stand for a value and express a single feature for instance jillsy underscore l1 is a variable that stands for a vector of the GLC dot sample package and then codes your language data variable namely the first language of 100 students GLC underscore l1 is then an our variable that links the concept of a first language with the actual collected student data the process of linking scientific concepts with a collected data through variables is often called operationalization the variable jillsy underscore l1 is a result of operationalizing the concept of a first language recorded in the collected sample before finishing this tutorial make sure you take one more walkthrough of the code on variable assignments and the hours of variable naming conventions let's practice the functions that you learned in the previous video on a different vector of the GLC dot sample package on gr underscore communication underscore skill before that you need to load the package GL C dot sample that contains it with the library function as usual now you can browse through the gr underscore communication underscore skill vector with the our studious view function the members of this vector represent the 100 students communication skills level in Greek passing an eye over the vectors elements you can observe that the students communication performance Greek is very good now let's ask for the length of the vector no surprise it is 100 next step is to get the first n items of the vector I chose its first 30 members and for the last 30 members you need the tail function you what about the unique elements of the vector or else how many assessment levels have been recorded for this you can use the unique function that outputs a vector with five members in our case although the number of unique elements is small you will often deal with character vectors that contain a big number of unique members in order to get the number of the distinct members of the vector you can use the unique function in combination with the length function that accepts as its argument the vector returned by the unique function as you can see the unique function is placed inside the parenthesis of the length function this is possible to do since R evaluates the expression in a from inside out fashion what I mean by that is that when R deals with nested expressions such as this one it first evaluates the most deeply nested expression the one that is inside the parenthesis then it gets the returning value a vector in the case of unique and passes it back as the argument to the length function that is why the length function takes as its argument the vector with the unique elements of G R underscore communication underscore skill and returns its length of course you could achieve the exact same thing in two steps you could first assign the resulting vector of the unique function to a variable as I did here with a unique underscore communication variable and then insert the variable as argument to the length function if you are feeling shaky as to what an our variable is check out the earlier video that explains the concept in detail here is the code summary so far feel free to pause the video you like and take a look at it until now we worked with character vectors loaded from the GLC dot sample package what if you wanted to create your own vector that would be the case if you had a small data set or if you wanted it to test some hypotheses on a sample of data and for that you need it to hardcode it into an R character vector so combining some character values into a vector can be achieved with a c function here i combined the three strings Greek English and German into a new character vector r's interpreter evaluates the expression and displays the resulting vector of course you can assign the vector to a new variable so that you can access it later as i just did here with a variable called languages so let's bring it all together and see how we could do something more creative with our data and with the freshly acquired knowledge let's assume that we would like to create a new vector with two elements the numbers of unique elements in the two character vectors GLC underscore l1 + gr underscore communication underscore skill the first step is to think of how to get the unique elements of the two vectors that is something you already know how to do and you saw it in this in the last video next step is to think of how you could get the lengths of the vectors returned by the unique function that you also know and just saw a minute ago each of the values returned by the last two statements will be an entry in the new vector so what remains to be done is to put these two code chunks together in the same vector and you can do that by using the C function that constructs a vector its arguments will be the members of the new vector that means we put the two earlier code chunks inside the parenthesis of the C function and separate them with comma as we do to a function that accepts more than one arguments finally we store the resulting vector to the variable lengths so that we can access it later by calling it you can see that it has two numbers as its elements 5 and 10 for the number of distinct languages and the number of distinct assessment levels of the GLC underscore l1 and the gr underscore communication underscores kill vectors correspondingly there is nothing special about this seemingly complex code chunk rewind what I said a minute ago about the way our deals with nested expressions namely by evaluating from inside out any complex code expression and you will see how the complexity vanishes now is your time to do something with the data so here are 2 coach ank's I prepared for you I would like you to tell me which of them number 1 or number 2 returns the length of unique elements of the first 50 members of GLC underscore one feel free to pause the video run both coach ankhs and think about the output you get I'm looking forward to receiving your answers or any question that may have come up in the comment section below I'll come back to the solution of this short exercise in the next video decoding mentally the way that our evaluates nested expressions is definitely the first and decisive step to understanding our code and creating your own art programs in the last video you were assigned a short code exercise there you were asked to check which of the two lines of code one or two could produce the length of the vector of unique elements for the first 50 members of GLC underscore l1 let's first take option number one when writing nested code in our recall that by a nested I mean that one function is placed as argument within another function the most important thing to remember is the order of opening and closing brackets that indicates the arguments of a function and the commas that separate the arguments of a function in other words you aren't puzzled the code by looking at parentheses and commas and that is exactly what you need to do here in order to interpret what this line of code does recall also from last video that our evaluates expressions in and from inside out fashion so starting with the innermost expression we know that R will evaluate it and return the first 50 members of the vector GLC honest world 1 or else the first 50 languages of students of Greek as a Second Language the next level up is unique that takes the output of head and gives back the number of unique members it contains which is 5 let's head to the second option here the inside function head has only one argument and returns the first six members of TLC underscore l1 whereas the unique function has two arguments namely the head function and numbered fifty finally the outermost function is length that has only one argument the output of the unique function R starts to evaluate the innermost function head and as you already know by default when no second argument is given it outputs the first six members of the vector Jill siano squirrel one at the next level uniq has two arguments however when you learned about the unique function you may recall that it accepts one argument and not to let me explain what happens here the first argument we think the parentheses is the required one it is a vector whose unique members will be returned in our case this is the vector with the first six members of GLC underscore l1 returned by head and the second argument is number 50 apart from the first required argument unique allows for further arguments that for the time being are not functional meaning that they are not processed in any way in a later video when you will be learning about functions I will explain you type of argument called the three dots argument for now you simply need to keep in mind that although we said unique requires a single argument it also allows for further arguments that do not play some additional role in this case in other words what the code of the second option does is that it returns the unique elements of the first six members of TLC underscore l1 that is why option number one is the correct choice for spawning two the code exercise karthick vectors are valuable data structures that store one or more strings as you saw earlier in this series in this tutorial you will dig a bit deeper in the building blocks of a character vector namely its members strings you will learn what an our string is how it is defined and lastly you will see some of the basic tool tools our provides you to handle and explore textual data stored in character vectors so let's zoom in on strings a string is a piece of text represented as a sequence of characters B that letters numbers and symbols let's have a look at some strings in our studio I have written a string here our gives people the heebiejeebies and by pressing enter our console returns back the same string with its quotes showing you that it evaluates the string that you gave it correctly namely as a string a string as you can see is not identified with an actual word a single string may contain a whole natural language text or even more than one texts what matters for a string to be evaluated as such is that a sequence of one or more letters numbers or symbols is enclosed within either double or single quotes that delimit is bounders moreover the quotation must be done consistently what does consistently mean in this context though it means that when you are creating a string you need to pay attention to end the string in a consistent manner with the same type of code you started with in this string I created the second go I chose double quotes to put around the string so I use this type of code in both its beginning and end the same applies to single quotes if the string started with a single code as this one it should end with a single quote if the string contains quotes in it as in the case of having quoted words then the pairs of quotes inside should differ from the ones outside here let's try to replace the single quotes in the string with double ones and see what happens in this case I got an error message that indicates that there is a problem with the sequence of symbols within our string let's try to understand why this happens following the quotation syntax rule I just mentioned namely that the type of quotes is a means for marking the start and end boundaries of a string and that the ones inside should differ from the ones that mark the borders of the string then the sequence I just wrote consists of two strings with some symbols in the middle that do not belong to either strings so there are two problems here first I declared two strings on a single line and there are also some symbols the people part that do not belong to the string and that also do not represent any variable or function and hence cannot be evaluated by our the same applies if you chose to mark the boundaries of a string with single quote okay so let's put aside strings for a moment and let's head on to character vectors again recall that character vectors are sequences of strings and you're going to learn some very basic functions or commands if you like but I suggest that you get used to the term function instead of command since that is the right term to use and these functions you will see will allow you to handle character vectors and take some basic information about them let's assume that you would like to get the number of characters of each of the strings within a character vector let's further assume that each member of the character vector is a word string namely a string that corresponds to an English word followed by punctuation for example the exclamation mark is in the following vector that contains has its members the words of the previous string notice that I assigned the character vector as a value to the variable sentence to achieve this the end char function is useful what n char does is that it takes as its argument a character vector and for each of its strings it calculates the number of characters then it returns a new vector with the counts of characters of each string on the preowned the positions they were in the initial vector let's see it in practice the first position of the new vector is the number one the number of characters of the first word are of the vector assigned to the variable sentence on the second position five for the following member of sentence the verb gives on the third position in the outputs three for the article there and so on and so forth within char you can get a good first overview of the vector sentence imagine you had a vector with its members being word strings of a whole text then n char would give you the lengths of four words in the text this might be considered a valid factor for measure in sentence complexity in terms of both comprehending and skimming through a text in fact the number of characters in a text is already considered as a factor by researchers of the field of psycholinguistics the next crucial step is to see how you could arrive at the character vector with word units as members such as the vector sentence this is an important step to know how to do since if you have a character vector with words as its members you could employ are to obtain insights from the textual data so how do we get from a row text to a character vector that has word strings as its members our provides numerous functions from different packages but to that end I will use here the base our function STR split as I mentioned in an earlier video on our packages functions that belong to base our are considered inbuilt functions which means that they can be used from the very beginning of any our session and do not belong to an external installed package so the library function does not need to be used you already learned some other bizarre functions and these are they see or the length functions that you saw examples of other basic functions that you already learned in previous tutorials are the C function for creating vectors in the length function for getting the size of a vector okay starting with a row string R gives people the heebie jeebies i will first have to assign it to a variable and here i choose to call it row dot txt the STR split function takes two arguments the first argument is the string to be segmented represented here by the variable loaded text and the second argument is the segmentation criterion namely the criterion for splitting a string I use the empty whitespace character for that notice that the whitespace character is surrounded by quotes to signify that it is a string keep in mind that even though it signifies the emptiness it still has length one and by using the whitespace character as a segmentation criterion I mean that the whitespace character is used to mark the boundaries of the members of the new resulting object or in other words the places in the string that the new members will be cut this will become clear to you when you see it in a minute in order to get the character vector there is one last step though STR split segment strings into sequences of word strings but does not return a character vector instead it returns a list signified by the double square brackets you haven't seen list yet and there will be separate videos on lists dealing with how to define and manipulate them but they won't bother us now for now you simply need to know how to convert the list return from the STR split function in the character vector that you know for this you need to use the unlist function the unlist function takes a list as its argument and as its name suggests it returns a vector in this case it takes the returns list of the sto split function recall that in the case of applying a function on the output of another function you could either do it in a single step by putting the STR split function within the parentheses of the analyst function or in two steps where you first assign the returned list of STR split to a variable and then put the variable into the parentheses of an list I suggest you go the indirect way so that you get used to defining and using variables here the word that lists variable is assigned the value of the list returned from the STR split function and the work that vector variable stands for the converted character vector let's check on word that vector as you can see the result is a character vector that consists of word strings by the way the process of segmenting a piece of text into a sequence of natural language word strings is also called tokenization now you are in a position to use the familiar by now functions for handling character vectors and to get some basic insights of the text for instance you can ask for the length of the vector or in other words for the length of a text in terms of word units as you can see the text consists of six words or you could ask for all the distinct words of a text with a unique function again they were unique words are six since no word is repeated most of the times euro textual data will be stored in files in your computer and you will need to import them in R this means that in order for you to be able to further process your text files in our studio you should first convert them into our objects namely character vectors and strings that are can understand and allow you to use functions for handling strings and character vectors such as the ones you learned in the last couple of tutorials in this short tutorial you will learn to do that namely to open and read text files into R objects into that end I will use the three different options that are provides us they reach our the read lines and they read file underscore file functions so first things first let's take the text file lorem underscore ipsum dot txt that you will be importing in R that contains a big part of the lorem ipsum text here it is I opened the text file with an editor called sublime text but you could have opened it with any plain editor such as notepad for those not familiar with the lorem ipsum text this is a specific blind or dummy latin like text used very often by the desktop publishing industry as replacement text for testing purposes essentially the lorem ipsum text is there when the text content is not the issue at hand as in our case so here we don't really care what the content of the text file would be I already saved the text content of lorem ipsum to this file in the folder YouTube within my home folder for using the same text file to practice what you see in this tutorial you can go to this link that I also added on the video description below then copy the lorem ipsum text open your favorite text editor and paste and save it as a txt file in a folder that you will set as your working directory in the way that I will show you right now it is crucial to understand at this point that in order for art to open this text file you need to show are exactly where the text file is placed within your machines file system although we'll prepare separate videos specifically on how our navigates through your file system via file paths for now keep in mind that you only need to set the folder with a text file or Aman description dot txt leaves as your working directory briefly the working directory is the folder whose files will be directly available to our to do that you go to one of the right panels that displays the file system of your machine the panel that you see right now placed on the top right will probably be shown on the bottom right side of our study on your screen but apart from the positioning of the panel's nothing else is different in my art studio settings so you go to the folder that contains the text file that you would like to load in our in my case it is the YouTube folder in my home directory and double click on it now you simply go to the tab more open it and select the set as working directory and from that moment on every file that you will put in this folder will be available to our for reading it there are three options for opening and reading row texts in our the first option is to use the read lines function that opens a text file and reads or converts its content into a character vector whose members are the distinct lines of the text I saved the output to the variable called lorem ipsum the argument of read lines is the string with the name of the text file that is why it is surrounded by quotes as you can see each member of the vector lorem ipsum maps the separate line of the original text the end of the line in the original text file is marked with the newline character as you will see in a minute the new line is the criterion for segmenting the original text and creating each member of the new character vector lorem ipsum also note that some members consist of the empty character that means that there were some blank lines in the original text file until now in this series you met some methods for handling character vectors but you did not learn how to retrieve a specific member or a range of members of any character vector you'll learn how to do that in the next follow up tutorial for now let's use the length function that you already saw to find the number of lines in the text as you can see there are ten lines recall that in the last tutorial you show how to use the STR split function on a single string and then the length function to find the number of words in that string the output of red lines though is a character vector and not a single string for which you could use STR split to segment it into words for reading a text file directly into a single string you could use the second option of using the read char function the read char function takes two arguments the first of which is the string with the name of the text file and the second argument declares the number of bytes that should be read by R for declaring the number of bytes you can use the file dot info function you're not equipped yet to understand what goes on in this chunk of code but you will soon be able to do that let's have a look at the variable lorem ipsum dot string that stands for the content of the original text file as you can see the line boarders of the original text file are marked with the newline character signified with a backslash followed by in the text between the newline characters were separate lines in the original text now you could use the code demonstrated in the last video tutorial to segment the string into a character vector with words of the lorem ipsum text as its members using the STR split function and the unlist function you now you can ask for the size of the text in terms of words with a length function which is 543 the last option is to use the read underscore file function of the external package radar which is available in cran recall that to install any external cran package you use the install that packages function if you need to brush up on our packages and on how to install one go ahead and visit my earlier video on the subject apart from the card that you see right now in the top right side of this video I will also add the youtube link on the description below after loading the package radar you can use the read underscore file function that does exactly the same thing with the read char function namely treats and converts the text content of the file into a single or string the difference with red char is that it only needs a single argument with the name of the text file and you don't have to add a second argument that specifies the suitable memory size to allocate of course since you now have the whole text as a single string again you can do exactly the same thing that I just did with lorem ipsum dot string namely to segment the string stored in lorem ipsum dot string dot radar into a character vector with words of the lorem ipsum text as its members using the combination of str split and unlist lastly as previously you can get the text size in terms of words with a length function which again is 543 wrapping up this tutorial make sure you check out the code summary some tutorials ago you were introduced to the concept of a character vector as a onedimensional data structure in R that you can use to store values of type string and recall that by one dimensional I mean that its members represent a single feature of the data be that the first language or the country of residence of a speaker or some other theoretically interesting feature that can be encoded as strings in this tutorial it's about time to dig a bit deeper into character vectors and learn about their second defining feature namely that each member in the character vector is implicitly assigned an index or else a numbered position let's take a simple example of a character vector to see how indexing works in R this character vector has four members or indices the two terms can be used interchangeably here that stand for the position of each member in increasing order if we start counting the characters from left to right number 1 is assigned to the string read number 2 to yellow number 3 to blue and number 4 to green as you notice then indexing starts with the number 1 as opposed to other languages such as Python that start counting from 0 and for that reason they are also said to be zero based languages so when you hear that R is a one based indexing language they mean exactly that namely that it's indexing system starts with a number 1 now the next natural question to answer is how do you retrieve values out of character vectors or equally equivalently and to use the write our terminology how do you subset a character vector sub setting in our is very powerful and unbelievably efficient among the three ways of sub setting that you see right now on the slide I will focus on the first way in this tutorial the others will be presented in the next tutorials using the indexing of a character vector is the base a tool for subsetting a character vector and secondly you need the subsetting operator of square brackets so let's jump directly on into our first example of subsetting a vector for that I have taken the character vector of the earlier example with the strings of colors as its members and assign it to the variable colors for subsetting the vector colors you need to use these subsetting operators besides the name of the variable that stands for the character vector and between the opening and closing square brackets you insert the index that corresponds to the value you would like to retrieve so if you'd like to retrieve the second value of the vector you simply insert the number 2 within the brackets for the fourth member of the vector then you would simply use number 4 apart from subsetting a single value with using a single index you can also subset a range of values for that you need to use the arrange operator represented with the colon punctuation mark that needs two numbers on both of its sides left and right the one on the left represents the start of the range and the other one right the end of the range of values you want to subset so by writing this code of chanc you ask art to return you the values of the second the third and the fourth member an important note to have in mind that you can see in the output that our returns after subsetting the vector colors and of any vector for that matter is that the retained output is a new vector a number one on the left of the output signifies that one it's right starts the first member of a new vector the returned vector let's take another pretty often scenario let's suppose you needed to get specific values that are not besides to one another or in other words they are not placed they are placed in various positions within the vector in this case the range operator is of no use to us what you need is instead is to use a vector of indices within the subsetting operator the chunk of code that you see simply says give me the first and third member of the of the character vector colors and this is one more example of nested code the nesting comes from the fact that the vector is placed within the sub setting operator evaluation is done as you already know by now in a from inside out fashion namely the vector with a values one and three is evaluated first and then these two values are given as inputs to the sub setting operator another pretty common scenario is that you might need to extract all values except some specific ones for which you know their index in that case the minus operator is at use you simply put it in front of the index that you want to exclude here assuming you want to exclude the first member of the vector you put minus one inside the square brackets and you are done so all members of colors are returned within we are returned within a new vector except the first one if you would like to subset the second and fourth member and exclude the first and the third you simply get a bit more creative by using the tools you just learned and you create a vector of negative indices that you would like to exclude and put it within the square brackets equivalently you could put the minus in front of the vector with the same effect namely are here interpret this code Chang in the following way give me back all the values of the vector that do not belong to the vector inside the square brackets lastly you can't mix positive and negative integer integers in a single sub setting this line of code simply returns a false message that indicates that a last remark that is that although some of you may not have already thought about it when you learn the basic tools of navigating through an character vector with the head and tail functions you already did the basic sub setting on a character vector however these two functions are limited in the values that they can achieve and the ways they can do that and they cannot by any means substitute the subsetting mechanism that you just started to learn right now just keep in mind that you only scratched the surface of ours flexibility and power to subset vectors wrapping up this tutorial make sure you check out the code summary last time you were introduced to the concept of subsetting a character vector more specifically you'll learn to use the first of the three different ways of subsetting character vectors namely using indexing and for that I used numbers within the square brackets operator let's turn our attention now to another way of subsetting a vector by using relational or logical operators this method allows to retrieve data that fulfill one or more conditions and therefore it is a very useful tool for powerful explorations in the data that reveal the underlying characteristics of the data set however this powerful technique for exploring vectors and other more complicated our objects as you'll see in the near future comes with a cost namely you need to understand how the underlying logic of using it works and to that end I will spend some time in the following videos to help you grasp the jist of it so in this video you will see how relational operators in our function and as a necessary intermediate step on your path of understanding and using them you get to know the boolean values a new type of data that is retained when you use these operators no worries I will take one concept at a time the first step is to learn how to express yourself in R when asking whether two or more values are the same or differ and in general how to use relational operators as we call them for doing that so lay back and in a couple of minutes you will have understood how you use them in combination with the square brackets for retrieving sets of values out of a character vector so let's dive in the first operator is the Equality operator signified by the double equal sign with the equal operator you can compare two values for equality for instance the following line is about to compare the two strings on the left and on the right of the equality operator notice that since I typed these two strings although their content is the same namely it consists of a number of specific symbols that happen to be same and in the same order they will still be interpreted by our as two strings and not one what we asked it to check is whether these two strings indeed consist of the same symbols and in that exact same order now as it usually happens when you ask something from our it will return you a value in our case when you will be asking it to check for equality between these two strings it will always be returning you one of the two values true or false true if indeed the two values and the comparison are the same in the way I just mentioned and false otherwise let's go directly to the example the two strings here are the same and therefore as expected the return value is true in this second line I get false because apparently the two strings do not consist of the same characters of course you can use the Equality operator if you want to check whether two numeric values are the same as here appreciate that the values true and false are not strings of four in five separate characters they have their own status as values and together these specific two values comprise their own data class or type you can think of these two values as being the only two animals of one species being a type of data as the character symbols in our are called strings this type of data also has its own name and is called the boolean type of value so the values true and false are the two boolean values let's move on to the second operator the opposite relational operator namely that of inequality this one checks whether the two objects are not the same if they are not the same then the true value is returned if they are the same though then false is returned so in the evaluation of the following two lines we expect the exact opposite values namely in the first one the value true since the inequality of the two strings is indeed true and the other way around for the second line of code now these operators can be used for comparing or run to values for instance you can use the equality and inequality operators for comparing two character vectors pairwise let's see an example of how this works I created two different vectors here and assign them to the variables name underscore one and name underscore two if I use the Equality operator the two vectors are compared are compared using their indices namely the positions of the strings within each vector the first string in names underscore one will could be compared with the first string in names underscore two the strings in the second position of both vectors we saw will also be compared for equality and so on and so forth the result is now a vector of boolean values where the index of the vector of this retell parent vector maps to the boolean values of its comparison namely the first member of the vector false is the result of comparing for equality the string election draws from names underscore one and ningke's and Nick four names underscore two the second value true is for comparing the strings in the second position of the two vectors assets may just mentioned namely the two identical ones Georgia in terms of their content moreover you can compare a character string with the whole vector of strings the comparisons are done pairwise again but this time the one side of the comparison always includes the string in this line of code what's compared is the string alexandros with each member of names underscore two a third member of names underscores too as you see is equal to Alexander's and that is why the third member of their tenth effect vector is true the last case we're going to see is when the two sides of comparison are vectors with different sizes and the pairwise comparisons are not done in a onetoone correspondence some members of the bigger vector are not compared with new members of the other side however the pairwise comparisons are done but this time the comparison starts all over for the smaller vector let's see this example I renamed the vectors name underscore one and name names underscore two into name Santos Co three in name's Andrew score four correspondingly and made one more small change namely I deleted the last two members of names underscore one Zaheer and Ibrahim when the pairwise equality comparisons are done the prey last comparison for Zahir is done with the first member of name Santos code three namely with Alex honors since there are no new members names underscore three and that is why it starts all over four names under school three for Jim of names underscore for the comparison is done with the second member of names and score three Georgia so this might not be a desirable feature if you compare your language data since you care whether the vectors you want to compare have the same size and there are other ways for remedying this short cam of the relational operators as you will learn later now the last and crucial thing to note is that internally our stores boolean values is two numbers 0 & 1 0 corresponds to the false boolean value and 1 to true what this means is that when you see the value true you would rather think of it as the number one and the number 0 for the value false let's see why this would be useful for you since the vector of boolean values returned from the comparisons of name Sanskar 1 and name some score 2 are internally represented as a vector of ones and zeros you could sum all these zeros and ones of that vector and you will find the number of pairwise comparisons done with a quality operator for names underscore one in nimes underscore two that have identical strings since false values are simply translated to zeros when you would create the sum of all these internally represented numbers of the retained vector of boolean values they would not contribute anything to the sum of these internal numerical values let's go ahead and find the sum of internal numbers not represent internally the boolean values you can use the sum function that takes all the numerical values of a vector it gives its some in our case it recognizes that the boolean values are translated as numbers and so it proceeds and takes their sum that is why it outputs a number number four which means that the two vectors have identical strings and four in four different positions as you can see I use nested code whereby the relational statement is placed within the sum function which means that the function sum will take as its input the vector of boolean values let's try it to check with the number of times a specific string that we are interested in is identified with any of the strings of names underscore one recall that this is the case of comparing pairwise a single string with each member of a character vector here the sum function outputs one and that means that there is only one successful pairwise comparison for equality let's try the same for the inequality operator as you can see by placing the inequality operator in the same place I get three the number of the rest of the pairwise comparisons when the two members of the two vectors are not equal recall that the size of the two vectors is seven let's check now the inequality comparison between a string at a vector as expected again the number is six that's it for now last time you were introduced to the concept of a boolean value into how a boolean value is interpreted in the context of comparing two numbers two strings and two vectors for equality or inequality you also learned what happens under the hood when it comes to comparing unequal in size vectors the question now is how does this relate to sub setting values from a vector will hang on in there before you attempt to answer this question since you need to learn a bit more about the rest relational operators in this video so the next complementary relational operators are the greater than and less than operators let's have a look at them when it comes to numbers things are pretty easy for instance here I check whether 4 is greater than 5 and sure enough I get the false boolean value back on the contrary when I check whether 5 is greater than 4 I get true if I change the greater than 2 the less than operator I get the exact opposite results as expected as you can see here if you compare two strings with the less than operator our checks the alphabetical order of the initial letters of the two strings in this case a from Aleksandras precedes tea from tantos and we get the true value back so this greater than and less than operators are not such useful operators for comparing two strings after all if you think about it the last two relational operators are the less than or equal to and the greater than or equal to operators this mainly applied to numbers in a short while you'll be able to appreciate their usefulness especially when you will learn how to subset vectors with the help of relational operators so as expected for indeed is less than or equal to 5 and 5 and 4 is definitely not greater than or equal to 5 the same applies to strings but as you saw a minute ago our son is done in terms of order in the alphabet so in the first case since a definitely precedes T we still get true whereas in the second case the opposite apart from the simple relational operators assigned specifically for comparing two objects are allows more complex relational operators that combine more than one of the simpler relational operators that you already saw the first one is the so called element wise logical or operator signified with a vertical bar let's go directly to an example with the GLC underscore l1 vector of the GLC dot sample package first you need to load the package as always before you use the GLC underscore l1 vector recall that GLC underscore l1 is a vector with the first language profiles of learners of Greek as a second language assume that you want to check which of the learners in jillsy underscore l1 have either Albanian or Russian as their first language this translates to two different comparisons combined with the or operator the first on the Left checks whether each member of jillsy underscore L 1 is equal to Albanian whereas the second on the right checks for equality comparison 4 of each member of jillsy underscore l1 with Russian in the middle of this complex statement is the or operator and the whole can be thought of as the following instruction give me back which of the learners are either speakers of Albanian or Russian the result will be a vector with boolean values depending on whether each of the members satisfies either of the two conditions for instance the first speaker does not have Russian or Albanians here first language where is the second one does let's head to the second complex relational operator the elementwise end operator the end operator returns a boolean vector where the true values represent members that satisfy both conditions on the right and the left side in the context of the previous statement if we replace the vertical bar that stands for or with a ampersand that signifies the end operator it is impossible to take a single true value in the retaining boolean value vector since no member could be both Albanian and Russian the end operator makes much more sense for Strings when it comes to using them for subsetting more complex objects such as data frames as you'll see in the near future for now for using end it makes sense only for numeric vectors let's see what I mean by this with an example on GLC underscore part one I remind you that the vector jillsy underscore part one store's listening task scores of the same 100 students of Greek as a second language let's see which of the students got a score less than 14 and more than 10 if you would like to see which of the students has less than 12 but not 10 you can use a combination of the existing operators for inequality and less than as in the code here along with the logical end essentially the conditions on both sides of the logical end are checked which means that when each member of chilly underscore part 1 is less than 12 and also is not equal to 10 then in the new vector a true value is recorded and the false wall and false value otherwise now it's worth noting that you could add one more condition in the previous complex expression as in this code Chang where true values are turning they are returned in the resulting boolean vector for members of GLC underscore part 1 that are less than 12 they are not equal to 10 and they are also greater than 5 recall that by a boolean vector I refer to a vector that solely consists of true and false values so the resulting boolean vector reflects whether the members of a vector satisfy the conditions of a complex expression ok now how do we use this knowledge in subsetting vectors well if we nest these complex expressions within the subsetting operators namely the square brackets then the retained or retrieved values will only be the members of the vector that map to the true values of the boolean vector let's interact what I mean by that let's take the simple expression with the less than operator if I put this expression within the square brackets then the output will be a vector with those values of the GLC underscore part 1 vector that satisfy the condition as you can see here from the retrieved vector similarly if I put within the square brackets the more complex expression with the logical end operator that we saw a minute ago repeated here then I get the values that satisfy both conditions let's try out the logical order this time in this case those members of jillsy underscore part 1 will be retrieved that are either less than 10 or more than 12 as you can see our has a very powerful mechanism in retrieving vectors values by allowing you to express for the values you want to retrieve as complex conditions as you like as we move to more complex data structures ours subsetting mechanism becomes even more important in preparing your data before you build your first statistical models in this short video you will be presented with the last way of subsetting vectors that of using character vectors as selection criterion let's see what I mean by that sometimes you may need to create a character vector whose members have tags or names attached to them that signify an attribute or feature for instance you may have a vector with the first language profiles of some speakers and you may want to attach the name of the language family that each of the languages belong to let's create such a short vector that will serve our purposes and name it a l1 underscore profiles l1 underscore profiles has the names of eight languages some of them pretty common in Europe such as Greek and German and some others as exotic as the Nigerian Congo languages Vanda and jewel for assigning a name to each member of l1 underscore profiles that represents the feature offenders you may use one of the following two ways depending on what you want to do next the first way is to use the names function what this says is that the vector with the language families of each language of l1 underscore profiles on the right of the arrow assignment operator is taking its place as a named vector attached to each member of the l1 underscore profiles vector separately let's check now how the resulting vector looks like as you can see the vector l1 underscore profiles has the language family name on top of each language what this means is that the vector is the same as earlier but now additionally it contains some more information about its members in other words the language families of the languages in l1 underscore profiles are considered metadata let's move on to the second way of creating a named vector for that I will be using the same vector but now stored under the variable name l1 underscore profiles underscore 2 to leave l1 underscore profiles and chains and work later with that now the second way is to use the set names function this function takes the l1 underscore profiles underscore two as its first argument and a vector with the names as its second argument the names being the language family names set names outputs a named character vector while it keeps the original vector l1 underscore profiles underscore two intact this means that unlike the names function that attaches the names directly 121 underscore profiles with set names you need to attach to assign the output separately to a new variable I chose the variable name alone underscore profiles underscore named here as a as a result you now have two vectors the initial unnamed vector l1 underscore profiles underscore two and the named vector l1 underscore profiles underscore named so if you want to give both vectors they are named and the named one you can use the set names function otherwise if you simply need to create a named correct named character vector out of an unnamed one use the first way with the names function so far with creating named character vectors let's head on to learn how to subset a named character vector for doing this I will choose the work with the l1 underscore profiles vector I created earlier although I could do the exact same things with l1 underscore profiles underscore named vector the reason why named character vectors can be useful is that you may subset members of a character vector based on their own they're attached named attribute in the case of l1 underscore profiles you may want to subset languages that belong to a specific language family for doing this you can use a character vector with language family names within the square brackets operator for instance for picking the first indoeuropean language you insert the character vector with a string indoeuropean as its member within the square brackets notice that such a vector does not return all languages of l1 the underscore that belonged to the indoeuropean language family but only the first one the position of the languages in l1 underscore profiles does not play a role you can subset l1 underscore profiles for other language families without caring about the position the respective languages are placed in l1 underscore profiles moreover you don't have to care about the positions of the members within the sub setting vector as you can see in l1 our score profiles the Turkic language Turkish is placed after the japonic language of Okinawan okay it's just mentioned so far the sub setting does not result to all languages of a language family in other words the character vector does not function as a selection criterion in the same way a conditional statement does for doing that namely for sub setting all indoeuropean languages for instance you could use the familiar by now conditional operator of equality as expected this line of code returns those languages whose name is into European let's see what happens under the hood the quality operator checks whether each of the names of l1 underscore profiles is equal to the string in the European for each comparison it outputs a true or false value the result of all comparisons is a logical vector that contains true and false values the job of the sub setting square bracket operator is to give back those members of l1 underscore profiles that are in the same position with the true values of the logical operators retained by the evaluated relational statement of equality in other words it outputs those members who is assigned name is into European for sub setting both indoeuropean and japonic languages you can use the logical or signified by the vertical vertical bar as demonstrated in the previous tutorial lastly you can obtain the same result with the in operator that you haven't seen until now the in operator checks whether each of the members vector on its left side belongs to the vector on its right in return it's a logical value for each pair of membership checking let's have a look at the retained logical vector the first false value results from checking whether Niger Congo belongs to the vector that contains the language families that we would like to select namely into European and japonic the next is true since the second member of l1 and the score profiles is assigned the name into European that belongs to the vector on the right of the in operator moving one step forward if you embed the statement within the square brackets the true values of the returned logical vector become now the selection criteria for the members of l1 underscore profiles so that's it for now don't forget to freeze the video on this slide in this video it's your turn to gain some handson experience by solving a few subsetting code exercises I admit that the three code exercises I prepared for you may be a bit challenging but I can assure you that if you follow the previous tutorials you have nothing to fear so the initial setting of the data to work on in the exercises is the following suppose you have three vectors whose members describe three features of a group of 50 speakers the first vector has recorded response times from an online conversation experiment for that these 50 speakers participated in the second vector has their scores on a language proficiency test and the third vector has their first languages for constructing the specific scenario I'm going to take advantage of the vectors in the GLC the sample package the first thing we need to do is to load the package ill see the sample with the library function as usual for preparing the first vector I choose the R norm function to create a simple random sample of 50 numbers that supposedly represent response times and follows a normal distribution with a mean of 5 and a standard deviation of 1.5 these numbers are supposed to represent response times in terms of seconds here I also round the numbers of the vector to two digits after the decimal point with the round function after completing the first tutorials that introduce the basic so far I will visit our norm and all the concepts related to the most commonly used probability distributions for language data analysis and explain them from scratch so no worries if you did not understand exactly what I just said for now the important thing to note is that the resulting vector has 50 numbers with a mean of 5 seconds and most of the data are around around this number around 5 seconds with an average spread of 1.5 seconds now each time you run the code of this last line you get a different simple random sample from the same distribution which means that if you run it now on your console you will get a different vector of numbers but always with a mean of five and an SD of 1.5 in order to work with the exact same vector I just created go ahead to the link in the description below and after you visit it copy the vectors the vector of numbers you see there paste it on your art studio console and assign it to the variable x underscore sample for creating the second vector you are going to extract the first 15 members of the GLC underscore part one vector which I stored here as test underscore scorers underscore sample we are almost ready to go we need to create the third vector now and we are going to do that by extracting the first 50 l ones from the jillsy underscore L 1 vector and name the vector l1 underscore sample now let's get down to the exercises notice that you you now have three different vectors whose members encode three features for 50 people in the exact same position meaning that the first member of all three vectors are the test score the response time and the first language of one in the same specific speaker the same holds for the second members of all vectors and so on in some sense these vectors could be part of a single threedimensional data unit since they all describe three different aspects of these 50 people that is why as you will see in the near future table like or spreadsheet like objects that comprise of rows and cones are really useful for encoding language language data information and you can do that with data frames in R for the time being I'm going to say at the exercises of this video let's get on to the first one here you are asked to subset the L ones for the people who have score more than 13 and response time less than four seconds lastly you're asked to find how many of these extract these figures are as a hint for completing the exercise you may subset one vector by using another vector within the square brackets since remember the data of all vectors in the same position mapped to the same individual pay attention to the formulation of the exercise it uses the conjunction end twice which means that both conditions must be satisfied the second exercise asks you to return the L ones of the speakers with a response time more than 5.5 seconds or those that have response time less than 4.5 seconds notice that this time you need to choose the set of L ones that either satisfy the first or the second conditions the or here is not exclusive which means that the vector with the desired outcome includes both the L ones of people who had a response time more than 5.5 seconds in the L ones of the people who had response time a time less than 4.5 seconds in the last exercise you need to return the scores of the speakers that have response time greater or less than half standard deviation or SD away from the mean and Albanian as their l1 recall that the SD of times underscore sample is 1.5 seconds this exercise is a bit more complicated to solve on the previous ones for completing it you need to think in terms of preparing a stepwise plan the first step is to find how many seconds equals greater or less than half an SD away from the mean of five seconds the second step is to implement the or conjunction for comparing the members of x underscore sample with the specific two numbers that you'll have that you will have found in the previous step the third step is to implement the end part of the exercise namely to choose only the l1 speakers of Albanian so I'm looking forward to receiving your answers or any question that may have come up in the comment section below I will come back to the solution of the exercises in the next video since by now you already familiarize yourselves with a basic so far it's about time to start thinking of how you can have our find specific files in your machines file system and manipulate them so that in the second step it will be able to import these files as appropriate our objects meaning that it will take these files and then convert or transform them into objects that belong to one of ours data types such as character vectors or objects of a more complex data type such as data frames that we will see in later videos but before being able to import files into our it's essential to understand the concepts of a file system and a file path and also to navigate your file system with some basic art functions and that is what you are going to learn in this video let's start off with some basics and break down the concept of a file system first a file system is a set of files and folders of your machine that respects a certain hierarchical structure and that you come across every day when you open and work on your computer all operating systems have graphical user interfaces that represent folders or directories as envelope icons that you can double click on them and see their contents by the way I use the terms directory and folder interchangeably since both folders and directories essentially mean the same thing they are simply meant to contain one or more files or other folders the folders and the files that live inside a specific folder can be thought of as nodes of a tree is the one that you see here where the folders are colored colored orange and the white colored nodes underneath them are the files that you are used to see when you doubleclick on a folder files are leaves of the tree meaning that there is no way that you can place any file inside them or else they lead to a dead end the tree that you see right now is also called a file hierarchy and is a valid representation of a part of a hypothetical file system three representations like this one reflect the hierarchical structure of the files and folders in your machine of course the whole file system is much more complex since it includes a big number of branches and has many more files and folders that make its III representation much harder to display on a single slide that is why I simply omitted them and replace them with the three dots so this tree then is a partial representation of the file system a special place on the tree is its top node also called the root folder and is always signified with a forward slash the second important concept that you need to understand is that of a file path a file path is a description of a path that reaches a specific node or branch of the tree from any other place on the tree knowing how to traverse the file system in R is important since it helps us signify the path from and to any specific location on the file system that are should follow in order to find a specific file and read it so in other words through file paths you give our directions edge to where to find a file in your file system let's have a look at two paths the first path starting off from the root folder goes all the way down to sub underscore nesting underscored fear of through testing underscore deer and sub and ur score testing underscore dr1 and then ends up at this sub underscore testing underscore deer following the second path here you start from the root directory again and then through the folders testing underscore deer and sub done the score testing underscore dr1 you reached the place of the file task and score file 5 now how do you indicate a path to a specific folder or file in R or in any other programming language for that matter there are two ways of doing that through describing the path starting from the uppermost node of the tree the root folder or through describe it's relative to a different location on the tree and not the root folder the first way is implemented with an absolute path and the second one with a relative path so for writing down the absolute path leading to SAP underscore testing underscore d2 you would first need to add the root folder that is always signified with the first forward slash then the folder that is within it while the rest of the folders of the path that lead to stop on his Core testing underscore tier two are separated with more forward slashes notice the two different uses of the forward slash that is the first use in the beginning of the of the absolute path that denotes the root folder and the second use for the noting is separator between the folders for understanding what a relative path is it is better to first answer a very sensible question that a novice our user may have what does it mean to give directions to our when I actually don't know where it's starting point is is it always the root folder or some other place in other words you would need to know where the actual working directory of far is throughout your session or else which place of your filesystem are has my immediate access to let's head to the art studio console and find that out in our you can find the current working directory with the get WD function the returned output is a string that shows the actual folder in the file system whose files are has immediate access to the current working directory as you can see is the folder sub underscore testing underscore dr2 folder so they returned out which is actually in absolute path now let's get back to the second type of paths the relative paths relative paths are passed to specific folders or files written relatively to some location on the filesystem other than the root folder as I just said so you could define a path to a file relative to your current working directory let's have a look at a couple of relative paths on the tree that you saw let's assume that your current working directory is the SAP underscore testing underscore dr2 folder and you would like to describe the relative path to the file test underscore file file in order to do that you simply follow the structure of the tree you first need to go up one level and find the branch SAP runs Core testing underscore dr1 and then go down again to find the file test underscore file 5 the notation for going one level up is a double dot using a double dot in a path automatically transfers you to the folder a bowl namely namely to SAP underscore testing underscore dr1 then you again have to use the forward slash to indicate the next step to follow in the path since you already reach the SAP underscore testing underscore zero one folder the only step that remains is to go down to test underscore file 5 and you do that last last step by simply writing down the name of the file you want to reach let's take a second example suppose you are again at the same working directory as previously but now you need to go to test underscore file too this time you know that you need to go to levels up first through a SAP runs core testing underscore dr1 then through testing underscore do and then one level down to test underscore file to from the previous example you already know how to write down the first step going up and no surprise you need that here too the second step is no different from the first one though which means that I need the double dot again the last step is to go one level down after the last forward slash and I simply write down the name of the file I want to reach namely as test underscore file lets get down to practice now and try to change our current working directory to other locations within our tree using absolute and relative paths to make things easier for you I created the files and folders of the tree you see within my file system and I suggest you also create a file structure similar to our tree within a convenient place in your files them so that you can follow along the code of this tutorial as you saw earlier by using the get WD function we found out that the current working directory is the one we've been using as a starting point for the relative paths examples in order to change the current working working directory you need to use the set WD function the argument that this function takes is a string with the path to a location that you would like your new working directory to be so let's say you would like your new working directory to be testing underscore Deere which means that you would need to go to levels up in the hierarchy for this happen as you know by now you should place two double dots in a row separated by the forward slash that signifies the change in location now let's check out whether our new working directory is where we want it to be with get WD okay good notice that for setting a working directory you need to specify a path to a directory as its name says and not a file if file is not a location that contains other files and cannot be a working directory let's change our current working directory back to the previous location to levels down that means simply that you write down sequentially the folders underneath one after the other and if you want to check out the effect of the change you made you can use the get WD function again for setting your new working directory using an absolute path you simply need to write down all the folders starting from the root folder down to the one you're interested in so for setting the testing underscore D folder as the working directory I would have to write down the following path as the argument to the file to the function set WD the next step for you is to be able to programmatically ask for information related to the working directory for instance for listing the files and folders of your working directory you can use the list dot files function you can also list the contents of a different folder on the tree without change your working directory by simply using relative paths for instance let's say you would like to see what the contents of SAP underscore testing underscore dear one is to do that I write the string with a relative path of the folder I would like to checkins Condon's going one step down means to simply include the name of the folder sup underscore testing underscore tier one is the argument to list dot files function as I do here if you only need to see which folders your working directory has ignoring the files in it you list them with a list deer's function here as expected the only folder included in testing underscore dear he is sup underscore testing underscore dear one check that out on the tree that we saw earlier the output is a character vector whose members are the paths of the folders it contains notice that the first member of the return vector is a single dot a single dot represents the current working directory you don't need to know more about the single dot since it's related to the way that the file system is handled internally for now make sure to interpret the single dot in the beginning of a path as the current working directory relative to which the rest of the path can be described let's move on to asking for information about specific files within a folder and let's remind ourselves once more the contents of the working directory with the list dot files function now with the file dot info function you can ask for information about specific files as I do here with the test underscore file 6 file the output includes lots of useful information let's go ahead and see them one by here on the size indicates the file size and bytes apparently since I created empty files for the purpose of the video test underscore file 6 is empty as high and has size of 0 there is dear column indicates whether it's a folder or a file we got four since it's not a folder the mode is octal is an octal number that indicates the file permissions for all potential users this number specification has its roots to the UNIX operating system and the way that the files have been treated historically in UNIX based systems I suggest you go ahead and look up for the set for how to set file permissions and if you are interested especially if you are working on the team will share the same computer or network of computers the EM time signifies the last modified time stamp meaning the last point in time that the file was modified the seat time indicates the time stamp that the file was created while the eighttime signifies the last time it was opened the last four columns describe information about the owner of the file the group the file belongs to and as said just a minute ago it applies to shared accounts or computer networks hi there I hope you're fine and enjoy the videos of the playlist so far I haven't posted a new video for a while since I was preparing the animation of this video based on this new astonishing Python animation package called money I'm pretty excited with my name and the animation quality it provides and I hope you share this excitement with me let's see and of course any comment or advice for further improvement one on what you see here is more than welcome so let's move on to the meat of this video before moving on to factors and data frames in the next videos I intend here to present the our code solution to the first exercise of the video number 14 it was called subsetting card two vectors practice and more in this first exercise you were asked to subset the L ones of the students in the vector l1 underscore sample and to remind you l1 and the sample is a vector that includes the first 50 members of the GLC underscore part 1 vector who at the same time have scored 13 or more out of 15 in the language proficiency assessment test in the test scores are stored in the test underscore scorers vectors as you'll see in a minute and also have had a response time less than 4 seconds based on the injuries of the vector x underscore sample recall that x underscore sample is a vector with synthetic data meaning that the injuries of x underscore sample did not come from real recorded data but they were created for the purpose of these videos with the are norm function so x anushka sample contains a simple random sample of 50 numbers that represent hypothetical response times of a time measured experiment of the same people in the test underscore scores in the l1 underscore sample vector now since each time you create a simple random sample with the are known function naturally you get a different vector with 50 different random numbers if you would like to replicate the exact same response times with this in the earlier video feel free to visit the link in the video description below copy its content paste it on your RCA console and store the result two times underscore sample vector a variable name following the same name link you can also copy the two other relevant vectors l1 underscore sample and test underscore sample and test underscore scored sorry create it in video number 14 and used here and follow directly what I do in this video recall also that times underscore sample follows that the data stored in the time Sanders core sample vector follow a normal distribution with a mean of five and a standard deviation of one point five seconds now I assume that the three vectors are are aligned in terms of their members namely the first member of test underscore scores records a score of a student who has had a response time that is the first member of times underscore sample in the first language of that person is also stored in the first position of L underscore sample and so on going back to the exercise the last step for completing the exercise was to obtain the L ones of the speakers with that performance apparently this last part rings a bell for using this subsetting operator on the l1 underscore sample vector but I suggest we take things one step at a time there are two things that need to simultaneously be satisfied students with scores more than 12 and response times less than four seconds translating these two conditions in our code means you simply add the pieces in place as here what is important to understand here is how our proceeds in executing each of the two statements for the left statement are takes each member of the vector test underscore scores and compares it with the score 12 and this is where the left Bart does and the result will be a vector of logical values as you will see you then the same will happen for time underscore samples members each member will be compared with the number four that stands for four seconds and the result will again be a logical vector you for finding those students with both scores more than 12 and response times less than four seconds our proceeds in the same manner as earlier namely it simply compares the resulting logical vectors of the two separate comparisons and outputs a new logical vector with true values in positions that both logical vectors have true values in them and false otherwise the ampersand or logical and operator serves exactly that purpose namely it compares the results of the first comparison with the results of the second comparison and assigns a true value when only when the pairwise results are both true let's see the contents of the final logical vector directly in our studio console as expected here you can see there's the resulting logical vector but what was actually asked was to retrieve the first languages of the people with these performance and that means you need to think in terms of what you have to do to subset the relevant first languages of the l1 our score sample vector actually you're almost there since you already prepared the logical vector that will function as the picking mechanism within al l underscore sample recall that the three values of the resulting logical vector will be translated internally as once by our and the false values as zeros then the subsetting operator represented by the square brackets as we already know will retrieve the languages on the exact same positions that the logical vector had once in it so let's actually do this last step now you enter the complex statement within the square brackets and there you have it the first languages of the people with score results more than 12 and in response time less than four take a moment to think about what one can do with such powerful subsetting mechanism with a single line of code you can perform now this kind of complex sub settings that serve you choose subgroups of yours objects or of your texts if you're working on corpora that meet very complex and specific criteria so that you can focus on that group and test your hypothesis or build your models for your research that's it for now I hope you liked the animation and helped you real clear out the concept of subjective and of course if you liked the content of these videos don't forget to subscribe to the channel to get notifications when new videos are released see you in the next video
