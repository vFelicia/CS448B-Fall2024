With timestamps:

00:00 - Welcome to our first video on numpy
00:03 - lecture Series this is gonna be an
00:06 - introductory video
00:08 - so let's get started
00:12 - so what is numpy numpy is a library for
00:15 - the Python programming language it's
00:18 - stands for numerical python it was
00:21 - created by Travis oliphan in 2005.
00:24 - it supports large multi-dimensional
00:27 - arrays and mathematical functions to
00:30 - operate on these Aries now the million
00:33 - dollar question is why use numpy when we
00:37 - are able to process arrays with the help
00:39 - of python lists
00:41 - this is because python lists do serve
00:44 - the purpose of arrays but they are too
00:47 - slow to process numpy aims to provide an
00:51 - array object that is more faster than
00:53 - traditional python lists
00:56 - Aries are very frequently used in data
00:59 - science with speech and resources are
01:02 - very important if we have a slow array
01:05 - then it will affect the speed of the
01:09 - program and also increase the time in
01:12 - which the program is executed
01:16 - some of you must be wondering what is
01:19 - data science data science is the branch
01:21 - of computer science that deals with
01:23 - storing using and in analyzing data and
01:27 - deriving information from it
01:29 - now let's move on to our next question
01:32 - why
01:34 - are numpy arrays faster than this
01:38 - let us look at the basic definition of
01:42 - an array
01:43 - anari is a collection of homogeneous
01:46 - data types that are stored in contiguous
01:49 - memory locations
01:51 - this is the definition that we are
01:53 - learning since kindergarten so we all
01:56 - know that Aries are implemented with the
01:58 - help of lists in Python
02:01 - now a python list is a collection of
02:04 - data types stored is in non-contiguous
02:07 - locations so fetching R elements from
02:10 - non-contiguous location takes more time
02:14 - this is the reason why python lists are
02:17 - slower and numpy Aries are about 50
02:21 - times faster than
02:24 - pythonless
02:28 - let's look at the other benefits of
02:31 - numpy
02:32 - it supports efficient manipulations and
02:36 - operations on high-level mathematical
02:38 - functions and multi-dimensional arrays
02:42 - it contains functions related to linear
02:45 - algebra random number capabilities
02:49 - see random number is very important in
02:53 - numpy for creating random distribution
02:57 - plots we will get into it later on
03:01 - it also supports functions related to
03:04 - Fourier transforms or transformations
03:08 - it provides tools for integrating C and
03:12 - C plus plus code
03:14 - Etc
03:15 - in Python
03:17 - and numpy is used mostly for scientific
03:21 - computing
03:23 - now let's move forward to the actual
03:27 - coding part
03:29 - first of all let me teach you how to
03:32 - install numpy on your system here I'm
03:36 - using a Macbook and I have my web
03:40 - installer package already installed so
03:43 - I'm just going to write
03:45 - babe
03:48 - install
03:50 - numpy
03:55 - and hit enter button so I have numpy
03:59 - already installed on on my system so
04:01 - it's showing requirement already
04:03 - satisfied but in your system it will
04:07 - process for some time and download the
04:10 - essential
04:12 - modules
04:14 - now let me just get started with python
04:21 - on three and hit enter button now I need
04:26 - to import numpy so for that I'm going to
04:29 - write import numpy
04:34 - as
04:35 - NP
04:38 - and hit enter
04:43 - now we
04:46 - don't get an output here this is because
04:49 - there is nothing to display or there is
04:52 - no such command now I'm going to create
04:55 - an array ARR equal to
04:59 - NP dot array
05:02 - and I'm going to pass a python list
05:06 - that is one two three four five
05:13 - so I have passed a list you can give any
05:16 - value that doesn't matter now I've
05:19 - successfully created an array now I want
05:22 - to print this array for that I need to
05:25 - write
05:25 - print
05:27 - bracket
05:28 - ARR and hit enter
05:32 - so we have successfully created and
05:35 - displayed an array
05:41 - now some of You Must Be Wondering Why
05:44 - did we import
05:45 - numpy or numpy SNP now let's see if we
05:50 - import it directly without giving it a
05:55 - nickname or a pseudo name so I'll just
05:58 - go back to Python 3 Type Python 3 and
06:02 - hit enter and now I'll import numpy
06:09 - by writing import
06:11 - numpy
06:13 - hitting enter and then creating an array
06:15 - again
06:17 - that is ARR or array name equals to
06:21 - numpy dot array and passing a python
06:25 - list to it
06:27 - so now I'm gonna print this array by
06:30 - writing print
06:32 - bracket ARR and hit enter now you can do
06:37 - this way or or you can do it the other
06:40 - way it doesn't matter but in large
06:42 - program you may need a pseudo name or a
06:46 - nickname or a reference
06:48 - so that while writing
06:52 - last fragments of code you can reduce
06:57 - hello welcome back to our course on
06:59 - numpy
07:01 - today we are gonna learn about
07:03 - n-dimensional Aries so let's get started
07:07 - so our first and foremost question is
07:10 - what is ND array so according to
07:15 - numpy.org I'm Andy array is a usually
07:19 - fixed sized monthly dimensional
07:22 - container of items of the same type and
07:25 - size
07:26 - the number of dimensions and items in an
07:29 - array is defined by its shape which is a
07:32 - tuple of n non-negative integers that
07:36 - specify the sizes of each Dimension the
07:39 - type of items in the array is specified
07:42 - by a separate data type object called as
07:45 - T-Type one of which is associated with
07:48 - each ND array so this is more of a
07:52 - complicated definition so in simpler
07:55 - words we know that numpy is mostly used
07:59 - to work with Aries the array object is
08:02 - numpy is called as ndra we create a
08:06 - numpy ND Ira object by using the array
08:10 - function
08:11 - so the thing is
08:12 - ND array is nothing but just n
08:15 - dimensional array like one dimension two
08:18 - Dimension three dimension
08:20 - let me just type python
08:24 - 3 and hit enter
08:27 - now I'm going to import
08:30 - numpy so import
08:34 - numpy
08:36 - as
08:37 - NP
08:39 - and hit enter
08:42 - now I'm going to create
08:45 - an array
08:47 - that is
08:48 - ARR or Avenue
08:51 - NP dot array
08:54 - and we are going to pass
08:56 - a python list
08:59 - here I'm taking the values one two three
09:02 - but you can take any value you want to
09:07 - so I have
09:09 - created an array I have passed a python
09:13 - list
09:15 - now I'm going to print it so I'm going
09:18 - to write print
09:21 - aaroni
09:23 - or ARR
09:25 - and now I'm going to hit enter so I got
09:28 - my array now
09:31 - let us print the type of array
09:35 - so I have told you earlier that
09:39 - that array object in numpy is indiary
09:43 - now let's verify it by printing
09:47 - the type so print
09:49 - type and array name so we can see that
09:53 - we got output as numpy dot ND array now
10:00 - type function is a built-in python
10:03 - function that tells us the type of the
10:06 - object passed to it
10:07 - like in previous code it shows that ARR
10:11 - or array name is numpy dot ND array type
10:16 - now some of you must be wondering why do
10:19 - I always pass python lists as input
10:24 - so uh in general to create an ND array
10:28 - we can pass a list double or any array
10:31 - like object into the array method it
10:34 - will be converted to ndra so now I'm
10:38 - going to show you an example where I'm
10:40 - going to pass a python Tuple so life is
10:43 - going as usual
10:45 - let me just write import numpy as NP and
10:49 - hit enter now array name is equal to
10:53 - numpy dot array but this time I'm going
10:56 - to pass a tuple
10:58 - so now I'm I'm going to print
11:01 - so you can see that it is in a list
11:05 - format
11:06 - but when I print the type
11:09 - and pass array name
11:12 - it shows numpy dot in the array now
11:16 - let's talk more about arrays so
11:18 - generally we have an n-dimensional array
11:21 - where n can take the values 0 1 2 3
11:26 - up to n so let's start with Zero
11:29 - Dimensional arrays
11:31 - so Zero Dimensional arrays are nothing
11:33 - but scalars
11:35 - for example the numbers 1 2 3 4 each of
11:40 - them represent a scalar or a Zero
11:43 - Dimensional array now an array that has
11:47 - Zero Dimensional arrays as its elements
11:50 - is called as a unidimensional or one the
11:53 - array
11:54 - for example I write bracket and inside I
11:58 - gives the values 1 to 3 4 so one
12:01 - dimensional array has Zero Dimensional
12:04 - arrays as its elements
12:08 - similarly a two-dimensional array has
12:12 - one dimensional arrays as its elements a
12:15 - three-dimensional array has 2D arrays or
12:19 - matrices as its elements
12:21 - an n-dimensional arrays have n minus one
12:26 - dimensional R is as its elements so
12:30 - two-dimensional arrays are called as
12:33 - second order tensors
12:35 - three-dimensional arrays are called as
12:38 - third order tensors and
12:41 - generally an N dimensional array is
12:45 - called as nth author tensor but the most
12:49 - basic and most common arrays that we use
12:53 - in our daily life are one dimensional
12:56 - artists higher dimensional arrays find
12:59 - more relevance in fields such as machine
13:02 - learning and artificial intelligence now
13:06 - let's Implement these arrays
13:12 - so guys I have opened my terminal
13:16 - now I'm just going to type
13:19 - Python 3
13:23 - and hit enter I'm going to import numpy
13:27 - as NP
13:29 - hit enter and then I'm going to write
13:33 - arr0
13:35 - is equal to
13:37 - NP dot array
13:42 - in in bracket this time I'm not going to
13:45 - pass
13:47 - a list I'm going to pass a scale because
13:50 - this is a Zero Dimensional array now I'm
13:52 - going to print
13:54 - err
13:58 - or zero
14:00 - and hit
14:01 - enter
14:04 - so I got the result as 21 note that this
14:08 - is a scalar
14:09 - and not
14:12 - in list or we can say it is not in list
14:16 - format now I'm going to create a
14:19 - one-dimensional array ARR one
14:22 - is equal to num
14:24 - P or NP dot r a
14:27 - and this time I'm going to pass a list
14:35 - now I'm going to hit enter
14:42 - so array has been created now I'm going
14:44 - to print it
14:46 - so I'm going to right print ARR
14:50 - 1
14:52 - close the bracket and hit enter
14:56 - now
14:57 - let's move on
14:59 - to
15:01 - a 2d array
15:03 - so I'm going to write
15:05 - ARR
15:08 - to
15:11 - is equal to NP
15:14 - dot array
15:17 - please note that this time I'm going to
15:20 - pass one dimensional arrays as it's
15:25 - element so I'm
15:27 - going to write square bracket
15:33 - square bracket again
15:36 - and one two three four
15:40 - sorry you can't take anything one two
15:42 - five
15:43 - and comma
15:45 - and I have to pass one more list because
15:47 - basically its elements are one
15:50 - dimensional app is
15:56 - now let me just hit enter
15:59 - and print two-dimensional array
16:09 - sorry I have to print error off
16:12 - to not the evaluate index 2.
16:17 - so please take care you can also make
16:19 - this mistake
16:21 - so now
16:25 - print it added successfully
16:28 - so let us now create a three-dimensional
16:31 - array
16:33 - which is third order tensor so AR out of
16:37 - three is equal to
16:40 - NP dot array
16:43 - and this time we are going to pass two
16:47 - dimensional arrays as its elements
16:52 - so square bracket square bracket and one
16:55 - more square bracket and pass
16:59 - the elements
17:13 - so I have passed one
17:16 - 2D array now I'm going to pass one more
17:40 - so this three-dimensional array has two
17:43 - two-dimensional arrays at its elements
17:46 - so 3D array has been created now we have
17:49 - to print it by using print and in
17:52 - bracket we have to write ARR of 3 and
17:56 - hit enter
17:59 - so we have successfully printed a 3D
18:03 - array
18:05 - now we have seen how to create a
18:08 - one-dimensional array a two-dimensional
18:10 - array and a three-dimensional array now
18:13 - I'm giving you an assignment
18:17 - create
18:19 - a
18:22 - four-dimensional array
18:27 - you have to follow the same procedure
18:29 - you just need to pass
18:33 - 3D arrays assets elements
18:38 - in today's lecture we covered and
18:41 - dimensional arrays ndra use of type
18:45 - function
18:48 - one dimensional array Zero Dimensional
18:50 - array two dimensional array three
18:52 - dimensional array how to create them and
18:57 - we have also given you an assignment
18:59 - that's all for today
19:02 - this video is brought to you by
19:05 - programming knowledge please like
19:07 - comment share subscribe and hit the Bell
19:10 - button for updates and stay tuned for
19:14 - next lecture bye
19:17 - hi guys welcome back to our course on
19:19 - numpy in our last lecture we covered
19:23 - n-dimensional arrays and today we are
19:26 - gonna learn about array indexing so
19:29 - let's get started
19:31 - so the first question that arises in our
19:34 - mind is what is array indexing so our
19:38 - indexing is nothing
19:40 - but
19:42 - accessing an array element now how can
19:46 - we access an array element the answer is
19:49 - pretty simple by referring to its index
19:52 - number
19:52 - indexes start from 0
19:55 - the first element is stored at the index
19:58 - 0 the second element is stored at index
20:03 - 1. and so on that end element is stored
20:08 - as index
20:10 - n minus 1.
20:14 - now let's see how can we do indexing
20:18 - in arrays of different dimension
20:22 - so let's first access
20:24 - array element for a 1D array so we just
20:28 - simply need to write print array name
20:30 - and we have to write the index that is a
20:33 - in 2D array it will be print
20:38 - a comma B because we have two parameters
20:42 - row and column similarly in a 3D array
20:47 - which is a third order tensor we need to
20:50 - pass three parameters and in general in
20:54 - an ND array or n dimensional array we
20:58 - have to pass n
21:00 - parameters
21:02 - as array index to print or access the
21:06 - element
21:07 - now let's move on to the coding part
21:12 - so I have opened my terminal let me just
21:15 - write python3 and hit enter now import
21:20 - numpy as NP hit enter
21:25 - and now I'm gonna create a 1D array
21:31 - so let's start
21:33 - with 1D array
21:38 - so ARR or array name one
21:42 - is equal to
21:44 - NP dot array and I'm gonna pass a python
21:49 - list to it
21:50 - so let it be 2 comma 3 comma 1 comma 5
21:54 - comma 3 comma 2 comma six
21:59 - and hit enter so we have successfully
22:03 - created a 1D array now let's print
22:08 - an element or axis an element so I'm
22:11 - gonna exist element at index 0
22:15 - but I made an error instead of passing
22:18 - Error 1 I passed ARR which is not
22:21 - defined so I'm gonna do it again
22:25 - print
22:26 - arr1 of 0 and the last element
22:31 - ARR one
22:33 - six so element at first index is 2 and
22:39 - the element at 6 index
22:42 - is
22:44 - six
22:46 - so I can also perform
22:48 - algebraic operations while printing let
22:52 - me just show you
22:54 - so I'm gonna write print err one
22:58 - index five
23:00 - into ARR one and index
23:05 - Let It Be
23:06 - 2 so it will show the multiplication
23:11 - of elements as Deeds to index so element
23:15 - at index 5 is
23:20 - 2 and element at index 2 is 1 should it
23:25 - display the result to similarly we can
23:28 - perform subtraction
23:31 - so
23:32 - arr1 element at index 3 minus element at
23:38 - index one sorry I made an error again
23:41 - let me just correct it
23:44 - so the answer is 2.
23:47 - so let's move on
23:51 - to a 2d array
23:53 - let me just create a 2d array
24:02 - so I'm gonna write arr2 is equal to NP
24:06 - dot array
24:08 - and this time I'm gonna pass
24:17 - 1D array as its elements
24:21 - so let it be 1 comma 2 comma 3 dot comma
24:25 - 4 bracket close five comma six comma
24:28 - seven comma bracket use so I'm gonna
24:31 - print
24:34 - the second
24:36 - element
24:42 - in
24:44 - first
24:46 - in second
24:49 - row
25:00 - so guys am I doing it right
25:10 - I have done it wrong please try to be
25:14 - careful because this is the wrong index
25:17 - I want to access
25:21 - some other element but I have passed
25:23 - some other index now
25:26 - this index 0 comma 1 it represents
25:32 - the first
25:35 - the second element and first row
25:38 - and not the second element in second row
25:41 - so please be careful because you can
25:44 - also do these kind of mistakes
25:47 - and I'm trying to help you Rectify those
25:50 - mistakes
25:52 - so
25:54 - the element that I have actually printed
25:57 - was
26:09 - it was
26:15 - the first element
26:22 - no it was not the first element it was
26:27 - the second element in first row so guys
26:31 - please try to be careful this is the
26:34 - most common mistake that we do while
26:37 - indexing I'm showing you this because I
26:41 - have seen a lot of people
26:43 - making these kind of mistakes even in
26:46 - engineering
26:48 - second air and third year this is a very
26:51 - common mistake so please try to be more
26:54 - careful and write the indexes
26:57 - correctly so second element in second
27:01 - row
27:08 - so I'm gonna pass one one this time and
27:10 - it is six
27:13 - now should we move on to a 3D array
27:17 - let's move on
27:21 - to
27:23 - a 3D array
27:31 - so I'm just gonna create a 3D array
27:45 - come on guys I'm just joking I'm not
27:49 - gonna create a 3D array instead I'm
27:52 - gonna give you an assignment
27:54 - that is
27:56 - create
27:57 - a 3D array yourself we have discussed
28:01 - how to create a 3D array and now you
28:05 - have to create a 3D array and access the
28:09 - first element
28:16 - in 3D array
28:19 - so in today's lecture we covered array
28:24 - indexing indexing in 1D array indexing
28:29 - into the array and I also give you an
28:32 - assignment to do indexing in a 3D array
28:35 - that's all for today this video is
28:38 - brought to you by programming knowledge
28:40 - please like comment share subscribe for
28:45 - updates and stay tuned with us for more
28:47 - lectures bye
28:49 - hi guys welcome back to our course on
28:52 - numpy in our last lecture we covered our
28:55 - indexing and today we are gonna learn
28:58 - about negative indexing and the use of
29:01 - Endive method so let's get started
29:05 - so first of all what is negative
29:08 - indexing so negative indexing
29:11 - in negative indexing we use negative
29:15 - indexes to access array elements from
29:19 - the end
29:20 - let's take an example that we need to
29:23 - print or access the last element of the
29:26 - second row in the given array
29:28 - so index number for elements for second
29:32 - row will be like 1 comma n minus 1 when
29:37 - we are using positive indexing and where
29:40 - we want to access the nth element from
29:43 - the beginning but in case of negative
29:46 - indexing the index number for the second
29:49 - row will be like 1 comma minus n where
29:53 - we want to access the nth element from
29:56 - the last
29:57 - now please note the difference in
29:59 - positive indexing
30:01 - we are accessing nth element from the
30:05 - beginning and we are giving the value 1
30:08 - comma n minus 1 but here we want to
30:12 - access the nth element from the last so
30:15 - we are giving the values 1 comma minus n
30:22 - now let's
30:24 - do negative indexing for this array
30:28 - so here by positive indexing the index
30:33 - of the last element of second row will
30:36 - be 1 comma 4 as is it is the fifth
30:40 - element from the beginning
30:43 - and in general for nth element from the
30:46 - beginning the index number will be row
30:49 - count minus 1 comma n minus 1.
30:53 - and if we do negative indexing the index
30:57 - will be 1 comma minus 1 as it is the
31:01 - first element from the last or the nth
31:04 - element from the last
31:06 - so in general for nth element from the
31:09 - last the index number will be row count
31:12 - minus 1 comma minus n
31:16 - now so let's open them let me just write
31:19 - Python 3 and hit enter
31:23 - now import
31:26 - numpy
31:30 - as NP
31:34 - hit enter
31:40 - let's create
31:42 - a 2d array first
31:49 - so I'm gonna create a 2d array so I'm
31:51 - gonna write
31:53 - arr2 is equal to
31:56 - NP dot array
32:00 - and now
32:01 - since we know that the elements of a 2d
32:05 - array are 1D array so I'm gonna pass
32:09 - to list
32:11 - as its element
32:13 - so let the list element will be one two
32:15 - three four and two four three one
32:19 - close the brackets and hit enter
32:27 - so we have successfully created a 2d
32:30 - array now let's print
32:32 - so I'm gonna write print
32:36 - the second
32:39 - element
32:42 - sorry the second row and the last
32:44 - element
32:50 - so it's gonna be
32:53 - ARR or array name
32:57 - one comma
32:59 - minus 1.
33:07 - because positive indexes
33:10 - start from 0 and negative indexes start
33:13 - from -1
33:15 - so the second row and last element is 1.
33:19 - now let's print
33:24 - the array
33:27 - so we have printed the array and you can
33:29 - see that the second row and last element
33:33 - is
33:36 - 1. now some of you might be wondering
33:39 - can we pass both the values in negative
33:44 - indexes yes we can
33:48 - so for the last row
33:51 - it will be minus 1 and for the last
33:54 - element it will be minus 1. so second
33:58 - row and last element when we have passed
34:01 - both the values as negative is same
34:05 - it's one now let's print the second row
34:09 - and the second last element
34:22 - so I've written the command and now I'm
34:25 - gonna hit enter so as you can see that
34:29 - the second row and the second last
34:30 - element is three
34:32 - now let's do it again by
34:41 - changing the row value now we are gonna
34:45 - print the first row and the second last
34:48 - element
34:49 - so I've written the command and hit
34:52 - enter so the result is 2. as you can see
34:56 - from the array now I'm
34:59 - gonna do it again but this time I'm
35:03 - gonna give negative values
35:08 - so the result is again two
35:13 - this was all
35:15 - about negative array
35:19 - indexing
35:26 - so now I'm gonna give you an assignment
35:29 - that is create a 1D array and access its
35:36 - last
35:39 - element
35:43 - now
35:48 - yeah you have to use positive indexing
35:51 - as well as negative indexing while doing
35:53 - this assignment
36:03 - so now let's move on to our next topic
36:05 - for today that is use of enzyme method
36:11 - so and I method
36:14 - Returns the number of dimensions in an
36:17 - array the syntax is print
36:21 - bracket array name dot ending or first
36:25 - we can store the result in
36:28 - a or any variable like a is equal to
36:33 - rename dot enzyme and then we can print
36:37 - a
36:41 - so let's see an example
36:45 - so I've opened my terminal
36:48 - I'm gonna write python3 and hit enter
36:50 - I'm gonna import
36:52 - numpy as NP
36:56 - hit enter now I'm gonna create arrays so
37:01 - first R is AR 0 is equal to NP dot array
37:08 - bracket
37:10 - I have passed the value 32 and this is a
37:13 - Zero Dimensional array or a scalar now
37:16 - I'm gonna create a 1D array
37:21 - so now I'm gonna create a 2d array
37:42 - so I've created a 2d array now
37:49 - let's move on to the use of ndi method
37:54 - so I'm just gonna write
37:59 - print
38:02 - arr0 dot enzyme so it's gonna give me 0
38:07 - because it's a zero D array similarly
38:12 - to check the dimension of
38:15 - the 1D array I'm gonna write arr1 Dot N
38:20 - dime so it shows result 1.
38:24 - and in the same way when we do it for 2D
38:29 - array
38:30 - it's gonna print the result as 2.
38:46 - so by the use of n die method you can
38:50 - get the dimension for any array it will
38:54 - display the result as the number of
38:57 - Dimensions present in that particular
38:59 - array now the assignment for you is to
39:02 - print
39:04 - the number of dimension
39:11 - for
39:15 - the fourth dimensional array that you
39:18 - created as your the path of your
39:22 - previous assignment
39:35 - so this was all about
39:37 - the use of enzyme function or enzyme
39:42 - method
39:43 - hi guys welcome back to our course on
39:46 - numpy today we are gonna cover array
39:49 - slicing
39:50 - so let's get started
39:52 - so first of all what is array slicing
39:56 - slicing means taking elements from one
39:59 - given index to another index
40:02 - here instead of passing an array index
40:05 - we pass a slice
40:08 - so the syntax is that we pass a starting
40:12 - element and an ending element that is
40:15 - denoted by start and end respectively
40:19 - we can also Define the number of steps
40:21 - we want to take while slicing so we can
40:24 - pass either two parameters start and end
40:28 - or we can pass three parameters that are
40:32 - start and understood
40:36 - so now the question arises what if I
40:39 - ignore or don't pass these three
40:42 - parameters if we don't pass start it is
40:45 - taken as zero if we don't pass end it is
40:49 - taken as the length of array in that
40:51 - Dimension and if we don't pass step it
40:54 - is taken one by default
40:58 - now we can also slice the array using
41:03 - negative indexes
41:06 - so this is a brief introduction to array
41:10 - slicing now let's move on to the coding
41:13 - part
41:15 - so guys
41:16 - let me just import numpy as NP
41:21 - and hit enter
41:23 - now I'm gonna write array name or ARR is
41:28 - equal to NP dot array
41:31 - and now I'm gonna pass a python list to
41:35 - it
41:37 - Let It Be One comma 2 comma three comma
41:39 - five and hit enter
41:45 - now let's slice elements
41:47 - from
41:50 - index
41:53 - one
41:54 - to index
41:57 - 5.
41:59 - sorry here we have indexes
42:02 - from
42:03 - the 0 to 4. that is size -1 so
42:13 - if I pass
42:26 - we're gonna slice elements from index 1
42:29 - to index four
42:31 - and
42:33 - I'm gonna write print array name err and
42:38 - I'm gonna get start as one
42:40 - and and ask for that is the last index
42:44 - and I'm gonna
42:46 - press enter so it displayed
42:50 - two three and four
42:54 - so there's a very important
42:56 - observation to make here
43:02 - so what is that observation
43:08 - we can observe that it has
43:12 - included the value or the element
43:17 - at
43:19 - index
43:21 - one
43:22 - but
43:24 - it has not included
43:28 - the element at index 4
43:32 - so it's not gonna include the value at
43:35 - index 4.
43:38 - so indexing will always
43:41 - neglect
43:43 - the element
43:45 - which is present at end
43:49 - or the parameter that is given
43:53 - so in general
43:55 - when we
43:57 - write
44:05 - array
44:07 - start
44:10 - call it n
44:15 - it will
44:17 - ignore the element
44:22 - at the ending
44:26 - index and it's going to include element
44:30 - at the start index
44:33 - so please keep this in mind because in
44:37 - questions related to Output
44:39 - we can make this kind of sillimistic so
44:42 - it's good to be careful
44:48 - so start will be included in the result
44:50 - while end won't be included in the
44:54 - result
44:58 - now let's see
45:01 - what happens
45:04 - when we don't pass
45:07 - start
45:09 - so I'm gonna write print
45:17 - ARR
45:20 - so array has been printed now I'm gonna
45:24 - give it a slice
45:26 - so I'm gonna print ARR
45:29 - I'm not gonna pass start this time
45:32 - so
45:34 - start is empty and I'm gonna give end as
45:41 - the third index so it should print one
45:45 - two and three
45:49 - as you can see the result is 1 2 and 3.
45:58 - now
46:00 - let's see what happens when we don't
46:03 - pass end
46:06 - so let me just write print
46:12 - array name or ARR and I'm gonna pass
46:15 - start S2
46:18 - and I'm not gonna pass any end
46:22 - let me just hit enter
46:24 - so at second index the value is 3 and
46:29 - since we have not passed an end it will
46:32 - take
46:34 - the size
46:35 - of R in that Dimension that is 5 as end
46:39 - so it's gonna print
46:42 - 3 4 and
46:44 - 5 minus 1 the valued fourth index so
46:49 - it print
46:51 - 3 4 and 5.
46:54 - so here
46:56 - in above examples we did not pass the
47:00 - step size
47:01 - so by default it is taken as
47:05 - 1 as we already discussed
47:12 - now let's do
47:20 - or let's pass step size
47:33 - I'm gonna create a new array that is
47:36 - err1 is equal to NP dot array
47:40 - and I'm gonna pass a list of a bigger
47:43 - size the current list was short in price
47:46 - so if I increase the step size there
47:49 - will be less elements so to exhibit or
47:52 - to display the method of
47:55 - slicing using sip size I have created a
47:59 - new array and I've printed the existing
48:01 - array as well as the newly created array
48:06 - now let's pass
48:08 - step size and do the slicing
48:11 - so for the first array I'm gonna
48:14 - give the start as zero and I'm gonna
48:18 - give end as
48:23 - four and let the step size be equal to
48:28 - 2.
48:30 - so the value at zeroth index is one and
48:33 - at Fourth index is 5 so it should print
48:36 - the elements
48:39 - one
48:41 - and three sorry there was a mistake in
48:43 - the syntax
48:44 - so it shows the in invalid index or
48:48 - sorry invalid syntax
48:51 - so let me just Rectify it and
48:55 - do it again so this time I'm gonna write
48:58 - print ARR
49:04 - um
49:06 - print error
49:09 - one again
49:11 - and let me just
49:14 - write the command again
49:18 - so I'm gonna write ARR
49:21 - 0 4
49:23 - and 2. so the result is 1 and 3.
49:27 - now let's do it for the second array
49:32 - so the start was 0 and the end was eight
49:35 - so it displayed one three five and seven
49:38 - as theoretically expected
49:44 - now we have an observation
49:48 - to make here
49:51 - if we observe carefully
49:54 - the command
49:56 - that we have written have returned
50:02 - every other element
50:07 - from index
50:10 - 0
50:12 - to 4
50:15 - sorry from the index 0
50:19 - to 4
50:21 - for the first array
50:25 - and
50:26 - every other element
50:34 - from index 0 to 8
50:38 - in the second nappy
50:43 - so now let's move on
50:46 - and print
50:49 - every other element
50:52 - in the whole array
50:55 - so let's see how to
50:58 - return or print
51:01 - every other element
51:04 - in the
51:06 - whole array or entire array
51:11 - so I'm gonna write
51:13 - print
51:16 - every name
51:17 - I'm not gonna pass the start
51:20 - or end I'm just gonna pass step size
51:23 - that is 2.
51:26 - I'm gonna close the bracket and hit
51:29 - enter
51:30 - so it has returned every other element
51:32 - in entire array
51:35 - now similarly return every other element
51:38 - in the
51:41 - second array so it shows 1 3 5 7 and 9.
51:46 - so we have
51:52 - returned every other element in the
51:55 - array
51:56 - now let's
51:57 - slice
52:00 - a 2d array
52:06 - so I'm gonna write arr2
52:09 - equal to NP dot array
52:13 - and I'm gonna pass 2 1D arrays as its
52:17 - elements
52:19 - let them be 1 comma 2 comma 3 comma 4
52:22 - and the other one the array will be 1 5
52:26 - 6 7 and 8. sorry this mistaken
52:30 - parenthesis so let me just do it again
52:32 - I've created a 2d array now let me print
52:36 - it
52:38 - so I've printed array now I'm gonna
52:41 - slice
52:44 - so
52:56 - so I'm gonna slice element
52:59 - or elements from
53:03 - index
53:05 - 1
53:06 - 2 index
53:13 - for
53:16 - and of course the index 4 will not be
53:20 - included
53:23 - and in
53:25 - second
53:29 - row
53:34 - so I'm gonna write print
53:37 - ARR or array name and I'm gonna give
53:43 - please be careful here we have to pass
53:45 - the first row and instead of column
53:49 - value we are gonna pass the slice so
53:52 - please be careful
53:56 - so I've passed
54:00 - sorry there was a mistake
54:04 - let me just correct it and
54:17 - and hit enter
54:23 - sorry the array name was written
54:25 - incorrectly so let me just change it to
54:28 - arr2
54:30 - so it has given us the corresponding
54:33 - values that are 6 and 7.
54:38 - now similarly we can pass the row value
54:42 - as a slice and give some column value or
54:46 - we can do both path to row value as a
54:50 - slice on the column value as a slice
54:54 - so similarly we can slice a 3D array and
54:58 - in general we can slice
55:01 - an N dimensional
55:03 - array
55:08 - so there's an assignment for you
55:16 - take
55:19 - create
55:22 - and slice
55:24 - a 3D array
55:31 - now
55:33 - some of You Must Be Wondering dot can we
55:37 - slice and array
55:40 - using negative indexes
55:43 - are red negative indexes the answer is
55:47 - we can do it for sure
55:53 - so surely we can
55:56 - so I'm just gonna print
55:59 - the existing array
56:03 - and now I'm gonna slice it using
56:05 - negative indexes
56:08 - so first of all we need
56:11 - the values of the indexes to slice
56:16 - so let's slice from
56:22 - index
56:25 - minus 3 to index
56:29 - minus 1.
56:32 - so let me just write the command that is
56:34 - print
56:37 - ARR
56:38 - -3 comma minus 1.
56:43 - sorry I need to pass the slice
56:47 - instead of these values
56:53 - so this kind of Mystic is very common
56:56 - please be careful because you have to
56:59 - pass the slice
57:02 - and not the index
57:05 - so I have passes slice and it has shown
57:07 - with the result 8 and
57:10 - hi guys welcome back to our course on
57:12 - numpy in today's lecture we are going to
57:15 - study the data types in numpy so let's
57:18 - get started
57:21 - let's first take a look at the default
57:23 - data types in Python the integer float
57:27 - Boolean string and complex
57:31 - integer represents numbers like 1 2 3
57:34 - minus 1 minus 2 minus three float
57:37 - represents real numbers Boolean
57:40 - represent true or false value and string
57:43 - represents text
57:44 - while complex represent complex number
57:47 - which has real as well as
57:50 - imaginary part let's move on to data
57:53 - types in numpy numpy has some additional
57:56 - data types and are represented using
57:59 - alphabets
58:00 - low case I stands for integer lowercase
58:04 - U stands for unsigned integer lowercase
58:08 - b stands for Boolean lowercase f stands
58:12 - for float low Case C stands for complex
58:15 - float Locus m stands for time Delta
58:19 - uppercase m stands for date time o
58:22 - stands for object uppercase s represents
58:27 - string and V represents chunk of memory
58:30 - or void now let's move forward
58:34 - to another topic that is how to check
58:36 - the data type of an array
58:39 - so numpy array object has a property
58:42 - called T type that Returns the type of
58:45 - array the syntax is print
58:49 - and in bracket we have to give array
58:52 - name dot T type and this command or this
58:57 - line or this
58:59 - thing will return as the data type of
59:02 - the array
59:04 - that we have passed now let's move on to
59:08 - the coding path and implement this
59:12 - so I have opened my terminal and I'll
59:14 - write Python 3 and hit enter now I'm
59:18 - gonna import numpy as NP
59:22 - and create an array ARR is equal to NP
59:28 - dot array and now I'm gonna pass a list
59:32 - to it
59:35 - but this time
59:36 - the less
59:38 - contains
59:40 - string characters
59:43 - and not integers so let the elements be
59:47 - pen banana
59:49 - you can take anything or chalk
59:55 - so close the brackets and hit enter now
59:59 - I've created an array now we are gonna
60:01 - print the data type so I'm gonna write
60:04 - print and in Brackets I'm gonna write I
60:07 - rename or ARR dot d type and hit enter
60:11 - so I have obtained the result as U6
60:15 - please note that here U stands for
60:17 - Unicode string
60:21 - so now let's take one more example
60:25 - now I'm gonna create one more array
60:29 - and
60:31 - it's gonna be an array of
60:34 - integers
60:36 - so arr1 is equal to NP dot array and now
60:41 - I'm gonna pass an integer list to it
60:45 - so let the elements be one two three
60:47 - four close brackets and hit enter so I'm
60:50 - gonna print
60:51 - arr1 dot d type
60:57 - so the result is int 64. please know
61:00 - that end refers to integer so data type
61:04 - is integer 64.
61:09 - now let's move on
61:12 - and see how can we create an array with
61:15 - a specified data type so click to create
61:18 - an array with a specified data type we
61:21 - need to pass an optional argument while
61:23 - creating the array that is D type so the
61:27 - syntax is going to be array name is
61:30 - equal to NP dot array and we have to
61:34 - pass list and we have to add a comma and
61:37 - we have to pass Theta type as the
61:40 - required data type
61:42 - now let's take an example
61:45 - so let me just zoom
61:48 - the terminal
61:52 - now I'm gonna write
61:55 - python3
61:56 - hit enter import numpy
62:00 - as NP
62:02 - hit enter now I'm gonna create an array
62:06 - but this time I'm going to specify the
62:10 - data type so let's create an array
62:14 - with data type
62:19 - 4 byte integer
62:23 - so I'm gonna write ARR or array name is
62:27 - equals to NP dot array and this time we
62:31 - are going to pass a list but
62:34 - we are also gonna specify the data type
62:39 - so I have to specify the data type as
62:44 - int or in this case we can use I also or
62:50 - I4 so 4 bytes
62:54 - um
62:55 - I hit enter so I'm gonna print
62:59 - array and I'm going to print its data
63:02 - type
63:04 - so print ARR Dot D type so you can see
63:09 - it's int 32.
63:11 - so 4 bytes means 32 bits
63:19 - now let's take one more example
63:46 - so let's create
63:49 - an array
63:52 - with d type or data type
63:56 - string
63:59 - so I'm gonna write ARR 1 or whatever the
64:04 - array name is is equal to NP dot array
64:09 - and I'm gonna pass a list to it but this
64:13 - time I'm gonna specify the T type or
64:15 - data type as s that represents string
64:20 - I made an error there's some problem in
64:23 - brackets I have added
64:26 - an extra right bracket so let me just
64:29 - Rectify it
64:45 - so let me just print
64:47 - the array
64:48 - print ARR
64:51 - I have to print the error one so print
64:54 - arr1
64:58 - hit enter and you can see the result as
65:01 - a list of
65:03 - strings
65:04 - and when we print the D type or data
65:07 - type
65:08 - it shows
65:16 - S1
65:20 - that is string
65:21 - N1
65:23 - bye
65:26 - so now let's see what happens when a
65:29 - data type
65:30 - cannot be converted
65:34 - when you have a mixed kind of list that
65:37 - is it contains integers alphabets or
65:40 - it's in a mixed form and this problem in
65:43 - conversion
65:45 - so let me just give an example era 2 is
65:49 - equal to NP dot array
65:51 - and I'm gonna pass
65:53 - a character in list and other elements
65:58 - as integers
66:05 - and I'm gonna specify the data type as
66:09 - I that represents end
66:12 - so it says unmatched there's some
66:15 - problem in Brackets let me just correct
66:18 - it
66:19 - and
66:21 - do it again
66:23 - so it shows invalid literal for end with
66:27 - base 10.
66:31 - so this is the problem that arises when
66:34 - a data type cannot be converted
66:37 - hi guys welcome back to our course on
66:40 - numpy in our last lecture we covered
66:43 - data types and how to create an array
66:47 - with a specified data type
66:50 - so today we are going to cover the as
66:52 - type method
66:54 - so let's get started
66:56 - so we know how to create an array with a
66:59 - specified data type now the question
67:02 - arises
67:03 - how to convert data type on existing
67:07 - arrays the answer is the best way to
67:10 - change the data type of an existing
67:13 - array is to make a copy of the array
67:16 - with the as type method the ask type
67:18 - method returns a new data frame where
67:21 - the data types have been changed to a
67:24 - specified data type or in simpler words
67:27 - we can see that as type function creates
67:30 - a copy of the array and a laws U to
67:34 - specify the data type as the parameter
67:37 - please note that we can specify the data
67:41 - type using short notations like I for
67:44 - integer f for float or by using the data
67:48 - types directly like int for integer
67:51 - float for float
67:54 - Etc
67:55 - now let's see an example
68:01 - so let's change the data type from flow
68:04 - to integer by using I parameter value
68:09 - so let me just write Python 3 hit enter
68:11 - I'm gonna import numpy as NP
68:19 - now I'm going to create an array
68:23 - so I'm going to write NP dot array and
68:26 - I'm gonna pass a list
68:29 - so this is a list of
68:32 - float
68:34 - floating Point numbers
68:39 - so it gave me an error because I made a
68:41 - mistake I need to insert
68:44 - comma
68:50 - so let me hit enter I've created an
68:53 - array now let me use the ask type method
68:56 - to create a new array so new a new array
69:00 - name is equal to ARR dot as type
69:04 - and in bracket I'm gonna specify the
69:08 - data type
69:09 - so it's I here
69:13 - and your has been created now let's
69:15 - display
69:17 - so I'm gonna write print
69:19 - ARR
69:23 - hit enter
69:24 - this was our original array let's
69:27 - display the data type of the existing
69:31 - array
69:32 - or the old array it's showing float 64.
69:37 - now let's print the new array
69:41 - and print the data type of the new array
69:44 - so I'm gonna write print new dot d tag
69:49 - so it's showing n32
69:53 - now let's move on to next example change
69:56 - data type from floor to integer by using
69:59 - end parameter value so last time we use
70:02 - I this time we are going to use end so
70:05 - I'm gonna write python 3.
70:08 - and hit enter
70:10 - I'm gonna import numpy
70:18 - I'm going to import numpy
70:21 - as NP
70:24 - now I'm gonna create an array
70:28 - so err or R Dynamics equal to
70:32 - np.ra and I'm gonna pass
70:35 - a list to it a list of floating Point
70:39 - numbers
70:43 - I made a mistake I need to go back
70:46 - to rectify it
70:49 - and I have to add
70:50 - brackets
70:52 - so I passed the list
70:54 - and I have created an array now let's
70:57 - create a new array using aspect method
71:00 - so new equal to array name dot as type
71:03 - and I'm going to specify the data type
71:06 - as int last time we used
71:09 - I in commas
71:16 - so I'm gonna print array and I'm gonna
71:18 - print
71:20 - the data type of
71:22 - original array so it's load 64 and I'm
71:28 - gonna print the new array and it's data
71:30 - type
71:33 - so the result
71:36 - is
71:39 - in 64.
71:41 - let's move on to another example change
71:43 - data type from integer to Boolean now if
71:48 - the data is or the data element is 0 it
71:52 - will return false and if it is greater
71:55 - than 0 it will return 1 or true
71:59 - so I'm gonna import numpy again as NP
72:08 - and hit enter I'm gonna create an array
72:12 - of integers
72:15 - so I'm gonna write NP dot array
72:18 - and I'm gonna pass a list to it
72:26 - and don't forget to add brackets
72:31 - so now I'm gonna hit enter array has
72:34 - been created now let's print
72:37 - the array
72:39 - and print its data type
72:45 - so it's in 64. now let me print
72:50 - no sorry now let me create
72:53 - a new array using as type method so new
72:55 - equal to Arab dot as type
72:59 - and and type I'm going to specify
73:02 - Boolean so it's
73:05 - bull or B Double L for Boolean so the
73:09 - new array is
73:11 - true false true false true these are
73:14 - Boolean values
73:16 - so I'm gonna print the data type of the
73:19 - new array as well
73:21 - so it is
73:23 - B Double L or Boolean
73:29 - so
73:31 - in today's lecture
73:33 - we covered the use of as type method
73:37 - and
73:39 - we looked at hi guys welcome back to our
73:42 - course on numpy in our last lecture we
73:45 - covered the as type method in numpy and
73:49 - today we are gonna learn about the
73:50 - difference between copy and view in
73:53 - numpy so let's get started
73:56 - so it is copy versus view so copy
74:01 - creates a new array it's a new array and
74:04 - view is just a view of the original
74:06 - array don't worry you'll understand it
74:09 - when we get into the code copy owns the
74:12 - data and view does not own the data
74:15 - those who have read database management
74:17 - system they might be acquainted with the
74:20 - term View
74:22 - so the changes made to copy will not
74:25 - affect the original array but the
74:28 - changes made to view
74:30 - will affect the original array so copy
74:33 - is just a new array which is a copy of
74:37 - the present array
74:39 - and view is just
74:41 - the same array with different name the
74:44 - changes made to view will affect the
74:47 - original array now let's move on to the
74:50 - code I've opened my terminal now I'm
74:52 - gonna write Python 3 and hit enter now
74:55 - I'm gonna import numpy
74:58 - as NP and hit enter
75:03 - now I'm gonna create an array
75:06 - with array name err is equal to NP dot
75:10 - array and I'm gonna pass a python list
75:17 - hit enter now add it has been created
75:20 - successfully
75:22 - so now I'm gonna write
75:24 - X is equal to ARR or array name Dot
75:29 - View
75:31 - and brackets
75:33 - and hit enter so I've created a view I'm
75:36 - gonna print the original array
75:41 - as well as I'm gonna print The View
75:47 - so print
75:49 - X
75:51 - so they both are the same now let's
75:54 - observe what happens
75:58 - let's now make
76:00 - changes
76:03 - to
76:04 - original array and see whether they are
76:07 - reflected
76:10 - to view
76:12 - so ARR
76:14 - zero
76:16 - is equal to
76:18 - 34. now we have initialized the zeroth
76:22 - index as 34. now I'm gonna print array
76:25 - as well as view to observe the
76:28 - difference
76:30 - see the array has been updated
76:34 - and the view has been updated so the
76:38 - changes in original array can
76:42 - affect View
76:45 - so we can see that view is affected by
76:48 - the changes
76:51 - made
76:54 - to
76:56 - the original
76:59 - array
77:01 - now
77:04 - let's move forward and
77:09 - make a copy
77:18 - so now I'm going to create a copy
77:22 - so why
77:23 - our copy name
77:34 - so copy name or Y is equal to ARR Dot
77:39 - copy
77:41 - and now I'm gonna
77:44 - write brackets and hit enter now a copy
77:46 - has been created
77:52 - now let's print
77:56 - the copy
77:59 - so it is same as the array now let's see
78:02 - what happens if we
78:06 - make changes
78:09 - in original array
78:12 - and their corresponding changes to copy
78:15 - and view
78:17 - so let's make changes
78:21 - one more time
78:26 - so I'm gonna write ARR or array name
78:30 - and initialize the second index as
78:35 - 243
78:36 - so I've made changes to original RN now
78:39 - let's see whether these changes are
78:41 - reflected to view
78:43 - and copy
78:46 - so now I'm gonna print
78:48 - view see it has been updated now let's
78:52 - see what happens to the copy
78:54 - now we can observe that we have
78:58 - made changes to the original array and
79:02 - our view which is denoted by X has been
79:05 - updated or affected by the changes made
79:08 - in original array but the copy Remains
79:12 - the Same
79:13 - it has not been updated to the copy Y is
79:16 - not affected by changes while view X is
79:20 - affected now let's move on to our next
79:22 - topic that is how to check if Ari owns
79:25 - its data so this is basically a method
79:28 - of checking where the a given
79:31 - element is a copy or it's
79:35 - a view
79:36 - so we know that copies owns data and
79:39 - view does not own data but how to check
79:42 - this
79:43 - so every numpy array has an attribute
79:46 - base that returns none if the array owns
79:50 - the data otherwise the base attribute
79:53 - Returns the original object
79:56 - now let's take an example
79:58 - and understand it through a code
80:01 - so I'm gonna write Python 3 and hit
80:04 - enter now I am gonna import numpy as NP
80:10 - now I'm gonna tweet an array ARR is
80:14 - equal to NP dot array and pass the list
80:17 - to it
80:21 - so I've created an array
80:24 - now I'm gonna create a view as well as a
80:28 - copy
80:30 - so for view X is equal to array name dot
80:34 - view or ar Dot View and for copy Y is
80:38 - equal to arrename.copy or ARR dot copy
80:43 - now let's use base
80:48 - so I'm gonna write print
80:52 - x dot base
80:56 - so it Returns the original array because
80:59 - this is
81:00 - a view X is a view so it Returns the
81:03 - original array while
81:08 - y returns none because it's a copy
81:11 - so x dot base
81:13 - returns us
81:15 - the original array
81:18 - because it's a view
81:21 - hi guys welcome back to our course on
81:24 - numpy in our last lecture we covered the
81:27 - difference between copy and View and
81:30 - today we are gonna learn about the array
81:32 - shape so let's get started
81:37 - so the first question is what is
81:42 - array shape in numpy so the shape of
81:45 - Abby represents the number of elements
81:48 - present in each dimension
81:50 - now the next question arises in our mind
81:53 - is how to get the shape of an array
81:57 - so we can use the array attribute called
82:00 - shape to get the shape of an array
82:03 - so the result is a tuple which each
82:06 - index having the number of respective
82:09 - elements now
82:11 - let's move on to the code
82:14 - so let me just write python3 and hit
82:16 - enter now I'm gonna import numpy as NP
82:22 - and hit enter
82:26 - so now let's start
82:29 - with
82:31 - a Zero Dimensional array a Zero
82:35 - Dimensional array is a scalar so I'm
82:37 - gonna write ARR 0 or array name is equal
82:40 - to NP dot array and in bracket I'm gonna
82:44 - write a scalar this time I'm not gonna
82:46 - pass a double
82:48 - so now I'm gonna print err 0
82:52 - sorry I need to rectify it arr0 and hit
82:57 - enter so I got the scalar as result now
82:59 - I'm gonna print
83:02 - arr0 dot shape
83:07 - so it returns me an NT double so it
83:12 - doesn't have any Dimension so it is a 0d
83:15 - array
83:18 - so now let's move on to 1D array
83:22 - so I'm gonna create a 1D array first so
83:25 - array name arr1 is equal to NP dot array
83:31 - and this time I'm gonna pass a tuple
83:37 - so the values from one to nine
83:39 - constitute the Tuple now I'm gonna print
83:43 - the array
83:47 - and I'm gonna print
83:49 - its shape
83:57 - since it is a 1D array it has one
84:00 - dimension and the number of elements in
84:02 - that Dimension is
84:04 - nine
84:06 - so now let's move on to a
84:08 - two-dimensional array so first I'm going
84:11 - to create a 2d array so ARR of 2
84:15 - or RN name is equal to NP dot array
84:21 - this time I'm gonna pass
84:24 - 2 1D arrays because we know that
84:28 - in a 2d array or Matrix the elements are
84:31 - 1D arrays
84:36 - so I've passed the elements
84:40 - now let me print
84:42 - ARR to
84:45 - and now I'm gonna print its shape
84:49 - so print
84:51 - ARR to
84:54 - dot shape
84:58 - so it has two Dimension the number of
85:02 - elements in First Dimension R2 and in
85:05 - second dimensional four it is other way
85:08 - of saying that number of rows are 2 and
85:10 - number of columns are four now moving on
85:13 - to a 3D array let's create a 3D array
85:22 - so the elements of a 3D array are 2D
85:26 - arrays
85:28 - so we have to create a 3D array
85:30 - accordingly
85:57 - so I've created a
86:00 - 3D array now I'm gonna print
86:04 - array
86:06 - and I'm gonna print the shape of the
86:09 - array
86:10 - so print
86:13 - err
86:15 - or 3 Dot
86:17 - shape
86:20 - so it's showing me list object has no
86:24 - attribute shape so let me just
86:29 - do it again there's an error
86:32 - so it's an attribute error so let me
86:35 - just create a 3D array again
86:48 - so let's
86:50 - try again
86:52 - this is the basic thing when you fail
86:54 - you have to try again
86:57 - just don't give up so here are three
87:01 - that's the image arr3 new
87:06 - or three new
87:15 - so here are three new is equal to NP dot
87:19 - r a
87:20 - and now I'm gonna pass
87:24 - two Diaries
87:47 - so I've created a 3D array a new 3D
87:51 - array from scratch again and now I'm
87:54 - gonna print
87:56 - error 3 new
87:59 - dot shape
88:06 - now I'm gonna hit enter
88:14 - so this has three dimension and the
88:18 - number of elements in respective
88:19 - Dimension are 2 2 and 3. so this is the
88:27 - optimized or the exact or the correct
88:30 - output now I have got an assignment for
88:33 - you
88:33 - you have to create a 4D array
88:39 - and you have to print
88:43 - and you have to print the shape of that
88:46 - 4D array you can also create a 4D array
88:50 - using ndi method as we discussed
88:53 - so in today's lecture we covered array
88:56 - shape
88:57 - hi guys welcome back to our course on
89:00 - numpy in our last video we covered shape
89:03 - of a numpy array and today we are gonna
89:06 - learn about the use of free shape method
89:10 - so let's get started
89:15 - so reshaping numpy Aries so we know that
89:18 - shape of an array is the number of
89:20 - elements present in each Dimension so
89:24 - reshaping refers to changing the shape
89:26 - of an array so what is actually achieved
89:30 - by reshaping that is addition or removal
89:33 - of Dimension and changing the number of
89:37 - elements in each Dimension so let's move
89:40 - on to the code
89:41 - let me just write python3 and hit enter
89:46 - now I'm gonna write import
89:49 - numpy
89:51 - as NP
89:55 - I'm gonna hit enter
89:57 - now
89:59 - reshape
90:01 - from
90:02 - 1D to
90:05 - 2D so we have to change the shape of an
90:09 - array from one dimension to two
90:10 - Dimension so I'm gonna write
90:14 - firstly we have to create an array to
90:17 - use the reshape method so I'm going to
90:19 - create an array so array name is equal
90:22 - to numpy or NP dot array and I have to
90:26 - pass a list so this is a list of 12
90:29 - elements
90:33 - so I'm gonna close the bracket and hit
90:36 - enter
90:38 - so I've created
90:40 - a 1D array now to convert
90:45 - the 1D array
90:50 - to
90:52 - sorry I have to convert the one the
90:55 - array with 12 elements
90:57 - into
90:59 - a 2d array
91:10 - so I'm gonna write
91:13 - new array or new array name is equal to
91:18 - current array name ARR Dot V shape I'm
91:24 - gonna specify
91:25 - the parameters so into e array we have
91:29 - two parameters
91:31 - that is row count and column count
91:36 - so now I'm gonna print the current array
91:39 - as well as the new array
91:44 - so you can see that I got a new array
91:47 - with four rows and three columns
91:55 - so we have four rows
91:59 - with three elements each
92:02 - or we can say that we have a new 2D
92:05 - array with four rows and three columns
92:11 - so let's reshape from
92:13 - 1D to 3D
92:19 - so we are going to to reshape from 1D
92:22 - array to a 3D array or three dimensional
92:25 - array so I'm gonna write new array name
92:28 - is equal to
92:31 - current array name or arr.v shape and I
92:35 - have to specify three parameters here
92:39 - so let them be 2 3 and 2 so that the
92:42 - product is 12.
92:47 - so now I'm gonna print the current array
92:52 - as well as the new array
93:00 - so you can't see the result we have a 3D
93:03 - array
93:04 - with two elements and each element is a
93:07 - 2d array consisting of three
93:12 - rows and two columns now we have an
93:17 - important observation to make here do
93:20 - you guys observe anything
93:22 - yes there's
93:24 - a very important observation here so the
93:27 - product of the parameters that we have
93:30 - passed and the elements in
93:35 - the number of elements that we have
93:38 - is same so the product of parameters is
93:42 - equal to the number of elements in one
93:44 - the array or in general
93:47 - so this is a very important thing
93:50 - so we have to take care of this thing in
93:54 - our mind while
93:55 - reshaping the arrays now the question is
93:59 - can we reshape into
94:01 - any shape
94:03 - so the answer is
94:07 - no we can't do that
94:13 - so we can't
94:16 - reshape
94:19 - into
94:22 - any shape that we want to
94:25 - they there are some constraints
94:33 - so let's see
94:36 - an example
94:43 - so let me just create an array
94:47 - so errat or array name is equal to
94:51 - NP dot array
94:54 - and I'm gonna pass a list
94:57 - so let the number of elements be eight
95:03 - now I have created an array
95:06 - it has
95:08 - eight elements
95:20 - now what are the possible combinations
95:23 - of parameters that I can pass so let's
95:26 - see we can
95:30 - make
95:31 - a 2d array
95:35 - with
95:37 - four rows
95:39 - and
95:40 - two columns
95:44 - we can make
95:48 - a 2d array
95:53 - are
96:00 - if we create an array with eight rows
96:03 - it's just gonna be a 1D array
96:07 - because the thing will remain the same
96:12 - so eight rows and it just it's gonna be
96:15 - a skew
96:19 - so let it be two rows and four columns
96:26 - so we can
96:28 - make an array with two rows and four
96:31 - columns or four rows and two columns but
96:34 - we can't make a 2d array with three rows
96:39 - and
96:41 - four columns because that would require
96:44 - 3 into 4 that is 12 elements
96:49 - so that would require
96:54 - 3 multiplied by 4
96:56 - that is equal to 12 elements
97:02 - but
97:03 - we have only
97:06 - eight elements
97:08 - so now let me just
97:10 - create new arrays so firstly creating a
97:14 - 2d array with four rows and two columns
97:18 - so let the new RN name be ARR new
97:21 - the RR mu is equal to ARR Dot pre-shape
97:25 - and I'm gonna pass 4 comma 2.
97:32 - now I'm gonna print the new array
97:37 - sorry the name is new
97:41 - so let me hit enter so we got a new
97:44 - array with four rows and two columns now
97:47 - let's make a 2d array with two rows and
97:50 - four columns so I'm gonna write error
97:52 - new is equal to reshape Dot sorry
97:55 - error.v shape 2 comma four I'm gonna
97:59 - print the new array
98:01 - so we have got a new array that is two
98:04 - dimensional with two rows and four
98:07 - columns now let's try to create a 2d
98:10 - array with three rows and four columns
98:13 - so this time I'm gonna pass three comma
98:16 - 4.
98:18 - so sorry I pass 3 comma 3 but still it
98:22 - cannot reshape because the size 8 can't
98:27 - be reshaped into size nine so it gives
98:31 - an error hi guys welcome back to our
98:34 - course on numpy in last video we started
98:37 - the reshape method and today we are
98:39 - gonna continue it so let's get started
98:44 - now let's see whether v-shape method
98:46 - returns a copy or it returns a view let
98:50 - me open my terminal
98:52 - so I'm gonna import
98:55 - numpy as NP gonna hit enter
99:01 - now let me create an array
99:04 - so add a name is equal to NP dot array
99:07 - and I'm gonna pass a list to it as usual
99:19 - I'm gonna hit enter
99:21 - so array has been created I'm gonna
99:23 - print
99:27 - add a name or ar Dot
99:30 - reshape
99:34 - I'm gonna give the parameters
99:38 - and I'm gonna
99:40 - add an attribute base to it which is
99:43 - used to check
99:44 - whether it's a copy or it's a view so it
99:47 - gave me an error because the array
99:49 - cannot be converted because
99:52 - size is 9 and the shape is eight
99:56 - so I change it to 3 comma 3 and I have
100:00 - written another command print add a name
100:03 - dot V shape and parameters are three and
100:06 - three and
100:07 - added the attribute base to it and I got
100:10 - the result as the original array and not
100:13 - none so since I got the result as the
100:18 - original array this is a view this is
100:22 - not a copy
100:24 - now you might be wondering what if
100:27 - dimensions are unknown
100:29 - so we are allowed to have one unknown
100:32 - Dimension it means that we don't have to
100:34 - specify an exact number for one of the
100:37 - dimension in v shape method instead we
100:41 - pass -1 and numpy calculates the
100:44 - dimension for us
100:47 - so we know that number of elements is
100:50 - equal to product of
100:53 - the parameters so if we have two
100:55 - parameters the calculation will be
100:57 - number of element divided by the
101:00 - remaining parameters now let's see an
101:03 - example through code
101:07 - so I have opened my terminal once again
101:10 - I'm gonna write python3 hit enter and
101:14 - I'm gonna import numpy
101:17 - as NP
101:20 - so I'm gonna
101:21 - create an array again
101:24 - so array name is equal to NP
101:28 - dot array
101:30 - and I'm gonna pass a python list to it
101:43 - so numpy array has been created
101:45 - successfully now I'm gonna
101:48 - write new array name or new ARR equal to
101:52 - current array name or ar dot reshape
101:56 - and I'm gonna pass two comma 2 and minus
102:00 - 1 so
102:01 - this parameter will be calculated
102:03 - automatically
102:05 - let's see how so I'm gonna print ARR
102:08 - that is original array and new array
102:12 - that is print
102:14 - bracket
102:15 - new ARR so this is the new array now I'm
102:18 - gonna print
102:23 - the shape of the new array
102:29 - and hit
102:31 - enter after closing the brackets
102:35 - sorry I have added an extra pair of
102:39 - bracket let me just correct it
102:44 - so I'm gonna write the command again
102:48 - so the answer is 2 comma two comma Dot
102:51 - comma two so the numpy has automatically
102:54 - calculated third parameter now let's
102:57 - move on to the next topic that is
102:59 - flattening the arrays so what is
103:02 - flattening flattening array means
103:04 - converting a multi-dimensional array
103:07 - into a 1D array
103:09 - we use reshape and in bracket minus one
103:15 - method to do it
103:18 - so the syntax is array name dot V shape
103:21 - and in bracket we have to pass
103:24 - -1 let's see an example
103:27 - so I've opened my terminal
103:29 - I'm I'm gonna import numpy
103:32 - as NP
103:36 - let me create
103:41 - a 2d array
103:43 - for flattening
103:45 - so arr2 is equal to NP dot array and I'm
103:50 - gonna pass
103:52 - 2 1D arrays
103:54 - as
103:56 - the elements of a 2d array
104:02 - so I have created a 2d array
104:05 - now I'm gonna paint
104:09 - the
104:11 - sorry the array name is arr2 so let me
104:13 - correct it and press the original array
104:16 - and now I'm gonna print
104:22 - the shape of the original array
104:31 - so it is
104:32 - 2 comma 4 that is two elements in First
104:35 - Dimension and four elements in the
104:37 - second dimension
104:39 - so two rows and four columns so now I'm
104:41 - going to reshape it
104:47 - and now I'm gonna print
104:50 - the new array
104:53 - so you can see I've got a 1D array or a
104:56 - flattened array
104:58 - I'm gonna print its shape as well
105:02 - so you can see that that the shape is
105:05 - eight elements in First Dimension
105:08 - hi guys welcome back to our course on
105:11 - numpy in our last lecture we covered
105:15 - v-shape method and today we are gonna
105:18 - cover another method under shape
105:21 - manipulation that is the transpose
105:24 - method
105:25 - so let's get started
105:29 - so what is transpose transpose is an
105:33 - operator which flips a matrix over its
105:36 - diagonal it switches the row and the
105:39 - column indexes of the Matrix thereby
105:42 - producing another Matrix some of you
105:45 - must be acquainted with the transpose
105:47 - method
105:48 - so let's see an example
105:52 - so let me just write python3 hit enter
105:55 - now I'm gonna import numpy
105:58 - as NP and hit enter
106:03 - so let's create
106:07 - a 2d or two dimensional array first to
106:10 - find its transpose
106:13 - so let the rnm be arr2
106:17 - and error 2 or rnm is equal to num Pi
106:20 - dot array and I'm gonna pass 2 1D arrays
106:24 - as elements of a 2d array
106:29 - good morning
106:37 - sorry I made a mistake I have imported
106:39 - numpy as in p so I need to correct it so
106:43 - please take care of the name and the
106:46 - pseudo name or alias
106:49 - so I've created a 2d array now I'm gonna
106:52 - write the command to find its transpose
107:04 - so array name or arr2
107:08 - will be equal to
107:16 - sorry here I have to write another
107:18 - command that is
107:21 - NP dot transpose
107:24 - and I have to pass the array name that
107:28 - is error2
107:31 - now let me hit enter
107:36 - so this is the transpose and let me
107:38 - print the original array so that you can
107:40 - see the difference
107:42 - so
107:43 - this is the original array and what we
107:47 - printed previously was the transpose so
107:50 - we can see that
107:52 - original array
107:54 - and its transpose can be obtained by
107:57 - interchanging
107:58 - the rows and columns in a 2d Matrix
108:03 - now
108:04 - let's move on to another question this
108:06 - is a mixed problem
108:08 - on v-shape method and transpose first we
108:11 - need to create a 1D array then we need
108:13 - to reshape it to a 2d array and then we
108:16 - need to find the transpose of the two
108:19 - dimensional array
108:21 - so let's go to the solution let me just
108:24 - write python3 and hit enter now I'm
108:28 - gonna import numpy
108:31 - as NP and hit enter now I'm gonna create
108:37 - a 1D array
108:39 - so let's
108:41 - create
108:42 - a 1D array
108:45 - first
108:47 - so let me just write every name this
108:50 - time I'm taking array name as ARR so ARR
108:55 - is equal to NP dot array and I'm gonna
108:57 - pass a python list to it
109:01 - so let the number of elements B 8.
109:10 - now let's reshape this 1D array or this
109:16 - array to a 2d array
109:20 - so I'm gonna write X
109:22 - is equal to
109:27 - ARR dot reshape or rename dot reshape
109:31 - and I'm gonna pass
109:33 - the parameters that is the number of
109:35 - rows and the number of columns I want in
109:37 - my 2D array so I've created a reshaped
109:42 - this into a 2d array
109:45 - now let's
109:46 - print
109:48 - the original array
109:54 - the reshaped array
109:57 - or array after reshaping
110:02 - and the transpose
110:08 - and the transpose
110:12 - so let me just write print
110:15 - ARR
110:17 - or print original array
110:29 - I'm going to write arrs so original
110:33 - array has been printed I'm gonna print
110:38 - the array after reshaping
110:51 - so this time it's gonna be X
110:58 - so the format in which it is displayed
111:01 - it's a little different let me just
111:04 - print X simply so that you can see the
111:08 - whole array at one place or whole Matrix
111:10 - at one place I'm gonna print the
111:13 - transpose so I'm gonna write NP dot
111:17 - transpose
111:20 - so X
111:22 - it's not X it's in P dot transpose and
111:26 - I'm gonna pass X as a parameter
111:32 - so you can see the transpose has been
111:34 - displayed now we can see the original
111:38 - array the array after reshaping and the
111:43 - transpose of the reshaped array so we
111:46 - have fulfilled all the requirements of
111:49 - the question
111:52 - hi guys welcome back to our course on
111:54 - numpy in our last lecture we covered the
111:58 - transpose method under sheep
112:00 - manipulation and today we are gonna
112:02 - learn about the flat and the flattened
112:04 - method
112:05 - under shape manipulation so let's get
112:09 - started
112:12 - so our first question is what is
112:15 - flattening so flattening an array means
112:18 - converting a multi-dimensional array
112:21 - into 1D array
112:22 - as earlier discussed we can use the
112:25 - reship method by passing -1 as a
112:29 - parameter to flatten an array but we
112:32 - have other methods as well
112:34 - so one of the methods is flat this
112:37 - function returns a 1D iterated over the
112:41 - array or in simpler words it will return
112:43 - the element corresponding to the index
112:46 - in flattened array and the other method
112:49 - is
112:49 - flatten method this function returns an
112:52 - array collapse into one dimension or it
112:55 - returns a 1D array
112:58 - now let's see some examples
113:00 - so let me just open my terminal
113:06 - so let me write python3 hit enter now
113:09 - I'm gonna import
113:11 - numpy
113:13 - as NP
113:18 - and hit enter
113:28 - so I have to create
113:30 - an array first
113:32 - so let the RNA be a so a is equal to NP
113:36 - dot r a
113:39 - and I'm gonna create
113:42 - a 2d array
113:45 - because of 1dr is already flattened and
113:48 - the elements of a 2d array are one the
113:51 - arrays so I'm gonna pass 2 1D arrays as
113:55 - the elements of this 2D array
114:02 - so I've
114:05 - past elements and hit enter now I'm
114:10 - gonna print
114:12 - the original array
114:16 - so you can see the array has been
114:17 - displayed
114:19 - now let me use
114:22 - the flat method first
114:28 - so now let's use the flat method
114:34 - so print
114:41 - after using
114:45 - the flat method
114:48 - or the flat function
115:04 - so we are going to print
115:08 - a DOT flat and we are gonna pass an
115:12 - index
115:13 - so this function will return us
115:15 - the value at index 5 in the flattened
115:19 - array now you can see
115:21 - the value at index 5 in the flattened
115:25 - array is fixed
115:29 - so the value
115:31 - at
115:33 - the index
115:36 - 5
115:38 - after
115:40 - flattened
115:43 - array
115:45 - is
115:47 - 6 and it has been displayed
115:53 - so the flat function returns 1D operator
115:56 - over the array
115:58 - now let's print
116:02 - the original array and the flattened
116:04 - array
116:05 - to verify our answer
116:09 - so I'm gonna write print array sorry I
116:11 - made a mistake array name is a so I have
116:14 - to write print a
116:16 - now let me print the flattened array
116:18 - using reshape method first
116:22 - so print a DOT V shape I'm gonna pass
116:28 - minus 1 to it
116:32 - so the flattened array has been
116:33 - displayed and you can see that the value
116:36 - at the fifth index in the flattened
116:39 - array is 6.
116:42 - now let's discuss one more way of
116:45 - flattening the array that is the
116:48 - flattened method
116:50 - so now let's look at
116:53 - an entire method
116:55 - of
116:56 - flattening
116:58 - the array are a method of flattening the
117:01 - entire area there is a little
117:04 - average
117:05 - so this is a method of flattening the
117:08 - entire array
117:10 - so I have to write print
117:16 - so let me print the original array first
117:19 - so print original array
117:31 - let me just write print
117:34 - and pass the array name to print the
117:37 - original array
117:43 - so the original array has been displayed
117:46 - now we have to flatten it using the
117:49 - flatten method so I'm going to write
117:51 - print
117:53 - and
117:57 - I have to use the method or the function
118:00 - flatten so I'm gonna write flattened
118:02 - array
118:10 - and now I'm gonna write
118:12 - a command
118:16 - as
118:18 - a continuation of this so a DOT flatten
118:22 - so flattened array has been
118:26 - displayed
118:29 - so this flattened array is 1 comma 2
118:31 - comma 3 comma 4 comma 5 comma six comma
118:35 - 7 and comma 8 in one dimension
118:39 - so we have got our flat and array
118:44 - using flatten method so in today's
118:47 - lecture we covered
118:49 - flattening
118:52 - flatten method and flat method under
118:56 - shape manipulation
118:58 - that will be all for today this video is
119:01 - brought to you by programming knowledge
119:03 - please like comment share subscribe and
119:06 - hit the Bell button for updates and
119:09 - please stay tuned with us for more
119:11 - lectures on this series
119:14 - hi guys welcome back to our course on
119:16 - numpy in our last video we covered the
119:20 - flat and the flattened methods under
119:22 - shape manipulation and today we are
119:25 - gonna learn about the concatenate method
119:28 - so let's get started so the first and
119:31 - foremost question is what is
119:34 - concatenation or concatenation
119:37 - so concatenation refers to a group of
119:41 - things linked together or occurring
119:43 - together in a way that produces a
119:46 - particular result or effect and in the
119:48 - context of programming it refers to the
119:52 - operation of joining two entities now
119:55 - these entities can be arrays strings or
119:59 - anything so here we are going to deal
120:01 - with concatenation of two
120:04 - Aries or merging of two arrays so the
120:09 - general Syntax for concatenation is
120:12 - numpy dot concatenate or concatenate and
120:15 - we have to pass the list of arrays we
120:18 - want to merge and the corresponding axis
120:21 - now you must be wondering what is Axis
120:24 - so axis plural are defined for arrays
120:28 - with more than one dimension a
120:31 - two-dimensional array has two
120:33 - corresponding axes the first running
120:35 - vertically downwards across row or the
120:38 - axis 0 and the second running
120:41 - horizontally across columns or axis one
120:45 - likewise a 3D array has three axis a 4D
120:50 - array has four axis
120:53 - and
120:54 - so on
120:56 - so now let's move on to the code let me
120:59 - just open my terminal
121:02 - so let me just write python 3. and hit
121:06 - enter now I'm gonna import
121:08 - numpy
121:10 - as NP
121:13 - hit enter
121:16 - now let's
121:18 - concatenate
121:22 - or join two one dimensional RVs so first
121:27 - of all we are going to concatenate or
121:29 - merge or join to 1D arrays so let's
121:33 - create
121:34 - to 1D arrays first
121:41 - so I'm gonna write arr1 is equal to NP
121:45 - dot array
121:46 - and I'm gonna pass a python list to it
121:52 - now I'm gonna create the second array in
121:55 - a similar manner
122:06 - so I have created to 1dras now let me
122:10 - print
122:12 - the result
122:13 - after
122:15 - concatenation of these two arrays so I'm
122:18 - gonna write NP dot concatenate
122:21 - and I'm gonna pass
122:24 - first ra or Error 1 and the second array
122:27 - or ARR to close the bracket and hit
122:30 - enter
122:35 - there was a bracket missing I have to
122:37 - add an extra set of brackets
122:41 - so it gave me an average let me just
122:44 - add an extra pair of brackets
122:48 - and
122:54 - hit enter
122:58 - now we can see the result of the merger
123:00 - of these two arrays
123:03 - now
123:07 - we can see that these arrays have been
123:11 - concatenated
123:12 - so we can see that the arrays have been
123:16 - merged concatenated
123:19 - or
123:21 - joined
123:29 - now
123:31 - let's
123:32 - move on
123:37 - and try to concatenate 2D arrays
123:42 - first of all we have to create two two
123:45 - dimensional arrays
123:51 - so I'm gonna write
123:53 - rr2
123:55 - 1
123:56 - is equal to num Pi or NP dot array
124:00 - and I'm gonna pass to 1D arrays as
124:04 - elements of
124:05 - two dimensional arrays
124:13 - let me now create the second two
124:15 - dimensional array in a similar manner
124:34 - so let the element be four five six and
124:37 - seven eight nine for the second
124:40 - array of created to 1D arrays before
124:44 - concatenating 2D arrays let's first try
124:48 - to understand the concept of
124:53 - axis so I'm gonna concatenate
124:57 - the 1D arrays again
125:04 - but this time
125:08 - will have an observation to make
125:14 - so I have
125:16 - to concatenate the 1D arrays again
125:20 - so now I'm gonna print the result
125:27 - see I've concatenated the one the
125:30 - address again
125:32 - so by default
125:43 - the concatenation is done along the axis
125:47 - zero
125:52 - so by default the concatenation is along
125:55 - the axis 0. so you must be wondering why
125:58 - did not I pass an axis value when I
126:01 - concatenate it these 1D arrays now let's
126:05 - try to pass
126:07 - value of access
126:11 - so now let's concatenate along axis 1.
126:17 - so I'm gonna give the value of axis
126:20 - equals to 1.
126:25 - so it is given axis 1 is out of bounds
126:28 - or array of Dimension 1 this is because
126:31 - axis
126:33 - 0 is only present in case of a 1D array
126:36 - for X is 1 we have to move to 2dra
126:42 - now let's
126:44 - concatenate are two dimensional arrays
126:48 - so I'm gonna give add it to 1 and add it
126:52 - to 2.
127:03 - I'm gonna hit enter now
127:15 - now I'm gonna print
127:17 - the result or ARR new
127:24 - so this is the result of concatenation
127:27 - of 2D arrays along the axis 0.
127:38 - so this
127:40 - can be
127:43 - concatenated
127:45 - about
127:48 - axis
127:50 - 0 1 and none
127:55 - so an array of
127:58 - Dimension n can be concatenated along
128:03 - n number of axis starting from 0 1 and
128:07 - so on
128:08 - including none
128:11 - now I'm gonna display the result after
128:13 - concatenation along axis 1.
128:17 - so this is the result
128:19 - so in today's lecture we covered the
128:22 - concatenation method
128:25 - under shape manipulation that will be
128:28 - all for today
128:29 - this video is brought to you by
128:31 - programming knowledge please like
128:33 - comment share subscribe and hit the Bell
128:36 - button for updates and please stay tuned
128:39 - with us for next lecture thank you hi
128:42 - guys welcome back to our course on numpy
128:45 - in our last video we covered array
128:48 - concatenation under shape manipulation
128:51 - and today we are going to learn about
128:53 - the sort method which is used for
128:56 - sorting arrays in numpy so let's get
129:00 - started
129:01 - so first of all what is sorting
129:05 - so sorting refers to the action of
129:07 - putting elements in an ordered sequence
129:10 - an audit sequence is any sequence it can
129:14 - be numeric or alphabetical the order can
129:17 - be ascending or descending now the
129:20 - question is how to sort the numpy ndra
129:23 - has a function or method called as sort
129:26 - that will sort of specified array now
129:29 - let's move on to the code so let me
129:31 - write Python 3 and hit enter I'm gonna
129:34 - import numpy
129:36 - as NP
129:40 - and hit enter
129:44 - now
129:46 - let's
129:49 - sort
129:51 - the array
129:54 - alphabetically first
129:59 - so I need to create
130:02 - an array first for sorting purpose
130:05 - so let it be ARR and the command is
130:09 - error is equal to NP dot R A and I have
130:14 - to pass a python list
130:21 - so let the elements be banana almond
130:25 - or anything you like
130:30 - so the third element is chocolate
130:32 - because I like chocolate
130:35 - so I have closed the brackets and I fit
130:39 - into so I has been created successfully
130:42 - now
130:44 - let's
130:48 - thought
130:50 - so I'm gonna write
130:53 - print
130:55 - and then bracket I'm gonna write NP dot
130:59 - sort and I'm going to pass the array
131:02 - name that is ARR and close the brackets
131:07 - so we have displayed the sorted array
131:12 - so we got
131:14 - the result
131:16 - as
131:18 - the sorted
131:21 - Ari
131:23 - now let's move on
131:32 - let's sort a Boolean array so Boolean
131:35 - values are either true or false
131:39 - so we have to create a Boolean array
131:42 - first
131:45 - so
131:47 - arrb
131:49 - or Boolean array is equal to NP dot r a
131:56 - I made a mistake let me just correct it
132:03 - so this time we are going to pass either
132:05 - true or false values
132:08 - so let it be false false
132:11 - true
132:16 - and close the brackets and hit enter
132:21 - now let's display the sorted array
132:29 - so print NP dot sort
132:32 - and I'm gonna pass the array
132:35 - name or arrp
132:40 - and hit enter so I've got the sorted
132:42 - array but the thing is here the array
132:46 - I have passed and the sorted array
132:50 - appeared to be the same so we can't
132:53 - conclude anything because what we passed
132:57 - an input we got at output
133:00 - so here we got the sorted array but
133:04 - it appears
133:07 - to be
133:08 - same as
133:12 - original array
133:19 - so we can't
133:23 - determine
133:26 - whether
133:30 - it is
133:32 - sorted
133:34 - or not so there's no way of determining
133:38 - because input is same as output so how
133:40 - can we determine whether it's actually
133:43 - sorted or not
133:44 - so let me do some changes in the Boolean
133:46 - array
133:47 - and sort it again
133:53 - so I'm gonna add some true false values
133:56 - randomly to the array
134:10 - so I've added some values and changed to
134:13 - array
134:14 - and I've sorted array
134:17 - so now we can see that
134:20 - the false values are displayed first and
134:24 - two values are displayed at the last
134:27 - this is an important observation
134:30 - so now we can observe that in a sorted
134:33 - Boolean array
134:39 - false
134:41 - values
134:46 - will be
134:48 - displayed
134:53 - before
134:55 - the True Values so this is an important
134:59 - conclusion please take care because this
135:02 - may be asked in an output question in
135:05 - your examination
135:06 - so let's move on
135:09 - to two dimensional array
135:12 - now let's sort a two-dimensional array
135:19 - so we have to create a 2d array first so
135:22 - arr2 is equal to
135:26 - NP dot array and this time we are
135:30 - creating a 2d array so we have to pass 2
135:33 - 1D arrays as its elements so let the add
135:37 - elements be three to one for the first
135:40 - 1D array and
135:42 - Let It Be 4 8. 2
135:45 - for the second 1D array which is an
135:48 - element of 2D array now I'm gonna print
135:52 - NP dot sort and I'm going to pass the
135:56 - array name
136:01 - so I have got the result at the sorted
136:05 - array now
136:07 - we can
136:11 - observe that
136:17 - both the individual elements of the 2D
136:21 - array
136:23 - have been sorted
136:30 - or we can say
136:33 - both the 1D arrays
136:37 - that
136:44 - or which are the elements
136:48 - of
136:50 - 2D
136:51 - array
136:53 - have been
136:56 - sorted
136:58 - so in today's lecture we covered the
137:00 - thought method for sorting the arrays
137:03 - and we sorted 1D array and a 2d array
137:07 - that will be all for today this video is
137:10 - brought to you by programming knowledge
137:12 - please like comment share subscribe and
137:16 - hit the Bell button for updates and
137:18 - please stay tuned with us for next
137:20 - lecture thank you
137:25 - hi guys welcome back to our course on
137:27 - numpy in our last video we covered the
137:30 - Sorting and today we are gonna learn
137:33 - about iteration
137:34 - so let's get started
137:37 - so first of all what is the meaning of
137:39 - iteration iteration means going through
137:43 - the elements one by one we can use the
137:46 - basic for Loop for of the Python for
137:49 - iteration so iteration on a 1D array
137:52 - will go through each element or scalar
137:55 - one by one now let's move on to the
137:58 - coding path
138:01 - so let me just write Python 3 hit enter
138:03 - now I'm gonna import numpy
138:07 - as NP hit enter
138:11 - now
138:13 - iteration
138:16 - or iterate on the elements
138:19 - of
138:20 - a 1D
138:22 - array so this is the example where we
138:24 - gonna iterate a 1D array so let me
138:27 - create a 1D array first
138:38 - so I've created a 1D array now I'm gonna
138:40 - iterate it using for Loop so for X in
138:46 - array name or err and now I'm gonna
138:49 - write print
138:51 - X
138:53 - and hit enter twice
138:58 - so the elements of on the array have
139:02 - been
139:03 - displayed
139:05 - so this is the result
139:11 - we can see that
139:15 - when
139:16 - we will
139:18 - it wait
139:21 - on a 1D array
139:26 - it will go through
139:29 - all elements
139:35 - one by one
139:37 - so we can say that when will it wait on
139:40 - a 1D array it will go through all the
139:42 - elements one by one where individual
139:45 - elements are scalars this is a very
139:48 - important observation
139:50 - that we are actually going through the
139:52 - elements of the array
139:54 - in this case the elements are scalars so
139:57 - the scalars have been displayed now
139:59 - let's iterate on 2D arrays
140:02 - so we are gonna create a 2d array first
140:06 - so array name or arr2 is equal to NP dot
140:10 - array and now I'm gonna
140:14 - pass to 1D arrays to it because elements
140:18 - of a 2d array are 1D arrays
140:23 - so I have passed now I'm gonna hit enter
140:26 - so array has been created now I'm gonna
140:29 - use four for X in
140:32 - add a name or error 2 and I'm gonna
140:35 - print X
140:43 - so you can see that
140:46 - list to list
140:48 - have been displaced and not the scalars
140:52 - so some of you must be expecting the
140:55 - scalars as a result
140:57 - but we got the answer as to list which
141:00 - are the original elements of R to the
141:03 - array so we can see that when we iterate
141:06 - on a 2d array
141:09 - it will go through elements of 2D array
141:14 - when
141:17 - sorry which are
141:21 - not scalars so elements of a 2d array
141:25 - are not scalars but one Dr is
141:29 - so in this case 1D RS will be displayed
141:36 - so some of you might be expecting
141:38 - scalars but we got a different result
141:40 - now let's move on to
141:43 - 3D arrays so so in similar manner I need
141:47 - to create a 3D array first so I'll write
141:50 - array name
141:56 - sorry I've already imported so I don't
141:58 - need to write import
142:00 - so I have to write array name
142:03 - is equal to
142:05 - NP dot array and this time we are gonna
142:08 - create a 3D array so always remember to
142:12 - create a 3D array we have to pass 2D
142:15 - arrays as elements
142:21 - [Music]
142:25 - so I've passed 2D
142:28 - RS and there are two win numbers
142:31 - so let me just scroll the brackets
142:35 - and hit enter so error has been created
142:37 - now to write
142:39 - the for Loop so for X in ARR or array
142:43 - name I have to print X and hit enter
142:46 - twice
142:51 - so we can see that we got the result as
142:54 - 2
142:56 - D arrays so we can say that when we
142:59 - iterate on a 3D array it will
143:03 - go through all the elements
143:10 - so it will go through all the elements
143:12 - one by one
143:16 - so it will go through all the elements
143:17 - of a 3D array
143:19 - which are 2D angles
143:25 - and
143:26 - not the scalar so in this case also we
143:30 - got
143:31 - the result as the elements of 3D arrays
143:35 - which are 2D arrays and not the scalars
143:40 - so there's an assignment for you
143:49 - so what you have to do is
143:53 - you have to iterate
143:56 - on
143:59 - the 4D array
144:06 - that you have created as a part of your
144:09 - previous assignment so we'll continue
144:11 - our discussion on iteration in the next
144:14 - lecture so today we started with the
144:18 - basics of iteration in numpy that's all
144:22 - for today this video is brought to you
144:24 - by programming knowledge please like
144:26 - comment share subscribe and hit the Bell
144:29 - button for updates and stay tuned with
144:31 - us for next lecture thank you
144:34 - hi guys welcome back to our course on
144:36 - numpy in our last lecture we covered the
144:40 - basics of iteration and today we are
144:43 - gonna continue with this topic so let's
144:45 - get started
144:48 - so iteration down to the scalers so to
144:52 - return the actual values the scalars we
144:55 - have to iterate the arrays in each
144:57 - dimension
144:59 - now let's see how
145:01 - so let me just write Python 3 hit enter
145:04 - and import numpy as NP as usual
145:11 - so let's have a quick recap
145:14 - so in our last video
145:19 - we saw that
145:21 - when we iterate
145:26 - on
145:27 - so if we iterate on a
145:30 - 1D array
145:37 - it goes through
145:39 - each element
145:41 - or each scalar
145:43 - element
145:48 - so it goes through each scalar element
145:51 - one by one similarly when we iterate on
145:56 - a one sorry a 2d array
146:01 - it goes through
146:06 - each
146:08 - 1D array
146:11 - element
146:14 - one by one so because the elements of a
146:18 - 2d array are one Dr is so it goes
146:20 - through each one drf one by one so
146:23 - similarly when we iterate on a 3D array
146:27 - it goes through
146:29 - each
146:32 - 2D array element
146:39 - so it goes through each 2D array element
146:41 - one by one
146:48 - so we are going to generalize it
146:52 - so in general
146:57 - we can see that
147:01 - if we iterate
147:06 - honor
147:08 - or on an n-dimensional
147:12 - or ND array
147:19 - so if we treat on an ndra it will go
147:23 - through
147:27 - n minus 1.
147:30 - dimensions
147:36 - one by one
147:38 - so this is the generalized result
147:41 - now the question is
147:47 - how to
147:49 - iterate
147:52 - down to the scales so how to iterate
147:55 - down to the scalars how to achieve this
147:58 - thing
148:00 - so we have a goal and we need to achieve
148:03 - it so how to do it
148:07 - so one of
148:10 - the many ways
148:11 - so see whenever we have a problem we
148:13 - have a lot of ways of tackling it so one
148:16 - of the method that we can use here is
148:19 - using nested loops
148:23 - so we are going to use nested faults
148:26 - here
148:28 - so first example is
148:32 - it rate on each element on each scalar
148:36 - element
148:39 - of a 2d array or a two-dimensional array
148:43 - so now let's create a 2d array first so
148:51 - so elements of 2D array are one Dr is
148:55 - so I've passed them
148:58 - and hit enter and has been created now
149:01 - I'm going to write the for Loop so for
149:03 - xn
149:04 - array name or ARR and
149:08 - nested Loop for y in this time we are
149:12 - not going to write in ARR or RNA we are
149:15 - going to write in x
149:17 - and we are going to write
149:20 - print
149:21 - y
149:23 - now we can see that each scalar element
149:26 - of the 2D array has been displayed
149:30 - so we are successful
149:34 - in
149:36 - iterating
149:38 - down to the
149:40 - or down to scalars
149:42 - now let's move on to iteration down to
149:46 - scalars in three dimensional arrays
149:51 - so similarly
149:53 - let's iterate
149:55 - down to scalars
149:58 - in a 3D array
150:03 - so we have to create a 3D array first
150:06 - and keep in mind that elements of an ndr
150:10 - array are n minus 1 D Alice so elements
150:13 - of a 3D arrays are 3 minus 1 equals to
150:17 - 2D arrays
150:19 - so we are going to pass 2D arrays as
150:21 - elements
150:25 - so you can take any random values
150:33 - close the brackets and hit enter
150:36 - so array has been created now we have to
150:38 - write the four Loops or nested Loops so
150:42 - for X in rnm or ER for y in x
150:47 - and for
150:52 - V in y
150:58 - and now I have to write print
151:01 - Z
151:02 - in case in place of print y as we did in
151:06 - 2D arrays so we can see that each scalar
151:10 - element of
151:12 - 3D array have been displayed so we are
151:16 - successful in iterating down to
151:19 - scalars
151:21 - in
151:22 - a
151:23 - 3D array
151:26 - now I got an assignment for you
151:34 - so it wait
151:35 - down to scalars
151:40 - in the 4D array
151:44 - that you have created as a part of your
151:48 - previous assignment
151:52 - so you have to iterate down to scalars
151:54 - in a 4D array
151:58 - so in today's lecture we covered how to
152:02 - iterate down to scalars in higher
152:04 - dimensional arrays that will be all for
152:07 - today this video is brought to you by
152:10 - programming knowledge please like
152:12 - comment share subscribe and hit the Bell
152:15 - button for updates and stay tuned with
152:17 - us for next lecture on this series
152:21 - thank you
152:22 - hi guys welcome back to our course on
152:25 - numpy in our last lecture we covered the
152:28 - method of iterating down to scalars in
152:31 - higher dimensional arrays using nested
152:34 - loops and today we are going to learn
152:36 - about the ND eater method so let's get
152:40 - started
152:42 - so first of all what is ndator Method so
152:46 - the function indicator is a helping
152:48 - function it solves the basic issues that
152:51 - we faced in iteration so in basic for
152:54 - Loops if we have ND array or n
152:56 - dimensional array iterating through each
152:59 - scalar element would require n Loops
153:02 - which can be difficult to write for
153:04 - arrays with very high dimensionality
153:07 - so what we are gonna do is use ndator
153:09 - method so let me just write python3 hit
153:12 - enter I'm gonna import numpy as NP
153:19 - so
153:21 - iterate all the elements or all the
153:25 - scalars
153:28 - or iterate down to the scalars
153:34 - in a 2d array so this is an example that
153:38 - we are going to you do using ND iter
153:41 - method
153:42 - our function so let first of all let's
153:45 - create a 2d array
153:49 - so you know the procedure how to do it
153:51 - we have done it almost
153:54 - 50 times or more I guess
153:58 - so create a 2d array the elements of a
154:01 - 2d array are 1D arrays so pass them
154:05 - close the brackets and hit enter
154:09 - so array has been created successfully
154:12 - now I have to use one for loops with ND
154:16 - iter method or ND heater function so for
154:19 - xn NP dot indicator
154:22 - and I am going to pass the array name
154:28 - so I have written the command and now
154:31 - I'm going to write the print function
154:34 - so print X
154:38 - and hit enter twice
154:41 - so I got the result
154:50 - as scalars
155:01 - so the result is scalars and we didn't
155:04 - need to use nested for Loops so we
155:08 - iterated down to scalars
155:11 - with help of
155:14 - one
155:16 - or only one for Loop
155:21 - and
155:26 - 1 and the heater
155:29 - function
155:41 - so now the question is why is ND eater
155:44 - function
155:46 - more convenient
155:49 - so you can say that why or you can ask
155:53 - that why should we use ND interfunction
155:56 - rather than using nested Loops because
155:59 - all of us are habitual of using nested
156:02 - Loops while iteration
156:05 - so ND inter function is convenient
156:08 - because we don't need to use nested
156:11 - loops but you might have a counter
156:15 - argument that you are comfortable
156:18 - with using nested Loops but then
156:21 - my response would be you can use nested
156:25 - Loop for 3D array for Dra 5D array but
156:30 - the array is off
156:32 - thousand dimensions let us consider that
156:36 - we have an area of 1000 Dimension then
156:38 - you need to write 1000
156:41 - for Loops to iterate down to scalars in
156:44 - an array of
156:45 - 1000 or array with thousand
156:48 - dimensionality
156:50 - so ndated function is convenient because
156:52 - we don't need to use nested Loops here
156:54 - so in general if we have an ND array we
156:58 - need to use l Loops to iterate down to
157:00 - scalars so if n is of order 100 or 1000
157:06 - it will increase
157:09 - loc or line of control or code it will
157:13 - increase the line of code and effort of
157:16 - the programmer
157:18 - so you need to write a lot of
157:21 - commands or lines in your code if you
157:25 - want to iterate down to scalars in an
157:28 - array of very high dimensionality so we
157:31 - can say that and the heater function is
157:34 - more convenient
157:39 - so now let's iterate down to scalars in
157:43 - a 3D array
157:52 - so let's iterate down to scalars in a 3D
157:55 - array using ND eater
157:57 - function so the process is same we need
158:00 - to create a 3D array first so elements
158:03 - of a 3D array are 2D arrays so I need to
158:06 - pass those
158:11 - you can choose any random values that
158:14 - you want to choose
158:21 - so just passed
158:25 - parameters
158:27 - and
158:28 - close the brackets and hit enter now you
158:31 - have created a 3D array now we have to
158:34 - write for Loops so for X in
158:38 - p
158:42 - dot NDT and we are going to pass the
158:45 - array name or ARR
158:51 - now we are going to write print X
158:57 - and hit enter twice so we got the
159:00 - desired result
159:06 - so I can say that we are successful in
159:09 - iterating down to scalars
159:15 - in a
159:18 - 3D array
159:21 - now I have an assignment for you
159:26 - so what you have to do is you have to
159:29 - iterate
159:30 - down to scalars
159:33 - in a
159:34 - 4D array or four dimensional array
159:38 - that you have created as a part of your
159:45 - previous assignment
159:51 - so you have to create a 4D array
159:56 - and use editor method to
160:01 - iterate down to scalars
160:04 - now let's
160:07 - move on to next topic which is iterating
160:11 - with different step size using indicator
160:14 - method
160:17 - so in last examples we had this step
160:19 - sizes one so let's change the step size
160:23 - and look at a different example so the
160:27 - question is iterate
160:31 - in a 2d array
160:33 - with help of
160:36 - ndated function and with step size 2 so
160:41 - I have to create the array first
160:44 - so follow the standard procedure
160:51 - so I've created the array now I have to
160:53 - write the function
160:55 - sorry I have to write the for Loop and I
160:57 - have to use n data function so for X in
161:03 - NP Dot and theater
161:06 - and F to pass array
161:09 - and in Array
161:11 - inside the square brackets
161:14 - I have to
161:17 - pass
161:21 - only the step size
161:23 - so it's going to be 2.
161:29 - I need to use square brackets
161:31 - so let's close the brackets
161:35 - and hit enter
161:40 - oh sorry by mistake I used an extra
161:43 - closing bracket this let me just remove
161:46 - it and
161:48 - hit the enter again
161:50 - so
161:52 - so I have written the for Loop now to
161:53 - write print X
161:58 - so I got
161:59 - the result so we have iterated down to
162:02 - scalers in a 2d array with step size 2.
162:09 - so the result is we iterated this 2D
162:13 - array down to scalars
162:18 - with step size
162:21 - 2 and using ND eater method
162:25 - so now I have one more assignment for
162:27 - you
162:31 - so the assignment is iterate down to
162:34 - scalars
162:39 - in the 4D array that you have created as
162:42 - a part of your previous assignment
162:50 - and you have to change the step size
162:53 - to 3.
162:56 - so in this lecture we studied about the
162:59 - use of editor method so that's all for
163:02 - today this video is brought to you by
163:04 - programming knowledge please like
163:06 - comment share subscribe and hit the Bell
163:09 - button for updates and stay tuned with
163:12 - us for next lecture on numpy thank you
163:17 - hi guys welcome back to our course on
163:19 - numpy in our last lecture we continued
163:21 - with our discussion on iteration in
163:24 - numpy arrays and we demonstrated the use
163:27 - of
163:28 - and the iter method today we are going
163:31 - to start with searching and look at the
163:34 - where method
163:36 - so what is searching searching is the
163:38 - action of assessing a specified element
163:40 - from the array so here in this lecture
163:44 - we are going to use the where method to
163:47 - search in a numpy array
163:49 - so let me just write Python 3 hit enter
163:53 - now I'm gonna import
163:56 - numpy
163:58 - as NP
164:00 - so in this lecture we are going to
164:02 - demonstrate the use of where method for
164:07 - searching
164:09 - so let me just create an array first
164:12 - so array name or ARR is equal to NP dot
164:16 - r a
164:17 - and I'm going to pass a python list to
164:20 - it
164:21 - so I can
164:24 - write any random elements
164:27 - while creating the list
164:30 - and I need to close the brackets
164:34 - and hit enter
164:38 - make sure that your parentheses are
164:40 - balanced now I'm gonna create a variable
164:43 - X and I'm going to store
164:46 - the index in it so X is equal to NP dot
164:50 - where
164:51 - and I'm gonna pass the condition so
164:54 - where ARR is equal to
164:58 - 2 so this will return the indices where
165:02 - the value at index is 2 so we can see
165:07 - that the indexes or indices where the
165:11 - values 2 are 1 6 and 8.
165:18 - so this means that the value 2
165:20 - is present at multiple indices
165:25 - which are
165:29 - 1
165:30 - 6
165:31 - and 8.
165:34 - now let's move on to the next example
165:37 - now we are going to search for a value
165:40 - which is not present in the array
165:44 - so let me just give the value 10 which
165:47 - is not present in the array I have
165:49 - stored the result and I'm gonna print it
165:51 - so we can observe that I got the result
165:55 - as an empty
165:58 - fit or emptiness indicating that the
166:01 - value 10 is not present in the array
166:05 - so this results
166:07 - or it returns an empty list this means
166:11 - that the value 10
166:15 - was not
166:17 - found or it's not present in the array
166:24 - now let's look at some more examples
166:36 - so one more example
166:44 - so we have to find
166:51 - so find the indexes
166:53 - where
166:55 - the values stored
166:59 - or values are
167:01 - odd
167:03 - so now we are going to
167:06 - write X is equal to NP Dot
167:10 - where
167:12 - and we are going to pass
167:15 - add a name or ARR
167:19 - mod of 2
167:22 - not equal to
167:24 - zero
167:25 - so this is the condition for the odd
167:27 - elements that when they are divided by 2
167:30 - the remainder is not 0.
167:33 - so we are going to print the original
167:35 - array and now we are going to
167:39 - print the indexes where the values are
167:41 - odd so at index 0 that is 1 R2 that is 3
167:46 - at 4 that is 5 so these are the indexes
167:50 - where the values are odd now next
167:53 - example is find the indices
167:56 - where values are even now we have to
168:00 - replicate the same thing we just need to
168:03 - change the condition for all elements
168:06 - the condition is
168:07 - add a name mod of 2 not equal to 0 but
168:11 - here in case of even elements the
168:14 - condition will be array name or ARR mod
168:17 - of 2 equal to equal to 0.
168:21 - now I have displayed the original array
168:24 - and now I'll display the indexes
168:28 - containing even values
168:31 - so the even values are present at index
168:34 - 1 3 5 6 and 8. so in this lecture we
168:40 - started with searching in numpy arrays
168:43 - and we covered
168:45 - or demonstrated the use of wear method
168:48 - that's all for today
168:50 - this video is brought to you by
168:52 - programming knowledge please like
168:54 - comment share subscribe and hit the Bell
168:57 - button for updates and stay tuned with
168:59 - us for next lecture thank you
169:02 - hi guys welcome back to our course on
169:04 - number in our previous lecture we
169:07 - started our discussion on searching in
169:09 - numpy arrays and I demands created the
169:12 - use of where method in today's lecture
169:15 - we are going to cover the search sorted
169:18 - method for searching in numpy arrays so
169:21 - let's get started
169:25 - so Source sorted method performs binary
169:28 - search in an array it Returns the index
169:32 - at which specified values should be
169:34 - present in order to maintain the order
169:38 - so the thing is it assumes the array to
169:41 - be sorted
169:43 - so let's move on to the coding path let
169:46 - me just write python3 hit enter
169:51 - so here
169:54 - we are going to use search sorted method
170:02 - so search sorted method performs binary
170:05 - search
170:07 - on the array
170:14 - so we need
170:16 - assorted array so binary search is
170:19 - always performed on a sorted array
170:25 - so we need to sorted array just we like
170:29 - we do in binary search
170:35 - so array name is equal to
170:38 - sorry first after import numpy
170:42 - import numpy as NP hit enter
170:46 - now let's create
170:51 - an array
170:56 - in which the elements
170:59 - are present
171:03 - in ascending order
171:09 - or in other words
171:14 - an array
171:17 - which is already
171:20 - sorted
171:22 - so let me just create an array
171:24 - name or ARR is equal to NP Dot
171:29 - array
171:31 - and I have to pass a sorted python let's
171:36 - do it
171:37 - so let the elements be 1 to 10
171:42 - close the brackets and hit enter
171:47 - now let's
171:49 - find
171:53 - the index
171:56 - at which
171:58 - value
172:00 - seven is present so I have to create a
172:03 - variable to store the value
172:07 - so it can't be ARR it has to be some
172:10 - other thing so X is equal to NP dot so
172:14 - it's sorted
172:16 - and I'm going to pass the array name and
172:20 - the value
172:22 - so I have to print X
172:27 - so the result is 6 it indicates that
172:31 - the value 7 is present at the index 6.
172:37 - now let's search for a value
172:39 - that is not present
172:44 - in the array
172:48 - so I have to write X is equal to NP Dot
172:52 - so it's sorted
172:54 - you have to pass the add a name
172:57 - as well as sorry the array name is error
173:03 - so I have to change it
173:05 - to ARR
173:07 - so I've passed 12 which is not evaluate
173:10 - the index
173:13 - so I'm going to print X
173:16 - so the result is 10 which is a little
173:18 - ambiguous because there is no index then
173:22 - and there is no value 12. let's try one
173:27 - more time
173:28 - so I'm going to write
173:30 - 130 this time and I'm going to print X
173:33 - again
173:35 - so again I got the result is 10 which is
173:39 - the number of elements present in Array
173:41 - and its little ambiguous
173:43 - because there is no index then we have
173:45 - indexes from 1 to 9. so I think when
173:50 - there is a value which is not present in
173:52 - the array it gives the number of
173:54 - elements present in the array as to the
173:57 - result
173:58 - and not the index or empty
174:02 - list
174:03 - so let's search from the right side so
174:07 - in previous example the indexes were
174:10 - counted from the left now let's
174:13 - count indexes from right
174:16 - now let's create a new array
174:20 - and elements are 3 4 5 and 6.
174:24 - so I'm going to write X is equal to NP
174:28 - Dot so it's sorted
174:31 - this time I'm going to pass the array
174:34 - name
174:35 - the element to be searched and also the
174:39 - side so the side is right
174:43 - so hit enter and I'm going to print X
174:50 - so the result is 2 but note that this is
174:54 - not the negative indexing from right
174:56 - because generally we prefer to do
174:58 - negative indexing from right
175:01 - so
175:02 - one thing that we need to observe is
175:06 - here the element is present
175:09 - at index to
175:12 - if we do positive indexing from
175:17 - right that is we conceded 6 at the root
175:21 - index 5 at first index and 4 at
175:25 - second index and so on
175:29 - now let's search for multiple values
175:33 - so till now we searched one value at a
175:38 - time but now we are going to search for
175:40 - multiple values at once
175:43 - so let's print the array first so R is
175:46 - three four five six and I'm going to
175:48 - write X is equal to NP dot so sorted and
175:52 - I'm going to pass the array name ARR and
175:55 - I'm going to pass the list of values for
175:59 - searching
176:01 - so I've passed
176:03 - the list of values and I'm going to
176:06 - print X so it denotes that the values 4
176:11 - and 5 are present at the indexes 1 and
176:14 - 2.
176:15 - one thing to note here is here instead
176:19 - of returning a single index
176:21 - it returns
176:23 - a list of
176:25 - indices
176:29 - corresponding
176:33 - to
176:35 - the values or the search values
176:41 - or we can say that the values entered
176:48 - now let's move on to the next example
176:52 - which is in the form of a question
176:58 - so the question is
177:00 - for an array
177:02 - given as
177:03 - 1 comma 3 comma 2 comma one
177:09 - five comma 32 comma 53 comma 21 comma 67
177:18 - we need to search
177:21 - the location
177:24 - of element
177:32 - or element 2 using search sorted method
177:44 - so this is the question now let's move
177:47 - on to the solution
177:49 - first of all
177:52 - the important thing to note here is that
177:55 - since the array
177:57 - is not sorted we have to sort it first
178:00 - because
178:03 - if we use the search sorted method it
178:05 - performs the binary search and for the
178:07 - bind research we need a sorted array so
178:11 - since the array is not sorted we need to
178:13 - sort it after creating
178:16 - and
178:17 - then
178:19 - search sorted method
178:22 - so these are the steps to approach the
178:26 - solution
178:27 - so first of all we have to create the
178:29 - array so add a name
178:31 - it's X this time so X is equal to NP dot
178:35 - array and I have to pass
178:38 - the list of elements
178:40 - given in the question
178:46 - so I've passed the list of elements and
178:48 - I have created the array successfully
178:52 - now second step is to sort the array
178:55 - using the sort method as already
178:57 - discussed in previous lectures so if you
179:01 - are not acquainted with it please go
179:03 - through the previous lecture another
179:06 - thing to note here is that I have not
179:08 - sorted it I just displayed the result
179:10 - after sorting
179:12 - I have to sort and store the result
179:17 - if I don't do that and directly use the
179:21 - search sorted method
179:23 - I will get ambiguous results or error so
179:27 - let's see what if I just
179:31 - sorted and display the result but not
179:33 - actually store the sorted result
179:36 - so after printing u i get the result as
179:40 - 1 but 2 is present at the location
179:44 - 2. and 3 so the result is wrong so the
179:50 - correct way to do is I have to store the
179:54 - result of the sorted array
179:57 - so there is
180:01 - a mistake here
180:06 - there were no changes made to
180:10 - original array so what I have observed
180:13 - is many students just display the result
180:16 - of after sorting and not don't actually
180:19 - make the changes to the original array
180:21 - or store it in another variable so this
180:25 - is a very common mistake please take
180:28 - care of this while
180:30 - doing any project or during your exam
180:34 - so now I have
180:36 - stored
180:38 - the result in a variable y and now I'm
180:42 - going to use the search sorted method
180:44 - again
180:49 - so I'm going to print the value of U
180:53 - so it returns me the index to because 2
180:57 - is present at the index it is the
181:00 - desired result so in today's lecture we
181:03 - covered the search sorted method for
181:06 - searching in a numpy array that will be
181:10 - all for today this video is brought to
181:13 - you by programming knowledge please like
181:15 - comment share subscribe and hit the Bell
181:19 - button for updates and please stay tuned
181:21 - with us for next lecture thank you
181:25 - hi guys welcome back to our course on
181:28 - numpy in our previous lecture we started
181:31 - about the search sorted method
181:34 - to search in a numpy array and today we
181:37 - are going to begin our new topic that is
181:39 - filtering of Aries
181:41 - and this lecture will cover two methods
181:44 - of filtering first one is using Boolean
181:47 - index list and the other one is by the
181:51 - use of filter function so let's get
181:54 - started
181:56 - so what is cell train getting some
181:59 - elements out of an existing array and
182:02 - creating a new array out of them is
182:04 - called as filtering in numpy we can
182:08 - filter an array using Boolean index list
182:11 - a Boolean list is a list of elements
182:14 - corresponding to indexes in the array we
182:18 - can also filter an array using the
182:21 - filter function if the value at the
182:24 - index is true that element is contained
182:26 - in the filtered array and if it is fault
182:29 - that element is excluded from the
182:32 - filtered array now let's move on to the
182:35 - code
182:36 - so I'm going to write Python 3 hit enter
182:39 - I'm going to
182:41 - import
182:43 - numpy
182:44 - as NP
182:47 - hit enter
182:49 - now
182:53 - let us first look at what we are going
182:56 - to do
182:57 - so filter
183:00 - so filter is used to extract
183:04 - values
183:06 - from
183:08 - a sequence
183:11 - under
183:13 - certain
183:15 - conditions
183:18 - so if the condition is fulfilled the
183:21 - value will be extracted and if it's not
183:24 - fulfilled the value won't be extracted
183:28 - so first
183:30 - we are going to create a Boolean array
183:34 - so let the elements be true false
183:37 - true false
183:42 - now let's create a sequence from which
183:45 - we have to
183:48 - extract the elements so this is a python
183:53 - array
183:55 - consisting of
183:57 - Boolean values
184:01 - now let's create a nump by
184:04 - sequence or numpy array
184:08 - to add a name is equal to NP dot array
184:11 - let me pass values so I'm gonna pass
184:15 - four values because I have four Boolean
184:18 - values in my original array
184:22 - but I made a mistake I named both the
184:25 - arrays as same
184:27 - so I need to change one of it
184:36 - so if I don't change and continue with
184:39 - the same names
184:40 - it will give me an error
184:45 - so I need to change
184:48 - so I'm gonna change it
184:50 - so
184:51 - lit
184:53 - the Boolean RS name be arrp denoting
184:57 - that it's a Boolean array now I'm going
185:00 - to
185:01 - do the action of filtering by writing
185:04 - the command new
185:06 - denotes the filtered array is equal to
185:09 - array name and in square brackets I'm
185:12 - gonna pass the Boolean array now I'm
185:14 - gonna print the new array
185:18 - so print new
185:22 - so I got
185:24 - the result as two elements corresponding
185:27 - to the True Values and excluding the
185:30 - elements corresponding to the false
185:33 - values
185:35 - so we observe that in the above example
185:41 - so the example will return
185:44 - 411 and 21
185:48 - because
185:53 - the values
185:57 - in the array
186:00 - corresponding
186:05 - to
186:09 - so corresponding to that
186:15 - indexes
186:22 - in the Boolean array
186:27 - were
186:28 - true
186:32 - so only 411 and 221 were filtered
186:40 - because the Boolean values corresponding
186:42 - to these elements were true let's look
186:45 - at another example now
186:49 - so in this example we'll create a filter
186:56 - now let's define a new sequence or
187:00 - declare a new sequence so let it be
187:06 - integers from 1 to 10
187:17 - so I have created a sequence
187:21 - now I'm going to use the filter method
187:26 - to create a filter and not use the
187:28 - Boolean list directly so I'm going to
187:31 - write list
187:32 - and this time I have to pass
187:35 - sorry I also need to write filter method
187:38 - so I have made a small error let me just
187:42 - Rectify my mistake
187:51 - so I've made a mistake and I have to
187:54 - correct it so let me just go back and
187:57 - write filter so I have to create a list
188:01 - so list and in list I have to write
188:04 - filter and filter I have to pass
188:10 - two sequences the Lambda function will
188:14 - generate a sequence a sequence which
188:17 - will contain Boolean values and the
188:20 - other sequence will be our original
188:22 - sequence
188:23 - so we got the result as
188:26 - 2 4 6 8 and then and we observe that
188:30 - this filter which we have created
188:32 - filters out the even elements from the
188:35 - array now let's create or let's create a
188:39 - filter to filter out the odd elements
188:42 - from the array
188:46 - so the procedure will be same we just
188:49 - need to change
188:50 - the condition in the Lambda function
188:53 - those who are not acquainted with Lambda
188:55 - function please refer to our
188:58 - python playlist
189:01 - so we just need to change the condition
189:03 - to not equal to 0 and we obtained the
189:07 - odd elements so we have filtered out the
189:10 - odd elements from the
189:12 - given sequence
189:14 - so that's how we filter array using
189:18 - the filter function
189:22 - of filter method
189:26 - so
189:29 - we demonstrated the use of Boolean index
189:32 - list and filter method for filtering an
189:35 - array
189:36 - that will be all for today this video is
189:38 - brought to you by programming knowledge
189:40 - please like comment share subscribe and
189:44 - hit the Bell button for updates and stay
189:47 - tuned with us for next lecture on numpy
189:49 - thank you hi guys welcome back to our
189:52 - course on numpy in our previous lecture
189:55 - we started our discussion on filtering
189:57 - of numpy arrays and we discussed
190:01 - two methods of filtering arrays that is
190:04 - using Boolean index list and filter
190:07 - method today we are going to look at
190:09 - another method that is the direct method
190:12 - so let's get started so filtering is a
190:15 - quite common task in numpy so there is
190:19 - an easy method to do it we can directly
190:22 - substitute the array instead of the
190:25 - iterable variable in our condition and
190:27 - it works just fine it will be clear when
190:30 - we look at some examples
190:33 - so let's move on to the code let me just
190:35 - write python3 and hit enter
190:39 - now
190:40 - I'm gonna import numpy
190:43 - as NP
190:46 - and hit enter
190:51 - now let's
190:56 - create a filter
190:59 - directly
191:01 - so creating filter directly from the
191:04 - array
191:05 - that's what we are gonna do
191:16 - so to create a filter
191:18 - we need an array first
191:28 - so let's create an array first to filter
191:30 - out the values from the array
191:32 - so we have to write array name
191:35 - or ARR
191:37 - or array or whatever you want
191:41 - I'm gonna avoid using array completely
191:44 - so I'm gonna write ARR is equal to NP
191:47 - dot array and I'm gonna pass a list to
191:50 - it
191:54 - so I have passed the list
191:58 - as you can see so I've created an array
192:03 - so here we
192:05 - won't use
192:06 - a Boolean index
192:09 - less so in previous lecture we filtered
192:13 - using Boolean index list and filter
192:16 - methods but here we won't use a Boolean
192:18 - index list
192:22 - will you do it directly because it's the
192:25 - direct approach now let's proceed to
192:28 - creating
192:29 - the filter
192:32 - or creating the filtered array
192:35 - so first we have to create a filter
192:39 - and then we can create a filter array
192:42 - so this is the filter so filter is equal
192:45 - to
192:46 - array name greater than 42 so it will
192:50 - filter all the elements which are
192:52 - greater than 42 and new array is
192:56 - used to store this result of the filter
192:59 - so
193:01 - note that filter actually filters a new
193:04 - array is actually storing the result of
193:07 - the filter
193:08 - so I'm gonna paint
193:10 - the new added
193:12 - here you can see that it's an empty list
193:15 - because there's no value which is
193:17 - greater than 42. now let's change the
193:20 - value and
193:23 - so it's now three so it will filter out
193:25 - all the elements which are greater than
193:28 - 3.
193:30 - so I've created a filter I've stored the
193:33 - result in a new array and I have printed
193:36 - the new arrays so all the elements
193:38 - greater than three were printed
193:41 - now you can see that I did not use a
193:45 - Boolean list directly in this example
193:48 - but let's understand
193:50 - what is actually happening at the back
193:53 - end
193:55 - so we need to observe we need to
193:57 - understand so please try to understand
193:59 - this clearly
194:03 - so I was saying that we did not use a
194:06 - Boolean index list
194:08 - directly
194:10 - but
194:12 - we still have a Boolean index list here
194:18 - it is not direct it's not visible to us
194:20 - but it is still present
194:23 - so let's see how
194:27 - so when we
194:36 - so when we execute it the command that
194:39 - is filtered is equal to array name or ER
194:42 - created in three it kind of creates a
194:46 - Boolean index list
194:51 - so the list is present but it is not
194:56 - visible to us
194:58 - so let me just print the result of this
195:01 - filter directly instead of storing the
195:04 - result in a new array so if I print
195:06 - filter I get
195:08 - a Boolean index list
195:11 - so a Boolean index list is present here
195:15 - but it's not visible to us
195:18 - and it's working in the back end
195:21 - so there is a Boolean index list but we
195:25 - did not create
195:26 - it explicitly we have not created a
195:30 - Boolean list directly as we did in the
195:33 - previous example
195:36 - so we can say that this is a direct
195:39 - method
195:42 - now let's see one more example
195:58 - so our objective in this example is to
196:01 - sort the even elements
196:04 - from
196:06 - the add a
196:08 - directly
196:09 - so we have to sort even element
196:12 - from the array and we have to follow the
196:15 - direct approach now I'm gonna write
196:18 - the command for the filter so filter is
196:21 - equal to
196:23 - array name mod of 2 equal to equal to 0
196:26 - because this is the condition to sort
196:28 - the even elements from the array
196:33 - now I'm gonna store the result in a new
196:35 - array
196:37 - and I'm gonna print the new array
196:42 - I made a little mistake here instead of
196:46 - giving the proper
196:49 - brackets I gave the square brackets
196:53 - so I have to rectify it and write it
196:55 - again
197:01 - so all the even elements have been
197:05 - displayed
197:07 - so we got the even values
197:10 - in the array
197:12 - or original array
197:16 - so similarly we can do it for the odd
197:19 - elements or the odd values
197:22 - so in today's lecture we covered the
197:25 - direct approach for filtering the array
197:28 - that will be all for today this video is
197:31 - brought to you by programming knowledge
197:33 - please like comment share subscribe and
197:36 - hit the Bell button for updates and stay
197:39 - tuned with us for next video thank you
197:42 - hi guys welcome back to our course on
197:45 - numpy in our previous lecture we started
197:47 - our discussion on filtering of numpy
197:50 - arrays and we discussed
197:53 - two methods of filtering arrays that is
197:56 - using Boolean index list and filter
197:58 - method today we are going to look at
198:01 - another method that is the direct method
198:04 - so let's get started so filtering is a
198:07 - quite common task in numpy
198:10 - so there is an easy method to do it we
198:13 - can directly substitute the array
198:15 - instead of the iterable variable in our
198:18 - condition and it works just fine it will
198:21 - be clear when we look at some examples
198:24 - so let's move on to the code let me just
198:27 - write python3 and hit enter
198:30 - now
198:32 - I'm gonna import numpy
198:35 - as NP
198:38 - and hit enter
198:43 - now let's
198:48 - create a filter
198:51 - directly
198:53 - so creating filter directly from the
198:56 - array
198:57 - that's what we are gonna do
199:07 - so to create a filter
199:10 - we need an array first
199:19 - so let's create an array first to filter
199:22 - out the values from the array
199:24 - so we have to write array name
199:27 - or ARR
199:29 - or array or whatever you want
199:33 - I'm gonna avoid using array completely
199:35 - so I'm gonna write ARR is equal to NP
199:39 - dot array and I'm gonna pass a list to
199:42 - it
199:46 - so I have passed the list
199:49 - as you can see so I've created an array
199:54 - so here we
199:57 - won't use
199:58 - a Boolean index
200:00 - less so in previous lecture we filtered
200:05 - using Boolean index list and filter
200:07 - methods but here we won't use a Boolean
200:10 - index list
200:14 - will you do it directly because it's the
200:17 - direct approach now let's proceed to
200:19 - creating
200:21 - the filter
200:23 - or creating the filtered array
200:27 - so first we have to create a filter
200:30 - and then we can create a filter array
200:33 - so this is the filter so filter is equal
200:36 - to
200:37 - array name greater than 42 so it will
200:41 - filter all the elements which are
200:43 - greater than 42 and new array is
200:48 - used to store this result of the filter
200:51 - so
200:52 - note that filter actually filters a new
200:56 - array is actually storing the result of
200:59 - the filter
201:00 - so I'm gonna paint
201:02 - the new added
201:04 - here you can see that it's an empty list
201:07 - because there's no value which is
201:09 - greater than 42. now let's change the
201:12 - value and
201:15 - so it's now three so it will filter out
201:17 - all the elements which are greater than
201:19 - 3.
201:22 - so I've created a filter I've stored the
201:24 - result in a new array and I have printed
201:28 - the new arrays so all the elements
201:30 - greater than three were printed
201:33 - now you can see that I did not use a
201:37 - Boolean list directly in this example
201:39 - but let's understand
201:42 - what is actually happening at the back
201:45 - end
201:47 - so we need to observe we need to
201:49 - understand so please try to understand
201:51 - this clearly
201:54 - so I was saying that we did not use a
201:58 - Boolean index list
202:00 - directly
202:02 - but
202:04 - we still have a Boolean index list here
202:09 - it is not direct it's not visible to us
202:12 - but it is still present
202:14 - so let's see how
202:19 - so when we
202:28 - so when we execute it the command that
202:31 - is filtered is equal to array name or
202:34 - error greater than three it kind of
202:37 - creates a Boolean index list
202:43 - so the list is present but it is not
202:48 - visible to us
202:50 - so let me just print the result of this
202:53 - filter directly instead of storing the
202:56 - result in a new array so if I print
202:58 - filter I get
203:00 - a Boolean index list
203:03 - so a Boolean index list is present here
203:07 - but it's not visible to us
203:09 - and it's working in the back end
203:13 - so there is a Boolean index list but we
203:16 - did not create
203:18 - it explicitly we have not created a
203:22 - Boolean list directly as we did in the
203:25 - previous example
203:28 - so we can say that this is a direct
203:31 - method
203:34 - now let's see one more example
203:49 - so our objective in this example is to
203:53 - sort the even elements
203:55 - from
203:58 - the add a
203:59 - directly
204:01 - so we have to sort even element
204:04 - from the array and we have to follow the
204:06 - direct approach now I'm gonna write
204:09 - the command for the filter so filter is
204:13 - equal to
204:14 - array name mod of 2 equal to equal to 0
204:18 - because this is the condition to sort
204:20 - the even elements from the array
204:24 - now I'm gonna store the result in a new
204:27 - array
204:29 - and I'm gonna print the new array
204:33 - I made a little mistake here instead of
204:38 - giving the proper
204:41 - brackets I gave the square brackets
204:45 - so I have to rectify it and write it
204:47 - again
204:53 - so all the even elements have been
204:56 - displayed
204:58 - so we got the even values
205:02 - in the array
205:04 - or original array
205:08 - so similarly we can do it for the odd
205:11 - elements or the odd values
205:14 - so in today's lecture we covered the
205:17 - direct approach for filtering the array
205:19 - that will be all for today this video is
205:23 - brought to you by programming knowledge
205:24 - please like comment share subscribe and
205:28 - hit the Bell button for updates and stay
205:30 - tuned with us for next video thank you
205:34 - hi guys welcome back to our course on
205:36 - numpy in our previous lecture we covered
205:40 - the direct method for filtering of numpy
205:43 - Aries and today we are going to do some
205:45 - more examples on array filtering so
205:49 - let's get started
205:52 - so we covered three methods of array
205:55 - filtering so far that is using Boolean
205:58 - index list the filter method and the
206:01 - direct method we also filtered the even
206:03 - and odd elements of a sequence using
206:06 - filter method and direct method now
206:08 - let's see how can we filter the even and
206:11 - odd elements of a sequence using the
206:14 - Boolean index list because in previous
206:16 - examples we used to specify the Boolean
206:19 - index list beforehand but now we are
206:23 - going to create Boolean index list using
206:27 - append method that is first of all we'll
206:30 - create an empty Boolean list and then
206:33 - we'll insert the element as true or
206:36 - false according to a certain given
206:39 - condition
206:41 - so let's move on to the coding path
206:45 - so I'm going to open my terminal write
206:47 - python3 and hit enter
206:49 - now I'm going to import
206:53 - numpy
206:56 - as NP and hit enter
207:04 - so let's
207:05 - create
207:10 - a filter
207:12 - Adi that will
207:15 - only
207:17 - return
207:19 - even values
207:22 - from
207:26 - the original array
207:29 - or original sequence so first of all we
207:33 - need to create an array
207:36 - and then we are going to create a filter
207:38 - array that will return only even values
207:41 - from that array
207:43 - so I've created an array
207:47 - I'm gonna hit enter
207:50 - now
207:52 - I'm going to create an empty filter
207:55 - first
208:00 - so the filter is empty it does not
208:03 - contain
208:04 - any Boolean value
208:06 - initially
208:10 - now I'll create
208:13 - a for Loop
208:17 - and if
208:20 - the element
208:25 - is divisible by 2 that is the mod is
208:30 - equal to equal to 0 then I'm gonna
208:33 - append
208:37 - True Value in the filtered array so if
208:42 - it's even
208:43 - the corresponding element in the
208:46 - filtered array will be true and if it is
208:49 - odd the corresponding value in the
208:53 - filter array will be false
208:57 - so we did not initially
209:00 - specify the value in the filter but we
209:05 - are appending the values based on
209:07 - certain conditions
209:22 - now I'm gonna store
209:24 - the values
209:26 - in the new array
209:38 - so I have
209:40 - stored the values in a new array
209:43 - it is giving me an error because
209:48 - of
209:50 - the wrong brackets I need to use a
209:53 - square bracket here
209:55 - so peace
209:57 - please keep these things in your mind
210:00 - while executing your code otherwise you
210:03 - will get an error like me
210:06 - so I need to change the brackets that I
210:10 - did and I'm gonna print the new array
210:13 - now so print new it is giving me all the
210:17 - even values in the array
210:20 - so we got the result
210:24 - as even elements
210:30 - let's understand
210:33 - what
210:34 - actually happened
210:41 - so this thing appears quite complicated
210:44 - when we observe it for the first time
210:47 - because you might be wondering why
210:51 - create an empty filter first and then
210:54 - insert the true or false values in it we
210:57 - do it because we don't know beforehand
211:00 - that what
211:02 - values are we gonna get
211:05 - so sometimes we have to take the array
211:07 - as input from the user so that's the
211:10 - case now what actually happened is the
211:13 - filter
211:14 - stored the Boolean values
211:19 - that were
211:22 - assigned with the help of loop or that
211:25 - would append it to the filter array
211:29 - so the array filter is nothing but a
211:32 - Boolean index list which was used to
211:35 - iterate
211:37 - which was used to filter
211:39 - the even elements from the array with
211:43 - the help of iteration
211:44 - and using a for Loop
211:48 - now for odd elements we need to
211:51 - follow the same procedure
211:53 - we just need to change the selection
211:56 - condition that is
211:58 - add a name
212:00 - or err
212:01 - or mod of 2 not equal to 0 in this case
212:06 - we have to append true
212:13 - so I have to change the condition
212:16 - so in case of
212:18 - not equal to 0
212:25 - I have to in case of not equal to 0 I
212:28 - have to store
212:31 - true
212:32 - or also I can do is in case of equal to
212:36 - equal to 0 I can append false and
212:39 - otherwise I can append true
212:42 - else filter dot append
212:48 - true
212:49 - so you can follow any of the two
212:52 - approaches
212:53 - that I have
212:55 - suggested
213:11 - so now I'm going to store the result in
213:14 - a new array
213:17 - and
213:19 - so it is giving me an error
213:24 - exactly it should give me an error
213:27 - because
213:28 - there are now 20 values in the filter
213:31 - because 10 were the initial values from
213:34 - the previous example and 10 values are
213:37 - from this example so filter has 20
213:41 - values
213:42 - which is why we are getting an error
213:47 - message so please be careful because you
213:49 - might do the same mistake now the error
213:53 - is that filter already contains some
213:57 - values and we
213:59 - added values to it so what you can do is
214:02 - that you can create a new filter
214:05 - and then
214:07 - you can
214:08 - store the result in a new array
214:11 - so I'm giving you the this thing as an
214:15 - assignment create a new array
214:18 - a new filter a new array instead of
214:21 - using the same code
214:25 - so this is your assignment
214:29 - so an assignment is to create a filter
214:33 - for filtering
214:35 - odd values
214:38 - or or elements from
214:41 - the same array which we
214:44 - used in this example now we have one
214:47 - more assignment for you so the second
214:49 - assignment is to create a filter
214:52 - for filtering
214:54 - the elements
214:57 - from the array in the given example
215:04 - so filtered elements from array in given
215:07 - example
215:12 - or in this video lecture
215:15 - which are
215:17 - greater
215:19 - then four
215:23 - so in this video we discussed some
215:26 - examples based on filtering using
215:30 - Boolean index list that will be all for
215:33 - today
215:33 - this video is brought to you by
215:35 - programming knowledge please like
215:37 - comment share subscribe and hit the Bell
215:40 - button for updates and stay tuned with
215:43 - us for next lecture thank you hi guys
215:45 - welcome back to our course on numpy in
215:48 - our last lecture we did some examples on
215:50 - array filtering and today we are going
215:53 - to study how to calculate mean median
215:56 - mode and standard deviation using numpy
216:00 - methods so let's get started
216:04 - so as you must be knowing mean median
216:08 - and mode are the measures of central
216:10 - location of data and standard deviation
216:13 - gives us the extent of deviation of the
216:15 - data about the central location these
216:18 - measures are of utmost important while
216:21 - analyzing any data
216:23 - so let's get started with the coding
216:26 - part let me open my terminal
216:28 - so I'm going to write Python 3 hit enter
216:31 - now I'm going to import numpy
216:35 - as NP
216:38 - so first of all
216:41 - let's
216:45 - talk about
216:48 - or let's take a look at the measures of
216:52 - central location
216:56 - so as you
216:57 - must have studied in statistics at some
217:00 - level about the majors of central
217:03 - location so there are three main majors
217:06 - of central location they are mean
217:09 - median and mode
217:12 - as we know the mean refers to the
217:15 - average value of the data
217:18 - similarly the median refers to the
217:20 - middle value of the data so median
217:23 - divides the data sets into two equal
217:26 - parts and finally the mode refers to the
217:30 - most common value it is also known as
217:34 - the most repeated value of the data sets
217:37 - now let's calculate the measures of
217:41 - central location using numpy methods for
217:44 - that we need to create an array first
217:47 - so let's create an array and calculate
217:49 - all three measures of central location
217:52 - for that particular array
217:55 - so I'm going to create an array with
217:57 - name X so X is equal to NP dot array and
218:01 - I'm going to pass a python list
218:04 - so this is our data
218:10 - so it can contain any random values but
218:13 - make sure that it had some repeated
218:15 - values so we calculate
218:18 - the mode
218:21 - otherwise it will be a multi-modal
218:26 - data set
218:34 - now let's start with calculation of mean
218:38 - so let's first calculate mean and we are
218:41 - going to use
218:44 - the standard formula
218:48 - so what is the standard formula standard
218:50 - formula is the one that you use like you
218:54 - calculate the sum and you divide by the
218:56 - number of
218:57 - samples or number of observations so
219:01 - this is not a numpy method it is the
219:03 - general formula that we use or we are
219:06 - using since fourth or fifth grades so we
219:09 - need to find the sum of all the samples
219:11 - or all the values and we have to divide
219:14 - by the number of values
219:17 - or the number of samples so
219:20 - let me just add all the values and
219:23 - divide it by
219:26 - the number of values so what is the
219:28 - number of L is one two three four five
219:30 - six seven eight nine ten eleven twelve
219:32 - thirteen fourteen fifteen so I have
219:35 - total 15 values or 15 samples so I have
219:38 - to divide by 15.
219:40 - so divided by 15 close the bracket and
219:43 - hit enter so this is the mean that is
219:48 - 3.5333333 and so on
219:52 - now let's use the mean method
219:56 - which is the method of numpy
219:59 - so I just need to write print in P dot
220:01 - mean
220:02 - and I have to pass the array name
220:05 - we can see that we obtain the same
220:09 - result in both the cases so I don't need
220:12 - to add all the values and divide it by
220:14 - the number of values because if we have
220:17 - a very large data set it will be
220:19 - difficult
220:21 - so
220:22 - it's easier to use the standard method
220:26 - offered by numpy let's calculate median
220:30 - now which is the middle value
220:33 - so to calculate the median we should
220:36 - have
220:38 - a sorted array
220:40 - now the question arises that why do we
220:42 - need a sorted array so if you are in a
220:46 - state to recall
220:47 - the method you followed in your
220:50 - primary school that we just need to sort
220:53 - the array in US sorted order whether
220:56 - ascending or descending and we just need
220:59 - to circle out
221:01 - the middle value so you need to count
221:03 - from beginning and count from back and
221:06 - the value where you meet
221:09 - by taking unit step at a time
221:12 - so that value will be the
221:15 - median and in case you get two values it
221:18 - will be the average of those two values
221:22 - so here I have obtained the array in a
221:26 - sorted order
221:28 - using the sort method of numpy now the
221:32 - middle value as you can clearly see is
221:34 - three so median of this data is 3.
221:39 - now let's use the median method
221:42 - for that I just need to write print
221:45 - NP dot median
221:48 - and I need to pass the array name
221:50 - so as you can see that the answer is 3.
221:55 - so now let's calculate or move on to
221:59 - mode
222:01 - thank you
222:08 - so let me just obtain the sorted array
222:11 - again
222:12 - as you can clearly see in the sorted
222:15 - array 2 is repeated
222:18 - five times so it is the most repeated
222:21 - value
222:22 - so mod of this data set or data is to
222:27 - now let's use the mod method
222:31 - now the procedure is same
222:44 - print NP dot mode and pass X but you got
222:48 - an error this time so here's the catch
222:51 - numpy does not offer any method to
222:55 - calculate
222:57 - mode
222:59 - so there is no inbuilt method in numpy
223:02 - to calculate mode so you must be
223:04 - wondering how to calculate more than
223:08 - I'll get back to that topic in a while
223:11 - first of all let's explicitly mention
223:15 - this error
223:16 - because there's a very high probability
223:18 - that you will make the same mistake and
223:21 - get the same error while calculating the
223:24 - majors of central location because other
223:27 - central location measures can be
223:29 - calculated by numpy methods but for this
223:33 - you need a scipy method called as mode
223:37 - so I got an error because mod is not an
223:41 - attribute of numpy it's an attribute of
223:44 - PSI Pi or Scientific Python we'll
223:47 - discuss this library in detail later on
223:50 - we will create a separate playlist for
223:53 - sci-fi
223:55 - for now just
223:58 - look at what I'm going to write and copy
224:01 - paste the same thing in your
224:04 - command prompt or your terminal or
224:07 - whatever ID you are using to implement
224:10 - this code so from PSI Pi import stats
224:15 - so stats is a module of PSI pi
224:19 - so print stats dot mod x so the result
224:23 - is 2 and the count is 5. this shows that
224:28 - the mod of the given data is to and it
224:32 - has occurred five times
224:34 - so it shows the mod as well as the count
224:37 - of that mod count just refers to the
224:40 - number of time a particular value occurs
224:44 - so don't be worried for now just copy
224:47 - paste the same thing if you are not able
224:49 - to understand it's not a big deal we are
224:51 - going to explain it in detail later on
224:55 - now let's move on to calculation of
224:57 - standard deviation standard deviation is
225:00 - a measure of
225:02 - deviation dispersion how much the data
225:06 - deviates from the central value
225:09 - in this case it's going to be mean
225:12 - because you can calculate standard
225:14 - deviation around mean median as well as
225:16 - node but this inbuilt method is only for
225:21 - mean
225:22 - because most important
225:25 - measure of standard deviation is
225:27 - standard deviation about mean
225:29 - so I just need to write print NP dot STD
225:32 - and I need to pass the array name and I
225:35 - got the result and this is the most
225:38 - important thing to note that it gives
225:41 - the standard deviation about mean
225:43 - now I have an assignment for you
225:47 - calculate
225:49 - the standard deviation
225:54 - using
225:58 - the correct formula
226:02 - so this time you don't need to use this
226:06 - inbuilt method you just do it using the
226:09 - standard procedure that you follow in
226:11 - probability and statistics and
226:14 - peace match both these values they will
226:18 - be same but I want you to calculate it
226:21 - manually
226:22 - so that you can verify the result and
226:26 - you need to check whether the
226:27 - theoretical value coincides with the
226:30 - calculated value
226:34 - so in today's lecture we covered the
226:37 - measures of central location that is
226:39 - mean median and mod and we also
226:43 - demonstrated
226:45 - the use of STD method for calculation of
226:49 - standard deviation that will be all for
226:51 - today this video is brought to you by
226:53 - programming knowledge please like
226:55 - comment share subscribe and hit the Bell
226:58 - button for updates and stay tuned with
227:00 - us for next lecture thank you hi guys
227:04 - welcome back to our course on numpy in
227:06 - our last lecture we covered the measures
227:09 - of central location as well as we
227:12 - calculated the standard deviation and in
227:14 - today's lecture I am going to explain
227:16 - and demonstrate the use of a range
227:20 - and Lin space methods of numpy so let's
227:24 - get started let me open my terminal
227:28 - so first of all I'm going to write
227:30 - python3 and hit enter
227:34 - so what is a range method
227:40 - that's going to be our first topic
227:42 - so numpy e range is one of the array
227:46 - creation routines in Python
227:52 - our equation routine is just a method to
227:56 - create an array
227:58 - so a range method is one of the array
228:00 - creation routines or array creation
228:02 - methods based on numerical ranges
228:06 - it creates an instance
228:09 - of
228:11 - ND array
228:14 - with
228:16 - evenly
228:18 - spaced
228:21 - values
228:22 - so it creates an instance of ND array
228:26 - with evenly spaced values and Returns
228:29 - the reference
228:31 - to that
228:33 - array
228:36 - in simpler words because I know that
228:38 - complicated definitions are a little
228:40 - difficult to understand
228:44 - so in very simple words or in beginners
228:48 - or true Keys words it returns a list of
228:52 - integers
228:53 - between
228:56 - the start and
228:59 - stop
229:01 - parameters
229:05 - so it returns a list of integers between
229:08 - the start and
229:11 - stop
229:12 - parameters or values including the start
229:16 - value but excluding
229:19 - the
229:21 - stop value or the end value
229:25 - so it's pretty simple now it's a method
229:28 - to create an array so that array will
229:32 - contain a list of values which will be
229:35 - evenly spaced
229:37 - and they will be between a start and a
229:42 - stop value so let me just write array is
229:45 - equal to NP dot arrange and pass a start
229:47 - value
229:48 - and a stock value
229:50 - sorry I have not imported num by as in p
229:54 - first so it's giving me an error let me
229:56 - just import an
229:58 - do the same thing again so array is
230:01 - equal to NP dot arrange and I need to
230:03 - pass 0 and 11 as start and stop value
230:05 - and I need to print the array so you can
230:08 - see that I pass 0 and 11 so I got all
230:12 - the integers between 0 and 10.
230:17 - and not 11 so 11 is not included
230:20 - so this returns us numbers from 1 to 10
230:24 - and one thing to note is that 11 is not
230:29 - included
230:34 - so that's an important observation and
230:36 - an important thing to keep in mind while
230:39 - working with events method if you might
230:42 - have observed e-range method is very
230:44 - similar to the python range method so if
230:48 - you are not acquainted with the range
230:49 - method please refer to our playlist on
230:53 - python
230:54 - another important attribute of the Aries
230:57 - method is the step size we can also
231:00 - specify the step size so let me just
231:03 - specify this step size as 2
231:07 - now I am printing the array again and
231:11 - now I got only the even values
231:16 - so note that this returns us
231:20 - the even values
231:22 - or the even numbers from 0 to
231:27 - 11.
231:32 - so whenever there's a question that
231:35 - create an array of even numbers between
231:40 - a starting and an ending value
231:43 - you can always use
231:46 - a range method and specify the step size
231:49 - as 2.
231:51 - so we can specify whatever step size we
231:54 - require
231:55 - now let's move on to the Lin space
231:58 - method
231:59 - so we discussed
232:01 - the arrange method which is very similar
232:03 - to the range method in Python and now we
232:06 - are going to move to Lin space method
232:09 - and see what is the difference between a
232:11 - range method and the Lin space method so
232:14 - the Lin space method returns evenly
232:17 - spaced points or elements
232:22 - between
232:26 - a start value and an end value so it
232:30 - returns evenly space points or elements
232:33 - between a start value and a stop value
232:35 - but an important thing to note here is
232:37 - that they don't need to be integers
232:42 - so arrange method always returns us
232:45 - integers but Lin space meth third will
232:48 - return us evenly spaced values or evenly
232:52 - spaced point but they will not be
232:55 - integers
232:57 - so the syntax is
233:00 - numpy alleys or NP dot Lin space we need
233:04 - to pass start stop and the number of
233:08 - elements or the number of points that we
233:11 - need or required
233:14 - so note that the difference between the
233:17 - Lin space
233:18 - and E range
233:20 - is that
233:23 - Lin space
233:25 - does not
233:27 - necessarily return
233:32 - integer values
233:34 - this is a very important point to
233:37 - emphasize that's why I am repeating it
233:39 - multiple times so that it gets into your
233:42 - head directly
233:44 - so don't confuse Lin space with
233:47 - e-arrange method because it returns
233:51 - integer values only
233:54 - so now I'm going to demonstrate the use
233:57 - of length space method
234:02 - so you need to follow the syntax as
234:05 - described earlier so the start is 0 and
234:09 - this 5. and number of values required
234:12 - are 10.
234:14 - so it gives me 10 values another
234:17 - important observation
234:20 - here is that
234:22 - it Returns the start value
234:25 - as well as the end value
234:30 - yes so that's another difference between
234:35 - lens space and e-range Method because
234:37 - e-range method excludes the end value
234:40 - while the Lin space method includes the
234:45 - end value
234:46 - now the next example is obtained 100
234:49 - points between 0 and 1 which are evenly
234:53 - spaced so this time I need to specify
234:57 - the start as 0 the end as 1 and
235:01 - the number of values required as 100 now
235:04 - I have printed
235:06 - the list
235:08 - so it gives me 100 values between 0 and
235:12 - 1. and it includes
235:15 - one
235:16 - that's the difference
235:19 - now I have an assignment for you
235:21 - obtained
235:23 - 50 evenly spaced values between 6 and 9
235:28 - using
235:30 - Lin space method
235:33 - so that's your assignment I hope you
235:36 - complete it
235:38 - so in today's lecture we started about a
235:42 - range and lens space methods of numpy
235:45 - and I demonstrated the use of both that
235:49 - will be all for today this video is
235:51 - brought to you by programming knowledge
235:53 - please like comment share subscribe and
235:56 - hit the Bell button for updates and stay
235:58 - tuned with us for next lecture thank you
236:01 - hi guys welcome back to our course on
236:03 - numpy in our previous lecture
236:07 - we studied about the a range and length
236:10 - space methods of numpy and today we are
236:13 - going to see how to create an array
236:15 - containing all values as zeros or ones
236:18 - and also how to create identity
236:22 - mattresses in numpy so let's get started
236:27 - so I've opened my terminal I'm going to
236:29 - write Python 3 hit enter and I also I'm
236:33 - going to import numpy as NP
236:39 - so our first job is to create a 1D array
236:44 - with all elements as zeros
236:49 - so creating a 1D array
236:51 - of
236:52 - all zeros
236:54 - or
236:56 - an array in which all the elements are
236:59 - 0.
237:03 - so the syntax is
237:07 - array name is equal to
237:10 - numpy Alias or NP Dot
237:15 - zeros
237:17 - and I need to pass the number of values
237:22 - so number of elements or number of
237:25 - values is going to be the parameter in
237:28 - this case
237:29 - now let's create an actual array by
237:33 - following the syntax so array name
237:37 - is equal to NP dot zeros and I'm going
237:40 - to pass 5 as the number of values and
237:44 - I'm going to print this array
237:47 - so I got the result as an array
237:50 - containing five zeros
237:53 - now let's create a 2d array or a matrix
237:56 - in which all the values are zeros
238:07 - foreign
238:15 - I need to pass a tuple
238:18 - to this method that is rows and columns
238:22 - in last case I only passed the number of
238:26 - elements but in 2D array we have rows as
238:29 - well as columns
238:31 - so we need to pass a tuple
238:35 - containing number of rows and number of
238:38 - columns so we need double brackets here
238:41 - because it's a tuple we are passing a
238:43 - tuple and not a scalar
238:47 - so the syntax is same
238:50 - with slight
238:53 - change
238:57 - so I have created a 2d array of all
239:01 - zeros containing three rows and four
239:03 - columns
239:04 - now let's create a 1D array
239:08 - of all ones
239:12 - or an array in which all the values are
239:15 - 1.
239:18 - so syntax is same as
239:22 - zeros
239:24 - but we need to replace the word zeros by
239:28 - ones
239:30 - so syntax is same as the previous
239:32 - example we just need to replace
239:36 - the word zeros by
239:40 - once
239:42 - it's same as we do in physics like we
239:46 - replace
239:47 - and one and M2 by q1 and Q2 and the
239:52 - formula changes from Newton's law of
239:55 - gravitation to Coulomb's law
239:58 - with different constants of cos but it's
240:01 - a slight change
240:04 - so please take a joke and let's move on
240:06 - so I need to write array name is equal
240:08 - to np.1 and I need to pass 5 because I'm
240:13 - creating an array of ones which contains
240:17 - five ones or in which the value 1 occurs
240:20 - five time and the only value present is
240:24 - 1. now let's create a 2d array of all
240:27 - ones so syntax is same
240:31 - we need to pass a tuple this time with
240:35 - number of rows and number of columns
240:38 - that we want
240:40 - so I have specified that I need
240:42 - an array of all ones a 2d array of all
240:46 - ones with three rows and four columns so
240:49 - I got the relevant or the required
240:52 - result
240:53 - now let's see
240:56 - that how can we create identity matrices
241:00 - so for those who don't know what is an
241:03 - identity mattress so it is a special
241:06 - type of mattress
241:08 - in which the diagonal elements are 1
241:13 - and rest of the elements are 0 and by
241:17 - diagonal I mean the main diagonal which
241:21 - starts from top of left side and ends at
241:26 - the bottom of right side because there
241:29 - are two diagonals but there is only one
241:31 - main diagonal
241:34 - in a matrix
241:37 - so we can use the I method to create
241:41 - the identity Matrix and in this case we
241:44 - have one parameter that is the order of
241:46 - Matrix because an identity Matrix will
241:49 - always be a square Matrix
241:54 - so it returns a matrix and not a vector
241:57 - so syntax is NP dot I and I need to
242:00 - specify order and order is 5 in this
242:03 - case
242:04 - so in today's lecture we studied how to
242:08 - create an array with all values as ones
242:11 - or zeros and also demonstrated the
242:15 - method to create an identity Matrix that
242:19 - will be all for today this video is
242:21 - brought to you by programming knowledge
242:22 - please like comment share subscribe and
242:26 - hit the Bell button for updates and stay
242:28 - tuned with us for next lecture thank you
242:31 - hi guys welcome back to our course on
242:33 - numpy in our previous lecture we studied
242:36 - how to create an array of all zeros and
242:39 - ones
242:42 - identity mattresses and today we are
242:45 - going to get acquainted to random module
242:49 - in numpy and it's related methods so
242:53 - let's get started
242:55 - so first of all what are random numbers
242:57 - so Random means something which can't be
243:00 - predicted with help of logic it does not
243:03 - necessarily mean getting a different
243:06 - number every time or a different value
243:08 - every time numpy offers the module
243:11 - random to work with random numbers
243:14 - now let's try to understand the
243:17 - difference between true random and
243:19 - pseudo-random we all know that computers
243:22 - execute programs and programs are a set
243:25 - of instructions with definite meaning
243:27 - so programs are used to implement some
243:30 - algorithms to solve specific problems so
243:34 - there must be an algorithm to generate a
243:37 - random number now the question arises if
243:40 - some algorithm or program is used to
243:43 - generate a random number the random
243:45 - number generated with the help of
243:48 - algorithm can be predicted so it's not
243:51 - true random because as per the
243:54 - definition of the random number we can't
243:56 - predict random number with any kind of
243:58 - logic so we can say that the random
244:02 - numbers generated by algorithms on our
244:05 - computers are not true randoms they are
244:09 - referred to as
244:11 - pseudo-randoms or false so whenever we
244:14 - work with randoms in our programs we
244:17 - work with pseudorandoms
244:19 - now let's move on to the coding part
244:23 - so let me write Python 3 hit enter now
244:28 - let's
244:30 - generate
244:33 - a random
244:34 - number
244:38 - with type
244:42 - float and by using
244:45 - Rand method
244:47 - so we are going to generate a random
244:49 - number which will be of the type float
244:51 - and we'll do it with the help of Rand
244:54 - method of the random module of numpy so
244:58 - I'm going to import numpy S and P and
245:01 - write x equal to random
245:05 - Dot
245:07 - Rand
245:09 - and hit enter
245:12 - so here one thing to note is that it
245:15 - gives us an error because we have not
245:18 - imported
245:19 - the random module directly from numpy so
245:23 - we need to use numpy Alias with random
245:27 - and Rand so I am going to write NP dot
245:30 - random dot Rand
245:32 - method
245:33 - and I'm going to print X now so I got a
245:36 - random number
245:38 - so note that
245:40 - this returns
245:43 - a random
245:45 - number
245:47 - between
245:49 - 0 to 1 and it's of the type float
245:53 - So Random Number of the type float
245:55 - between 0 and 1.
245:58 - so now I'm going to show you another
246:01 - method to import random directly
246:06 - so now let's import random directly so
246:09 - we don't need to use NP
246:12 - in this case we don't need an alias we
246:15 - can just write random dot Rand directly
246:19 - so for that we have to import the random
246:21 - module directly from numpy
246:27 - so in this case I'm going to write from
246:30 - numpy
246:32 - import
246:35 - random
246:38 - so from numpy import random
246:42 - so now I can directly use random dot
246:46 - Rand method and I don't need to write NP
246:49 - Dot random.rand
246:53 - so directly write random dot brand and
246:57 - print the value of variable in which you
247:00 - have stored the result so I got the
247:02 - random number
247:05 - so note that
247:09 - the values
247:10 - are different so the values in both the
247:15 - cases are different because they are
247:17 - working with random numbers and it
247:20 - absolutely makes sense to get a
247:22 - different value each time we are calling
247:25 - the function
247:28 - so we are getting different values and
247:31 - they are correct
247:35 - so there's an assignment for you
247:38 - generate a random number between
247:42 - 0 and 100
247:46 - sorry it is 0 and 1 I have just missed
247:49 - the decimal and it should be of type
247:52 - float
247:54 - so today's lecture was an introduction
247:57 - to the random module
247:59 - and use of Rand function in numpy that's
248:03 - all for today this video is brought to
248:05 - you by programming knowledge please like
248:07 - comment share subscribe and hit the Bell
248:10 - button for updates and stay tuned with
248:12 - us for next lecture thank you
248:15 - hi guys welcome back to our course on
248:18 - numpy in our previous lecture we started
248:21 - with the random module in Python and I
248:25 - demonstrated the use of rant method of
248:29 - random module to generate a random
248:31 - number today we are going to cover brand
248:33 - method in detail so let's get started
248:37 - let me just write python3 hit enter now
248:41 - I'm going to import
248:42 - numpy as NP
248:46 - and
248:48 - let's start our discussion on plant
248:51 - function
248:54 - or the run method
248:57 - so the run method returns
249:02 - random number or numbers or I can say
249:05 - that random sample or samples of type
249:11 - float
249:13 - between
249:16 - 0 and 1. so it returns
249:20 - random samples of type float between 0
249:23 - and 1.
249:31 - so samples are taken from a uniform
249:34 - distribution this is a very important
249:37 - point
249:38 - so it returns
249:40 - random samples of type float between 0
249:43 - and 1 and samples are taken from a
249:46 - uniform distribution we have a lot of
249:49 - distribution of different kinds and this
249:52 - Rand function takes samples from a
249:54 - uniform distribution
249:56 - so the syntax is x equal to NP dot
249:59 - random dot brand as discussed in the
250:02 - previous lecture now we have to print X
250:05 - to get a random number between 0 and 1.
250:11 - so now what if we want more than one
250:15 - sample
250:17 - so this
250:19 - example generated one random number now
250:23 - what if I want an array of random
250:26 - numbers between 0 and 1.
250:30 - and the samples which belong to a
250:33 - uniform distribution
250:35 - so the syntax is NP dot random dot Rand
250:40 - and I need to
250:42 - specify the number of samples
250:46 - so now let's generate five random
250:49 - numbers
250:51 - of type float
250:54 - between 0 and 1. so the syntax is
251:02 - X is equal to
251:06 - NP dot random dot rant and I need to
251:10 - pass 5 as parameter
251:13 - denoting that we are going to generate
251:15 - five random numbers so I got the result
251:23 - so we get a list as a result
251:30 - now let's generate a 2d array or a
251:34 - matrix
251:36 - with the help of Rand method
251:39 - and all the values of that Matrix
251:44 - will range between 0 and 1. they will be
251:48 - random and they will be the samples of a
251:52 - uniform distribution
251:54 - now I just need to write x equal to NP
251:56 - dot random dot Rand and I need to pass
252:00 - rows as well as columns and I need to
252:03 - print X so I got the result as a
252:08 - Square Matrix
252:10 - because I have passed equal number of
252:13 - rows and columns
252:15 - but you can pass
252:17 - different
252:19 - parameters like less value of row and
252:22 - more value of
252:24 - column or vice versa so we got a matrix
252:28 - as a result with five rows and five
252:31 - columns
252:35 - so now there is an assignment for you
252:37 - create a matrix with the help of Rand
252:39 - method
252:41 - of two rows and one column so in today's
252:45 - lecture we covered the rant method of
252:48 - the random module in detail that will be
252:51 - all for today this video is brought to
252:53 - you by programming knowledge please like
252:55 - comment share subscribe and hit the Bell
252:57 - button for updates and stay tuned with
253:00 - us for next lecture thank you
253:03 - hi guys welcome back to our course on
253:05 - numpy in our previous lecture we covered
253:08 - the rant n method and today we are going
253:11 - to cover the rant n method of the random
253:14 - module of the numpy and we'll try to
253:17 - understand what is the difference
253:18 - between the rant method and the Rand and
253:22 - Method so let's get started
253:26 - so let me just write Python 3 and hit
253:29 - enter
253:30 - now I am going to import numpy
253:34 - as
253:35 - NP
253:37 - and hit enter so I've imported the numpy
253:40 - library
253:42 - now
253:43 - the numpy
253:45 - Dot
253:47 - random
253:48 - Dot Rand in method
253:54 - here we have not imported the random
253:57 - module directly so we will use
254:00 - numpy or NP dot random dot friend in
254:06 - as the whole syntax
254:08 - so it creates an array of specified
254:11 - shape and
254:13 - fills it
254:15 - with
254:18 - values or numbers
254:26 - as per the standard
254:29 - normal distribution
254:40 - so it creates an array of the specified
254:43 - shape and fills it with the values as
254:46 - per the standard normal distribution now
254:49 - if you recall in case of the Rand method
254:52 - it fills the array
254:56 - with values as per the standard uniform
254:59 - distribution this is a very important
255:02 - difference between the Rand
255:04 - and the rant in method
255:07 - so one important
255:09 - thing to note is that it fills the array
255:12 - with random floats
255:14 - sampled from
255:18 - univariate
255:21 - normal
255:24 - or we can say gaussian
255:29 - so the rat and Method take samples
255:33 - from a normal or gaussian distribution
255:41 - and mean of that gaussian or normal
255:45 - distribution is 0 and the variance is 1
255:48 - will cover the uniform and normal
255:52 - distribution later on
255:55 - this is just a brief intro
256:00 - now
256:01 - note that normal distribution is a
256:06 - distribution
256:09 - which is continuous in nature we have a
256:13 - lot of different kinds of distributions
256:16 - in statistics like
256:19 - uniform distribution normal distribution
256:22 - poisson distribution relics distribution
256:27 - Etc
256:28 - so
256:29 - normal distribution is a kind of
256:32 - continuous distribution and it has a
256:35 - probability density function
256:38 - as opposed to the discrete distributions
256:41 - which have a corresponding probability
256:44 - Mass function
256:49 - now an important
256:52 - thing to note is that if we provide no
256:56 - argument in this brand in method then it
257:00 - will return a randomly generated float
257:04 - which will be sampled from
257:07 - the distribution or we can say from the
257:10 - normal or gaussian distribution so this
257:13 - is a very important thing to note
257:16 - so if we provide no argument then a
257:18 - single float randomly sampled from the
257:21 - distribution is returned
257:25 - so please keep a note of that
257:29 - now we'll start with
257:35 - the code and first of all I'm going to
257:38 - pass no argument so I'll write X is
257:42 - equal to NP dot random
257:46 - Dot Rand
257:48 - in
257:49 - and I'm going to pass known parameter
257:52 - and I am going to print the value of x
257:56 - so I got one
257:59 - random number
258:00 - which is a sampled from a normal
258:04 - distribution which is centered around
258:06 - zero with mean 0 and variance 1. now
258:12 - I'll create a 1D array
258:15 - so I need to pass one parameter
258:18 - and I need to print the value of x so
258:20 - this is the result
258:23 - so as a result
258:25 - we got a 1D array
258:27 - or I can say that a row vector
258:34 - so the result is a row vector or a 1D
258:37 - array similarly if I want to create a 2d
258:40 - array I need to pass two parameter that
258:43 - is the row count as well as the column
258:46 - count
258:48 - so now let's create it to the array or a
258:50 - matrix
258:52 - so I need to follow the same syntax I
258:55 - just need to give two parameters this
258:58 - time
259:00 - so let it be four and three I'll print
259:03 - so I got a matrix with four rows and
259:07 - three columns
259:08 - so the result is a 2D array
259:15 - or I can say a matrix
259:22 - now let's create a 3D array
259:25 - so the syntax will be same
259:27 - I just need to pass three parameters
259:30 - this time
259:33 - because a 3D array has three dimensions
259:39 - so I need to follow the same syntax I
259:42 - just need to give three parameters
259:45 - and I'll print the value of x again
259:51 - so you can see that
259:53 - I have got a 3D array as a result
260:00 - so result is a 3D array or I can say
260:03 - that a third order tensor
260:06 - because if you recall
260:10 - in higher dimension
260:12 - end order array is referred to as nth
260:16 - order answer
260:18 - now I've got an assignment for you
260:19 - create a 4D array randomly using the
260:24 - Rand n method
260:28 - and print it
260:30 - so in today's lecture we covered the use
260:33 - of Rand and method of the random module
260:36 - of numpy that will be all for today this
260:39 - video is brought to you by programming
260:41 - knowledge please like comment share
260:43 - subscribe and hit the Bell button for
260:45 - updates and stay tuned with us for next
260:48 - lecture thank you hi guys welcome back
260:52 - to our course on numpy in our previous
260:54 - lecture we covered the rant n method and
260:57 - today we are going to learn about the
260:59 - rant end method of the random module of
261:02 - numpy so let's get started
261:05 - so let me just write python3 and hit
261:08 - enter
261:10 - now I'm going to import numpy
261:15 - so I'm going to import numpy as NP hit
261:18 - enter
261:21 - so today we are gonna discuss about the
261:24 - round end method
261:27 - so round end
261:29 - stands for random integer and it is an
261:34 - inbuilt function offered
261:37 - by the random module
261:40 - of numpy
261:42 - so it's an inbuilt function like Rand
261:45 - and brand n and it's also
261:49 - a function of the random module of numpy
261:52 - so you know that the random module gives
261:56 - access
261:58 - to various
262:01 - useful
262:03 - functions so the module random gives
262:07 - access to various useful functions and
262:10 - one of them
262:13 - is
262:17 - Rand and
262:19 - which is able to Generate random integer
262:23 - numbers
262:24 - so the rant and Rand in functions
262:27 - generated
262:28 - float values but this function generates
262:32 - random numbers
262:34 - and they are of type int
262:40 - now let's move on to the syntax
262:43 - so the syntax is
262:45 - you have to write NP or numpy dot random
262:50 - dot Rand int
262:54 - and you have to pass the start
262:57 - to stop
262:59 - value
263:02 - so you have to give a range within which
263:04 - you want to get a random integer
263:07 - so this is the syntax
263:11 - and also note that both the start and
263:14 - stop values
263:17 - must be
263:20 - integers
263:22 - so the start stop values indicating the
263:25 - range must be integer values otherwise
263:28 - you will get an error while executing
263:31 - the statements
263:33 - so now let's just write X is equal to NP
263:37 - dot random Dot
263:40 - Rand int
263:43 - so dot Rand int
263:46 - and pass to start as well as the stop
263:50 - value
263:53 - and now I'm going to print the value of
263:56 - this randomly generated integer so it's
263:59 - 8 in this case you may get a different
264:01 - value because we are working with random
264:04 - numbers
264:05 - now let's move on to some more examples
264:11 - so next example is
264:13 - generate
264:16 - a random
264:18 - number
264:19 - between
264:23 - minus 10 and
264:26 - minus 1 and it should be of the type
264:30 - integer so I'm gonna write X is equal to
264:34 - NP dot random dot run in and I'm going
264:38 - to pass the start as minus 10 and the
264:41 - stop as minus 1.
264:44 - now I'm going to print the value of x
264:50 - and it comes out to be
264:52 - -3 so I have generated a random number
264:55 - of type integer between minus 10 and
264:58 - minus 1. now let's see what happens when
265:01 - we pass
265:03 - non-integer values
265:09 - so x equal to NP Dot random dot Rand IND
265:15 - and I'm going to pass non-integer values
265:17 - let's see what happens
265:19 - ideally it should give us an error
265:23 - so I'm going to pass the float values
265:27 - and I'm going to print the value of x
265:29 - now
265:35 - so I'm going to write print
265:37 - X
265:39 - and hit enter
265:41 - now you guys must be wondering that we
265:44 - got a result but we should get an error
265:47 - so this is because there might be an
265:49 - update
265:52 - I guess now we can use compatible data
265:56 - types as start and stop values now let's
265:59 - try using non-compatible data types like
266:03 - string
266:04 - or character values so I'm going to pass
266:09 - character values this time
266:13 - or string values
266:17 - so it gave me an error
266:20 - so invalid literal for INT with base 10
266:23 - so this is an non-compatible data type
266:27 - so note that
266:29 - we got an error with non-compatible data
266:34 - type and in the previous versions if you
266:38 - try float values also you will get an
266:40 - error because now there might be an
266:43 - update but in previous version
266:45 - it gave us an error now there's an
266:49 - assignment for you
266:51 - generate
266:52 - a random
266:54 - number
266:55 - between
266:58 - minus 5 and
267:01 - Let It Be 4 and 4 using rant end method
267:07 - so in today's lecture we covered the
267:10 - rant end or the random integer method of
267:13 - random module of numpy that will be all
267:16 - for today
267:17 - this video is brought to you by
267:18 - programming knowledge please like
267:20 - comment share subscribe and hit the Bell
267:23 - button for updates and stay tuned with
267:25 - us for next lecture thank you
267:28 - hi guys welcome back to our course on
267:30 - numpy in our previous lecture we covered
267:33 - the rant end method and today we are
267:36 - going to do some more examples
267:38 - based on the methods offered by the
267:41 - random module of numpa so let's get
267:44 - started
267:46 - so let me just write python3 hit enter
267:49 - now I'm going to import
267:52 - numpy as NP and hit enter
267:57 - now today's topic is
267:59 - some more examples
268:04 - on the methods
268:07 - offered by the random module of numpy
268:13 - so we'll try to do some mixed examples
268:15 - so first question is create
268:20 - a 1D
268:23 - numpy
268:26 - random
268:28 - array
268:30 - and
268:32 - sort
268:34 - it
268:36 - so we have to create a 1D numpy random
268:39 - array and we need to sort it so let's
268:41 - move on to the solution first of all
268:44 - let's create the array
268:46 - let the RN name be a so a is equal to NP
268:50 - dot random dot Rand
268:53 - and let the number of elements be six
268:56 - now let's print
268:58 - the sorted array
269:01 - so I have to write print and in bracket
269:03 - I have to pass NP dot sort and in sort I
269:07 - have to pass e so this is the sorted
269:09 - array
269:12 - you can see that it has been sorted
269:14 - according to the ascending order so if
269:17 - we got the sorted array and we use
269:23 - Rand method
269:25 - to create a random numpy array
269:33 - or we can say we use the Rand method of
269:36 - the random module of numpy to generate a
269:40 - random array and we used the sort method
269:48 - of numpy
269:50 - to sort the array so this was a mixed
269:53 - example
269:55 - now let's move on to the next problem
270:05 - so next problem is
270:08 - problem number two
270:10 - create
270:13 - a 2d
270:18 - Matrix of dimensions
270:22 - 2 cross 3 that means two rows and three
270:25 - columns
270:27 - so create a 2d array or a matrix
270:32 - with Dimension 2 comma 3
270:36 - that contains six random numbers between
270:40 - two and six
270:41 - so let's move on to the solution
270:44 - so I have to write array name or ARR is
270:48 - equal to NP dot random Dot
270:52 - Rand
270:57 - this time I need an array that contains
271:00 - integer values and I have to pass
271:04 - the start stop as two and six and I have
271:08 - to pass the dimensions of array as a
271:11 - tuple
271:12 - so that is 2 comma 3. Now I'm going to
271:15 - print this array
271:17 - so you can see that I got a 2d array
271:20 - with Dimensions 2 comma 3 or 2 rows and
271:24 - three columns and it contains random
271:27 - numbers or random integers between 2 and
271:31 - 6.
271:34 - so here we constructed a 2d array or
271:37 - Matrix with help of Rand int method
271:44 - now let's move on to our third
271:47 - example or third problem
271:53 - so problem number third is
271:56 - use
271:57 - numpy
272:00 - random
272:03 - number
272:04 - function
272:07 - to generate
272:10 - at least
272:13 - 1000
272:15 - numbers
272:17 - between
272:20 - the range
272:21 - of
272:23 - 1
272:24 - 2
272:27 - 1 lakh or hundred thousand
272:31 - and after generating we need to perform
272:35 - some operations
272:39 - so we have to generate
272:43 - an array of thousand numbers and the
272:45 - range is 1 to 1 lakh or hundred thousand
272:48 - and we need to perform some operations
272:51 - on it so let's move on to solution so
272:54 - first of all let's create
272:57 - the required array so I'm going to write
272:59 - ARR is equal to NP Dot
273:03 - random dot Rand int and I am going to
273:08 - pass start
273:10 - stop
273:13 - and the number of elements
273:18 - so in this case it's
273:20 - 1000
273:21 - so size is 1000.
273:26 - now the first operation is
273:29 - or I can say that the first part of the
273:33 - question is to
273:36 - sort
273:39 - these elements so I have created
273:43 - an array with random integer numbers
273:45 - from 1 to
273:48 - 100
273:49 - 000 and now I need to sort these
273:51 - elements and store them in a new array
273:54 - so the new array name or ARR new is
273:57 - equal to NP dot sort
274:00 - and I'm going to pass the RNA
274:03 - now I'm going to print
274:08 - the original array first
274:11 - so you can see that
274:13 - it contains
274:16 - randomly distributed numbers and I'm
274:19 - going to print the new array now
274:21 - so it is sorted I'll scroll so that you
274:26 - can see clearly the first one
274:29 - was there randomly arranged numbers and
274:33 - second one is the sorted array
274:37 - now the second part is to determine
274:40 - the maximum and minimum element
274:49 - so part 2 is to determine the maximum
274:53 - and minimum element from this array so
274:57 - we need to write Min element or mean Le
275:00 - whatever variable name you want to give
275:03 - and that is equal to NP dot Min and we
275:06 - need to pass the array name
275:08 - and similarly for the max just replace
275:10 - the Min by Max
275:13 - and I'm going to print these values now
275:17 - so print Min Ellie as well as print Max
275:20 - early so the minimum element is 268 and
275:24 - the maximum element is
275:27 - 999.05 you may get different values as
275:31 - we are working with random numbers now
275:33 - the third part of the question is to
275:36 - determine the average
275:38 - or we can say the mean
275:42 - so for that I have to write
275:46 - err mean or whatever variable name
275:50 - is equal to NP dot mean and I have to
275:53 - pass the array name that is err or now
275:56 - I'll print it
276:05 - so the mean of all the values is around
276:09 - 50 252
276:13 - .304 and now fourth part of the question
276:16 - is an assignment for you that is find
276:19 - the mod the median and standard
276:22 - deviation
276:23 - for this data
276:26 - contained in the array
276:29 - so in today's lecture we solved some
276:31 - questions based on the methods offered
276:34 - by the random module of numpy that will
276:37 - be all for today this video is brought
276:39 - to you by programming knowledge please
276:41 - like comment share subscribe and hit the
276:44 - Bell button for updates and stay tuned
276:46 - with us for next lecture thanks hi guys
276:50 - welcome back to our course on numpy in
276:52 - our previous lecture we solved some
276:54 - examples based on the methods offered by
276:58 - the random module of numpy and today we
277:01 - are going to take a look at random
277:04 - permutations
277:05 - so let's get started
277:09 - today we are going to execute our code
277:11 - in the Jupiter notebook I'll teach you
277:14 - how to set up jupyter notebook in the
277:17 - next lecture
277:18 - so let's start with today's topic so a
277:22 - random permutation refers to an
277:24 - arrangement of elements for example
277:29 - take an array with the values 4 3 2 1 so
277:33 - it is a random permutation of
277:36 - one two three four and vice versa so
277:41 - just with a sequence we can make several
277:45 - different arrangements or combinations
277:48 - so they are called as permutations
277:51 - so a lot of other permutations are
277:54 - possible as well
277:57 - but
278:00 - the numpy methods which we are going to
278:03 - study today they give only one
278:06 - permutation on passing the sequence
278:11 - so we get only one random permutation on
278:15 - passing a sequence or an array
278:24 - so a lot of permutation are possible
278:26 - that can be calculated using the formula
278:30 - npx
278:31 - but here we'll get only one random
278:34 - permutation by using methods of numpy
278:38 - random module So numpy Random module has
278:42 - two methods to find out the random
278:45 - permutation the first method is the
278:48 - shuffle method
278:49 - so for that I need to create an array
278:52 - first so I've created an array and now
278:56 - to get a permutation I need to write NP
278:59 - dot random dot Shuffle and I have to
279:02 - pass the array name
279:03 - now I'm going to print
279:08 - the shuffled array first to get a
279:11 - permutation
279:14 - so it gave me an error because I have
279:17 - not imported numpy so let me just import
279:20 - numpy as NP first
279:24 - and let me run this cell again
279:32 - now let me just print
279:34 - the array after shuffling
279:38 - so I got the result
279:41 - as four two one three five which is a
279:43 - permutation of one two three four five
279:45 - also note that this Shuffle method
279:49 - makes changes to the original array so
279:52 - if I write print in P dot random dot
279:54 - Shuffle and I pass the array name I'll
279:56 - get no result or the result as none
280:00 - now the second method is using the
280:03 - permutation method so now let's create
280:06 - an array again the same array
280:09 - we created
280:11 - the same array again because it has been
280:14 - shuffled so
280:17 - now I created the array again and I use
280:21 - the method permutation so I need to
280:24 - write NP dot random dot permutation and
280:26 - I need to pass the array name as ARR so
280:29 - I got another permutation of one two
280:32 - three four five
280:34 - now let me print the original array as
280:37 - well so I'll print
280:39 - array name or ARR
280:44 - and I'll hit enter or run this
280:48 - cell by shift plus enter now I got the
280:51 - original array as well as you can see
280:54 - the array after permutation now shuffled
280:58 - array
280:59 - makes changes to the original array
281:02 - while the permutation method does not
281:04 - make changes to the original array
281:06 - please note this this is a very
281:09 - important observation to make also note
281:12 - that if you want changes in original
281:15 - array you need to use the shuffle method
281:18 - and if you don't want any changes in the
281:22 - original array you need to use the
281:25 - permutation method because you need to
281:29 - choose according to the situation that
281:32 - you are in now there's an assignment for
281:35 - you create an array
281:38 - using
281:40 - rant end
281:42 - method
281:47 - so create an array using the Run Inc
281:49 - method of the random module of numpy
281:52 - sort that array using
281:55 - sort method
281:59 - and
282:02 - the third objective is to find the
282:05 - random permutation for that
282:07 - Adi
282:17 - or distorted array
282:20 - so in today's lecture we covered random
282:23 - permutations and the shuffle and
282:26 - permutation method
282:28 - to obtain a random permutation that will
282:31 - be all for today this video is brought
282:32 - to you by programming knowledge please
282:34 - like comment share subscribe and hit the
282:37 - Bell button for updates and stay tuned
282:39 - with also next lecture thank you
282:42 - hi guys welcome back to our course on um
282:45 - bye in our previous lecture we covered
282:47 - random permutations and today I am going
282:50 - to teach you how to install Anaconda get
282:54 - started with the Jupiter notebook and
282:57 - how to install C bone and matplotlip
283:00 - libraries
283:01 - so let's get started
283:04 - so I'm sharing my screen I'm going to
283:07 - Safari
283:10 - so you can go to your browser and you
283:13 - can search Anaconda
283:17 - so it's showing the name of website as I
283:20 - had already installed
283:22 - so you can see the first search result
283:25 - as the name of the website now this is
283:28 - the website or the official website for
283:31 - installing the Anaconda package
283:34 - so this is the website and you can click
283:37 - the download since I'm using a Mac so
283:41 - I'll install it for Mac
283:43 - if you are using some different
283:45 - operating system it will show you the
283:49 - package corresponding to that particular
283:53 - operating system now it's downloading
283:57 - so it's of around
283:59 - 620 MB for Mac OS users it may vary
284:05 - according to whatever operating system
284:08 - you are using
284:10 - since I have already installed I am
284:13 - canceling the download but you need to
284:15 - complete the download
284:18 - so there's one other method to download
284:22 - Anaconda if you are using a Mac with and
284:27 - you have Homebrew support
284:31 - so go to home brew and search Anaconda
284:37 - so you will get a command to install
284:40 - Anaconda so just copy it
284:43 - open your terminal
284:48 - so I'm going to open my terminal and
284:50 - just paste the command and hit enter
284:55 - so paste the command
284:58 - and hit
285:00 - enter
285:02 - now it's taking a little bit time here
285:10 - the running View Auto update
285:15 - so it has updated and it's showing
285:18 - cast Anaconda is already installed
285:21 - because I have already installed
285:23 - Anaconda
285:25 - so it's already installed
285:29 - now
285:32 - let's move on to
285:35 - installation of
285:43 - libraries that are c bond and
285:48 - matplotlib you can install these
285:51 - libraries using pip installer package or
285:55 - anaconda
285:57 - so here I'll be installing them using
285:59 - pip installer package first so I need to
286:03 - write pip install c bond to install c
286:06 - bond
286:08 - so it shows requirement already
286:10 - satisfied because it's already installed
286:13 - in my system
286:14 - now similarly for matplotlib I have to
286:18 - write pip install matplotlib
286:23 - so it will show requirement already
286:27 - satisfied again because I have already
286:30 - satisfied these libraries
286:34 - now let's see how to install them using
286:39 - Anaconda
286:41 - so if you want to use Anaconda for
286:44 - installing
286:46 - these
286:47 - libraries
286:52 - so you need to write
286:55 - the command
286:59 - conda
287:00 - installed
287:03 - C bone
287:07 - and
287:08 - the process will take some time
287:12 - so there is some background process
287:15 - going on
287:24 - so there will be some processing
287:26 - so it shows done
287:31 - so it's asking for a permission to
287:33 - install new packages since I have
287:36 - already installed so I won't be
287:38 - proceeding with this but since you are
287:41 - installing it for the first time you
287:43 - have to proceed with why
287:46 - so you need to proceed with y and
287:49 - similarly
287:51 - you need to install
287:53 - matplotlib using the command conda
287:57 - install matplotlink
287:59 - so the process is similar you just need
288:02 - to replace
288:03 - c bond with matplotlib so the command
288:07 - will be conda
288:10 - installed
288:13 - matplotlib
288:31 - let me clear the screen
288:38 - now let's
288:41 - open
288:43 - the Anaconda Navigator
288:49 - so open the Anaconda Navigator
288:56 - and close the terminal
289:02 - so I've opened the Anaconda Navigator
289:04 - and it's showing a lot of options but we
289:07 - have to select the notebook and click
289:09 - launch
289:11 - so it will take a minute
289:13 - or 30 seconds
289:15 - and it will open in your browser
289:20 - don't worry this process is offline it
289:23 - doesn't require internet connection
289:28 - so just create a new folder
289:31 - wherever you want to store your code
289:34 - so I've created a new Untitled folder
289:38 - for that
289:40 - so I'll just open this folder by
289:42 - clicking on it
289:45 - so it shows the notebook list is empty
289:47 - and I'm going to create a new notebook
289:49 - now
289:51 - now this is a cell
289:54 - so in this cell I am going to import
289:57 - numpy as NP
290:01 - I'm also going to import
290:04 - c bond as
290:08 - SNS
290:10 - and import
290:11 - matplotlib dot Pi plot
290:17 - as PLT and I am going to
290:21 - hit shift and enter to run this cell so
290:25 - it gave me no error
290:28 - so we have successfully imported these
290:30 - libraries you can also rename the
290:32 - notebook by clicking on the name that is
290:35 - Untitled so I'm changing it to my first
290:38 - notebook
290:43 - so now there is an assignment for you
290:54 - so assignment is that
290:57 - you need to practice some of the
291:00 - problems that we already discussed in
291:03 - the previous lectures
291:06 - in Jupiter notebook because if you
291:08 - practice more you'll get acquainted with
291:11 - this
291:12 - quickly so practice some of the codes we
291:15 - have discussed in previous lectures
291:20 - in Jupiter notebook
291:34 - so in today's lecture I demonstrated how
291:37 - to install Anaconda
291:39 - and also how to install
291:43 - c bond and matplotlip libraries using
291:46 - pip installer package as well as
291:49 - Anaconda we also created our first
291:53 - Jupiter notebook that will be all for
291:56 - today this video is brought to you by
291:58 - programming knowledge please like
292:00 - comment share subscribe and hit the Bell
292:02 - button for updates and stay tuned with
292:05 - us for next lecture thanks hi guys
292:08 - welcome back to our course on numpy in
292:11 - our last lecture I explain you how to
292:13 - install c-bond matplotlip and get
292:16 - started with the jupyter notebook and
292:18 - today I am going to teach you the normal
292:21 - distribution so let's get started
292:24 - so as per Wikipedia
292:27 - normal distribution also known as
292:30 - gaussian Gauss or LaPlace Gauss
292:32 - distribution is a type of continuous
292:35 - probability distributions for a real
292:37 - valued random variable the general form
292:40 - of its PDF or probability density
292:44 - function is given by f of x is equal to
292:47 - 1 by
292:48 - Sigma into under root 2 pi multiplied by
292:52 - e daised to the power minus 1 by 2 x
292:54 - minus mu by Sigma whole Square
292:59 - here f of x is the probability density
293:02 - function mu is the mean of the
293:04 - distribution and sigma is the standard
293:07 - deviation now let's look at the plots
293:12 - so these are the normal thoughts for
293:15 - different mean and for different
293:18 - standard deviation values
293:20 - so one General observation is the
293:23 - distribution will always be centered
293:26 - around the mean
293:28 - so in this blue
293:32 - curve the mean is zero so centered
293:34 - around 0 same for red and yellow but the
293:38 - green is centered around
293:40 - -2 and you can see that they are
293:43 - dispersed differently
293:45 - now let's take a look at the CDF curves
293:50 - so these are the CDs curves so
293:54 - three curves intersect at zero because
293:57 - they have mean as 0 and 1 is passing
294:01 - through minus 2 because the mean is
294:03 - minus two so this was a CDS curve now
294:07 - let's move on to the coding or plotting
294:10 - part
294:12 - so generate a random
294:15 - normal
294:16 - distribution
294:20 - of
294:21 - size
294:23 - 3 into 3
294:27 - with so we have parameters here so the
294:31 - parameters are mean and standard
294:34 - deviation
294:37 - so here mean is 1 and standard deviation
294:40 - is 2.
294:44 - so
294:46 - from numpy
294:49 - import
294:52 - random
294:54 - so from numpy import random
294:57 - and
294:58 - proceed further so X is equal to random
295:02 - dot normal
295:06 - and we will specify the parameters
295:10 - that is
295:12 - location is equal to one
295:15 - K is equal to 2
295:18 - and size is equal to
295:20 - whatever is the size of the distribution
295:28 - so location means the mean what
295:32 - the value around which the distribution
295:33 - is centered so this is the returned
295:36 - array and the elements are the samples
295:39 - taken from a normal distribution
295:43 - now
295:45 - let's
295:48 - visualize the normal distribution
295:50 - visualization is a very important aspect
295:53 - because here we are dealing with c bond
295:56 - numpy as well as plot lip so a
296:00 - combination of these three libraries
296:02 - helps us in visualization
296:06 - the math plot ping matplotlip being the
296:09 - grandfather of the visualization
296:12 - libraries
296:14 - so now let's visualize import matplotlab
296:19 - as
296:20 - sorry matplotlip dot Pi plot as PLT
296:26 - and import c bond
296:30 - as SNS
296:35 - now SNS Dot
296:37 - this plot
296:39 - and we are going to pass an array
296:44 - which contains samples taken from a
296:48 - normal distribution
296:50 - so random.normal and size
296:53 - is equal to
296:57 - so let the size be
297:01 - 1000
297:03 - and hist is equals to
297:08 - false
297:10 - so we have taken the hist as false
297:14 - because normal distribution is a
297:16 - continuous distribution
297:19 - so we are just
297:21 - concerned with the KDE plot
297:25 - so here
297:30 - I'm using
297:32 - jupyter notebook
297:36 - so I taught you how to install all the
297:40 - libraries and get started with the
297:42 - jupyter notebook if you have skipped
297:44 - that lecture I advise you to go back and
297:49 - watch it again
297:55 - so here I'm using the jupyter notebook
297:58 - but if you are using
298:03 - any other platform then you have to
298:05 - write PLT dot show and here sometimes in
298:10 - jupyter notebook we also use
298:13 - percent map plot lib inline explicitly
298:17 - for jupyter Notebook also
298:20 - please note that normal distribution
298:23 - has a belt shaped curve
298:26 - so in today's lecture we covered the
298:29 - normal distribution the PDF and CDF of a
298:33 - normal distribution and their plot and
298:37 - we created an array with values
298:42 - from a normal distribution and at the
298:45 - last we visualized
298:48 - the shape of a normal distribution curve
298:51 - that will be all for today this video is
298:54 - brought to you by programming knowledge
298:56 - please like comment share subscribe and
298:59 - hit the Bell button for updates and stay
299:02 - tuned with us for next lecture thank you
299:06 - hi guys welcome back to our course on
299:08 - numpy in our previous lecture we covered
299:12 - the normal distribution and today we are
299:14 - going to take a look at the binomial
299:16 - distribution its PDF curve and how to
299:20 - plot the PDF for a binomial distribution
299:23 - using numpy c-bond unmapped plot clip so
299:28 - let's get started so what is binomial
299:31 - distribution so binomial distribution is
299:34 - a discrete distribution it describes the
299:36 - outcome of binary scenarios example toss
299:40 - of a coin that is head or tail weaning
299:43 - or losing passing or failing Etc it has
299:47 - three parameters and the number of
299:50 - Trials P the probability of success and
299:54 - queue the probability against success
299:58 - so its probability Mass function is
300:00 - given by P of X is equal to K that is
300:04 - probability that our variable takes on
300:06 - the value K is equal to
300:10 - nck P raised part K into 1 minus P whole
300:15 - raised to power n minus k
300:18 - so this is the probability Mass function
300:21 - because it's a discrete distribution now
300:24 - let's see how a binomial distribution
300:27 - looks like so in first case n equals to
300:31 - 10 the probability of success is 0.5
300:34 - that is 1 by 2
300:36 - so in this case
300:38 - the distribution is nearly symmetrical
300:41 - about
300:43 - X is equal to 5.
300:46 - so for
300:48 - p is equal to 0.5 that is probability of
300:53 - success is half
300:55 - then the distribution will always be
300:58 - symmetrical now let's take a look at the
301:01 - second case where value of n is fault
301:04 - and the value of p is not equal to 0.5
301:08 - in this case the distribution will not
301:12 - be symmetrical it will be a symmetrical
301:16 - now let's take a look at the last case
301:20 - in this case the value of P
301:23 - not 0.5 but it still looks symmetrical
301:27 - because here the value of n is very very
301:30 - large
301:32 - also note that it just looks symmetrical
301:35 - it is not symmetrical it will only be
301:38 - symmetrical if p is equal to 0.5 or half
301:44 - now let's move on to the coding path
301:50 - so let me just rename it to
301:53 - binomial
301:56 - and we are good to go
302:03 - so here
302:05 - we have
302:09 - three important
302:11 - parameters
302:13 - also note that the parameters for
302:16 - different
302:17 - distributions will be different so you
302:20 - have to memorize all of them in order to
302:23 - be able to plot all the distributions
302:27 - so the parameters are in denoting the
302:30 - number of Trials P denoting the
302:33 - probability of
302:35 - success
302:38 - or the probability of trial and size
302:42 - that is the shape of the array returned
302:53 - so these are the parameters
302:57 - now given 12 trials
303:03 - for a coin toss so coin toss is a binary
303:07 - scenario and there are 12 trials that is
303:10 - n is equal to 12 and the probability of
303:14 - trial or probability of success will be
303:17 - 0.5 because in a fair time cost
303:21 - head and tail have equal probabilities
303:23 - so we have to generate 10 data points
303:27 - that is we have to take 10 samples from
303:30 - a binomial distribution where n is equal
303:33 - to 12 and P is equal to 0.5 so after
303:38 - analyzing the problem we can say that
303:41 - here and is equal to 10 p is equal to
303:44 - 0.5
303:46 - and size is equal to 10 because we have
303:50 - to generate 10 data points I'm sorry I
303:53 - made an error n is not 10 here n is
303:56 - equal to 12. so let me just rectify the
304:00 - error
304:01 - so n is equal to 12 and size is equal to
304:08 - 10. now let's move forward
304:13 - let's create a new cell
304:17 - so now I'm going to write from numpy
304:21 - import
304:24 - random
304:26 - and now I'm going to write X is equal to
304:29 - random dots
304:32 - binomial
304:34 - and I'm going to pass the parameters
304:37 - so n is equal to 10 p is equal to 0.5
304:43 - and
304:44 - the size is equal to 10. so we'll get 10
304:48 - samples
304:49 - from a binomial distribution as a result
304:52 - so these are the 10 samples
304:57 - now we have
304:59 - obtained samples from a binomial
305:02 - distribution now let's move on
305:05 - to visualization of a
305:07 - binomial distribution
305:19 - so let's visualize now
305:22 - so I'm going to
305:25 - write
305:29 - so let's first initialize the parameters
305:32 - so let's n is equal to 10 p is equal to
305:35 - 0.5 and the size p
305:40 - let it be 10 000.
305:43 - so these are the parameters with which
305:45 - we are going to plot
305:47 - a binomial distribution so I'm going to
305:49 - write from
305:51 - numpy
305:55 - import random
306:00 - and import
306:02 - matplotlib dot Pi plot
306:05 - as PLT
306:09 - and import
306:12 - c bond as SNS
306:18 - now sns.displot
306:23 - random
306:24 - Dot binomial
306:27 - and we have to pass the parameters here
306:34 - sorry this is a different kind of cell
306:38 - so let me just
306:40 - clear this thing
306:47 - so let me just write import
306:54 - sorry what was I writing I just forgot
306:56 - so it was sns.displot
306:59 - and
307:01 - pass the parameters
307:04 - So Random dot binomial and we have to
307:07 - pass the parameters so n is equal to 10
307:10 - p is equal to 0.5 and size is equal to
307:15 - 10 000.
307:21 - and we have to specify the hist as true
307:25 - because this is a discrete distribution
307:29 - and we are concerned with the histogram
307:32 - and we can specify the KDE as false
307:35 - because we don't need
307:37 - kernel density estimation that is
307:40 - important in case of a continuous
307:42 - distribution
307:44 - the last cell was a text cell so just
307:47 - let me copy paste and hit enter
307:52 - so I got the plot for a binomial
307:55 - distribution and
307:57 - this is the plot you can see that it is
308:03 - almost symmetrical it is not almost
308:06 - symmetrical it is definitely symmetrical
308:08 - because the probability of success is
308:11 - 0.5 and whenever p is equal to 0.5 the
308:17 - shape will be symmetrical
308:20 - so in today's lecture I covered
308:24 - by normal distribution and its
308:27 - shape
308:28 - that's all for today this video is
308:30 - brought to you by programming knowledge
308:32 - please like comment share subscribe and
308:34 - hit the Bell button for updates and stay
308:37 - tuned with us for next lecture thank you
308:40 - hi guys welcome back to our course on
308:42 - numpy in our previous lecture we covered
308:45 - the binomial distribution and in today's
308:49 - lecture we are going to cover the
308:51 - uniform distribution so let's get
308:53 - started so first of all what is a
308:57 - uniform distribution so it is a
309:00 - continuous distribution
309:03 - and according to Wikipedia in
309:05 - probability Theory and statistics The
309:08 - Continuous uniform distribution or a
309:10 - rectangular distribution is a family of
309:12 - symmetric probability distributions the
309:16 - distribution describes an experiment
309:18 - where there is an arbitrary outcome that
309:20 - lies between 13 pounds that are A and B
309:24 - and PDF is given by 1 by B minus a for
309:28 - all X belonging to a till B and 0
309:33 - otherwise
309:34 - now let's take a look at the PDF so this
309:38 - is the PDF and it's zero for any value
309:42 - less than a and greater than b and it is
309:46 - only defined between A and B including
309:51 - both the values that is a and b
309:54 - now let's move on to the CDF or the
309:57 - cumulative distribution function so here
310:01 - it's like a transfer curve and it has a
310:05 - slope from A to B
310:08 - so this is the cumulative distribution
310:11 - function
310:12 - now let's move on to the coding part
310:15 - let me just change the name to
310:18 - uniform
310:21 - and
310:24 - now I'm going to
310:29 - mention the important parameters of a
310:32 - uniform distribution also note that in
310:35 - uniform distribution the probabilities
310:38 - are generally equal the uniform
310:40 - distributions can be either continuous
310:44 - or discrete and in discrete uniform
310:47 - distribution the probabilities are same
310:50 - but in
310:53 - continuous distribution the scenario is
310:55 - different we deal with three important
310:59 - parameters here that is lower bound
311:02 - that is denoted by a and has the default
311:05 - value 0 B the upper bound
311:09 - having the default value
311:12 - 1
311:15 - so B has the default value 1 on the
311:18 - third parameter is the size
311:22 - that is the shape of the returned array
311:31 - so size is the shape of the returned
311:34 - array
311:35 - now let me create a new cell and first
311:39 - of all let's draw out some samples from
311:43 - a uniform distribution
311:50 - so create
311:54 - a
311:55 - 3
311:57 - cross 3 or 3 into 3
312:00 - that is three rows and three column
312:02 - Matrix
312:03 - consisting of values which are samples
312:07 - taken from a uniform distribution
312:11 - or in short I can say that create a 3
312:14 - cross 3 uniform distribution sample I
312:18 - tried to add comments here but it is not
312:20 - working
312:21 - so let me just clear all this and
312:27 - just write it simply
312:31 - as a single line company
312:40 - so create a three cross three uniform
312:43 - distribution sample
312:48 - now let's move on to the next cell
312:51 - add from numpy I'm going to import
312:56 - random
312:59 - so from num by import random and X is
313:02 - equal to random Dot
313:06 - uniform
313:09 - now we have to pass the parameters that
313:11 - is size
313:17 - and print
313:21 - so this is a 2d array and the elements
313:24 - of this 2D array are samples taken from
313:27 - a uniform distribution
313:31 - now let's move on to the visualization
313:34 - path
313:35 - so let's visualize
313:38 - uniform distribution
313:44 - so now I'm going to import
313:48 - random from the numpy module by writing
313:51 - from numpy import random
313:53 - import
313:55 - matplotlib dot pipe dot as PLT
314:02 - import c bond as SNS
314:09 - and now I write SNS dot this plot and I
314:14 - will pass the parameters
314:18 - So Random Dot
314:21 - uniform and I have to pass the
314:24 - parameters such as size
314:27 - is equal to thousand
314:30 - so I have specified the size as 1000 you
314:33 - can specify a different size
314:36 - and I'm specifying the hist as false
314:40 - because this is
314:42 - a continuous uniform distribution
314:47 - so it's not a perfect rectangular PDF as
314:53 - scene but this is the actual thing that
314:58 - was theoretical
315:00 - now let's try to
315:03 - see the histogram as well so it's
315:07 - in shape of a box so that is much closer
315:12 - but we are only concerned with the
315:14 - boundary and not the failed portion so
315:16 - it's not
315:18 - true for a hist it is true for a
315:23 - KDE but it's not the perfect shape here
315:26 - so that's all for today
315:29 - in today's lecture we covered a uniform
315:33 - distribution its PDF
315:35 - the CDF as well as we visualized the
315:39 - uniform distribution that will be all
315:41 - for today this video is brought to you
315:43 - by programming knowledge please like
315:45 - comment share subscribe and hit the Bell
315:48 - button for updates and stay tuned with
315:51 - us for next lecture thank you
315:54 - hi guys welcome back to our course on
315:56 - numpy in our previous lecture we covered
315:59 - the uniform distribution and in this
316:02 - lecture we are going to cover the
316:04 - poisson distribution so let's get
316:06 - started
316:07 - so first of all poisson distribution is
316:11 - a discrete distribution it estimates how
316:14 - many times an event can happen in a
316:17 - specified time for example if we get
316:20 - three hits on continuously tossing a
316:23 - coin what is the probability of getting
316:26 - four heads that is one example of python
316:30 - distribution and its probability Mass
316:33 - function is given by Lambda raised to
316:35 - part k e raised to power minus K divided
316:38 - by K factorial with Lambda is the
316:41 - expected rate of occurrences now let's
316:44 - look at the PDF of a poisson
316:47 - distribution so here we have three
316:50 - different PDFs for three different
316:53 - poisson distributions for different
316:55 - values of Lambda
316:58 - we note that the peakedness of the
317:02 - distribution depends on the value of
317:05 - Lambda let's say the value of Lambda
317:08 - more will be the peakedness now poisson
317:12 - distribution is a discrete distribution
317:14 - it has two parameters Lam that is rate
317:19 - or the no number of occurrences and size
317:22 - or the shape of the returned array
317:26 - now let's write some code first of all
317:30 - we will create an array which will
317:34 - contain samples taken from a poisson
317:37 - distribution
317:39 - so let's generate a random
317:45 - 1 cross 10
317:49 - distribution
317:54 - for
317:58 - occurrence
318:02 - so we are going to generate a random
318:05 - 1 cross 10 distribution for Lambda is
318:09 - equal to 3.
318:11 - so from numpy
318:14 - import random
318:19 - so X is equal to random
318:22 - Dot poisson
318:24 - and we are going to pass
318:27 - Lam
318:28 - or Lambda is equal to 3 and 5 is equal
318:31 - to 10.
318:38 - because it's 1D array so we don't write
318:40 - size equal to 1 comma 3 in Brackets so
318:44 - we directly write 10 so this array
318:47 - contains samples
318:49 - which are taken from a
318:52 - poisson distribution
318:56 - now let's move on to the visualization
318:58 - part
319:02 - so visualization of poisson distribution
319:12 - now I'm going to write
319:15 - first let's import so from
319:19 - numpy import random
319:25 - import matplotlib dot Pi plot
319:34 - as PLT
319:37 - import c bond
319:40 - as SNS
319:48 - now I'm going to write percent map plot
319:52 - lip in line
319:55 - and now I'm going to write SNS DOT test
319:59 - plot
320:00 - so SNS DOT test plot
320:06 - random
320:07 - dot POI sorry it's yeah poisson so
320:12 - Random Dot poisson
320:14 - and I'm going to pass the Lambda value
320:18 - add
320:19 - the size
320:22 - so let the size be thousand
320:26 - and Lambda is equal to 3 and KDE is
320:29 - equal to
320:30 - false because this is a discrete
320:34 - distribution
320:36 - and
320:38 - sorry I've written my plot lip instead
320:42 - of path plot lab so let me just correct
320:45 - it
320:46 - so this is the plot
320:55 - so that's s how
320:58 - a poisson distribution looks like
321:07 - now let's see what's the difference
321:09 - between
321:13 - poisson
321:14 - and normal distribution or difference
321:16 - between normal and poisson distribution
321:20 - so first of all normal distribution is a
321:23 - continuous distribution and poisson
321:25 - distribution is a
321:27 - discrete distribution
321:43 - normal distribution is used when we are
321:45 - predicting something on a continuous
321:48 - range while poisson distribution
321:51 - is used when we are concerned with an
321:55 - event and intervals of time
322:01 - let's see the plots in one frame
322:06 - so sns.disk plot and random dot normal
322:14 - so let the location with 50 that is mean
322:17 - is 50. scale is equal to 7 and the size
322:22 - is equal to 1000.
322:25 - now let me draw
322:28 - or plot a corresponding
322:31 - poisson distribution
322:33 - also
322:35 - so sns.displot
322:39 - random Dot poisson
322:46 - and I'm going to pass the parameters
322:50 - so let the lamb or Lambda is equal to 50
322:54 - the size be 1000
323:02 - and
323:10 - also let me label it so that we can see
323:13 - the difference so label is equal to
323:16 - normal for the normal distribution and
323:18 - table is equal to poisson for the
323:21 - poisson distribution
323:24 - and let me hit
323:28 - shift enter
323:29 - so now you can see the difference
323:32 - between the two
323:34 - so in today's lecture we covered the
323:37 - poisson distribution its PDF and its
323:40 - visualization we also
323:43 - differentiated between a poisson
323:46 - distribution and a normal distribution
323:49 - that will be all for today this video is
323:51 - brought to you by programming knowledge
323:53 - please like comment share subscribe and
323:55 - hit the Bell button and stay tuned with
323:57 - us for more lectures thank you hi guys
324:00 - welcome back to our course on numpy in
324:03 - our previous lecture we covered poisson
324:06 - distribution and today we are going to
324:08 - cover
324:09 - exponential distribution so let's get
324:12 - started
324:13 - so first of all exponential distribution
324:16 - is used for describing time till next
324:20 - event example failure success Etc
324:24 - the PDF is given by Lambda e raised to
324:27 - power minus Lambda X and the CDF is
324:30 - given by 1 minus E raised to power minus
324:34 - Lambda X here
324:36 - Lambda denotes the rate or the inverse
324:40 - scale and Lambda should be greater than
324:42 - 0. now let's take a look at the PDF and
324:47 - CDF curves
324:49 - so this figure shows us the PDF curve
324:53 - and this figure shows us the CDF curve
324:57 - for different values of Lambda
324:59 - now let's move on to the coding part
325:02 - so exponential distribution is used to
325:04 - describe the time till next event as
325:07 - already discussed it has two parameters
325:10 - that is scaled
325:13 - that is inverse of freight and with
325:16 - default value 1 at size that is the
325:19 - shape of the returned array
325:22 - now let's first draw out samples from an
325:27 - exponential distribution and store it in
325:30 - an array
325:32 - so let's draw out a sample
325:34 - for
325:36 - exponential
325:38 - distribution
325:43 - with
325:44 - scale is equal to 2.5 and
325:50 - 2 into 2
325:52 - size that is 2 cross 2 size
325:56 - so we have to draw out samples from
325:59 - exponential distribution and store it in
326:02 - an 2D array
326:05 - with size 2 cross 2 so I'm going to
326:07 - import
326:10 - random from numpy so from numpy import
326:13 - random and x equal to random dot
326:17 - exponential
326:19 - and I'm going to pass
326:22 - the scale
326:24 - that is our first parameter
326:27 - and I have to
326:29 - pass the second parameter that is size
326:33 - so size equal to two cro 2 comma 2
326:37 - denoting two cross to size
326:40 - and now I'm going to print X
326:42 - so this is a 2d array with four values
326:46 - which
326:48 - are sampled from an exponential
326:51 - distribution
326:53 - now let's visualize
326:55 - the exponential distribution
326:59 - so visualization of exponential
327:02 - distribution
327:05 - now I'm going to
327:08 - again
327:09 - import
327:11 - random from numpy so from num by import
327:14 - random
327:15 - import
327:16 - matplotlib dot Pi plot as PLT
327:23 - and
327:25 - finally import
327:28 - c bond as
327:32 - SNS
327:36 - now I'm going to write SNS dot disk plot
327:42 - and I'm going to write random Dot
327:47 - exponential and I'm going to pass the
327:50 - parameters that is the value of Lambda
327:53 - and size
327:58 - let's just pass size here and Lambda
328:01 - will attain its default value
328:04 - and mention
328:06 - the hist as false because
328:10 - this is a continuous distribution
328:15 - so this is the PDF
328:18 - that is probability density function
328:21 - curve for an exponential distribution
328:35 - now let's try to understand the relation
328:37 - between
328:39 - exponential
328:42 - and
328:45 - poisson distribution
328:52 - so poisson distribution
328:57 - denotes
329:00 - number of
329:04 - let me just move to the next line so
329:07 - poisson distribution denotes number of
329:10 - occurrences of an event
329:19 - number of occurrences of an event in a
329:22 - time period
329:26 - where as exponential distribution
329:33 - or exponential deals with
329:37 - the time
329:39 - between
329:42 - the events
329:43 - so in today's lecture we covered the
329:46 - exponential distribution and visualize
329:50 - the PDF of the exponential distribution
329:53 - further
329:55 - we try to understand the relation
329:57 - between the poisson distribution and
330:00 - exponential distribution that will be
330:02 - all for today this video is brought to
330:05 - you by programming knowledge please like
330:07 - comment share subscribe and hit the Bell
330:10 - button for updates and stay tuned with
330:12 - us for next lecture thank you
330:16 - hi guys welcome back to our course on
330:19 - numpy in our last lecture we covered
330:21 - exponential distribution and today we
330:24 - are going to cover logistic distribution
330:26 - so let's get started
330:32 - so logistic
330:35 - distribution
330:38 - so first of all what is logistics
330:41 - distribution so logistic distribution is
330:44 - used to describe
330:47 - growth
330:52 - it's a logistic distribution describes
330:55 - the growth and it is a very very
330:57 - important distribution because if you
331:00 - are acquainted with machine learning you
331:03 - must have heard of the term logistic
331:06 - regression
331:09 - so it's a very important Concept in
331:11 - machine learning data science
331:14 - so this distribution is very very
331:16 - important and it will be explained in
331:19 - detail once we move on to machine
331:21 - learning and data science
331:23 - so logistic distribution is used to
331:26 - describe growth it is a very very
331:28 - important distribution and it is used
331:31 - extensively in logistic regression
331:34 - neural networks Etc
331:37 - and mathematical description will be
331:40 - given later on
331:43 - I mean in the future courses on data
331:45 - science and machine learning
331:48 - so today we are just going to visualize
331:51 - it
331:52 - and out samples from logistic
331:55 - distribution
331:56 - so let me just create a new cell
332:09 - so first of all let's discuss the
332:12 - parameters so it has three parameters
332:15 - the lock or the location or the mean
332:21 - the place where we have a peak
332:24 - like in the previous lectures we used to
332:26 - call it
332:28 - mean only but here we are using lock or
332:32 - which denotes the location or location
332:34 - of the peak and default value for mean
332:38 - or lock is zero and the second parameter
332:42 - is scale
332:46 - it denotes standard deviation
332:52 - and what is
332:54 - standard deviation or what does standard
332:57 - deviation denote it denotes the flatness
333:00 - or the peakedness or the deviation from
333:04 - mean
333:08 - Central uh
333:11 - value we have a central value and
333:14 - standard deviation tells us how much our
333:16 - data deviates from that Central
333:21 - value or the measure of central location
333:24 - which is mean in this case we have other
333:28 - measures for
333:29 - central location that is mod median but
333:33 - we prefer mean
333:35 - over others so let's draw out samples
333:41 - from a logistic distribution so let's
333:45 - draw out three cross three samples from
333:48 - logistic distribution
333:55 - and we need some parameters so let the
333:58 - mean be one and standard deviation B
334:03 - 3.
334:05 - so we are going to write X is equal to
334:08 - random
334:09 - Dot
334:11 - logistic
334:13 - and in bracket
334:17 - we are going to pass the parameters that
334:20 - is lock or location is equal to 1 which
334:24 - denotes that the mean as 1 and scale is
334:27 - equal to 3 that means standard deviation
334:30 - is 3 and let the size be
334:34 - 2 comma 3.
334:37 - sorry 3 comma 3 because we want to have
334:39 - a 3 into 3 array
334:43 - so I forgot to import random so let's
334:47 - write a line for that
334:49 - from
334:52 - so from numpy
334:55 - import
334:56 - ant
335:00 - now let's execute and we got this array
335:03 - which has three rows and three columns
335:05 - and all the elements of this array are
335:08 - samples taken from a logistic
335:11 - distribution of mean one and standard
335:13 - deviation 3.
335:15 - now let's try to visualize the logistic
335:18 - distribution to see how the
335:22 - shape looks like
335:28 - so from numpy
335:30 - import
335:32 - random
335:35 - and in next line from
335:40 - sorry here we'll directly import
335:43 - matplotlib dot Pi plot
335:45 - as PLT
335:48 - and import c bond
335:52 - as
335:54 - SNS
335:56 - now we'll write SNS DOT test plot
336:00 - and we will pass
336:04 - random dot logistic
336:07 - and in bracket we'll write the
336:09 - parameters that is lock
336:12 - or location or mean the scale and the
336:16 - size
336:17 - but here we are not gonna pass let it
336:20 - acquire the default values so we are
336:24 - only going to pass size that is 100 and
336:28 - hist is equal to false because this is
336:31 - going to be a
336:33 - continuous distribution
336:37 - now let's execute
336:42 - so this is the
336:46 - pictorial form of the distribution or we
336:49 - can say the graphical form
336:52 - of logistic distribution
336:58 - so logistic distribution looks similar
337:03 - to normal distribution
337:07 - as you can see that this
337:10 - shape is also like Bell
337:13 - so it the curve is
337:15 - also Bell shape but you can see some
337:18 - difference in the Tails of the
337:20 - distribution
337:22 - so if you look around the values minus 6
337:25 - to minus 10 the shape is little bit
337:28 - different than we had in the normal
337:30 - distribution
337:32 - so it has more area under tails so in
337:35 - today's lecture we covered the logistic
337:38 - distribution and we visualized logistic
337:42 - distribution along with comparison with
337:45 - normal distribution that's all for today
337:48 - this video is brought to you by
337:49 - programming knowledge please like
337:51 - comment share subscribe and hit the Bell
337:54 - button for updates and stay tuned with
337:56 - us hi guys welcome back to our course on
337:59 - numpy in our last lecture we covered
338:02 - logistic distribution and today we are
338:04 - going to cover the multinomial
338:06 - distribution
338:08 - so let's get started
338:12 - let me just rename
338:15 - The Notebook to multinomial
338:26 - so I've renamed the notebook and let me
338:28 - just zoom in
338:30 - or maximize
338:33 - so let's get started with multinomial
338:36 - distribution so what is a multinomial
338:39 - distribution
338:40 - so in simple words we can say that
338:44 - multinomial distribution is just a
338:46 - generalization of binomial distribution
338:50 - so in binomial distribution we dealt
338:53 - with two events but in multinomial
338:56 - distribution we are dealing with
338:58 - multiple events
339:01 - so
339:02 - in simple words binomial distribution
339:06 - gives us information about two scenarios
339:10 - where by means two and multinomial
339:13 - distribution
339:15 - gives us information about multiple
339:18 - scenarios or multiple events
339:21 - so multiple
339:28 - so this is the case where we have
339:33 - two scenarios and we generalize it for n
339:36 - scenarios
339:41 - so example of binomial is toss of a coin
339:46 - that we have discussed earlier that
339:49 - either head or tail so two events but in
339:53 - multinomial we have multiple events like
339:56 - occurrence of one occurrence of two
339:59 - occurrence of three or
340:02 - occurrence of six
340:04 - on toss of a dive
340:08 - so example of multi-normal distribution
340:10 - is
340:13 - ruling of a die
340:18 - so multinomial distribution has three
340:21 - parameters
340:23 - will not be going into details about
340:25 - multinomial distribution
340:27 - because it's not concerned with subject
340:31 - matter at hand
340:34 - but will have a general idea so
340:37 - multinomial distribution has three
340:39 - parameters that is n or number of
340:42 - outcomes
340:48 - P valves or the probabilities of the
340:52 - outcomes
340:54 - that is list of probabilities
340:58 - of outcomes so first we have number of
341:02 - outcomes then we have list of
341:04 - probabilities of outcomes and third we
341:08 - have the shape of the returned array
341:11 - that is common almost for every
341:14 - distribution whenever
341:17 - we try to sample something because after
341:20 - sampling we'll return something right
341:22 - the size the number of elements returned
341:27 - so the mathematics that is PDF or CDF
341:30 - will be discussed in future lectures
341:34 - today we'll emphasize on visualization
341:37 - of multinomial distribution and draw out
341:41 - conclusions if any
341:44 - so let's draw out
341:47 - samples first
341:50 - so let's draw out
341:53 - a sample
342:02 - let's take the rolling die
342:05 - experiment for this
342:09 - sampling so let X is equal to random Dot
342:14 - multinomial
342:17 - now we have to pass
342:20 - the number of outcomes that is 6
342:24 - the P valves or probabilities of
342:26 - outcomes here in a
342:30 - role of a die the probability is 1 by 6
342:34 - for each in every number so each and
342:38 - every number has equal probability of
342:40 - occurring this may not be the case for
342:43 - some biased
342:45 - experiments so you keep that in mind
342:48 - here we have each probability value is
342:52 - equal to 1 by 6 and
342:59 - we need to import a random from numpy so
343:02 - from numpy import
343:04 - random
343:09 - so X
343:12 - so this is the ra returned
343:19 - please
343:25 - so there is a very important observation
343:28 - to make
343:29 - the shape
343:31 - of return array is not one it is not a
343:35 - single element
343:36 - but I didn't specify any size so by
343:41 - default it should give me one that's
343:44 - what I thought or that's what you must
343:48 - have thought but it has returned an
343:51 - array with six elements so an important
343:54 - point is that multinomial samples will
343:57 - not produce a single value they will
344:00 - produce one value for each
344:06 - be Val so keep this in mind
344:09 - they will not produce a single value
344:11 - they will produce one value for each
344:15 - corresponding probability value
344:19 - also note that
344:21 - since multinomial distribution
344:25 - is an extension or we can say that
344:28 - generalization of binomial distribution
344:32 - so its shape
344:35 - or it the shape of its PDF will be same
344:38 - as the shape of PDF of a binomial
344:41 - distribution
344:46 - so we will not plot
344:49 - a multinomial distribution today that is
344:52 - for you to do that will be your homework
344:55 - or assignment task
345:14 - so as a home assignment plot a
345:18 - multinomial distribution
345:22 - so in today's lecture we covered the
345:26 - multinomial distribution and observe the
345:29 - similarities between a binomial
345:32 - distribution and a multinomial
345:34 - distribution we also gave you an
345:36 - assignment that is visualization of
345:38 - multinomial distribution that is all for
345:41 - today this video is brought to you by
345:42 - programming knowledge please like
345:44 - comment share subscribe and hit the Bell
345:46 - button and stay tuned with us for next
345:49 - lecture thank you
345:51 - hi guys welcome back to our course on
345:53 - numpy in our last lecture we covered the
345:57 - multinomial distribution and today we
345:59 - are going to learn the chi-square
346:01 - distribution so let's get started
346:05 - so let me just rename the notebook to
346:07 - chi-square
346:13 - so what is a chi-square distribution or
346:16 - what is the significance of a chi-square
346:19 - distribution
346:21 - like
346:22 - the multinomial distribution is used in
346:25 - multinomial scenarios the logistic
346:27 - distribution is applicable to various
346:30 - machine learning algorithms in a similar
346:33 - manner the chi-square distribution is
346:36 - used to verify a hypothesis so it is
346:40 - used in hypothesis verification it is
346:43 - more of a statistical concept and we'll
346:47 - discuss it later on
346:51 - when we
346:52 - cover the essential mathematics for
346:56 - machine learning and data science in
346:58 - that course we'll be dealing with
347:00 - chi-square distribution
347:03 - so for now you need to remember that it
347:06 - has two important parameters first is DF
347:11 - that means the degree of freedom and
347:14 - other one is the size or the shape of
347:17 - the returned array
347:24 - now let's insert a new cell
347:27 - and
347:29 - let's draw out samples from a chi-square
347:33 - distribution
347:35 - so draw
347:37 - out
347:40 - a sample
347:44 - for a
347:46 - Chi Squared
347:48 - distribution
347:52 - with degree of freedom because we always
347:55 - need parameters while we extract the
348:00 - samples so let the degree of Freedom be
348:03 - 3 and size
348:06 - B 3 into 3 this is the size
348:11 - which denotes the shape of the returned
348:14 - array now from numpy import
348:18 - random
348:21 - and X is equal to random dot Chi Squared
348:27 - and will pass
348:29 - the parameter status degree of Freedom
348:32 - or DF is equal to 3 and size is equal to
348:38 - 3 comma 3
348:40 - now let's print
348:43 - X
348:48 - so this is a 2d array but all the
348:51 - individual values of this 2D array are
348:55 - samples taken from a chi-square
348:58 - distribution
349:00 - now let's move on to the visualization
349:03 - of Chi Squared Distribution
349:06 - so let's visualize a chi-square
349:08 - distribution
349:15 - so we need to write from
349:18 - numpy import random
349:25 - import matplotlib
349:30 - dot Pi plot
349:34 - as PLT
349:37 - import fee Bond
349:42 - as SNS
349:46 - now we are going to write sns.displot
349:50 - and we are going to pass
349:52 - random dot Chi Square
349:56 - on
349:57 - Within
349:59 - brackets will pass the degree of Freedom
350:02 - Let It Be 1 and the size p
350:08 - so let the size be 1000.
350:11 - now
350:12 - will specify hist as false because this
350:16 - is also a continuous distribution
350:21 - so we don't need to visualize the
350:23 - histogram we just
350:25 - need the KDE path the KDE path also is
350:29 - not a very precise measure of
350:32 - the PDF but it helps us to visualize the
350:36 - PDF
350:39 - so we have visualized
350:42 - chi-square distribution
350:45 - so it has a longer tail on one side and
350:49 - a very short tail on the other side
350:55 - so in today's lecture we covered
350:58 - chi-square distribution
351:00 - we took out some samples from a
351:03 - chi-square distribution and at the end
351:06 - we visualized a chi-square distribution
351:08 - that will be all for today this video is
351:11 - brought to you by programming knowledge
351:13 - please like comment share subscribe and
351:16 - hit the Bell button for updates and stay
351:19 - tuned with us for next lecture thank you
351:22 - hi guys welcome back to our course on
351:25 - numpy in our previous lecture we covered
351:28 - the chi Square distribution and today we
351:31 - are going to cover a relics distribution
351:33 - so let's get started
351:36 - so let me just rename my notebook to
351:39 - relics distribution or really
351:46 - so first of all
351:48 - what is a relics distribution
351:54 - so Radix distribution
351:56 - is used mainly in
351:59 - signal process
352:01 - so the main application of this
352:03 - distribution is in Signal processing
352:07 - we'll discussed it in detail in future
352:11 - lectures
352:12 - so this lecture is the idea only
352:16 - will not go into mathematical part or
352:20 - complex definitions just remember that
352:24 - Radix distribution is used mainly in
352:27 - Signal process we will discuss the PDF
352:30 - later on
352:38 - so it has two important parameters this
352:42 - is what we need to focus on
352:44 - the first parameter being the scale
352:51 - the scale here means the standard
352:53 - deviation
352:57 - which decides
352:59 - how much
353:02 - the data is
353:05 - dispersed or how flat is the
353:07 - distribution or how flat this
353:10 - distribution will be
353:13 - add
353:14 - the default value of scale or standard
353:17 - deviation is
353:19 - 1
353:21 - .0 so here scale means standard
353:25 - deviation which describes the flatness
353:27 - of the distribution and the default
353:29 - value will be 1.
353:32 - and the second important parameter is
353:35 - size it denotes the shape of the
353:38 - returned array
353:42 - now let's draw out samples from a relix
353:46 - distribution
353:50 - so draw out a sample for a relics
353:55 - distribution
353:57 - now we can have two parameters here the
354:00 - first being scale and the second being
354:03 - size
354:04 - so let the scale be
354:06 - 3 and
354:09 - the size B
354:12 - 3 cross 3 as usual
354:15 - so let's insert a new cell
354:18 - so from numpy
354:21 - import random
354:27 - and
354:28 - X is equal to random Dot
354:33 - relics
354:37 - and let me just pass this deal
354:43 - and the size
354:50 - now let's print X
354:53 - to
354:54 - see
354:56 - so X is a 2d array it has nine
355:01 - individual values that are samples taken
355:04 - from a relix distribution
355:07 - now let's move on to the visualization
355:09 - of freelix distribution
355:13 - so from
355:15 - numpy
355:18 - import random
355:24 - import
355:26 - matplotlib dot Pi plot
355:32 - as PLT
355:35 - import c bond as SNS
355:44 - and
355:45 - sns.dis plot
355:48 - pass
355:49 - NP Dot
355:52 - sorry we don't need NP here we just need
355:54 - random dot relics and pass
355:58 - the value of size
356:02 - and scale will acquire the default value
356:05 - 1 and we don't need a hist so specify it
356:10 - as false
356:12 - so there is a slight error somewhere
356:19 - sorry there's mistake in the spelling of
356:22 - Felix
356:23 - so
356:25 - make sure you don't spell it incorrectly
356:28 - otherwise it will give an error and it
356:30 - will take a lot of time
356:32 - to fix it
356:34 - I'm quite used to errors so it takes me
356:37 - lesser time but it will take you a lot
356:39 - of time if you make such errors also
356:42 - note that
356:45 - unit
356:47 - standard deviation
356:52 - and
356:54 - 2 degree of Freedom or two degrees of
356:58 - freedom
357:01 - a relics distribution
357:04 - is equal to Chi Square distribution so
357:08 - this is the relation between a relics
357:10 - distribution and chi-square distribution
357:12 - so in today's lecture we covered a Felix
357:16 - distribution
357:17 - we drew out some samples from a relics
357:20 - distribution we visualized it and we try
357:24 - to understand the similarities between a
357:28 - relief distribution and a chi-square
357:30 - distribution that will be all for today
357:32 - this video is brought to you by
357:34 - programming knowledge please like
357:36 - comment share subscribe and hit the Bell
357:39 - button for updates and stay tuned with
357:41 - us for next lecture thank you hi guys
357:44 - welcome back to our course on numpy in
357:47 - our previous lecture we covered prelix
357:49 - distribution and today we are going to
357:51 - cover our last distribution that is
357:54 - Pareto distribution so let's get started
357:58 - first of all let me change the name of
358:01 - notebook to Pareto
358:05 - and let me maximize the screen
358:12 - so a distribution
358:14 - following
358:17 - parvedo's law
358:19 - is called asparatus distribution
358:22 - so this is the simplest definition which
358:25 - absolutely makes no sense because it's
358:28 - not much of description
358:33 - so what you actually need to remember is
358:36 - what is pareto's law so don't just write
358:39 - that distribution following pareto's law
358:42 - is called as pareto's distribution you
358:44 - have to mention this 80 20 distribution
358:47 - thing
358:54 - so what is 80 20 distribution or what is
358:57 - 80 20 law
359:00 - its figure out let's see
359:11 - so 80 20 distribution or 80 20 log
359:15 - operators law
359:17 - means that 20 factors can cause 80
359:21 - percent
359:24 - outcomes
359:26 - so this is the important
359:28 - statement that is 20 factors costs
359:32 - eighty percent outcomes and I hope that
359:36 - some of you must have heard of a rule
359:39 - or
359:40 - a proverb or something like this that is
359:44 - 20 hard work can bring 80 percent
359:48 - results
359:50 - so back in school some of the students
359:53 - used to say that to bring 80 percent
359:55 - marks we need to study only 20 percent
359:59 - syllabus so that is not true you have to
360:02 - study 80 syllabus for 80 marks at least
360:06 - so
360:08 - but in general in life in general you
360:12 - need 20 hard work to get 80 results
360:18 - so here we have two important parameters
360:21 - the first being the she parameter and
360:24 - second being the size of the returned
360:27 - array
360:28 - are the shape of the returned array
360:35 - now we'll insert a new cell
360:39 - and we'll try to draw some samples
360:43 - from a pareto's distribution so let's
360:46 - draw out samples from
360:48 - burritos
360:57 - distribution
361:00 - so we need to specify some parameters
361:04 - so let the shape
361:07 - B3 that means e is equal to 3 and that's
361:11 - the size B 3 cross 3 that means the
361:15 - shape of returned array will be 3 cross
361:18 - 3 it will have three rows and three
361:21 - columns so from num Pi import
361:24 - random
361:27 - X is equal to random Dot
361:32 - Pareto
361:34 - and will pass is equal to 3 and size is
361:38 - equal to
361:40 - 3 comma 3 and we'll print the value of x
361:45 - so X is a 3 cross 3 Matrix which
361:48 - contains some values that are sampled
361:52 - from a pareto's distribution
361:55 - now let's visualize
361:57 - the distribution
362:05 - so from numpy
362:09 - import random
362:17 - import
362:19 - tip dot Pi plot
362:25 - as PLT
362:29 - import c bond
362:33 - as SNS
362:37 - and sns.displot
362:43 - and in Brackets random dot Pareto
362:48 - and will pass
362:54 - a is equal to 2 and size
362:58 - is equal to
363:01 - 1000 and since pareto's distribution
363:07 - is
363:08 - a disk free distribution we need KDE as
363:11 - false
363:13 - so this is how shape of a pareto's
363:17 - distribution looks like
363:26 - hence we have
363:29 - visualized pareto's distribution or we
363:33 - can say that pareto's distribution have
363:35 - been
363:36 - visualized
363:38 - so in today's lecture we covered
363:40 - potatoes distribution and we visualized
363:43 - the shape of a pareto's distribution
363:47 - that will be all for today this video is
363:50 - brought to you by programming knowledge
363:51 - please like comment share subscribe and
363:54 - hit the Bell button for updates and stay
363:57 - tuned with us for next lecture thank you
364:01 - hi guys welcome back to our course on
364:03 - numpy in our last lecture we concluded
364:06 - our discussion on distributions and
364:09 - today we are going to start with
364:10 - universal functions so let's get started
364:14 - let me just rename my notebook first
364:19 - so let the name be you funk
364:23 - so what is a u-funk so ufunk basically
364:27 - stands for Universal functions
364:30 - are you functions in plural means
364:33 - Universal functions
364:37 - so what are these Universal functions or
364:41 - you functions so these are the numpy
364:44 - functions that act on or that operate on
364:49 - ND array objects
364:53 - so these are some predefined functions
364:55 - which can readily be used when we are
365:00 - working with numpy
365:03 - and why are the used they facilitate
365:06 - vaporization and broadcasting among
365:10 - other important Concepts
365:13 - so you Fung's or Universal functions are
365:17 - used to implement vectorization they
365:21 - provide Broadcasting
365:26 - and
365:28 - additional
365:30 - methods
365:33 - so this is basically the reason
365:37 - behind using u-funks or Universal
365:40 - functions
365:41 - so at times we have to perform some
365:44 - basic operations so you funds help us
365:48 - perform
365:49 - these operations without explicitly
365:53 - creating a new functions so you
365:56 - functions can also take additional
365:58 - parameters like where D type and out
366:04 - now let's try to understand with an
366:06 - example that why do we need
366:09 - a U func or a universal function
366:13 - so let's consider
366:16 - that
366:17 - we need
366:22 - to add elements
366:25 - off
366:27 - to list
366:29 - so here we have to add elements of two
366:31 - less and store the result in a new list
366:35 - so there are two ways to do it without
366:38 - you func and with you so without you fun
366:41 - or Universal function we can do it by
366:44 - zip method now
366:48 - X is equal to 1 2 3 4 5 P the first list
366:52 - and Y is equal to 4 2 3 4 and 5 be the
366:58 - second list now we need a third list
367:00 - which is
367:04 - or which contains the sum of individual
367:07 - elements of these tools so without
367:12 - ufunk we can do it by zip method and we
367:15 - need to declare an empty list first and
367:18 - then we'll iterate so for I comma G in
367:22 - zip
367:23 - X comma y
367:24 - Z dot append I plus G
367:29 - Now display Z so there is an error
367:31 - because I have not commented out that
367:34 - portion so let me just comment it out
367:37 - and run it again now you can see that
367:40 - lists Z contains the sum of individual
367:45 - elements of X and Y so 4 plus 1 5 2 plus
367:50 - 2 4 and so on now numpy has a universal
367:54 - function to do the same task
367:58 - that is ADD
368:01 - so we can perform the same operation
368:04 - using the U Funk or Universal function
368:07 - add
368:08 - so we just need to write V is equal to
368:11 - NP dot at X comma y
368:16 - so sorry I have not imported numpy
368:19 - because in earlier example I didn't use
368:22 - so just let me import numpy as NP
368:28 - and run it again
368:30 - now it will not give an error
368:33 - so this
368:35 - result is same in both the cases but
368:38 - lines of code in second one are lesser
368:41 - as compared to lines of code and first
368:44 - example
368:56 - so this is a method of Performing sum
369:02 - without
369:04 - iterating
369:05 - over
369:07 - the arrays or the list
369:09 - or we can see that without iterating
369:11 - over individual
369:17 - elements
369:31 - also it's worth noting that there are
369:34 - several kinds of universal functions or
369:37 - Q funks available which help us perform
369:40 - different operations and we'll discuss
369:44 - all of them one by one in future classes
369:48 - in today's lecture I introduce you to
369:51 - the concept of universal functions or
369:54 - you functions that will be all for today
369:56 - this video is brought to you by
369:58 - programming knowledge please like
370:00 - comment share subscribe and hit the Bell
370:02 - button for updates and stay tuned with
370:05 - us for next lecture thank you hi guys
370:08 - welcome back to our course on numpy in
370:10 - our last lecture we started our
370:12 - discussion on universal functions and
370:15 - today we'll learn how to create a
370:17 - universal function
370:19 - so let's get started
370:21 - so let me just create a new notebook
370:27 - and rename it
370:37 - so let the name be creating
370:40 - a u-funk a universal function
370:48 - now
370:49 - will
370:51 - first learn
370:54 - how to create
370:57 - a universal function or U func because
371:00 - it may happen that you want to call a
371:03 - function for performing some operation
371:05 - again and again but it's not available
371:23 - so to create a u-func we need to define
371:25 - a function and then we need to save it
371:28 - to the numpy ufunc library using
371:33 - another function
371:36 - so first we have to create a function
371:39 - and then we need to add it to the numpy
371:46 - using another method that is from PI
371:50 - func method
371:53 - so please try to remember to create a
371:58 - u-funk we need to declare and Define a
372:01 - function first then we need to add it to
372:04 - the numpy ufunk library with the from P
372:09 - func or from PI func method
372:15 - also note that the from PI func method
372:20 - takes some parameters
372:26 - so from PI function method X the
372:30 - following arguments or parameters
372:33 - first one being the function
372:39 - or the name of the function
372:44 - so the first parameter will be the name
372:46 - of the function that you want to add to
372:49 - the numpy youfunk library
372:51 - the second parameter is inputs the
372:54 - number of the inputs that your function
372:57 - will have
373:00 - and third parameter is the number of
373:03 - outputs so we have to pass three
373:06 - important arguments that is the function
373:10 - name the number of inputs and the number
373:14 - of outputs
373:23 - now let's move on to an example
373:27 - so we'll create our own Universal
373:30 - function
373:32 - which will take 2
373:34 - arguments
373:37 - X and Y
373:40 - and it will return X raised to power y
373:44 - as output
373:49 - also note that X and Y need not to be
373:53 - numbers or integers they can be an array
373:58 - of integers
374:03 - so first
374:05 - step is to create a function so I
374:09 - created a function
374:10 - that is my func and it takes two
374:13 - arguments X and Y and I am returning X
374:18 - asterisk asterisk Y which means X raised
374:22 - to power y
374:24 - and now we'll save this function to the
374:27 - num by
374:28 - ufunk Library using from PI func method
374:34 - so my func is equal to NP Dot from PI
374:38 - func and I'll pass function name that is
374:41 - my func the number of inputs
374:45 - that is 2 and the number of output
374:48 - starts 1.
374:49 - and I'll execute
375:01 - let's do one more thing
375:04 - let's print the value
375:07 - returned by the function
375:10 - side by side
375:12 - so let's print my
375:14 - func
375:20 - and let the input B
375:25 - and array
375:27 - so we have to give two inputs
375:30 - that is
375:32 - two arrays
375:38 - there's an import error because of
375:41 - improper indentation so let's just
375:44 - correct
375:46 - the indentation
375:50 - the return is not correctly indented
375:54 - again so let me just
375:57 - fix it
375:59 - now let's run
376:01 - so 1 raised to power
376:03 - 3 and 2 raised to power 4.
376:07 - so this is the result
376:10 - now our function got saved in the num by
376:14 - ufunk library and we can call it in
376:18 - future programs
376:20 - so in today's lecture we discussed how
376:24 - to create your own Universal function or
376:27 - you func that will be all for today this
376:30 - video is brought to you by programming
376:31 - knowledge please like comment share
376:33 - subscribe and hit the Bell button for
376:35 - updates and stay tuned with us for next
376:38 - lecture thank you hi guys welcome back
376:41 - to our course on numpy in our last
376:44 - lecture we covered how to create a
376:46 - universal function and today we will
376:48 - discuss some Universal functions related
376:51 - to simple arithmetic operations so let's
376:54 - get started
376:56 - let me just
376:58 - create a new notebook
377:01 - and rename it
377:06 - so let the name be simple arithmetic
377:14 - so today we'll discuss some Universal
377:17 - functions
377:18 - which help us perform basic mathematical
377:21 - arithmetic operations such as addition
377:25 - subtraction Division and multiplication
377:29 - so we can use arithmetic operators
377:32 - directly between
377:35 - numpy
377:37 - arrays
377:46 - so let's first discuss the addition of
377:50 - numpy arrays
377:58 - let me just comment it so the function
378:02 - add
378:04 - and brackets to pass the parameters
378:08 - sums the content of
378:12 - two arrays and stores the result in a
378:15 - third array or a new array or we can say
378:18 - that it returns a new array
378:31 - so for addition we have the function add
378:35 - now let's demonstrate the addition of 2
378:38 - less using the add function so import
378:43 - them by as NP
378:46 - and first of all create two arrays
378:50 - let their names be arr1 and arr2
379:04 - so we already know how to create numpy
379:07 - arrays
379:09 - we have discussed it a million times by
379:12 - now
379:15 - so we have written the code for creating
379:18 - two arrays and now we'll create a new
379:21 - array
379:22 - which will
379:25 - contain the sum of individual elements
379:28 - of array 1 and array 2. so for that we
379:31 - have to write new array is equal to NP
379:33 - dot at and pass the array names I got an
379:37 - error because of
379:39 - a wrong name so
379:44 - we got the result
379:46 - as an array which contains some of
379:49 - individual elements of the two arrays
379:52 - now let's move on to subtraction
379:55 - so we have ADD function for addition
379:58 - similarly we have the subtract function
380:01 - for subtraction so the subtract function
380:05 - subtracts two arrays and the result is
380:08 - written as a new array
380:12 - so we just need to write new array Let
380:16 - It Be new array 1 is equal to NP Dot
380:19 - subtract
380:21 - and pass the parameters as Error 1 and
380:26 - error 2.
380:28 - Now display
380:31 - and we got the result as an array of all
380:35 - minus tense because
380:38 - all of the elements differ by 10 and
380:41 - elements of array 2 are greater than
380:44 - elements of array 1. now let's move on
380:48 - to multiplication
380:50 - so for multiplication we use the
380:53 - multiply function
381:04 - so multiplication is done and answer is
381:08 - returned as a new array
381:15 - so the procedure will be same we'll just
381:18 - need to replace add or subtract Pi
381:22 - multiply so new array name is equal to
381:25 - NP dot multiply and in Brackets we'll
381:28 - pass the parameters so new r
381:32 - a new array name is equal to NB dot
381:35 - multiply and in Brackets Error 1 and
381:38 - arr2 are passed as arguments and I will
381:42 - display
381:45 - so this result is wrong because I have
381:48 - to write new arr2
381:52 - so let me just correct it
381:59 - so this is probably me figuring it out
382:02 - that what mistake I've done while I was
382:04 - recording the video but it's the wrong
382:08 - so now corrected it and I got the
382:11 - correct result
382:13 - at last we are going to discuss division
382:18 - so the procedure of division will be the
382:21 - same we just need to replace multiply by
382:25 - divide this time
382:28 - so division is performed by use of
382:30 - divide function
382:32 - division is done and answer is returned
382:36 - as a new array
382:39 - so it divides
382:43 - the corresponding array elements and
382:46 - Returns the result as a new array
382:56 - now let's demonstrate
382:58 - division of two num by arrays with help
383:01 - of an example
383:03 - so new array name or new arr3 is equal
383:07 - to NP dot divide and will pass
383:10 - two arrays that is Error 1 and arr2
383:15 - now let's
383:18 - display the result so new arr3 in my
383:22 - case I'm using notebook so it's directly
383:26 - displaying the output part you need to
383:29 - write print
383:31 - if you want display the output now let's
383:34 - see what if some elements are zero what
383:38 - will happen
383:39 - do we get an error or not
383:44 - so let's see what happens if we have a
383:46 - Zero Entry so let everyone be
383:50 - a less containing only 0 and
383:53 - array to be a less containing only two
383:57 - now let's divide
384:00 - so ARR 8 or any new array name is equal
384:05 - to NP dot divide and arr1 comma
384:10 - sorry we I have to write comma here not
384:13 - the Divide sign I'm used to it because
384:16 - in division we use
384:19 - divide side so let me just change it
384:21 - comma
384:23 - so it gave me the result as 0 because 0
384:27 - divided by 2 is 0. now let's see the
384:30 - result of 2 divided by 0.
384:33 - so I am interchanging
384:35 - so it gave me divide by added
384:39 - or divide by 0 error
384:42 - so in today's lecture we discuss some
384:46 - Universal functions related to basic
384:49 - mathematical operations that will be all
384:52 - for today this video is brought to you
384:53 - by programming knowledge please like
384:56 - comment share subscribe and hit the Bell
384:58 - button for updates and stay tuned with
385:00 - us for next lecture thank you
385:04 - hi guys welcome back to our course on
385:06 - numpy in today's lecture we'll continue
385:09 - our discussion on some Universal
385:12 - functions to perform simple arithmetic
385:15 - operations so let's get started
385:19 - let me just change the notebook name to
385:22 - simple arithmetic
385:26 - part 2.
385:30 - so first of all we'll discuss the power
385:33 - function
385:35 - so the power function Rises the value
385:38 - from first array to the power of values
385:41 - of the second array and result is
385:44 - written in form of a new array
385:47 - so in our day-to-day life we need to
385:52 - perform some operations related to
385:55 - squaring cubing or any X raised to power
386:00 - y
386:01 - so we can solve such problems with the
386:04 - help of power function
386:08 - so power function Rises the value from
386:12 - first array to the power of values of
386:14 - the second array and result is written
386:17 - as a new array now let's demonstrate the
386:21 - use of power function with the help of
386:23 - an example so import numpy SNP
386:27 - and first of all we need to create two
386:30 - arrays
386:42 - so
386:43 - I have created two arrays
386:47 - now I'll write new array name is equal
386:51 - to NP dot power
386:55 - and pass
386:57 - the names of two
386:59 - lists
387:01 - now I'll print this new array
387:05 - and the result is the elements of array
387:09 - 1
387:11 - raised to part the elements of array a
387:15 - list two
387:17 - so one raised to the power 2 is 1
387:21 - 2 raised to power 2 is 4 3 raised to the
387:23 - power 2 is 9 and so on
387:27 - and the second problem is how to get the
387:31 - remainder
387:33 - of any division so to get a remainder of
387:37 - any division we can use two functions
387:40 - the first being the mod function and the
387:43 - second being the remainder function
387:46 - so we can say that both mod and
387:50 - remainder functions are used to return
387:53 - the remainder
387:58 - and how does it operate
388:03 - the remainder of values in first array
388:07 - correspond to the value in
388:11 - second
388:19 - so it will return the remainder of
388:21 - values in first array corresponding to
388:25 - values in second
388:28 - when division is performed now let's try
388:31 - to understand through an example
388:35 - so let's write new array name is equal
388:38 - to NP dot mod and pass the array names
388:44 - and let's print this new array
388:48 - so new arr1 and it gave us the result
388:53 - so 1 divided by 2
388:55 - gives the remainder 1 2 divided by 2
388:58 - give the remainder 0 3 divided by 2
389:01 - gives the remainder 1 and 4 divided by 2
389:05 - give the remainder 0 so this is how the
389:09 - mod function works
389:12 - so remainder function is similar
389:19 - now let's write
389:25 - new array is equal to NP dot remainder
389:28 - and pass the array names so we should
389:31 - get the same result
389:35 - so let's see yes the result is same in
389:39 - both the cases
389:40 - demonstrating that both mod function and
389:44 - remainder function are used to return
389:46 - the remainders
389:49 - now let's discuss
389:53 - the functions to get the question and
389:56 - the mod
389:57 - so the function div mod
390:04 - returns
390:06 - both the question and the mod
390:09 - and it returns two arrays the first
390:14 - contains quotient and the second
390:16 - contains mod so div mod function takes
390:22 - two parameters
390:24 - and it returns two outputs first one
390:28 - being
390:29 - the equation and the second one being
390:32 - mod
390:45 - s demonstrate the use of div mod
390:48 - function
390:50 - the new array name is equal to NP Dot
390:53 - divmod and will pass the array names
390:57 - that are array 1 and array2 or arr1 and
391:02 - arr2 now we have the result as two
391:06 - arrays the first one being two equations
391:09 - and the second one being the mod values
391:15 - now let's move on to the last topic or
391:17 - last function which is to get the
391:21 - absolute values to get the absolute
391:24 - values
391:25 - we can use two functions the first one
391:29 - being absolute and the second one being
391:32 - abs
391:34 - you might have heard of ads function
391:38 - before in some programming language so
391:41 - we can use adds or absolute both
391:46 - to fit the job
391:48 - now let's debunk straight the use of
391:52 - adds an absolute function so
391:55 - err or array name is equal to NP dot
391:59 - array
392:00 - and let me pass a list containing some
392:03 - negative elements because we need to get
392:05 - absolute value
392:08 - which will be same for positive but
392:10 - different for negative
392:12 - so new array is equal to NP dot apps and
392:16 - array name
392:17 - now I'll print the new array
392:21 - and it gave me positive values by using
392:24 - absolute also it will give me the same
392:26 - result
392:28 - so in today's lecture we concluded our
392:31 - discussion on universal functions for
392:34 - performing basic mathematical arithmetic
392:38 - operations that will be all for today
392:40 - this video is brought to you by
392:41 - programming knowledge please like
392:43 - comment share subscribe and hit the Bell
392:45 - button for updates and stay tuned with
392:48 - us for next lecture thank you
392:51 - hi guys welcome back to our course on
392:53 - numpy in our previous lecture we covered
392:56 - some Universal functions to perform
392:59 - basic arithmetic operations and today we
393:03 - are going to cover some Universal
393:05 - function which help us to round float or
393:09 - decimal values so let's get started
393:13 - let me change the notebook name to
393:15 - rounding
393:18 - so in numpy there are five functions
393:22 - which help us round decimal values
393:27 - so there are primarily
393:30 - five ways
393:32 - of rounding off
393:36 - they are
393:38 - truncation
393:42 - fix
393:46 - rounding
393:49 - floor
393:52 - and
393:55 - ceiling
393:58 - you must be knowing the difference
394:00 - between these five methods
394:04 - these methods are also discussed in AP
394:08 - mathematics
394:11 - so let's first discuss the trunk and fix
394:14 - method so run and fix function I used to
394:18 - remove the decimals and return number
394:21 - closest
394:27 - so it Returns the closest number
394:30 - for example if it's 2.1 it will return 2
394:34 - and if it's 2.9 it will return
394:38 - 3.
394:40 - so we can say that the trunk and fixed
394:43 - function I used to return the closest
394:47 - integer number now let's demonstrate the
394:51 - use of
394:53 - Grant in fixed method
394:57 - so let's write
394:59 - ARR is equal to NP dot trunk
395:03 - and will pass
395:05 - a list containing float values
395:08 - so it should give us minus 2 and 3 and
395:13 - the result is as expected
395:15 - now let's demonstrate the use of fixed
395:19 - function
395:20 - so I'll write NP dot fix and I'll pass
395:25 - a list of
395:29 - float values
395:32 - so I should get the result as minus 2
395:34 - and
395:37 - 8.
395:39 - so result is same as expected
395:49 - so I hope you understand the difference
395:52 - between
395:53 - trunk and fixed method
396:02 - now let's move forward
396:05 - with rounding
396:08 - and the use of
396:10 - a round function
396:13 - so the around function increments the
396:16 - preceding digit or decimal by 1.
396:21 - so it increments the preceding digit or
396:24 - decimal by one if we take an example if
396:27 - the number is 3.166666
396:32 - then it should round it to 3.17
396:38 - yeah
396:40 - also we need to pass an additional
396:43 - parameter that is number of decimal
396:46 - digit that we want
396:48 - to round two for example we just want to
396:52 - display two digit after decimal
396:55 - or one digit or three digit output table
396:59 - the number of digits that you want after
397:02 - the decimal point
397:06 - now I'll demonstrate the use of rounding
397:10 - with a round function
397:13 - so I'll write import numpy as NP
397:20 - and new array name
397:24 - is equal to NP dot around and I'll pass
397:28 - two parameters the number
397:31 - as well as the number of
397:36 - digits after decimal Let It Be 2.
397:40 - so I'll get the result as
397:44 - 3.17 I should get the result as 3.17
397:48 - let's see what do we get so the result
397:51 - is 3.17 as expected
397:54 - now let's move on to the floor function
397:57 - and ceiling function now it's for you to
398:02 - figure out that what's the difference
398:04 - between
398:05 - floor function and thieving function
398:07 - although it will be clear once we see an
398:10 - example
398:12 - so the floor function
398:15 - rounds of decimal to nearest lower
398:18 - integer
398:21 - so we'll get the nearest lower integer
398:24 - in this case
398:31 - so let's demonstrate the use of floor
398:34 - function so array name is equal to NP
398:38 - dot floor and will pass
398:43 - a list containing
398:45 - decimal values or float values
398:51 - so we'll display the result
398:56 - and the result is minus 3 and 3 because
398:59 - these are the nearest lower integer
399:06 - and lastly
399:08 - the seal function
399:11 - or the ceiling function as shown in
399:13 - mathematics
399:17 - so the Seal of
399:19 - 3.166 is 4 but the floor of 3.166 is 3.
399:26 - this is the difference between
399:28 - the floor function and the seal function
399:31 - now let's see an example
399:35 - so I'm gonna import numpy as NP
399:45 - and I'll write ARR is equal to NP dot
399:50 - field
399:51 - and I'll pass a list of
399:56 - float or decimal values
400:18 - so it's giving me as minus 3 and
400:23 - four
400:28 - sorry I made a mistake the Seal of 3.166
400:33 - will be 4 and the floor will also be 4.
400:39 - but it is different for
400:43 - 3.667 for that value
400:50 - the field will be 4
400:53 - but
400:55 - the floor will be three point a 3.0 or
400:58 - 3. so sorry made a mistake and I should
401:03 - not execute this block so I'll just
401:06 - try to undo it
401:08 - so in today's lecture we covered
401:11 - different Universal functions in numpy
401:14 - which help us round
401:16 - decimal or float values that will be all
401:19 - for today this video is brought to you
401:21 - by programming knowledge please like
401:23 - comment share subscribe and hit the Bell
401:26 - button for updates and stay tuned with
401:28 - us for next lecture thank you hi guys
401:32 - welcome back to our course on numpy in
401:34 - today's lecture we are going to take a
401:36 - look at some Universal functions which
401:39 - help us perform logarithmic operations
401:42 - so let's get started
401:45 - let me just change the notebook name to
401:48 - logs
401:51 - so it's done so numpy has functions to
401:55 - perform log at the base 2 10 and E
402:01 - so there are direct functions available
402:03 - to perform
402:05 - these logs
402:07 - that is the base to the base 10 and the
402:12 - base e lock at base e is also called as
402:17 - natural log
402:19 - and then we'll discuss
402:21 - a general way to take log at any base
402:32 - so then there is a general way to take
402:35 - log
402:37 - at anyways
402:40 - first of all we'll start with log at the
402:43 - base 2.
402:49 - so log at the base 2.
402:52 - so first of all I'll import number as NP
403:01 - and I'll write ARR is equal to NP dot a
403:05 - range
403:07 - 1 comma 11.
403:11 - it will return me a list of
403:15 - numbers from 1 to 10. so this e range
403:20 - method or function returns array if you
403:24 - recall we have discussed it earlier
403:27 - in many lectures
403:31 - so I'll just print in P Dot
403:34 - log
403:36 - 2 and Arena
403:40 - so it will perform log at the base 2 for
403:43 - all the values in this array so you can
403:47 - see that log 2 to the base 1 will be 0
403:51 - Log
403:54 - 2 to the base 2 will be 1 and so on we
404:00 - know that this is locked to the base 2
404:02 - because for 2 it gives us 1 because 2
404:06 - raised to power
404:08 - one is two
404:10 - Now log at the base 10
404:14 - so we just need to replace log 2 by log
404:17 - 10. so NP DOT log
404:22 - 10 and then we have to pass the array
404:25 - name
404:27 - so it should give us 1 at 10 yes the
404:32 - result is as expected because log 10 to
404:36 - the base 10 will be 1 so in this way we
404:39 - know that our answer is correct
404:46 - now
404:48 - let us take log at the base e
404:55 - so log to the base e or
404:58 - popularly known as natural log
405:06 - so we just need to replace log 10 or log
405:10 - 2 by simply log
405:13 - and it gives us the log at the base E
405:17 - for
405:18 - every element of the array now if you
405:20 - see clearly it gives around 1 for 3
405:25 - because the value of e is two point
405:29 - something
405:30 - and it's closer to 3 so log 3 base e
405:38 - will be closer to 1 so value of is 2.718
405:43 - so log
405:45 - 3 to the base e will give us a value
405:49 - very closer to 1.
405:52 - now we'll
405:53 - see a general way
405:56 - to perform log at any base
406:04 - so this is not using numpy Universal
406:08 - function
406:10 - we'll do it by using function log from
406:16 - math library of python
406:20 - so I'll just import
406:22 - from math import log
406:26 - import numpy as NP and NP log is equal
406:30 - to NP Dot from p func
406:37 - log
406:41 - and
406:43 - 2 comma 1.
406:47 - and I'll print this NB log
406:52 - for 100
406:54 - comma 15.
407:01 - so we have created a sort of new
407:05 - Universal function if you see the
407:09 - pattern here if you don't see the
407:11 - pattern here compare it with the video
407:13 - where we created a universal function
407:18 - from scratch and stored it in the numpy
407:21 - ufunk library
407:24 - so in today's lecture we covered some
407:27 - Universal functions related with
407:30 - logarithmic operations that will be all
407:33 - for today this video is brought to you
407:35 - by programming knowledge please like
407:37 - comment share subscribe and hit the Bell
407:40 - button for updates and stay tuned with
407:43 - us for next lecture thank you

Cleaned transcript:

Welcome to our first video on numpy lecture Series this is gonna be an introductory video so let's get started so what is numpy numpy is a library for the Python programming language it's stands for numerical python it was created by Travis oliphan in 2005. it supports large multidimensional arrays and mathematical functions to operate on these Aries now the million dollar question is why use numpy when we are able to process arrays with the help of python lists this is because python lists do serve the purpose of arrays but they are too slow to process numpy aims to provide an array object that is more faster than traditional python lists Aries are very frequently used in data science with speech and resources are very important if we have a slow array then it will affect the speed of the program and also increase the time in which the program is executed some of you must be wondering what is data science data science is the branch of computer science that deals with storing using and in analyzing data and deriving information from it now let's move on to our next question why are numpy arrays faster than this let us look at the basic definition of an array anari is a collection of homogeneous data types that are stored in contiguous memory locations this is the definition that we are learning since kindergarten so we all know that Aries are implemented with the help of lists in Python now a python list is a collection of data types stored is in noncontiguous locations so fetching R elements from noncontiguous location takes more time this is the reason why python lists are slower and numpy Aries are about 50 times faster than pythonless let's look at the other benefits of numpy it supports efficient manipulations and operations on highlevel mathematical functions and multidimensional arrays it contains functions related to linear algebra random number capabilities see random number is very important in numpy for creating random distribution plots we will get into it later on it also supports functions related to Fourier transforms or transformations it provides tools for integrating C and C plus plus code Etc in Python and numpy is used mostly for scientific computing now let's move forward to the actual coding part first of all let me teach you how to install numpy on your system here I'm using a Macbook and I have my web installer package already installed so I'm just going to write babe install numpy and hit enter button so I have numpy already installed on on my system so it's showing requirement already satisfied but in your system it will process for some time and download the essential modules now let me just get started with python on three and hit enter button now I need to import numpy so for that I'm going to write import numpy as NP and hit enter now we don't get an output here this is because there is nothing to display or there is no such command now I'm going to create an array ARR equal to NP dot array and I'm going to pass a python list that is one two three four five so I have passed a list you can give any value that doesn't matter now I've successfully created an array now I want to print this array for that I need to write print bracket ARR and hit enter so we have successfully created and displayed an array now some of You Must Be Wondering Why did we import numpy or numpy SNP now let's see if we import it directly without giving it a nickname or a pseudo name so I'll just go back to Python 3 Type Python 3 and hit enter and now I'll import numpy by writing import numpy hitting enter and then creating an array again that is ARR or array name equals to numpy dot array and passing a python list to it so now I'm gonna print this array by writing print bracket ARR and hit enter now you can do this way or or you can do it the other way it doesn't matter but in large program you may need a pseudo name or a nickname or a reference so that while writing last fragments of code you can reduce hello welcome back to our course on numpy today we are gonna learn about ndimensional Aries so let's get started so our first and foremost question is what is ND array so according to numpy.org I'm Andy array is a usually fixed sized monthly dimensional container of items of the same type and size the number of dimensions and items in an array is defined by its shape which is a tuple of n nonnegative integers that specify the sizes of each Dimension the type of items in the array is specified by a separate data type object called as TType one of which is associated with each ND array so this is more of a complicated definition so in simpler words we know that numpy is mostly used to work with Aries the array object is numpy is called as ndra we create a numpy ND Ira object by using the array function so the thing is ND array is nothing but just n dimensional array like one dimension two Dimension three dimension let me just type python 3 and hit enter now I'm going to import numpy so import numpy as NP and hit enter now I'm going to create an array that is ARR or Avenue NP dot array and we are going to pass a python list here I'm taking the values one two three but you can take any value you want to so I have created an array I have passed a python list now I'm going to print it so I'm going to write print aaroni or ARR and now I'm going to hit enter so I got my array now let us print the type of array so I have told you earlier that that array object in numpy is indiary now let's verify it by printing the type so print type and array name so we can see that we got output as numpy dot ND array now type function is a builtin python function that tells us the type of the object passed to it like in previous code it shows that ARR or array name is numpy dot ND array type now some of you must be wondering why do I always pass python lists as input so uh in general to create an ND array we can pass a list double or any array like object into the array method it will be converted to ndra so now I'm going to show you an example where I'm going to pass a python Tuple so life is going as usual let me just write import numpy as NP and hit enter now array name is equal to numpy dot array but this time I'm going to pass a tuple so now I'm I'm going to print so you can see that it is in a list format but when I print the type and pass array name it shows numpy dot in the array now let's talk more about arrays so generally we have an ndimensional array where n can take the values 0 1 2 3 up to n so let's start with Zero Dimensional arrays so Zero Dimensional arrays are nothing but scalars for example the numbers 1 2 3 4 each of them represent a scalar or a Zero Dimensional array now an array that has Zero Dimensional arrays as its elements is called as a unidimensional or one the array for example I write bracket and inside I gives the values 1 to 3 4 so one dimensional array has Zero Dimensional arrays as its elements similarly a twodimensional array has one dimensional arrays as its elements a threedimensional array has 2D arrays or matrices as its elements an ndimensional arrays have n minus one dimensional R is as its elements so twodimensional arrays are called as second order tensors threedimensional arrays are called as third order tensors and generally an N dimensional array is called as nth author tensor but the most basic and most common arrays that we use in our daily life are one dimensional artists higher dimensional arrays find more relevance in fields such as machine learning and artificial intelligence now let's Implement these arrays so guys I have opened my terminal now I'm just going to type Python 3 and hit enter I'm going to import numpy as NP hit enter and then I'm going to write arr0 is equal to NP dot array in in bracket this time I'm not going to pass a list I'm going to pass a scale because this is a Zero Dimensional array now I'm going to print err or zero and hit enter so I got the result as 21 note that this is a scalar and not in list or we can say it is not in list format now I'm going to create a onedimensional array ARR one is equal to num P or NP dot r a and this time I'm going to pass a list now I'm going to hit enter so array has been created now I'm going to print it so I'm going to right print ARR 1 close the bracket and hit enter now let's move on to a 2d array so I'm going to write ARR to is equal to NP dot array please note that this time I'm going to pass one dimensional arrays as it's element so I'm going to write square bracket square bracket again and one two three four sorry you can't take anything one two five and comma and I have to pass one more list because basically its elements are one dimensional app is now let me just hit enter and print twodimensional array sorry I have to print error off to not the evaluate index 2. so please take care you can also make this mistake so now print it added successfully so let us now create a threedimensional array which is third order tensor so AR out of three is equal to NP dot array and this time we are going to pass two dimensional arrays as its elements so square bracket square bracket and one more square bracket and pass the elements so I have passed one 2D array now I'm going to pass one more so this threedimensional array has two twodimensional arrays at its elements so 3D array has been created now we have to print it by using print and in bracket we have to write ARR of 3 and hit enter so we have successfully printed a 3D array now we have seen how to create a onedimensional array a twodimensional array and a threedimensional array now I'm giving you an assignment create a fourdimensional array you have to follow the same procedure you just need to pass 3D arrays assets elements in today's lecture we covered and dimensional arrays ndra use of type function one dimensional array Zero Dimensional array two dimensional array three dimensional array how to create them and we have also given you an assignment that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned for next lecture bye hi guys welcome back to our course on numpy in our last lecture we covered ndimensional arrays and today we are gonna learn about array indexing so let's get started so the first question that arises in our mind is what is array indexing so our indexing is nothing but accessing an array element now how can we access an array element the answer is pretty simple by referring to its index number indexes start from 0 the first element is stored at the index 0 the second element is stored at index 1. and so on that end element is stored as index n minus 1. now let's see how can we do indexing in arrays of different dimension so let's first access array element for a 1D array so we just simply need to write print array name and we have to write the index that is a in 2D array it will be print a comma B because we have two parameters row and column similarly in a 3D array which is a third order tensor we need to pass three parameters and in general in an ND array or n dimensional array we have to pass n parameters as array index to print or access the element now let's move on to the coding part so I have opened my terminal let me just write python3 and hit enter now import numpy as NP hit enter and now I'm gonna create a 1D array so let's start with 1D array so ARR or array name one is equal to NP dot array and I'm gonna pass a python list to it so let it be 2 comma 3 comma 1 comma 5 comma 3 comma 2 comma six and hit enter so we have successfully created a 1D array now let's print an element or axis an element so I'm gonna exist element at index 0 but I made an error instead of passing Error 1 I passed ARR which is not defined so I'm gonna do it again print arr1 of 0 and the last element ARR one six so element at first index is 2 and the element at 6 index is six so I can also perform algebraic operations while printing let me just show you so I'm gonna write print err one index five into ARR one and index Let It Be 2 so it will show the multiplication of elements as Deeds to index so element at index 5 is 2 and element at index 2 is 1 should it display the result to similarly we can perform subtraction so arr1 element at index 3 minus element at index one sorry I made an error again let me just correct it so the answer is 2. so let's move on to a 2d array let me just create a 2d array so I'm gonna write arr2 is equal to NP dot array and this time I'm gonna pass 1D array as its elements so let it be 1 comma 2 comma 3 dot comma 4 bracket close five comma six comma seven comma bracket use so I'm gonna print the second element in first in second row so guys am I doing it right I have done it wrong please try to be careful because this is the wrong index I want to access some other element but I have passed some other index now this index 0 comma 1 it represents the first the second element and first row and not the second element in second row so please be careful because you can also do these kind of mistakes and I'm trying to help you Rectify those mistakes so the element that I have actually printed was it was the first element no it was not the first element it was the second element in first row so guys please try to be careful this is the most common mistake that we do while indexing I'm showing you this because I have seen a lot of people making these kind of mistakes even in engineering second air and third year this is a very common mistake so please try to be more careful and write the indexes correctly so second element in second row so I'm gonna pass one one this time and it is six now should we move on to a 3D array let's move on to a 3D array so I'm just gonna create a 3D array come on guys I'm just joking I'm not gonna create a 3D array instead I'm gonna give you an assignment that is create a 3D array yourself we have discussed how to create a 3D array and now you have to create a 3D array and access the first element in 3D array so in today's lecture we covered array indexing indexing in 1D array indexing into the array and I also give you an assignment to do indexing in a 3D array that's all for today this video is brought to you by programming knowledge please like comment share subscribe for updates and stay tuned with us for more lectures bye hi guys welcome back to our course on numpy in our last lecture we covered our indexing and today we are gonna learn about negative indexing and the use of Endive method so let's get started so first of all what is negative indexing so negative indexing in negative indexing we use negative indexes to access array elements from the end let's take an example that we need to print or access the last element of the second row in the given array so index number for elements for second row will be like 1 comma n minus 1 when we are using positive indexing and where we want to access the nth element from the beginning but in case of negative indexing the index number for the second row will be like 1 comma minus n where we want to access the nth element from the last now please note the difference in positive indexing we are accessing nth element from the beginning and we are giving the value 1 comma n minus 1 but here we want to access the nth element from the last so we are giving the values 1 comma minus n now let's do negative indexing for this array so here by positive indexing the index of the last element of second row will be 1 comma 4 as is it is the fifth element from the beginning and in general for nth element from the beginning the index number will be row count minus 1 comma n minus 1. and if we do negative indexing the index will be 1 comma minus 1 as it is the first element from the last or the nth element from the last so in general for nth element from the last the index number will be row count minus 1 comma minus n now so let's open them let me just write Python 3 and hit enter now import numpy as NP hit enter let's create a 2d array first so I'm gonna create a 2d array so I'm gonna write arr2 is equal to NP dot array and now since we know that the elements of a 2d array are 1D array so I'm gonna pass to list as its element so let the list element will be one two three four and two four three one close the brackets and hit enter so we have successfully created a 2d array now let's print so I'm gonna write print the second element sorry the second row and the last element so it's gonna be ARR or array name one comma minus 1. because positive indexes start from 0 and negative indexes start from 1 so the second row and last element is 1. now let's print the array so we have printed the array and you can see that the second row and last element is 1. now some of you might be wondering can we pass both the values in negative indexes yes we can so for the last row it will be minus 1 and for the last element it will be minus 1. so second row and last element when we have passed both the values as negative is same it's one now let's print the second row and the second last element so I've written the command and now I'm gonna hit enter so as you can see that the second row and the second last element is three now let's do it again by changing the row value now we are gonna print the first row and the second last element so I've written the command and hit enter so the result is 2. as you can see from the array now I'm gonna do it again but this time I'm gonna give negative values so the result is again two this was all about negative array indexing so now I'm gonna give you an assignment that is create a 1D array and access its last element now yeah you have to use positive indexing as well as negative indexing while doing this assignment so now let's move on to our next topic for today that is use of enzyme method so and I method Returns the number of dimensions in an array the syntax is print bracket array name dot ending or first we can store the result in a or any variable like a is equal to rename dot enzyme and then we can print a so let's see an example so I've opened my terminal I'm gonna write python3 and hit enter I'm gonna import numpy as NP hit enter now I'm gonna create arrays so first R is AR 0 is equal to NP dot array bracket I have passed the value 32 and this is a Zero Dimensional array or a scalar now I'm gonna create a 1D array so now I'm gonna create a 2d array so I've created a 2d array now let's move on to the use of ndi method so I'm just gonna write print arr0 dot enzyme so it's gonna give me 0 because it's a zero D array similarly to check the dimension of the 1D array I'm gonna write arr1 Dot N dime so it shows result 1. and in the same way when we do it for 2D array it's gonna print the result as 2. so by the use of n die method you can get the dimension for any array it will display the result as the number of Dimensions present in that particular array now the assignment for you is to print the number of dimension for the fourth dimensional array that you created as your the path of your previous assignment so this was all about the use of enzyme function or enzyme method hi guys welcome back to our course on numpy today we are gonna cover array slicing so let's get started so first of all what is array slicing slicing means taking elements from one given index to another index here instead of passing an array index we pass a slice so the syntax is that we pass a starting element and an ending element that is denoted by start and end respectively we can also Define the number of steps we want to take while slicing so we can pass either two parameters start and end or we can pass three parameters that are start and understood so now the question arises what if I ignore or don't pass these three parameters if we don't pass start it is taken as zero if we don't pass end it is taken as the length of array in that Dimension and if we don't pass step it is taken one by default now we can also slice the array using negative indexes so this is a brief introduction to array slicing now let's move on to the coding part so guys let me just import numpy as NP and hit enter now I'm gonna write array name or ARR is equal to NP dot array and now I'm gonna pass a python list to it Let It Be One comma 2 comma three comma five and hit enter now let's slice elements from index one to index 5. sorry here we have indexes from the 0 to 4. that is size 1 so if I pass we're gonna slice elements from index 1 to index four and I'm gonna write print array name err and I'm gonna get start as one and and ask for that is the last index and I'm gonna press enter so it displayed two three and four so there's a very important observation to make here so what is that observation we can observe that it has included the value or the element at index one but it has not included the element at index 4 so it's not gonna include the value at index 4. so indexing will always neglect the element which is present at end or the parameter that is given so in general when we write array start call it n it will ignore the element at the ending index and it's going to include element at the start index so please keep this in mind because in questions related to Output we can make this kind of sillimistic so it's good to be careful so start will be included in the result while end won't be included in the result now let's see what happens when we don't pass start so I'm gonna write print ARR so array has been printed now I'm gonna give it a slice so I'm gonna print ARR I'm not gonna pass start this time so start is empty and I'm gonna give end as the third index so it should print one two and three as you can see the result is 1 2 and 3. now let's see what happens when we don't pass end so let me just write print array name or ARR and I'm gonna pass start S2 and I'm not gonna pass any end let me just hit enter so at second index the value is 3 and since we have not passed an end it will take the size of R in that Dimension that is 5 as end so it's gonna print 3 4 and 5 minus 1 the valued fourth index so it print 3 4 and 5. so here in above examples we did not pass the step size so by default it is taken as 1 as we already discussed now let's do or let's pass step size I'm gonna create a new array that is err1 is equal to NP dot array and I'm gonna pass a list of a bigger size the current list was short in price so if I increase the step size there will be less elements so to exhibit or to display the method of slicing using sip size I have created a new array and I've printed the existing array as well as the newly created array now let's pass step size and do the slicing so for the first array I'm gonna give the start as zero and I'm gonna give end as four and let the step size be equal to 2. so the value at zeroth index is one and at Fourth index is 5 so it should print the elements one and three sorry there was a mistake in the syntax so it shows the in invalid index or sorry invalid syntax so let me just Rectify it and do it again so this time I'm gonna write print ARR um print error one again and let me just write the command again so I'm gonna write ARR 0 4 and 2. so the result is 1 and 3. now let's do it for the second array so the start was 0 and the end was eight so it displayed one three five and seven as theoretically expected now we have an observation to make here if we observe carefully the command that we have written have returned every other element from index 0 to 4 sorry from the index 0 to 4 for the first array and every other element from index 0 to 8 in the second nappy so now let's move on and print every other element in the whole array so let's see how to return or print every other element in the whole array or entire array so I'm gonna write print every name I'm not gonna pass the start or end I'm just gonna pass step size that is 2. I'm gonna close the bracket and hit enter so it has returned every other element in entire array now similarly return every other element in the second array so it shows 1 3 5 7 and 9. so we have returned every other element in the array now let's slice a 2d array so I'm gonna write arr2 equal to NP dot array and I'm gonna pass 2 1D arrays as its elements let them be 1 comma 2 comma 3 comma 4 and the other one the array will be 1 5 6 7 and 8. sorry this mistaken parenthesis so let me just do it again I've created a 2d array now let me print it so I've printed array now I'm gonna slice so so I'm gonna slice element or elements from index 1 2 index for and of course the index 4 will not be included and in second row so I'm gonna write print ARR or array name and I'm gonna give please be careful here we have to pass the first row and instead of column value we are gonna pass the slice so please be careful so I've passed sorry there was a mistake let me just correct it and and hit enter sorry the array name was written incorrectly so let me just change it to arr2 so it has given us the corresponding values that are 6 and 7. now similarly we can pass the row value as a slice and give some column value or we can do both path to row value as a slice on the column value as a slice so similarly we can slice a 3D array and in general we can slice an N dimensional array so there's an assignment for you take create and slice a 3D array now some of You Must Be Wondering dot can we slice and array using negative indexes are red negative indexes the answer is we can do it for sure so surely we can so I'm just gonna print the existing array and now I'm gonna slice it using negative indexes so first of all we need the values of the indexes to slice so let's slice from index minus 3 to index minus 1. so let me just write the command that is print ARR 3 comma minus 1. sorry I need to pass the slice instead of these values so this kind of Mystic is very common please be careful because you have to pass the slice and not the index so I have passes slice and it has shown with the result 8 and hi guys welcome back to our course on numpy in today's lecture we are going to study the data types in numpy so let's get started let's first take a look at the default data types in Python the integer float Boolean string and complex integer represents numbers like 1 2 3 minus 1 minus 2 minus three float represents real numbers Boolean represent true or false value and string represents text while complex represent complex number which has real as well as imaginary part let's move on to data types in numpy numpy has some additional data types and are represented using alphabets low case I stands for integer lowercase U stands for unsigned integer lowercase b stands for Boolean lowercase f stands for float low Case C stands for complex float Locus m stands for time Delta uppercase m stands for date time o stands for object uppercase s represents string and V represents chunk of memory or void now let's move forward to another topic that is how to check the data type of an array so numpy array object has a property called T type that Returns the type of array the syntax is print and in bracket we have to give array name dot T type and this command or this line or this thing will return as the data type of the array that we have passed now let's move on to the coding path and implement this so I have opened my terminal and I'll write Python 3 and hit enter now I'm gonna import numpy as NP and create an array ARR is equal to NP dot array and now I'm gonna pass a list to it but this time the less contains string characters and not integers so let the elements be pen banana you can take anything or chalk so close the brackets and hit enter now I've created an array now we are gonna print the data type so I'm gonna write print and in Brackets I'm gonna write I rename or ARR dot d type and hit enter so I have obtained the result as U6 please note that here U stands for Unicode string so now let's take one more example now I'm gonna create one more array and it's gonna be an array of integers so arr1 is equal to NP dot array and now I'm gonna pass an integer list to it so let the elements be one two three four close brackets and hit enter so I'm gonna print arr1 dot d type so the result is int 64. please know that end refers to integer so data type is integer 64. now let's move on and see how can we create an array with a specified data type so click to create an array with a specified data type we need to pass an optional argument while creating the array that is D type so the syntax is going to be array name is equal to NP dot array and we have to pass list and we have to add a comma and we have to pass Theta type as the required data type now let's take an example so let me just zoom the terminal now I'm gonna write python3 hit enter import numpy as NP hit enter now I'm gonna create an array but this time I'm going to specify the data type so let's create an array with data type 4 byte integer so I'm gonna write ARR or array name is equals to NP dot array and this time we are going to pass a list but we are also gonna specify the data type so I have to specify the data type as int or in this case we can use I also or I4 so 4 bytes um I hit enter so I'm gonna print array and I'm going to print its data type so print ARR Dot D type so you can see it's int 32. so 4 bytes means 32 bits now let's take one more example so let's create an array with d type or data type string so I'm gonna write ARR 1 or whatever the array name is is equal to NP dot array and I'm gonna pass a list to it but this time I'm gonna specify the T type or data type as s that represents string I made an error there's some problem in brackets I have added an extra right bracket so let me just Rectify it so let me just print the array print ARR I have to print the error one so print arr1 hit enter and you can see the result as a list of strings and when we print the D type or data type it shows S1 that is string N1 bye so now let's see what happens when a data type cannot be converted when you have a mixed kind of list that is it contains integers alphabets or it's in a mixed form and this problem in conversion so let me just give an example era 2 is equal to NP dot array and I'm gonna pass a character in list and other elements as integers and I'm gonna specify the data type as I that represents end so it says unmatched there's some problem in Brackets let me just correct it and do it again so it shows invalid literal for end with base 10. so this is the problem that arises when a data type cannot be converted hi guys welcome back to our course on numpy in our last lecture we covered data types and how to create an array with a specified data type so today we are going to cover the as type method so let's get started so we know how to create an array with a specified data type now the question arises how to convert data type on existing arrays the answer is the best way to change the data type of an existing array is to make a copy of the array with the as type method the ask type method returns a new data frame where the data types have been changed to a specified data type or in simpler words we can see that as type function creates a copy of the array and a laws U to specify the data type as the parameter please note that we can specify the data type using short notations like I for integer f for float or by using the data types directly like int for integer float for float Etc now let's see an example so let's change the data type from flow to integer by using I parameter value so let me just write Python 3 hit enter I'm gonna import numpy as NP now I'm going to create an array so I'm going to write NP dot array and I'm gonna pass a list so this is a list of float floating Point numbers so it gave me an error because I made a mistake I need to insert comma so let me hit enter I've created an array now let me use the ask type method to create a new array so new a new array name is equal to ARR dot as type and in bracket I'm gonna specify the data type so it's I here and your has been created now let's display so I'm gonna write print ARR hit enter this was our original array let's display the data type of the existing array or the old array it's showing float 64. now let's print the new array and print the data type of the new array so I'm gonna write print new dot d tag so it's showing n32 now let's move on to next example change data type from floor to integer by using end parameter value so last time we use I this time we are going to use end so I'm gonna write python 3. and hit enter I'm gonna import numpy I'm going to import numpy as NP now I'm gonna create an array so err or R Dynamics equal to np.ra and I'm gonna pass a list to it a list of floating Point numbers I made a mistake I need to go back to rectify it and I have to add brackets so I passed the list and I have created an array now let's create a new array using aspect method so new equal to array name dot as type and I'm going to specify the data type as int last time we used I in commas so I'm gonna print array and I'm gonna print the data type of original array so it's load 64 and I'm gonna print the new array and it's data type so the result is in 64. let's move on to another example change data type from integer to Boolean now if the data is or the data element is 0 it will return false and if it is greater than 0 it will return 1 or true so I'm gonna import numpy again as NP and hit enter I'm gonna create an array of integers so I'm gonna write NP dot array and I'm gonna pass a list to it and don't forget to add brackets so now I'm gonna hit enter array has been created now let's print the array and print its data type so it's in 64. now let me print no sorry now let me create a new array using as type method so new equal to Arab dot as type and and type I'm going to specify Boolean so it's bull or B Double L for Boolean so the new array is true false true false true these are Boolean values so I'm gonna print the data type of the new array as well so it is B Double L or Boolean so in today's lecture we covered the use of as type method and we looked at hi guys welcome back to our course on numpy in our last lecture we covered the as type method in numpy and today we are gonna learn about the difference between copy and view in numpy so let's get started so it is copy versus view so copy creates a new array it's a new array and view is just a view of the original array don't worry you'll understand it when we get into the code copy owns the data and view does not own the data those who have read database management system they might be acquainted with the term View so the changes made to copy will not affect the original array but the changes made to view will affect the original array so copy is just a new array which is a copy of the present array and view is just the same array with different name the changes made to view will affect the original array now let's move on to the code I've opened my terminal now I'm gonna write Python 3 and hit enter now I'm gonna import numpy as NP and hit enter now I'm gonna create an array with array name err is equal to NP dot array and I'm gonna pass a python list hit enter now add it has been created successfully so now I'm gonna write X is equal to ARR or array name Dot View and brackets and hit enter so I've created a view I'm gonna print the original array as well as I'm gonna print The View so print X so they both are the same now let's observe what happens let's now make changes to original array and see whether they are reflected to view so ARR zero is equal to 34. now we have initialized the zeroth index as 34. now I'm gonna print array as well as view to observe the difference see the array has been updated and the view has been updated so the changes in original array can affect View so we can see that view is affected by the changes made to the original array now let's move forward and make a copy so now I'm going to create a copy so why our copy name so copy name or Y is equal to ARR Dot copy and now I'm gonna write brackets and hit enter now a copy has been created now let's print the copy so it is same as the array now let's see what happens if we make changes in original array and their corresponding changes to copy and view so let's make changes one more time so I'm gonna write ARR or array name and initialize the second index as 243 so I've made changes to original RN now let's see whether these changes are reflected to view and copy so now I'm gonna print view see it has been updated now let's see what happens to the copy now we can observe that we have made changes to the original array and our view which is denoted by X has been updated or affected by the changes made in original array but the copy Remains the Same it has not been updated to the copy Y is not affected by changes while view X is affected now let's move on to our next topic that is how to check if Ari owns its data so this is basically a method of checking where the a given element is a copy or it's a view so we know that copies owns data and view does not own data but how to check this so every numpy array has an attribute base that returns none if the array owns the data otherwise the base attribute Returns the original object now let's take an example and understand it through a code so I'm gonna write Python 3 and hit enter now I am gonna import numpy as NP now I'm gonna tweet an array ARR is equal to NP dot array and pass the list to it so I've created an array now I'm gonna create a view as well as a copy so for view X is equal to array name dot view or ar Dot View and for copy Y is equal to arrename.copy or ARR dot copy now let's use base so I'm gonna write print x dot base so it Returns the original array because this is a view X is a view so it Returns the original array while y returns none because it's a copy so x dot base returns us the original array because it's a view hi guys welcome back to our course on numpy in our last lecture we covered the difference between copy and View and today we are gonna learn about the array shape so let's get started so the first question is what is array shape in numpy so the shape of Abby represents the number of elements present in each dimension now the next question arises in our mind is how to get the shape of an array so we can use the array attribute called shape to get the shape of an array so the result is a tuple which each index having the number of respective elements now let's move on to the code so let me just write python3 and hit enter now I'm gonna import numpy as NP and hit enter so now let's start with a Zero Dimensional array a Zero Dimensional array is a scalar so I'm gonna write ARR 0 or array name is equal to NP dot array and in bracket I'm gonna write a scalar this time I'm not gonna pass a double so now I'm gonna print err 0 sorry I need to rectify it arr0 and hit enter so I got the scalar as result now I'm gonna print arr0 dot shape so it returns me an NT double so it doesn't have any Dimension so it is a 0d array so now let's move on to 1D array so I'm gonna create a 1D array first so array name arr1 is equal to NP dot array and this time I'm gonna pass a tuple so the values from one to nine constitute the Tuple now I'm gonna print the array and I'm gonna print its shape since it is a 1D array it has one dimension and the number of elements in that Dimension is nine so now let's move on to a twodimensional array so first I'm going to create a 2d array so ARR of 2 or RN name is equal to NP dot array this time I'm gonna pass 2 1D arrays because we know that in a 2d array or Matrix the elements are 1D arrays so I've passed the elements now let me print ARR to and now I'm gonna print its shape so print ARR to dot shape so it has two Dimension the number of elements in First Dimension R2 and in second dimensional four it is other way of saying that number of rows are 2 and number of columns are four now moving on to a 3D array let's create a 3D array so the elements of a 3D array are 2D arrays so we have to create a 3D array accordingly so I've created a 3D array now I'm gonna print array and I'm gonna print the shape of the array so print err or 3 Dot shape so it's showing me list object has no attribute shape so let me just do it again there's an error so it's an attribute error so let me just create a 3D array again so let's try again this is the basic thing when you fail you have to try again just don't give up so here are three that's the image arr3 new or three new so here are three new is equal to NP dot r a and now I'm gonna pass two Diaries so I've created a 3D array a new 3D array from scratch again and now I'm gonna print error 3 new dot shape now I'm gonna hit enter so this has three dimension and the number of elements in respective Dimension are 2 2 and 3. so this is the optimized or the exact or the correct output now I have got an assignment for you you have to create a 4D array and you have to print and you have to print the shape of that 4D array you can also create a 4D array using ndi method as we discussed so in today's lecture we covered array shape hi guys welcome back to our course on numpy in our last video we covered shape of a numpy array and today we are gonna learn about the use of free shape method so let's get started so reshaping numpy Aries so we know that shape of an array is the number of elements present in each Dimension so reshaping refers to changing the shape of an array so what is actually achieved by reshaping that is addition or removal of Dimension and changing the number of elements in each Dimension so let's move on to the code let me just write python3 and hit enter now I'm gonna write import numpy as NP I'm gonna hit enter now reshape from 1D to 2D so we have to change the shape of an array from one dimension to two Dimension so I'm gonna write firstly we have to create an array to use the reshape method so I'm going to create an array so array name is equal to numpy or NP dot array and I have to pass a list so this is a list of 12 elements so I'm gonna close the bracket and hit enter so I've created a 1D array now to convert the 1D array to sorry I have to convert the one the array with 12 elements into a 2d array so I'm gonna write new array or new array name is equal to current array name ARR Dot V shape I'm gonna specify the parameters so into e array we have two parameters that is row count and column count so now I'm gonna print the current array as well as the new array so you can see that I got a new array with four rows and three columns so we have four rows with three elements each or we can say that we have a new 2D array with four rows and three columns so let's reshape from 1D to 3D so we are going to to reshape from 1D array to a 3D array or three dimensional array so I'm gonna write new array name is equal to current array name or arr.v shape and I have to specify three parameters here so let them be 2 3 and 2 so that the product is 12. so now I'm gonna print the current array as well as the new array so you can't see the result we have a 3D array with two elements and each element is a 2d array consisting of three rows and two columns now we have an important observation to make here do you guys observe anything yes there's a very important observation here so the product of the parameters that we have passed and the elements in the number of elements that we have is same so the product of parameters is equal to the number of elements in one the array or in general so this is a very important thing so we have to take care of this thing in our mind while reshaping the arrays now the question is can we reshape into any shape so the answer is no we can't do that so we can't reshape into any shape that we want to they there are some constraints so let's see an example so let me just create an array so errat or array name is equal to NP dot array and I'm gonna pass a list so let the number of elements be eight now I have created an array it has eight elements now what are the possible combinations of parameters that I can pass so let's see we can make a 2d array with four rows and two columns we can make a 2d array are if we create an array with eight rows it's just gonna be a 1D array because the thing will remain the same so eight rows and it just it's gonna be a skew so let it be two rows and four columns so we can make an array with two rows and four columns or four rows and two columns but we can't make a 2d array with three rows and four columns because that would require 3 into 4 that is 12 elements so that would require 3 multiplied by 4 that is equal to 12 elements but we have only eight elements so now let me just create new arrays so firstly creating a 2d array with four rows and two columns so let the new RN name be ARR new the RR mu is equal to ARR Dot preshape and I'm gonna pass 4 comma 2. now I'm gonna print the new array sorry the name is new so let me hit enter so we got a new array with four rows and two columns now let's make a 2d array with two rows and four columns so I'm gonna write error new is equal to reshape Dot sorry error.v shape 2 comma four I'm gonna print the new array so we have got a new array that is two dimensional with two rows and four columns now let's try to create a 2d array with three rows and four columns so this time I'm gonna pass three comma 4. so sorry I pass 3 comma 3 but still it cannot reshape because the size 8 can't be reshaped into size nine so it gives an error hi guys welcome back to our course on numpy in last video we started the reshape method and today we are gonna continue it so let's get started now let's see whether vshape method returns a copy or it returns a view let me open my terminal so I'm gonna import numpy as NP gonna hit enter now let me create an array so add a name is equal to NP dot array and I'm gonna pass a list to it as usual I'm gonna hit enter so array has been created I'm gonna print add a name or ar Dot reshape I'm gonna give the parameters and I'm gonna add an attribute base to it which is used to check whether it's a copy or it's a view so it gave me an error because the array cannot be converted because size is 9 and the shape is eight so I change it to 3 comma 3 and I have written another command print add a name dot V shape and parameters are three and three and added the attribute base to it and I got the result as the original array and not none so since I got the result as the original array this is a view this is not a copy now you might be wondering what if dimensions are unknown so we are allowed to have one unknown Dimension it means that we don't have to specify an exact number for one of the dimension in v shape method instead we pass 1 and numpy calculates the dimension for us so we know that number of elements is equal to product of the parameters so if we have two parameters the calculation will be number of element divided by the remaining parameters now let's see an example through code so I have opened my terminal once again I'm gonna write python3 hit enter and I'm gonna import numpy as NP so I'm gonna create an array again so array name is equal to NP dot array and I'm gonna pass a python list to it so numpy array has been created successfully now I'm gonna write new array name or new ARR equal to current array name or ar dot reshape and I'm gonna pass two comma 2 and minus 1 so this parameter will be calculated automatically let's see how so I'm gonna print ARR that is original array and new array that is print bracket new ARR so this is the new array now I'm gonna print the shape of the new array and hit enter after closing the brackets sorry I have added an extra pair of bracket let me just correct it so I'm gonna write the command again so the answer is 2 comma two comma Dot comma two so the numpy has automatically calculated third parameter now let's move on to the next topic that is flattening the arrays so what is flattening flattening array means converting a multidimensional array into a 1D array we use reshape and in bracket minus one method to do it so the syntax is array name dot V shape and in bracket we have to pass 1 let's see an example so I've opened my terminal I'm I'm gonna import numpy as NP let me create a 2d array for flattening so arr2 is equal to NP dot array and I'm gonna pass 2 1D arrays as the elements of a 2d array so I have created a 2d array now I'm gonna paint the sorry the array name is arr2 so let me correct it and press the original array and now I'm gonna print the shape of the original array so it is 2 comma 4 that is two elements in First Dimension and four elements in the second dimension so two rows and four columns so now I'm going to reshape it and now I'm gonna print the new array so you can see I've got a 1D array or a flattened array I'm gonna print its shape as well so you can see that that the shape is eight elements in First Dimension hi guys welcome back to our course on numpy in our last lecture we covered vshape method and today we are gonna cover another method under shape manipulation that is the transpose method so let's get started so what is transpose transpose is an operator which flips a matrix over its diagonal it switches the row and the column indexes of the Matrix thereby producing another Matrix some of you must be acquainted with the transpose method so let's see an example so let me just write python3 hit enter now I'm gonna import numpy as NP and hit enter so let's create a 2d or two dimensional array first to find its transpose so let the rnm be arr2 and error 2 or rnm is equal to num Pi dot array and I'm gonna pass 2 1D arrays as elements of a 2d array good morning sorry I made a mistake I have imported numpy as in p so I need to correct it so please take care of the name and the pseudo name or alias so I've created a 2d array now I'm gonna write the command to find its transpose so array name or arr2 will be equal to sorry here I have to write another command that is NP dot transpose and I have to pass the array name that is error2 now let me hit enter so this is the transpose and let me print the original array so that you can see the difference so this is the original array and what we printed previously was the transpose so we can see that original array and its transpose can be obtained by interchanging the rows and columns in a 2d Matrix now let's move on to another question this is a mixed problem on vshape method and transpose first we need to create a 1D array then we need to reshape it to a 2d array and then we need to find the transpose of the two dimensional array so let's go to the solution let me just write python3 and hit enter now I'm gonna import numpy as NP and hit enter now I'm gonna create a 1D array so let's create a 1D array first so let me just write every name this time I'm taking array name as ARR so ARR is equal to NP dot array and I'm gonna pass a python list to it so let the number of elements B 8. now let's reshape this 1D array or this array to a 2d array so I'm gonna write X is equal to ARR dot reshape or rename dot reshape and I'm gonna pass the parameters that is the number of rows and the number of columns I want in my 2D array so I've created a reshaped this into a 2d array now let's print the original array the reshaped array or array after reshaping and the transpose and the transpose so let me just write print ARR or print original array I'm going to write arrs so original array has been printed I'm gonna print the array after reshaping so this time it's gonna be X so the format in which it is displayed it's a little different let me just print X simply so that you can see the whole array at one place or whole Matrix at one place I'm gonna print the transpose so I'm gonna write NP dot transpose so X it's not X it's in P dot transpose and I'm gonna pass X as a parameter so you can see the transpose has been displayed now we can see the original array the array after reshaping and the transpose of the reshaped array so we have fulfilled all the requirements of the question hi guys welcome back to our course on numpy in our last lecture we covered the transpose method under sheep manipulation and today we are gonna learn about the flat and the flattened method under shape manipulation so let's get started so our first question is what is flattening so flattening an array means converting a multidimensional array into 1D array as earlier discussed we can use the reship method by passing 1 as a parameter to flatten an array but we have other methods as well so one of the methods is flat this function returns a 1D iterated over the array or in simpler words it will return the element corresponding to the index in flattened array and the other method is flatten method this function returns an array collapse into one dimension or it returns a 1D array now let's see some examples so let me just open my terminal so let me write python3 hit enter now I'm gonna import numpy as NP and hit enter so I have to create an array first so let the RNA be a so a is equal to NP dot r a and I'm gonna create a 2d array because of 1dr is already flattened and the elements of a 2d array are one the arrays so I'm gonna pass 2 1D arrays as the elements of this 2D array so I've past elements and hit enter now I'm gonna print the original array so you can see the array has been displayed now let me use the flat method first so now let's use the flat method so print after using the flat method or the flat function so we are going to print a DOT flat and we are gonna pass an index so this function will return us the value at index 5 in the flattened array now you can see the value at index 5 in the flattened array is fixed so the value at the index 5 after flattened array is 6 and it has been displayed so the flat function returns 1D operator over the array now let's print the original array and the flattened array to verify our answer so I'm gonna write print array sorry I made a mistake array name is a so I have to write print a now let me print the flattened array using reshape method first so print a DOT V shape I'm gonna pass minus 1 to it so the flattened array has been displayed and you can see that the value at the fifth index in the flattened array is 6. now let's discuss one more way of flattening the array that is the flattened method so now let's look at an entire method of flattening the array are a method of flattening the entire area there is a little average so this is a method of flattening the entire array so I have to write print so let me print the original array first so print original array let me just write print and pass the array name to print the original array so the original array has been displayed now we have to flatten it using the flatten method so I'm going to write print and I have to use the method or the function flatten so I'm gonna write flattened array and now I'm gonna write a command as a continuation of this so a DOT flatten so flattened array has been displayed so this flattened array is 1 comma 2 comma 3 comma 4 comma 5 comma six comma 7 and comma 8 in one dimension so we have got our flat and array using flatten method so in today's lecture we covered flattening flatten method and flat method under shape manipulation that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and please stay tuned with us for more lectures on this series hi guys welcome back to our course on numpy in our last video we covered the flat and the flattened methods under shape manipulation and today we are gonna learn about the concatenate method so let's get started so the first and foremost question is what is concatenation or concatenation so concatenation refers to a group of things linked together or occurring together in a way that produces a particular result or effect and in the context of programming it refers to the operation of joining two entities now these entities can be arrays strings or anything so here we are going to deal with concatenation of two Aries or merging of two arrays so the general Syntax for concatenation is numpy dot concatenate or concatenate and we have to pass the list of arrays we want to merge and the corresponding axis now you must be wondering what is Axis so axis plural are defined for arrays with more than one dimension a twodimensional array has two corresponding axes the first running vertically downwards across row or the axis 0 and the second running horizontally across columns or axis one likewise a 3D array has three axis a 4D array has four axis and so on so now let's move on to the code let me just open my terminal so let me just write python 3. and hit enter now I'm gonna import numpy as NP hit enter now let's concatenate or join two one dimensional RVs so first of all we are going to concatenate or merge or join to 1D arrays so let's create to 1D arrays first so I'm gonna write arr1 is equal to NP dot array and I'm gonna pass a python list to it now I'm gonna create the second array in a similar manner so I have created to 1dras now let me print the result after concatenation of these two arrays so I'm gonna write NP dot concatenate and I'm gonna pass first ra or Error 1 and the second array or ARR to close the bracket and hit enter there was a bracket missing I have to add an extra set of brackets so it gave me an average let me just add an extra pair of brackets and hit enter now we can see the result of the merger of these two arrays now we can see that these arrays have been concatenated so we can see that the arrays have been merged concatenated or joined now let's move on and try to concatenate 2D arrays first of all we have to create two two dimensional arrays so I'm gonna write rr2 1 is equal to num Pi or NP dot array and I'm gonna pass to 1D arrays as elements of two dimensional arrays let me now create the second two dimensional array in a similar manner so let the element be four five six and seven eight nine for the second array of created to 1D arrays before concatenating 2D arrays let's first try to understand the concept of axis so I'm gonna concatenate the 1D arrays again but this time will have an observation to make so I have to concatenate the 1D arrays again so now I'm gonna print the result see I've concatenated the one the address again so by default the concatenation is done along the axis zero so by default the concatenation is along the axis 0. so you must be wondering why did not I pass an axis value when I concatenate it these 1D arrays now let's try to pass value of access so now let's concatenate along axis 1. so I'm gonna give the value of axis equals to 1. so it is given axis 1 is out of bounds or array of Dimension 1 this is because axis 0 is only present in case of a 1D array for X is 1 we have to move to 2dra now let's concatenate are two dimensional arrays so I'm gonna give add it to 1 and add it to 2. I'm gonna hit enter now now I'm gonna print the result or ARR new so this is the result of concatenation of 2D arrays along the axis 0. so this can be concatenated about axis 0 1 and none so an array of Dimension n can be concatenated along n number of axis starting from 0 1 and so on including none now I'm gonna display the result after concatenation along axis 1. so this is the result so in today's lecture we covered the concatenation method under shape manipulation that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and please stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last video we covered array concatenation under shape manipulation and today we are going to learn about the sort method which is used for sorting arrays in numpy so let's get started so first of all what is sorting so sorting refers to the action of putting elements in an ordered sequence an audit sequence is any sequence it can be numeric or alphabetical the order can be ascending or descending now the question is how to sort the numpy ndra has a function or method called as sort that will sort of specified array now let's move on to the code so let me write Python 3 and hit enter I'm gonna import numpy as NP and hit enter now let's sort the array alphabetically first so I need to create an array first for sorting purpose so let it be ARR and the command is error is equal to NP dot R A and I have to pass a python list so let the elements be banana almond or anything you like so the third element is chocolate because I like chocolate so I have closed the brackets and I fit into so I has been created successfully now let's thought so I'm gonna write print and then bracket I'm gonna write NP dot sort and I'm going to pass the array name that is ARR and close the brackets so we have displayed the sorted array so we got the result as the sorted Ari now let's move on let's sort a Boolean array so Boolean values are either true or false so we have to create a Boolean array first so arrb or Boolean array is equal to NP dot r a I made a mistake let me just correct it so this time we are going to pass either true or false values so let it be false false true and close the brackets and hit enter now let's display the sorted array so print NP dot sort and I'm gonna pass the array name or arrp and hit enter so I've got the sorted array but the thing is here the array I have passed and the sorted array appeared to be the same so we can't conclude anything because what we passed an input we got at output so here we got the sorted array but it appears to be same as original array so we can't determine whether it is sorted or not so there's no way of determining because input is same as output so how can we determine whether it's actually sorted or not so let me do some changes in the Boolean array and sort it again so I'm gonna add some true false values randomly to the array so I've added some values and changed to array and I've sorted array so now we can see that the false values are displayed first and two values are displayed at the last this is an important observation so now we can observe that in a sorted Boolean array false values will be displayed before the True Values so this is an important conclusion please take care because this may be asked in an output question in your examination so let's move on to two dimensional array now let's sort a twodimensional array so we have to create a 2d array first so arr2 is equal to NP dot array and this time we are creating a 2d array so we have to pass 2 1D arrays as its elements so let the add elements be three to one for the first 1D array and Let It Be 4 8. 2 for the second 1D array which is an element of 2D array now I'm gonna print NP dot sort and I'm going to pass the array name so I have got the result at the sorted array now we can observe that both the individual elements of the 2D array have been sorted or we can say both the 1D arrays that or which are the elements of 2D array have been sorted so in today's lecture we covered the thought method for sorting the arrays and we sorted 1D array and a 2d array that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and please stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last video we covered the Sorting and today we are gonna learn about iteration so let's get started so first of all what is the meaning of iteration iteration means going through the elements one by one we can use the basic for Loop for of the Python for iteration so iteration on a 1D array will go through each element or scalar one by one now let's move on to the coding path so let me just write Python 3 hit enter now I'm gonna import numpy as NP hit enter now iteration or iterate on the elements of a 1D array so this is the example where we gonna iterate a 1D array so let me create a 1D array first so I've created a 1D array now I'm gonna iterate it using for Loop so for X in array name or err and now I'm gonna write print X and hit enter twice so the elements of on the array have been displayed so this is the result we can see that when we will it wait on a 1D array it will go through all elements one by one so we can say that when will it wait on a 1D array it will go through all the elements one by one where individual elements are scalars this is a very important observation that we are actually going through the elements of the array in this case the elements are scalars so the scalars have been displayed now let's iterate on 2D arrays so we are gonna create a 2d array first so array name or arr2 is equal to NP dot array and now I'm gonna pass to 1D arrays to it because elements of a 2d array are 1D arrays so I have passed now I'm gonna hit enter so array has been created now I'm gonna use four for X in add a name or error 2 and I'm gonna print X so you can see that list to list have been displaced and not the scalars so some of you must be expecting the scalars as a result but we got the answer as to list which are the original elements of R to the array so we can see that when we iterate on a 2d array it will go through elements of 2D array when sorry which are not scalars so elements of a 2d array are not scalars but one Dr is so in this case 1D RS will be displayed so some of you might be expecting scalars but we got a different result now let's move on to 3D arrays so so in similar manner I need to create a 3D array first so I'll write array name sorry I've already imported so I don't need to write import so I have to write array name is equal to NP dot array and this time we are gonna create a 3D array so always remember to create a 3D array we have to pass 2D arrays as elements so I've passed 2D RS and there are two win numbers so let me just scroll the brackets and hit enter so error has been created now to write the for Loop so for X in ARR or array name I have to print X and hit enter twice so we can see that we got the result as 2 D arrays so we can say that when we iterate on a 3D array it will go through all the elements so it will go through all the elements one by one so it will go through all the elements of a 3D array which are 2D angles and not the scalar so in this case also we got the result as the elements of 3D arrays which are 2D arrays and not the scalars so there's an assignment for you so what you have to do is you have to iterate on the 4D array that you have created as a part of your previous assignment so we'll continue our discussion on iteration in the next lecture so today we started with the basics of iteration in numpy that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we covered the basics of iteration and today we are gonna continue with this topic so let's get started so iteration down to the scalers so to return the actual values the scalars we have to iterate the arrays in each dimension now let's see how so let me just write Python 3 hit enter and import numpy as NP as usual so let's have a quick recap so in our last video we saw that when we iterate on so if we iterate on a 1D array it goes through each element or each scalar element so it goes through each scalar element one by one similarly when we iterate on a one sorry a 2d array it goes through each 1D array element one by one so because the elements of a 2d array are one Dr is so it goes through each one drf one by one so similarly when we iterate on a 3D array it goes through each 2D array element so it goes through each 2D array element one by one so we are going to generalize it so in general we can see that if we iterate honor or on an ndimensional or ND array so if we treat on an ndra it will go through n minus 1. dimensions one by one so this is the generalized result now the question is how to iterate down to the scales so how to iterate down to the scalars how to achieve this thing so we have a goal and we need to achieve it so how to do it so one of the many ways so see whenever we have a problem we have a lot of ways of tackling it so one of the method that we can use here is using nested loops so we are going to use nested faults here so first example is it rate on each element on each scalar element of a 2d array or a twodimensional array so now let's create a 2d array first so so elements of 2D array are one Dr is so I've passed them and hit enter and has been created now I'm going to write the for Loop so for xn array name or ARR and nested Loop for y in this time we are not going to write in ARR or RNA we are going to write in x and we are going to write print y now we can see that each scalar element of the 2D array has been displayed so we are successful in iterating down to the or down to scalars now let's move on to iteration down to scalars in three dimensional arrays so similarly let's iterate down to scalars in a 3D array so we have to create a 3D array first and keep in mind that elements of an ndr array are n minus 1 D Alice so elements of a 3D arrays are 3 minus 1 equals to 2D arrays so we are going to pass 2D arrays as elements so you can take any random values close the brackets and hit enter so array has been created now we have to write the four Loops or nested Loops so for X in rnm or ER for y in x and for V in y and now I have to write print Z in case in place of print y as we did in 2D arrays so we can see that each scalar element of 3D array have been displayed so we are successful in iterating down to scalars in a 3D array now I got an assignment for you so it wait down to scalars in the 4D array that you have created as a part of your previous assignment so you have to iterate down to scalars in a 4D array so in today's lecture we covered how to iterate down to scalars in higher dimensional arrays that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture on this series thank you hi guys welcome back to our course on numpy in our last lecture we covered the method of iterating down to scalars in higher dimensional arrays using nested loops and today we are going to learn about the ND eater method so let's get started so first of all what is ndator Method so the function indicator is a helping function it solves the basic issues that we faced in iteration so in basic for Loops if we have ND array or n dimensional array iterating through each scalar element would require n Loops which can be difficult to write for arrays with very high dimensionality so what we are gonna do is use ndator method so let me just write python3 hit enter I'm gonna import numpy as NP so iterate all the elements or all the scalars or iterate down to the scalars in a 2d array so this is an example that we are going to you do using ND iter method our function so let first of all let's create a 2d array so you know the procedure how to do it we have done it almost 50 times or more I guess so create a 2d array the elements of a 2d array are 1D arrays so pass them close the brackets and hit enter so array has been created successfully now I have to use one for loops with ND iter method or ND heater function so for xn NP dot indicator and I am going to pass the array name so I have written the command and now I'm going to write the print function so print X and hit enter twice so I got the result as scalars so the result is scalars and we didn't need to use nested for Loops so we iterated down to scalars with help of one or only one for Loop and 1 and the heater function so now the question is why is ND eater function more convenient so you can say that why or you can ask that why should we use ND interfunction rather than using nested Loops because all of us are habitual of using nested Loops while iteration so ND inter function is convenient because we don't need to use nested loops but you might have a counter argument that you are comfortable with using nested Loops but then my response would be you can use nested Loop for 3D array for Dra 5D array but the array is off thousand dimensions let us consider that we have an area of 1000 Dimension then you need to write 1000 for Loops to iterate down to scalars in an array of 1000 or array with thousand dimensionality so ndated function is convenient because we don't need to use nested Loops here so in general if we have an ND array we need to use l Loops to iterate down to scalars so if n is of order 100 or 1000 it will increase loc or line of control or code it will increase the line of code and effort of the programmer so you need to write a lot of commands or lines in your code if you want to iterate down to scalars in an array of very high dimensionality so we can say that and the heater function is more convenient so now let's iterate down to scalars in a 3D array so let's iterate down to scalars in a 3D array using ND eater function so the process is same we need to create a 3D array first so elements of a 3D array are 2D arrays so I need to pass those you can choose any random values that you want to choose so just passed parameters and close the brackets and hit enter now you have created a 3D array now we have to write for Loops so for X in p dot NDT and we are going to pass the array name or ARR now we are going to write print X and hit enter twice so we got the desired result so I can say that we are successful in iterating down to scalars in a 3D array now I have an assignment for you so what you have to do is you have to iterate down to scalars in a 4D array or four dimensional array that you have created as a part of your previous assignment so you have to create a 4D array and use editor method to iterate down to scalars now let's move on to next topic which is iterating with different step size using indicator method so in last examples we had this step sizes one so let's change the step size and look at a different example so the question is iterate in a 2d array with help of ndated function and with step size 2 so I have to create the array first so follow the standard procedure so I've created the array now I have to write the function sorry I have to write the for Loop and I have to use n data function so for X in NP Dot and theater and F to pass array and in Array inside the square brackets I have to pass only the step size so it's going to be 2. I need to use square brackets so let's close the brackets and hit enter oh sorry by mistake I used an extra closing bracket this let me just remove it and hit the enter again so so I have written the for Loop now to write print X so I got the result so we have iterated down to scalers in a 2d array with step size 2. so the result is we iterated this 2D array down to scalars with step size 2 and using ND eater method so now I have one more assignment for you so the assignment is iterate down to scalars in the 4D array that you have created as a part of your previous assignment and you have to change the step size to 3. so in this lecture we studied about the use of editor method so that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture on numpy thank you hi guys welcome back to our course on numpy in our last lecture we continued with our discussion on iteration in numpy arrays and we demonstrated the use of and the iter method today we are going to start with searching and look at the where method so what is searching searching is the action of assessing a specified element from the array so here in this lecture we are going to use the where method to search in a numpy array so let me just write Python 3 hit enter now I'm gonna import numpy as NP so in this lecture we are going to demonstrate the use of where method for searching so let me just create an array first so array name or ARR is equal to NP dot r a and I'm going to pass a python list to it so I can write any random elements while creating the list and I need to close the brackets and hit enter make sure that your parentheses are balanced now I'm gonna create a variable X and I'm going to store the index in it so X is equal to NP dot where and I'm gonna pass the condition so where ARR is equal to 2 so this will return the indices where the value at index is 2 so we can see that the indexes or indices where the values 2 are 1 6 and 8. so this means that the value 2 is present at multiple indices which are 1 6 and 8. now let's move on to the next example now we are going to search for a value which is not present in the array so let me just give the value 10 which is not present in the array I have stored the result and I'm gonna print it so we can observe that I got the result as an empty fit or emptiness indicating that the value 10 is not present in the array so this results or it returns an empty list this means that the value 10 was not found or it's not present in the array now let's look at some more examples so one more example so we have to find so find the indexes where the values stored or values are odd so now we are going to write X is equal to NP Dot where and we are going to pass add a name or ARR mod of 2 not equal to zero so this is the condition for the odd elements that when they are divided by 2 the remainder is not 0. so we are going to print the original array and now we are going to print the indexes where the values are odd so at index 0 that is 1 R2 that is 3 at 4 that is 5 so these are the indexes where the values are odd now next example is find the indices where values are even now we have to replicate the same thing we just need to change the condition for all elements the condition is add a name mod of 2 not equal to 0 but here in case of even elements the condition will be array name or ARR mod of 2 equal to equal to 0. now I have displayed the original array and now I'll display the indexes containing even values so the even values are present at index 1 3 5 6 and 8. so in this lecture we started with searching in numpy arrays and we covered or demonstrated the use of wear method that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on number in our previous lecture we started our discussion on searching in numpy arrays and I demands created the use of where method in today's lecture we are going to cover the search sorted method for searching in numpy arrays so let's get started so Source sorted method performs binary search in an array it Returns the index at which specified values should be present in order to maintain the order so the thing is it assumes the array to be sorted so let's move on to the coding path let me just write python3 hit enter so here we are going to use search sorted method so search sorted method performs binary search on the array so we need assorted array so binary search is always performed on a sorted array so we need to sorted array just we like we do in binary search so array name is equal to sorry first after import numpy import numpy as NP hit enter now let's create an array in which the elements are present in ascending order or in other words an array which is already sorted so let me just create an array name or ARR is equal to NP Dot array and I have to pass a sorted python let's do it so let the elements be 1 to 10 close the brackets and hit enter now let's find the index at which value seven is present so I have to create a variable to store the value so it can't be ARR it has to be some other thing so X is equal to NP dot so it's sorted and I'm going to pass the array name and the value so I have to print X so the result is 6 it indicates that the value 7 is present at the index 6. now let's search for a value that is not present in the array so I have to write X is equal to NP Dot so it's sorted you have to pass the add a name as well as sorry the array name is error so I have to change it to ARR so I've passed 12 which is not evaluate the index so I'm going to print X so the result is 10 which is a little ambiguous because there is no index then and there is no value 12. let's try one more time so I'm going to write 130 this time and I'm going to print X again so again I got the result is 10 which is the number of elements present in Array and its little ambiguous because there is no index then we have indexes from 1 to 9. so I think when there is a value which is not present in the array it gives the number of elements present in the array as to the result and not the index or empty list so let's search from the right side so in previous example the indexes were counted from the left now let's count indexes from right now let's create a new array and elements are 3 4 5 and 6. so I'm going to write X is equal to NP Dot so it's sorted this time I'm going to pass the array name the element to be searched and also the side so the side is right so hit enter and I'm going to print X so the result is 2 but note that this is not the negative indexing from right because generally we prefer to do negative indexing from right so one thing that we need to observe is here the element is present at index to if we do positive indexing from right that is we conceded 6 at the root index 5 at first index and 4 at second index and so on now let's search for multiple values so till now we searched one value at a time but now we are going to search for multiple values at once so let's print the array first so R is three four five six and I'm going to write X is equal to NP dot so sorted and I'm going to pass the array name ARR and I'm going to pass the list of values for searching so I've passed the list of values and I'm going to print X so it denotes that the values 4 and 5 are present at the indexes 1 and 2. one thing to note here is here instead of returning a single index it returns a list of indices corresponding to the values or the search values or we can say that the values entered now let's move on to the next example which is in the form of a question so the question is for an array given as 1 comma 3 comma 2 comma one five comma 32 comma 53 comma 21 comma 67 we need to search the location of element or element 2 using search sorted method so this is the question now let's move on to the solution first of all the important thing to note here is that since the array is not sorted we have to sort it first because if we use the search sorted method it performs the binary search and for the bind research we need a sorted array so since the array is not sorted we need to sort it after creating and then search sorted method so these are the steps to approach the solution so first of all we have to create the array so add a name it's X this time so X is equal to NP dot array and I have to pass the list of elements given in the question so I've passed the list of elements and I have created the array successfully now second step is to sort the array using the sort method as already discussed in previous lectures so if you are not acquainted with it please go through the previous lecture another thing to note here is that I have not sorted it I just displayed the result after sorting I have to sort and store the result if I don't do that and directly use the search sorted method I will get ambiguous results or error so let's see what if I just sorted and display the result but not actually store the sorted result so after printing u i get the result as 1 but 2 is present at the location 2. and 3 so the result is wrong so the correct way to do is I have to store the result of the sorted array so there is a mistake here there were no changes made to original array so what I have observed is many students just display the result of after sorting and not don't actually make the changes to the original array or store it in another variable so this is a very common mistake please take care of this while doing any project or during your exam so now I have stored the result in a variable y and now I'm going to use the search sorted method again so I'm going to print the value of U so it returns me the index to because 2 is present at the index it is the desired result so in today's lecture we covered the search sorted method for searching in a numpy array that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and please stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we started about the search sorted method to search in a numpy array and today we are going to begin our new topic that is filtering of Aries and this lecture will cover two methods of filtering first one is using Boolean index list and the other one is by the use of filter function so let's get started so what is cell train getting some elements out of an existing array and creating a new array out of them is called as filtering in numpy we can filter an array using Boolean index list a Boolean list is a list of elements corresponding to indexes in the array we can also filter an array using the filter function if the value at the index is true that element is contained in the filtered array and if it is fault that element is excluded from the filtered array now let's move on to the code so I'm going to write Python 3 hit enter I'm going to import numpy as NP hit enter now let us first look at what we are going to do so filter so filter is used to extract values from a sequence under certain conditions so if the condition is fulfilled the value will be extracted and if it's not fulfilled the value won't be extracted so first we are going to create a Boolean array so let the elements be true false true false now let's create a sequence from which we have to extract the elements so this is a python array consisting of Boolean values now let's create a nump by sequence or numpy array to add a name is equal to NP dot array let me pass values so I'm gonna pass four values because I have four Boolean values in my original array but I made a mistake I named both the arrays as same so I need to change one of it so if I don't change and continue with the same names it will give me an error so I need to change so I'm gonna change it so lit the Boolean RS name be arrp denoting that it's a Boolean array now I'm going to do the action of filtering by writing the command new denotes the filtered array is equal to array name and in square brackets I'm gonna pass the Boolean array now I'm gonna print the new array so print new so I got the result as two elements corresponding to the True Values and excluding the elements corresponding to the false values so we observe that in the above example so the example will return 411 and 21 because the values in the array corresponding to so corresponding to that indexes in the Boolean array were true so only 411 and 221 were filtered because the Boolean values corresponding to these elements were true let's look at another example now so in this example we'll create a filter now let's define a new sequence or declare a new sequence so let it be integers from 1 to 10 so I have created a sequence now I'm going to use the filter method to create a filter and not use the Boolean list directly so I'm going to write list and this time I have to pass sorry I also need to write filter method so I have made a small error let me just Rectify my mistake so I've made a mistake and I have to correct it so let me just go back and write filter so I have to create a list so list and in list I have to write filter and filter I have to pass two sequences the Lambda function will generate a sequence a sequence which will contain Boolean values and the other sequence will be our original sequence so we got the result as 2 4 6 8 and then and we observe that this filter which we have created filters out the even elements from the array now let's create or let's create a filter to filter out the odd elements from the array so the procedure will be same we just need to change the condition in the Lambda function those who are not acquainted with Lambda function please refer to our python playlist so we just need to change the condition to not equal to 0 and we obtained the odd elements so we have filtered out the odd elements from the given sequence so that's how we filter array using the filter function of filter method so we demonstrated the use of Boolean index list and filter method for filtering an array that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture on numpy thank you hi guys welcome back to our course on numpy in our previous lecture we started our discussion on filtering of numpy arrays and we discussed two methods of filtering arrays that is using Boolean index list and filter method today we are going to look at another method that is the direct method so let's get started so filtering is a quite common task in numpy so there is an easy method to do it we can directly substitute the array instead of the iterable variable in our condition and it works just fine it will be clear when we look at some examples so let's move on to the code let me just write python3 and hit enter now I'm gonna import numpy as NP and hit enter now let's create a filter directly so creating filter directly from the array that's what we are gonna do so to create a filter we need an array first so let's create an array first to filter out the values from the array so we have to write array name or ARR or array or whatever you want I'm gonna avoid using array completely so I'm gonna write ARR is equal to NP dot array and I'm gonna pass a list to it so I have passed the list as you can see so I've created an array so here we won't use a Boolean index less so in previous lecture we filtered using Boolean index list and filter methods but here we won't use a Boolean index list will you do it directly because it's the direct approach now let's proceed to creating the filter or creating the filtered array so first we have to create a filter and then we can create a filter array so this is the filter so filter is equal to array name greater than 42 so it will filter all the elements which are greater than 42 and new array is used to store this result of the filter so note that filter actually filters a new array is actually storing the result of the filter so I'm gonna paint the new added here you can see that it's an empty list because there's no value which is greater than 42. now let's change the value and so it's now three so it will filter out all the elements which are greater than 3. so I've created a filter I've stored the result in a new array and I have printed the new arrays so all the elements greater than three were printed now you can see that I did not use a Boolean list directly in this example but let's understand what is actually happening at the back end so we need to observe we need to understand so please try to understand this clearly so I was saying that we did not use a Boolean index list directly but we still have a Boolean index list here it is not direct it's not visible to us but it is still present so let's see how so when we so when we execute it the command that is filtered is equal to array name or ER created in three it kind of creates a Boolean index list so the list is present but it is not visible to us so let me just print the result of this filter directly instead of storing the result in a new array so if I print filter I get a Boolean index list so a Boolean index list is present here but it's not visible to us and it's working in the back end so there is a Boolean index list but we did not create it explicitly we have not created a Boolean list directly as we did in the previous example so we can say that this is a direct method now let's see one more example so our objective in this example is to sort the even elements from the add a directly so we have to sort even element from the array and we have to follow the direct approach now I'm gonna write the command for the filter so filter is equal to array name mod of 2 equal to equal to 0 because this is the condition to sort the even elements from the array now I'm gonna store the result in a new array and I'm gonna print the new array I made a little mistake here instead of giving the proper brackets I gave the square brackets so I have to rectify it and write it again so all the even elements have been displayed so we got the even values in the array or original array so similarly we can do it for the odd elements or the odd values so in today's lecture we covered the direct approach for filtering the array that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next video thank you hi guys welcome back to our course on numpy in our previous lecture we started our discussion on filtering of numpy arrays and we discussed two methods of filtering arrays that is using Boolean index list and filter method today we are going to look at another method that is the direct method so let's get started so filtering is a quite common task in numpy so there is an easy method to do it we can directly substitute the array instead of the iterable variable in our condition and it works just fine it will be clear when we look at some examples so let's move on to the code let me just write python3 and hit enter now I'm gonna import numpy as NP and hit enter now let's create a filter directly so creating filter directly from the array that's what we are gonna do so to create a filter we need an array first so let's create an array first to filter out the values from the array so we have to write array name or ARR or array or whatever you want I'm gonna avoid using array completely so I'm gonna write ARR is equal to NP dot array and I'm gonna pass a list to it so I have passed the list as you can see so I've created an array so here we won't use a Boolean index less so in previous lecture we filtered using Boolean index list and filter methods but here we won't use a Boolean index list will you do it directly because it's the direct approach now let's proceed to creating the filter or creating the filtered array so first we have to create a filter and then we can create a filter array so this is the filter so filter is equal to array name greater than 42 so it will filter all the elements which are greater than 42 and new array is used to store this result of the filter so note that filter actually filters a new array is actually storing the result of the filter so I'm gonna paint the new added here you can see that it's an empty list because there's no value which is greater than 42. now let's change the value and so it's now three so it will filter out all the elements which are greater than 3. so I've created a filter I've stored the result in a new array and I have printed the new arrays so all the elements greater than three were printed now you can see that I did not use a Boolean list directly in this example but let's understand what is actually happening at the back end so we need to observe we need to understand so please try to understand this clearly so I was saying that we did not use a Boolean index list directly but we still have a Boolean index list here it is not direct it's not visible to us but it is still present so let's see how so when we so when we execute it the command that is filtered is equal to array name or error greater than three it kind of creates a Boolean index list so the list is present but it is not visible to us so let me just print the result of this filter directly instead of storing the result in a new array so if I print filter I get a Boolean index list so a Boolean index list is present here but it's not visible to us and it's working in the back end so there is a Boolean index list but we did not create it explicitly we have not created a Boolean list directly as we did in the previous example so we can say that this is a direct method now let's see one more example so our objective in this example is to sort the even elements from the add a directly so we have to sort even element from the array and we have to follow the direct approach now I'm gonna write the command for the filter so filter is equal to array name mod of 2 equal to equal to 0 because this is the condition to sort the even elements from the array now I'm gonna store the result in a new array and I'm gonna print the new array I made a little mistake here instead of giving the proper brackets I gave the square brackets so I have to rectify it and write it again so all the even elements have been displayed so we got the even values in the array or original array so similarly we can do it for the odd elements or the odd values so in today's lecture we covered the direct approach for filtering the array that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next video thank you hi guys welcome back to our course on numpy in our previous lecture we covered the direct method for filtering of numpy Aries and today we are going to do some more examples on array filtering so let's get started so we covered three methods of array filtering so far that is using Boolean index list the filter method and the direct method we also filtered the even and odd elements of a sequence using filter method and direct method now let's see how can we filter the even and odd elements of a sequence using the Boolean index list because in previous examples we used to specify the Boolean index list beforehand but now we are going to create Boolean index list using append method that is first of all we'll create an empty Boolean list and then we'll insert the element as true or false according to a certain given condition so let's move on to the coding path so I'm going to open my terminal write python3 and hit enter now I'm going to import numpy as NP and hit enter so let's create a filter Adi that will only return even values from the original array or original sequence so first of all we need to create an array and then we are going to create a filter array that will return only even values from that array so I've created an array I'm gonna hit enter now I'm going to create an empty filter first so the filter is empty it does not contain any Boolean value initially now I'll create a for Loop and if the element is divisible by 2 that is the mod is equal to equal to 0 then I'm gonna append True Value in the filtered array so if it's even the corresponding element in the filtered array will be true and if it is odd the corresponding value in the filter array will be false so we did not initially specify the value in the filter but we are appending the values based on certain conditions now I'm gonna store the values in the new array so I have stored the values in a new array it is giving me an error because of the wrong brackets I need to use a square bracket here so peace please keep these things in your mind while executing your code otherwise you will get an error like me so I need to change the brackets that I did and I'm gonna print the new array now so print new it is giving me all the even values in the array so we got the result as even elements let's understand what actually happened so this thing appears quite complicated when we observe it for the first time because you might be wondering why create an empty filter first and then insert the true or false values in it we do it because we don't know beforehand that what values are we gonna get so sometimes we have to take the array as input from the user so that's the case now what actually happened is the filter stored the Boolean values that were assigned with the help of loop or that would append it to the filter array so the array filter is nothing but a Boolean index list which was used to iterate which was used to filter the even elements from the array with the help of iteration and using a for Loop now for odd elements we need to follow the same procedure we just need to change the selection condition that is add a name or err or mod of 2 not equal to 0 in this case we have to append true so I have to change the condition so in case of not equal to 0 I have to in case of not equal to 0 I have to store true or also I can do is in case of equal to equal to 0 I can append false and otherwise I can append true else filter dot append true so you can follow any of the two approaches that I have suggested so now I'm going to store the result in a new array and so it is giving me an error exactly it should give me an error because there are now 20 values in the filter because 10 were the initial values from the previous example and 10 values are from this example so filter has 20 values which is why we are getting an error message so please be careful because you might do the same mistake now the error is that filter already contains some values and we added values to it so what you can do is that you can create a new filter and then you can store the result in a new array so I'm giving you the this thing as an assignment create a new array a new filter a new array instead of using the same code so this is your assignment so an assignment is to create a filter for filtering odd values or or elements from the same array which we used in this example now we have one more assignment for you so the second assignment is to create a filter for filtering the elements from the array in the given example so filtered elements from array in given example or in this video lecture which are greater then four so in this video we discussed some examples based on filtering using Boolean index list that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we did some examples on array filtering and today we are going to study how to calculate mean median mode and standard deviation using numpy methods so let's get started so as you must be knowing mean median and mode are the measures of central location of data and standard deviation gives us the extent of deviation of the data about the central location these measures are of utmost important while analyzing any data so let's get started with the coding part let me open my terminal so I'm going to write Python 3 hit enter now I'm going to import numpy as NP so first of all let's talk about or let's take a look at the measures of central location so as you must have studied in statistics at some level about the majors of central location so there are three main majors of central location they are mean median and mode as we know the mean refers to the average value of the data similarly the median refers to the middle value of the data so median divides the data sets into two equal parts and finally the mode refers to the most common value it is also known as the most repeated value of the data sets now let's calculate the measures of central location using numpy methods for that we need to create an array first so let's create an array and calculate all three measures of central location for that particular array so I'm going to create an array with name X so X is equal to NP dot array and I'm going to pass a python list so this is our data so it can contain any random values but make sure that it had some repeated values so we calculate the mode otherwise it will be a multimodal data set now let's start with calculation of mean so let's first calculate mean and we are going to use the standard formula so what is the standard formula standard formula is the one that you use like you calculate the sum and you divide by the number of samples or number of observations so this is not a numpy method it is the general formula that we use or we are using since fourth or fifth grades so we need to find the sum of all the samples or all the values and we have to divide by the number of values or the number of samples so let me just add all the values and divide it by the number of values so what is the number of L is one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen so I have total 15 values or 15 samples so I have to divide by 15. so divided by 15 close the bracket and hit enter so this is the mean that is 3.5333333 and so on now let's use the mean method which is the method of numpy so I just need to write print in P dot mean and I have to pass the array name we can see that we obtain the same result in both the cases so I don't need to add all the values and divide it by the number of values because if we have a very large data set it will be difficult so it's easier to use the standard method offered by numpy let's calculate median now which is the middle value so to calculate the median we should have a sorted array now the question arises that why do we need a sorted array so if you are in a state to recall the method you followed in your primary school that we just need to sort the array in US sorted order whether ascending or descending and we just need to circle out the middle value so you need to count from beginning and count from back and the value where you meet by taking unit step at a time so that value will be the median and in case you get two values it will be the average of those two values so here I have obtained the array in a sorted order using the sort method of numpy now the middle value as you can clearly see is three so median of this data is 3. now let's use the median method for that I just need to write print NP dot median and I need to pass the array name so as you can see that the answer is 3. so now let's calculate or move on to mode thank you so let me just obtain the sorted array again as you can clearly see in the sorted array 2 is repeated five times so it is the most repeated value so mod of this data set or data is to now let's use the mod method now the procedure is same print NP dot mode and pass X but you got an error this time so here's the catch numpy does not offer any method to calculate mode so there is no inbuilt method in numpy to calculate mode so you must be wondering how to calculate more than I'll get back to that topic in a while first of all let's explicitly mention this error because there's a very high probability that you will make the same mistake and get the same error while calculating the majors of central location because other central location measures can be calculated by numpy methods but for this you need a scipy method called as mode so I got an error because mod is not an attribute of numpy it's an attribute of PSI Pi or Scientific Python we'll discuss this library in detail later on we will create a separate playlist for scifi for now just look at what I'm going to write and copy paste the same thing in your command prompt or your terminal or whatever ID you are using to implement this code so from PSI Pi import stats so stats is a module of PSI pi so print stats dot mod x so the result is 2 and the count is 5. this shows that the mod of the given data is to and it has occurred five times so it shows the mod as well as the count of that mod count just refers to the number of time a particular value occurs so don't be worried for now just copy paste the same thing if you are not able to understand it's not a big deal we are going to explain it in detail later on now let's move on to calculation of standard deviation standard deviation is a measure of deviation dispersion how much the data deviates from the central value in this case it's going to be mean because you can calculate standard deviation around mean median as well as node but this inbuilt method is only for mean because most important measure of standard deviation is standard deviation about mean so I just need to write print NP dot STD and I need to pass the array name and I got the result and this is the most important thing to note that it gives the standard deviation about mean now I have an assignment for you calculate the standard deviation using the correct formula so this time you don't need to use this inbuilt method you just do it using the standard procedure that you follow in probability and statistics and peace match both these values they will be same but I want you to calculate it manually so that you can verify the result and you need to check whether the theoretical value coincides with the calculated value so in today's lecture we covered the measures of central location that is mean median and mod and we also demonstrated the use of STD method for calculation of standard deviation that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we covered the measures of central location as well as we calculated the standard deviation and in today's lecture I am going to explain and demonstrate the use of a range and Lin space methods of numpy so let's get started let me open my terminal so first of all I'm going to write python3 and hit enter so what is a range method that's going to be our first topic so numpy e range is one of the array creation routines in Python our equation routine is just a method to create an array so a range method is one of the array creation routines or array creation methods based on numerical ranges it creates an instance of ND array with evenly spaced values so it creates an instance of ND array with evenly spaced values and Returns the reference to that array in simpler words because I know that complicated definitions are a little difficult to understand so in very simple words or in beginners or true Keys words it returns a list of integers between the start and stop parameters so it returns a list of integers between the start and stop parameters or values including the start value but excluding the stop value or the end value so it's pretty simple now it's a method to create an array so that array will contain a list of values which will be evenly spaced and they will be between a start and a stop value so let me just write array is equal to NP dot arrange and pass a start value and a stock value sorry I have not imported num by as in p first so it's giving me an error let me just import an do the same thing again so array is equal to NP dot arrange and I need to pass 0 and 11 as start and stop value and I need to print the array so you can see that I pass 0 and 11 so I got all the integers between 0 and 10. and not 11 so 11 is not included so this returns us numbers from 1 to 10 and one thing to note is that 11 is not included so that's an important observation and an important thing to keep in mind while working with events method if you might have observed erange method is very similar to the python range method so if you are not acquainted with the range method please refer to our playlist on python another important attribute of the Aries method is the step size we can also specify the step size so let me just specify this step size as 2 now I am printing the array again and now I got only the even values so note that this returns us the even values or the even numbers from 0 to 11. so whenever there's a question that create an array of even numbers between a starting and an ending value you can always use a range method and specify the step size as 2. so we can specify whatever step size we require now let's move on to the Lin space method so we discussed the arrange method which is very similar to the range method in Python and now we are going to move to Lin space method and see what is the difference between a range method and the Lin space method so the Lin space method returns evenly spaced points or elements between a start value and an end value so it returns evenly space points or elements between a start value and a stop value but an important thing to note here is that they don't need to be integers so arrange method always returns us integers but Lin space meth third will return us evenly spaced values or evenly spaced point but they will not be integers so the syntax is numpy alleys or NP dot Lin space we need to pass start stop and the number of elements or the number of points that we need or required so note that the difference between the Lin space and E range is that Lin space does not necessarily return integer values this is a very important point to emphasize that's why I am repeating it multiple times so that it gets into your head directly so don't confuse Lin space with earrange method because it returns integer values only so now I'm going to demonstrate the use of length space method so you need to follow the syntax as described earlier so the start is 0 and this 5. and number of values required are 10. so it gives me 10 values another important observation here is that it Returns the start value as well as the end value yes so that's another difference between lens space and erange Method because erange method excludes the end value while the Lin space method includes the end value now the next example is obtained 100 points between 0 and 1 which are evenly spaced so this time I need to specify the start as 0 the end as 1 and the number of values required as 100 now I have printed the list so it gives me 100 values between 0 and 1. and it includes one that's the difference now I have an assignment for you obtained 50 evenly spaced values between 6 and 9 using Lin space method so that's your assignment I hope you complete it so in today's lecture we started about a range and lens space methods of numpy and I demonstrated the use of both that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we studied about the a range and length space methods of numpy and today we are going to see how to create an array containing all values as zeros or ones and also how to create identity mattresses in numpy so let's get started so I've opened my terminal I'm going to write Python 3 hit enter and I also I'm going to import numpy as NP so our first job is to create a 1D array with all elements as zeros so creating a 1D array of all zeros or an array in which all the elements are 0. so the syntax is array name is equal to numpy Alias or NP Dot zeros and I need to pass the number of values so number of elements or number of values is going to be the parameter in this case now let's create an actual array by following the syntax so array name is equal to NP dot zeros and I'm going to pass 5 as the number of values and I'm going to print this array so I got the result as an array containing five zeros now let's create a 2d array or a matrix in which all the values are zeros foreign I need to pass a tuple to this method that is rows and columns in last case I only passed the number of elements but in 2D array we have rows as well as columns so we need to pass a tuple containing number of rows and number of columns so we need double brackets here because it's a tuple we are passing a tuple and not a scalar so the syntax is same with slight change so I have created a 2d array of all zeros containing three rows and four columns now let's create a 1D array of all ones or an array in which all the values are 1. so syntax is same as zeros but we need to replace the word zeros by ones so syntax is same as the previous example we just need to replace the word zeros by once it's same as we do in physics like we replace and one and M2 by q1 and Q2 and the formula changes from Newton's law of gravitation to Coulomb's law with different constants of cos but it's a slight change so please take a joke and let's move on so I need to write array name is equal to np.1 and I need to pass 5 because I'm creating an array of ones which contains five ones or in which the value 1 occurs five time and the only value present is 1. now let's create a 2d array of all ones so syntax is same we need to pass a tuple this time with number of rows and number of columns that we want so I have specified that I need an array of all ones a 2d array of all ones with three rows and four columns so I got the relevant or the required result now let's see that how can we create identity matrices so for those who don't know what is an identity mattress so it is a special type of mattress in which the diagonal elements are 1 and rest of the elements are 0 and by diagonal I mean the main diagonal which starts from top of left side and ends at the bottom of right side because there are two diagonals but there is only one main diagonal in a matrix so we can use the I method to create the identity Matrix and in this case we have one parameter that is the order of Matrix because an identity Matrix will always be a square Matrix so it returns a matrix and not a vector so syntax is NP dot I and I need to specify order and order is 5 in this case so in today's lecture we studied how to create an array with all values as ones or zeros and also demonstrated the method to create an identity Matrix that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we studied how to create an array of all zeros and ones identity mattresses and today we are going to get acquainted to random module in numpy and it's related methods so let's get started so first of all what are random numbers so Random means something which can't be predicted with help of logic it does not necessarily mean getting a different number every time or a different value every time numpy offers the module random to work with random numbers now let's try to understand the difference between true random and pseudorandom we all know that computers execute programs and programs are a set of instructions with definite meaning so programs are used to implement some algorithms to solve specific problems so there must be an algorithm to generate a random number now the question arises if some algorithm or program is used to generate a random number the random number generated with the help of algorithm can be predicted so it's not true random because as per the definition of the random number we can't predict random number with any kind of logic so we can say that the random numbers generated by algorithms on our computers are not true randoms they are referred to as pseudorandoms or false so whenever we work with randoms in our programs we work with pseudorandoms now let's move on to the coding part so let me write Python 3 hit enter now let's generate a random number with type float and by using Rand method so we are going to generate a random number which will be of the type float and we'll do it with the help of Rand method of the random module of numpy so I'm going to import numpy S and P and write x equal to random Dot Rand and hit enter so here one thing to note is that it gives us an error because we have not imported the random module directly from numpy so we need to use numpy Alias with random and Rand so I am going to write NP dot random dot Rand method and I'm going to print X now so I got a random number so note that this returns a random number between 0 to 1 and it's of the type float So Random Number of the type float between 0 and 1. so now I'm going to show you another method to import random directly so now let's import random directly so we don't need to use NP in this case we don't need an alias we can just write random dot Rand directly so for that we have to import the random module directly from numpy so in this case I'm going to write from numpy import random so from numpy import random so now I can directly use random dot Rand method and I don't need to write NP Dot random.rand so directly write random dot brand and print the value of variable in which you have stored the result so I got the random number so note that the values are different so the values in both the cases are different because they are working with random numbers and it absolutely makes sense to get a different value each time we are calling the function so we are getting different values and they are correct so there's an assignment for you generate a random number between 0 and 100 sorry it is 0 and 1 I have just missed the decimal and it should be of type float so today's lecture was an introduction to the random module and use of Rand function in numpy that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we started with the random module in Python and I demonstrated the use of rant method of random module to generate a random number today we are going to cover brand method in detail so let's get started let me just write python3 hit enter now I'm going to import numpy as NP and let's start our discussion on plant function or the run method so the run method returns random number or numbers or I can say that random sample or samples of type float between 0 and 1. so it returns random samples of type float between 0 and 1. so samples are taken from a uniform distribution this is a very important point so it returns random samples of type float between 0 and 1 and samples are taken from a uniform distribution we have a lot of distribution of different kinds and this Rand function takes samples from a uniform distribution so the syntax is x equal to NP dot random dot brand as discussed in the previous lecture now we have to print X to get a random number between 0 and 1. so now what if we want more than one sample so this example generated one random number now what if I want an array of random numbers between 0 and 1. and the samples which belong to a uniform distribution so the syntax is NP dot random dot Rand and I need to specify the number of samples so now let's generate five random numbers of type float between 0 and 1. so the syntax is X is equal to NP dot random dot rant and I need to pass 5 as parameter denoting that we are going to generate five random numbers so I got the result so we get a list as a result now let's generate a 2d array or a matrix with the help of Rand method and all the values of that Matrix will range between 0 and 1. they will be random and they will be the samples of a uniform distribution now I just need to write x equal to NP dot random dot Rand and I need to pass rows as well as columns and I need to print X so I got the result as a Square Matrix because I have passed equal number of rows and columns but you can pass different parameters like less value of row and more value of column or vice versa so we got a matrix as a result with five rows and five columns so now there is an assignment for you create a matrix with the help of Rand method of two rows and one column so in today's lecture we covered the rant method of the random module in detail that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the rant n method and today we are going to cover the rant n method of the random module of the numpy and we'll try to understand what is the difference between the rant method and the Rand and Method so let's get started so let me just write Python 3 and hit enter now I am going to import numpy as NP and hit enter so I've imported the numpy library now the numpy Dot random Dot Rand in method here we have not imported the random module directly so we will use numpy or NP dot random dot friend in as the whole syntax so it creates an array of specified shape and fills it with values or numbers as per the standard normal distribution so it creates an array of the specified shape and fills it with the values as per the standard normal distribution now if you recall in case of the Rand method it fills the array with values as per the standard uniform distribution this is a very important difference between the Rand and the rant in method so one important thing to note is that it fills the array with random floats sampled from univariate normal or we can say gaussian so the rat and Method take samples from a normal or gaussian distribution and mean of that gaussian or normal distribution is 0 and the variance is 1 will cover the uniform and normal distribution later on this is just a brief intro now note that normal distribution is a distribution which is continuous in nature we have a lot of different kinds of distributions in statistics like uniform distribution normal distribution poisson distribution relics distribution Etc so normal distribution is a kind of continuous distribution and it has a probability density function as opposed to the discrete distributions which have a corresponding probability Mass function now an important thing to note is that if we provide no argument in this brand in method then it will return a randomly generated float which will be sampled from the distribution or we can say from the normal or gaussian distribution so this is a very important thing to note so if we provide no argument then a single float randomly sampled from the distribution is returned so please keep a note of that now we'll start with the code and first of all I'm going to pass no argument so I'll write X is equal to NP dot random Dot Rand in and I'm going to pass known parameter and I am going to print the value of x so I got one random number which is a sampled from a normal distribution which is centered around zero with mean 0 and variance 1. now I'll create a 1D array so I need to pass one parameter and I need to print the value of x so this is the result so as a result we got a 1D array or I can say that a row vector so the result is a row vector or a 1D array similarly if I want to create a 2d array I need to pass two parameter that is the row count as well as the column count so now let's create it to the array or a matrix so I need to follow the same syntax I just need to give two parameters this time so let it be four and three I'll print so I got a matrix with four rows and three columns so the result is a 2D array or I can say a matrix now let's create a 3D array so the syntax will be same I just need to pass three parameters this time because a 3D array has three dimensions so I need to follow the same syntax I just need to give three parameters and I'll print the value of x again so you can see that I have got a 3D array as a result so result is a 3D array or I can say that a third order tensor because if you recall in higher dimension end order array is referred to as nth order answer now I've got an assignment for you create a 4D array randomly using the Rand n method and print it so in today's lecture we covered the use of Rand and method of the random module of numpy that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the rant n method and today we are going to learn about the rant end method of the random module of numpy so let's get started so let me just write python3 and hit enter now I'm going to import numpy so I'm going to import numpy as NP hit enter so today we are gonna discuss about the round end method so round end stands for random integer and it is an inbuilt function offered by the random module of numpy so it's an inbuilt function like Rand and brand n and it's also a function of the random module of numpy so you know that the random module gives access to various useful functions so the module random gives access to various useful functions and one of them is Rand and which is able to Generate random integer numbers so the rant and Rand in functions generated float values but this function generates random numbers and they are of type int now let's move on to the syntax so the syntax is you have to write NP or numpy dot random dot Rand int and you have to pass the start to stop value so you have to give a range within which you want to get a random integer so this is the syntax and also note that both the start and stop values must be integers so the start stop values indicating the range must be integer values otherwise you will get an error while executing the statements so now let's just write X is equal to NP dot random Dot Rand int so dot Rand int and pass to start as well as the stop value and now I'm going to print the value of this randomly generated integer so it's 8 in this case you may get a different value because we are working with random numbers now let's move on to some more examples so next example is generate a random number between minus 10 and minus 1 and it should be of the type integer so I'm gonna write X is equal to NP dot random dot run in and I'm going to pass the start as minus 10 and the stop as minus 1. now I'm going to print the value of x and it comes out to be 3 so I have generated a random number of type integer between minus 10 and minus 1. now let's see what happens when we pass noninteger values so x equal to NP Dot random dot Rand IND and I'm going to pass noninteger values let's see what happens ideally it should give us an error so I'm going to pass the float values and I'm going to print the value of x now so I'm going to write print X and hit enter now you guys must be wondering that we got a result but we should get an error so this is because there might be an update I guess now we can use compatible data types as start and stop values now let's try using noncompatible data types like string or character values so I'm going to pass character values this time or string values so it gave me an error so invalid literal for INT with base 10 so this is an noncompatible data type so note that we got an error with noncompatible data type and in the previous versions if you try float values also you will get an error because now there might be an update but in previous version it gave us an error now there's an assignment for you generate a random number between minus 5 and Let It Be 4 and 4 using rant end method so in today's lecture we covered the rant end or the random integer method of random module of numpy that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the rant end method and today we are going to do some more examples based on the methods offered by the random module of numpa so let's get started so let me just write python3 hit enter now I'm going to import numpy as NP and hit enter now today's topic is some more examples on the methods offered by the random module of numpy so we'll try to do some mixed examples so first question is create a 1D numpy random array and sort it so we have to create a 1D numpy random array and we need to sort it so let's move on to the solution first of all let's create the array let the RN name be a so a is equal to NP dot random dot Rand and let the number of elements be six now let's print the sorted array so I have to write print and in bracket I have to pass NP dot sort and in sort I have to pass e so this is the sorted array you can see that it has been sorted according to the ascending order so if we got the sorted array and we use Rand method to create a random numpy array or we can say we use the Rand method of the random module of numpy to generate a random array and we used the sort method of numpy to sort the array so this was a mixed example now let's move on to the next problem so next problem is problem number two create a 2d Matrix of dimensions 2 cross 3 that means two rows and three columns so create a 2d array or a matrix with Dimension 2 comma 3 that contains six random numbers between two and six so let's move on to the solution so I have to write array name or ARR is equal to NP dot random Dot Rand this time I need an array that contains integer values and I have to pass the start stop as two and six and I have to pass the dimensions of array as a tuple so that is 2 comma 3. Now I'm going to print this array so you can see that I got a 2d array with Dimensions 2 comma 3 or 2 rows and three columns and it contains random numbers or random integers between 2 and 6. so here we constructed a 2d array or Matrix with help of Rand int method now let's move on to our third example or third problem so problem number third is use numpy random number function to generate at least 1000 numbers between the range of 1 2 1 lakh or hundred thousand and after generating we need to perform some operations so we have to generate an array of thousand numbers and the range is 1 to 1 lakh or hundred thousand and we need to perform some operations on it so let's move on to solution so first of all let's create the required array so I'm going to write ARR is equal to NP Dot random dot Rand int and I am going to pass start stop and the number of elements so in this case it's 1000 so size is 1000. now the first operation is or I can say that the first part of the question is to sort these elements so I have created an array with random integer numbers from 1 to 100 000 and now I need to sort these elements and store them in a new array so the new array name or ARR new is equal to NP dot sort and I'm going to pass the RNA now I'm going to print the original array first so you can see that it contains randomly distributed numbers and I'm going to print the new array now so it is sorted I'll scroll so that you can see clearly the first one was there randomly arranged numbers and second one is the sorted array now the second part is to determine the maximum and minimum element so part 2 is to determine the maximum and minimum element from this array so we need to write Min element or mean Le whatever variable name you want to give and that is equal to NP dot Min and we need to pass the array name and similarly for the max just replace the Min by Max and I'm going to print these values now so print Min Ellie as well as print Max early so the minimum element is 268 and the maximum element is 999.05 you may get different values as we are working with random numbers now the third part of the question is to determine the average or we can say the mean so for that I have to write err mean or whatever variable name is equal to NP dot mean and I have to pass the array name that is err or now I'll print it so the mean of all the values is around 50 252 .304 and now fourth part of the question is an assignment for you that is find the mod the median and standard deviation for this data contained in the array so in today's lecture we solved some questions based on the methods offered by the random module of numpy that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thanks hi guys welcome back to our course on numpy in our previous lecture we solved some examples based on the methods offered by the random module of numpy and today we are going to take a look at random permutations so let's get started today we are going to execute our code in the Jupiter notebook I'll teach you how to set up jupyter notebook in the next lecture so let's start with today's topic so a random permutation refers to an arrangement of elements for example take an array with the values 4 3 2 1 so it is a random permutation of one two three four and vice versa so just with a sequence we can make several different arrangements or combinations so they are called as permutations so a lot of other permutations are possible as well but the numpy methods which we are going to study today they give only one permutation on passing the sequence so we get only one random permutation on passing a sequence or an array so a lot of permutation are possible that can be calculated using the formula npx but here we'll get only one random permutation by using methods of numpy random module So numpy Random module has two methods to find out the random permutation the first method is the shuffle method so for that I need to create an array first so I've created an array and now to get a permutation I need to write NP dot random dot Shuffle and I have to pass the array name now I'm going to print the shuffled array first to get a permutation so it gave me an error because I have not imported numpy so let me just import numpy as NP first and let me run this cell again now let me just print the array after shuffling so I got the result as four two one three five which is a permutation of one two three four five also note that this Shuffle method makes changes to the original array so if I write print in P dot random dot Shuffle and I pass the array name I'll get no result or the result as none now the second method is using the permutation method so now let's create an array again the same array we created the same array again because it has been shuffled so now I created the array again and I use the method permutation so I need to write NP dot random dot permutation and I need to pass the array name as ARR so I got another permutation of one two three four five now let me print the original array as well so I'll print array name or ARR and I'll hit enter or run this cell by shift plus enter now I got the original array as well as you can see the array after permutation now shuffled array makes changes to the original array while the permutation method does not make changes to the original array please note this this is a very important observation to make also note that if you want changes in original array you need to use the shuffle method and if you don't want any changes in the original array you need to use the permutation method because you need to choose according to the situation that you are in now there's an assignment for you create an array using rant end method so create an array using the Run Inc method of the random module of numpy sort that array using sort method and the third objective is to find the random permutation for that Adi or distorted array so in today's lecture we covered random permutations and the shuffle and permutation method to obtain a random permutation that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with also next lecture thank you hi guys welcome back to our course on um bye in our previous lecture we covered random permutations and today I am going to teach you how to install Anaconda get started with the Jupiter notebook and how to install C bone and matplotlip libraries so let's get started so I'm sharing my screen I'm going to Safari so you can go to your browser and you can search Anaconda so it's showing the name of website as I had already installed so you can see the first search result as the name of the website now this is the website or the official website for installing the Anaconda package so this is the website and you can click the download since I'm using a Mac so I'll install it for Mac if you are using some different operating system it will show you the package corresponding to that particular operating system now it's downloading so it's of around 620 MB for Mac OS users it may vary according to whatever operating system you are using since I have already installed I am canceling the download but you need to complete the download so there's one other method to download Anaconda if you are using a Mac with and you have Homebrew support so go to home brew and search Anaconda so you will get a command to install Anaconda so just copy it open your terminal so I'm going to open my terminal and just paste the command and hit enter so paste the command and hit enter now it's taking a little bit time here the running View Auto update so it has updated and it's showing cast Anaconda is already installed because I have already installed Anaconda so it's already installed now let's move on to installation of libraries that are c bond and matplotlib you can install these libraries using pip installer package or anaconda so here I'll be installing them using pip installer package first so I need to write pip install c bond to install c bond so it shows requirement already satisfied because it's already installed in my system now similarly for matplotlib I have to write pip install matplotlib so it will show requirement already satisfied again because I have already satisfied these libraries now let's see how to install them using Anaconda so if you want to use Anaconda for installing these libraries so you need to write the command conda installed C bone and the process will take some time so there is some background process going on so there will be some processing so it shows done so it's asking for a permission to install new packages since I have already installed so I won't be proceeding with this but since you are installing it for the first time you have to proceed with why so you need to proceed with y and similarly you need to install matplotlib using the command conda install matplotlink so the process is similar you just need to replace c bond with matplotlib so the command will be conda installed matplotlib let me clear the screen now let's open the Anaconda Navigator so open the Anaconda Navigator and close the terminal so I've opened the Anaconda Navigator and it's showing a lot of options but we have to select the notebook and click launch so it will take a minute or 30 seconds and it will open in your browser don't worry this process is offline it doesn't require internet connection so just create a new folder wherever you want to store your code so I've created a new Untitled folder for that so I'll just open this folder by clicking on it so it shows the notebook list is empty and I'm going to create a new notebook now now this is a cell so in this cell I am going to import numpy as NP I'm also going to import c bond as SNS and import matplotlib dot Pi plot as PLT and I am going to hit shift and enter to run this cell so it gave me no error so we have successfully imported these libraries you can also rename the notebook by clicking on the name that is Untitled so I'm changing it to my first notebook so now there is an assignment for you so assignment is that you need to practice some of the problems that we already discussed in the previous lectures in Jupiter notebook because if you practice more you'll get acquainted with this quickly so practice some of the codes we have discussed in previous lectures in Jupiter notebook so in today's lecture I demonstrated how to install Anaconda and also how to install c bond and matplotlip libraries using pip installer package as well as Anaconda we also created our first Jupiter notebook that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thanks hi guys welcome back to our course on numpy in our last lecture I explain you how to install cbond matplotlip and get started with the jupyter notebook and today I am going to teach you the normal distribution so let's get started so as per Wikipedia normal distribution also known as gaussian Gauss or LaPlace Gauss distribution is a type of continuous probability distributions for a real valued random variable the general form of its PDF or probability density function is given by f of x is equal to 1 by Sigma into under root 2 pi multiplied by e daised to the power minus 1 by 2 x minus mu by Sigma whole Square here f of x is the probability density function mu is the mean of the distribution and sigma is the standard deviation now let's look at the plots so these are the normal thoughts for different mean and for different standard deviation values so one General observation is the distribution will always be centered around the mean so in this blue curve the mean is zero so centered around 0 same for red and yellow but the green is centered around 2 and you can see that they are dispersed differently now let's take a look at the CDF curves so these are the CDs curves so three curves intersect at zero because they have mean as 0 and 1 is passing through minus 2 because the mean is minus two so this was a CDS curve now let's move on to the coding or plotting part so generate a random normal distribution of size 3 into 3 with so we have parameters here so the parameters are mean and standard deviation so here mean is 1 and standard deviation is 2. so from numpy import random so from numpy import random and proceed further so X is equal to random dot normal and we will specify the parameters that is location is equal to one K is equal to 2 and size is equal to whatever is the size of the distribution so location means the mean what the value around which the distribution is centered so this is the returned array and the elements are the samples taken from a normal distribution now let's visualize the normal distribution visualization is a very important aspect because here we are dealing with c bond numpy as well as plot lip so a combination of these three libraries helps us in visualization the math plot ping matplotlip being the grandfather of the visualization libraries so now let's visualize import matplotlab as sorry matplotlip dot Pi plot as PLT and import c bond as SNS now SNS Dot this plot and we are going to pass an array which contains samples taken from a normal distribution so random.normal and size is equal to so let the size be 1000 and hist is equals to false so we have taken the hist as false because normal distribution is a continuous distribution so we are just concerned with the KDE plot so here I'm using jupyter notebook so I taught you how to install all the libraries and get started with the jupyter notebook if you have skipped that lecture I advise you to go back and watch it again so here I'm using the jupyter notebook but if you are using any other platform then you have to write PLT dot show and here sometimes in jupyter notebook we also use percent map plot lib inline explicitly for jupyter Notebook also please note that normal distribution has a belt shaped curve so in today's lecture we covered the normal distribution the PDF and CDF of a normal distribution and their plot and we created an array with values from a normal distribution and at the last we visualized the shape of a normal distribution curve that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the normal distribution and today we are going to take a look at the binomial distribution its PDF curve and how to plot the PDF for a binomial distribution using numpy cbond unmapped plot clip so let's get started so what is binomial distribution so binomial distribution is a discrete distribution it describes the outcome of binary scenarios example toss of a coin that is head or tail weaning or losing passing or failing Etc it has three parameters and the number of Trials P the probability of success and queue the probability against success so its probability Mass function is given by P of X is equal to K that is probability that our variable takes on the value K is equal to nck P raised part K into 1 minus P whole raised to power n minus k so this is the probability Mass function because it's a discrete distribution now let's see how a binomial distribution looks like so in first case n equals to 10 the probability of success is 0.5 that is 1 by 2 so in this case the distribution is nearly symmetrical about X is equal to 5. so for p is equal to 0.5 that is probability of success is half then the distribution will always be symmetrical now let's take a look at the second case where value of n is fault and the value of p is not equal to 0.5 in this case the distribution will not be symmetrical it will be a symmetrical now let's take a look at the last case in this case the value of P not 0.5 but it still looks symmetrical because here the value of n is very very large also note that it just looks symmetrical it is not symmetrical it will only be symmetrical if p is equal to 0.5 or half now let's move on to the coding path so let me just rename it to binomial and we are good to go so here we have three important parameters also note that the parameters for different distributions will be different so you have to memorize all of them in order to be able to plot all the distributions so the parameters are in denoting the number of Trials P denoting the probability of success or the probability of trial and size that is the shape of the array returned so these are the parameters now given 12 trials for a coin toss so coin toss is a binary scenario and there are 12 trials that is n is equal to 12 and the probability of trial or probability of success will be 0.5 because in a fair time cost head and tail have equal probabilities so we have to generate 10 data points that is we have to take 10 samples from a binomial distribution where n is equal to 12 and P is equal to 0.5 so after analyzing the problem we can say that here and is equal to 10 p is equal to 0.5 and size is equal to 10 because we have to generate 10 data points I'm sorry I made an error n is not 10 here n is equal to 12. so let me just rectify the error so n is equal to 12 and size is equal to 10. now let's move forward let's create a new cell so now I'm going to write from numpy import random and now I'm going to write X is equal to random dots binomial and I'm going to pass the parameters so n is equal to 10 p is equal to 0.5 and the size is equal to 10. so we'll get 10 samples from a binomial distribution as a result so these are the 10 samples now we have obtained samples from a binomial distribution now let's move on to visualization of a binomial distribution so let's visualize now so I'm going to write so let's first initialize the parameters so let's n is equal to 10 p is equal to 0.5 and the size p let it be 10 000. so these are the parameters with which we are going to plot a binomial distribution so I'm going to write from numpy import random and import matplotlib dot Pi plot as PLT and import c bond as SNS now sns.displot random Dot binomial and we have to pass the parameters here sorry this is a different kind of cell so let me just clear this thing so let me just write import sorry what was I writing I just forgot so it was sns.displot and pass the parameters So Random dot binomial and we have to pass the parameters so n is equal to 10 p is equal to 0.5 and size is equal to 10 000. and we have to specify the hist as true because this is a discrete distribution and we are concerned with the histogram and we can specify the KDE as false because we don't need kernel density estimation that is important in case of a continuous distribution the last cell was a text cell so just let me copy paste and hit enter so I got the plot for a binomial distribution and this is the plot you can see that it is almost symmetrical it is not almost symmetrical it is definitely symmetrical because the probability of success is 0.5 and whenever p is equal to 0.5 the shape will be symmetrical so in today's lecture I covered by normal distribution and its shape that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the binomial distribution and in today's lecture we are going to cover the uniform distribution so let's get started so first of all what is a uniform distribution so it is a continuous distribution and according to Wikipedia in probability Theory and statistics The Continuous uniform distribution or a rectangular distribution is a family of symmetric probability distributions the distribution describes an experiment where there is an arbitrary outcome that lies between 13 pounds that are A and B and PDF is given by 1 by B minus a for all X belonging to a till B and 0 otherwise now let's take a look at the PDF so this is the PDF and it's zero for any value less than a and greater than b and it is only defined between A and B including both the values that is a and b now let's move on to the CDF or the cumulative distribution function so here it's like a transfer curve and it has a slope from A to B so this is the cumulative distribution function now let's move on to the coding part let me just change the name to uniform and now I'm going to mention the important parameters of a uniform distribution also note that in uniform distribution the probabilities are generally equal the uniform distributions can be either continuous or discrete and in discrete uniform distribution the probabilities are same but in continuous distribution the scenario is different we deal with three important parameters here that is lower bound that is denoted by a and has the default value 0 B the upper bound having the default value 1 so B has the default value 1 on the third parameter is the size that is the shape of the returned array so size is the shape of the returned array now let me create a new cell and first of all let's draw out some samples from a uniform distribution so create a 3 cross 3 or 3 into 3 that is three rows and three column Matrix consisting of values which are samples taken from a uniform distribution or in short I can say that create a 3 cross 3 uniform distribution sample I tried to add comments here but it is not working so let me just clear all this and just write it simply as a single line company so create a three cross three uniform distribution sample now let's move on to the next cell add from numpy I'm going to import random so from num by import random and X is equal to random Dot uniform now we have to pass the parameters that is size and print so this is a 2d array and the elements of this 2D array are samples taken from a uniform distribution now let's move on to the visualization path so let's visualize uniform distribution so now I'm going to import random from the numpy module by writing from numpy import random import matplotlib dot pipe dot as PLT import c bond as SNS and now I write SNS dot this plot and I will pass the parameters So Random Dot uniform and I have to pass the parameters such as size is equal to thousand so I have specified the size as 1000 you can specify a different size and I'm specifying the hist as false because this is a continuous uniform distribution so it's not a perfect rectangular PDF as scene but this is the actual thing that was theoretical now let's try to see the histogram as well so it's in shape of a box so that is much closer but we are only concerned with the boundary and not the failed portion so it's not true for a hist it is true for a KDE but it's not the perfect shape here so that's all for today in today's lecture we covered a uniform distribution its PDF the CDF as well as we visualized the uniform distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the uniform distribution and in this lecture we are going to cover the poisson distribution so let's get started so first of all poisson distribution is a discrete distribution it estimates how many times an event can happen in a specified time for example if we get three hits on continuously tossing a coin what is the probability of getting four heads that is one example of python distribution and its probability Mass function is given by Lambda raised to part k e raised to power minus K divided by K factorial with Lambda is the expected rate of occurrences now let's look at the PDF of a poisson distribution so here we have three different PDFs for three different poisson distributions for different values of Lambda we note that the peakedness of the distribution depends on the value of Lambda let's say the value of Lambda more will be the peakedness now poisson distribution is a discrete distribution it has two parameters Lam that is rate or the no number of occurrences and size or the shape of the returned array now let's write some code first of all we will create an array which will contain samples taken from a poisson distribution so let's generate a random 1 cross 10 distribution for occurrence so we are going to generate a random 1 cross 10 distribution for Lambda is equal to 3. so from numpy import random so X is equal to random Dot poisson and we are going to pass Lam or Lambda is equal to 3 and 5 is equal to 10. because it's 1D array so we don't write size equal to 1 comma 3 in Brackets so we directly write 10 so this array contains samples which are taken from a poisson distribution now let's move on to the visualization part so visualization of poisson distribution now I'm going to write first let's import so from numpy import random import matplotlib dot Pi plot as PLT import c bond as SNS now I'm going to write percent map plot lip in line and now I'm going to write SNS DOT test plot so SNS DOT test plot random dot POI sorry it's yeah poisson so Random Dot poisson and I'm going to pass the Lambda value add the size so let the size be thousand and Lambda is equal to 3 and KDE is equal to false because this is a discrete distribution and sorry I've written my plot lip instead of path plot lab so let me just correct it so this is the plot so that's s how a poisson distribution looks like now let's see what's the difference between poisson and normal distribution or difference between normal and poisson distribution so first of all normal distribution is a continuous distribution and poisson distribution is a discrete distribution normal distribution is used when we are predicting something on a continuous range while poisson distribution is used when we are concerned with an event and intervals of time let's see the plots in one frame so sns.disk plot and random dot normal so let the location with 50 that is mean is 50. scale is equal to 7 and the size is equal to 1000. now let me draw or plot a corresponding poisson distribution also so sns.displot random Dot poisson and I'm going to pass the parameters so let the lamb or Lambda is equal to 50 the size be 1000 and also let me label it so that we can see the difference so label is equal to normal for the normal distribution and table is equal to poisson for the poisson distribution and let me hit shift enter so now you can see the difference between the two so in today's lecture we covered the poisson distribution its PDF and its visualization we also differentiated between a poisson distribution and a normal distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button and stay tuned with us for more lectures thank you hi guys welcome back to our course on numpy in our previous lecture we covered poisson distribution and today we are going to cover exponential distribution so let's get started so first of all exponential distribution is used for describing time till next event example failure success Etc the PDF is given by Lambda e raised to power minus Lambda X and the CDF is given by 1 minus E raised to power minus Lambda X here Lambda denotes the rate or the inverse scale and Lambda should be greater than 0. now let's take a look at the PDF and CDF curves so this figure shows us the PDF curve and this figure shows us the CDF curve for different values of Lambda now let's move on to the coding part so exponential distribution is used to describe the time till next event as already discussed it has two parameters that is scaled that is inverse of freight and with default value 1 at size that is the shape of the returned array now let's first draw out samples from an exponential distribution and store it in an array so let's draw out a sample for exponential distribution with scale is equal to 2.5 and 2 into 2 size that is 2 cross 2 size so we have to draw out samples from exponential distribution and store it in an 2D array with size 2 cross 2 so I'm going to import random from numpy so from numpy import random and x equal to random dot exponential and I'm going to pass the scale that is our first parameter and I have to pass the second parameter that is size so size equal to two cro 2 comma 2 denoting two cross to size and now I'm going to print X so this is a 2d array with four values which are sampled from an exponential distribution now let's visualize the exponential distribution so visualization of exponential distribution now I'm going to again import random from numpy so from num by import random import matplotlib dot Pi plot as PLT and finally import c bond as SNS now I'm going to write SNS dot disk plot and I'm going to write random Dot exponential and I'm going to pass the parameters that is the value of Lambda and size let's just pass size here and Lambda will attain its default value and mention the hist as false because this is a continuous distribution so this is the PDF that is probability density function curve for an exponential distribution now let's try to understand the relation between exponential and poisson distribution so poisson distribution denotes number of let me just move to the next line so poisson distribution denotes number of occurrences of an event number of occurrences of an event in a time period where as exponential distribution or exponential deals with the time between the events so in today's lecture we covered the exponential distribution and visualize the PDF of the exponential distribution further we try to understand the relation between the poisson distribution and exponential distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we covered exponential distribution and today we are going to cover logistic distribution so let's get started so logistic distribution so first of all what is logistics distribution so logistic distribution is used to describe growth it's a logistic distribution describes the growth and it is a very very important distribution because if you are acquainted with machine learning you must have heard of the term logistic regression so it's a very important Concept in machine learning data science so this distribution is very very important and it will be explained in detail once we move on to machine learning and data science so logistic distribution is used to describe growth it is a very very important distribution and it is used extensively in logistic regression neural networks Etc and mathematical description will be given later on I mean in the future courses on data science and machine learning so today we are just going to visualize it and out samples from logistic distribution so let me just create a new cell so first of all let's discuss the parameters so it has three parameters the lock or the location or the mean the place where we have a peak like in the previous lectures we used to call it mean only but here we are using lock or which denotes the location or location of the peak and default value for mean or lock is zero and the second parameter is scale it denotes standard deviation and what is standard deviation or what does standard deviation denote it denotes the flatness or the peakedness or the deviation from mean Central uh value we have a central value and standard deviation tells us how much our data deviates from that Central value or the measure of central location which is mean in this case we have other measures for central location that is mod median but we prefer mean over others so let's draw out samples from a logistic distribution so let's draw out three cross three samples from logistic distribution and we need some parameters so let the mean be one and standard deviation B 3. so we are going to write X is equal to random Dot logistic and in bracket we are going to pass the parameters that is lock or location is equal to 1 which denotes that the mean as 1 and scale is equal to 3 that means standard deviation is 3 and let the size be 2 comma 3. sorry 3 comma 3 because we want to have a 3 into 3 array so I forgot to import random so let's write a line for that from so from numpy import ant now let's execute and we got this array which has three rows and three columns and all the elements of this array are samples taken from a logistic distribution of mean one and standard deviation 3. now let's try to visualize the logistic distribution to see how the shape looks like so from numpy import random and in next line from sorry here we'll directly import matplotlib dot Pi plot as PLT and import c bond as SNS now we'll write SNS DOT test plot and we will pass random dot logistic and in bracket we'll write the parameters that is lock or location or mean the scale and the size but here we are not gonna pass let it acquire the default values so we are only going to pass size that is 100 and hist is equal to false because this is going to be a continuous distribution now let's execute so this is the pictorial form of the distribution or we can say the graphical form of logistic distribution so logistic distribution looks similar to normal distribution as you can see that this shape is also like Bell so it the curve is also Bell shape but you can see some difference in the Tails of the distribution so if you look around the values minus 6 to minus 10 the shape is little bit different than we had in the normal distribution so it has more area under tails so in today's lecture we covered the logistic distribution and we visualized logistic distribution along with comparison with normal distribution that's all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us hi guys welcome back to our course on numpy in our last lecture we covered logistic distribution and today we are going to cover the multinomial distribution so let's get started let me just rename The Notebook to multinomial so I've renamed the notebook and let me just zoom in or maximize so let's get started with multinomial distribution so what is a multinomial distribution so in simple words we can say that multinomial distribution is just a generalization of binomial distribution so in binomial distribution we dealt with two events but in multinomial distribution we are dealing with multiple events so in simple words binomial distribution gives us information about two scenarios where by means two and multinomial distribution gives us information about multiple scenarios or multiple events so multiple so this is the case where we have two scenarios and we generalize it for n scenarios so example of binomial is toss of a coin that we have discussed earlier that either head or tail so two events but in multinomial we have multiple events like occurrence of one occurrence of two occurrence of three or occurrence of six on toss of a dive so example of multinormal distribution is ruling of a die so multinomial distribution has three parameters will not be going into details about multinomial distribution because it's not concerned with subject matter at hand but will have a general idea so multinomial distribution has three parameters that is n or number of outcomes P valves or the probabilities of the outcomes that is list of probabilities of outcomes so first we have number of outcomes then we have list of probabilities of outcomes and third we have the shape of the returned array that is common almost for every distribution whenever we try to sample something because after sampling we'll return something right the size the number of elements returned so the mathematics that is PDF or CDF will be discussed in future lectures today we'll emphasize on visualization of multinomial distribution and draw out conclusions if any so let's draw out samples first so let's draw out a sample let's take the rolling die experiment for this sampling so let X is equal to random Dot multinomial now we have to pass the number of outcomes that is 6 the P valves or probabilities of outcomes here in a role of a die the probability is 1 by 6 for each in every number so each and every number has equal probability of occurring this may not be the case for some biased experiments so you keep that in mind here we have each probability value is equal to 1 by 6 and we need to import a random from numpy so from numpy import random so X so this is the ra returned please so there is a very important observation to make the shape of return array is not one it is not a single element but I didn't specify any size so by default it should give me one that's what I thought or that's what you must have thought but it has returned an array with six elements so an important point is that multinomial samples will not produce a single value they will produce one value for each be Val so keep this in mind they will not produce a single value they will produce one value for each corresponding probability value also note that since multinomial distribution is an extension or we can say that generalization of binomial distribution so its shape or it the shape of its PDF will be same as the shape of PDF of a binomial distribution so we will not plot a multinomial distribution today that is for you to do that will be your homework or assignment task so as a home assignment plot a multinomial distribution so in today's lecture we covered the multinomial distribution and observe the similarities between a binomial distribution and a multinomial distribution we also gave you an assignment that is visualization of multinomial distribution that is all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we covered the multinomial distribution and today we are going to learn the chisquare distribution so let's get started so let me just rename the notebook to chisquare so what is a chisquare distribution or what is the significance of a chisquare distribution like the multinomial distribution is used in multinomial scenarios the logistic distribution is applicable to various machine learning algorithms in a similar manner the chisquare distribution is used to verify a hypothesis so it is used in hypothesis verification it is more of a statistical concept and we'll discuss it later on when we cover the essential mathematics for machine learning and data science in that course we'll be dealing with chisquare distribution so for now you need to remember that it has two important parameters first is DF that means the degree of freedom and other one is the size or the shape of the returned array now let's insert a new cell and let's draw out samples from a chisquare distribution so draw out a sample for a Chi Squared distribution with degree of freedom because we always need parameters while we extract the samples so let the degree of Freedom be 3 and size B 3 into 3 this is the size which denotes the shape of the returned array now from numpy import random and X is equal to random dot Chi Squared and will pass the parameter status degree of Freedom or DF is equal to 3 and size is equal to 3 comma 3 now let's print X so this is a 2d array but all the individual values of this 2D array are samples taken from a chisquare distribution now let's move on to the visualization of Chi Squared Distribution so let's visualize a chisquare distribution so we need to write from numpy import random import matplotlib dot Pi plot as PLT import fee Bond as SNS now we are going to write sns.displot and we are going to pass random dot Chi Square on Within brackets will pass the degree of Freedom Let It Be 1 and the size p so let the size be 1000. now will specify hist as false because this is also a continuous distribution so we don't need to visualize the histogram we just need the KDE path the KDE path also is not a very precise measure of the PDF but it helps us to visualize the PDF so we have visualized chisquare distribution so it has a longer tail on one side and a very short tail on the other side so in today's lecture we covered chisquare distribution we took out some samples from a chisquare distribution and at the end we visualized a chisquare distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered the chi Square distribution and today we are going to cover a relics distribution so let's get started so let me just rename my notebook to relics distribution or really so first of all what is a relics distribution so Radix distribution is used mainly in signal process so the main application of this distribution is in Signal processing we'll discussed it in detail in future lectures so this lecture is the idea only will not go into mathematical part or complex definitions just remember that Radix distribution is used mainly in Signal process we will discuss the PDF later on so it has two important parameters this is what we need to focus on the first parameter being the scale the scale here means the standard deviation which decides how much the data is dispersed or how flat is the distribution or how flat this distribution will be add the default value of scale or standard deviation is 1 .0 so here scale means standard deviation which describes the flatness of the distribution and the default value will be 1. and the second important parameter is size it denotes the shape of the returned array now let's draw out samples from a relix distribution so draw out a sample for a relics distribution now we can have two parameters here the first being scale and the second being size so let the scale be 3 and the size B 3 cross 3 as usual so let's insert a new cell so from numpy import random and X is equal to random Dot relics and let me just pass this deal and the size now let's print X to see so X is a 2d array it has nine individual values that are samples taken from a relix distribution now let's move on to the visualization of freelix distribution so from numpy import random import matplotlib dot Pi plot as PLT import c bond as SNS and sns.dis plot pass NP Dot sorry we don't need NP here we just need random dot relics and pass the value of size and scale will acquire the default value 1 and we don't need a hist so specify it as false so there is a slight error somewhere sorry there's mistake in the spelling of Felix so make sure you don't spell it incorrectly otherwise it will give an error and it will take a lot of time to fix it I'm quite used to errors so it takes me lesser time but it will take you a lot of time if you make such errors also note that unit standard deviation and 2 degree of Freedom or two degrees of freedom a relics distribution is equal to Chi Square distribution so this is the relation between a relics distribution and chisquare distribution so in today's lecture we covered a Felix distribution we drew out some samples from a relics distribution we visualized it and we try to understand the similarities between a relief distribution and a chisquare distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered prelix distribution and today we are going to cover our last distribution that is Pareto distribution so let's get started first of all let me change the name of notebook to Pareto and let me maximize the screen so a distribution following parvedo's law is called asparatus distribution so this is the simplest definition which absolutely makes no sense because it's not much of description so what you actually need to remember is what is pareto's law so don't just write that distribution following pareto's law is called as pareto's distribution you have to mention this 80 20 distribution thing so what is 80 20 distribution or what is 80 20 law its figure out let's see so 80 20 distribution or 80 20 log operators law means that 20 factors can cause 80 percent outcomes so this is the important statement that is 20 factors costs eighty percent outcomes and I hope that some of you must have heard of a rule or a proverb or something like this that is 20 hard work can bring 80 percent results so back in school some of the students used to say that to bring 80 percent marks we need to study only 20 percent syllabus so that is not true you have to study 80 syllabus for 80 marks at least so but in general in life in general you need 20 hard work to get 80 results so here we have two important parameters the first being the she parameter and second being the size of the returned array are the shape of the returned array now we'll insert a new cell and we'll try to draw some samples from a pareto's distribution so let's draw out samples from burritos distribution so we need to specify some parameters so let the shape B3 that means e is equal to 3 and that's the size B 3 cross 3 that means the shape of returned array will be 3 cross 3 it will have three rows and three columns so from num Pi import random X is equal to random Dot Pareto and will pass is equal to 3 and size is equal to 3 comma 3 and we'll print the value of x so X is a 3 cross 3 Matrix which contains some values that are sampled from a pareto's distribution now let's visualize the distribution so from numpy import random import tip dot Pi plot as PLT import c bond as SNS and sns.displot and in Brackets random dot Pareto and will pass a is equal to 2 and size is equal to 1000 and since pareto's distribution is a disk free distribution we need KDE as false so this is how shape of a pareto's distribution looks like hence we have visualized pareto's distribution or we can say that pareto's distribution have been visualized so in today's lecture we covered potatoes distribution and we visualized the shape of a pareto's distribution that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we concluded our discussion on distributions and today we are going to start with universal functions so let's get started let me just rename my notebook first so let the name be you funk so what is a ufunk so ufunk basically stands for Universal functions are you functions in plural means Universal functions so what are these Universal functions or you functions so these are the numpy functions that act on or that operate on ND array objects so these are some predefined functions which can readily be used when we are working with numpy and why are the used they facilitate vaporization and broadcasting among other important Concepts so you Fung's or Universal functions are used to implement vectorization they provide Broadcasting and additional methods so this is basically the reason behind using ufunks or Universal functions so at times we have to perform some basic operations so you funds help us perform these operations without explicitly creating a new functions so you functions can also take additional parameters like where D type and out now let's try to understand with an example that why do we need a U func or a universal function so let's consider that we need to add elements off to list so here we have to add elements of two less and store the result in a new list so there are two ways to do it without you func and with you so without you fun or Universal function we can do it by zip method now X is equal to 1 2 3 4 5 P the first list and Y is equal to 4 2 3 4 and 5 be the second list now we need a third list which is or which contains the sum of individual elements of these tools so without ufunk we can do it by zip method and we need to declare an empty list first and then we'll iterate so for I comma G in zip X comma y Z dot append I plus G Now display Z so there is an error because I have not commented out that portion so let me just comment it out and run it again now you can see that lists Z contains the sum of individual elements of X and Y so 4 plus 1 5 2 plus 2 4 and so on now numpy has a universal function to do the same task that is ADD so we can perform the same operation using the U Funk or Universal function add so we just need to write V is equal to NP dot at X comma y so sorry I have not imported numpy because in earlier example I didn't use so just let me import numpy as NP and run it again now it will not give an error so this result is same in both the cases but lines of code in second one are lesser as compared to lines of code and first example so this is a method of Performing sum without iterating over the arrays or the list or we can see that without iterating over individual elements also it's worth noting that there are several kinds of universal functions or Q funks available which help us perform different operations and we'll discuss all of them one by one in future classes in today's lecture I introduce you to the concept of universal functions or you functions that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we started our discussion on universal functions and today we'll learn how to create a universal function so let's get started so let me just create a new notebook and rename it so let the name be creating a ufunk a universal function now will first learn how to create a universal function or U func because it may happen that you want to call a function for performing some operation again and again but it's not available so to create a ufunc we need to define a function and then we need to save it to the numpy ufunc library using another function so first we have to create a function and then we need to add it to the numpy using another method that is from PI func method so please try to remember to create a ufunk we need to declare and Define a function first then we need to add it to the numpy ufunk library with the from P func or from PI func method also note that the from PI func method takes some parameters so from PI function method X the following arguments or parameters first one being the function or the name of the function so the first parameter will be the name of the function that you want to add to the numpy youfunk library the second parameter is inputs the number of the inputs that your function will have and third parameter is the number of outputs so we have to pass three important arguments that is the function name the number of inputs and the number of outputs now let's move on to an example so we'll create our own Universal function which will take 2 arguments X and Y and it will return X raised to power y as output also note that X and Y need not to be numbers or integers they can be an array of integers so first step is to create a function so I created a function that is my func and it takes two arguments X and Y and I am returning X asterisk asterisk Y which means X raised to power y and now we'll save this function to the num by ufunk Library using from PI func method so my func is equal to NP Dot from PI func and I'll pass function name that is my func the number of inputs that is 2 and the number of output starts 1. and I'll execute let's do one more thing let's print the value returned by the function side by side so let's print my func and let the input B and array so we have to give two inputs that is two arrays there's an import error because of improper indentation so let's just correct the indentation the return is not correctly indented again so let me just fix it now let's run so 1 raised to power 3 and 2 raised to power 4. so this is the result now our function got saved in the num by ufunk library and we can call it in future programs so in today's lecture we discussed how to create your own Universal function or you func that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our last lecture we covered how to create a universal function and today we will discuss some Universal functions related to simple arithmetic operations so let's get started let me just create a new notebook and rename it so let the name be simple arithmetic so today we'll discuss some Universal functions which help us perform basic mathematical arithmetic operations such as addition subtraction Division and multiplication so we can use arithmetic operators directly between numpy arrays so let's first discuss the addition of numpy arrays let me just comment it so the function add and brackets to pass the parameters sums the content of two arrays and stores the result in a third array or a new array or we can say that it returns a new array so for addition we have the function add now let's demonstrate the addition of 2 less using the add function so import them by as NP and first of all create two arrays let their names be arr1 and arr2 so we already know how to create numpy arrays we have discussed it a million times by now so we have written the code for creating two arrays and now we'll create a new array which will contain the sum of individual elements of array 1 and array 2. so for that we have to write new array is equal to NP dot at and pass the array names I got an error because of a wrong name so we got the result as an array which contains some of individual elements of the two arrays now let's move on to subtraction so we have ADD function for addition similarly we have the subtract function for subtraction so the subtract function subtracts two arrays and the result is written as a new array so we just need to write new array Let It Be new array 1 is equal to NP Dot subtract and pass the parameters as Error 1 and error 2. Now display and we got the result as an array of all minus tense because all of the elements differ by 10 and elements of array 2 are greater than elements of array 1. now let's move on to multiplication so for multiplication we use the multiply function so multiplication is done and answer is returned as a new array so the procedure will be same we'll just need to replace add or subtract Pi multiply so new array name is equal to NP dot multiply and in Brackets we'll pass the parameters so new r a new array name is equal to NB dot multiply and in Brackets Error 1 and arr2 are passed as arguments and I will display so this result is wrong because I have to write new arr2 so let me just correct it so this is probably me figuring it out that what mistake I've done while I was recording the video but it's the wrong so now corrected it and I got the correct result at last we are going to discuss division so the procedure of division will be the same we just need to replace multiply by divide this time so division is performed by use of divide function division is done and answer is returned as a new array so it divides the corresponding array elements and Returns the result as a new array now let's demonstrate division of two num by arrays with help of an example so new array name or new arr3 is equal to NP dot divide and will pass two arrays that is Error 1 and arr2 now let's display the result so new arr3 in my case I'm using notebook so it's directly displaying the output part you need to write print if you want display the output now let's see what if some elements are zero what will happen do we get an error or not so let's see what happens if we have a Zero Entry so let everyone be a less containing only 0 and array to be a less containing only two now let's divide so ARR 8 or any new array name is equal to NP dot divide and arr1 comma sorry we I have to write comma here not the Divide sign I'm used to it because in division we use divide side so let me just change it comma so it gave me the result as 0 because 0 divided by 2 is 0. now let's see the result of 2 divided by 0. so I am interchanging so it gave me divide by added or divide by 0 error so in today's lecture we discuss some Universal functions related to basic mathematical operations that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in today's lecture we'll continue our discussion on some Universal functions to perform simple arithmetic operations so let's get started let me just change the notebook name to simple arithmetic part 2. so first of all we'll discuss the power function so the power function Rises the value from first array to the power of values of the second array and result is written in form of a new array so in our daytoday life we need to perform some operations related to squaring cubing or any X raised to power y so we can solve such problems with the help of power function so power function Rises the value from first array to the power of values of the second array and result is written as a new array now let's demonstrate the use of power function with the help of an example so import numpy SNP and first of all we need to create two arrays so I have created two arrays now I'll write new array name is equal to NP dot power and pass the names of two lists now I'll print this new array and the result is the elements of array 1 raised to part the elements of array a list two so one raised to the power 2 is 1 2 raised to power 2 is 4 3 raised to the power 2 is 9 and so on and the second problem is how to get the remainder of any division so to get a remainder of any division we can use two functions the first being the mod function and the second being the remainder function so we can say that both mod and remainder functions are used to return the remainder and how does it operate the remainder of values in first array correspond to the value in second so it will return the remainder of values in first array corresponding to values in second when division is performed now let's try to understand through an example so let's write new array name is equal to NP dot mod and pass the array names and let's print this new array so new arr1 and it gave us the result so 1 divided by 2 gives the remainder 1 2 divided by 2 give the remainder 0 3 divided by 2 gives the remainder 1 and 4 divided by 2 give the remainder 0 so this is how the mod function works so remainder function is similar now let's write new array is equal to NP dot remainder and pass the array names so we should get the same result so let's see yes the result is same in both the cases demonstrating that both mod function and remainder function are used to return the remainders now let's discuss the functions to get the question and the mod so the function div mod returns both the question and the mod and it returns two arrays the first contains quotient and the second contains mod so div mod function takes two parameters and it returns two outputs first one being the equation and the second one being mod s demonstrate the use of div mod function the new array name is equal to NP Dot divmod and will pass the array names that are array 1 and array2 or arr1 and arr2 now we have the result as two arrays the first one being two equations and the second one being the mod values now let's move on to the last topic or last function which is to get the absolute values to get the absolute values we can use two functions the first one being absolute and the second one being abs you might have heard of ads function before in some programming language so we can use adds or absolute both to fit the job now let's debunk straight the use of adds an absolute function so err or array name is equal to NP dot array and let me pass a list containing some negative elements because we need to get absolute value which will be same for positive but different for negative so new array is equal to NP dot apps and array name now I'll print the new array and it gave me positive values by using absolute also it will give me the same result so in today's lecture we concluded our discussion on universal functions for performing basic mathematical arithmetic operations that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in our previous lecture we covered some Universal functions to perform basic arithmetic operations and today we are going to cover some Universal function which help us to round float or decimal values so let's get started let me change the notebook name to rounding so in numpy there are five functions which help us round decimal values so there are primarily five ways of rounding off they are truncation fix rounding floor and ceiling you must be knowing the difference between these five methods these methods are also discussed in AP mathematics so let's first discuss the trunk and fix method so run and fix function I used to remove the decimals and return number closest so it Returns the closest number for example if it's 2.1 it will return 2 and if it's 2.9 it will return 3. so we can say that the trunk and fixed function I used to return the closest integer number now let's demonstrate the use of Grant in fixed method so let's write ARR is equal to NP dot trunk and will pass a list containing float values so it should give us minus 2 and 3 and the result is as expected now let's demonstrate the use of fixed function so I'll write NP dot fix and I'll pass a list of float values so I should get the result as minus 2 and 8. so result is same as expected so I hope you understand the difference between trunk and fixed method now let's move forward with rounding and the use of a round function so the around function increments the preceding digit or decimal by 1. so it increments the preceding digit or decimal by one if we take an example if the number is 3.166666 then it should round it to 3.17 yeah also we need to pass an additional parameter that is number of decimal digit that we want to round two for example we just want to display two digit after decimal or one digit or three digit output table the number of digits that you want after the decimal point now I'll demonstrate the use of rounding with a round function so I'll write import numpy as NP and new array name is equal to NP dot around and I'll pass two parameters the number as well as the number of digits after decimal Let It Be 2. so I'll get the result as 3.17 I should get the result as 3.17 let's see what do we get so the result is 3.17 as expected now let's move on to the floor function and ceiling function now it's for you to figure out that what's the difference between floor function and thieving function although it will be clear once we see an example so the floor function rounds of decimal to nearest lower integer so we'll get the nearest lower integer in this case so let's demonstrate the use of floor function so array name is equal to NP dot floor and will pass a list containing decimal values or float values so we'll display the result and the result is minus 3 and 3 because these are the nearest lower integer and lastly the seal function or the ceiling function as shown in mathematics so the Seal of 3.166 is 4 but the floor of 3.166 is 3. this is the difference between the floor function and the seal function now let's see an example so I'm gonna import numpy as NP and I'll write ARR is equal to NP dot field and I'll pass a list of float or decimal values so it's giving me as minus 3 and four sorry I made a mistake the Seal of 3.166 will be 4 and the floor will also be 4. but it is different for 3.667 for that value the field will be 4 but the floor will be three point a 3.0 or 3. so sorry made a mistake and I should not execute this block so I'll just try to undo it so in today's lecture we covered different Universal functions in numpy which help us round decimal or float values that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you hi guys welcome back to our course on numpy in today's lecture we are going to take a look at some Universal functions which help us perform logarithmic operations so let's get started let me just change the notebook name to logs so it's done so numpy has functions to perform log at the base 2 10 and E so there are direct functions available to perform these logs that is the base to the base 10 and the base e lock at base e is also called as natural log and then we'll discuss a general way to take log at any base so then there is a general way to take log at anyways first of all we'll start with log at the base 2. so log at the base 2. so first of all I'll import number as NP and I'll write ARR is equal to NP dot a range 1 comma 11. it will return me a list of numbers from 1 to 10. so this e range method or function returns array if you recall we have discussed it earlier in many lectures so I'll just print in P Dot log 2 and Arena so it will perform log at the base 2 for all the values in this array so you can see that log 2 to the base 1 will be 0 Log 2 to the base 2 will be 1 and so on we know that this is locked to the base 2 because for 2 it gives us 1 because 2 raised to power one is two Now log at the base 10 so we just need to replace log 2 by log 10. so NP DOT log 10 and then we have to pass the array name so it should give us 1 at 10 yes the result is as expected because log 10 to the base 10 will be 1 so in this way we know that our answer is correct now let us take log at the base e so log to the base e or popularly known as natural log so we just need to replace log 10 or log 2 by simply log and it gives us the log at the base E for every element of the array now if you see clearly it gives around 1 for 3 because the value of e is two point something and it's closer to 3 so log 3 base e will be closer to 1 so value of is 2.718 so log 3 to the base e will give us a value very closer to 1. now we'll see a general way to perform log at any base so this is not using numpy Universal function we'll do it by using function log from math library of python so I'll just import from math import log import numpy as NP and NP log is equal to NP Dot from p func log and 2 comma 1. and I'll print this NB log for 100 comma 15. so we have created a sort of new Universal function if you see the pattern here if you don't see the pattern here compare it with the video where we created a universal function from scratch and stored it in the numpy ufunk library so in today's lecture we covered some Universal functions related with logarithmic operations that will be all for today this video is brought to you by programming knowledge please like comment share subscribe and hit the Bell button for updates and stay tuned with us for next lecture thank you
