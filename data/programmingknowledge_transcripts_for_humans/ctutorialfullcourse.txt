With timestamps:

00:00 - hey guys welcome to programming
00:03 - knowledge in this video we will be
00:05 - looking at some basic concepts of
00:06 - computer programming and we will also be
00:09 - installing tools to help us code in C
00:11 - plus plus
00:12 - this video is going to be the first
00:14 - video in the tutorial series on CPS Plus
00:17 - for beginners let's get started
00:19 - the first thing we need to address
00:21 - before learning how to program is what
00:23 - is programming so programming is
00:26 - basically a way to instruct the computer
00:27 - to perform specific tasks and by
00:30 - specific tasks I mean those tasks which
00:32 - you typical human will find it difficult
00:35 - to perform within a limited time frame
00:37 - so these tasks are generally a huge
00:40 - scientific computation for monitoring
00:43 - minor changes in the data but we can
00:46 - make the computer perform any tasks of
00:49 - our choice by programming it to do so so
00:52 - we need a way to communicate with the
00:54 - computer right we need to communicate
00:55 - with the computer to make it perform the
00:57 - task so we do that by using special
01:00 - languages known as programming languages
01:02 - so you might have heard of famous
01:04 - programming languages like C C plus plus
01:07 - Java python so there are tons of
01:10 - languages out there and in this tutorial
01:13 - series we will be exploring CPS Plus
01:16 - the next question comes is why learn
01:18 - programming so the first obvious reason
01:21 - is that computers are extremely fast
01:24 - if you know how to utilize the power of
01:27 - computer programming you can do wonders
01:30 - with it for a typical computer of
01:32 - today's time an addition of two numbers
01:34 - which could be as big as a billion is
01:37 - just going to take a nanosecond so just
01:40 - imagine how fast a computer is it can
01:42 - perform billions of additions in one
01:45 - second that that's the power of
01:47 - computers and it is extremely fast in
01:49 - performing the task next thing is that
01:52 - computers are cheap so nowadays any
01:55 - electronic Gadget which is released in
01:57 - our Market comes with embedded CPU so
01:59 - everything is basically a computer in
02:02 - itself you are you have microcontrollers
02:05 - also so you can basically turn anything
02:07 - I mean any electronic Gadget into a
02:10 - Computing device and you can make it
02:12 - perform the task next thing is that
02:14 - computers can work 24 7. so if you are a
02:18 - beginner of task you can without any
02:20 - worries delegate it to a computer and
02:23 - then computer is going to finish the
02:25 - task for you and keep it ready so next
02:28 - question which comes is why out of all
02:30 - the languages should we learn C plus
02:32 - plus so C plus plus is very close to the
02:34 - hardware by learning C plus plus we can
02:37 - actually relate the concept to the
02:40 - hardware programming so uh it's really a
02:43 - plus point for beginners who are willing
02:45 - to take out application development
02:47 - directly from scratch next thing is that
02:50 - C plus plus gives a clear understanding
02:51 - of object oriented programming for
02:53 - beginners we will discuss about object
02:55 - oriented programming at a later stage
02:57 - but for no we can understand object
02:58 - oriented programming is um essential
03:01 - competitive programming concept with C
03:03 - plus plus will make it easier to
03:05 - understand next thing is that C plus
03:08 - plus has a huge fan base if you have a
03:10 - Hindi query there are tons of people out
03:12 - there who help you with it
03:14 - next thing it is used in application and
03:18 - system programming as I told so if you
03:21 - are a software engineer you can choose
03:23 - your career between application and
03:25 - System Program next thing is that
03:27 - it teaches you the difference between
03:29 - compiler Linker loader and other
03:31 - programming Concepts this is the main
03:33 - reason C plus plus is recommended for a
03:35 - beginner I do agree that python is much
03:38 - easier to learn and it can perform way
03:41 - more tasks than C plus plus but in C
03:43 - plus plus we will be dealing with
03:45 - everything from scratch even though
03:47 - there are libraries there is a way to
03:50 - actually Implement each and every
03:52 - concept from scratch by using that
03:55 - methodology we can actually learn
03:57 - everything to the core if you are a
03:59 - person who is interested in the core
04:01 - concept and the origin of every
04:03 - algorithm or any other concept C plus
04:07 - plus is the best language for you next
04:10 - thing is that it is widely used in
04:11 - application CPS plus can be found in any
04:14 - many applications like games animations
04:17 - web browsers you have databases and
04:20 - compilers operating systems run on C
04:22 - plus plus C plus plus has a white scope
04:25 - next thing is that it is extremely fast
04:27 - so if you have an idea of competitive
04:29 - programming it is basically a
04:31 - competition where our programming skills
04:34 - are tested within a limited time frame
04:36 - and uh there are there is a constraint
04:39 - so at that point many programmers use C
04:43 - plus plus so 99 percent use C plus plus
04:45 - has their language in computer
04:46 - programming because C plus plus is
04:48 - extremely fast in passing the data and
04:50 - working with the data so if you're a
04:53 - person who needs immediate results you
04:55 - press this language for you these are
04:57 - some of the reasons for the learning CPS
04:59 - Plus so now we'll start by installing
05:02 - the tools which will require to code in
05:05 - C plus plus so first thing we require is
05:08 - a software which can make the computer
05:10 - understand our CPS Plus Code that
05:12 - software is called a compiler so there
05:14 - is a difference between interpreter and
05:16 - compiler we will be talking about that
05:18 - in a later video but for now we can
05:21 - understand compiler as a software which
05:23 - can convert C plus plus code into binary
05:26 - code so that the computer can understand
05:28 - so some of the available C plus
05:30 - compilers are Apple export export is an
05:33 - IDE comes with an integrated C plus plus
05:35 - compiler you have Del C plus plus C
05:38 - language
05:41 - plus if you're on Linux you have the gno
05:44 - C plus plus pre-installed wizard in any
05:46 - distribution of Linux you can type GPS
05:49 - plus minus minus version and you'll see
05:52 - the version of the compiler which came
05:54 - with your distribution and if Windows
05:56 - you can directly go to control panel
05:59 - you can go to the programs
06:02 - programs and features and here if you
06:05 - scroll down you will see something
06:06 - called Microsoft Visual CPS plus so this
06:09 - is actually a c plus compiler provided
06:11 - by the Microsoft itself if you if you
06:14 - are a gamer and if you have installed
06:15 - any heavy game before you might have
06:18 - noticed that the game asks you to
06:19 - install the latest version of visual C
06:22 - plus plus or update the Microsoft Visual
06:25 - CPS plus component in your computer that
06:27 - is because as I told you C plus plus is
06:30 - used for building games and then those
06:32 - games require the latest version of the
06:34 - C plus plus compiler to be installed in
06:36 - a computer so Microsoft Visual C plus
06:38 - plus as both a platform and a compiler
06:41 - and if to use it we need Microsoft
06:45 - products you cannot directly use this
06:46 - visual C plus plus compiler uh these are
06:50 - open source compilers okay some of these
06:53 - the Min GW SQL and gnu are all open
06:56 - source compiler next thing we need is an
06:58 - IDE from what an IDE is basically ID is
07:01 - an integrated development environment so
07:03 - if we go by the definition of Wikipedia
07:06 - it says an integrated in development
07:08 - environment is a software application
07:10 - that provides comprehensive facilities
07:12 - to computer programmers so basically
07:14 - what it means is that IDE is a tool
07:17 - which is going to help you write your
07:19 - program you can actually write your
07:20 - programs in notepad also for actually
07:22 - for writing C plus plus codes you just
07:25 - need a compiler and you can even use
07:27 - your notepad to write C plus plus code
07:29 - so what you need to do is just type your
07:32 - code in and then you save it with a DOT
07:34 - CPP extension so C plus files Global
07:38 - extension dot CPP and then the when you
07:40 - run it through the compiler the binary
07:43 - file will be generated and the computer
07:45 - is going to execute it but why we need
07:47 - an ID is ID is know what our code is IDs
07:51 - know our language so while coding what
07:55 - we need to do is we need to concentrate
07:57 - more on the logic than the syntax and
07:59 - semantics of the language we need to
08:01 - concentrate on the logic and the grammar
08:04 - so IDs are great tool because they have
08:07 - a feature of correcting the grammatical
08:10 - mistakes you make the syntactical errors
08:12 - which we call technically those errors
08:14 - are identified by the IDE and ID is
08:17 - actually sometimes the corrected some ID
08:19 - is corrected basically and some ideas
08:22 - ask you to correct it before compilation
08:24 - itself so that's a great feature in idea
08:26 - and it also contains many other features
08:28 - like it provides you a debugging
08:31 - environment we will look at debugging
08:33 - when we are testing our application the
08:35 - best I leave for Microsoft is visual
08:37 - studio so you might have heard about
08:39 - this Visual Studio is the best ID you
08:42 - can find on for Windows development you
08:44 - also get it with game development and
08:47 - many Visual Studio is a best idea for
08:49 - Microsoft
08:50 - it's also available for Mac but xcode is
08:54 - better for Mac so visual studio you can
08:56 - actually download it because you can
08:58 - download the community version display
08:59 - but this uh this ID is actually a heavy
09:02 - software it is going to take about 10 GB
09:05 - of space so if if you are running low on
09:08 - computer specs you need to consider
09:10 - other IDs there are a couple of other
09:11 - IDs as well their famous IDs like
09:14 - Eclipse neck bins Etc but for a beginner
09:17 - I would recommend code blocks as your ID
09:19 - so code blocks is a lightweight ID you
09:22 - can go you can search code blocks on
09:24 - your favorite browser open the first
09:26 - link which is codeblocks.org so this is
09:30 - the website here for code block this is
09:33 - a open source ID and it is really a
09:37 - lightweight idea you can make
09:39 - intermediate projects in code blocks you
09:41 - can use it for heavy projects but for
09:44 - learning the language and working on
09:46 - intermediate level projects code blocks
09:49 - works the best for you and it is not
09:52 - even bigger it just takes about 500 MB
09:55 - of space in our tutorial series we'll be
09:58 - using the code blocks ID you can
10:00 - download the source code or download the
10:02 - binary source code is for the people who
10:04 - are in Linux environment if you are
10:06 - familiar with Linux you will be finding
10:08 - yourself compiling everything from
10:10 - scratch for that the source code is also
10:12 - provided but uh if you just need a
10:14 - straightforward installation you can go
10:16 - to the download the binary list here you
10:18 - will find different files for different
10:21 - platforms so in Windows I'm here and
10:23 - then you'll find it for Linux and the
10:26 - Mac as well you can download your
10:27 - version and here we need to understand
10:29 - something so core blocks is just an ID
10:32 - okay the IDE software is only going to
10:35 - be installed we need a compiler as it
10:37 - will compiler is first required
10:39 - generally we can compile our code and we
10:42 - can ID we can only write the code you
10:45 - can download any of these compilers out
10:47 - here you have segment or Dev C plus plus
10:50 - or main GW but
10:53 - the thing is it is going to be a bit
10:55 - complicated once you download the
10:57 - compiler you need to actually integrate
10:59 - it with the I integrated development
11:01 - environment that is IDE then only our
11:04 - code will be compiled and run by the ID
11:07 - for that you can actually go go to a
11:10 - favorite browser and then type for
11:11 - sigvin or you can even install main GW
11:20 - the problem here is that once you
11:22 - download the compiler you need to add it
11:24 - to the path this is a complicated
11:26 - process and for a beginner I'm I would
11:28 - not recommend adding adding compilers to
11:31 - the path and then integrating it with
11:33 - IDE so what I recommend is just directly
11:37 - download this file which says code block
11:39 - 17.1 to Min GW setup.dxe what this is is
11:43 - code blocks provides a inbuilt ngw
11:47 - compiler along with the environment this
11:49 - setup will contain the imagew compiler
11:52 - and then by installing itself you
11:54 - install the compiler also in the
11:57 - environment so the compiler is not said
11:59 - to work in the path I mean the compiler
12:02 - won't work in a whole computer but it
12:04 - will only work in the environment in
12:06 - which code blocks is installed so once
12:08 - you download this setup file you will be
12:11 - having a compiler but that compiler will
12:13 - work only in the code blocks environment
12:15 - so so that is actually recommended for a
12:18 - beginner but if you like to explore more
12:20 - we'll have a separate video on how to
12:23 - download addition external compilers and
12:26 - Link it with our ID so visual studio
12:28 - doesn't need a linking because it
12:30 - directly uses the Microsoft Visual C
12:31 - plus compiler other compilers we need to
12:34 - integrate it with the ID so for now we
12:37 - are directly going to download this one
12:39 - you can choose any of these mirrors I'm
12:41 - going to go with fossil
12:43 - so once you are in fossil you need to
12:46 - wait for few seconds to download get
12:49 - started and you need to start the
12:50 - download so I'm going to pause the video
12:52 - till it gets downloaded
12:54 - okay guys so my download is completed so
12:58 - I'm going to close it I'm going to open
13:00 - the downloads folder
13:04 - and in the programs I'm going to find
13:06 - the code block setup file so this is a
13:08 - very straightforward installation in
13:10 - Windows you just have to click next and
13:12 - then you need to agree the terms and
13:14 - conditions
13:16 - I'll leave it as it is we need all these
13:18 - plugins and uh you can actually change
13:21 - the destination folder I'm going to
13:23 - leave it uh as default I'm just going to
13:25 - click on install so this extraction
13:27 - process is going to take about a minute
13:29 - and once it's ready we can launch our
13:32 - code box ID
13:34 - so
13:35 - it is basically extracting the files and
13:38 - the compiler so the compiler comes with
13:41 - the idea itself so you can just click on
13:43 - yes and then it's going to open and we
13:46 - can close this wizard we can just click
13:47 - finish and finish over here and here uh
13:51 - it says that a compilation detoxes the
13:53 - dnu GCC compiler that is the mean GW
13:55 - compiler you need to just click on this
13:57 - and then click ok now that is inside the
14:00 - code block so it just comes with it so
14:01 - you can once you hover over the most you
14:03 - can see the path of the minty W compile
14:05 - it's inside the code blocks environment
14:07 - So eventually okay
14:10 - so uh you can just click OK and this is
14:14 - the interface of code block for now we
14:17 - are just going to go create a simple
14:18 - application just click on create a new
14:20 - project go to the console application so
14:23 - all these are different kinds of
14:25 - applications we can develop with C plus
14:27 - plus but uh for now we are going to just
14:30 - go with console application so you can
14:32 - just click on go and then we can skip
14:34 - this page
14:36 - we need to select the language so just
14:38 - select C plus plus click next and then
14:40 - we need to give a project title so I'm
14:43 - just going to say
14:45 - cpp1 and then uh the folder to create
14:49 - project 10 I'm going to browse it I'm
14:51 - just going to put it in my desktop you
14:53 - can choose any location of your choice
14:55 - and then just click ok so here uh the
14:58 - file name will be created so the dot CBP
15:01 - extension stands for code blocks per
15:05 - project file that file is directly
15:07 - accessed by the code blocks IDE and
15:09 - inside that you will find a sources
15:11 - folder in which your CPP file will be
15:14 - there CPAP is the C plus file and you
15:17 - see BP is a code block style you can
15:20 - just click on next and then you can
15:22 - leave everything as it is it is just a
15:24 - compiler configuration and then you are
15:26 - ready to code so here in the left hand
15:28 - side you can see in the workspace uh you
15:31 - have CPP and then inside that you have
15:34 - subfolder known as sources you can just
15:35 - click on us and he inside that you will
15:38 - find a main.cpp file so if you double
15:40 - click it you will have the basic program
15:42 - over here so this program just prints
15:45 - hello world to the console okay if you
15:48 - want to run it you can just press F9 or
15:50 - this button over here which says build
15:52 - and run if you just click on this it is
15:55 - going to build the application it is
15:56 - going to run it and here on the console
15:58 - we see hello good so congratulations
16:00 - guys we just compiled our first C plus
16:03 - plus program so as I told you these are
16:05 - some of the lines provided by the
16:07 - compile weather IDE so it just returns
16:11 - it with the return code and then there's
16:13 - the execution time it just took 0.022
16:16 - seconds to execute this code and uh
16:18 - these are some of the features of the ID
16:20 - so what we wrote is just District you
16:23 - can uh you can actually Tinker on with
16:25 - that you can actually change this line
16:27 - you can make it as a welcome welcome to
16:32 - programming knowledge
16:39 - welcome to programming language
16:41 - in this video we'll discuss about
16:46 - computers do and what are the
16:48 - differences between them for a recap
16:50 - this is the program provided by the code
16:53 - blocks IDE I just change the default
16:56 - hello world statement to this statement
16:58 - and then once you press this button or
17:01 - the F9 button you are going to execute
17:04 - this call and the console is going to
17:05 - pop which is going to print welcome the
17:07 - programming knowledge on both the world
17:09 - statement you typed inside the double
17:11 - code and then it is going to return the
17:13 - execution time and all these things let
17:16 - us see what is actually happening in the
17:18 - background
17:19 - foreign
17:26 - language Assembly Language
17:30 - machine language is a fundamental
17:32 - language of the computers process
17:34 - computer is not able to understand any
17:36 - other language than the machine language
17:39 - all programs are converted into machine
17:41 - language before they can be executed and
17:43 - machine language is just a series
17:46 - that represents low and high voltage
17:49 - language
17:55 - but the difference is that assembly
17:57 - languages use symbolic population
17:59 - represent the machine operation code
18:01 - both the Assembly Language in the
18:04 - machine language are all more similar to
18:06 - C but the only difference is that
18:08 - Assembly Language are built available
18:11 - kind of machine language
18:18 - on High level languages
18:28 - let's look at an example
18:30 - so this is a single program to do a
18:35 - mathematical computation definition
18:38 - to understand is that the computation
18:41 - which is going to be performed as B into
18:43 - H by 2 that is the contents of B is
18:46 - going to be multiplied with the content
18:48 - of H and then the result is going to be
18:51 - divided by 2 and that is the value we
18:52 - are going to get
18:54 - of what happens in the background is
18:56 - that polished a memory location with the
19:00 - size of memory required for this
19:01 - particular object is loaded into the
19:05 - memory and then the guidance of B are
19:07 - transferred into the location Army same
19:09 - thing happens with R2 then
19:13 - multiply the contents of R1 and R2 are
19:16 - multiplied and then the result is stored
19:18 - back in R1
19:19 - next step and here divides the patterns
19:23 - of R1 by the number two and then the
19:26 - result is given back in our query
19:28 - location which is requesting the
19:30 - computation all this temporary memory
19:33 - locations which have been created and
19:35 - then unloaded from the memory
19:39 - so this is what happens background of
19:42 - this simple computation
19:44 - so in case of our hello world program
19:47 - here all the welcome to programming
19:50 - knowledge this one what happens is that
19:52 - first link is established between the
19:55 - console and our program and then there's
19:59 - a process which will generate machine
20:01 - code from this particular code and then
20:05 - that is going to be executed and what we
20:07 - see as a result is this statement on our
20:10 - function so there's a lot of problems
20:12 - going behind let's see what a compiler
20:15 - is
20:16 - so as I told you compiler is a piece of
20:20 - software that translates the high level
20:22 - language to the Machine level
20:25 - the compiler basically takes the source
20:27 - code and then it converts it into the
20:30 - executable code this type is known as a
20:32 - reprocessing step and then the
20:34 - executable code which is the zeros and
20:36 - one or sometimes assembly code are
20:40 - converted into the machine code which is
20:43 - purely 0 seconds and then this code is
20:46 - executed by the machine so compilation
20:48 - step consists of two steps reprocessing
20:51 - and the processing so a compiler takes a
20:54 - lot of free processing time it is going
20:56 - to go through the whole of your program
20:58 - it is going to be reach at every
21:00 - statement it is on the errors and then
21:03 - it is going to ask you to correct the
21:05 - errors it is again going to register
21:07 - your program and then it is going to
21:09 - finally generate the executable
21:12 - reports
21:14 - in your program
21:39 - at a later stage
21:42 - so once it's loaded into the compiler it
21:45 - is going to generate the lower level
21:46 - code that is the object code
22:17 - so what an interpreter is interpreter is
22:19 - same as a component there is not much
22:21 - difference the only thing is that in
22:23 - interpreter the pre-processing step is
22:25 - faster than the case of compiling in
22:28 - interpreter The Interpreter is going to
22:30 - go through each and every line of the
22:33 - core it is going to execute that
22:35 - particular plan in a virtual environment
22:37 - and then once you television error it is
22:40 - going to stop right there
22:45 - around the interpretation process
22:48 - continues from that particular point to
22:51 - the end that's why The Interpreter is
22:54 - faster at 3 processing and then it
22:56 - doesn't generate an object file object
22:58 - files are generated in the runtime
23:00 - itself that is why the processing type
23:02 - is Big because while executing the same
23:05 - program multiple times every time at
23:07 - every education an object will need to
23:09 - be generated on the runtime unlike the
23:12 - case of compiler and only one object
23:14 - file is generated at the first time
23:16 - compilation and the same object is used
23:18 - to run the program that's why if we see
23:22 - this if we change anything here if I
23:25 - make welcome programming knowledge as
23:28 - the default hello world
23:30 - hello world and if I just run this
23:33 - program I am just going to get welcome
23:36 - to programming knowledge
23:38 - why did this happen because the object
23:40 - file is the same in this case in case of
23:43 - an interpreter that is going to change
23:45 - if you directly change this code here
23:47 - and then run the program you are going
23:49 - to get where hello world inclusion
23:52 - welcome to programming knowledge
24:13 - always it is going to work on the
24:15 - previously generated object file so once
24:17 - we create this build and run the vehicle
24:20 - is built and run button we are going to
24:22 - get a logo here and now again if you
24:26 - click on this button we just press run
24:29 - you will get hello because the object
24:31 - file has been replaced now and then
24:33 - because if we make any changes now if we
24:36 - just type hello here and then again type
24:38 - again click on run it is just going to
24:41 - say hello that's how a opt-in file works
24:59 - and it is not Hardware dependent so if
25:04 - you are checking the efficiency of a
25:06 - program we need to check the runtime of
25:08 - the program not the compilation because
25:10 - if in a computer with higher
25:13 - specifications mobile time will be much
25:15 - faster than a computer with lower
25:17 - specification but the Run type of both
25:19 - the program is going to be same foreign
26:10 - first takes the code line by line and
26:13 - then it is going to execute it in a
26:15 - virtual environment immediately then but
26:18 - look at the result and only that
26:20 - particular line is correct it is going
26:22 - to go for the compilation
26:24 - next in object code is generated and
26:27 - compiler layers in interpreter is not
26:29 - generated it is generated during the
26:31 - runtime itself the thing which is the
26:33 - most important thing is that the runtime
26:36 - of combined languages are much faster
26:38 - than interpreted diabetes this is
26:40 - because compile over makes only one obj
26:44 - file only one object code which is used
26:47 - to compile it again and again
26:56 - is generated in the runtime and that is
26:59 - going to be executed we are comparing
27:01 - the performance of C plus plus and
27:03 - python python is an interpreted language
27:04 - C plus plus will perform much faster
27:07 - than python because of the obj file in
27:10 - which it is going to save on the disk
27:12 - python is not going to save the obj file
27:15 - and it is going to generate the obj file
27:17 - every time it is executed so that is the
27:19 - difference between interpreter and
27:20 - compiler in this video we'll be looking
27:22 - at this template code which code blocks
27:25 - had provided us while creating a project
27:26 - and also we will be learning how to
27:28 - perform simple output in C plus plus
27:30 - let's get started
27:33 - so the first line here says hash include
27:35 - IO stream
27:37 - Ash include is known as a pre-processor
27:39 - directive so hash include is used to
27:42 - load files which are already present in
27:44 - the compiler Q plus plus compiler comes
27:46 - with many files which are which have
27:49 - predefined functions to help us code
27:51 - with so higher stream is one of them and
27:54 - by using this preprocessor directive by
27:56 - using hash include we are actually
27:58 - invoking this file from the compiler so
28:01 - without this file you cannot perform any
28:03 - input or output in CPS plus there are
28:05 - many other header files we will be
28:06 - coming across in the run but for now let
28:09 - us explore IO stream IO stream contains
28:12 - all the functions which we need to
28:15 - perform console input or output so IO
28:18 - stream basically stands for input and
28:20 - output Stream So by name itself we can
28:24 - say every every function we need for
28:26 - performing input or output is present in
28:28 - IO stream
28:30 - next with this line it says using
28:32 - namespace STD so STD is known as a scope
28:36 - hope we can understand like a region so
28:39 - every function inside this IO stream
28:41 - Works only in a certain region so for
28:43 - now we are not going to deal with any
28:46 - other course rather than the standard
28:48 - scope but just for information there
28:51 - other scope also that we will be
28:53 - learning when we are already good in C
28:55 - plus plus that comes at an advanced
28:57 - stage but for now we can see uh only use
29:00 - the standard scope standard scope is
29:02 - nothing but the console so if if I just
29:05 - remove this line you will be seeing that
29:07 - this all these functions go out of the
29:09 - scope so now if I build and run this by
29:13 - hitting F9
29:14 - so now you can see that it shows an
29:17 - error what does the error say it says
29:18 - that 3 out was not declared in the scope
29:20 - this just means that this line or this
29:25 - particular function cannot be executed
29:27 - because it is out of the scope scope is
29:30 - nothing but the standard scope the way
29:32 - we Define standard scope is by using the
29:34 - scope resolution operation cooperation
29:37 - is nothing but this just write the scope
29:39 - and then the function and in between the
29:42 - scope and the function you just specify
29:44 - the scope by putting two columns so this
29:48 - is how you specify the scope so if I now
29:52 - execute it
29:54 - uh yeah I'm getting another error
29:56 - because this ended this angle is also uh
29:59 - from the io stream so it does not have
30:01 - that uh
30:03 - scope so I need to provide the scope for
30:05 - this also now if I build and run this I
30:07 - will be getting the output so here you
30:09 - can see welcome to programming knowledge
30:12 - so that is the importance of scope then
30:15 - why do we need using namespace
30:18 - also well you cannot do this for every
30:21 - statement right it is going to be lot of
30:23 - it is going to take a lot of time to
30:27 - actually do this and sometimes we may
30:28 - also forget to do this so suppose I am
30:31 - writing 10 coed statements this is a
30:33 - sealed statement here there's nothing
30:34 - but the output statement this one what
30:37 - I'm printing onto the console is known
30:39 - as coord statement so this statement if
30:42 - I writing 10 times I need to specify the
30:45 - scope 10 times so every time I use this
30:47 - function or not on only this function
30:49 - you if I use any function from this IO
30:52 - stream Library I need to actually
30:53 - specify this particular standard scope
30:56 - that is why to avoid that C plus plus
30:58 - provides a way to globalize that by
31:00 - using the namespace statement so by
31:03 - writing using namespace STD you are
31:07 - actually globalizing the statement and
31:10 - it is going to take care of any other
31:12 - standard so you if you don't write the
31:14 - standard it is automatically taken care
31:16 - of by the compiler because it just
31:18 - encountered this line this line just
31:20 - means that wherever standard scope needs
31:22 - to be used you just use it that is what
31:24 - this line means
31:26 - so the next line says Ink Main
31:28 - is actually a function every program has
31:32 - a main function main is like a
31:33 - triggering function so every program has
31:36 - this without main there is no program
31:39 - because all the execution starts only
31:42 - from the main function so suppose you
31:44 - write a 100 file program or even say
31:47 - thousand file program they may contain n
31:50 - number of functions but there is only
31:52 - one main function and that main function
31:55 - cannot be replaced and without this main
31:57 - function this program is not going to
32:00 - run so if I simply just type a capital M
32:03 - over here well C plus plus is case
32:05 - sensitive so capital M mean and a small
32:08 - M main are different so now if I try to
32:11 - build and run this I will be getting an
32:13 - error it says undefined reference to
32:15 - this win main at the rate 16 this is
32:19 - actually something which is inside the
32:20 - compare it is a compiler issue that is
32:22 - because it did not encounter the main
32:24 - function so only if you write the main
32:26 - function you are going to execute it so
32:28 - so bursting any scene plus plus program
32:31 - looks for is this for this function it
32:34 - needs to be Main and with a small M and
32:38 - it should be empty you can actually put
32:40 - void over here so all that also doesn't
32:42 - matter but just it just makes it look
32:44 - complex so it's best to leave it empty
32:47 - so if you put like this and then it has
32:50 - to be int the reason we'll be looking at
32:52 - it later and the meaning of this end and
32:55 - this return 0 will be understanding only
32:57 - when we are dealing with functions so
32:59 - for now we can ignore them so just
33:01 - remember that you need to write in any
33:03 - other main doesn't work so suppose if I
33:05 - put while or some in let's say float
33:08 - main all these are not going to work
33:10 - only in plane is going to work and for
33:12 - now you can actually remove this return
33:14 - 0. so without this also the program is
33:16 - going to run and it's going to give you
33:19 - uh there is a lot of significance for
33:22 - the return statement and we will be
33:24 - discussing about that when we are
33:25 - discussing functions
33:27 - so this as I told you is the coat
33:29 - statement just stands for the console
33:32 - output so CH stands for console output
33:34 - and whatever you write here goes to the
33:36 - screen and this operator is known as the
33:39 - stream operator stream operators are
33:41 - very important you will be looking at it
33:43 - while we are dealing with other streams
33:45 - also like file stream or something like
33:47 - that but for now while we are using the
33:50 - io stream that is the console stream we
33:52 - need to have these two functions in a
33:54 - pair so the this is a this is the stream
33:57 - function that is the co then this is the
33:59 - stream operator and this is the stream
34:01 - operand uh this is a statement but
34:04 - technically in computer programming this
34:06 - is called a string string is nothing but
34:09 - a collection of character it is called a
34:11 - string so that is a data type we'll be
34:14 - talking about that in the next video
34:16 - so for now this is what the program was
34:19 - and yeah I forgot to tell you this one
34:21 - uh this is actually appending another
34:24 - function in the same here so see how it
34:26 - actually operates on only one operand so
34:29 - if you want to operate on multiple
34:30 - operands you need to separate that with
34:32 - this stream operator so you see this is
34:35 - a string and this is a function angle is
34:38 - actually a function so uh the way it
34:40 - works is it is going to first do the it
34:43 - is going to first operate on this and
34:45 - then it is going to encounter this and
34:47 - then it is like adding another third
34:49 - statement that's it so if I just put a
34:51 - semicolon here and then put a c out over
34:53 - here it is going to work the same way
34:55 - just that it is not to get you confused
34:58 - these are two separate Church statements
35:00 - if you are wanting to put multiple
35:03 - statements in a single statement then
35:05 - that is how this is how you do it you
35:07 - just put a operator in between and then
35:10 - put the next operand over here and this
35:13 - semicolon is very important no matter
35:14 - which is a semicolon over here also
35:16 - semicolon is known as a Terminator so in
35:19 - C plus plus you can write multiple
35:21 - commands in the same line so Terminator
35:24 - what it does is it is going to separate
35:26 - each and every command so that the
35:28 - compiler knows what comment execute
35:30 - after executing the previous command so
35:33 - that is why we use a Terminator it is
35:36 - very important so if we remove this it
35:38 - is going to result to an error because
35:39 - it doesn't terminate and it says
35:41 - expected the semicolon before this
35:44 - particular
35:47 - end of a statement before this one that
35:50 - is why we put a semicolon and this curly
35:54 - pressure just signify the body of the
35:56 - main so whatever code you write you are
35:58 - going to write between these two braces
35:59 - for some time until we are we get
36:03 - familiar with functions so once we are
36:05 - familiar with functions we will be
36:06 - writing multiple functions and we will
36:08 - be invoking the functions within this
36:10 - main method
36:11 - we will be looking at that later but for
36:13 - now let us talk about the output so we
36:16 - all know how to put output right this is
36:19 - how we put output we just put them
36:21 - inside the two double quotes well this
36:23 - is a string
36:24 - uh we can also put numbers also so for
36:27 - numbers you can either put it as a
36:29 - stream so you can put something like
36:32 - this
36:33 - right and then execute it you will be
36:35 - getting Phi over there or integers are
36:39 - separate in programming so even if you
36:41 - put a file like this you are directly
36:43 - going to see file in the console so here
36:45 - you can see and now comes the major
36:48 - difference if I put 5 plus 5 over here
36:51 - and then executed
36:53 - I will be getting 10 over here that is
36:56 - the value of 5 plus 5 but if I just
36:58 - enclose it within a code uh within a
37:01 - double code
37:03 - what will I get I'll just get the same
37:06 - thing I'll just get 5 plus 5 because
37:09 - this is treated as a constitution what
37:12 - this double quote means is that whatever
37:15 - you put inside this double quotes is
37:17 - just going to be replicated as it is on
37:19 - the screen and if you don't put a double
37:21 - quote it has to be either memory
37:23 - location or some operand so memory
37:26 - location or variable will be looking at
37:28 - the next video while we are discussing
37:29 - input but for now and output we need we
37:33 - need to bother about memory location
37:35 - let's just talk about the integer part
37:37 - of it so if I just put uh let's say
37:41 - let's try another one let's put
37:43 - something like this 5 plus 5. let us try
37:47 - this one these are two different strings
37:49 - and now you know used a plus operator
37:52 - between these things so what we expect
37:54 - is actually 10 but let us now execute
37:57 - this and look at that it says invalid
38:00 - operands of types const care and
38:03 - constant what this means is you cannot
38:06 - add two constant characters or constant
38:09 - string or const care in this square
38:11 - bracket is square bracket is actually
38:13 - called an IA okay so we will be looking
38:16 - all of these things when we are
38:17 - discussing data types but for now we can
38:20 - uh you can understand that you cannot
38:23 - add two strings you can only add two
38:25 - numbers so if I just put 5 plus 5 I'm
38:28 - going to get the answer
38:31 - so here so this is same with real
38:34 - numbers also you can even put 0.5 plus
38:37 - uh 1.5
38:38 - so that makes it two so here you will be
38:41 - getting 2.2 over here so and you can
38:45 - even work with decimals also even if I
38:47 - put 1.45 you're going to get the answer
38:50 - so you will be getting 1.95
38:53 - so that is the major difference between
38:56 - strings and numbers so if you are
38:58 - working with numbers you can directly
39:00 - add them you can multiply you can double
39:02 - multiply here is the star symbol which
39:05 - you will be finding on the 8 on number
39:08 - eight on your keyboard so that is a
39:10 - multiply symbol and then divide as the
39:12 - normal forward slide symbol so this is
39:15 - the divide and multiply
39:18 - and there is another
39:20 - one also there is another operator that
39:22 - is called the modular operator what this
39:25 - does is it gives
39:27 - sorry it gives the remainder
39:33 - of the two numbers
39:37 - right so what what it means is if you
39:40 - just put 5 modulo 2 what this does is
39:44 - it gives a reminder so if you divide 5
39:47 - with 2 what is the remainder you are
39:48 - going to get you are going to get one
39:50 - because uh well it is uh 2 into 2
39:54 - plus 1 which makes it 5 right so this is
39:57 - the operation so that is why so 2 goes
40:00 - two times in 5 and then one is the
40:02 - remainder that is why you are getting
40:03 - one so you can verify that you can do
40:05 - that by simply putting
40:08 - 2 in uh well you can directly put 5 mod
40:11 - 2 right you're going to get one over
40:14 - here so if I just run this
40:16 - here you can see one there are many
40:19 - other operators will be looking at them
40:21 - later
40:22 - when these are the uh this is how you
40:25 - can perform output in CPS plus well
40:28 - there are other things also like instead
40:30 - of using this we have something called
40:32 - Escape sequences let me talk about them
40:34 - quickly
40:36 - it is escape
40:38 - sequences what these are is basically
40:42 - there are some keyboard tools which we
40:46 - cannot perform during runtime right so
40:48 - suppose we wanted to perform a backspace
40:50 - during the runtime it is not possible I
40:52 - am talking about the runtime so suppose
40:54 - I wanted to hello world over here
40:57 - suppose and then I wanted to perform a
41:00 - backspace for this extra space I have
41:03 - provided over here I cannot do that in
41:05 - the runtime right now I can do anything
41:07 - I can even put this I can change this
41:09 - character I can do anything
41:10 - but what about during the run time for
41:13 - that there are some special keystrokes
41:15 - that are actually treated as Escape
41:19 - sequences so the way we Define a script
41:21 - sequences are you actually put a
41:23 - backslash and then a special character
41:26 - so here there will be a special
41:29 - character
41:31 - and then this is going to actually give
41:34 - you a special meaning so this is going
41:37 - to execute that particular keystroke
41:43 - so there's there are some of the Escape
41:46 - sequences like slash a it's going to
41:48 - bring you a bill so you might have
41:50 - noticed that there will be a
41:53 - notification Bell that will come and
41:55 - then there is a slash B which is for
41:58 - backspace
41:59 - and then slash T and slash n we'll be
42:02 - using these things more often blast is
42:05 - for a horizontal tab
42:08 - and then slashing is for a new line wait
42:13 - we did see this one somewhere right this
42:16 - one so ndel is actually a function this
42:19 - is actually a significant difference
42:20 - between using slash and an Intel so I'm
42:23 - just going to
42:24 - delete these things let us first try
42:27 - slash in so first slash a I'm going to
42:30 - run this
42:32 - so you might have heard that uh song
42:35 - right that Bell song that is the
42:38 - function of Slash a so let us look at
42:41 - slash T that is just it's going to put
42:43 - it down so let me put a tab between
42:45 - hello and world so if I put slash D over
42:48 - here and then execute it
42:50 - here you will be seeing hello and then
42:52 - this space and then a word so this is
42:56 - what the function of Slash D and then
42:58 - slash n is what going to do the same
43:01 - thing what this function does it is just
43:04 - going to put the contents in the next
43:06 - line so if I just execute it there will
43:08 - be a new line so hello and then a new
43:10 - line and then the word
43:12 - so that is the function of Slash n in
43:14 - this video we'll be looking more about
43:16 - the Escape sequences which we have
43:18 - talked about in the previous video and
43:21 - we will be learning how to perform input
43:23 - in C plus plus so before getting started
43:25 - with the input let's talk more about the
43:27 - Escape sequences so the Escape sequences
43:30 - which I talked about in the previous
43:31 - video are slash a slash B 12 slash T and
43:36 - then once again slash d slash n
43:40 - okay there are actually many other
43:42 - Escape sequences also you do have a
43:44 - slash V but all these things we won't be
43:46 - using much flash is for a vertical tab
43:49 - we won't use that much but you can
43:51 - always go up into the internet and then
43:54 - check for the list of Escape sequences
43:56 - there so
43:58 - what do we need Escape sequences for is
44:00 - it just to perform these actions or do
44:03 - they have other purpose also so let us
44:06 - say I wanted to print something like
44:08 - this so let us say I wanted to print uh
44:12 - Escape
44:14 - sequences uh let me just put it without
44:17 - a brace so that this this is what this
44:20 - is the exact sentence I will be needing
44:22 - on the screen right so just try to print
44:24 - this Escape sequences
44:29 - start with a slash and uh
44:33 - have a
44:34 - character
44:37 - and have a uh let's say single code
44:40 - single or have a single
44:45 - character in them something like this I
44:49 - wanted to print this particular
44:51 - statement as it is onto the console
44:56 - you might think it's very easy right
44:57 - just cut it uh well I'm just going to
45:00 - cut it and then put it in pair of
45:04 - double quotes and then paste it over
45:06 - there and then let's just run it it says
45:10 - it's an error why it is expecting a
45:13 - semicolon before single well keto I have
45:15 - a semicolon right what's the problem
45:17 - with this well the problem is
45:20 - when you are putting a backslash in the
45:23 - in a string it is going to consider a
45:27 - backslash and the subsequent character
45:30 - as a escape sequence itself and here
45:33 - once you put a double quote over here it
45:36 - it means that this is a separate string
45:39 - and then this is a separate string and
45:43 - this is actually something in between
45:44 - right so it doesn't have any meaning at
45:48 - all so what we actually wanted was we
45:51 - wanted this double code to appear onto
45:54 - the screen right but we cannot do that
45:56 - we have a way yes we do that is by using
45:59 - Escape sequences so here I am wanted a
46:03 - backslash to appear right so how do we
46:05 - make a backslash up your backslatch
46:07 - itself is a Escape character when the
46:09 - worker wonders you put another backslash
46:12 - so this what it means is it means that
46:15 - this is a escape sequence and it this
46:17 - particular escape sequence just means
46:19 - that you need to put backslash on screen
46:22 - so that that is why your you you were
46:25 - getting an error back then and now you
46:27 - will be getting a backslash perfectly as
46:29 - you wanted it and here instead of this
46:32 - course you actually put a backslash
46:34 - before the code right so what they says
46:37 - is if you put a Escape Port over here if
46:40 - you put a code as a skip sequence it
46:42 - means that this code is not a part of
46:45 - this code which is actually uh
46:47 - indicating the start or end of a string
46:50 - but it's Escape character itself and it
46:52 - needs to be printed onto the screen that
46:54 - is what means if you use a code with it
46:58 - escape sequence so the same thing goes
47:00 - over here also if I just put the
47:02 - backslash it is going to go away this is
47:05 - now entirely highlighted in blue that
47:07 - just means that this and this entire
47:09 - thing is now a string and now if I
47:11 - execute it I'll be getting the output so
47:14 - here you can see Escape sequences start
47:16 - with the backslash and have a single
47:19 - character in them and single is enclosed
47:22 - within double quotes now exactly what we
47:25 - wanted so that is the importance of
47:27 - Escape sequences so there are many other
47:31 - so there are many places where you will
47:34 - be needing them so something like you
47:36 - wanted to enclose something using double
47:38 - quotes or you wanted to put a backslash
47:40 - over in some some place or suppose you
47:43 - wanted backslash n to appear but you
47:45 - can't directly print like this right you
47:47 - know what this is backslash n is
47:49 - actually a new line so if you put
47:51 - something like this and if you try to
47:52 - execute it you will be getting something
47:54 - like this thing sequences start with a
47:57 - and then a new line and then a space and
47:59 - then have a single character in them so
48:02 - that becomes a problem how do we do that
48:04 - same thing you just put double
48:07 - backslashes and then so now this
48:11 - actually this backslash and this
48:13 - backslash n are now different this
48:16 - backslash only corresponds to this
48:18 - backslash and then this n is now is
48:19 - greater as a separate character so now
48:22 - if I run this you will be getting your
48:23 - output so escape sequence will start
48:25 - with the backslash and you just got what
48:27 - you wanted and have a single character
48:29 - in them
48:31 - so this is how you use Escape sequences
48:33 - in your strength now let's talk about
48:35 - the input
48:37 - before not talking about input let us
48:41 - talk about something called data types
48:44 - the people that is done here
48:46 - data types why do we need to know about
48:49 - this well you can't just take input
48:51 - right you need to store the input at
48:53 - some place so that you can use it at a
48:55 - later stage so where we store the data
48:58 - is actually defined by the memory
48:59 - location and how will allocate memory
49:02 - that depends on the type of data we are
49:04 - going to get so we need to know what
49:06 - kind of data we need to we are going to
49:08 - get as an input so that we can store
49:10 - that data so what kind of data can we
49:12 - get we can either get numbers
49:15 - or characters right we can't get
49:17 - anything else well we do have other
49:19 - types of data also something like you
49:22 - have graphs or you have images videos
49:24 - but all that are ultimately broken down
49:27 - into it into numbers only that's a
49:29 - different story we are not going to talk
49:31 - about that at this stage
49:33 - but for now we can
49:35 - say that data is fundamentally consists
49:38 - of only numbers and characters we can't
49:40 - get anything else other than that
49:43 - so the way we data types are broken down
49:46 - is to satisfy either numbers or
49:49 - characters so in numbers what do we have
49:51 - we have integers
49:54 - or we do have real numbers so real
49:56 - numbers are nothing but decimals
49:58 - fraction all these things so the way we
50:00 - take integer cells by end so in this
50:03 - data type which is for integers so this
50:06 - is the data type and this is what it
50:08 - means so integers it's going to take so
50:10 - anything any integer is going to say
50:12 - minus 12 or 20 or 20 000 all these are
50:15 - integers only so can it take anything
50:18 - can you take even Infinity well no
50:21 - integer do have a range value and that
50:24 - ranges so let me write it separately
50:26 - here that ranges from minus 2 power
50:31 - 31
50:33 - 2 2 power 31 minus 1. well it's not 2
50:38 - into 31 it's 2 power 31 minus 1. so this
50:42 - is the range of the integers it is going
50:44 - to take up to this big numbers so you do
50:46 - have something called short and unsigned
50:49 - signed ends all these things we will be
50:51 - talking about that
50:52 - at a later stage for now this is the
50:55 - range of integers so you can store as
50:57 - small as minus 2 power 31 and as big as
51:00 - 2.31 2 power 31 is nothing but it's
51:03 - around 4 billion so that is the number
51:06 - you can store in
51:07 - so what if we need a bigger number than
51:10 - 4 billion let's say 6 billion or 8
51:13 - billion for that we do have a solution
51:15 - we are going to use long so long as
51:18 - another data type so long is actually a
51:21 - type modifier it is not a data type long
51:24 - you can use it within so this makes it
51:27 - this actually makes it pretty readable
51:30 - so it's just nothing but a big integer
51:32 - so what it does is it's going to store
51:34 - bigger numbers than int so this will
51:38 - take about eight bites just this is
51:40 - going to take only four bytes so this is
51:42 - whole bytes of memory we'll be looking
51:44 - at how this 4 bytes right now there's
51:47 - such a way to check how how much memory
51:50 - this takes so this is going to take
51:52 - eight bytes of memory
51:54 - and its range is uh approximately up to
51:59 - 64 2.64 approximately it goes up to this
52:03 - so this is a huge number right you won't
52:06 - practically need much bigger than this 2
52:09 - or 64 is very big you've got 32 itself
52:13 - is Big right 2.31 2.32 they almost go up
52:16 - to 4 billion so you don't need bigger
52:19 - numbers than that but uh
52:21 - in case you need you have long integers
52:23 - same goes to the real numbers also if
52:26 - you are working with smaller decimals or
52:28 - real-time decimals which are not so big
52:31 - you have float which is for decimal
52:34 - numbers so you got minus two or sorry
52:38 - 0.2 or you got something like
52:41 - 0.0003 or all these things so 12.0 also
52:46 - if you just put a point zero it becomes
52:48 - a load and these are all
52:51 - floats and then if you want bigger
52:53 - floats you do have double double is for
52:55 - bigger float
52:59 - bigger floats
53:01 - this again is for 8 bytes and this is
53:05 - the range of double
53:06 - so in C plus plus if you if you did not
53:09 - specify the data type if it is
53:12 - if just a number if it's just an integer
53:15 - it is always going to default to integer
53:18 - only
53:19 - and uh if it is a decimal number it is
53:22 - always going to default to double
53:25 - so what I did here is just added a
53:27 - comment so comments are those statements
53:29 - are not executed by the compiler I'll be
53:32 - showing a demo shortly
53:33 - so for regarding data types these are
53:36 - the data types for storing numbers and
53:38 - for characters you don't need much you
53:41 - would have only two types of character
53:43 - inputs that is you'll get only one
53:45 - character or you get a collection of
53:46 - characters so for one character you have
53:48 - cat but if for one character
53:52 - and for multiple characters you have
53:55 - strings so strings is actually more than
53:57 - just collection of characters there is
54:00 - much more to talk about strings we'll be
54:03 - doing that at a later video
54:05 - so now uh for characters the way we
54:08 - Define characters is by using single
54:11 - quotes so you have
54:13 - if you put anything inside a single code
54:15 - something like a or if you put B over
54:18 - here or exclamation mark anything inside
54:21 - a single code but only one character
54:24 - strictly only one character you cannot
54:26 - put multiple characters inside a single
54:28 - that will cause an error
54:30 - and the fun fact is if you put something
54:33 - like this this will also become even
54:35 - though one is integer if you put it
54:38 - inside a single code it becomes a
54:40 - character the same goes with decimals
54:42 - also you cannot put decimals inside
54:44 - single quotes because it contains more
54:46 - than one character right so even if you
54:48 - put 1.0 something like that one is a
54:51 - character this period is a character and
54:53 - then 0 is also a character so you cannot
54:55 - put more than one character inside
54:57 - string so that will come under string so
55:00 - strings how do we Define like we did
55:03 - here so using double quotes
55:06 - string is just a collection of
55:08 - characters
55:10 - collection
55:11 - collection of characters
55:14 - that's it and it is going to be n plus
55:17 - within double quotes so anything you put
55:18 - inside even if you put even if you don't
55:21 - put anything inside double quotes this
55:23 - is also a string this is called a null
55:25 - string we'll talk about null and all
55:28 - these things at a later stage but for
55:30 - now just for your information purpose
55:32 - I'm just telling about the null string
55:33 - and you do even if you put something
55:36 - like this this is going to be a string
55:37 - it is just a space
55:39 - and even one one character
55:41 - also it is going to be considered
55:43 - assisting so this is also a string and
55:46 - now you can put something like 1.0 or
55:49 - 1.00
55:50 - 2 all these are now considered as
55:52 - strings the way you represent data is
55:54 - very very important if you just take
55:57 - numbers if you just put one it is going
55:59 - to be end if you put 1.0 it is going to
56:02 - be double remember that
56:05 - here if if you put if you do not specify
56:09 - the data type it is going to be
56:10 - defaulted to double only in C plus plus
56:13 - and if you want to floor if you want the
56:15 - data type to be float you can just add
56:17 - an F over there so if you just put F
56:19 - over here it is going to be float the
56:21 - same goes here also if you want this one
56:23 - to be considered as long you just put an
56:25 - L over there so this is considered as
56:28 - long and how do you define a character
56:31 - put like this this is going to be a care
56:34 - and if you put it like this this is
56:38 - going to be a string so see how how how
56:41 - differently it is interpreted if we type
56:45 - the data in a different way so this is
56:47 - the importance of data test here
56:49 - anything we get from the character is
56:52 - categorized only into these data type so
56:54 - we don't have to worry about any other
56:56 - data whatever we type is just going to
56:59 - be a subset of all all of these things
57:03 - now now let us work on some real input
57:06 - we forgot to mention about the comments
57:08 - so let us know well we can actually show
57:11 - the comment over here only so suppose I
57:13 - want this data but this is something for
57:16 - you to understand right so these are not
57:19 - part of C plus plus command these are
57:20 - something I typed right so these don't
57:22 - make any sense in C plus plus
57:25 - but I don't want to delete it because
57:26 - I'll be using it to explain to you guys
57:29 - so how can I do that without and also
57:32 - run this program without actually going
57:34 - into an error I cannot write another
57:36 - another program and use a separate file
57:39 - right I don't want to do that I can but
57:41 - I don't want to do that
57:42 - well for that we have something called
57:45 - comments I need this data but I don't
57:47 - want the computer to execute it so what
57:49 - I do is I'm going to hide this data from
57:52 - the compiler so the way we do that is by
57:55 - using these clients as comments so
57:58 - comments are actually used to uh
58:01 - explain some lines of code and also they
58:04 - are generally used to actually debug the
58:06 - program so if you are developing a big
58:09 - program and you don't want some of the
58:11 - lines to execute and you directly want
58:13 - to see what is the result of two or
58:16 - three lines you can actually comment on
58:18 - the other lines and you can see the
58:19 - result that is going to be very useful
58:21 - when you're testing your program so for
58:23 - that comments are there so there are two
58:25 - types of commands one is the single line
58:27 - comment which I did over here so this is
58:29 - just going to comment on this entire
58:31 - line so whatever I'll write after this
58:34 - pair of forward slashes is considered a
58:37 - comment comment so all these are
58:40 - commented out and then if I need to
58:42 - commit at multiple lines the way I do
58:44 - that is by putting a forward slash and
58:46 - putting a star over there so you can see
58:47 - all these are grayed out now and the
58:50 - thing is it is completely graying out my
58:53 - program so even this thing is grayed out
58:55 - and now if I try to execute I will be
58:57 - getting another it says that this
58:59 - unterminated comment is here that is
59:02 - this one see this one has been started
59:04 - but it is not terminated at any point so
59:06 - I want to terminate my comment over this
59:08 - length because these are these are the
59:10 - lines I don't want the compiler to
59:12 - exhibit right so to terminate I'm just
59:14 - going to do the reverse software I'm
59:15 - going to put a star and then
59:18 - slash so this is actually going to
59:21 - comment out all these lines these lines
59:23 - change my program code these are not
59:25 - going to be executed by the compiler so
59:27 - now I can run my program without any
59:29 - issues and I'm going to get the output
59:32 - so that is the importance of comments we
59:34 - will be commenting out many things at a
59:36 - later stage when we are working with
59:38 - bigger programs comments are very
59:39 - important
59:42 - so now let us write some useful code let
59:47 - us now write a program to add two
59:49 - numbers so it is always wise to actually
59:52 - put a comment on what you are doing and
59:55 - also put some authorization so you can
59:58 - put something like I did it on
60:03 - on it for now I'm just going to write
60:04 - the name of the program what I'm going
60:06 - to do is I am going to write a program
60:07 - for add two numbers it is always
60:10 - advised to put comments before your
60:13 - program code you don't have to put it
60:15 - over there only I am just putting it
60:17 - there you can put it anywhere you like I
60:19 - I even you I can put it inside here also
60:23 - I can put comments anywhere I like now
60:25 - let us write a program to add two
60:27 - numbers so first thing is I need to ask
60:30 - the user to enter because obviously we
60:33 - need to ask the user something generally
60:35 - is going to know what your program
60:37 - Ming so let us say enter
60:40 - the first number
60:41 - simple enter the first
60:44 - number
60:47 - and now
60:49 - how do we uh now we need to create a
60:53 - memory location I told you right we need
60:55 - to create a memory location to actually
60:56 - store our input
60:58 - the way we do that is we need to First
61:00 - specify what kind of data we are going
61:02 - to get what we can because it's a number
61:05 - it is actually going to be
61:08 - um Floats or doubles right we can we can
61:10 - add any number but for Simplicity
61:13 - purpose I'm just going to go with int
61:15 - you can actually go forwards or doubles
61:16 - also uh it is completely up to you I'm
61:19 - just going to go with paint or in this
61:22 - tutorial so I'm just going to type int
61:24 - and then I need to name the location we
61:26 - need to give some meaningful name so
61:28 - this is also known as a variable
61:30 - declaration uh we are just creating a
61:32 - variable to store something so this can
61:35 - be understood as a mathematical
61:38 - function right so we are just going to
61:40 - put x equal to 5 it just means the
61:42 - variable access storing the value 5 but
61:45 - in computer this is what is happening
61:47 - you if you are declaring a variable it
61:50 - is it means that you are actually
61:51 - creating a memory block and then
61:53 - assigning a name to that so it's just
61:56 - like an alias for the memory block so
61:59 - here I'm just going to name it num1 just
62:01 - to keep it simple and here you can I you
62:03 - can do two things you can either specify
62:06 - the value which is going to go inside
62:07 - the memory location or else you can even
62:09 - uh keep that so here since I don't know
62:13 - what is going to go inside this location
62:14 - I'm just going to skip it and enter a
62:16 - semicolon this means that this command
62:18 - is terminated so I'll executing this
62:21 - command the compiler will know that it
62:23 - has to just print a memory location
62:25 - and now how do you get the input it is
62:27 - just the reverse of it you guys should
62:29 - try it if it is C orb it is going to be
62:31 - C in and then if it is this side this is
62:35 - going to be on the opposite side
62:37 - well this is how we take input and then
62:40 - in where do we need to store the input
62:42 - we need to store it in this location so
62:44 - just write num1 and then put a semicolon
62:46 - so we got our input inside number
62:50 - same thing we need to do for the next
62:52 - number also
62:55 - it's going to copy paste that and here
62:57 - instead of first number I'm just going
62:59 - to write second number and then instead
63:02 - of num2 I'm just going to store uh sorry
63:04 - instead of number I'm going to store it
63:05 - in num2 location
63:07 - and now I'm I need the sum of these two
63:10 - numbers right so remember that I can
63:13 - directly put numbers so you can directly
63:15 - show the sum like this so you can write
63:17 - sum is and
63:20 - this one and then what was that num1
63:23 - plus num2 you can directly put like this
63:26 - but this actually makes it little bit
63:28 - confusing and it is always advised to
63:31 - keep your code very very understandable
63:33 - so if somebody is reading your code they
63:36 - should understand what is going on so
63:38 - this is not always a best practice
63:39 - unless you are in into competitive
63:41 - programming you need to consider all
63:43 - memory and all those things but uh we
63:46 - are now learning so it is always advice
63:48 - to use as many variables we want so for
63:51 - storing the sum I'm just going to go
63:53 - with an integer so because if we add two
63:56 - integers you are only going to get an
63:57 - integer right well I'm not talking about
63:59 - the Border cases where you go with very
64:02 - big numbers like 2 power 32 plus 2 power
64:04 - 32 that is obviously going to go out of
64:06 - the range of integers but I'm just
64:09 - talking about normal cases so I'm just
64:11 - going to store it inside this location
64:13 - sum and what it is going to store it is
64:16 - going to store the value of num1 plus
64:18 - num2 and then I am going to invoke the
64:21 - sum over here so remember in the
64:24 - previous video I told that memory
64:25 - locations and numbers can be accessed
64:27 - without this double quotes that is why I
64:30 - put some without double quote and now if
64:32 - I executed
64:33 - here we have our first program of
64:36 - audition this is our first useful
64:37 - program it is not just printing
64:39 - something on the discrete it is actually
64:40 - doing something for us so here I am
64:44 - going to enter the first number it is 12
64:46 - um second number let's say something
64:48 - like 24 and then if I enter it the sum
64:51 - is 36 perfect 12 plus 24 is 36 we got
64:55 - our answer
64:56 - yeah I forgot to mention the way we
64:59 - check size of the data type is by an
65:02 - operator called size of so how we do
65:05 - that we just put size and then put an
65:07 - off
65:08 - and inside the brackets you are going to
65:10 - name your data type you can either put
65:12 - the data type or you can put the data
65:14 - itself so if I just put one over here
65:16 - and let me put an angle so that you
65:19 - don't get
65:19 - that
65:22 - compiler statements so here you are
65:25 - going to get four
65:27 - why because one is an integer as I told
65:29 - you it's just going to be treated as an
65:31 - integer only and if I just put 1.0
65:35 - as I told you it is going to be
65:37 - defaulted to double that is why the size
65:39 - is 8 and now if I put 1.0 f it is going
65:43 - to be plus a float and you will be
65:45 - getting only four bytes so that is how
65:48 - size of works and now if I just put a
65:51 - character it is going to take only one
65:53 - byte so if I just put like this you are
65:56 - going to save one over here and then
65:57 - even for a null character that is I'm
65:59 - not putting any character these are just
66:01 - two
66:03 - codes side by side even if I run this I
66:06 - will be good I'll be getting an error it
66:08 - says empty character constant that
66:09 - cannot be done another thing is if you
66:12 - just put one character in the inside
66:14 - double quotes let's see what happens in
66:16 - single code this written one right so
66:18 - what will happen in the double quote
66:20 - well as she told you this thing is
66:22 - nothing but a collection of characters
66:24 - so maybe it will be the count of the
66:26 - characters right so something like hello
66:29 - if I just put hello then this is
66:32 - actually five characters right h e l l o
66:34 - makes five characters so the side should
66:36 - be five right but you'll be surprised
66:38 - that the size will be six
66:40 - so that is why I told you strings are
66:43 - something more than just collection of
66:45 - characters there is something called a
66:46 - concept of terminating character or a
66:48 - null character we'll be talking about
66:50 - that in the when we are discussing
66:52 - strings so that's all for this video in
66:55 - the next video we'll be talking about
66:56 - strings and how to use them in our
66:59 - program so
67:00 - till then I I would like you to actually
67:03 - meddle around with the code I would like
67:05 - you to do as many errors as possible and
67:08 - try to read these errors the errors are
67:10 - very very important so you just try to
67:13 - do something like this and then compile
67:15 - you know that this is going to result in
67:17 - an error but what is important is this
67:20 - message because every time it is not
67:22 - going to give you a perfect message for
67:23 - General or something if I have something
67:25 - like this if I just forgot the semicolon
67:27 - over here and then put something like uh
67:31 - let's say hi over here and then put a
67:34 - semicolon and if I try to compile it it
67:36 - is going to show an error in this line
67:38 - it says in line number eight it is
67:40 - expected uh it expected a semicolon
67:43 - before c out statement but there is a
67:45 - semicolon statement where is the error
67:48 - it is actually in the previous line I
67:49 - forgot to put the semicolon in this line
67:51 - so that is why you make as many errors
67:54 - as possible and try to understand these
67:56 - lines these are very very important it
67:57 - is going to help you to write better
68:00 - code you you won't find yourself trying
68:02 - to figure out where the error happened
68:05 - in this video we'll be talking about
68:07 - ASCII or American Standard code for
68:13 - information exchange so what is this
68:17 - this is basically a number which is
68:20 - associated with every character let me
68:23 - give you an example the previous video
68:24 - we wrote a program for adding two
68:26 - numbers right so same thing we are going
68:28 - to repeat over here so let's say enter
68:31 - foreign
68:34 - and I'm going to create a memory
68:36 - location and take an input inside that
68:40 - location
68:42 - let's say a right so instead of A1 I'm
68:46 - just going to name it a and same thing
68:48 - is going to happen enter second number
68:55 - okay let me give a space over here so
68:57 - that looks nice and in b
69:02 - c n b and In Sum equal to a plus b and
69:08 - we are going to just say
69:10 - the sum is
69:13 - and the sum right we wrote this program
69:16 - in the previous video right so we you
69:19 - all know what it is going to do it is
69:20 - just going to ask for two numbers we are
69:22 - going to input that and it is going to
69:24 - process those two numbers it's going to
69:26 - add those two numbers and then it's
69:28 - going to store the value inside this
69:30 - memory location that is sum and then
69:32 - here the memory location is invoked and
69:35 - the value inside that memory location is
69:37 - going to be displayed onto the screen
69:39 - here now
69:41 - what if I just change this end to some
69:45 - other data let's say care
69:47 - and here also let us see here
69:51 - now let us run and check this out
69:54 - so here it did not show any error and it
69:58 - is working perfectly so now if I just
70:00 - save one over here
70:02 - enter first number that is 1 and the
70:05 - second number two and now the sum is
70:08 - going to be something different so you
70:09 - might think it's going to throw an error
70:11 - because we are trying to add two
70:13 - characters but as you told you
70:14 - characters are actually a form of
70:18 - integers only computer stores character
70:20 - in form of integers so this addition is
70:24 - completely valid and the value of the
70:27 - sum is going to store which is actually
70:28 - the sum of the ASCII values of those
70:31 - characters so one whose ASCII value of
70:34 - 49 then 2 whole is asking value of 50 so
70:38 - once you press enter you are going to
70:40 - get the sum as 99 that is 49 plus 50
70:44 - that is 99 right that is why I told you
70:47 - that representing data in different
70:49 - forms is very important so if you write
70:52 - one like this it is going to be let me
70:55 - write it separately somewhere in the
70:57 - bottom so if I just type 1 this is an
71:01 - integer and if I I put it like this this
71:04 - is a character so that is why I told you
71:07 - the way you represent data is very
71:09 - important so instead of size that is
71:11 - four bytes and one one byte so that is
71:14 - also there but here this integer is
71:18 - actually processed
71:21 - as one only so it is processed as well
71:24 - and this thing it is processed as 49 so
71:30 - this is the number it is going to
71:31 - process when you just say a character
71:34 - one right so every character in your
71:37 - keyboard has a high speed value so to
71:39 - look at that just go into your favorite
71:41 - browser and check for ask you over there
71:44 - and here you might see many links so
71:48 - just click any of them so they are going
71:50 - to give you a table of ASCII values so
71:53 - this is the ASCII value and this is
71:55 - actually the decimal and this is the
71:57 - hexadecimal representation you don't
71:59 - need to bother over the hexadecimal
72:01 - representation what is important is this
72:04 - decimal representation and the symbol
72:06 - associated with it so you can see the
72:09 - knowledge associated with ASCII value is
72:11 - 0 and there are many other characters so
72:14 - 13 is actually the carriage return that
72:16 - is the enter key and 27 is a Escape key
72:19 - so here you can see 27 is the Escape key
72:21 - so what is important is our numbers and
72:25 - characters so those ASCII ranges are
72:27 - only very important to us we will be
72:29 - using them interchangeably while dealing
72:31 - with data right so mostly data consists
72:34 - of only numbers and characters that is
72:36 - why we need to remember the range of
72:39 - numbers and characters as Q values so
72:42 - here number starts from 48 so here you
72:45 - can see 48 is 0 so it starts from 0 and
72:48 - goes up to 57 that is 9 so this is the
72:51 - range of ASCII values so 48 to 57 that
72:55 - is the range of numbers and capital A
72:58 - starts from 65 and goes up to 90 90 is
73:02 - Captain said likewise small a starts at
73:06 - 97 and then it goes up to 122 so 122 is
73:10 - small Z so these are the ranges so let
73:13 - me write that down here
73:15 - so
73:17 - let me put a comment so this multi-line
73:20 - comment
73:22 - so 0
73:24 - starts at 48
73:27 - and 1 is 49 in likewise
73:31 - right okay I'll put underscore here
73:35 - same way capital A is 65
73:39 - capital B is 66 likewise and small a is
73:45 - 97 small B is 98 and it goes on so these
73:50 - are some of the important aspiranges we
73:53 - will be dealing with this while we are
73:55 - working with the conditions and all
73:57 - those things we will be looking at that
73:59 - in a later video but these are some of
74:01 - the ASCII values which will be
74:03 - using very frequently so it is better
74:07 - that you remember the starting value
74:08 - because the other values you can
74:11 - directly derive from the first value so
74:13 - 0 is 48 capital is 65 and all a is 97 so
74:17 - these are some of the values uh that
74:19 - would be very helpful if you remember
74:21 - these steps so now
74:25 - you know how to predict the output right
74:27 - so let us try with some other characters
74:29 - Also let's just put this as a character
74:31 - only so instead of end I'm just calling
74:33 - it a scare now if I try to build and run
74:36 - this so here it is asking for the first
74:38 - number let's say some random character
74:40 - I'm just putting this
74:43 - question mark and this apostrophe so let
74:47 - us look at the table so question mark As
74:51 - 39 is the apostrophe and 63 is
74:56 - question mark So 63 plus 39 so now if I
75:00 - just put it the sum is f that is
75:03 - over
75:04 - here 102 right so that is how
75:09 - ASCII version just work so they were
75:11 - just like numbers just that the
75:13 - character is associated with a special
75:15 - number and you need to know the number
75:17 - to actually correctly predict the output
75:20 - so sometimes human basis out right so
75:23 - sometimes you may put a character and
75:25 - try to add two character and see absurd
75:27 - answers those are not upset just that
75:30 - your logic is wrong so here if I just
75:33 - put an intent character sometimes this
75:35 - happens so if I just put a hint over
75:37 - here and Cat over here and then try to
75:40 - build and run this so first I'll put one
75:42 - and then put an A so now the output is
75:45 - going to be B Because 65 plus 1 that is
75:48 - 66 and the character value of 66 is B so
75:52 - you can check that from this table
75:54 - so here you can see capital B is 66.
76:00 - right
76:01 - so ask device are just like numbers so
76:04 - you're just going to operate them as you
76:07 - are going to operate on numbers so you
76:09 - can put uh you can add one or you can
76:12 - multiply it so into two that is also
76:16 - possible so this is only character so
76:18 - let's just make character and then once
76:21 - I try to run this
76:23 - here it is 1 and 2 so here the sum is B
76:26 - Because 48 into 2 that is sorry 49 into
76:32 - 2 that is small B right that is 98 so
76:36 - here you can check that out so 40
76:39 - 49 into 2 that is 98 so 98 is B so you
76:43 - can do that you can divide those things
76:45 - in this video we will be looking at
76:48 - conditional statements so what are
76:50 - conditional statements what are
76:51 - conditions basically conditions are
76:54 - those set of rules which Define a
76:56 - particular procedure to be followed so
76:58 - what do I mean by that let's take an
77:00 - example suppose you want to sort out all
77:03 - those files which you created yesterday
77:05 - from the C drive or from the desktop
77:08 - so the way we do that is we take all the
77:11 - files we look at the date when it was
77:13 - created and then if it matches
77:15 - yesterday's date we put that inside
77:17 - separate folder or else you leave it or
77:20 - you put it inside another folder that
77:22 - doesn't matter so our only focus is we
77:24 - are putting those files which were
77:26 - created yesterday into a separate folder
77:29 - so when you're checking whether the date
77:31 - matches or not you are actually
77:33 - performing a conditional operation so
77:35 - that is what conditional operators or
77:37 - conditional statements do so conditional
77:40 - operators work like if something is
77:42 - there and you need follow some procedure
77:45 - or else you need to follow some other
77:47 - procedure which may or may not be
77:49 - defined if it is not defined you need
77:51 - need not do anything if it is defined
77:52 - you need to follow that procedure so it
77:55 - is like if something
77:57 - then you do something so do procedure
78:00 - one suppose and then else what you need
78:04 - to do do is do a procedure
78:08 - to or you can leave it
78:11 - right this does not need to be defined
78:14 - so this is not important what is
78:16 - important is this condition this
78:18 - condition if that something is satisfied
78:21 - then only you need to do procedure one
78:23 - or else you need not do anything or you
78:25 - need to do some other set of statements
78:27 - which are defined so that is how
78:30 - conditional statement work and the same
78:33 - goes with C plus plus also so the way
78:35 - you define condition statement is you
78:37 - put an if and then inside a pair of
78:39 - parenthesis you put a conditional
78:41 - statement
78:42 - and here you have a block so this block
78:47 - is different from this block here I'm
78:50 - writing it so this is if block so this
78:54 - executes only when that condition is
78:57 - satisfied and then if this condition
79:00 - fails in our example suppose some other
79:03 - file came up which was created one year
79:04 - ago so what you need to do you need not
79:07 - do anything or else if you want you can
79:09 - put it inside another block that is up
79:11 - to you so do that as else if that
79:14 - condition fails you have another block
79:16 - you need to follow this particular
79:17 - procedure so this set of statements or
79:20 - this set of rules execute only when this
79:24 - rule is
79:25 - true or this conditional statements
79:28 - evaluate to true or else it follows this
79:31 - else block so the way you define
79:34 - conditions is by using operators called
79:37 - relational operator relational operator
79:39 - is just
79:40 - give the relation between two operands
79:42 - so these are same as the mathematical
79:44 - relations you have a greater than you
79:46 - have a less than you have a greater than
79:48 - or equal to less than or equal to and
79:51 - then you have an is equal to this is is
79:56 - equal to so do not get confused with a
79:59 - single equal to sign we use so by
80:02 - declaring variables I told that in k
80:04 - equal to 10 means a holds the value of
80:06 - 10. so this single equal to operator is
80:10 - known as the assignment operator and
80:13 - this double equal to is the is equal to
80:16 - operator so
80:17 - the difference is when you tell a equal
80:20 - to 10 and a equal to equal to 10 this
80:24 - means that assign the value 10 to 8 so
80:28 - this is what this statement means and
80:30 - this statement means compare a and 10
80:33 - and check its equality
80:36 - so this is what it means so this double
80:40 - equal to means that you you will take
80:42 - the value of a you will take 10 you
80:44 - compare it and if they both are equal
80:47 - then you say it's true or else you you
80:50 - tell that it's false so this single
80:52 - equal to Operator just means that you
80:54 - put this 10 inside this memory location
80:56 - a that's what it means here under Point
80:59 - node is 10 equal to a is an error so
81:04 - here even though it mathematically both
81:07 - the statements are same then equal to a
81:09 - cannot be processed because the computer
81:12 - always wants the left hand side to be
81:14 - Memory location whatever the right hand
81:16 - side is it can be a memory location it
81:18 - can be a constant value it can be
81:19 - anything so whatever it is it has to go
81:22 - into the left hand memory location by
81:25 - using this operator which is the
81:27 - assignment operator and this double
81:29 - equal to operator can work either way so
81:31 - even if you put n equal to equal to a
81:33 - this is the same meaning it takes 10 it
81:36 - takes a value of 8 Compares it and if
81:38 - they are equal it's going going to tell
81:39 - yes what else it's going to tell no so
81:42 - these are the operators and you have
81:44 - another operator this is double equal to
81:46 - which is is equal to and then you have a
81:49 - not equal to not is basically this
81:51 - exclamation mark over here this is not
81:54 - equal to so these are the operators you
81:56 - use to check the conditions so let us
81:59 - look at a quick program let us make some
82:01 - program let's say uh to check whether
82:04 - the person is eligible to let's say
82:07 - drive a vehicle or not so for the legal
82:09 - age for driving Vehicles is 18 years so
82:12 - let's check whether a person is eligible
82:14 - to drive the vehicle around or else
82:17 - put an oath or not whether is an
82:20 - eligible voter or not we can do that so
82:22 - let's start by writing the input
82:25 - statement so
82:27 - first we ask the name enter the name is
82:30 - going to enter the name you know name is
82:33 - going to be a string so string name I
82:35 - don't know the name that's why I'm going
82:36 - to leave it blank and I'm going to take
82:38 - in the name over here so CN name
82:42 - and now I'm going to take the age of
82:45 - that person so let's say uh CR
82:50 - enter okay
82:52 - enter your age
82:56 - or here now I'm going to take the edges
82:59 - here so let us mention that also over
83:02 - here in
83:03 - in years something like that
83:06 - so I'm going to get the age in years
83:08 - number of years is going to be in
83:11 - integer so I'm just going to took an INT
83:14 - age and then I'm going to get the age
83:16 - also good but now I need to check in
83:20 - condition so what is going to be the
83:22 - condition I want to tell that the user
83:25 - can drive the vehicle or put the oat
83:27 - only if it's above 18 years of age so
83:30 - baby do a test you put an if and then
83:32 - inside this pair of brackets you put the
83:35 - condition the conditioners if his age is
83:39 - greater than or equal to 18 or not we
83:42 - are going to check that and then if his
83:46 - age is greater than 18 then you put the
83:49 - statement right let's say you are
83:53 - eligible to Vote or
83:57 - Private Car something like that right
84:00 - this eligible if it's greater than or
84:02 - equal to 8 in his eligible else you can
84:05 - just print
84:09 - sorry
84:11 - okay sorry
84:14 - you are not eligible something like that
84:17 - what we have done we have just taken the
84:20 - name we have taken the age your complete
84:23 - the age and we are checking whether the
84:25 - age is greater than or equal to 18 or
84:27 - not so if he is greater than or equal to
84:29 - 18 or if it's a major you are going to
84:33 - tell that he is eligible to vote or
84:36 - drive a car or any vehicle or else you
84:39 - are going to say that you are not
84:41 - eligible so that's how you do that let's
84:43 - try and execute this program so here
84:46 - let's say enter the name something like
84:47 - John and enter your age 12 so here it
84:51 - says sorry or not eligible let me put a
84:54 - new line after this health statement so
84:57 - that you don't get confused with the
84:58 - compiler's output
85:02 - and here
85:05 - so let's say some other name um
85:07 - uh let's say Harry
85:09 - and uh enter your age he is going to be
85:13 - 21 so here you can see you are eligible
85:15 - to vote or drive a car right so this is
85:18 - a simple program we have written so here
85:21 - you can also do another check right so
85:24 - suppose the person who is using a
85:27 - program is a notify wants to
85:29 - I'll check the validity of your program
85:31 - suppose you want to
85:33 - do something like he wants to put
85:35 - negative integers or something so age is
85:37 - always positive right the way you do
85:39 - that is first you check whether the age
85:41 - is positive or not so the way you do
85:43 - that is if age is greater than
85:46 - zero if it is a positive number then
85:49 - only check it so all these statements go
85:51 - inside this
85:53 - right if the his particular age is legal
85:57 - then only you can check that right if he
86:00 - is providing some negative number you
86:01 - cannot check that so here I'm just going
86:04 - to indent distance so that looks nice
86:08 - uh you also try to indent your program
86:11 - so that you can understand what you are
86:13 - writing so this if is this uh from this
86:16 - block to this block this is another if
86:18 - this is else inside this if block so all
86:21 - these statements are inside this
86:22 - statement or else
86:24 - you see
86:27 - um
86:28 - Shield
86:31 - please enter a valid age right so it is
86:35 - not valid minus Pi is not a valid age
86:38 - right so you take only positive integers
86:41 - as ages and you are checking whether
86:43 - that age is 18 or not so if it is equal
86:46 - to or greater than 18 your your saying
86:49 - that you are eligible to watch a driving
86:51 - card or else you are telling that you
86:53 - are not eligible so here now you can
86:55 - execute and try out this program it is
86:58 - better to execute after every uh
87:00 - condition you write right because when
87:02 - you are writing a bigger program it is
87:04 - it will be a good practice to actually
87:06 - check when you are putting a condition
87:07 - so that validates your program even more
87:10 - faster and you will be able to easily
87:13 - debug your program so here let's say
87:15 - enter the name let's think of some other
87:17 - name let's say Jack
87:18 - and enter the age let's try the hunting
87:21 - not you know let's type minus 120 and
87:23 - enter so here it says please enter a
87:26 - validate
87:27 - so you can have many checks like that so
87:30 - you can have also maybe he's going to
87:33 - enter some weird is a thousand years or
87:35 - two thousand years you can check that
87:37 - also the age should be less than 1000 or
87:40 - less than two thousand something like
87:42 - that for that we are going to need
87:44 - another set of operators which I will be
87:46 - talking in the next video but you can do
87:48 - that inside this if also so I can check
87:50 - over here also if age is less than
87:53 - let's say what's the maximum 800 right
87:56 - so let's say one or five or one or two
87:58 - maximum one or two so if it is less than
88:01 - one or two then only you need to execute
88:03 - these statements
88:05 - so Ctrl X and it goes inside this
88:11 - and let me intend this properly
88:18 - right so if H is pleasure Mark to this
88:22 - or else you are again going to say the
88:24 - same thing so just Ctrl C and then over
88:27 - here inside this if you're putting is
88:29 - this else
88:30 - so that is how simple conditional
88:34 - statements are you are just going to
88:36 - play with conditions so here I am
88:37 - checking if it is a positive number and
88:39 - here I am checking whether it's too big
88:41 - if it is too big I am telling that
88:43 - please enter a valid age and if it's too
88:45 - small also I'm telling that please enter
88:47 - valid age and here if it lies between
88:51 - the range of 1 to 101 because 102 is the
88:56 - maximum wage so I put less than 102
88:58 - which goes up to 101 and greater than
89:00 - zero starts from one so from 1 to 101
89:03 - it's going to check and if that age is
89:06 - greater than or equal to 18 it's it's
89:08 - going to say that you are eligible to
89:09 - vote or else it's going to say if you
89:12 - are not eligible so that is how you
89:14 - perform a conditional check so this
89:17 - statements which are written inside and
89:19 - if so I have written a if inside if so
89:22 - this if is the main F inside this I have
89:24 - written this and inside this I have
89:26 - written this if else statement so this
89:29 - concept is actually known as us let me
89:32 - write somewhere over here okay on the
89:34 - top I'll write this is known as Mr if so
89:37 - nested conditional statements
89:41 - so this is what this is called as now if
89:45 - I enter a bigger value than a hundred
89:47 - and one let's say 105 or 200 so that
89:51 - will say you are not uh you're not
89:53 - entering a valid age and even if I enter
89:56 - some negative numbers also your it's
89:58 - going to tell that you're not entering a
90:00 - value range so that is how you play with
90:02 - conditional statements you try writing a
90:05 - program which will segregate whether a
90:07 - number is order even or not I know this
90:09 - is a very simple program you will find
90:10 - it in the internet but just try it on
90:12 - your own so let me give you a hint and
90:15 - even number
90:18 - um then divided by 2
90:23 - gives remainder 0. and
90:27 - that's it we'll need another condition
90:29 - so this is the only condition you're
90:31 - going to give you are going to take a
90:32 - number and then you are going to
90:34 - determine whether it's an even number on
90:36 - or an odd number and this is the hint so
90:39 - if an even number is divided by 2 it it
90:41 - will given remainder as 0 and then if it
90:44 - is an odd number it's going to be some
90:46 - other remainder remainder is going to be
90:48 - one so you can try that you can try
90:50 - writing that program in this video we
90:52 - will be talking about logical operators
90:54 - in the previous video
90:57 - we wrote a program to validate the age
90:59 - the user enters right so we are giving a
91:03 - condition like if it's check whether
91:05 - it's a positive number or not and if
91:08 - it's a positive number we were again
91:09 - checking whether it's too great or not
91:11 - if it was too great uh we were telling
91:14 - something like your age is not valid
91:18 - and if it was okay if it was in a Range
91:22 - then we were checking whether he's 18
91:25 - years or younger we were considering
91:27 - that the age was valid
91:29 - or else we are telling that it was a
91:31 - North valid age right
91:34 - Here If You observe this condition and
91:37 - this condition go together so if a
91:40 - number is positive and if a number is
91:42 - too great then it's not a valid number
91:45 - or if you look at the larger scope here
91:48 - you can combine these three two
91:50 - statements if a number is positive and
91:53 - it's too great or if a number is
91:56 - negative then it's not validate or else
92:00 - it's going to be valid so the way you
92:03 - group these conditions are by using
92:05 - logical operators these are just like
92:08 - the cut connecting words are used in the
92:10 - English statement so here if I talk
92:13 - about the condition when the age is not
92:16 - going to be valid let me write it down
92:18 - here and number is a valid age or a
92:21 - number is not a valid age if it is
92:24 - positive and if it is too great
92:28 - or the number is negative so this was
92:33 - the condition right so if a number is
92:35 - positive and too great so these two
92:38 - conditions go together or
92:41 - the number is negative then
92:45 - the age is not valid so this was the
92:47 - condition if you write it down in this
92:50 - manner it is much easier to write it
92:52 - down than these group of Master
92:55 - different else statements
92:57 - so the way to achieve these things to
93:00 - validate these conditions and to join
93:03 - the result of these two these results
93:05 - are joined right you need to check
93:07 - whether the number is positive and
93:10 - whether it's too great and you need to
93:12 - combine these two results and you are
93:14 - going to get a result also you are going
93:16 - to check whether the number is negative
93:17 - or not what if it's not positive you
93:20 - need to check whether it's negative or
93:21 - not and then you are going to check
93:23 - these two conditions if one of them is
93:25 - true then you are going to say it is not
93:28 - valid so this is basically the function
93:31 - of logical operators so there are three
93:34 - logical operators in C plus plus or in
93:37 - any language these are same as The
93:39 - Logical gates in physics you might have
93:41 - come across it so these are and you have
93:45 - an r and a not so not symbol you might
93:48 - have guessed it while I was talking
93:50 - about the relational operators I was
93:51 - talking about this operator right so if
93:53 - this one stands for not equal to so this
93:56 - exclamation stands for or not so this is
93:59 - not and for R we are going to put two
94:01 - vertical bars which are which you will
94:04 - see on on top of the enter key
94:07 - and here for and you have two ampersands
94:10 - the very important point to note here is
94:12 - that you need to use two Ampersand
94:15 - symbols for and two vertical bars for R
94:18 - because a single version also exists so
94:22 - in C plus plus there is also an uh
94:25 - operator which is this one which is a
94:28 - single and a single or
94:30 - so these are actually bitwise operators
94:32 - we need to dig deep into these operators
94:35 - because they deal with a binary
94:38 - representation of the data but just for
94:40 - your information I'm telling these
94:42 - things we will talk about that in a
94:44 - later video for now we don't need these
94:47 - bitwise operators or bit manipulators we
94:49 - are only going to need the logical
94:51 - operators which are just going to tell
94:52 - the relation between two conditions so
94:55 - and this basically if two or any kind
94:59 - any number of condition if all are true
95:01 - then the result is true so and this
95:03 - basically uh if all the conditions are
95:06 - true
95:08 - then it's going to be true
95:11 - and for R you have
95:15 - if any one of the condition is true
95:18 - right if any one of the condition is
95:21 - true then the result is going to be true
95:24 - that is the specialty of all so you if
95:27 - you have any number of conditions even
95:29 - if one condition validates should true
95:32 - then the result is going to be true and
95:35 - for and
95:36 - if n number of conditions are there all
95:39 - the number of conditions should be
95:40 - satisfied then only you are going to get
95:42 - the true value or else you are going to
95:44 - get false so
95:46 - this is the basically the and and our
95:49 - operator not is just it's going to turn
95:51 - the value so not is it is going to uh
95:55 - change
95:56 - true to false and vice versa so the
96:00 - function of not is just to change true
96:02 - to false and false to true or text n
96:06 - number of conditions and if any one of
96:09 - the condition is true then the result is
96:11 - true and for and it is going to check
96:14 - all n number of conditions and if any
96:16 - one of them is false then the result is
96:18 - false every condition should be true
96:21 - then only and is going to give you a
96:23 - true
96:24 - so that is basically The Logical
96:26 - operators so here another thing is that
96:29 - if you are writing a logical operator
96:30 - let's say some condition one and
96:33 - condition two that's how you represent
96:36 - and for all it is the same thing if
96:38 - condition 1
96:40 - or condition 2 and not basically doesn't
96:44 - need two conditions just going to
96:46 - reverse the condition so first you put
96:47 - an exclamation mark and you put the
96:49 - condition so here if you are using an
96:51 - and operator if this condition evaluates
96:54 - to true this first condition then only
96:57 - it's going to check the second condition
96:58 - so even if the second condition is true
97:01 - who is the first condition is false it
97:03 - is not going to check the second
97:04 - condition at all it is not going to
97:07 - perform anything over here
97:09 - so the thing with r is it is going to
97:12 - check every every condition and here if
97:15 - this one is true it is not going to
97:17 - check other condition so in the
97:19 - condition for R is that if any one of
97:21 - them is true right so you if it forms
97:24 - any one of the condition is true then
97:26 - it's going to evaluate it as true and
97:28 - this whole condition becomes a true
97:30 - condition so this part is going to be
97:32 - executed that is with the all so those
97:34 - are the condition those are The Logical
97:36 - operators let's take a quick example we
97:39 - are going to deal with the same example
97:41 - we took yesterday so here I'm directly
97:44 - going to take the 8 so enter your age
97:48 - and I'm going to take that inside a
97:51 - variable so end 8C in H
97:54 - and here I'm going to validate the age
97:57 - so if
97:59 - if age is greater than 0 and
98:04 - H is greater than 102 right so this was
98:08 - the condition we gave yesterday or 101
98:10 - something like that so let's stick with
98:12 - 102 now and if this condition if this
98:16 - age is greater than 0 and the H is
98:19 - greater than 1 0 2 so this condition is
98:21 - basically not required because if it is
98:23 - greater than 0 then only it's going to
98:25 - be greater than 102 right so I'm just
98:27 - going to take out this particular
98:28 - condition
98:29 - so if the age is greater than 102 or if
98:35 - the age is less than zero right so if an
98:38 - age is greater than 100 something like
98:41 - 101 102 something like that or if the
98:45 - age is less than zero what we are going
98:47 - to say
98:49 - you have not entered
98:52 - uh a valid age right
98:56 - and
98:58 - or else we are just going to perform the
99:01 - check so if age is greater than or equal
99:04 - to 18
99:05 - which is ah let me tell you over here I
99:08 - forgot yesterday we were talking about
99:10 - the block right so here if you have only
99:14 - one statement execute then you know need
99:17 - not use a block so here I have only one
99:19 - statement X good this is going to be the
99:21 - same thing as uh this one
99:24 - here if I put a block inside this and
99:26 - then put the C out statement it's going
99:28 - to be the same thing but block is
99:30 - totally used to hold two or more
99:32 - statements if I am going to use only one
99:35 - statement I don't need a block so I can
99:37 - just directly put the statement beside
99:40 - the if conditioner itself so this is
99:42 - also valid but if you write any other
99:45 - statement over here so let's say
99:46 - statement two if I write something over
99:49 - here this is actually not considered a
99:52 - part of this if statement unless and
99:54 - until I have a block something like this
99:56 - so here inside this block whatever right
99:58 - inside this block all the statements
100:01 - belong to this else statement but here
100:04 - since I have not put in Block over here
100:06 - this particular statements goes to the
100:08 - if this statement stays to the else part
100:11 - only unless and until I specify another
100:14 - block and mention these two things over
100:16 - here so if I put these two things over
100:18 - here now these two have become a part of
100:20 - this if statement and this whole if
100:23 - statement becomes a part of the else
100:24 - statement and here I have put only one
100:27 - statement that is why I don't need a
100:29 - block
100:30 - and here if an age is greater than or
100:33 - equal to 18 I am going to say that
100:37 - you are eligible so whatever for
100:41 - eligible to watch something like that
100:45 - or else we are going to see
100:49 - uh
100:52 - sorry
100:55 - you are not eligible something
100:59 - so this is the program we have written
101:02 - this is going to do the same thing which
101:05 - we had done in the previous video but
101:07 - see how small the program now looks so
101:10 - if you consider taking out these braces
101:13 - then it's going to look much much
101:15 - smaller because uh you have only one
101:17 - statement execute inside the if block
101:19 - but
101:21 - because it many people tend to forget
101:23 - putting these braces for multiple
101:25 - statements also it is always advisable
101:27 - to put the braces for even one condition
101:29 - but generally I don't do that I just if
101:32 - there's only one condition I put it
101:34 - beside the condition itself so if one
101:36 - statement execute I put it beside the
101:38 - condition itself it's up to you either
101:40 - way it's going to work
101:42 - so the
101:43 - here now let us execute it we are going
101:46 - to get the same output so here it's
101:48 - going to ask for the age so enter your
101:50 - age let's say 12 so here it says sorry
101:54 - you are not eligible
101:57 - and that's it we have created the same
102:01 - program but here it's a much smaller
102:03 - program than the previous program in
102:06 - this video we'll be talking about switch
102:08 - case statements so before talking about
102:10 - the switch case statement I would like
102:12 - to talk about the if else if else ladder
102:15 - so that is nothing very simple
102:16 - implementation of the if else ladder
102:19 - itself so let me give an example suppose
102:21 - you have a little commit it down here
102:23 - you have a question like the McQ kind of
102:27 - thing so you have a question and you
102:29 - have four options uh like this and you
102:34 - have a choice so I just say you your
102:36 - choice sorry your choice and here the
102:39 - user can enter whatever number he wants
102:42 - and you can check whether his answer is
102:45 - correct or not so you just check whether
102:47 - the choice whether the choice is one or
102:50 - else you again go for another check you
102:53 - check whether the choice is who or not
102:57 - right and if it is not two you go and
103:00 - check for another set of conditions so
103:03 - if Choi is equal to 3
103:05 - you have something to do uh or else
103:08 - again you check whether
103:11 - his choice is four or not so if Chi is
103:14 - equal to 4
103:16 - and if none of these are two then you
103:19 - say uh that it is an invalid option so
103:23 - you do something like this right so this
103:25 - is
103:26 - the kind of implementation where you are
103:28 - not using the if else if else ladder so
103:32 - here you are using the if else ladder
103:36 - so how do I make and make it as an if
103:39 - else if else ladder so what is else if
103:43 - basically it is the same implementation
103:45 - just that it is using a rule that the
103:49 - else statement always goes with the
103:51 - inner Motif so let me write it down here
103:53 - it's a very important rule so the rule
103:56 - is
103:57 - always
103:59 - the else statement
104:03 - goes with
104:05 - the innermost if
104:07 - so this is a rule you need to remember
104:10 - always this is always true that the L
104:13 - statement goes with the innermost F so
104:16 - if if you write some a program like if
104:18 - and then you have a else for that sorry
104:22 - else for that and you have and if you
104:26 - have another if and you have an else so
104:28 - the hierarchy of this particular program
104:30 - is derision if condition and for that
104:34 - you have an else condition so these
104:36 - three statements belong to this else
104:38 - condition so let me write it down neatly
104:41 - so if you have an if condition like this
104:43 - and suppose this phase the else is there
104:47 - right so inside this else actually so
104:50 - even if you write something like if if
104:52 - and else so what is going to happen is
104:55 - these three statements go with this L
104:57 - statement and this is if and this else
105:00 - are what are the actual if and else the
105:03 - actual contrary part that is this one so
105:05 - if Choice equal to 1 or else you going
105:08 - to perform any of these operations right
105:10 - or else you are not even going to look
105:11 - at them if charge equal to 1 you won't
105:13 - consider these options
105:15 - so here again so Here If You observe
105:19 - there are two ifs right so this if is
105:21 - evaluated so this L this LS always will
105:25 - go with the inner Motif so what is the
105:27 - innermost step right so here if I have a
105:30 - condition 1 and here if I have condition
105:33 - 2 condition 1 is evaluated and condition
105:37 - 2 is also evaluated and only if the
105:40 - condition 2 fails so if this fails then
105:44 - this else is activated
105:45 - right so this else always goes with this
105:49 - particular if not the condition 2 1 but
105:52 - always with the innermost step so this
105:55 - is your rule that is what is used while
105:58 - uh using the if lcfl slider the thing
106:02 - you do is you don't actually put the
106:04 - braces but you just put a word like else
106:07 - if so that has the same meaning instead
106:09 - of this braces you are just minimizing
106:11 - it so it increases the readability so
106:14 - here if I put else if and here also the
106:18 - same thing
106:19 - so this if I just remove this and this
106:24 - is goes here and you have final Edge so
106:27 - you see I did not add any word just that
106:31 - the same program the same braces I just
106:34 - removed the braces so now the program is
106:36 - much more readable right so if Choice
106:38 - equal to 1 or else if charge equal to 2
106:40 - or else if charge is equal to 3 or will
106:42 - shift charge equal to 4 or else if none
106:45 - of these are true it's an invalid option
106:46 - that is the use of L shift
106:48 - so now let us talk about the switch case
106:51 - statement
106:52 - so switch key statements are not always
106:55 - used for all kinds of comparison they
106:58 - are actually a kind of alternative for
107:01 - the conditional statements but they are
107:04 - always not used switch cases are used
107:06 - only when we need to compare the
107:09 - equality of two operands so let me write
107:12 - it on here which cases okay sorry
107:19 - switch cases only compare
107:23 - equality
107:24 - so you cannot compare whether something
107:27 - is greater than or less than equal to or
107:30 - something like that you can just compare
107:31 - whether they are equal to or not equal
107:33 - to so the way you define switch case
107:36 - statement is for same thing I am going
107:38 - to do so let us write a complete program
107:40 - we will understand like that so let me
107:42 - put this here
107:43 - um
107:46 - so let us ask by asking something
107:49 - so
107:51 - see out
107:52 - or not
107:55 - you can add any kind of input for of
107:59 - your choice so just I'm just saying
108:02 - enter your choice and I'm going to uh
108:05 - put my choices
108:07 - one down the other so I'll start with
108:10 - number one
108:12 - and again another one so let's say two
108:16 - and you have three and you have four and
108:20 - you have new line
108:22 - and here I'll just put
108:25 - enter your choice
108:28 - so let me give another new line so that
108:30 - we can differentiate between our choice
108:31 - and the question
108:33 - so now our choice is going to be an end
108:35 - so in choice and see how sorry see in
108:40 - choice
108:42 - so I got a chance now
108:45 - in the previous case how we did that we
108:47 - just checked whether the choice is one
108:49 - or two or three you can do that actually
108:51 - if else if else if else if and else so
108:54 - Suppose there are 10 conditions you have
108:56 - nine L shapes and one if and then you
108:59 - have an else part where it is none of
109:02 - the choices so that's how it works in
109:04 - case of switch case it becomes much more
109:06 - easier so the way you do that is you
109:08 - just switch
109:10 - sorry spelling of songs which you put
109:13 - your variable in there so what is your
109:14 - variable in its choice right so sweet
109:16 - choice you have a brace and here you are
109:19 - just going to Define your cases so you
109:21 - have a case and then this is just like
109:24 - comparing
109:25 - charge equal to some number so I just
109:29 - say short case one and then you need to
109:31 - do something so let's just print uh
109:35 - you chose one something like that
109:38 - and then the most important thing in
109:41 - switch case is that you need to do
109:43 - something called break so we'll talk
109:45 - about this keyword this break is a
109:48 - keyword we'll talk about that in the
109:50 - next video but for now you just remember
109:52 - after
109:54 - every case after performing every
109:57 - statement for a case you need to break
110:00 - out of that case I generally do that
110:03 - without the basis but you can even put a
110:05 - brace over here so this is also correct
110:08 - but I generally don't use a brace it's
110:11 - okay if even if you don't
110:13 - so this is the same thing we are going
110:15 - to do for every case so case one case
110:17 - two case three case four that's all
110:20 - right so we have only four choices and
110:22 - then uh let me first do that afterwards
110:25 - we'll look at the other condition so you
110:28 - have you chose two you chose three you
110:30 - chose four now let's suppose you did not
110:33 - choose any or not any one of them
110:36 - now what is going to happen is
110:38 - you are going to use something called
110:40 - the default case so the way you do like
110:43 - this you put a default and then you just
110:46 - print
110:48 - um the invalid whatever the exception
110:51 - you wanted to print so invalid Choice
110:53 - something like that
110:55 - so that is how you use switch case it is
110:58 - very easy to read and this is mostly
111:00 - used in case of such menu based program
111:03 - so you have menus or you want to choose
111:05 - something or something like that so
111:08 - generally we use which cases because
111:10 - they are much easier to implement than
111:12 - the if well so you need to write if else
111:15 - again and again and again so this one is
111:17 - much more easier than writing the if
111:19 - else if else ladder so you can even
111:22 - compare strings you can compare
111:24 - characters so characters are nothing but
111:26 - integers
111:27 - and you can compare Boolean values also
111:32 - you cannot compare something relational
111:35 - right so you cannot compare whether it's
111:37 - some in some range or not if you want to
111:39 - compare that you need to go with the efl
111:41 - statement or else which case is going to
111:44 - work for you so let us quickly execute
111:47 - this program so F9
111:49 - so here it's asking enter your choice
111:52 - let me just put 2 and enter so here it
111:55 - says you chose to
111:56 - so let us now look at what will happen
112:00 - if I just remove this break so let me
112:02 - just remove these three bricks
112:09 - right now once I try to execute it just
112:14 - see what happens
112:17 - now it's again asking for my choice now
112:19 - if I enter something like let's have one
112:22 - what it should print it should print you
112:24 - choose one right it was working in the
112:26 - previous time so now if I just put enter
112:29 - it says you chose one you chose two you
112:32 - chose three you chose four why did that
112:34 - happen because of the break statement so
112:37 - now if I don't have the break statement
112:40 - what is going to happen is it is going
112:42 - to evaluate from this order only it is
112:44 - going to from top to bottom so now if
112:46 - first it takes the first case and then
112:49 - if this phase it goes to the second one
112:51 - if this case it goes to the third one
112:53 - and whenever it finds a match it is just
112:56 - going to drop down just like that so the
112:59 - break prevents the drop down if you
113:01 - don't have a break it is going to fit
113:03 - everything in that order so if I just
113:06 - remove this break also and suppose I
113:08 - tried to execute this again so now here
113:11 - if I uh put some case like let's say
113:15 - some arbitrary number so three so here
113:17 - here if I press 3 now observe that there
113:20 - is no break right so it is going to go
113:22 - from 3 4 and invalid charge there's no
113:25 - break in between so it's just going to
113:27 - drop down to the whole switch statement
113:29 - so just press enter it's going to say
113:32 - you chose three you chose four and then
113:34 - invalid choice so that is why you need
113:37 - to put the break statement so that's all
113:39 - for the switch case in this video we'll
113:41 - be looking at Loops so what are Loops
113:44 - let's take an example
113:45 - so here I have sample program uh this
113:49 - does nothing but just taking name and
113:50 - age of a person and then print it onto
113:52 - the console so what if you ask you to
113:55 - take the date of 10 people so what you
113:58 - will do is you either execute it 10
114:00 - times or you just copy the whole thing
114:03 - and then paste it 10 times and just
114:06 - change the name like the name one name
114:08 - to name three and so on so that those
114:10 - are two ways so what happens when the
114:14 - user decides how many number of times
114:16 - you need to ask him so what if in the
114:19 - runtime I am the user and I and I tell
114:23 - you that I want to store the data of
114:25 - let's say 100 people and you just wrote
114:28 - the program for 10 people so at that
114:30 - time your program fails right so to
114:33 - counter such type of situations and the
114:35 - counter such redundant code so you are
114:37 - not doing anything practically
114:40 - useful right you're just copying and
114:42 - pasting the whole code again and again
114:44 - so to counter those type of limitations
114:47 - we have something called Loops so today
114:49 - we are going to look at for loops
114:53 - so for loops work like a counter based
114:57 - Loop so you have a counter you have
114:59 - starting value and then you have an
115:01 - ending value so the loop goes from the
115:03 - starting value to the ending value
115:04 - that's all for Loop works so the syntax
115:06 - is you write for and then you have a
115:08 - starting value of a counter and then you
115:11 - put a semicolon
115:13 - and
115:14 - in between you put a condition so this
115:17 - condition is actually the loop condition
115:20 - so what happens is the counter is
115:24 - actually checked with a condition before
115:26 - going ahead so for every time the
115:29 - counter value is checked is compared
115:32 - with some value so that it stays true so
115:36 - this condition should straight through
115:38 - for the whole Loop to execute if it
115:40 - fails the loop is going to break and
115:42 - then the control goes over to the next
115:44 - statement which is also of the loop so
115:46 - for the loop to execute this condition
115:48 - it needs to be true and the way you grow
115:51 - this starting energy you cannot stay
115:54 - over there right so if you just put the
115:56 - starting condition in the loop this is
115:58 - also a for Loop only but what happens is
116:00 - there is no growth condition right so
116:03 - the starting value stays the same and
116:04 - this condition also is always true so
116:07 - this Loop will be going on forever so
116:10 - that type of loop is called an infinite
116:12 - Loop so the easiest way to create an
116:14 - infinite Loop is you just put two
116:16 - semicolons this becomes an infinite Loop
116:18 - so because there is no starting value
116:20 - there is no condition so this becomes
116:22 - any value what you do is you just Define
116:24 - some value over here
116:27 - so this makes it as an infinite Loop so
116:30 - infinite Loops are bad you don't want
116:33 - your program to
116:35 - keep executing the same set of
116:37 - statements again and again and again the
116:39 - user gets bored right so you want to end
116:41 - it after a certain number of times
116:44 - so what you do is you put a counter and
116:47 - then you put a condition and you put an
116:50 - increment value so you increment the
116:52 - counter or you you basically
116:55 - increase the value of the counter so
116:57 - that at some point this condition
116:59 - becomes false and the loop breaks so
117:02 - that's what you are going to do so let
117:04 - me write a small for Loop over here so
117:06 - what we're going to do is fall and then
117:08 - for the counter variable I'm going to
117:10 - initialize it inside this so there is
117:13 - something called scope so what happens
117:16 - is I can even do it like this also I can
117:18 - put an i over here and I put I equal to
117:20 - 0 something like that
117:22 - that also works but
117:25 - what happens is this particular I will
117:28 - be used in the whole program I mean in
117:30 - the whole scope of the main so we'll
117:33 - talk about scope in a separate video for
117:35 - now
117:36 - it is best to use counters inside the
117:40 - loops itself because once the loop end
117:42 - the counter gets out of the scope and it
117:44 - is deleted automatically from the memory
117:46 - so it's best to use counters as a local
117:49 - variable we'll talk about what are local
117:52 - variables Global variables when you are
117:54 - talking about scope we'll definitely do
117:55 - that in in another video so for now we
117:58 - are just going to write for I equal to 0
118:00 - so that is the starting value and I want
118:03 - to execute it 10 times right so for how
118:06 - for 10 times I am going to check so let
118:09 - me start from one that becomes easier so
118:11 - many times you will be starting your
118:13 - your counter from zero there's a reason
118:16 - for that that you will understand when
118:18 - we are dealing with arrays or something
118:21 - generally computers counting starts from
118:23 - zero so
118:25 - for now we'll start from one and then
118:27 - suppose we want to go till 10. so when
118:31 - will the condition fail when we go for a
118:34 - number we are growing this number right
118:36 - so let me not write the condition right
118:38 - now I'll just put the growth rate so I
118:40 - equal to 1 so I will just do an i plus
118:43 - plus I talked about this increment
118:45 - operator right so what this does is it
118:47 - just increments the value of I from by
118:51 - one unit so if it is 1 it becomes 2 and
118:54 - then it becomes 3 and so on so now this
118:57 - I will go on increment it will go till
118:59 - the range of uh the integer that is sum
119:02 - 2 power 32 something like that and then
119:04 - it again Cycles back it again goes to
119:07 - minus two per something so this Loop
119:10 - won't end at all because there's no
119:12 - ending condition for this so to end this
119:15 - loop I want to execute it 10 times so
119:17 - that condition will fail only if I
119:20 - becomes greater than 10 so
119:22 - till the value of I is less than or
119:26 - equal to 10 execute the slope once it is
119:29 - greater just break out of it so
119:31 - here you put a brace so this braces as I
119:34 - told you signify a block of commands so
119:38 - this block represents the for Block
119:40 - inside just whatever you write is going
119:42 - to be executed these many number of
119:44 - times it depends on this condition in
119:46 - this set of conditions
119:48 - so here instead of writing all this I'm
119:50 - just going to put the number itself so
119:52 - let's just put an i over there because
119:54 - uh you don't want the whole set of
119:57 - statements getting confused so let's
119:59 - just put I over here and then I'll just
120:01 - put a new line so endl and a semicolon
120:04 - so let's now execute this F9 so here if
120:07 - you see you have all the numbers from 1
120:10 - to 10.
120:12 - so that is because of this so what if I
120:14 - put less than 10
120:16 - less than 10 is when it goes to 10 it's
120:18 - going to break right so now you know the
120:21 - output it's going to come till nine so
120:22 - F9 so here you have numbers from 1 to 9.
120:27 - um
120:28 - what happens if I remove this condition
120:31 - as I told you you will be going into an
120:33 - infinite Loop so what it feels like it
120:35 - it feels like something like this so you
120:37 - can see it's just going on increasing it
120:39 - went to four thousand five thousand six
120:41 - thousand it won't stop it's just going
120:43 - on just printing the numbers just
120:46 - because I don't have a stopping
120:48 - condition it doesn't know where to stop
120:49 - it's just going on going on it goes up
120:51 - to that whatever that value is it's 2 go
120:54 - into 10 power 9 or something and then
120:56 - it's eventually going to cycle back and
120:59 - this process will continue it's we're
121:00 - never going to stop so to stop such a
121:03 - loop you can either directly close this
121:05 - or press Ctrl C it's going to stop so
121:07 - those are used for Loop and C plus plus
121:09 - uh there are other type of usages as
121:13 - well so
121:14 - instead of putting the counter here as I
121:17 - told you you can put it over here so if
121:18 - entire equal to 0 and then here I will
121:21 - just put a semicolon and then I'll just
121:24 - put the condition over here and then I
121:26 - plus plus so what this will do is it is
121:28 - automatically understood that I am using
121:30 - is my counter and once it goes up to 10
121:32 - it's going to stop so it's just going to
121:34 - give me the same output it's going to
121:36 - give me 1 to 10.
121:38 - and what if I you cannot remove this
121:42 - condition because once you remove this
121:44 - condition uh the loop is going to be
121:46 - infinite and one other thing you can do
121:48 - is you can
121:50 - put this thing inside here so this also
121:55 - does the same thing only thing is that
121:57 - this statement becomes this uh statement
122:00 - of the loop these statements are
122:01 - executed
122:03 - in an order so what happens is first
122:05 - this statement is executed let me number
122:07 - them down so first this statement is
122:09 - executed then this statement is executed
122:13 - so all these statements whatever is
122:15 - inside the block then this statement is
122:17 - executed let me number it as 3 and then
122:20 - it is checked over here so this check is
122:24 - performed at the last so once if it is
122:26 - true it is going to again go there and
122:28 - again this condition this statement will
122:31 - execute then this check will happen and
122:33 - then again if it is true this Loop will
122:35 - continue that's how it goes
122:38 - another thing you can do is you can
122:40 - actually omit the condition also there
122:42 - is a way to actually stop the look
122:43 - without the condition also what you do
122:45 - is you just put two blank semicolons and
122:49 - then to stop
122:51 - I will write if that particular eye is
122:55 - greater than or equal to 10 so or sorry
122:58 - greater than 10 because once it is
123:01 - greater than 10 I mean once the I goes
123:03 - to the value of 11 the look should stop
123:05 - right so what you do is you just break
123:07 - remember this break we use in switch
123:10 - case statements that's the same break
123:12 - this is actually a jump statement so
123:14 - this is how it is used for breaking out
123:16 - of an infinite Loop for braiding
123:18 - breaking out of a loop at a particular
123:20 - point of time so we will be talking
123:22 - about these jump statements in our next
123:25 - video
123:27 - so this is how break works you can you
123:29 - also have continue so that we will be
123:32 - talking about in the next video and now
123:34 - I will just increment the value so here
123:37 - this is the same exact Loop so if you
123:39 - just execute it you will be getting the
123:41 - output so here you have one to ten
123:43 - numbers so here I see because I have 0
123:46 - over here so I'll just change it to 1
123:48 - here you have numbers from 1 to 11. now
123:51 - why did this happen that's because I
123:54 - checked after printing this so that's a
123:56 - logical mistake that's not the fault of
123:58 - the loop I just forgot to put it before
124:01 - printing it so once it goes to the value
124:04 - of 11 it should break right so if it is
124:06 - less than uh sorry if it is less than or
124:10 - equal to 10 then only I should print so
124:12 - first I need to check if it is not
124:14 - greater than 10 if it is less than or
124:16 - equal to 10 then only I need to print so
124:18 - this Loop will execute expected in this
124:21 - video we'll be looking at while loops
124:23 - and also we'll be learning how to work
124:26 - on patterns so by patterns I mean we'll
124:29 - be printing some text in some fancy way
124:32 - like we'll be making shapes like squares
124:34 - or rectangles so we will be taking those
124:36 - shapes from the internet and we'll try
124:38 - to replicate the same onto our console
124:40 - so first let's look at while Loops in
124:42 - the previous video we saw four Loops
124:45 - right so the only difference between for
124:47 - Loop and while loop is the condition so
124:50 - in while loop the condition is must in
124:52 - for Loop if you skip the condition it
124:54 - goes as an infinite Loop but in while
124:57 - loop you cannot skip the condition the
124:59 - way you write a while loop is you put
125:01 - while and inside a pair of parentheses
125:03 - you define the condition and then you
125:06 - have a body where the body is defined by
125:09 - the two early presses and inside the
125:11 - body whatever statements you write
125:12 - belong to the while loop again if you
125:14 - want to execute only one condition you
125:18 - can skip this braces and you can
125:19 - directly write the statement beside this
125:22 - Loop so now how do you make an infinite
125:26 - Loop if the condition is so much whether
125:28 - you can put a condition which always
125:30 - stays true so something like 1 equal to
125:33 - 1 so this condition will always stay
125:35 - true and this will become an infinite
125:38 - Loop or you can either use the Boolean
125:40 - true that is t r u e the word true or
125:43 - you can use directly integers also so
125:47 - this is a possible only languages like C
125:50 - C plus plus Python and all so in Java
125:53 - integers and booleans are separate so
125:55 - you need to be sure whether the
125:57 - particular programming language supports
125:59 - integers as booleans so in C plus plus
126:02 - integers are supported as booleans so 0
126:04 - is considered to be Boolean false and
126:08 - any other number except 0 is true so you
126:11 - can click any number from the integer
126:13 - range but generally people tend to use
126:16 - one as true because uh 0 and 1 make the
126:19 - binary numbers so generally people use
126:21 - one as true zero is false but you can
126:24 - basically use any number X Sub 0 for
126:27 - making it as true so let me give you an
126:30 - example over here so let me put some
126:32 - number so minus 120 which is not 0 and
126:35 - if I try to print some message like
126:38 - welcome to program knowledge
126:43 - and let me put an end line after that
126:45 - statement so now if I try to execute it
126:48 - if I print F9 so here you see it's going
126:52 - as an infinite Loop so you can put any
126:55 - number over here but if I put 0 and try
126:58 - to execute it you will see that nothing
127:00 - happened because 0 is false so this
127:03 - whole Loop is not executed so to make it
127:07 - execute a finite number of times what
127:09 - you do is you put a value over here
127:11 - something like int let's say
127:15 - steps
127:16 - equal to 10
127:19 - or you can start the steps from one you
127:22 - can go either way you can go from bottom
127:24 - top or from top to bottom you can do it
127:27 - either way and inside the condition let
127:30 - us print it 10 times so while step is
127:34 - less than or equal to 10 that is while
127:36 - uh this particular value stays less than
127:40 - or equal to 10 that is I wanted to print
127:42 - 10 times and then I'll increase the
127:44 - value of tips every time so steps plus
127:46 - plus or you can either do steps equal to
127:49 - steps plus one so both are same you are
127:52 - going to do either of them so now this
127:54 - will increase the value of the steps one
127:56 - by one so I will be getting this uh
127:59 - message 10 times so here you can see the
128:02 - message has been printed 10 times
128:04 - you can do this either other way also so
128:07 - that is basically a common approach used
128:10 - by competitive programmer so I think
128:12 - competitive programming the number of
128:14 - test cases are defined so they will tell
128:17 - the number of test cases like they'll be
128:19 - telling that I will be asking 10 queries
128:21 - and your program needs to answer those
128:23 - 10 queries so generally people tend to
128:25 - use that so let's say this is the 10
128:27 - queries so what I will do is I'll just
128:30 - write step minus minus so here this
128:33 - operation is getting performed right
128:35 - over here and since this is an integer
128:37 - which is not 0 it is going to be
128:39 - considered as true so this a shortcut
128:41 - kind of thing so this will also make the
128:44 - loop Run 10 times so generally while
128:47 - Loops are used at places where you don't
128:49 - know how many times the loop needs to be
128:51 - executed so generally people use this
128:54 - kind of statements to run the loop till
128:57 - the condition stays true or you can do
129:00 - it with a for Loop also you put an
129:02 - infinite Loop and then break out of the
129:03 - loop when time come so either way you
129:06 - can do it so that's all for while Loops
129:08 - let's not talk about the patterns so let
129:10 - me go into my browser and search for
129:12 - some patterns let's say see programming
129:15 - pattern
129:19 - uh let's go to images let's pick up some
129:22 - simple ones first
129:24 - so here you have this half pyramid so
129:28 - the way it goes is one one two one two
129:30 - three one two three four one two three
129:31 - four five so first let us replace these
129:34 - numbers which just starts so first we'll
129:36 - be making this particular triangle with
129:38 - all stars over there so you have one
129:40 - star two stars three stars four stars
129:43 - five stars and this will continue up to
129:44 - how many hour rows the user wants so
129:47 - this is the first row second row third
129:48 - row fourth row fifth row so now let us
129:51 - try to code this one so let me just uh
129:54 - put what we are going to do here so we
129:56 - don't need this
129:58 - let me put a multi-line comment
130:01 - and we'll be printing something like
130:04 - this we will have one and then two stars
130:06 - three stars four stars and then five
130:10 - stars so first we will try to print this
130:12 - and then the user can decide how many
130:14 - stars he wants to put
130:16 - it so now if you consider this one what
130:19 - we will be doing is first we will be
130:21 - talking about this one so Here If You
130:24 - observe we are going for first row we
130:26 - are going to print only one star for the
130:29 - second row we are going to print two
130:31 - stars for the third row of these stars
130:33 - and so on so here the way you identify
130:35 - the row and the column there you need to
130:38 - identify a relation between the row and
130:40 - the column so here relation between the
130:43 - rows and the columns here so columns is
130:46 - basically the number of stars the
130:48 - relation is that the number of stars in
130:50 - every row is equal to the row number
130:52 - itself so the way you do that is we are
130:55 - we we will be using nested Loop so the
130:57 - nested Loops are nothing but a loop
130:59 - inside loop so let me show you as an
131:02 - example so here let's first take the
131:05 - number of rows so let me call the
131:07 - variable as row itself so intro equal to
131:10 - let's say 1 and then flow is less than
131:13 - or equal to five let's first make it for
131:15 - five rows and then we will extend it for
131:17 - n rows row is less than or equal to Phi
131:20 - and then rho plus plus so now you know
131:23 - that this particular Loop is going to
131:24 - run n times so whatever is there inside
131:26 - this block it's going to run for n times
131:29 - so now what I'm going to do is I'm going
131:31 - to run another loop inside this Loop so
131:34 - now I have the loop right so now I will
131:37 - be printing one line two line three line
131:39 - so just consider this as every separate
131:42 - line so now I need to determine how many
131:44 - stars I want to print so those number of
131:47 - stars are going to depend on the row
131:48 - number right so I'll print another I'll
131:51 - give another loop so for INT let's say
131:55 - Stars
131:56 - equal to let's start from 1 and then the
132:00 - number of starts is going to be the row
132:02 - number right so star
132:05 - is less than or equal to rho right so if
132:10 - if we are in the third row we are going
132:13 - to print one two and three right so less
132:15 - than or equal to row and then you are
132:18 - going to give Stars plus plus or Stars
132:21 - equal to Star Plus One whatever is
132:23 - convenient for you then what we are
132:25 - going to do is inside this particular
132:27 - Loop we are going to print the Stars
132:29 - right so see out uh we need to print the
132:32 - star and
132:34 - you know you don't need the space or any
132:36 - new line right so the number of stars
132:38 - will be printed one beside the other so
132:40 - what this will happen when the first row
132:43 - is one you will start from one and then
132:45 - we will check the condition one is less
132:47 - than or equal to one that is true so it
132:49 - will print one star again this this will
132:52 - get activated so one will become two now
132:55 - and this condition will be checked so 2
132:57 - is not less than or equal to one so
132:59 - because the row is one so this
133:01 - particular Loop will break and then it
133:03 - will go to the next row so before going
133:05 - to the next row let us just print and
133:07 - end the line so that we get to the next
133:09 - line so now what is happening when this
133:12 - particular first iteration is finished
133:14 - it will just go to the next line and
133:16 - then the row will become 2 because of
133:18 - this condition so 2 is less than or
133:20 - equal to 5 that condition is checked and
133:23 - then here it will start from one so one
133:25 - is less than or equal to two one star is
133:27 - printed again it will go so 2 is less
133:29 - than or equal to 2 so again another star
133:31 - is printed and then this condition will
133:33 - be make it three so three is not less
133:36 - than or equal to 2 so this particular
133:38 - Loop is broken and it will go to the
133:41 - next line so if you just execute it you
133:43 - will be getting your output so here you
133:45 - have one star two stars three stars four
133:48 - stars five star for n Stars you are just
133:50 - going to ask the user so that's pretty
133:52 - simple right so you can just ask enter
133:55 - how many rows
133:57 - you want something like that so the end
134:01 - user will enter so in let's say number
134:04 - of
134:06 - rules and then see in number of rows
134:12 - so here I have number of rows so here
134:14 - what will happen for rho 1 to row five
134:17 - now I'll just print number of rows now
134:21 - let's execute this program it's asking
134:23 - how many rows you want I want 10 rows so
134:26 - if I just print it so here I have row 10
134:29 - where there are 10 Stars so this is what
134:31 - is a basic pattern thing now we'll
134:35 - extend the pattern we'll extend the
134:36 - difficulty so let us try to print this
134:39 - one
134:39 - so what is happening over here you are
134:42 - getting one one two one two three
134:44 - something like that right so why is that
134:46 - happening that is because of this
134:48 - particular Loop right as I told you the
134:50 - number of stars which are getting
134:53 - printed in each row is because of this
134:55 - inner for Loop so outer for Loop just
134:58 - manages the row so this particular rows
135:02 - which is one two three four five these
135:04 - rows are managed by the author follow
135:06 - and then the content inside each row
135:08 - like just one two and three so these
135:11 - contents are printed by the inner for
135:13 - Loop so for printing these things what
135:15 - we need to do here we just need to print
135:17 - instead of star we just have to print
135:21 - starts over here because stars is
135:23 - directly an integer so we're directly
135:25 - printing the integers we don't have to
135:27 - do anything so first the stars is one so
135:29 - it will print one then it will print two
135:31 - or two point three let's look at that
135:33 - I want five rows so here you have the
135:36 - outputs right so one one two one two
135:38 - three one two three four one two three
135:39 - four five like just the number of
135:42 - iterations were just printed that is why
135:44 - it came like that
135:45 - so let me close this
135:48 - so let's try the second one now so it is
135:51 - going from five to one it is just a
135:53 - reverse of it so what we need to do is
135:55 - we need to go from a five to one so what
135:58 - we are going to do we are going to start
135:59 - the row at five right so let's start it
136:02 - 25 or let's make it generic let's just
136:04 - print the number of rows over here and
136:07 - row is greater than or equal to 1 that
136:10 - is I'm going from five to one uh well
136:13 - the first Loop doesn't make any
136:14 - difference because from one to five or
136:16 - five to one there are only five
136:17 - iterations so these are acetone for
136:19 - number of rows so inside the rows you
136:23 - need to manage the content right so
136:24 - because of this statement I wrote
136:26 - Because if it was something like five
136:28 - four three two one the inner loop should
136:31 - start from the highest number right so
136:33 - since it is one two three four five I am
136:37 - starting from
136:38 - one so if it was five or three to one
136:42 - this particular Loop would have started
136:44 - from five because uh it just the value
136:48 - which is getting printed over here only
136:51 - depends on this particular inner for
136:53 - Loop so here uh this Remains the Same
136:56 - and now if I just try to execute it I am
136:59 - getting an error what is that
137:01 - okay it is not star it is Stars
137:04 - and F9
137:06 - so enter how many rows you want I want
137:08 - five rows so here you have that output
137:10 - you have one two three four five one two
137:12 - three four one two three one two one so
137:14 - this is how you print basic patterns
137:16 - let's take one difficult one
137:18 - um let's say this one right so this one
137:21 - is you can try out this one this is
137:22 - nothing but just printing spaces till
137:25 - the next number so suppose this is the
137:27 - second row so you have no space over
137:29 - here and then you got the third row so
137:32 - there are two spaces and then fourth row
137:33 - so you have three spaces on the fifth
137:36 - row you don't have anything for the last
137:37 - row you are just going to print all the
137:39 - numbers as it is so you can try this one
137:41 - and this one is a similar one as this
137:43 - one so we'll be talking about this one
137:45 - so here what is happening is there is a
137:47 - space actually so what you do is for any
137:50 - kind of pattern you're just going to
137:52 - divide it into a matrix kind of fitting
137:54 - so if we just put a matrix or whatever
137:56 - managed you can divide these things into
137:58 - rows and columns so if you just put rows
138:01 - and columns you will be seeing that this
138:03 - first row there are uh let's say step
138:07 - now one two three four spaces right so
138:10 - after four spaces the number is getting
138:12 - printed that is if there are five rows
138:15 - so there are one two three four five
138:17 - rows right so the if there are five rows
138:19 - what is happening is
138:21 - after five rows for every five rows uh
138:24 - there are n minus one uh spaces uh
138:27 - before the first element right so if n
138:29 - is pi you have four spaces before the
138:31 - first element and then the number of
138:33 - spaces are decreasing so n minus two
138:35 - spaces that is four three spaces for the
138:38 - second element two spaces for the first
138:40 - element one space for the uh fourth
138:44 - element and then zero spaces for The
138:45 - Fifth Element so Fifth Element is
138:47 - directly starting from the edge so let's
138:49 - first uh manage the spaces
138:52 - so here uh we won't be requiring this so
138:55 - okay we need the a two Loops but this
138:59 - one this particular logic will change so
139:01 - what will happen is Let's uh first deal
139:04 - with the spaces so let me name it as
139:06 - spaces
139:08 - so now when I have
139:10 - um
139:11 - the first row my spaces should be four
139:14 - right so I need to start from the
139:17 - highest number that is I need to start
139:18 - from the number of rows and this row
139:20 - number uh it it could be either way so I
139:23 - prefer going from the
139:25 - please to the highest so lowest num less
139:29 - than number of rows and then row plus
139:31 - plus
139:32 - so for the spaces what we are going to
139:34 - do is let me clear this down here
139:37 - for the first row we have four spaces
139:39 - that is for taking ns5 that is number of
139:42 - rows as five we are going to take uh
139:45 - five rows as our example so we will be
139:47 - printing the same thing and then you can
139:48 - extend it so what is going to happen is
139:51 - for for number of rows you are going to
139:54 - give number of rows minus one spaces so
139:57 - if it is pyros you are going to give
139:58 - four spaces for the first element if it
140:00 - was seven rows you would have given six
140:02 - spaces for the first element something
140:04 - like that so now let us print this thing
140:07 - what we are going to do is for number of
140:09 - rows we need to run a loop from one to
140:12 - number of rows minus one so here when
140:16 - space is equal to 1 and then spaces
140:20 - is less than or equal to uh
140:23 - number of rows minus 1
140:26 - and then spaces plus plus and then since
140:29 - I have only one statement I'm just going
140:31 - to write it over here I'll just print a
140:34 - space without a new line because once
140:37 - it's a new line it's going to go to the
140:38 - next line we don't want that to happen
140:40 - we are just dealing with the values
140:42 - right now and then after printing this
140:45 - what do we need to print as the number
140:46 - so here we are just starting with the
140:49 - row number and then we are going till
140:52 - the
140:53 - ah so we are going till this middle
140:56 - value right so we are just going like
140:58 - one two three and then three four five
141:01 - and then four five six seven basically
141:03 - what is happening is the first and last
141:04 - values are a bit uh similar and then
141:07 - this middle value is just the
141:09 - progression of this so for every row
141:11 - this particular value that is the
141:14 - maximum value these elements go up to
141:17 - and then decrease will depend on the row
141:19 - number so here if you see for the first
141:21 - row uh I'm not going any further for the
141:25 - second row I'm just going one and one
141:27 - number further for the third row I am
141:29 - going two numbers further for the fourth
141:31 - row I am going three numbers further but
141:33 - fifth one I am going four numbers so
141:35 - five plus four nine four plus three
141:37 - seven three plus two is five two plus
141:39 - one is three and then one plus zero is
141:41 - one that's why I'm staying here so for
141:44 - that we again need a loop so for uh
141:47 - let's call it something else now
141:49 - uh let's say the number right so for end
141:52 - number equal to let's start from the row
141:55 - number because it's starting from the
141:56 - row number right so the first row is for
141:58 - starting from one second row starting
142:00 - from two something like that so for low
142:02 - number equal to the row number
142:06 - and where should it go it should go till
142:09 - row minus one right so number is less
142:12 - than or equal to rho minus 1 and then
142:16 - again number
142:18 - plus plus
142:20 - and then here since I have only one
142:22 - statement I'm not using that Curly
142:25 - braces so see out what number
142:28 - right so till where did we do we did
142:31 - till here right so we did not print
142:33 - these statements so we did not print any
142:36 - of these statements we just printed this
142:39 - particular triangle in this fashion so
142:41 - we just have a space and then one then
142:43 - space and then two numbers space then
142:45 - three numbers something like that so now
142:46 - to deal with this numbers we need to
142:49 - print these numbers also right we cannot
142:50 - just omit this so we need to start from
142:53 - this particular number and go till there
142:55 - so how do I know what is this number we
142:57 - don't know that right we we know that it
142:59 - is rho minus 1 so if it is sorry it is
143:03 - rho plus rho minus 1 what I am saying is
143:05 - this particular highest number till
143:07 - where it gets to is rho plus rho minus
143:11 - 1. so this particular equation you can
143:13 - get that right it's just from
143:14 - observation that let's take this row
143:17 - this is the fourth row so that is row
143:19 - equal to 4 4 plus 4 minus 1 that is 3 so
143:22 - 4 plus 3 that is seven so this is the
143:24 - highest number we will get so from there
143:26 - we need to go till there go right so for
143:29 - first row we are not going to go
143:30 - anywhere so row plus rho minus 1 is just
143:33 - one so we need to go from 1 to the
143:36 - highest number uh sorry 1 to the row
143:39 - number which is one so we don't have to
143:40 - print anything over here so we are
143:42 - already at one so we just break out of
143:44 - the loop so here what we'll do we'll
143:46 - we'll be at 3 and then from 3 we need to
143:50 - go to the row number so from 3 we need
143:52 - to go to 2 so we need to print this
143:54 - particular two and then again for from
143:56 - fry we need to go to 3 from 7 we need to
143:59 - go to four so just we are just
144:01 - subtracting 1 1 over here
144:03 - so we'll like write that Loop uh we'll
144:06 - call it back number something like that
144:08 - so let's say um
144:10 - that second triangle let's just call it
144:13 - second triangle uh let's start it from
144:16 - that highest number what is that highest
144:17 - number uh let's start it from highest
144:20 - number minus one because uh you don't
144:22 - have to print that highest number again
144:23 - right so if we are at 3 you need to
144:26 - start from two
144:27 - we are going in this fashion we don't
144:29 - have to print the Spy again right so we
144:31 - have already printed this 13579 already
144:34 - we just need to print these lines so how
144:37 - do we do that we just start from uh as I
144:40 - told you the equation for that rho plus
144:42 - rho minus 1 and minus 1.
144:45 - right so this is this so if you can uh
144:49 - actually simplify it it comes as 2 into
144:52 - rho minus 2 so you can write that also
144:55 - or 2 into rho minus 1 that is also
144:57 - correct so you can directly write it as
144:59 - 2 into row minus 1 or uh I'll leave it
145:02 - just like that so that you understand so
145:04 - this row into rho minus 1 is actually
145:06 - the highest number we'll get to at every
145:08 - row so rho into rho minus 1
145:11 - and then the second triangle goes up to
145:14 - that particular row number right so
145:16 - greater than or equal to rho and then
145:18 - second triangle minus minus
145:21 - and since I'm writing only one statement
145:23 - I don't have to use that Loop or that
145:25 - braces so I'm just going to print that
145:28 - second triangle element whatever it is
145:31 - and then I am going to go to the next
145:34 - line so these three Loops inside this
145:37 - particular Loop uh is just makes a
145:40 - complex kind of a loop but it isn't
145:42 - complex if we just break this down so
145:44 - let me comment it down here these are
145:46 - for the spaces
145:47 - or for the starting spaces
145:53 - and these are for the starting
145:57 - 10 numbers right for every row they are
146:00 - if you take the nth row there are n
146:03 - numbers right so here for the first row
146:05 - there are only one number and then for
146:07 - second row your two numbers third row
146:09 - your three numbers so I'm talking about
146:10 - this particular triangle so this uh let
146:14 - me just call it the N numbers or n
146:18 - row numbers something like that and this
146:21 - will make the
146:23 - last
146:25 - n minus 1 numbers so here if you see
146:29 - for the first row you have only one uh
146:33 - for the second row you have only one
146:34 - element for the third row you have two
146:36 - elements I'm talking about this
146:37 - particular triangle now
146:39 - so this should give us the expected
146:41 - output let's run and see this
146:44 - uh so till where did he go he went up to
146:46 - five right so he he took five rows let's
146:48 - type with five rows
146:50 - and uh okay something is wrong over here
146:53 - we did not get the output tax expected
146:55 - so what happened
147:00 - um
147:01 - yeah so here what happened is I just
147:04 - took rho minus 1 so this particular look
147:06 - never ran what I should have taken is I
147:09 - had taken this particular expression so
147:11 - that's a mistake I did so it is not row
147:13 - minus 1 it is rho plus rho minus 1 and
147:16 - then now if you execute it you will be
147:18 - getting the output
147:20 - okay I did not close this
147:25 - so 5 and then uh here you have the
147:29 - output so it is one two three two three
147:31 - four five four three five four five six
147:34 - seven six five four now uh the numbers
147:37 - are correct but if you see the placement
147:39 - is wrong that is we messed up the spaces
147:41 - so let's see where we messed it up
147:45 - when the row is one it will go from
147:47 - number of rows minus one to one so now
147:50 - what is happening is if the row is one
147:52 - only then this condition is satisfied
147:54 - what about the next row and the next row
147:56 - so this should be number of rows minus
147:59 - rho and then spaces should be greater
148:01 - than or equal to one what I did is if
148:03 - number of rows is 5 and I'm in the first
148:06 - row so 5 minus 1 is 4 I'll be going from
148:09 - 4 to 1 and if I go from if I go to the
148:12 - next row that is second row so 5 minus 2
148:15 - that is 3 I'll be going from 3 to 1 that
148:17 - makes it three spaces so like when it
148:19 - will continue so now we should be
148:21 - getting our expected output if I just
148:23 - put 5 yes so here you can see the exact
148:26 - same output we got over here so so this
148:29 - one we made one two three two three four
148:31 - five four three so there's a space
148:32 - between the numbers we can do that very
148:34 - easily what we are going to do is we are
148:36 - just going to add a space between over
148:39 - here
148:40 - and uh over here also whenever we are
148:43 - printing the numbers we are just going
148:45 - to add one space over here
148:47 - and
148:48 - if we execute this 5
148:51 - so here you are going to get the output
148:53 - as expected so here you are having the
148:56 - same thing so one two three two three
148:58 - four five four three so now this one
149:00 - looks better than this that is because
149:03 - of the num spacing over here since I
149:05 - gave spaces over here I need to give two
149:07 - spaces over here for every uh thing so
149:11 - now what I mean is since uh there's a
149:14 - space between the numbers also so for
149:16 - every row suppose I'm going for the
149:18 - first row I should give 2 into those
149:21 - number of spaces so Suppose there are
149:23 - four spaces in between I I if I give
149:25 - eight spaces it will have been better so
149:27 - let me show that uh there's only one
149:30 - slide modification to make it look like
149:31 - that what we need to do is instead of
149:33 - number of rows minus row I am going to
149:36 - just go from 2 into this particular
149:38 - value number of rows minus low
149:40 - and now if execute it let's say 5 so
149:44 - here you are getting that particular
149:46 - equilateral triangle kind of a thing
149:49 - so here if you see so what I meant was
149:51 - in the last uh when the last time when
149:53 - we did not have a space between these
149:55 - numbers what was happening was uh since
149:58 - there are no spaces it was looking good
150:00 - but once we have spacers we are having a
150:03 - space between every number right so we
150:04 - need to increase the number of spaces
150:06 - over here also so I just made it two
150:08 - times so that it looks exactly like this
150:11 - so you can try these ones also this is
150:13 - tested uh implementation of this what is
150:17 - that is for every row you're just
150:18 - omitting the middle numbers you're going
150:20 - from the one to that particular the
150:23 - highest number of the true that is the
150:25 - row number and you are just omitting the
150:27 - in between numbers on this one also so
150:30 - and uh for complex patterns such as this
150:34 - one so this solid diamond or you can try
150:37 - this one also that is this number
150:39 - printing so one one two one two three
150:41 - one two three four so this one is just a
150:43 - implementation of these two triangles so
150:46 - what we did was this particular triangle
150:48 - is first printed so like one one two
150:50 - three one two three four something like
150:52 - that and then this whole Loop is just
150:54 - inverted again so you need to break the
150:57 - problem down into simpler so simpler
150:59 - problem so here if you you see this
151:01 - particular Diamond you can break it down
151:03 - into this particular triangle that is
151:05 - the upper triangle and then lower
151:06 - triangle if you just see it you will be
151:09 - able to understand you will be able to
151:11 - differentiate between those two shapes
151:12 - so you need to break down the complex
151:15 - shapes into simpler ones and simpler
151:17 - ones you pretty much can try all these
151:19 - shapes so these are just implementations
151:21 - so you can try it just like this so
151:24 - these are the number of
151:27 - so this is how you work with pattern so
151:29 - again for a review this particular first
151:31 - for Loop that is the outer for Loop let
151:33 - me write it down here
151:35 - um or let me go so outer for Loop
151:39 - controls
151:42 - number of lines or rows so the number of
151:46 - lines or rows are controlled by this
151:48 - outer for Loop and the content is always
151:51 - controlled by the inner for Loop or
151:53 - Loops it depends like in this one it
151:55 - took three Loops for
151:58 - controlling the data but uh if uh it was
152:01 - a simpler Loop such as the first one it
152:03 - was only one Loop so whatever it is the
152:06 - inner or Loops always control the data
152:08 - and the outer loop will control the row
152:10 - or the number of lines so here if you
152:14 - will need to actually kind of form a
152:17 - relation between the row number and the
152:19 - data so every time there will be a
152:21 - relation so that is why it's called a
152:23 - patent every time there is a relation
152:24 - between the row and data you need to
152:26 - identify that particular one and you
152:28 - need to work up on your logic to form
152:30 - such patterns in this video we'll be
152:32 - looking at do while loop and also the
152:34 - jump statements in C plus let's get
152:36 - started in the previous video we looked
152:38 - at for loops and while Loops right so
152:40 - let me just write down their basic
152:42 - structure so you have a counter you have
152:45 - a condition
152:47 - and then you have a growth rate of for
152:49 - the counter so that this particular
152:51 - condition becomes false at some point of
152:53 - time right and for while loop you define
152:56 - the condition inside a pair of
152:58 - parenthesis and then you have the body
152:59 - of the loop where you define the growth
153:02 - rate of that particular
153:04 - cut counter right so now if You observe
153:07 - if this particular condition is false at
153:11 - the beginning itself this whole Loop is
153:13 - not going to run right so what I'm
153:15 - talking about is if I declare some
153:18 - variable like enter equal to 0 and in
153:21 - place of this condition if I give I is
153:23 - less than 0 and this growth can be
153:25 - anything so let's say I equal to I plus
153:28 - 10 something like that so now if you see
153:31 - the starting value of I is 0 so once
153:33 - this condition is checked it is false so
153:36 - this whole Loop is not going to execute
153:38 - itself so if I write something like uh
153:40 - this is the for Loop statement
153:45 - so this whole statement is not going to
153:48 - be executed at all let me just add a new
153:49 - line also so this is the escape sequence
153:52 - of the new line
153:53 - so now the same will happen with the
153:56 - while loop also so if I just say in J
153:59 - equal to 0 let me just write down the
154:01 - same set of conditions so J is less than
154:03 - 0 and the growth will be J equal to J
154:06 - Plus 10. right and let me write on that
154:10 - particular statement so see out let me
154:13 - just copy this thing
154:16 - foreign
154:17 - and this one will be the while loop
154:20 - statement
154:21 - so if I execute this particular program
154:23 - I won't be getting anything so now if I
154:26 - just try to execute it you will be
154:28 - seeing that I have a blank output right
154:30 - I don't have anything over here
154:32 - so what if I want to execute this
154:35 - particular statement on what is a
154:37 - particular set of statements inside the
154:39 - loop at least once right so sometimes
154:42 - you are given a menu and then you are
154:44 - asked to choose something from that
154:46 - right so you uh you have something like
154:51 - this you have choose your option
154:54 - and then you have first one second one
154:57 - third one and uh so on so this will
154:59 - continue and then you will be given a
155:02 - choice where you can enter your choice
155:03 - so in programs like this these are
155:06 - called menu driven programs these are
155:08 - called menu driven programs and in
155:12 - programs like this what happens is you
155:15 - need to execute this whole set of
155:16 - operations at least once if I directly
155:19 - press 3 over here let's say 3 means exit
155:22 - right so you have some functions in one
155:24 - and two and three is equal so if I press
155:26 - three I should exit out of the program
155:28 - but for that to happen this whole set of
155:31 - code should execute at least once right
155:33 - so in this kind of loop that doesn't
155:36 - happen it will directly stop uh when
155:39 - this particular condition is false so in
155:42 - the beginning itself if the condition is
155:44 - false it is going to break out of the
155:47 - loop so in uh such kind of situations
155:50 - what we are going to do is we are going
155:52 - to use the do while loop
155:54 - well you can do that with these Loops
155:56 - also by using the jump statements but
155:59 - since I have not talked about the jump
156:00 - statements till now I'll be talking
156:02 - about them shortly so now we will be
156:04 - using the do while loop do a loop is
156:07 - relatively easier to use than jump
156:09 - statements so what we are going to do is
156:11 - you are going to write do and inside
156:13 - this you will be defining the body of
156:15 - the loop so this is actually a loop
156:17 - right so here inside you will be
156:20 - defining the loops body and then you
156:23 - will write while and then the condition
156:25 - right so what happens here is first you
156:29 - check the condition and execute the
156:31 - statements in these Loops right in this
156:33 - Loop what happens is first you execute
156:36 - the statements and then check for the
156:38 - condition
156:38 - that is the only difference between
156:40 - these four and while loops and this do
156:43 - while loop uh let us execute this
156:45 - particular same program so let's take
156:47 - int k equal to 0 and the same condition
156:50 - which is case less than 0
156:53 - and let me just copy on this particular
156:56 - statement
156:59 - inside the loops body
157:01 - right and this is the do value
157:04 - now if I execute this particular program
157:07 - you will be seeing that this has
157:09 - executed once this is the do-way look
157:11 - what happened is before checking for
157:13 - case less than 0 it first executed
157:15 - whatever is there inside this and then
157:17 - it went for this particular condition
157:19 - check which it turned out to be false
157:21 - that's why it broke out of the loop so
157:23 - in places where you need to execute the
157:26 - loop at least once in such cases where
157:28 - you have this kind of menu kind of thing
157:31 - you you are going to use the do while
157:33 - loop it is going to be very useful and
157:35 - very easy to use
157:37 - so let us quickly write a small menu
157:39 - driven program I will show you what I'm
157:41 - talking about
157:42 - uh so this one is going to be a menu
157:45 - driven program for uh choosing between
157:47 - addition and subtraction so let's say
157:50 - I'll do and then inside this I'm going
157:54 - to ask for your choice so
157:57 - uh choose one for
158:01 - addition and two for subtraction
158:07 - and I'll be getting a number so in
158:10 - Choice let's call it and then C in
158:13 - choice
158:14 - and then now I can switch the choices as
158:17 - I told you so I can use either switch
158:18 - case or if else I will go tape files
158:20 - because I have only two numbers to
158:23 - compare so if Choice equal to 1
158:27 - then what you are going to do is you are
158:29 - going to ask for two numbers so enter
158:32 - number one
158:36 - and I'll get a number in n1c in N1
158:40 - and the same thing goes for number two
158:43 - also
158:46 - and 2 and 2 and over here number two uh
158:50 - well we can actually put this thing
158:52 - outside because for both addition and
158:54 - subtraction since we are dealing with
158:56 - only two numbers I'm just going to put
158:58 - these things outside because it really
158:59 - doesn't matter whether the choice is one
159:01 - or two right we are anyway going to ask
159:03 - for the two numbers for age of addition
159:06 - or for subtraction only thing is the
159:08 - which is going to changes our print
159:10 - statement so I'm just putting it outside
159:12 - the conditions over here and then if
159:15 - charge equal to 1 what we need to print
159:17 - is we need to print the addition or the
159:19 - sum so since I have only one statement
159:21 - I'm going to skip those
159:23 - curly basis and then uh the sum is
159:28 - we can directly print the sum or you can
159:31 - even store it inside one of the
159:34 - variables and then print it I'm not
159:36 - going to do that and the same goes for
159:38 - the difference also right
159:41 - so if Choice equal to 2 then
159:43 - you print the difference so difference
159:46 - is
159:48 - N1 minus N2 and over here
159:52 - charge equal to 2 and you can use else
159:54 - if over here so instead of checking if
159:57 - you put two if what will happen is it
159:59 - will first check for this and again
160:00 - check for this but if you put an else if
160:03 - what will happen is if this condition is
160:05 - satisfied it won't check for this one so
160:07 - or if you have a hierarchy of conditions
160:09 - so if you have 10 conditions if the
160:11 - second one is satisfied it will directly
160:13 - skip to the next iteration so what what
160:16 - happens over here is if you put all ifs
160:18 - or all 10 ifs even if the second
160:20 - condition is satisfied this is going to
160:22 - check for all the 10 conditions so else
160:24 - if it's a better choice when you have
160:26 - two distinct choices right so now after
160:29 - printing this what we are going to do is
160:31 - we are going to ask for the user whether
160:33 - he wants to continue or not so do you
160:36 - want to continue
160:39 - foreign
160:45 - so now once you take the character what
160:48 - will happen is it will be limited to the
160:50 - scope so if I write something like care
160:52 - let's say can
160:55 - and then scan stands for Content I
160:57 - cannot use the word continue because
160:58 - it's a keyword I will be talking about
161:00 - that shortly let's just say Khan means
161:03 - continue right so now if I just taken
161:06 - Khan what will happen is this particular
161:09 - variable will be limited only to this
161:11 - scope the highlighted braces which you
161:13 - are seeing here so if you want uh to
161:16 - compare that that is not possible right
161:18 - because the while which we are riding is
161:21 - outside this one right so while we write
161:23 - outside this body of the loop so we need
161:26 - this variable to be accessible outside
161:29 - the body of the loop so we don't want to
161:31 - access it outside everything else right
161:33 - we don't want to uh access this variable
161:36 - outside everything so what we are going
161:38 - to do is we are just going to put this
161:40 - Con
161:41 - over here inside the main function so
161:45 - what will happen is it will be limited
161:47 - to this main function but since we are
161:49 - not dealing with other functions we are
161:51 - just uh using this particular one as a
161:54 - function variable that is it belongs to
161:57 - this particular function and then it can
161:59 - be accessed from anywhere in the
162:01 - function since this y also is inside the
162:03 - function it can access this continue
162:05 - variable now if you return it over here
162:08 - it could not have access to it so now we
162:11 - are going to do it until he says no or
162:14 - till he keeps saying yes both are
162:16 - equivalent statement you can do either
162:17 - con is not equal to s or you can say or
162:21 - sorry con is not equal to no till then
162:24 - you need to continue or else you need to
162:26 - continue till he keeps saying this so
162:29 - both of them are right you can do either
162:30 - one of them and now if I execute this
162:33 - so he's asking for the choice I'm going
162:36 - to say one enter number 1 12 12 so the
162:39 - sum is 24. I want to continue yes
162:42 - if I put 2 and then 12 12 so the
162:45 - difference is 0 and now if I press n
162:49 - it is going to stop so now you see uh
162:51 - how the do I look can be used so in if
162:54 - you are using the four or while loop
162:56 - that is also possible but it's quite
162:59 - clumsy to implement uh as compared to
163:02 - this particular do while loop so now
163:05 - let's talk about the jump statements
163:08 - I clear this we don't need this so the
163:10 - first jump statement we are going to
163:12 - look at is continue so what continue
163:15 - does is it will skip a particular
163:17 - iteration so let me show you an example
163:20 - so for entire equal to 1 is less than
163:23 - less than or equal to 10
163:25 - and I plus plus and inside this loop I
163:28 - am going to print something let's say
163:31 - let's just print type right and then a
163:34 - new line also now you know the output
163:37 - right it's just going to print all the
163:39 - numbers from 1 to 10. so now what I need
163:42 - is I don't want the value of Phi to be
163:44 - printed in the output I want all the
163:46 - numbers except 5 so one way you can do
163:49 - is you can do something like if I is not
163:53 - equal to 5 then you print all these
163:56 - things so this is also one of the ways
163:58 - to get the output what I actually uh
164:00 - said so here you can see all the numbers
164:03 - are getting printed except file but in
164:06 - some scenarios where uh what we need to
164:09 - do is when instead of writing everything
164:12 - in an if else Loop we can directly skip
164:15 - the statements if that number is not 5
164:18 - right sorry if the number is 5 we what
164:21 - the mean is
164:23 - if I have some set of statements over
164:25 - here so let's say um
164:28 - we have this one uh statement one and
164:32 - then I have another statement over here
164:34 - so statement two uh let me add a new
164:37 - line over here so that you can
164:38 - differentiate so after every uh I there
164:41 - is going to be a statement one in
164:43 - statement though but if I want that all
164:45 - to be executed only when I is not equal
164:48 - to Phi what I need to do is I need to
164:50 - put everything inside a particular
164:52 - inside the body of if Loop right so I
164:54 - need to do something like this and then
164:56 - here so inside this body of the if loop
165:00 - I am going to get all these statements
165:02 - printed only if the number is not fine
165:03 - the easier way to do is what we can do
165:06 - is we can skip those statements right so
165:08 - if I is 5 we can skip those treatments
165:10 - so the way you skip the statements is
165:13 - this stage as it is but once I equal to
165:16 - 5 what I am going to do is I'm just
165:18 - going to hit continue
165:21 - so what this will do is if I is equal to
165:23 - 5 it won't care about the next
165:25 - statements it won't care about any other
165:27 - statements inside it is just going to
165:29 - skip the iteration and go over to the
165:31 - next one so this is true with every Loop
165:34 - so even if you have the continue inside
165:37 - the if and then you have some statement
165:40 - over here let's say uh
165:42 - continue is
165:46 - triggered
165:49 - something like this so this statement
165:51 - won't be executed at all the once the
165:55 - continue is encountered it is directly
165:58 - going to skip everything and just going
165:59 - to the next iteration so now if I
166:02 - execute this you will be getting the
166:03 - same output
166:05 - okay I did not put this
166:08 - yeah now if you see I have one two three
166:12 - four and then Phi did not print anything
166:14 - at all and then six seven eight nine ten
166:16 - right so that is the use of continuous
166:18 - statement it's just going to skip the
166:20 - statements once it's not required so
166:22 - every statement is skip
166:24 - so next thing we are going to learn
166:26 - about is break
166:28 - break is almost same like continue what
166:31 - it does is just going to break or
166:32 - continue it's just going to skip the
166:34 - iteration it is just a break is going to
166:37 - completely skip the loop itself so once
166:39 - break is encountered it's just going to
166:41 - come outside the loop so if I write
166:42 - something like
166:45 - um the loop has executed
166:49 - this is outside the loop right so this
166:51 - particular statement is outside the loop
166:53 - and now if I execute it you will be
166:55 - seeing that
166:57 - all the statements are printed only up
167:00 - to five once Phi is encoded it has
167:02 - directly broken out of the loop and then
167:04 - it says loop as executed so that is the
167:07 - use of break statements so you you have
167:09 - encountered the break already right and
167:12 - switch case so this is what happens once
167:14 - a case is satisfied you are just going
167:16 - to break out of the whole switch case if
167:18 - you don't break out what is going to
167:19 - happen is it's going to follow all the
167:21 - statements which are associated with
167:23 - every switch case below that order so
167:26 - the next statement we're going to learn
167:27 - is about the go to statement
167:30 - so what go to is it's basically a
167:33 - connecting kind of a thing so you have a
167:36 - label so let's call something like let's
167:39 - call it label and then you have a set of
167:41 - statements inside this label so you have
167:43 - C out uh
167:45 - hello and then see how so you have these
167:48 - two statements right uh let me just add
167:51 - a space over here so these two
167:52 - statements are going to be printed side
167:54 - by side I don't have a new line over
167:56 - here so now what will happen is I want
168:00 - to
168:00 - execute these statements again and again
168:03 - when I press something so remember the
168:06 - do value we can do the same thing with
168:08 - the go to statement also it's not
168:10 - exactly a loop but it can act like a
168:12 - loop so let's say I have some
168:15 - variable over here let's call it int I
168:17 - so I so I'm going to take in I and then
168:21 - if I
168:24 - is equal to let's say some number let's
168:26 - say 12 or 7 something like this so if I
168:30 - use this particular number I want the
168:33 - whole thing to be executed again right
168:35 - so what I will do is go to this
168:38 - particular label what this does is it
168:41 - will directly switch the control from
168:43 - here to directly over here it will
168:45 - directly go from here to here or you can
168:48 - go from here to bottom also it can go
168:50 - from this particular place to any place
168:52 - in the whole program or in the whole
168:54 - function you can uh directly skip all
168:57 - the statements you can either go
168:58 - backwards or even forwards it completely
169:01 - depends upon your program but here what
169:05 - will happen is till I press some other
169:07 - number except seven this whole
169:09 - statements are going to be repeated
169:10 - again and again so once I press enter
169:12 - you are saying welcome to programming
169:14 - knowledge I press 9 enter so here you
169:17 - see it stopped now if I press 7 it's
169:20 - going to continue again and again so
169:23 - let's say 7 enter you see the same set
169:26 - of statements have executed seven seven
169:29 - till I press seven it's going to repeat
169:31 - and then if I press something else it's
169:33 - going to stop so that is about the go to
169:36 - statement
169:37 - and then you have another statement
169:39 - called exit statement so what exit does
169:41 - is it directly breaks the whole program
169:44 - your program is going to end but it's
169:47 - not a function directly so you need to
169:49 - have another header file to execute it
169:51 - so that header file is known as the
169:53 - standard Library header file so it is
169:56 - stdlib which stands for sandal library
169:58 - but it's a c header file so it's a name
170:02 - and C plus plus is cstrb so you need to
170:05 - type
170:07 - cstdlib so this is a header file and
170:10 - inside this you have the exit function
170:12 - so let's say I want to exit right after
170:14 - this one so I'll just press in exit one
170:16 - means exit with an error and Exit 0
170:18 - means it's just going to exit without
170:20 - any error so let me show that
170:22 - if I execute this you can see it just
170:25 - ended with return 0 that is the exit
170:29 - code which I passed over here so it went
170:31 - on without any errors but now if I press
170:33 - one and exit so here you can see process
170:36 - returned one that is the exit code so
170:39 - one main sum error right so here you can
170:41 - see it's terminated with a status one
170:43 - that is red color it means that it
170:45 - Terminator are normally
170:47 - from this video on which we'll be
170:49 - looking at functions in C plus plus so
170:52 - till now we have been using only one
170:53 - function right that is this particular
170:55 - main function whatever we have been
170:57 - writing we have been writing inside this
170:58 - function and then we have been executing
171:00 - it so from now onwards we will be
171:02 - understanding how to work with multiple
171:04 - such functions and how you make your
171:06 - program much more efficient and readable
171:10 - so first things first what is a function
171:12 - so if you remember your basic math
171:15 - classes you have come across something
171:16 - like y equal to sine X or Y equal to X
171:19 - Cube x squared so all these things are
171:22 - functions right so if you look at the
171:24 - mathematical definition of a function
171:27 - what it says is it will take in a set of
171:30 - numbers and then it will map every
171:33 - element in that set with exactly one
171:37 - element in the other set so if that is
171:39 - confusing what it basically means is it
171:42 - it can take n number of things inside
171:45 - this uh definition that is if I am
171:48 - defining a function as y equal to some f
171:51 - so inside this I can take as many
171:55 - elements as possible but the Y is going
171:58 - to be only one value so it can only
172:01 - compute something it can work on the
172:04 - mathematical operations and then it will
172:06 - give you exactly one single output for y
172:09 - so if you look over here so y equal to
172:12 - sine X there is a series of sine X right
172:15 - so it will it will be something like 1
172:17 - minus 1 1 factorial something like that
172:21 - so that computation is done on this
172:23 - particular X and then that only one
172:25 - value which is in the range of minus one
172:28 - to one right so minus one to one
172:30 - inclusive that particular value is
172:33 - written to Y so if you take an x square
172:36 - it is going to take some number X and
172:38 - then it is going to do some computation
172:41 - that is it is going to multiply itself
172:43 - and then it will return back your y so
172:45 - this is again only a single number so
172:48 - again if you take the equation of a line
172:50 - let's say y equal to MX plus C where m
172:53 - is the slope so here again I can define
172:55 - y and two or three different ways also
172:58 - so one first base let me write it down
173:01 - here first way is that it can it is
173:03 - going to take only one input that is y
173:05 - equal to f of x so where uh let's say f
173:09 - of x is going to return MX plus c and
173:12 - the other way is you can say y equal to
173:15 - F of let's say G of M comma X where it's
173:19 - going to take in the value of M and X
173:21 - where C is already defined inside the
173:24 - function and it's going to return you MX
173:25 - plus C right the other way is y equal to
173:29 - H of let's say m comma X comma C I'm
173:33 - going to take all the values and I'm
173:35 - just going to compute that so that is
173:37 - why where uh sorry over here it is G of
173:40 - X and H of this particular sorry this is
173:44 - M comma x h of M comma X comma C is
173:48 - going to be MX plus C so uh don't worry
173:52 - if it is really mathematical what I am
173:56 - trying to say is it is it can take
173:58 - multiple inputs but it is going to give
174:01 - you exactly one output so in this case
174:03 - it's going to give you exactly one
174:05 - number right that that is the y
174:07 - coordinate of this particular line if
174:09 - you're given the x coordinate it's going
174:10 - to give you the y coordinate or vice
174:11 - versa you can and Define it the other
174:13 - way too
174:15 - so that is exactly how functions work in
174:18 - programming also so let me write it down
174:20 - here in programming a function can take
174:23 - multiple inputs
174:26 - but it can give you only one single
174:31 - output
174:32 - input is basically it could be 0 as well
174:35 - as n number of input you can either give
174:38 - it something or it can perform
174:39 - independently also that will depend upon
174:42 - the function you are writing so enough
174:44 - of the definition of the function now
174:46 - let us look at why do we need functions
174:49 - so here I have a basic program we don't
174:52 - need this I'm just going to delete this
174:53 - and here we have a basic program to add
174:56 - two numbers right
174:58 - so what if I say that I want to ask the
175:02 - user for you know adding these two
175:05 - numbers let's say some 10 times at first
175:08 - you would say you need to copy and paste
175:11 - this thing 10 times now as you are well
175:13 - versed with loops what you are going to
175:15 - do is you will be putting these things
175:17 - inside the loop but if you look at this
175:19 - this is about let's say it's a nine
175:22 - liner code right so if you make a loop
175:25 - the loops body will contain nine lines
175:28 - of code so let's just imagine it's not
175:30 - such a simple program of adding two
175:32 - numbers it's something more than that
175:34 - and what if you are going to solve a
175:37 - particular problem which say which
175:40 - contains let's say 100 lines of code so
175:42 - if you're giving that code to me I won't
175:45 - understand what you're doing right so at
175:47 - the first glance I won't understand what
175:50 - you are doing and then I need to spend
175:52 - some time and then I need to understand
175:55 - everything I need to understand how you
175:57 - are using the variable bills and all and
175:59 - then I will be able to develop on that
176:01 - and the second thing is you will be
176:03 - writing a lot of redundant codes let me
176:05 - put this inside a loop next menu so
176:08 - let's say is less than 10 and I plus
176:10 - plus
176:13 - and this is a loop body right so it
176:16 - starts from here and uh
176:19 - ends over here so here this things are
176:22 - getting re-initialized again and again
176:24 - and again highly inefficient and then
176:27 - this particular competition is going on
176:29 - so basically this looks clumsy and it
176:32 - decreases the readability and then it
176:34 - will drastically increase the redundancy
176:37 - of the code so by using functions what
176:40 - you will be doing is you will be asking
176:42 - these 10 lines to be executed in a
176:46 - separate kind of environment where once
176:49 - the job is done you will return back to
176:51 - this particular environment so it's not
176:53 - exactly an environment but it's actually
176:55 - switching your control to some other
176:57 - thing right so it's like working in a
177:00 - team so instead of doing everything by
177:02 - yourself you will ask your team member
177:03 - to do something else for you right so
177:06 - that is how you use functions over here
177:09 - so let's now talk about how to work with
177:13 - functions how to define functions in CPS
177:15 - plus so in this video we will be just
177:18 - looking at one definition of a function
177:20 - the subsequent videos will be exploring
177:22 - more on these so a very basic
177:25 - implementation of function is that
177:27 - it won't take any inputs and then it
177:29 - won't give any output right so that is a
177:33 - very basic implementation of function so
177:35 - how you represent number of inputs and
177:39 - number of outputs and how you define a
177:41 - function as in this way so first thing
177:43 - is you write the return type of the
177:46 - function so what is a return type return
177:48 - type is basically what data it is going
177:51 - to give out after performing the job so
177:54 - if in case it's not giving anything you
177:57 - have a data type for that also right so
177:58 - remember from the data type video it is
178:01 - void so if you don't have anything to
178:03 - return you are just going to mention it
178:05 - as world and if you have anything to
178:07 - return you are going to put it as it so
178:09 - here now if you have a question why this
178:12 - particular main function is end if we
178:15 - execute this code you will be getting
178:16 - some code over there right so if you
178:18 - remember let me just quickly execute
178:20 - this code
178:22 - if I build and run this so let's say 12
178:25 - 12 and then 24 okay I'm executing this
178:29 - for 12 times 10 times let me just remove
178:32 - this particular Loop and then this one
178:35 - also
178:40 - I'll equal so here if you see it it
178:43 - returned with some code right that is
178:45 - zero so that is from this particular
178:48 - main function so that is why you were
178:50 - first writing return zero remember when
178:53 - the code block gave you the template
178:54 - code it had this return 0 over here so
178:57 - in case some anomaly happens while
178:59 - execution it will give different return
179:02 - codes that is -1 or something like that
179:05 - so those codes mean that your program
179:07 - did not end correctly if it successfully
179:10 - reached return 0 it means that your code
179:13 - run successfully and then 0 means no
179:16 - errors
179:17 - so that is why we uh use this written
179:21 - zero so even if we omit it from this
179:23 - particular main function it it does not
179:26 - matter because main is designed to
179:28 - return 0 when it's successfully executed
179:30 - for our functions we need to definitely
179:33 - return something if we put some other
179:35 - variable type
179:37 - I mean the return type except void so if
179:40 - you write something like int let's say
179:42 - add or float add or whatever it is if
179:46 - you write some other data type over here
179:48 - you need to return a data of that
179:50 - particular type to the function which is
179:53 - calling it right so
179:56 - that will be looking later so first we
179:59 - will understand how to work with
180:00 - functions which takes zero inputs and
180:03 - then zero outputs so let me write it
180:05 - over here it takes zero inputs and then
180:08 - oh
180:10 - zero input and zero outputs
180:14 - right so output I mean the returns so
180:18 - it it is going to give some output I'm
180:20 - just going to put everything inside the
180:21 - function so it is going to give you some
180:23 - output output as something on the screen
180:25 - return is something where you get back
180:28 - something right so like y equal to f of
180:30 - x you are going to get some value of y
180:33 - right so I'm what I'm doing here is I'm
180:36 - just calling f of x I'm not giving any y
180:39 - to that so I won't get any value back
180:41 - but I will get the job done over here so
180:45 - here for zero inputs I need to put y
180:48 - because I'm not going sorry for zero
180:50 - returns I need to put void because I'm
180:52 - not going to give out anything to the
180:54 - function and then for inputs I'm just
180:57 - going to leave it blank right so you
180:59 - need to put the parenthesis this
181:01 - parenthesis is exactly the same thing as
181:04 - your mathematical parenthesis inside
181:06 - that course all the arguments you are
181:09 - going to pass in through arguments or
181:11 - the inputs you are going to pass through
181:13 - the particular function for which you
181:15 - need a particular output right so I'm
181:17 - not going to pass in any input for now
181:20 - and then the way you Define function is
181:22 - you put this block right
181:25 - so notice that I'm writing the function
181:27 - outside this main function because this
181:29 - is a separate function and this becomes
181:31 - another function so if you can write
181:33 - inside this particular main function
181:35 - also but that is a bit clumsier and it
181:40 - has its own problems we will be talking
181:42 - about that at a later stage so for now
181:45 - we are going to write all our functions
181:47 - outside the main function right
181:50 - so you need to give a meaningful name to
181:52 - the function right so I forgot to
181:54 - mention about this this is the function
181:55 - name so you need to give some name which
181:58 - says what the function is doing you
182:01 - can't just give something like let's say
182:03 - x y z
182:05 - so something like that so you you
182:07 - yourself won't understand what you are
182:09 - going to do with that particular
182:10 - function so you need to give some value
182:12 - name so that you understand what that
182:15 - function is doing and it has some
182:17 - meaning related to what it's actually
182:19 - doing right so now what I'm going to do
182:22 - is I'm going to just cut everything from
182:24 - here and then put it inside this right
182:27 - so what it means is if I call add all
182:30 - this function all these statements are
182:32 - going to get executed right so how do we
182:35 - call that function we don't have any
182:38 - output right so I can't call something
182:40 - like y equal to add right because I'm
182:43 - not giving any return types I'm just uh
182:46 - putting it as white void means once the
182:49 - job is done it will go come back over
182:51 - here without returning anything
182:52 - returning this it's just going to give
182:55 - you some value right so it's not going
182:57 - to do that it is just going to continue
182:59 - with the flow so I'm not going to
183:01 - mention anything over here but just call
183:03 - add and then put a semicolon over here
183:06 - so notice this is the this is called the
183:09 - definition of the function so that is uh
183:12 - let me write it over here
183:14 - function definition
183:17 - and this one is called the function call
183:20 - right let us look at the execution it's
183:23 - going to do the same exact thing it is
183:25 - going to ask for two numbers and then
183:27 - it's going to return with the output so
183:29 - now if you look at the main function
183:31 - it's much more readable right you
183:33 - understand that you are actually adding
183:34 - two numbers so if we just look at this
183:37 - particular code it will be easier for
183:40 - you to understand as well as debug let's
183:42 - say you are writing a very big program
183:44 - where a particular part had a mistake
183:47 - and then instead of tracing the whole
183:49 - program you could actually trace the
183:50 - only this particular part of the program
183:53 - right suppose let's say I did not write
183:56 - the logic properly I put minus over here
183:59 - and once I execute I will get to know
184:01 - that instead of adding it is actually
184:03 - subtracting so I'll come back over here
184:05 - I'll just change this particular thing
184:06 - and then the job is done it is error
184:09 - free right so that is why we use
184:12 - functions and this particular approach
184:14 - is actually called procedural
184:16 - programming so what we are doing is we
184:18 - are dividing um our particular problem
184:21 - into procedures so procedures are
184:24 - nothing but functions and then we are
184:26 - actually solving everything on its own
184:29 - and then we are actually combining
184:30 - everything and then giving out the
184:32 - result so that is what procedure
184:34 - programming is and that is how we use
184:36 - functions in C plus plus so now if I
184:39 - just remove this particular thing and
184:41 - then put it over here right after the
184:44 - main function now what will happen is if
184:46 - I try to execute it you will be seeing
184:48 - that I have an error so what is that it
184:50 - says add was not declared in the scope
184:52 - what it means is that this particular ad
184:56 - it doesn't know that there is something
184:58 - called add in the particular program
185:01 - because add is defined by us right it is
185:04 - not a property of the compiler it
185:06 - doesn't know what address we actually
185:08 - mentioned that we are going to use
185:10 - something called add and add means you
185:12 - need to do all these things right so
185:15 - actually tells something like that you
185:18 - can either Define the functions before
185:21 - the main so that is as I executed right
185:24 - now another thing is that you have
185:26 - something called the Prototype process
185:28 - function so what a prototype message you
185:31 - put the return type of the functions
185:34 - and then the function name
185:36 - and then inside a pair of pencils the
185:38 - parameters list
185:40 - whatever you are going to use as the
185:44 - parameters for the vertical function and
185:46 - then you put a semicolon so it's just
185:48 - like uh popping this particular thing
185:50 - and then pasting it over here so one
185:53 - thing is that is of parameters you don't
185:55 - have to write the variable names to but
185:57 - since I have not discussed about the
185:58 - parameters I will be discussing about
186:00 - them in the next video so at that time
186:03 - we will be seeing that in the Prototype
186:04 - of a function we don't have to actually
186:06 - put in the variable names too we just
186:09 - have to put in the data type so for now
186:11 - we are not going to have any inputs
186:13 - right so we're just going to put this
186:16 - over here and then put a semicolon over
186:18 - here so what this does is it is called
186:21 - the Prototype and it will tell the
186:24 - compiler that hey I have a function
186:26 - called add so whenever you have an ad
186:29 - over here you need to refer to this
186:32 - particular add function so whenever I
186:34 - have uh something called add over here I
186:37 - need to refer back to this particular
186:39 - function which is actually the body of
186:43 - that function the definition of that
186:45 - function so whenever ad is called you
186:48 - need to execute all the statements line
186:50 - by line if I now execute it I will be
186:52 - getting an error free program so I can
186:54 - write something and then I'll be getting
186:56 - the output in the previous video we saw
186:59 - how to create an independent function
187:00 - right so this add function right here
187:03 - this is an independent function all it
187:05 - means is it is not going to take any
187:07 - inputs and it is not going to return you
187:09 - anything it just performs the task which
187:12 - it has to do when called that's it so in
187:15 - this video we will learn how to create
187:17 - dependent functions most of the time
187:19 - we'll be using dependent functions we
187:21 - will be using these kinds of functions
187:23 - also but
187:25 - these are very rare we will mostly use
187:28 - dependent functions we just pass it some
187:30 - parameters we ask the function to do
187:32 - something and then get back the value
187:34 - which we intended to so
187:37 - uh how to make this particular function
187:40 - dependent that is I need to pass in some
187:42 - parameters over here let's say 2 comma 3
187:45 - and then it should only add these two
187:47 - numbers it should not ask the user to
187:50 - enter two numbers and then only work on
187:53 - those two numbers I want to work on
187:56 - these two numbers which I passed in as
187:57 - parameters so how do we get these two
188:00 - numbers inside this function so the way
188:02 - we do that is we Define the parameters
188:04 - the way we Define parameters is we first
188:07 - put the data type of the parameter and
188:10 - then the name right so in this case uh
188:14 - the data type would be end and then the
188:16 - name of the parameter let's just say
188:18 - num1 right and then we have another
188:21 - integer so if you do like this like you
188:24 - declare variables sometimes you do this
188:27 - right so int a comma B well this is
188:30 - going to work only if you are declaring
188:32 - variables here you are not declaring
188:34 - variables here you are specifying the
188:36 - parameters right so while specifying the
188:38 - parameters it is compulsory that every
188:41 - parameter be mentioned along with its
188:43 - data type so you need to mention the
188:45 - data type of the second parameter also
188:47 - even though both the parameters belong
188:49 - to the same data type you cannot omit
188:52 - the data type of the second because it's
188:54 - just a continuation of the variable
188:56 - declaration now what we are going to do
188:58 - is we got the two numbers inside this
189:01 - and we don't need any of this right I'm
189:04 - just going to take out these things and
189:06 - then here instead of a plus pu those two
189:08 - numbers are number and num2 so you take
189:11 - num1 over here and then num2 over here
189:14 - and then it is just going to print out
189:16 - the sum so let us execute this and see
189:18 - so 2 plus 3 is 5 so we should be getting
189:21 - the sum is 5 as our output so here you
189:24 - can see the submissive right
189:27 - so another thing you can do is
189:29 - if you want to save this particular
189:32 - value that is if I want to add these two
189:35 - numbers and then keep the result there
189:37 - is no way to keep the result right well
189:39 - C contains the result of num1 plus num2
189:42 - but C is not accessible outside this
189:44 - function right and is one function and
189:48 - then main is another function well if
189:50 - you want to access this particular
189:51 - variable you need to make it Global that
189:53 - is you want you have to put it outside
189:56 - all the functions and then access it if
189:59 - you remove this then now C is accessible
190:02 - over here you could just say CLC over
190:04 - here and then if you executed here you
190:08 - can see it has printed the value of C
190:11 - but what happens is we don't prefer this
190:15 - kind of global variables the reason is
190:18 - that when whenever the program is
190:20 - getting executed everything is inside
190:22 - the ram that is the random access memory
190:24 - so once variables are out of scope they
190:28 - are automatically deleted and then again
190:31 - created whenever the time comes you need
190:33 - to free up the memory so that other
190:35 - tasks can go on right you cannot just
190:37 - keep this particular variable in the
190:39 - memory all the time so if it is
190:41 - compulsory that you need to keep it then
190:43 - you can but if there are other ways to
190:46 - do that without occupying that
190:48 - particular memory you need not do this
190:50 - because it takes up memory right so the
190:53 - way we do that is we return this
190:56 - particular value back to the calling
190:58 - function so what is written how do you
191:00 - return something to the calling function
191:03 - well the way you do that is you just
191:06 - need to put the return statement over
191:08 - here so you just say return C now
191:11 - instead of creating a global variable
191:13 - like I did before you don't have to
191:15 - actually create something and put it in
191:18 - a memory once you have executed it you
191:21 - can just return that particular value
191:22 - over here so that is the main objective
191:25 - of this add function right you need to
191:27 - take in two numbers add it and you are
191:29 - going to get one integer unit just
191:31 - return it so if I say something like a
191:34 - equal to or let's say sum equal to add 2
191:38 - comma 3 uh what to expect is these two
191:41 - numbers are added on the sum is coming
191:43 - to this particular variable that is sum
191:46 - right
191:47 - so here if I return it I'll be getting a
191:50 - problem so if I now execute it uh you
191:53 - will see that I have got a problem it
191:55 - says Okay C is not that's because I have
191:57 - written over here uh now let's again run
192:00 - it so here you can see that it says
192:02 - return statement with a value in a
192:04 - function containing void right returning
192:07 - void so as I told you before if you are
192:10 - not returning anything then only you
192:11 - need to use the void keyword or else you
192:13 - have to specify the data type what you
192:15 - are going to return so since I'm
192:17 - returning something I need to specify
192:19 - the data type and in my case it's going
192:21 - to be it because if you add two integers
192:23 - it's going to be integer right so I'm
192:25 - just going to return that particular
192:27 - integer and then here I need to capture
192:30 - that value so let's say In Sum equal to
192:33 - 2 comma 3 and then now I can
192:36 - do this thing
192:38 - inside the main function also so here I
192:42 - will just paste it and sumness in my
192:44 - case sum
192:45 - right now if I execute it we'll be
192:48 - getting the output as the sum S5 so
192:51 - another thing is what if we want to make
192:55 - one of the variable optional so let's
192:58 - say I have another field Also let's say
193:00 - in num3 this is another parameter so
193:04 - here if I just omit that parameter I'll
193:06 - be getting an error so here you can see
193:07 - that too few arguments to this function
193:10 - that is because I have specified three
193:12 - arguments and then here I'm giving only
193:15 - two arguments so what you need to do is
193:17 - if you are having an optional variable
193:20 - you can just put a default value over
193:23 - there so for addition if the default
193:26 - value is 0 if you add those three
193:28 - numbers there's no there's not going to
193:30 - be any difference right so if you just
193:32 - put 0 over here and then I don't pass
193:34 - anything so it will just do six plus two
193:37 - so let me just add the number over here
193:39 - so so num3 also so I'm just going to
193:42 - store c equal to num1 plus num2 plus
193:44 - num3 and then I'm going going to return
193:46 - C
193:47 - so now if I execute it you will won't be
193:50 - getting any error and you will be
193:51 - getting the sum perfectly and if I want
193:54 - to use that variable I don't have to do
193:55 - anything I just pass the number and I
193:57 - will be getting the output so 9 8 is 17
194:00 - so here you can this sum is 17. so
194:03 - that's how you use default parameters
194:05 - and regarding the Prototype so what is a
194:08 - prototype it is just mentioning the
194:11 - compiler that I do have a function like
194:13 - that in case you did not write the
194:15 - functions definition before calling it
194:18 - so whatever means I have already called
194:20 - this function over here so if I write
194:23 - the definition after calling it I need
194:26 - to specify it or it says that this
194:28 - particular function does not exist so to
194:31 - do that the for the Prototype as I told
194:33 - you you can directly copy paste this
194:35 - thing
194:36 - so Ctrl C and Ctrl V
194:39 - and then put a semicolon this is going
194:41 - to work but what you can do is in case
194:44 - of parameters function you don't have to
194:46 - write the variable names also so you can
194:48 - just skip these things well it's going
194:51 - to work with the variable names also but
194:53 - uh you don't have to put them and you
194:55 - should not pull default values over here
194:58 - so that is there in the function
194:59 - definition in the Prototype you just
195:02 - need to define the structure of the
195:03 - function and you don't have to put the
195:06 - default values and all you just need to
195:07 - put what the function is and what it's
195:09 - going to take and now if I execute it I
195:12 - won't be getting that any error and I
195:14 - will be getting the output so that's how
195:16 - you use dependent functions in C plus
195:18 - plus in the next video we will talk
195:20 - about recursion and different types of
195:23 - passing arguments so here I just pass
195:26 - some numbers right so these are direct
195:29 - numbers so what if I want to pass some
195:31 - variables also so let's say a equal to 2
195:34 - well in this particular case you can
195:36 - just pass it over here it is going to
195:39 - work well it's int a equal to 2 it is
195:42 - going to work but actually there is a
195:44 - meaning for passing like this there are
195:46 - two methods of passing variables that is
195:48 - passing by value and passing by
195:50 - reference in this video we'll be looking
195:52 - at different methods to call functions
195:55 - in C plus plus so now the question is
195:57 - why do we need different methods to call
196:00 - functions why calling function simply
196:02 - like this won't work always so to answer
196:06 - that question let us take another
196:07 - problem so let's say this time we need
196:10 - to write a function to swap the values
196:13 - of two numbers so what I mean is if I
196:16 - now print a and then B like this what I
196:20 - will be getting as my output is to comma
196:23 - 8 right because a value of a is 2 and
196:25 - value of piece 8. now what you want to
196:27 - do is I want to call a function so let's
196:30 - call that function something let's say
196:32 - uh swap nums so I want to call this
196:36 - vapnams function by passing in a and b i
196:39 - and then here if I then print this
196:42 - particular A and B's value what I should
196:45 - be getting is I should be getting 8
196:46 - comma 2 that is a is holding the value
196:49 - of B now and then B should be holding
196:52 - the value of a now so let us first try
196:55 - to solve this without a function so to
196:58 - do that first of all we need a temporary
197:00 - variable because once we overwrite a
197:02 - value uh it's gone right so I want to
197:05 - preserve both the values so that I can
197:07 - reassign them so let's say uh
197:10 - pin temp will hold the value of a and
197:13 - then I'm going to reassign the value of
197:15 - a to B and then now since I need the
197:17 - value of a it is already stored in temp
197:20 - the previous value of a so that I can
197:22 - just put it inside the B right so now if
197:26 - I now execute this particular code I
197:28 - will be getting my desired output so now
197:30 - a has become 8 and then B has become 2.
197:34 - now what if I want to Define this as a
197:37 - function so since we are not returning
197:39 - anything it's going to be void
197:42 - right and then uh those two parameters
197:46 - remain the same the name of the function
197:47 - is web nums so swap underscore nums and
197:51 - then this is the logic which goes inside
197:53 - that so control X and then return goes
197:57 - away and then here we have that
197:58 - particular logic so now if I now call
198:01 - this particular function
198:03 - and then try to execute this particular
198:06 - code you will be surprised that nothing
198:09 - happened over here it still is to commit
198:11 - a s value did not change neither did B's
198:14 - so now why did that happen that is
198:17 - because this A and B are not the same
198:20 - ones as this A and B these two are
198:22 - different variables actually even though
198:25 - the name of the variable is same but
198:27 - this particular variable which I have
198:29 - defined over here all the set of
198:31 - variables these belongs to this
198:34 - particular function that is the swap
198:36 - nums function and these two variables
198:38 - belong to this main function so I cannot
198:42 - use this particular variable here or
198:44 - this particular variable here so
198:47 - if if I try to print the values inside
198:49 - this that is uh if I print out a and b
198:54 - inside this particular function it will
198:56 - be swapped over here that is these two A
198:59 - and B are actually so I am not this A
199:01 - and B so to differentiate that let me
199:03 - just put a function over here so that we
199:05 - can differentiate the output of our
199:07 - function from the main and then I will
199:09 - even add an end line over here now if I
199:12 - execute this code
199:14 - so here you can see that in inside the
199:16 - function A and B got swapped correctly
199:19 - that uh a got the value of 8 and then B
199:22 - got the value of 2 but I'll check the
199:24 - function in the main function it did not
199:26 - happen so how do we solve that
199:28 - particular problem well
199:30 - to change these numbers directly or one
199:34 - way is that we can declare declare this
199:36 - as Global variables that is outside all
199:38 - the functions so that this will be
199:40 - always present in the memory but that is
199:43 - as I told in the previous video it is
199:45 - completely uh waste of memory so another
199:49 - way is to do that is we can directly
199:52 - change this particular variable by
199:55 - referencing it that is by going into the
199:57 - address of that variable every variable
200:00 - has addressed in the memory right we are
200:02 - just creating a location inside the
200:04 - memory and then renaming it to A and B
200:07 - over here so if we can access the
200:09 - address of this A and B we can go to
200:12 - that particular address and then change
200:13 - that particular value so in that way we
200:16 - won't be actually copying down this
200:18 - values inside new values over here and
200:21 - then working on those new values that is
200:23 - what is happening over here right once
200:25 - we pass in two numbers what is happening
200:27 - is these two variables are dynamically
200:30 - created in a member query and then these
200:32 - values are getting copied inside these
200:34 - values and whatever happens inside the
200:36 - functions happens on this particular
200:38 - local variables so variables which are
200:40 - actually called from the main function
200:42 - are not going to be affected by this
200:45 - function so whatever you do inside this
200:47 - function that remains local to those two
200:49 - variables only or those set of variables
200:52 - so to actually access the address of a
200:56 - location we need to understand a
200:58 - particular operator called the address
201:00 - operator
201:01 - or the reference operator or the
201:03 - Ampersand operator they are called in
201:05 - different ways so what it is is you just
201:08 - need to put an ampersand over here to
201:10 - access a address of a particular
201:12 - variable so now if I just execute it
201:14 - what you will be seeing is the address
201:16 - of that particular variable so here you
201:18 - can see 0x CD whatever it is that is the
201:21 - hexadecimal address of this particular
201:23 - variable that is a now B will have
201:26 - another address so if I now put B over
201:29 - here let me just close this and then if
201:32 - I now execute it
201:34 - so here you will be seeing 0 x 6 D
201:38 - whatever it is it is another address
201:40 - right both are at different locations so
201:43 - now what we are going to do is instead
201:46 - of passing the values inside this we are
201:48 - going to pass the address over here so
201:51 - that it knows that it needs to work on
201:52 - those addresses only so here instead of
201:55 - declaring variables like int a and then
201:58 - end B what I'm going to do is I am going
202:00 - to specify that we are going to get the
202:02 - address of a and b or any variable you
202:05 - can put X and Y over here it doesn't
202:07 - matter what what it specifically means
202:10 - is that you are going to get variables
202:12 - address and you need to work on that
202:14 - particular address only you don't have
202:16 - to create a new variable that's what
202:18 - this particular and means you can put
202:20 - any name over here it doesn't matter so
202:23 - now what happens is if I now call the uh
202:27 - function and then here if I just put
202:30 - this particular uh line over here so let
202:33 - me just replace this line
202:35 - and then uh let's say main right
202:39 - now if I now execute this particular
202:41 - code you will be seeing that in the
202:44 - function it got swapped and now in the
202:47 - main function also it got swept now a is
202:49 - holding the value of 8 and then B is
202:52 - holding the value of 2. so this is why
202:55 - we need different methods to call
202:56 - functions and basically there are only
202:59 - two methods to call functions one which
203:01 - we do always that is simply passing the
203:04 - values and then the other one is by
203:06 - passing the address so those are the two
203:08 - methods to call functions and they are
203:11 - actually named in that way only so one
203:14 - is called by value in which you just
203:16 - call using the normal method that is you
203:19 - just pass in the values over here and
203:21 - then the values get copied and then you
203:24 - get all the output which you required so
203:27 - this particular method is used only when
203:29 - you don't really care about changing the
203:32 - values in the main method or whatever it
203:35 - is the main particular value which are
203:37 - going to pass inside the function if you
203:39 - don't don't want to change that
203:41 - particular value but only want to do
203:43 - some computation with that value such uh
203:46 - functions are better to use that is
203:49 - called by value functions and when you
203:51 - want to change the value what you do is
203:53 - called by a reference so reference means
203:55 - address and the way you call by
203:58 - reference is in this way so you need to
204:01 - pass the ampersion symbol to specify
204:03 - that you are going to work with the
204:05 - address of that particular variable and
204:07 - not with the value of that variable so
204:10 - it knows that it doesn't have to create
204:11 - another variable and then copy that
204:13 - function but what it will do is it will
204:15 - directly go to that address and then
204:17 - carry out all the operations which is
204:19 - specified right so now instead of
204:22 - putting B and B over here I can even put
204:24 - B you can use combinations it totally
204:27 - depends upon the work of the particular
204:30 - function so since I had to change both
204:32 - the variables that is why I had to put
204:34 - and in both the variables if I want to
204:37 - change only a and not B now if you
204:40 - execute this function you will be seeing
204:42 - that a has changed to 8 and then B
204:45 - remains 8 inside the main function that
204:47 - is because I did not pass in b as an
204:50 - address but I passed in b as a value so
204:52 - that is how calling functions in
204:55 - different methods work and those two
204:56 - methods are called by value and call by
204:58 - reference in this video we will be
205:00 - looking at the equation so what is
205:02 - Recreation
205:03 - well the recursion is nothing but a
205:05 - method which we use to solve problems
205:07 - where if you manage to break that
205:10 - particular problem down into a set of
205:11 - simpler problems what you will observe
205:14 - is that those set of simpler problems
205:16 - are nothing but a simplified version or
205:19 - you can say miniature version of the
205:20 - main problem itself so let's take an
205:23 - example to understand it better
205:25 - so recursion
205:27 - so let's say we want to write a function
205:29 - called sum of N which will return us
205:32 - let's say the sum of natural numbers up
205:35 - to n so what you need is 1 plus 2 plus 3
205:37 - uh up to n so this is the value which we
205:41 - intend to return When sum of N is called
205:43 - now there are different methods to solve
205:46 - this problem one is a pretty naive
205:48 - approach so method one is nothing but by
205:50 - using looping right so everybody is
205:53 - familiar with this kind of approach what
205:55 - we have is we have some variable to
205:57 - handle the overall sum and then we will
206:01 - loop from the starting value till the
206:04 - ending value that is from 1 to n
206:07 - and
206:08 - while going through each value we'll
206:10 - just add that value to the overall sum
206:12 - and in the end we'll just return the
206:15 - value of sum so this is one of the
206:16 - method to solve this particular problem
206:19 - and the other method is by using a
206:22 - concept of mathematics called arithmetic
206:26 - progression or AP
206:29 - well I'm not going to go into the
206:31 - details of arithmetic progression that's
206:35 - a very beautiful concept and I encourage
206:37 - you to look that up in the internet but
206:39 - for now what we are interested in is how
206:42 - we can get the sum of N terms in an
206:45 - arithmetic progression or in AP
206:47 - well uh the formula for getting sum of N
206:51 - terms in an AP is n by 2 times 2 into a
206:56 - plus n minus 1 times D so this is the
207:01 - formula for getting the sum of N terms
207:03 - in an AP again I'm not going to go into
207:06 - the details of this formula you can
207:08 - again go and look that up now
207:12 - a is nothing but the first term of the
207:15 - series so in here the first term is
207:17 - nothing but 1 so 2 into 1 and then D is
207:20 - nothing but the dormant difference
207:22 - between two consecutive terms in the
207:24 - series so we need to constitute the
207:27 - terms you can take and then you can see
207:29 - that the difference is one so we can
207:31 - just substitute it over here and if you
207:33 - solve this if you simplify this you will
207:35 - be getting this particular result n into
207:37 - n plus 1
207:39 - over 2 so this is the result we will be
207:42 - getting after simplifying this equation
207:44 - now if you just plug in the value of N
207:47 - and you can just return this particular
207:50 - value you don't have to loop around and
207:52 - then keep another variable and all this
207:55 - stuff this is the most efficient way to
207:57 - solve this particular problem
207:59 - now we'll be looking at another approach
208:03 - to solve this particular problem
208:05 - no
208:07 - let me just clear this thing let's say
208:09 - we want to calculate the sum of uh some
208:12 - number let's say 10 so sum of 10. now
208:15 - what is sum of 10 it is nothing but 1
208:17 - plus 2 plus 3 all the way up to 10. now
208:21 - we can also write this as 10 plus 9 plus
208:24 - 8 plus all the way up to one I just
208:27 - reverse this particular order now if You
208:29 - observe what if you upload this
208:31 - particular value what is this this is
208:34 - nothing but sum of 9 because sum of
208:36 - then when it goes from 10 to 1 sum of 9
208:40 - should go from 9 to 1 so this is nothing
208:42 - but 10 less sum of 9
208:45 - now again if You observe this particular
208:47 - value this is nothing but sum of 8 so
208:50 - this is nothing but 10 plus 9 plus sum
208:52 - of 8
208:54 - so in a nutshell if you want to uh just
208:58 - generalize this you can say that sum of
209:00 - N is nothing but n plus sum of N minus
209:04 - 1. right and now this particular
209:08 - relation If You observe you are broken
209:09 - down this particular problem into a set
209:12 - of simpler problems and this problem is
209:15 - nothing but a simplified version of this
209:17 - problem so this is what is called
209:20 - recursion
209:21 - now before trying to code this thing we
209:25 - need to understand that recursion should
209:27 - have a limit now if you reach 1 so what
209:31 - will happen is it will try to find the
209:33 - sum of uh one and then here when it goes
209:36 - it will try to find the sum of 0 and it
209:40 - will go on up to negative Infinity right
209:42 - it will just go on and then once it
209:45 - reaches a stage where it has reached the
209:48 - extreme of the integer range or any data
209:51 - type you have kept over here it's going
209:54 - to stop and then it's going to throw you
209:55 - an error so the question should always
209:58 - have a limit so that limit is called as
210:01 - the recursion limit and it is really
210:05 - important that you should mention a
210:07 - requestion limit when you are using a
210:09 - recursive function the trigger shouldn't
210:12 - call or what you are doing is here you
210:15 - are just calling that function again
210:16 - right so this call should end somewhere
210:19 - so that somewhere is nothing but the
210:22 - recursion limit so now in this
210:24 - particular problem when you reach one
210:26 - you don't have to again call this
210:28 - particular value right because you have
210:30 - reached a saturation stage where sum of
210:33 - 1 is nothing but one so once you reach
210:36 - one you can just return one over there
210:39 - so the recursion limit for this
210:41 - particular problem is nothing but one
210:44 - so now let us code this so the return
210:46 - type is end and then the function's name
210:49 - is sum and then you have variable called
210:52 - n
210:53 - and here
210:55 - we what we need to return is return n
210:58 - plus sum of N minus 1 as I've just
211:01 - discussed before and before that we need
211:03 - to check whether we have reached a
211:05 - recursion limit or not so what is the
211:07 - recursion limit if n equal to 1 then
211:09 - what we need to do we just need to
211:11 - return one or else we need to return
211:13 - this so else written n plus sum of N
211:16 - minus 1 so that's all now we can just
211:19 - test this function C out sum of 10
211:22 - and once you run this you will be
211:24 - getting 55 Sr output
211:27 - so that is the correct value of sum of N
211:30 - and that's how Recreation works now this
211:33 - is a very bad example to actually
211:35 - explain recursion because recursion is
211:39 - not generally used where it is not
211:41 - needed so the question actually takes up
211:43 - lots of memory so Here If You observe if
211:46 - I just call it with a value 10 it is
211:48 - going to again call this particular
211:51 - function with the value 9 and again 8
211:53 - again 7 and so on so every time it calls
211:56 - a new value of n is created so
211:59 - what is happening is effectively if you
212:01 - calculate the space of a space required
212:04 - for running this particular problem
212:06 - uh so for n equal to 10 it is taking 4
212:11 - into 10 bytes right 4 is nothing but 4
212:15 - bytes which is the size of an integer
212:18 - and then 10 is because it's getting
212:20 - called 10 times so this is effectively
212:22 - 40 bytes of memory
212:25 - right
212:27 - and if you take the first case let me
212:29 - write this this is the third case right
212:31 - this is by using recursion
212:33 - now first case if You observe just by
212:36 - using looping what we are doing is we
212:39 - have three variables that is sum n and
212:42 - then I so it is nothing but 3 into 4
212:45 - which is 12 bytes now that has
212:47 - drastically reduce the num size right
212:49 - and then if you now look at 2 it is
212:52 - nothing but only four bytes of memory
212:55 - because we are not having any extra
212:57 - variable we are just using n and then we
213:00 - are just plugging it into an equation to
213:01 - get the result so this is the most
213:03 - effective way and this is a better way
213:06 - and this is the worst way to solve this
213:08 - problem but since this particular
213:11 - approach is easier to understand I had
213:13 - taken this example mostly requestion is
213:16 - used where you can't figure out a
213:18 - generalized looping solution to solve a
213:21 - particular problem so that particular
213:24 - example includes uh something like
213:27 - finding let's say paternal ancestor of a
213:30 - guy so let's just take a family tree
213:33 - example well no just search for family
213:35 - trees in the internet and then uh let's
213:39 - take an example let's say okay this one
213:42 - so this one is like a tree so here you
213:45 - can see that uh this is let's say uh Tom
213:49 - and then Tom has a mother and a father
213:51 - and his father again has a father and
213:55 - mother and mother again as a father and
213:56 - mother and again that hierarchy
213:58 - continues now if you want to find the
214:01 - paternal ancestor of the storm what you
214:05 - need to do is I need to find the father
214:07 - or father or father or father that's
214:09 - what you need to find right now to find
214:11 - that what we can do is we can just
214:13 - reduce this problem to just look at this
214:16 - particular generation that is only one
214:18 - generation if you take this one
214:20 - generation what we need to do is we just
214:21 - need to move to the father so let's say
214:24 - we need to move to left side of this
214:26 - particular hierarchy because right side
214:29 - is Mother Let's just assume like that
214:31 - for now right side is always mother and
214:33 - then left side is always father so here
214:35 - if we just take this particular
214:37 - generation we need to move to the left
214:38 - side and again if you just break this
214:40 - problem down here if you take this
214:43 - particular generation we again need to
214:44 - move the left and this particular
214:46 - generation we again need to move to left
214:48 - and once we have reached a stage where
214:50 - uh that particular guy doesn't have a
214:54 - father then he's the ancestor right so
214:57 - this fellow let's say John is the
215:00 - ancestor of Kim so though in such cases
215:02 - the question will be useful
215:04 - so that's all for recreation in this
215:07 - video we'll be looking at a race so till
215:10 - now we have been working with programs
215:12 - where we already knew the number of
215:14 - inputs right so we knew the space
215:17 - required for our programs to work and
215:19 - all the stuff so let's consider a
215:21 - program where we don't know how many
215:24 - inputs we need to store so something
215:26 - like this this is a code snippet which
215:29 - is basically taking in record let's say
215:32 - Student Records so every student has a
215:34 - name and age and then the user gets to
215:36 - enter how many records he wants to enter
215:38 - and then we are going to take in the
215:40 - records now if you run this program uh
215:44 - you can see that the program doesn't
215:45 - crash right so if I say I want to enter
215:48 - three records it's going to take in
215:50 - three records so A1 B2
215:52 - C3 so you can see that the records are
215:56 - taken successfully but if you look at
215:59 - this more closely you see that those
216:02 - records are not getting saved anywhere
216:04 - right those things are just getting
216:06 - overwritten every time now
216:09 - there is no way that we know how many
216:12 - records the user is going to enter right
216:14 - it completely depends on the user so how
216:17 - are we actually going to store all the
216:19 - records we can only store the last
216:22 - record in this way but all the previous
216:24 - records are getting lost right so how
216:27 - can we store all the data so that no
216:30 - data is lost and also we don't limit the
216:34 - number of records and the user gets to
216:37 - enter as many records as you want so it
216:40 - turns out that you cannot Define the
216:42 - number of variables or not the space you
216:45 - want at runtime but you can define a
216:48 - collection of space in one time so let
216:51 - me illustrate to you what I mean so
216:53 - let's say the user wants to enter some
216:57 - number of Records let's say uh five
217:00 - records so if you consider this white
217:03 - space as the computer's memory so what
217:07 - will be effectively doing is we will be
217:09 - creating collections of variables so we
217:12 - have two variables over here right so we
217:14 - have one name and then you have an age
217:17 - right so what you will be doing is
217:20 - instead of creating different variables
217:22 - like name one name two and so on we'll
217:25 - be creating a collection of variables
217:28 - something like this and then inside this
217:30 - collection what we will be doing is we
217:32 - will be separating this collection I
217:34 - mean we'll be creating partitions inside
217:36 - this collection so let's say the user
217:39 - wants to enter file record so what we do
217:41 - is we create a collection and then make
217:43 - five partitions into it so you have five
217:46 - partitions over here so all of them are
217:48 - obviously they are of the same size and
217:51 - then age also you will be giving five
217:53 - partitions so
217:57 - like this right so now what happens is
218:00 - once the user gets to enter the records
218:03 - you will be entering into that
218:05 - particular area which is assigned for
218:09 - every particular record so let's say for
218:11 - the first record you entered the data
218:13 - into the first box and then for the
218:15 - second record you enter it into the
218:16 - second partition so the third because
218:19 - you enter it in the third partition so
218:21 - and so on so this particular kind of
218:24 - process you will continue so that you
218:27 - can enter all the records and then you
218:29 - can also access this records by just
218:30 - accessing the partitions right so this
218:33 - is how arrays work well Iris literally
218:36 - mean collection of objects and that is
218:39 - what it means in programming too so what
218:42 - you are basically doing is instead of
218:44 - creating any number of variables you
218:47 - will just create this memory space which
218:49 - is capable of holding any number of
218:50 - variables and then create partitions
218:52 - into it so once you create partitions
218:55 - you can add data into it and then it you
218:58 - can retrieve it you can perform
218:59 - operations on it just like variables so
219:02 - basically you can think of array as a
219:04 - collection of variables but it's not
219:06 - actually a collection of variables it's
219:08 - just a collection of memory so if you
219:12 - take this particular array if you take
219:13 - the size of this particular array you
219:16 - will see that it is nothing but
219:19 - the number of elements inside it so in
219:21 - this case 5 into the size of each
219:24 - element it inside this so the size of
219:27 - each integer is four bytes so the size
219:29 - of this particular array is going to be
219:31 - 20 bytes so you can see that array is
219:35 - nothing but just a collection of memory
219:38 - or you can say collection of variables
219:40 - and then you can add and retrieve it as
219:42 - you like so let's see how to implement
219:44 - this particular ideology in programming
219:49 - so to implement an array what you need
219:51 - to do is you need to declare an array so
219:55 - how do we declare an array and see
219:56 - questions we don't have to do anything
219:58 - we just need to put square brackets so
220:01 - that this particular variable is
220:03 - addressed as an array by the compiler
220:05 - and then inside this particular brackets
220:09 - you need to specify the number of items
220:11 - the array should be capable of holding
220:13 - so in our case we are going to get the
220:16 - number of Records right so if you give n
220:18 - request you are going to have n names
220:20 - and N edges so the size of our array is
220:23 - nothing but the number of Records right
220:25 - so
220:26 - what you do is you just mention the size
220:29 - inside the square brackets so for the
220:31 - ah2 you are going to do the same thing
220:33 - so age records and then over here what
220:35 - we'll be doing is instead of name we
220:38 - will be accessing the partition now how
220:41 - do we access the partition of an array
220:43 - so for accessing the ith partition
220:48 - or the ith segment of the na or you can
220:51 - say the ith variable which is stored
220:53 - inside the collection you need to access
220:55 - it as the name of the array so array
220:58 - name
220:59 - and then inside pair of square brackets
221:01 - you need to specify the index where this
221:04 - particular index is nothing but I minus
221:07 - 1 so let's say you want to access the
221:09 - first partition of the array so for the
221:11 - first partition you need to give index
221:13 - as I minus 1 which is equal to zero so
221:17 - for the second one you need to give the
221:19 - index of 1 and so on so for the nth
221:21 - partition you will be effectively giving
221:23 - n minus 1 as your index so that is why
221:26 - if you remember I generally start Loops
221:28 - from 0 because it it becomes easier to
221:32 - work with arrays if you are working with
221:35 - Loops which are starting from zero
221:37 - because of this particular rule because
221:39 - the index of an array starts from 0 so I
221:43 - don't have to subtract one from the
221:45 - counter every time I can directly in
221:48 - Access the Partition by just calling the
221:51 - counter now to access this particular
221:54 - partition you don't have to do anything
221:55 - you just need to put the square bracket
221:57 - over here and then access the partition
221:59 - so since I am using a counter over here
222:02 - I'm directly going to access it by the
222:03 - counter and the same thing over here too
222:07 - okay
222:09 - now how do I retrieve it while
222:11 - retrieving also follows the same rule so
222:13 - you need to pass the arrays name and
222:16 - then the index which is nothing but I
222:18 - minus 1 if you want to access the ith
222:20 - partition so let's say we ask the user
222:24 - to retrieve some record let's say which
222:26 - record
222:28 - or do you want
222:30 - three
222:33 - and then the user enters your code so
222:36 - let's say nth record so he wants to
222:38 - retrieve the nth record so we'll be
222:41 - getting the nth record as our input and
222:43 - then what you need to do is you just
222:45 - need to access the nth record as n minus
222:48 - 1 is the same Rule and then for the name
222:52 - and then that goes same for the H2 so we
222:55 - just need to access it by n minus 1. and
222:58 - then if you run it so let me just put
223:00 - the N line over here so here you can see
223:02 - that if I enter some records let's say
223:05 - A1 B2 C3 and then if I want to retrieve
223:09 - the second record you see that the name
223:11 - is B and then the age is two so that's
223:13 - how arrays work that's a recap arrays
223:16 - are nothing but a collection of memory
223:18 - or you can say collection of variables
223:20 - where you can store and retrieve
223:22 - variables as you wish so now what all
223:27 - variations can you do with an array well
223:29 - it turns out that you
223:31 - not only can store collection of
223:34 - variables but you can store collections
223:36 - of collections too so that is basically
223:39 - the dimensions of an area so
223:42 - Dimension basically means collection of
223:47 - collections so basically if I'm saying
223:49 - that an array is one dimension so if I
223:52 - say that array is one dimension it
223:55 - basically means this thing that it it
223:58 - holds the collection
224:00 - now if I see that an array is two
224:03 - dimensional
224:04 - then what it means it it holds a
224:08 - collection
224:09 - of collections
224:11 - so how do we Define this we just put
224:13 - another pair of square brackets over
224:14 - here and then Define the second
224:16 - dimension so this is nothing but a
224:18 - matrix if you have to so if you are
224:20 - familiar with matrices you have some
224:22 - array of numbers right so one two three
224:23 - four
224:25 - four eight nine so if You observe this
224:27 - this whole thing is a collection and
224:30 - three such collections form this
224:32 - particular Matrix so how can you define
224:34 - this you can just Define this acid 3
224:36 - cross 3 array right so if you say this
224:40 - particular thing as a matrix so let's
224:42 - say this this Matrix M which is equal to
224:46 - this thing so if this particular Matrix
224:48 - is this one then it is nothing but a
224:51 - three cross three Matrix right and the
224:53 - way it is defined in the memory is you
224:55 - have this particular
224:57 - collection where inside each collection
224:59 - you have three items so one two three is
225:02 - one collection four five six is another
225:04 - collection and then seven eight nine is
225:06 - another collection and all three form
225:08 - the overall collection so this is how
225:10 - your variable mat is actually defined in
225:15 - the memory well you don't have to always
225:18 - take in input inside an array from the
225:21 - user you can even Define the inputs so
225:24 - how do we Define it well to Define
225:26 - inputs you just need to put a pair of
225:29 - curly brushes and then Define your data
225:31 - so let me just clear this and we'll take
225:34 - some generic examples
225:37 - so let's say our
225:39 - array is a three cross three array so
225:44 - let's just Define that Matrix which we
225:46 - talked about so how do we Define the
225:48 - first we find an overall collection and
225:51 - inside this collection there are going
225:53 - to be three collections so one
225:55 - collection is one two three and then you
225:57 - have the second collection as four five
226:00 - six
226:01 - and then the third collection as seven
226:04 - eight nine so this overall makes three
226:08 - by three Matrix so if you want to access
226:10 - it you can access it using Loops so for
226:12 - end I equal to 0 I is less than three
226:16 - I plus plus and then you need to run
226:19 - another loop for accessing the inner
226:20 - collection so for n j equal to 0 J is
226:24 - less than 3 J plus plus you can just
226:27 - show that element so a of I comma J
226:30 - right let's just give a space over here
226:33 - and then
226:35 - a new line of flow so that it looks like
226:38 - a matrix now if I run this
226:41 - so I forgot to put a come over here
226:46 - yeah so here you can see how 3 cross 3
226:49 - Matrix is defined well you can have
226:51 - collections of collections of collection
226:53 - so that is basically a three dimensional
226:55 - array you can go up to any dimension in
226:58 - a little small limit you can
227:01 - have as many collections of Collections
227:04 - and it completely depends upon your
227:07 - problem so mostly we tend to use this
227:09 - kind of collection which is the Matrix
227:12 - and then the single dimensional array
227:15 - which is nothing but just a collection
227:16 - of data well another point to note that
227:20 - is these collections cannot contain
227:22 - mixed data that is you cannot have both
227:25 - integers and strings in one array so in
227:29 - an array what happens is that particular
227:32 - array will contain data or will contain
227:36 - a collection of data of only that
227:38 - particular data type you cannot change
227:40 - the data type or you cannot have mixed
227:43 - data inside one particular collection so
227:46 - that's how you work with aeration C plus
227:48 - plus you can also pass in arrays to a
227:51 - function but always Aries will be passed
227:54 - as a reference not accept value so if
227:57 - you create a function over here let's
227:58 - say in funk
228:01 - um which just takes in the array so int
228:03 - a and then you need not Define the
228:05 - dimensions if it's just a single
228:07 - Dimension you can just leave it as a
228:09 - square bridge and if it is
228:11 - multi-dimensional then you need to
228:13 - define the last dimension of battery so
228:16 - let's say you are passing a
228:17 - three-dimensional array so then you need
228:19 - to Define the last Dimension which is a
228:22 - third dimension compulsively you cannot
228:25 - omit this Dimension and if you are
228:27 - passing this particular array which is a
228:29 - two dimensional array you need to pass
228:30 - the second dimension which is three you
228:32 - can leave this or you can Define this it
228:34 - really doesn't matter but if you are
228:37 - passing some array which is not single
228:39 - dimensional then you need to pass the
228:42 - last dimension of that particular array
228:45 - so now let us just Define this function
228:48 - let's say uh we don't have to do
228:50 - anything we just uh print the first
228:53 - element of the array so a is 0 0 this is
228:56 - the first element and then what we'll do
228:59 - is we will change that element so we'll
229:01 - change a 0 0 equal to 5.
229:05 - right and then uh I'll just return uh
229:08 - some things let's say it will skip this
229:11 - return we'll just make this void so
229:14 - this avoid function right now if we call
229:17 - this function so if I just say func and
229:20 - then passion a and then we when printing
229:25 - the first element after running this
229:26 - particular function so let's just put n
229:29 - lens over here so that we can
229:30 - differentiate between the output so one
229:33 - over here and then one over here and now
229:35 - if I run this particular program you
229:37 - will see that
229:39 - the value of array 0 0 was 1 which is
229:42 - nothing but this particular element and
229:45 - then if I change that value over here I
229:48 - could change it over here too so in the
229:49 - main thing also it changed so that
229:52 - explains that arrays are not passed by
229:55 - value but they are passed by reference
229:57 - so arrays don't get copied when you pass
229:59 - them to a function but that changed in
230:02 - the memory itself so what you are
230:05 - essentially doing is you're just passing
230:07 - a pointer we will be discussing pointer
230:09 - at a later stage but uh what pointers
230:12 - basically mean is they are nothing but
230:14 - those are variables which carry
230:16 - addresses we will discuss more about
230:18 - pointers at the latest age but for now
230:21 - this is how we use arrays and C plus
230:24 - plus in this video we'll be making our
230:27 - first programming project which is
230:29 - essentially going to be a console based
230:31 - tic-tac-toe game so in case you're not
230:34 - familiar with the game let me just
230:36 - quickly walk you through the game the
230:38 - game has a 3 costly port and two players
230:40 - who play alternatively so the objectives
230:44 - of the players is that they need to fill
230:47 - one of the roles or columns or the
230:49 - diagonals with their marker so if I just
230:51 - start the game with a computer you can
230:53 - see that we are playing alternatively
230:55 - and our goal is to just fill up one of
230:58 - the rows or columns or diagonals with
231:00 - our marker so here if you see the
231:02 - computer has managed to fill the row
231:04 - with its marker so it gets to win the
231:06 - game so we are going to implement this
231:09 - game on the console and well we won't be
231:12 - implementing such a sophisticated system
231:14 - where the computer can play although I
231:16 - will be giving the intuition required
231:18 - for building such a system towards the
231:20 - end but what we will be implementing is
231:23 - a two player game so if you go over here
231:25 - and then change this mode to play
231:27 - against a friend you can see that you
231:29 - make both the moves by yourself so we'll
231:32 - be implementing this but I will also be
231:34 - giving you the intuition required to
231:37 - implement a system which can and think
231:39 - and then make moves towards the end all
231:42 - right so let's get started so first uh
231:46 - create a new project naming Tic Tac Toe
231:49 - so the project title is Tick type 2 and
231:53 - let me just save it in my desktop and
231:55 - then click next finish
231:57 - so now we have our project with our
231:59 - source file all right so let me just uh
232:02 - make the text a little bit bigger now
232:05 - we'll start off by creating the board so
232:08 - there are different ways to implement
232:10 - this board you can think of this as an
232:12 - array of nine elements and then three of
232:15 - them are stacked together as a row or
232:18 - you can even think of this as a three
232:20 - cross three Matrix well I will be
232:22 - implementing this particular board as a
232:25 - three cross three Matrix because we can
232:27 - understand rows and columns better by
232:30 - looking at the indexes rather than the
232:32 - slots but you're free to implement it as
232:35 - a 1D array also that is uh by creating
232:38 - nine elements and then stacking three
232:40 - three vertically all right so I have
232:43 - managed to draw this implementation over
232:45 - here so what will be essentially
232:47 - building is a three cross three array
232:49 - like this
232:50 - and then these are the indexes and since
232:53 - we cannot uh detect Mouse clicks on our
232:57 - console we will be numbering our slots
232:59 - so let's say the user wants to enter his
233:02 - marker over here so the user can press 5
233:05 - and then we will remove this five and
233:07 - then put marker over here let's say x so
233:10 - the 5 goes and then we put X over here
233:13 - so that's how we are going to implement
233:15 - it but there are other libraries which I
233:17 - encourage you to look up which support
233:20 - Mouse clicks on consoles too so in case
233:23 - you are interested to implement such a
233:25 - system where you can click on the area
233:27 - and then your marker appear so you can
233:30 - check out those libraries well
233:32 - discussing those libraries are well
233:34 - beyond the scope of this course so we
233:36 - are not going to do that so for now we
233:38 - will be implementing this particular
233:40 - system right
233:42 - so let's start off by creating the bowl
233:44 - which is a two-dimensional character id
233:47 - so let's call this Arias board and then
233:50 - this is going to be two dimensional and
233:52 - every Dimension will have three three
233:55 - elements so this is a three cross three
233:57 - board let me just put it over here
234:00 - so even if you don't put it doesn't
234:02 - matter I'm just putting it so that uh we
234:04 - be clear with our implementation so let
234:07 - me just name the slot so one two three
234:10 - and then four five six seven eight nine
234:12 - so notice that I am numbering the slots
234:15 - as characters because if you put
234:17 - characters over there it will take it as
234:19 - an ASCII value I'm sure you know this
234:21 - right
234:22 - now let us quickly make a function to
234:26 - draw the board so let's say avoid the
234:28 - draw board
234:30 - and what this function is going to do is
234:33 - that it is going to draw the board
234:35 - neatly for us so something like this so
234:38 - uh these two vertical lines and then
234:40 - these two horizontal lines separate the
234:42 - rows and columns will be drawing that
234:44 - over here so you can use a loop but
234:47 - since there are only nine elements let's
234:48 - just hard code it so uh both 0 0 let us
234:53 - give a space before about 0 0 so that it
234:55 - doesn't get squashed up to the left all
234:58 - right both zero zero and then we have a
235:01 - space vertical line
235:03 - and then board a zero one space vertical
235:07 - line and then
235:09 - board zero two and then we have the next
235:12 - line because we just completed the row
235:14 - what we did is we just printed this row
235:16 - with these two vertical bars now we need
235:19 - to put a horizontal bar so uh let us
235:22 - just put that see how the horizontal
235:25 - wire is just going to be lines this is
235:27 - all completely designing you can do it
235:29 - as you want right
235:32 - and these steps continue for the next
235:35 - two rows two so Ctrl c b b and for the
235:39 - last row we don't need the horizontal
235:40 - lines
235:44 - and here you just need to change the
235:46 - road number so this becomes 2 this
235:48 - becomes one
235:50 - one
235:53 - over here two
235:55 - and two so now if we call this
235:58 - particular function let's just remove
236:00 - this
236:02 - and call drop board
236:05 - now if you run this we will be getting
236:07 - our boot so uh well the horizontal lines
236:10 - become extra how many characters are
236:12 - these three characters or more so let's
236:14 - just remove those three characters
236:16 - foreign
236:21 - so this board looks much better right so
236:24 - we have our Port ready
236:26 - now uh how do we put data inside this
236:30 - board
236:31 - so let's make another function to do
236:33 - that let's say void
236:36 - place
236:38 - marker which is going to take a slot
236:41 - number right because the user is going
236:43 - to enter the slot number now it asks us
236:45 - to convert the slot number into the row
236:49 - and column number right if you are using
236:51 - a one-dimensional array that is pretty
236:52 - easy you just need to do slot minus one
236:55 - to answer insert that into the
236:57 - particular position right so suppose you
236:59 - want to insert it into this particular
237:01 - position and if you are using a one
237:03 - dimensional array this is the fourth
237:04 - position right because array indexes
237:06 - start from 0 so 0 1 2 3 4 and you just
237:10 - need to do slot minus one but since we
237:13 - are using a two dimensional array we
237:14 - need to find out a way by which we can
237:18 - convert this slot number into a row and
237:21 - column number so what we can do to find
237:24 - the row number is that we can use an
237:28 - observation that all the rows start from
237:30 - a number which is just one greater than
237:33 - the previous multiple of three so if You
237:35 - observe over here one is nothing but 0
237:37 - times 3 plus 1 4 is 1 times 3 plus 1 and
237:41 - then 7 is 2 times 3 plus 1. so what you
237:45 - can do is you can get the row number by
237:47 - dividing the slot number by 3 but then
237:50 - again if the slot number itself is a
237:53 - multiple of three then you need to
237:55 - subtract one from the slot number that
237:57 - is if you take example of 6 so if you do
238:00 - six over three it is 2 right but we need
238:03 - it in slot number one so we need to
238:06 - subtract one from that so what I mean is
238:08 - if this particular slot
238:12 - foreign
238:15 - that is if the slot is a multiple of 3
238:18 - then slot equal to slot over 3 so this
238:23 - is this
238:25 - and then minus 1 so this will give us
238:27 - the slot number else
238:29 - slot is directly slot over 3. so this
238:33 - should give us the particular row number
238:35 - sorry let us take a variable just at
238:38 - least changing the slot so if slot
238:41 - percentile 3 is 0 then rho
238:45 - is going to be this particular value or
238:49 - else rho is going to be this value
238:51 - now let us just see whether our row
238:54 - works correctly or not
238:55 - and let us just call it with
238:59 - Place marker let's say 8 right now if
239:02 - you run this you should be getting 2
239:05 - which is correct right because 8 is in
239:07 - row number two
239:08 - now to get the column number you can do
239:12 - something similar to that so to observe
239:15 - the columns these are nothing but
239:16 - reminders which you get after dividing
239:18 - by three right so you can do the same
239:20 - thing so let's take another variable to
239:23 - store the column
239:24 - and
239:27 - column is nothing but slot modulus 3 so
239:31 - this should give us the reminder so if
239:33 - you look over here let me just pull up
239:36 - that image
239:38 - now if you say three then our row is
239:41 - going to be 3 over 3 and since 3 is a
239:44 - multiple of 3 so it is going to be 3
239:47 - over 3 minus 1 which is equal to 0 and
239:50 - then um
239:51 - our column is going to be 3 modulus 3
239:56 - which is going to be 0 but that is not
239:59 - our column we need two so what
240:02 - essentially we need to do is if it is a
240:04 - multiple of 3 if the slot is a multiple
240:07 - of 3 we need to put it in the end or
240:10 - else that particular logic will work all
240:12 - right
240:14 - over here what you need to do is if at
240:17 - this particular slot
240:19 - is again a multiple of three then our
240:23 - column is going to be two all right or
240:27 - every time when the value is a multiple
240:29 - of 3 you are going to put that in the
240:32 - last column and then you can divide this
240:34 - slot number by 3 and then get the
240:37 - reminder that is going to be your column
240:39 - number
240:39 - get the reminder and then subtract one
240:42 - from that that is because we are not
240:44 - considering the
240:45 - multiples of three right we are leaving
240:48 - the multiples of three so we need to
240:50 - subtract one let's say four so four
240:52 - divided by 3 you get a reminder one and
240:54 - then one minus zero is zero which is the
240:57 - column number of four okay so this is
240:59 - how you get the column number so uh let
241:01 - me let us just quickly uh rewrite this
241:04 - with uh fewer conditions so row is going
241:07 - to be uh this particular value right
241:09 - irrespective of whether slot is going to
241:12 - be a multiple of 3 or not if it is
241:14 - multiple of 3 we can just subtract 1
241:16 - from this value so a slot modulus 3 is
241:19 - equal to 0 then rho becomes rho minus 1
241:25 - and then column becomes 2 right this is
241:29 - only when the slot which you're giving
241:32 - is a multiple of three or else or let us
241:36 - Define the column before using it
241:40 - or else what happens is columns become
241:44 - slot modulus 3 minus one so first we
241:47 - perform slot modulus 3 and then we
241:50 - subtract one from that all right so this
241:52 - is how we can get the row and column
241:54 - from our slot number if you know check
241:56 - out the row and it will come over here
242:00 - and then column and then let us call
242:03 - with a so we should be getting 2 comma 1
242:06 - which is what we got right because 8 is
242:09 - in the second row First Column we can
242:10 - try it with some multiple of three let's
242:12 - say nine and then try to run this we
242:15 - should be getting 2 comma minus one now
242:18 - why did that happen well that is because
242:20 - we are trying to modify the column even
242:22 - after it is getting modified over here
242:24 - right we are modifying the column when
242:26 - slot modulus 3 is equal to 0 and then
242:29 - again we are modifying it over here so
242:31 - we need to put it in the else part all
242:33 - right now it should work fine now let us
242:35 - just close this and try again
242:37 - uh if I press F9 so here you can see it
242:41 - gave us 2 comma 2 which is correct so
242:43 - now we know that our Logic for getting
242:47 - the row and column is correct so we can
242:48 - proceed by putting our marker into the
242:50 - board so how do we track which Market to
242:53 - put so let us create a global variable
242:55 - for tracking a marker let's say current
242:58 - marker
243:00 - and let us set this to some value or
243:02 - else we'll set it while we are asking we
243:04 - will set it while we are asking the user
243:06 - to choose the marker right and we will
243:09 - also have a current layer right so we
243:11 - need to even track the current layer to
243:14 - check which player is playing right so
243:17 - we have one marker and one player now
243:21 - what we are going to do is we need to
243:22 - just put Board of this particular row
243:25 - and then this particular column is going
243:27 - to be the current marker
243:30 - so now we have successfully placed it
243:32 - let's place a marker over here and then
243:34 - try to draw the board
243:37 - I'll we'll draw a board over here too so
243:39 - draw board uh and then we'll put a new
243:42 - line so that we don't get converted
243:44 - between the two boats so let's uh just
243:46 - uh say that current marker is X for now
243:49 - and if we try to run this you will be
243:52 - seeing that
243:53 - in place of nine now there is an X right
243:56 - so now we know that this particular
243:58 - function works we can place our marker
244:00 - on the board
244:01 - now let us make a function to determine
244:05 - who won the game right so let's call
244:08 - this function
244:09 - win or winner something like this and we
244:13 - will put the data type to care I will
244:16 - just explain why we are putting the data
244:18 - type to care right now so this this is
244:20 - not going to take anything this is going
244:22 - to work on the global board variable
244:25 - which is this which is an array right so
244:28 - what we're going to do is we are going
244:30 - to check all the rows the columns and
244:32 - the diagonals and see whether those have
244:36 - the same value of marker right so in
244:38 - case there are numbers they are going to
244:39 - be different so nobody won and in case
244:42 - they have this excess or Os stacked up
244:46 - horizontally vertically or diagonally it
244:49 - means that that particular layer 1 right
244:51 - so now since we are getting the winner
244:53 - we can either put it true or false to
244:56 - determine whether the game is one or not
244:58 - but to determine who won the game we
245:01 - need to again check whether that
245:04 - particular marker is an X or o right so
245:06 - what we are going to do in this function
245:08 - is instead of checking twice we will
245:10 - directly return the marker of the winner
245:12 - so by marker we can identify which
245:14 - player one and then we can congratulate
245:17 - him or her right that is pretty easy now
245:19 - so to do that let us quickly run a for
245:22 - Loop so in time equal to 0 I is less
245:25 - than 3 I plus plus
245:27 - and inside this we are going to check
245:29 - for rows first so uh if this particular
245:33 - Board of I
245:35 - and then 0 is equal to board i1
245:40 - and board i1 is equal to board I2 then
245:46 - return the current marker right because
245:49 - uh we are going to check whether the
245:51 - player wins immediately after he places
245:55 - the marker so if this particular
245:58 - condition is satisfied then it means
246:00 - that one of the rules has been occupied
246:02 - by this current player so he's the
246:04 - winner and you can also check for the
246:07 - columns in the same Loop so what you
246:09 - need to do for the columns is the same
246:12 - thing but just the eyes get shifted to
246:15 - the second dimension so since I am
246:16 - checking the rows I am just putting I in
246:19 - the First Dimension for columns what we
246:21 - need to do is we need to remove the eye
246:24 - and place it over here
246:26 - so let me just cut and paste it
246:30 - and this goes
246:32 - over here
246:36 - and this goes over here so now we have
246:39 - successfully checked whether uh the rows
246:41 - or columns are filled for diagonals you
246:43 - can just hard code it since there are
246:45 - only two diagonals so if Board of zero
246:48 - zero is equal to board of 1 1
246:53 - and board of 1 1 is equal to code of one
246:58 - two so what we are doing is we are
246:59 - essentially checking whether this value
247:02 - is equal to this value and then this
247:05 - value equal to this value if these two
247:07 - conditions are true it means that these
247:09 - three values are equal and it means that
247:12 - the player has one so if these three if
247:15 - this condition turns out true then the
247:18 - current layer as one current player or
247:19 - Mark oh since I'm using the player as a
247:23 - integer I need to return in not CAD so
247:26 - over here it is not current marker but
247:29 - current player you can return either of
247:31 - them right you can return current marker
247:33 - or current player it just depends upon
247:36 - you right so now we need to check this
247:38 - condition for the second diagonal so
247:40 - this goes and then for the second
247:42 - diagonal so coordinates are 0 2 1 1 and
247:45 - 2 0 so 0 2
247:48 - one man Remains the Same and one one is
247:51 - equal to two zero then you return the
247:53 - current player
247:56 - right so now what if nobody won so you
248:00 - need to return something so what will
248:02 - return is we'll just return 0 0 means
248:05 - nobody won and if it is either one or
248:07 - two it means that player one is one or
248:09 - player 2 S1 so now we have the winner uh
248:12 - let's just create a arbitrary board and
248:14 - then check who won right so uh let's uh
248:17 - place these markers right place marker
248:19 - at nine eight and seven so it means that
248:23 - X is one so nine seven and then Place
248:26 - marker at eight
248:28 - and our current player is going to be
248:31 - one
248:37 - right now if you run this
248:40 - okay the spelling is wrong current
248:42 - player
248:44 - and if I try to run this
248:46 - so here you can see I have placed three
248:48 - x's over here now if I try to call this
248:51 - function
248:52 - which is uh
248:55 - winner
248:57 - and try to print the data over here so
249:00 - you can see that it has outputted one
249:02 - one is the current player who I just put
249:05 - three x's in a row so it works for row
249:07 - let's just check for column column is
249:11 - um let's say zero sorry one and then
249:14 - four and seven so this is the first
249:17 - column and we'll run this
249:20 - so it has returned one again and let's
249:23 - check for the diagonal so that is 159
249:28 - so now you see that doesn't work for
249:31 - diagonal that is because we messed up
249:33 - the logic somewhere let's take that out
249:35 - oh it is not one two it is 2 2 over this
249:39 - right so that's a small mistake I made
249:43 - oh now if you again run this
249:46 - this should work now
249:48 - so here you can see it has outputted one
249:51 - and let's keep some arbitrary uh Place
249:54 - let's say 169 so this shouldn't result
249:58 - in a win so this should give us 0 which
250:01 - it gives so now we can say that our
250:04 - winner function is pretty much validated
250:06 - and it works right so now let us quickly
250:09 - make the interface we need so let's call
250:12 - this interface game
250:14 - all right and in this let us Define our
250:18 - current player and marker so we will
250:20 - give a choice for the player one to
250:22 - choose a smart girl and player to
250:24 - automatically gets the other marker so
250:26 - what we are basically trying to do is if
250:29 - the player the first player has a choice
250:32 - of playing X or an O right so that's
250:36 - what we're going to do so uh
250:38 - player one uh let's say choose your
250:41 - marker
250:43 - now you can come up with your own
250:45 - sentences over here it doesn't really
250:47 - matter so this will enter our current
250:50 - marker all right or uh let's just keep a
250:54 - player one marker uh let's create a
250:57 - character which says marker
250:59 - marker of player one so we are going to
251:03 - get this particular marker so marker
251:05 - here one
251:07 - now our current player is going to be
251:10 - one
251:11 - and then the current marker is going to
251:14 - be the marker which appear when choose
251:17 - right now if You observe this game
251:21 - right they can be at most nine moves for
251:24 - this game to end up in a tie right so in
251:27 - case somebody wins it's going to be less
251:29 - than 9 moves but if it is going for a
251:32 - tie it's going to be 9 most important
251:35 - so what you can do is you can run a loop
251:38 - till nine moves so enter equal to zero I
251:40 - is less than nine and then I plus plus
251:43 - and inside this what you need to do is
251:46 - let's first draw the board or what we
251:48 - can do is we can First Take input from
251:50 - the user and then draw a good so for the
251:53 - first time let us just draw the board
251:55 - outside Loop and then for the subsequent
251:58 - moves we'll draw the board after the
252:00 - slot is entered so we'll ask the player
252:04 - to enter the slot so see how
252:08 - it's clear and then which player is that
252:12 - current player current players
252:15 - um let's say
252:18 - turn
252:19 - so enter your slot
252:23 - now we are going to get a slot so in
252:25 - slot C in slot and you know what to do
252:28 - you just need to place the marker so
252:30 - Place marker in this particular slot and
252:33 - then we will draw the board to draw
252:35 - board
252:36 - so now if we run this particular board
252:38 - we'll just call the function game to
252:41 - play a game right so we'll just remove
252:45 - all this and then just say game over
252:47 - here
252:49 - so now if you run this
252:51 - what you will be uh getting is player
252:54 - one choose a marker is going to be X and
252:56 - then uh it's my turn so let's sit two
252:59 - now you see that the player is not
253:02 - changing that's because we did not write
253:04 - code to change the player and the marker
253:07 - we need to swap the players and markers
253:09 - right because the players and marketers
253:11 - are going to change alternatively and
253:14 - here you can see that the slot has been
253:17 - accepted perfectly and then the X has
253:19 - come in place of two so here you can see
253:22 - that it works and then if I win
253:24 - somewhere it is not going to stop and
253:26 - then it's again going to continue right
253:28 - so this game is never going to stop so
253:31 - we need to fix all these issues so we'll
253:33 - do that one by one first let's take care
253:35 - of the issue where the player and
253:37 - markers are not changing so let's create
253:40 - function quickly which swaps a player in
253:43 - marker so let's avoid uh swap
253:47 - player and uh marker so this is the name
253:51 - of our function so what it does is
253:54 - pretty simple if the current player the
253:57 - current marker is X then change the
254:00 - marker to O
254:02 - current marker becomes o
254:05 - or else you just change the current
254:06 - marker to X and this is just swapping
254:09 - the markers and the same goes with
254:12 - players so if the current player
254:15 - this one then current player becomes 2
254:23 - or else Uh current player remains one
254:28 - so here we have successfully swapped the
254:31 - player in marker so once uh everything
254:33 - is done what we do is before drawing the
254:35 - board we just swap the player right so
254:38 - swap player and marker and this should
254:40 - do the job now let's test this so if I
254:42 - run this
254:44 - uh let's choose X now it's asking player
254:47 - Once you turn enter your slot let's say
254:48 - one and now player two Stern enter your
254:52 - slot if I enter two you can see that 2
254:54 - is occupied by an O now so now I we have
254:58 - successfully created a system where the
255:02 - players are changing and the markers are
255:04 - also changing and now we need to take
255:06 - care of the issue that once we are
255:07 - winning it is not stopping right so we
255:10 - need to check whether somebody won or
255:12 - not so over here
255:14 - what we can do is we can create a
255:16 - variable for storing the value which
255:19 - this particular function returns right
255:21 - this winner function returns it's going
255:23 - to return a value in the range of 0 1 2
255:26 - right it's not going to return any other
255:28 - value so let's just create a variable
255:31 - which shows the winners so let's say uh
255:34 - layer 1
255:36 - this is the
255:38 - integer value and what we need to do is
255:41 - after placing the marker we need to
255:43 - check whether he won or not so player
255:45 - one equal to this particular winner
255:47 - okay and now here
255:50 - if this particular value
255:52 - which is player one is equal to 1 which
255:55 - means that player one one right so see
255:58 - how the
255:59 - player one one
256:01 - and then let's say congratulations
256:05 - and what you need to do is just break
256:07 - out of the loop because we don't need to
256:08 - continue the game after somebody F1
256:10 - right so you can just break out of this
256:12 - Loop and over here the same thing goes
256:15 - with player two three right you if
256:18 - player one is equal to 2 then you says
256:22 - uh see out
256:25 - the same message just we need to change
256:28 - the player to and all these things
256:29 - remain the same so Ctrl C and Ctrl V
256:34 - and over here instead of one we just
256:36 - need to put two
256:38 - so in case nobody won it either means
256:42 - that the game can go on or if it has
256:45 - reached 9 moves it means that it's a tie
256:47 - right automatically if you're playing
256:50 - for nine moves and you make the ninth
256:52 - move and still nobody wins it's going to
256:54 - be a tie so what you need is if this
256:58 - particular
256:59 - winner condition which is player one is
257:02 - equal to 0 after completing this game
257:05 - then we need to say that
257:08 - nobody wins or let's say uh that is a
257:12 - tie game
257:14 - right so uh what this will do is if in
257:17 - case nobody wins even after nine moves
257:20 - and this comes out of the loop it will
257:23 - then say that it is a tie game right so
257:25 - suppose player one one and then it broke
257:28 - out of the loop then if you just put
257:31 - this particular thing without this if
257:33 - condition what will happen is it will
257:36 - print both the messages at once right so
257:38 - it will say player one one and then
257:39 - again it will say that that is a tie
257:41 - game we don't want that to happen that's
257:43 - why we have put a if condition to check
257:45 - whether it's a tie or not and then we
257:47 - will say it's versatile again right that
257:50 - will take care of all the issues
257:52 - hopefully so let's just try with o this
257:55 - time
257:56 - and its player once done so let's enter
257:59 - one two three so you can see it's
258:02 - filling alternatively and four five six
258:06 - seven and it says player one one
258:08 - congratulations but uh we cannot see
258:11 - what happened over here that is because
258:13 - we are not drawing the board immediately
258:15 - right so what we'll do is we'll shift
258:18 - this drawboard function before uh this
258:21 - particular
258:23 - winning condition right so what will
258:25 - happen is once I place this marker I
258:28 - will just draw the board so now if I run
258:31 - this
258:32 - uh let's say x and then one two three
258:35 - four five six seven and now you see that
258:39 - player one has one that is because this
258:41 - particular diagonal which I'm
258:43 - highlighting has been filled up by axis
258:45 - so player one one in case you fill it up
258:47 - with o it means that player two S1 and
258:50 - in case you don't fill it up let's take
258:53 - a draw keys
258:54 - uh let's say uh we play for nine moves
258:57 - so x uh let's just quickly put the
259:00 - numbers one two three so in case to draw
259:03 - we need to put five and then four
259:06 - six and eight seven
259:10 - nine right so now you can see that
259:13 - nobody has one even after nine moves so
259:16 - it says that is a tie game and the board
259:18 - is filled up so our game works perfectly
259:21 - for now right so there is a minor bug in
259:24 - this game for what what we did is so
259:27 - let's say I put my marker in the first
259:30 - slot right
259:31 - and now it is player two strand and what
259:35 - I will do is I will again press one so
259:37 - what will happen now is if You observe
259:40 - the X has gone and then o has taken its
259:42 - place it means I've just overwritten it
259:44 - right so we won't we don't want that to
259:46 - happen we don't want to move the markers
259:48 - away from the places so to fix that what
259:52 - we need to do is we need to check
259:53 - whether that slot is empty or not that
259:56 - is if that slot contains some character
259:58 - which is not an integer it means that it
260:00 - is a marker right and we don't want to
260:02 - change the smartphone so what we do is
260:04 - where we are placing the marker here
260:07 - what we need to do is we need to put
260:09 - this only when that particular row and
260:12 - column is not filled up so if that board
260:14 - and column
260:16 - a board of this row
260:20 - and then column is not equal to an X
260:24 - and it is also not equal to an O So
260:28 - Board of uh row and column is not equal
260:33 - to an o
260:35 - then you will be filling it up with this
260:38 - particular marker or else you won't fill
260:40 - it up right so let us return true or
260:42 - false over here and then we'll print the
260:44 - message over there so uh we'll make this
260:46 - Boolean or Bool
260:49 - and over here if this is the case then
260:52 - you first place the marker and then
260:55 - return true saying that this operation
260:58 - was completed successfully
261:01 - or else what you need to do is you
261:03 - return false over here
261:06 - and here once you are placing the marker
261:09 - where did we place it before placing it
261:11 - over here right so let's say Boolean
261:14 - status or you can directly put this in
261:18 - the if statement also right so if this
261:20 - particular condition is true then we
261:23 - don't have to do anything we want to
261:25 - print a message only when it is false so
261:27 - let's put a not over here so if not
261:29 - Place marker of slot that is if this
261:32 - condition is not true then we need to
261:35 - say
261:36 - um something so let's say that slot is
261:38 - occupied
261:41 - Tandon or try another slot
261:44 - so this particular message will print
261:47 - and then we need to decrease I by one
261:50 - that is because we need to uh give the
261:53 - player another chance right we can't
261:55 - just switch the players right there so
261:57 - we just decrease I by one and then we
262:00 - just put continue so that all these
262:02 - statements are skipped and then it goes
262:04 - back to the execution so let us just uh
262:06 - neatly against this indent this code so
262:10 - we print the message we decrease I so
262:13 - that the value of I remains same once
262:16 - continuous encountered right because if
262:18 - it is decreed decreased over here it
262:20 - will go back and it will increase over
262:22 - here so effectively the value of I
262:24 - remains same
262:26 - and it should work now
262:28 - and another thing is let's say the
262:31 - player entered some pretty big slot
262:33 - right let's say 100 or something so we
262:36 - need to take care of that too so if slot
262:39 - is less than nine less than one and if
262:42 - slot is sorry
262:44 - or if slot is greater than 9 we should
262:47 - not accept it so we need to do the same
262:49 - thing just the message changes Ctrl C
262:52 - and then Ctrl V
262:55 - and here you need to share that is an
262:58 - invalid slot right so that slot
263:02 - is invalid and then you try another slot
263:06 - and we just put continue so that the
263:08 - player doesn't change
263:11 - so this should do for us now if you
263:13 - execute this you will be having a
263:15 - functional tic-tac-toe game over here so
263:17 - it's asking player one choose your
263:19 - marker it's going to pay X and now it's
263:21 - player one stone so one two three
263:24 - four five six seven
263:27 - so now player one one that's because of
263:30 - this particular diagonal and let's make
263:33 - player 2 also again so let's try it once
263:35 - again so let's say x again so now it is
263:39 - going to be one two three and then five
263:43 - four
263:44 - and then what is that state now you can
263:47 - see player 2 1 congratulation that is
263:49 - because I have filled up this particular
263:51 - column with OS right so uh in case you
263:54 - wanted to implement
263:57 - AI kind of a thing where the computer
263:59 - place you can do that well uh we are
264:02 - just going to implement a pseudo AI not
264:04 - the original one so this is not going to
264:07 - think much it is just going to randomly
264:09 - place it so in case you want to Generate
264:11 - random slot what you need to do is you
264:13 - need to include another header file
264:15 - called STD lib which is standard Library
264:18 - you can include this one or three stdi
264:21 - Library which is the C plus plus version
264:23 - of this C standard Library so these
264:26 - libraries are nothing but they are from
264:28 - C language so in case you're using it in
264:31 - C plus plus you just add a c over here
264:34 - to indicate that that this is C library
264:36 - right
264:38 - now to Generate random numbers what you
264:40 - have is you have a function called rank
264:43 - which will directly give you a random
264:45 - number right Sprint Rand over here
264:47 - and here you can see it just printed 41
264:51 - onto the screen now if I execute it
264:53 - again you will see that the same 41 is
264:56 - over here if you close this whole
264:58 - program and then uh rerun it it is going
265:01 - to give you a different number but again
265:03 - uh till you don't remove this whole code
265:06 - from the memory it's going to be the
265:08 - same number again and again and again so
265:10 - to take care of that what you have is
265:12 - something called as a seed so for
265:15 - seeding the random functions reading is
265:17 - basically you will be giving different
265:20 - starting points to that random function
265:23 - to generate different numbers every time
265:25 - you call it so to feed the random number
265:27 - you call the function s Rand and inside
265:30 - this you put some number which
265:32 - constantly keeps changing right so let's
265:35 - say 1 over so let's say 10 over here and
265:38 - then if I try to run this you will be
265:40 - getting some other number let's say 71
265:42 - over here and if I put some other number
265:44 - let's say 1 over here now and then try
265:46 - to run it you will be getting another
265:47 - number which is 41 but we can't change
265:50 - this again and again right we need a way
265:52 - to change this particular number which
265:55 - will generate different numbers every
265:58 - time so to do that we can use time right
266:03 - so time is constantly changing it is not
266:06 - constant so what you can do is if you
266:08 - pass in time over here as an integer it
266:11 - will give you different random numbers
266:13 - without you having to change this
266:14 - manually so to do that we need to
266:16 - include another header file which is
266:18 - called time
266:19 - right so
266:21 - see time
266:22 - right so same reason why we are using
266:25 - over here it is time.h or C time both
266:28 - the same and you go over here and then
266:30 - what you do is instead of one you just
266:33 - pass in time and then pass in null as a
266:35 - parameter we'll talk about this null
266:37 - when we are discussing pointers but for
266:39 - now just remember this is the syntax and
266:42 - this is how we call the function for
266:44 - time right for getting time as an
266:46 - integer now if we run this
266:49 - you will be getting different uh numbers
266:52 - over here every time so this is 9170 if
266:54 - I execute it again you will be getting
266:56 - some other number 9187 right so to
266:59 - Generate random numbers in a Range we
267:02 - want it in a range right we want random
267:04 - numbers between one and nine so to do
267:06 - that what you can do is you have to use
267:09 - a formula there is no direct way to get
267:12 - random numbers in C plus plus in a
267:15 - particular range but what you can do is
267:17 - you can use
267:19 - a formula which states that if you want
267:22 - random numbers in the range of U to L
267:25 - right which is sorry L to you
267:28 - which is nothing but lower range to
267:31 - Upper range what if you want random
267:34 - numbers in this range what you do is run
267:36 - mod
267:37 - U minus L plus 1 and then the whole
267:41 - thing
267:43 - plus L well this formula does look
267:46 - pretty
267:47 - clumsy I know that but if you try to
267:51 - reduce this you will see that it
267:53 - mathematically means the same that the
267:56 - lowest number will be L and then the
267:58 - highest number will be you right so you
268:01 - just remember this formula to Generate
268:03 - random numbers within a range so in our
268:05 - case what it's going to be is upper
268:08 - range is 10 and then the lower range is
268:10 - one right upper range is not included so
268:13 - value for this notation it is
268:14 - mathematically this which means that the
268:18 - last number is not included but the
268:19 - number till the previous one is included
268:22 - so it becomes 10 minus 1 plus 1 and over
268:25 - here the
268:27 - upper radius one right so now if you do
268:29 - this over here if I try to print this
268:31 - value over here you will be getting
268:34 - numbers which are in the range of one to
268:36 - nine right let us put a semicolon in the
268:39 - end and we don't need this so we'll just
268:42 - remove this so every time we execute
268:43 - we'll be getting some random numbers
268:45 - which is uh in the range of one to nine
268:48 - right so here you can see that it's
268:50 - giving us different numbers in the range
268:52 - of one to nine
268:54 - so now what we can do is we can use this
268:58 - and instead of the second player what
269:00 - we'll do is we'll just uh ask the
269:03 - computer to generate some random slot
269:05 - number and then place our marker over
269:07 - there and then instead of 9 now the loop
269:10 - will run only for four times well just
269:12 - because uh the number of times the loop
269:16 - should run is halved right we are not
269:17 - going to take in inputs for nine times
269:19 - we are going to take it in input for
269:21 - four times so we need to just run it for
269:25 - 9 over 2 times which is 4 that's an
269:28 - integer Division if you want to
269:30 - implement a really sophisticated system
269:32 - like the one which Google uses right
269:34 - this one which can think so if you take
269:37 - this impossible level in this particular
269:41 - game and then try to play with Google
269:44 - you can see that you can never win right
269:47 - it will either end up in a draw or you
269:50 - lose right now there is no other outcome
269:52 - in this particular you cannot win that
269:54 - is for sure so to implement such a
269:56 - system there is an algorithm called as
269:59 - min max algorithm so
270:02 - you can try to study about this min max
270:05 - algorithm so sorry it is min max
270:09 - algorithm
270:11 - right so you have this particular
270:14 - algorithm so what this essentially does
270:16 - is it will take combinations of games
270:19 - right it will play the game with itself
270:22 - and it will score every game so let's
270:24 - say we have an arbitrary game so let us
270:27 - just clear this let's say we have an
270:28 - arbitrary boot so I have an X over here
270:31 - and over here and then another X over
270:34 - here
270:36 - and over here and then the computer is
270:38 - playing X so it has to make the next
270:40 - move so what it will do is it will try
270:43 - out all the possible boxes which are
270:45 - unfilled right and there are different
270:47 - outcomes for that so one of the outcomes
270:50 - is let's say I start off with this board
270:52 - so let's change the color so let's say I
270:55 - put an X over here now there are
270:57 - different ways to put oh I can either
270:59 - put one over here one over here it is up
271:01 - to me right so every possibility will
271:04 - generate a new set of boards which the
271:07 - computer will play itself right in the
271:09 - memory and then it will score its
271:12 - outcomes so let's say in in case it put
271:16 - X over here and then uh for the first
271:18 - case you put over here and then it turns
271:21 - out that after playing such combinations
271:23 - it turns out that if you put X over here
271:27 - you have uh let's say 10 combinations
271:30 - out of which you won five combinations
271:33 - right so this is one of the slots now
271:35 - what what it will do is it will keep the
271:38 - statistics and Again Play it with the
271:39 - next lot which is empty so what we'll do
271:42 - is it will just remove these things and
271:44 - then it will play with let's say this
271:47 - particular column so it will put an X
271:49 - over here and then again repeat the same
271:51 - process it will see all the combinations
271:52 - possible and then let's say in this
271:55 - particular column
271:57 - which I marked with red there are again
272:00 - let's say 10 possible outcomes and then
272:03 - it one or seven of them right and let's
272:06 - say it played over here let's take some
272:09 - other color let's say this one so it
272:12 - played over here and then in this again
272:14 - there are 10 possible outcomes and out
272:17 - of which it could win only two right and
272:20 - you have another
272:22 - possible to over here or in which 10
272:25 - possible outcomes
272:27 - it could not win any one right it lost
272:30 - all of them so it won zero now what
272:33 - we'll do is it will see all these scores
272:36 - so here it has 70 probability right so
272:39 - if you are winning seven games out of 10
272:41 - it means you have seventy percent
272:42 - probability of winning and here you have
272:44 - 50 here you have zero percent
272:46 - probability and here you have twenty
272:49 - percent probability so it will check the
272:51 - one with the most probability or the
272:54 - most score so if you take into if you
272:56 - talk in terms of numbers here you have
272:58 - Phi here you have seven zero and two
273:00 - right so it will take the number which
273:02 - is maximum that is this one so it will
273:05 - say that if I put my marker in this
273:08 - particular place I have more chances of
273:10 - winning so it will place it over there
273:12 - so for every move it will calculate all
273:15 - the possibilities and then place the
273:16 - best move and that is how this
273:19 - particular Google
273:20 - is using
273:22 - that particular algorithm to make its
273:26 - decision so that algorithm even though
273:28 - it is called something else it is
273:32 - actually requestion so if you look at
273:34 - the implementation it is basically
273:36 - recursion which is being implemented
273:38 - right so tic-tac-toe if you just search
273:41 - for that you will have many uh different
273:43 - uh
273:44 - resources to check that out so you uh
273:47 - check that from one of these resources
273:49 - so what you will see is it is basically
273:52 - implementing requestion it will just go
273:54 - over the boards and then try to
273:57 - implement and then you have a scoring
273:59 - method so uh I think they have used plus
274:02 - 10 as a score we have used plus one over
274:04 - here right where if we one you just put
274:07 - one over here if you don't win you just
274:09 - put minus one it means that you one and
274:12 - -1 means that you do so and you don't
274:14 - want negative scores right we just want
274:16 - positive scores so this is a bit of
274:19 - complicated stuff if you don't
274:21 - understand uh I don't expect you to
274:23 - understand at this stage but I would
274:25 - definitely recommend you to check that
274:27 - out and try to implement and this one
274:29 - you can try to implement by reducing the
274:32 - number of Loops over here and then
274:35 - creating another function so that the AI
274:37 - chooses what slot to put the marker in
274:40 - so in this video we'll be looking at
274:42 - pointers so now water pointers well as I
274:46 - had mentioned before pointers are
274:47 - variables that store addresses now why
274:51 - do we need a variable to store an
274:53 - address well if you have looked at the
274:56 - address by using the Ampersand symbol
274:57 - let's say we have variable called where
274:59 - and if we want to check the address of
275:02 - this variable
275:04 - then we do an ampersand where so that we
275:07 - get the address and once you run this
275:09 - you will be seeing some hexadecimal
275:11 - value right so this doesn't really make
275:13 - sense and why do we actually need to
275:17 - store these addresses what is the point
275:19 - of that so to answer this question let
275:21 - us take the problem which we were
275:23 - solving while discussing arrays right so
275:26 - the user has some records let's say n
275:30 - records and then the user gets to enter
275:32 - these records and we need to store all
275:35 - these records now let's say the user
275:37 - doesn't really know how many records he
275:40 - has now our program will terminate after
275:42 - taking number of Records right so that
275:45 - number depends on the user if he says he
275:48 - is going to enter 10 records we will
275:50 - create a collection something like this
275:52 - in a memory which will have the capacity
275:55 - to hold only 10 records we cannot
275:58 - increase the number of Records once
276:00 - memory space is defined so how do we
276:03 - solve this kind of a problem where the
276:06 - user is going to enter data and he
276:10 - doesn't know how much data is going to
276:12 - enter but we are expected to store that
276:14 - so to solve this issue what we use is
276:17 - called dynamic memory so what we do to
276:21 - solve this problem is we have a special
276:24 - data type defined and this data type
276:26 - does not belong to any one of the
276:28 - primitive data types right this is not
276:31 - an in float care or something this is a
276:34 - collection of data types combined as one
276:36 - data type we will discuss about how to
276:37 - generate these kind of data types in the
276:40 - upcoming videos but for now let's just
276:43 - focus on how this works so you have a
276:46 - data type like this where one of the
276:49 - data which this data type holds is a
276:52 - pointer now what we do is we will put
276:56 - data or we will generate a data which
276:59 - contains the records and then we will
277:01 - just randomly throw it in a memory so
277:03 - let's say this is one of them and we
277:06 - just randomly put all the data somewhere
277:09 - the memory
277:10 - and to keep a track of the records what
277:13 - we do is we will just keep a track of
277:15 - this particular record or this
277:17 - particular data now what we do is we
277:20 - will just link all these data with the
277:24 - pointers now this pointer will hold the
277:27 - address of this particular data and this
277:30 - will hold the address of the next one
277:32 - and this will hold the address of next
277:34 - one and so on so what I've discussed
277:36 - till now is nothing but an
277:37 - implementation of something called as a
277:39 - linked list right so or more
277:41 - specifically this is called a single
277:43 - linked list so we won't be implementing
277:46 - this particular data type in our
277:49 - programming right now because you don't
277:50 - have the intuition to Define such a data
277:54 - structure which can hold multiple data
277:56 - types we will be discussing about them
277:57 - later but I will definitely show you how
278:00 - to implement a pre-implemented data
278:04 - structure called list in C plus plus in
278:06 - this video
278:08 - so first let's discuss about pointers
278:10 - and how to use them and then we'll look
278:12 - at this particular implementation the
278:14 - implementation doesn't really have
278:16 - anything to do with pointers but this is
278:19 - how this particular data type is working
278:21 - in the memory so if you want to
278:23 - implement something like this from
278:25 - scratch you need to understand how
278:26 - pointers work right so let's get back to
278:29 - pointers so to create pointers what we
278:32 - do is we just name the data type of the
278:35 - pointer and then the name of the pointer
278:38 - let's say PTR and then before the
278:41 - pointer we put a star so so the star
278:43 - indicates this this particular variable
278:46 - doesn't hold a value but will hold the
278:48 - address so this is how we declare
278:50 - pointer and we can just store the
278:53 - address of this particular variable over
278:55 - here so you can either do it like this
278:57 - so you can say PTR equal to and where
279:02 - so PTR is the pointer and then and where
279:06 - is going to be the address so you can
279:08 - store
279:09 - the value of and where inside PTR or
279:13 - what you can do is you can even directly
279:15 - do it from here
279:16 - so note that this thing it is not equal
279:20 - to something like start PTR you just did
279:25 - install PTR and then in the next line
279:27 - you did star
279:30 - PTR equal to
279:32 - and where this is incorrect y see in
279:37 - Star PTR is going to be a pointer and a
279:40 - pointer Can Only Hold addresses now star
279:43 - PTR what it does is if you see star
279:47 - before accessing something it means that
279:50 - this values address and then star means
279:54 - it will reference to that address that
279:56 - means you will get the value to this so
279:58 - star Peter is actually the value which
280:00 - is stored inside the address which is
280:03 - pointed by PTR and here you are trying
280:06 - to store an address so this is incorrect
280:08 - so what you do is you either do PTR
280:11 - equal to and where to get the address of
280:13 - wire inside PTR or if you want the value
280:17 - of where inside PTR what you do is star
280:20 - PTR equal to where so you do either of
280:23 - this but not something like start PTR
280:26 - equal to Android that is incorrect right
280:29 - so now if you want to check what we have
280:32 - inside PTR you can just do c out PTR
280:36 - and we will see that yeah
280:39 - that is because I did not put a
280:41 - Ampersand over here now so now you can
280:44 - see that this shows uh okay this these
280:48 - are essentially the same addresses just
280:50 - that it is not separated with a new line
280:52 - so if I separate them with a new line
280:55 - you will see that both the addresses are
280:57 - same so let me just close this and open
280:59 - this again so here you can see the
281:02 - address of where and then the value of
281:04 - PTR are same
281:06 - now if you want the value which is
281:09 - stored inside PTR what you do is you put
281:11 - a star before PTR and you will get back
281:13 - the value so if I run this now
281:17 - so here you can see that 10 is the value
281:20 - which is stored inside PTR now
281:24 - what happens if you if you change the
281:25 - value
281:26 - inside PTR so let's say star PTR equal
281:29 - to 20.
281:31 - now what happens is since this PTR holds
281:34 - the value of this particular variable
281:37 - called where what happens is if we
281:39 - change the value which is inside this
281:42 - particular address it changes everywhere
281:45 - right so if you change it over here this
281:48 - value is going to be overwritten with 20
281:50 - it will change over there too that is
281:52 - because you are not using a copy but you
281:55 - are directly changing the value inside
281:57 - this particular address now if you try
282:00 - to print the value of where and we don't
282:02 - need this
282:04 - so here you see that the value of where
282:07 - has become 20 now that is because of
282:09 - this particular statement
282:11 - and you can have multiple pointers and
282:15 - pointers to pointers also let's say we
282:18 - have another pointer enter
282:21 - P PTR which is pointed to point here and
282:25 - for defining a pointer to pointer you
282:29 - just put two stars so there so this part
282:31 - means that this is a pointer and the
282:34 - whole part means that this is a pointer
282:35 - to pointer you can essentially have as
282:38 - many pointer to pointer to pointers as
282:40 - you want but for now we will just go
282:42 - with two and uh to access this what you
282:46 - do do is so P PTR is going to be the
282:52 - address of PTR so if you do and PTR you
282:56 - will get the address of PTR inside this
282:58 - pointer to pointer so let's call it
283:00 - something else this is pptr is pretty
283:02 - confusing let's say
283:04 - um
283:05 - pointer PTR so this is pretty good
283:09 - so pointer PTR will have the address of
283:13 - PTR so now if you try to run this what
283:16 - we'll be getting is the address of PTR
283:19 - so this is not the address of this wire
283:21 - but it is the address of PTR so if you
283:24 - try to print this so we'll just print
283:26 - all things at once so that we can
283:28 - compare them see out uh where first
283:33 - and then we have the address of where
283:36 - and where
283:38 - and then we'll put a new line over here
283:41 - so that we can differentiate the output
283:43 - so and
283:45 - and
283:46 - then we have the pointer which is PTR
283:49 - the value of uh PTR
283:53 - and we have the value which is stored
283:56 - inside PTR so star PTR
284:00 - right and we have this pointer PTR we
284:04 - have
284:05 - the star pointer PTR
284:08 - and star star pointer PTR
284:12 - and I forgot the end lines over here so
284:15 - handle
284:16 - handle and
284:18 - and
284:20 - so here you can see the value of where
284:23 - is 20 the address of where is this thing
284:26 - now the value inside PTR is this
284:29 - under value which is inside this
284:32 - particular address is 20. and value
284:36 - inside pointer PTR is this which is
284:38 - nothing but the address of this
284:40 - particular value which is PTR and this
284:43 - is nothing but the value which is inside
284:45 - this address so now this address is a
284:47 - pointer right this address will contain
284:50 - another address which is nothing but
284:52 - this one so essentially if you are doing
284:54 - a star PTR which is to a pointer to
284:57 - pointer it just means that you are
284:59 - accessing the value which is stored
285:01 - inside the value of another thing so
285:03 - star PTR is nothing but this thing which
285:07 - is the address stored in this particular
285:09 - address now star star PTR is nothing but
285:12 - the value which is stored inside the
285:15 - address which is stored inside this
285:16 - particular address so that is basically
285:18 - the hierarchy so if you don't understand
285:20 - let me just put it as a image so that
285:22 - you can understand better we'll just
285:24 - clear these things so now let's say this
285:27 - is PTR which will hold the address of
285:29 - some variable called where so now this
285:31 - is this variable called where which is
285:34 - nothing but a memory location and this
285:37 - will hold the address of this
285:39 - now pointed to PTR what you can do is
285:42 - when you define pointer to PTR as a
285:45 - pointer to pointer like this what it
285:49 - means is that it will hold this
285:52 - particular value it will essentially
285:53 - hold the address of the speed and now
285:55 - the PTR itself will be in some location
285:58 - right so let's say this is the location
286:00 - of PTR and that is the location of where
286:03 - now what happens is this address is
286:07 - stored inside this and you have another
286:10 - thing called pointer to PTR which will
286:14 - store this particular address now once
286:17 - you are accessing the value which is
286:19 - stored inside pointer to PTR that is
286:22 - nothing but this particular value right
286:23 - now the value inside this is nothing but
286:26 - an address which is the address of this
286:27 - bar so that is why we were getting the
286:30 - address of this pointer that is PTR when
286:34 - we are doing star PTR and then when we
286:37 - did star star PTR what happened is it it
286:41 - wanted the value which was pointed by
286:44 - the value which is inside this so that
286:46 - is why it is called pointer to pointer
286:48 - now what is the value inside this that
286:51 - is nothing but this particular value
286:52 - which is PTR so this is PTR
286:57 - and since you have another star it will
287:00 - go to the value which is pointed by this
287:02 - thing what is the value pointed by this
287:04 - thing it is nothing but this value so it
287:07 - will take out this value and then put it
287:09 - on the screen so that is where we were
287:10 - getting 20 when we did star star pointed
287:13 - to PTR
287:15 - now you can even use pointers and
287:17 - functions so let's say we created a
287:19 - function
287:20 - um avoid let's say swap numbers which we
287:24 - did when we were discussing about
287:26 - call by reference and call by values now
287:29 - instead of call by reference so when
287:33 - we're doing call by reference we were
287:34 - doing something like inter in B right so
287:37 - we are passing this Ampersand to mention
287:39 - that we are going to get an address but
287:42 - to get a pointer you can do the same
287:44 - thing you can just put a star over here
287:47 - and the way you swap numbers is we will
287:50 - have an intemp which is going to have
287:53 - the value of the first one so value is
287:57 - accessed by star a and we will change
288:00 - the value of a with b and Then star b
288:04 - equal to 10 and here while calling this
288:07 - particular function what we do is we can
288:10 - just pass the address correctly so let's
288:12 - say in terms
288:14 - a equal to 10 and b equal to 20. now to
288:18 - pass this what we do is we just call
288:21 - swap numbers and percentage and then
288:24 - Ampersand B why this Ampersand that is
288:26 - because this is a pointer and pointer
288:28 - needs addresses not just values and now
288:32 - if you put
288:34 - if you try to print a and b onto the
288:36 - console you will be seeing that they
288:38 - have indeed swapped over here so now the
288:41 - value of a is 20 and then the value of
288:43 - Base 10. so this is another worker on
288:45 - for call by reference where you want to
288:47 - change the actual parameters but we
288:51 - generally don't use such pointers we
288:53 - generally use the call by reference
288:56 - method which was directly passing
288:58 - address over here and then
289:01 - working with the addresses inside the
289:03 - function now what is the relation
289:05 - between a pointer and an array remember
289:07 - that when I told we were passing array
289:10 - to a function we are actually passing a
289:12 - pointer to the array now what does
289:15 - pointer have to do with an array
289:17 - so Ida is nothing but a collection right
289:20 - so
289:21 - this particular collection has a
289:23 - starting point and that starting point
289:25 - is defined by the pointer which is going
289:29 - over there so let's say we create an
289:31 - array uh int a equal to some
289:35 - foreign
289:37 - now
289:43 - let's just say C out a and what you will
289:46 - see is
289:48 - okay we don't need this we'll just
289:50 - remove this
289:54 - now what you will see is this particular
289:56 - address now
289:57 - why did an address come when we are
290:00 - calling an array that is because this
290:03 - first element or if you just say a0 and
290:06 - then put an and over here that is going
290:09 - to be the same thing as this thing so
290:11 - let us just print both of them together
290:12 - so that we can compare so C out a and
290:16 - then a new line
290:18 - and
290:20 - and
290:22 - is zero right so if you run this
290:24 - particular program what you will be
290:26 - getting is
290:28 - these addresses which are essentially
290:30 - the same thing so this particular a
290:33 - which you are referencing here is
290:36 - nothing but a pointer to the first
290:37 - element in the collection so that is the
290:40 - reason when you pass an array to a
290:43 - function it is essentially passing a
290:45 - pointer to the first element and you can
290:48 - increment pointers right so once you
290:50 - increment a pointer let's say some
290:53 - pointer n star PTR is going to be the
290:57 - first element in the array so this is
290:59 - you can do it uh either way you can just
291:01 - pass in a or you can even pass a zero
291:04 - both of them mean the same thing right
291:05 - now if I do PTR plus plus or BTR plus
291:10 - equal to 1 or PTR equal to PTR plus 1
291:14 - what happens is this will not increment
291:17 - the value over here it will increment
291:18 - the address now the address
291:20 - incrementation totally depends on what
291:22 - data type you are using so if it's an
291:24 - INT it will go forward by four bytes so
291:27 - if it's a float it will to move forward
291:28 - by four by two put your character it
291:30 - will go forward only by one byte so it
291:32 - totally depends on what data type you
291:34 - are using but if you're incrementing a
291:37 - pointer the data doesn't change but the
291:40 - pointers location changes now if you try
291:42 - to print just being pointed by this
291:44 - particular pointer
291:47 - then you will see that it is pointing to
291:49 - two that is because you are just
291:51 - incrementing the pointer from the first
291:52 - element to the second element now you
291:55 - can even run a loop
291:57 - through the pointer so what you can do
291:59 - is uh let's say to access all the
292:01 - elements what we are doing before is we
292:04 - were doing something like this entire
292:05 - equal to 0
292:07 - and I is less than the length which is 5
292:10 - I plus plus and here we were doing C out
292:14 - a i
292:16 - and this right so we're doing something
292:18 - like this now let's see the pointer
292:21 - implementation how to do this so we have
292:24 - a pointer so inch r i equal to a and
292:28 - then I will go till the length of this
292:31 - array now how do we determine the length
292:33 - now what we do is I is less than or
292:37 - equal to a plus 5 what you're doing is
292:40 - you're incrementing the pointer over
292:42 - here not the value of array or the array
292:45 - you are just incrementing the pointer
292:47 - which is nothing but this pointer plus 5
292:49 - is nothing but till here so what you are
292:52 - essentially going to get is the pointer
292:55 - or the address to this particular
292:56 - location and that address you will
292:59 - compare with the address which are right
293:01 - now and if it goes till here it needs to
293:04 - stop so you can directly do I plus plus
293:07 - over here and here you just need to put
293:10 - star I
293:11 - so this is the pointer implementation of
293:14 - getting the elements from an array now
293:16 - if you run this
293:18 - you will be getting the same thing but
293:22 - here you have a weird value
293:25 - now why did that happen that is because
293:27 - this particular value is the value
293:30 - stored in the collection outside the
293:33 - array now every memory location has some
293:36 - default value and this is the value
293:38 - which is stored in the collection which
293:40 - is just beside that we just went one
293:43 - further that is because I have put I is
293:45 - less than or equal to a plus 5 if I had
293:47 - put I is less than a plus 5 then it
293:50 - would have been correct but what
293:53 - happened is since I put is less than or
293:55 - equal to a plus 5 it went to one
293:57 - location further so this is the location
294:00 - which is just beside this collection and
294:03 - that is why the value inside that
294:04 - location got printed and this is some
294:06 - garbage which it doesn't have any
294:08 - meaning it's just there right so now
294:11 - since I changed this if you now execute
294:14 - this you will be getting the same output
294:15 - right so something like this
294:19 - now another very important
294:21 - implementation of pointers is the void
294:24 - pointer now let's say I create a integer
294:26 - pointer style PTR and will have an
294:30 - integer variable let's say I wire equal
294:32 - to 10 and we make the pointer point to
294:36 - this particular eye Wire by giving the
294:38 - address
294:39 - now if I just do PTR then I will be
294:42 - getting the address of this particular
294:44 - i1 right now let's say I create another
294:47 - variable called F1 which is float
294:50 - variable which stores some variable
294:52 - right 3.1415
294:54 - no
294:56 - if I try to change the location of
295:00 - pointer it won't permit me to do so it
295:03 - says cannot convert float start to
295:05 - install that is because I had
295:08 - implemented the pointer as an integer
295:10 - now to change such locations what we do
295:14 - is we have a void pointer now what void
295:17 - pointer does is it cannot print the
295:20 - value but it can change the location so
295:23 - this particular operation is permitted
295:25 - by void pointer so if I now do PTR and
295:30 - then we will see two different addresses
295:32 - on our screen
295:33 - so these are the two addresses uh it's
295:36 - not separated by new line just just do
295:38 - that and
295:40 - we'll run it again so here you can see
295:43 - there are two different addresses that
295:44 - is this is the address of this
295:46 - particular eye where and this is the
295:48 - address of the float variable now uh the
295:51 - only drawback is that you cannot get
295:53 - back the value so if I do star PTR over
295:56 - here you will see that it will put an
295:58 - error over here it says that void star
296:00 - is not a pointer to object type so if
296:04 - you just want to store the address of
296:06 - different variables or different types
296:08 - of variables you can do that but you
296:10 - cannot get the value to get the value it
296:12 - has to be the same data type as the data
296:15 - you are going to point to
296:17 - so this is how we use pointers in C plus
296:20 - plus now let's just quickly talk about
296:23 - how to implement such a dynamic
296:25 - collection which I just discussed before
296:27 - so in C plus plus you have something
296:30 - called a STL so STL is nothing but
296:34 - standard template Library let me just
296:36 - write it down here standard template
296:40 - Library so what it has is it has
296:43 - previously implemented ready-made
296:46 - functions for you so it has functions it
296:48 - has classes and we'll talk about water
296:51 - classes and how to use this particular
296:53 - STL at a later stage we will just
296:55 - discuss uh how to create such Dynamic
296:58 - containers or dynamic collections in our
297:01 - memory just like what we had discussed
297:03 - before so to do that in C plus plus
297:05 - there are two implementations these two
297:08 - implementations totally differ by the
297:10 - use cases one is nothing but a vector
297:13 - and the second one is the list so
297:16 - previously we had discussed about this
297:19 - particular implementation which is
297:20 - called a list right so the one let me
297:23 - just open this paint
297:25 - so uh this is the one which we had just
297:27 - discussed right we have different memory
297:30 - locations randomly put in the memory and
297:33 - then we will connect all these locations
297:35 - with a pointer like this
297:37 - now the difference between this
297:39 - implementation and the one we have over
297:42 - here is that this is called a single
297:44 - linked list as a previously discussed
297:47 - but this implementation which is there
297:50 - in the standard template library or the
297:52 - STL is nothing but a double linked list
297:55 - what a double linked list basically
297:57 - means is that
297:58 - you have links from here to here too so
298:03 - it is just like forward link and a
298:05 - backward link you have links in both
298:07 - directions so let's say this link points
298:10 - to here so you have another link which
298:12 - points from the previous element to the
298:15 - next element like this also so you can
298:17 - go either forward or backward as you
298:19 - wish so this is how the the list data
298:24 - type in STL is defined so this is called
298:26 - a double linked list or a dll for short
298:29 - so if you want to implement such data
298:32 - types in scratch we will discuss about
298:34 - how to do that in the next few videos
298:36 - but for now I had explained how this
298:39 - works to explain the importance of
298:40 - pointers right and the vector is nothing
298:43 - but a dynamic array so what it has is a
298:47 - normal arraylex structure it will store
298:50 - data in continuous memory location just
298:52 - like an array but what it does says it
298:56 - will have some extra spaces implemented
298:58 - so it does some calculations and then
299:00 - creates Extra Spaces for future elements
299:03 - and once the sketch filled it will
299:05 - search for another bigger
299:08 - sized location in the memory and then
299:11 - copy all the elements over here and then
299:13 - destroy this from the movie so all this
299:15 - gets copied over here
299:17 - and then you destroyed this completely
299:19 - so this doesn't exist now and this this
299:22 - becomes our new vector
299:24 - and this will keep changing and this
299:27 - process will go on till you stop
299:29 - inserting elements inside the vector
299:32 - now when to use a list and then when to
299:35 - use a vector so let us talk about that
299:38 - now vectors are used when you don't
299:40 - delete element often so in this
299:43 - implementation let's say we delete some
299:46 - two elements from the middle so let's
299:49 - just change the color and we deleted
299:51 - these two elements and then you have
299:53 - some ton of elements over here let's say
299:55 - you have 500 elements over here and then
299:58 - you have let's say 10 elements over here
300:01 - and let's just say that this is the size
300:03 - now if you want to delete these two
300:05 - elements what you do is you create
300:07 - another memory location somewhere and
300:09 - you copy this
300:11 - you just leave these two elements and
300:13 - then copy all these things again then
300:15 - you destroy this memory location so
300:17 - that's how vectors do it and in list
300:21 - it's pretty simple so let's just clear
300:23 - this now to do is deletion in a list
300:25 - what you do is you directly just remove
300:28 - this link that's it this is gone now
300:30 - what you do is you just create another
300:32 - link directly over here
300:34 - and the other link to in case of double
300:38 - linked list and this will go in the
300:41 - memory so once you're not using it it's
300:43 - gone right it is completely Disturbed
300:45 - from my memory so what you need to do is
300:48 - you just need to change the link so that
300:51 - is how simple it is to delete elements
300:53 - in list so in case you have a problem
300:55 - where you want to delete elements often
300:57 - from the middle that is more important
301:00 - you need to implement less right so if
301:05 - you want to delete elements from the
301:07 - middle or uh you are going to perform
301:10 - frequent deletions then you need to use
301:12 - a list or else Vector is a better choice
301:14 - because in list if you want to go to the
301:17 - third element you need to Traverse all
301:20 - this way right you need to find the
301:22 - first element in the second element and
301:24 - then third element but in case you are
301:26 - using a vector what will happen is it's
301:28 - a continuous memory location like an
301:30 - array so if you want to go to the Third
301:33 - location you just in increment the
301:35 - pointer with 3 and then you will get to
301:37 - the Third location that's how simple it
301:39 - is to access elements in a vector or in
301:42 - Array both are almost same so that's the
301:45 - thing if you are using a vector you need
301:47 - to use it when
301:49 - um you are mostly
301:52 - going to access the data right and you
301:55 - need to use a list if you are going to
301:57 - perform frequent deletions
302:01 - so these are the two points to remember
302:04 - and to implement it it's very simple you
302:07 - just include the list first so let's
302:10 - talk about the list and
302:12 - so to create a list what you do is you
302:15 - just put list and then in pair of such
302:18 - angular braces you put the data type
302:21 - what you want so let's say integer list
302:23 - for now so let's call it l and then to
302:26 - add elements you just say l dot push
302:28 - back push underscore back and then you
302:30 - put the image so let push back let's say
302:35 - 20 and then l dot push back 30. so by
302:40 - doing this you will be pushing back all
302:43 - this element so you have created a list
302:45 - which has three elements which look
302:47 - something like this and then if you want
302:50 - to access the elements it's a pretty
302:52 - clumsy way but this is how you need to
302:55 - do it what you do is you create a
302:58 - pointer for this list and for creating a
303:00 - pointer or such a STL data types you
303:04 - have something called an iterator so to
303:06 - do that what you do is you create an
303:08 - iterator for this list so you put this
303:11 - and then you put two search colons and
303:15 - you type iterator so this is how you
303:18 - create an pointer for this list for any
303:21 - such data type which is inside sdn and
303:25 - to move this you do the same thing so it
303:28 - will start from let's say or let's say
303:31 - just I it is going to start from the
303:34 - beginning so l dot begin begin returns a
303:37 - pointer to the beginning
303:38 - and then it has to go to the end so I is
303:41 - not equal to l dot n you can do that so
303:45 - end will again return a pointer to the
303:48 - ending element and then you can do I
303:50 - plus plus just like all we did with
303:52 - pointers and then to get the data you
303:55 - just do star I
303:57 - and then space so this will return us
303:59 - the data so if we now run this
304:02 - you will be getting the data which you
304:04 - entered so 10 20 30 is the data you will
304:07 - be looking how to implement this thing
304:10 - from scratch afterwards but for now this
304:13 - is how you implement in case you wanted
304:15 - to implement a dynamic list and to
304:18 - implement a dynamic array you need to
304:21 - input vector and Vector almost works
304:25 - like this but you have some feasibility
304:27 - right you can work with this like an
304:30 - array so Vector int let's say
304:33 - with
304:34 - and to add elements you do the same
304:37 - thing Big Dot pushback
304:39 - and then add the elements
304:43 - and to access the elements you do same
304:46 - thing like an array so in time equal to
304:48 - 0 and then I is less than the size which
304:51 - you can get by weight dot size and then
304:53 - I plus plus and you can directly access
304:56 - the elements just like you would do in
304:58 - Array you put a square brace and then
305:00 - put in the index so this is how you can
305:03 - access elements in a vector and this
305:05 - will give you the same result
305:07 - so that's how you use Dynamic containers
305:10 - or dynamic collections in C plus plus
305:12 - and that's how pointers play a very
305:15 - important role in designing such
305:17 - containers we will be talking about how
305:19 - to design our own data types and then go
305:23 - to design such collections at a later
305:25 - stage in this video we'll learn how to
305:28 - create our own data types using
305:30 - structures but before that let's first
305:32 - understand what object-oriented
305:34 - programming is now object-oriented
305:37 - programming or object-oriented
305:39 - programming structure as it's upgraded
305:41 - as oops it's nothing but a way of
305:43 - programming so what we have been doing
305:45 - till now is all procedural programming
305:48 - where you create procedures
305:52 - well procedures are nothing but
305:54 - functions and what we have been doing
305:56 - till now is we have been analyzing a
305:58 - problem we have been breaking down the
306:01 - problem into set of simpler problems
306:03 - solving them and then combining the
306:05 - result to give the output now procedural
306:08 - programming works for almost in every
306:11 - problem but when we want to generalize
306:13 - our Solutions procedure programming
306:15 - won't work so let's take an example
306:18 - let's say I want to create a student
306:20 - registration program now for student
306:23 - registration I Define a name I Define an
306:26 - age I Define IES or let's say vectors
306:29 - when the user doesn't know how many
306:31 - records is going to enter and then I
306:33 - will accept all the records and then
306:35 - save them so that does the student
306:37 - registration process now let's say I
306:39 - want to create a program where it the
306:42 - student registration but also it will
306:45 - give us some additional information
306:47 - let's say it's going to say
306:49 - um who is the highest scorer of the
306:51 - class right now
306:54 - what we do is we do all the same steps
306:57 - required for the student registration or
306:59 - the registration to happen and then we
307:02 - write additional functions so that we
307:04 - can compute the highest score or
307:06 - whatever it is
307:08 - now to overcome this problem or to
307:11 - generalize this particular kind of
307:14 - problem solving methods what we do is we
307:17 - create General objects so objects are
307:21 - nothing but collections of similarly
307:24 - grouped features now Here If You observe
307:28 - student is an object right so student
307:30 - has all these features of registration
307:33 - and then students has marks age name and
307:37 - all the features which are required by
307:39 - student and now what you do is you
307:41 - create such an object or you create a
307:45 - class
307:46 - where all the features are grouped
307:48 - together and then you use that
307:51 - particular class whenever you want so if
307:53 - you remember from our pointers video we
307:55 - have been doing something like hash
307:57 - include Vector where we include our
307:59 - vector class this is a class where you
308:03 - have all the features defined inside
308:05 - this now when you want to use it you
308:08 - just create a variable of the vector so
308:10 - you just say vector and where now what
308:13 - we have done is we have created an
308:15 - object of this particular class it's
308:17 - just like creating a variable or a
308:21 - memory location of this particular data
308:23 - type but in object oriented programming
308:26 - we refer to them as objects and classes
308:29 - now what we do is in case you want to
308:32 - add some item into this you just say
308:34 - vector.pushback so although you have so
308:37 - many methods inside this particular
308:39 - Vector but what you are interested in is
308:42 - just storing so you just say push back
308:44 - and then you just put them number you
308:46 - want to insert inside this
308:49 - so this is how objects work you don't
308:51 - know what is going on over here you just
308:53 - know that if you do pushback it's going
308:55 - to go inside the memory and you're
308:57 - seeing that so there's a whole lot of
309:00 - code implemented behind this but you can
309:03 - understand that this particular function
309:05 - is pretty much complicated to implement
309:08 - and it has been implemented for us you
309:11 - just need to use it so you you have a
309:13 - ready-made implementation and you
309:15 - whenever you want to use it you just say
309:17 - dot push and then you can get the
309:19 - function to work so that's how object
309:22 - oriented programming helps us to
309:24 - overcome such redundancy and when we
309:27 - create objects we generally generalize
309:29 - the object so that it can be used for
309:31 - any type of problem where it involves
309:34 - that particular object so that's about
309:36 - object oriented programming now there
309:38 - are some technical terms you need to
309:40 - understand bonus data encapsulation
309:44 - the second one is abstraction or data
309:47 - abstraction and then third one is
309:50 - polymorphism
309:52 - we'll be talking about these things in a
309:55 - great depth at a later stage but for now
309:57 - you can understand encapsulation as
310:00 - combining the features
310:02 - so when you combine all the features
310:05 - which are required by a particular
310:07 - object that is known as encapsulation
310:09 - and abstraction is you show only what is
310:13 - required
310:14 - so here if you see the pushback function
310:18 - is actually an implementation of
310:20 - abstraction so you don't know how this
310:23 - works but what you can do is you can
310:26 - just put in a number and then it goes
310:28 - and sits in the memory and to use such a
310:30 - function it is not required to know how
310:32 - it works so that is abstraction and
310:34 - polymorphism is nothing but able to use
310:39 - the same thing
310:41 - in different ways
310:44 - we'll be talking about this later stage
310:47 - when we are discussing about classes but
310:49 - for now this should do and we'll now get
310:53 - to defining our own data types or as an
310:56 - object-oriented programming we should be
310:58 - calling them as classes well classes and
311:02 - structures are actually different things
311:04 - in C plus plus also they both are
311:08 - literally the same thing so in the
311:10 - implementation of classes and structures
311:12 - you won't find any difference between
311:15 - them but we'll just stick to the
311:17 - Convention of using structures only to
311:20 - Define
311:21 - smaller objects and then use classes to
311:24 - Define somewhat bigger objects why these
311:27 - two things are there but when these two
311:29 - things mean the same thing well C was
311:32 - not an object oriented programming
311:34 - language when C was introduced it did
311:36 - not have this kind of capability to
311:39 - create objects as I've just discussed
311:41 - before so what it had is it had a
311:45 - capability to combine two or three data
311:48 - types and then store it as a collective
311:50 - data type that's what it had and that's
311:52 - what structure was for so when C plus
311:56 - plus was introduced it was made to be
311:59 - object oriented programming language so
312:02 - what they did is they just extended this
312:06 - implementation so that it could hold
312:07 - collections of data types and also it
312:10 - could perform features which I just
312:12 - discussed before you can hold functions
312:14 - related to that particular object or it
312:17 - can undergo inheritance and all those
312:19 - things we'll be discussing about that
312:20 - later that is how structure was designed
312:23 - but when programmers were shifting from
312:27 - C to C plus plus they did not like this
312:30 - idea of using structures in different
312:32 - ways and moreover many object-oriented
312:35 - programming languages which were
312:36 - introduced they had the process known as
312:40 - classes so for that C plus plus
312:43 - introduced another thing called flash
312:45 - but this is just a history it's just a
312:49 - convention but you can use both of them
312:51 - in a similar way in C plus plus right so
312:54 - now let's talk about structures how to
312:56 - use them well do you create a structure
312:59 - you just say strength and then a name of
313:02 - the structure and will call this
313:05 - something let's say student now this is
313:08 - student class or structure you can just
313:11 - call it whatever you want now this
313:13 - particular class that is the student
313:15 - class or student structure this can hold
313:18 - features now what are features does a
313:21 - student have let's say the student is a
313:24 - name a student has an age so end age
313:28 - and what all can a student have let's
313:30 - say marks so let's say a vector
313:34 - in marks
313:37 - now this particular structure or this
313:39 - particular class is just like a data
313:42 - type you can create variables from that
313:44 - so let's say we want to create a student
313:46 - variable you just say student and then
313:49 - let's say S1 now you have created a
313:52 - student if you want to assign a name
313:55 - what you do is dot name and then you
313:58 - assign name so let's say Tony
314:01 - and then to assign an age it's the same
314:04 - way age equal to 10 and then if you want
314:07 - to assign the marks it's just like
314:10 - putting it into a vector so S1 dot marks
314:13 - dot pushback sorry
314:15 - push back
314:16 - 10 and then S1 dot marks Dot pushback
314:21 - 20 and all those things you can almost
314:24 - use it just like you're using but the
314:27 - thing is these variables are dedicated
314:30 - only to this particular student or S1 if
314:34 - you create any other student let's say
314:36 - S2 this is a completely different object
314:39 - and all these things don't work here so
314:41 - if I just say C out S1 dot name
314:45 - you should be getting Tony Asha output
314:48 - that's because s1's name is Tony and now
314:51 - if you change this to S2 you will be
314:54 - seeing that it is blank
314:56 - so as you see here nothing has been
314:58 - printed so
315:00 - that's how objects come handy now if you
315:04 - want to just use the name of the student
315:07 - you can just use the name from here and
315:09 - then you just neglect all these things
315:11 - you don't have to just Define the name
315:14 - Define the age and everything you will
315:16 - have this file somewhere and then
315:18 - whenever you want to do it you just say
315:20 - hash include and then student in double
315:24 - close we will be seeing how to implement
315:26 - this the next video but you can have
315:28 - this in a different file and then you
315:30 - can include this like this and then you
315:33 - don't need all these things you can just
315:34 - say a student S1 S2 and then S1 dot name
315:37 - equal to Tony and this thing will work
315:39 - so that's how you can Define your own
315:41 - data type in structures or as I told you
315:44 - this is nothing but a class and you can
315:47 - have functions associated with it too so
315:49 - let's say I want to create a function
315:52 - which will give me the average marks of
315:55 - this particular student so what we do is
315:57 - I will create a function just like I
315:59 - create normally so avoid average
316:03 - and this doesn't take anything because
316:05 - everything is defined inside and to work
316:08 - on this particular function what I do is
316:11 - I just say In Sum equal to 0 and then
316:14 - calculate the sum first so oriented
316:16 - equal to 0 is less than
316:18 - this marks dot size and now this marks
316:22 - are for the particular student this is
316:24 - not the class marks but it's called this
316:27 - whatever student I'm accessing so that
316:30 - marks will be considered over here and
316:32 - then I plus plus what they do is sum
316:34 - equal to sum plus that marks I
316:39 - and in the end I just returned sum over
316:42 - total now
316:44 - the total is nothing but three total in
316:48 - the sense the total number of marks so
316:50 - marks dot size will give me the total
316:54 - number of marks now here I can just call
316:56 - that function and get the marks so if I
316:58 - just say S1 dot marks Dot pushback
317:03 - something so let's say 10 and then
317:09 - 20
317:11 - 0 marks Dot
317:14 - pushback 40 and now if I call dashman
317:19 - Dot marks sorry sman dot average which
317:22 - is which was a function now this should
317:25 - return us this average okay that's
317:27 - because there's no student file
317:30 - okay what does this say yeah that's
317:33 - because I have put void over here so int
317:36 - and then now if we run this we will be
317:38 - getting 23 as our average marks that's
317:41 - correct because what we have entered is
317:43 - 40 2010 which is 70 and
317:47 - 70 over 3 is 53 so that's correct so
317:51 - that's how you use objects in C plus
317:54 - plus
317:54 - and that's how you create your own data
317:58 - type using structures and here if you
318:01 - see this particular implementation is
318:03 - actually the example of abstraction
318:07 - so here the user actually doesn't know
318:10 - what is the actual computation which is
318:13 - going on behind the screens but he will
318:15 - be getting the average and this is how
318:18 - you implement abstraction and the whole
318:20 - thing is actually encapsulation so here
318:23 - you combined all the features this
318:26 - average is a feature of student and the
318:29 - marks age name all these things these
318:31 - are just features of a student and then
318:33 - you combine all the features so this
318:36 - whole thing is nothing but
318:38 - in capsulation
318:41 - so in the next video we will be
318:42 - understanding how to use classes and
318:45 - when to use classes and structures well
318:47 - you can use them interchangeably there
318:50 - is no restriction on that it's just by
318:52 - Convention as I told you before classes
318:55 - and structures are literally the same
318:57 - thing in C plus plus but it's just that
319:00 - convention matters over here when you're
319:03 - giving your code to somebody else to
319:05 - develop more you need to strictly follow
319:07 - the conventions right in this video we
319:09 - will be looking at classes in C plus
319:12 - plus but before that let's first discuss
319:14 - a small concept which I had missed in
319:16 - the previous video that is how to use
319:18 - pointers when using such Collective data
319:21 - types here if you see we have the
319:23 - student structure which we had defined
319:25 - in our previous video I have just added
319:27 - one single function to print the details
319:30 - of storage and here I have created a
319:32 - student with the name Tony age 10 and
319:35 - then the marks of these things now if
319:38 - you want to create a pointer it's just
319:40 - similar to the way you do for a
319:42 - primitive data type you just put style
319:44 - PTR and then you put PTR equal to the
319:48 - address of the student now if you want
319:51 - to access a particular feature because
319:53 - in primitive data types we did not have
319:55 - features right we just had data so if we
319:58 - did start PTR this was enough but in
320:01 - case of a object we have so many
320:04 - features we have two functions and then
320:05 - we have three variables how do we access
320:07 - these things separately well star won't
320:10 - work here and we have a special operator
320:13 - known as the arrow operator well what
320:16 - this does this basically allows us to
320:19 - access separate features of an object
320:21 - and the way you define our Arrow
320:24 - operator is by using a minus sign and
320:26 - this greater than symbol together so if
320:28 - you combine them that looks like an
320:30 - arrow so that's from where the name
320:32 - comes well if you want to use it you
320:34 - just say PTR that is the name of the
320:36 - pointer the arrow symbol and then the
320:40 - feature you want to access so let's say
320:41 - I want to access the name so if I just
320:43 - put name and then execute this I will be
320:45 - getting a name over here so age also
320:48 - works the same way if I just put age and
320:50 - then try to execute this
320:52 - I'll be getting the age and if I want to
320:56 - access some function let's say the
320:57 - average function I can just do that from
321:00 - here so if I put average and then call
321:03 - that function I'll be getting the
321:05 - average over here
321:07 - so that's how you use pointers the only
321:09 - difference is that instead of star you
321:11 - are now you're going to use this arrow
321:13 - symbol and this is a very important
321:16 - concept as we will see in a minute this
321:18 - is we'll be using a lot when using
321:21 - classes so now let's dive into classes
321:24 - well the way you'd work with classes and
321:26 - structures remain the same so if you
321:28 - want to change this definition to a
321:30 - class definition you just remove the
321:32 - structural keyword and then put class
321:34 - over here so this now becomes a class
321:37 - well the dot operator and then the way
321:40 - you work with pointers this arrow symbol
321:42 - all these things remain the same so you
321:43 - don't have to do anything so now let's
321:46 - do something like then dot print details
321:49 - now if we try to execute this particular
321:51 - function we will be getting an error so
321:53 - let's see what that is it says that this
321:55 - particular name is private
321:58 - well if at all there is any difference
322:00 - between a class and structure that is
322:02 - this thing a structure is public in
322:04 - nature and then class is private well
322:07 - this is not a big deal we can change
322:09 - public to private and private to public
322:11 - we will just talk about that in a minute
322:13 - but what is public and private well in
322:17 - object oriented programming when you are
322:19 - creating objects or when you are
322:21 - creating such Collective data types we
322:24 - don't want everything to be accessed by
322:26 - the outside agent or the user let's say
322:28 - so if we are creating a student data
322:32 - structure and the purpose of this
322:34 - particular data structure or this
322:35 - particular object is just to store the
322:38 - details and then show the details then
322:40 - you don't want the user to manipulate
322:42 - the details right so if I give the
322:44 - access of this marks to the particular
322:45 - user he can manipulate the values inside
322:48 - right so same with the name and age also
322:51 - so if you don't want some of your
322:53 - features to be public in nature that is
322:55 - you don't want some of the features to
322:57 - be accessible by the user you can put
323:00 - them in the private section so how do
323:02 - you put that you just need to put
323:04 - private over here and put a colon over
323:06 - here so in a class everything by default
323:09 - is in this particular definition so if
323:11 - you if you want to make a structure into
323:13 - a class you just need to remove this
323:16 - class and put structure over here now
323:18 - this particular entity is just like a
323:21 - class you will be getting the same error
323:22 - when you executed a class and if you
323:24 - want to create a class into a structure
323:26 - if you want to change a class into a
323:28 - structure what you just need to do is
323:30 - you need to change everything to public
323:31 - now if you change it you will be getting
323:34 - the output just like we got in case of a
323:36 - structure so that's why I told there is
323:39 - no difference between a class instructor
323:41 - although we don't use access specifiers
323:44 - these are called access specifies
323:45 - because they are specifying the access
323:47 - of this features right so we don't use
323:49 - them in structures that's just by
323:51 - convention you can use them there is no
323:53 - restriction on that but we generally
323:55 - don't use them we just use them with
323:57 - glasses so can you have multiple access
324:00 - specifier inside a class well you can so
324:02 - these just Define different features to
324:06 - be either public private so there's one
324:08 - more thing called protected which we
324:10 - won't be seeing in this particular video
324:12 - because uh we'll better understand it
324:15 - when discussing about inheritance but
324:18 - for now we'll just discuss about public
324:20 - and private so as I told you these
324:23 - things become private and I want only
324:26 - the print details function to be public
324:28 - so I'll put public over here so whatever
324:30 - is
324:31 - below private becomes private and
324:34 - whatever is below public becomes public
324:36 - in nature now I can access print details
324:39 - without any issues but I cannot access
324:41 - all these things then how can I actually
324:44 - create an object with these features
324:47 - that is I want the object's name to be
324:49 - Tony H to be 10 and marks to be these
324:52 - things how do we do that if I don't have
324:54 - the access of this variable itself well
324:57 - for that you can Define another function
324:59 - in the public section you can say
325:01 - something like void set detail something
325:04 - like that these are more specifically
325:06 - called Setters these are called Setters
325:09 - but Setters are used only for a single
325:12 - variable so if you want to assign
325:14 - variables at a time when creating the
325:17 - object itself you generally use
325:20 - something called Constructor well
325:22 - Constructor is basically a special
325:25 - function which is used to create the
325:27 - memory when you are creating an object
325:29 - of this type so let's say you are
325:31 - creating an object of this class student
325:34 - you need memory to hold these three
325:36 - variables so Constructor takes care of
325:38 - that particular memory requirement and
325:41 - you don't have to explicitly Define the
325:42 - Constructor although you can and many
325:46 - people use Constructor to assign
325:48 - variables when you are declaring them so
325:51 - in our case we are declaring these
325:52 - variables right which are private in
325:54 - nature so in case you want to declare
325:56 - them while creating you can either use a
325:59 - Setter function or many people just use
326:03 - Constructors for that so the way you
326:05 - define Constructor is it doesn't have a
326:07 - return type so you just need to omit the
326:10 - return type it you should not give any
326:12 - return type and then the name should be
326:14 - the same name as the student so
326:17 - over here you have student as our class
326:20 - name so that should be there and then
326:22 - you will just Define it just like a
326:24 - normal function and here you can pass in
326:26 - parameters and all you have different
326:28 - names for that so if you have a normal
326:30 - constructed definition like this this is
326:32 - called a general Constructor and then if
326:35 - you have parameters inside that let's
326:37 - say string name and then int age so this
326:40 - is called a parameters Constructor there
326:42 - are different names I encourage you to
326:43 - look that up but for now we'll use this
326:46 - particular parameters Constructor and
326:48 - here we will pass in another variable
326:50 - the marks variable and now there is an
326:54 - issue if you see the objects attribute
326:57 - or the object's feature called name is
327:00 - clashing with this particular name well
327:02 - you can change it so that you don't have
327:05 - an issue like this but as I told you
327:07 - when discussing the pointer just now
327:09 - that that's going to play a very
327:11 - important role in classes and that says
327:14 - where this comes into play this is is
327:17 - basically pointer
327:20 - it is called this pointer only so if you
327:22 - just put this you can see that it is
327:24 - bold it indicates that it's a property
327:27 - of the compiler it's a reserved keyword
327:29 - this is basically a pointer which will
327:32 - point to the current object itself
327:34 - so let's say I have 10 students and then
327:37 - I'm working on the seventh student so if
327:40 - I use this pointer then I will be
327:43 - accessing the seven student details not
327:45 - any other student details so this
327:48 - basically points to the current object
327:50 - which is getting used and then we use it
327:52 - just like we did in case of our own
327:55 - pointer so this and then this particular
327:57 - arrow symbol which is called the arrow
327:59 - operator and then the variable name so
328:01 - name equal to name you could say this
328:04 - age equal to age and then this
328:08 - marks equal to Marks well if you don't
328:11 - want to use this particular definition
328:12 - you can always rename this and this
328:15 - won't be a issue but just explain the
328:18 - importance of this particular pointer
328:20 - and this Arrow operator I just took this
328:22 - particular example but you're free to
328:24 - use whatever way is convenient for you
328:27 - many people tend to use this particular
328:29 - definition and here when we are creating
328:31 - you just need to pass in when creating
328:34 - itself so here if you put parenthesis
328:36 - and then pass in your variables so name
328:39 - equal to Tony and then the age is
328:42 - something 10 and then the marks well you
328:44 - need to create another variable for
328:46 - marks or marks and we'll push back all
328:50 - these things inside this particular new
328:52 - variable
328:55 - you don't need s over here because this
328:57 - is an independent variable now we just
328:59 - created a new variable in our memory and
329:02 - here you just need to pass in marks
329:04 - and now if you just remove all these
329:07 - things this should work as expected so
329:09 - if we now run this
329:11 - you will be getting the output just like
329:13 - we got in a case of structures and now
329:16 - you have successfully implemented an
329:18 - object oriented design so something is
329:20 - private something is public you are not
329:23 - giving access to everything and all
329:25 - these are basically features of object
329:27 - oriented programming
329:29 - so now let us see another very important
329:34 - function which is a special function
329:35 - called the destructor well this is not
329:38 - used much but since it's the part of
329:41 - object oriented programming we'll
329:42 - discuss it quickly it's basically the
329:45 - same thing as a Constructor it is
329:46 - defined by the compiler itself it's a
329:48 - default thing it Destructor what it does
329:51 - is it will scrape out the object from
329:53 - the memory so if you are running out of
329:56 - scope so let's say we had defined this
329:58 - object inside an if block so once the
330:01 - block has been executed that variable is
330:04 - out of the scope right so once
330:06 - everything gets out of the scope it's
330:07 - going to be scraped out of the memory so
330:09 - that's when a Destructor is called so if
330:12 - you want the destructor to do something
330:14 - else you can just do that by putting
330:16 - this tight symbol and then you define
330:18 - the destructor with the same name as a
330:21 - class and again you don't put any return
330:25 - type for the destructor and it does not
330:28 - even take any parameters so you cannot
330:31 - pass any parameters to Destructor you
330:33 - cannot call the destructor from anywhere
330:35 - you can just see what it does so if you
330:38 - just call this descriptor let's say uh
330:41 - I'm being scraped
330:44 - something like that you will be seeing
330:46 - this when the object gets out of the
330:48 - scope so
330:50 - um we'll just put something over here if
330:53 - some condition 10 equal to 10 this is
330:56 - going to be true so all these things
330:57 - will be executed
331:00 - and
331:02 - over here we will put something like
331:05 - done
331:07 - we'll put a new line also so that we can
331:09 - differentiate
331:11 - so if you know execute this you will see
331:13 - all this details and then it says I'm
331:16 - being scrapped and then done that is
331:18 - because once the F block has been
331:20 - executed that particular object has been
331:23 - removed after the scope that then it
331:25 - should be ready to be removed or to
331:27 - memory two so just remove that thing
331:30 - from the memory that's why this message
331:32 - is printed and then you have this done
331:34 - which is outside the if block which
331:38 - indicates that this has been scraped
331:41 - before coming over to this statement so
331:44 - that's the use of Destructor if you want
331:46 - to see when the object is getting
331:48 - removed from the memory you can use
331:50 - Destructor we will again talk about this
331:53 - when we are discussing about inheritance
331:56 - but Constructor is mostly used to
331:58 - actually pass in parameters when we are
332:01 - declaring a particular object something
332:03 - like this so now how do most people use
332:07 - classes in C plus plus well mostly
332:11 - people don't use classes in the way we
332:13 - used over here we wrote the class
332:15 - definition and the main function
332:17 - everything in a single file right so
332:20 - people generally don't tend to do that
332:22 - people generally use multiple files in
332:24 - their program
332:26 - so you have one particular file only
332:28 - executing the main program and then you
332:31 - have multiple objects so you don't put
332:33 - all the objects in a single file you
332:35 - create multiple files for holding the
332:37 - objects and then if you want to use this
332:40 - particular class let's say the student
332:42 - class you just include it just like this
332:44 - particular Vector so what you do include
332:46 - and then you put the student over here
332:49 - student dot h that's an extension we'll
332:52 - be seeing how to create this and here
332:55 - instead of angular braces you need to
332:57 - put this coach so this indicates that
333:00 - this is something from this particular
333:01 - directory and not from the compiler so
333:04 - these things are available in the
333:05 - compiler that's why we are putting this
333:07 - angular braces and here you are putting
333:09 - this to indicate that this is from from
333:11 - this particular directory or this
333:13 - particular project
333:15 - so you have two files when declaring
333:18 - such classes so what you do is you have
333:21 - one header file where you declared the
333:24 - skeleton of The Flash and then you have
333:27 - one CPP file
333:30 - which is just like this one which will
333:32 - hold the definition of this class so how
333:36 - do you substrate that so let's say I
333:38 - want a particular function to diff to be
333:40 - defined in a separate file so let's just
333:42 - say this particular function uh called
333:45 - to be defined a different file so how do
333:48 - we do that you just need to put a
333:50 - semicolon over here so this is just like
333:52 - a function prototype which we had
333:54 - discussed and let's assume that this is
333:56 - another file so this class is in some
333:59 - other file you just did something like
334:01 - hash include student.h and then if you
334:03 - want to Define this particular function
334:05 - the way you do that is you just Define
334:07 - this function normally as with this is
334:11 - just a normal function it it doesn't
334:13 - have anything to do with this class You
334:15 - just defined it so let's say uh I'm
334:18 - called and something like that you just
334:20 - Define it like this and then over here
334:24 - to Define that this particular function
334:27 - is specifically designed to display
334:30 - particular class or this function should
334:33 - be available only to this particular
334:35 - class what you do is you just put in
334:37 - this particular class name and then you
334:40 - put two columns over here so this will
334:43 - indicate that this particular function
334:45 - is to be used only with this class that
334:48 - is the student class now you cannot use
334:51 - call directly you need to call it using
334:54 - the student class so if you want to use
334:56 - that so you can say something like
335:00 - s dot called and it will work normally
335:03 - so that's okay we don't have the
335:06 - student.h right now we don't need these
335:09 - things also
335:11 - so if you run this okay there's another
335:14 - type over here
335:18 - okay so here you can see I am called
335:20 - that is from this particular function
335:22 - which we just defined that this called
335:25 - function over here and uh here this is
335:28 - the message from the destructor that is
335:30 - I am being script
335:32 - so that's how we actually use classes
335:36 - but this particular ID which is the code
335:40 - blocks ID provides an easier way to
335:42 - create classes you don't have to Define
335:44 - all these texts that is you don't have
335:46 - to create two files and then put them it
335:48 - will neatly organize everything and give
335:50 - it to you so how do you use that well go
335:53 - to file you go to new and then you
335:55 - create a class over here so you have
335:58 - class name so you just give some name
336:01 - let's say student
336:02 - and then here in place of arguments you
336:06 - just leave it so it has hash Destructor
336:08 - virtual Destructor all these things you
336:10 - don't have to understand all these
336:12 - things right now you can just ignore
336:13 - them but I will understand what all
336:16 - these things are in later videos and now
336:18 - if you just click on create you can see
336:21 - that the new class has been created do
336:23 - you want to add it to the current
336:24 - project if you just say yes and then you
336:27 - just put OK over here and then you will
336:29 - see that in headers you will have an
336:32 - include folder inside which you will
336:33 - have student.h so here if you see it
336:36 - just has the definition it just increase
336:38 - the font size
336:41 - uh here you can see it just has some
336:43 - definition you don't need this this is
336:45 - basically the virtual distractor we'll
336:48 - talk about that later and here you have
336:50 - a Constructor and you have protected and
336:53 - private you don't need protected also as
336:56 - I told you we'll be discussing about
336:58 - that when we are discussing inheritance
337:00 - and you have some special comments over
337:02 - here so what this roughly means is that
337:05 - once a particular class has been
337:08 - included in a memory and if it's again
337:11 - trying to include it you don't do that
337:13 - because we are using two files so let's
337:16 - say I'm using a function from this
337:19 - particular file so when I don't want
337:22 - this particular function to again
337:24 - include it so here you can see hash
337:25 - include student.h so when I'm doing it
337:29 - multiple times I don't want this
337:31 - particular class to be loaded into my
337:33 - memory multiple times so this particular
337:36 - guard block will as it's called This is
337:38 - called a guard block
337:41 - card block what this will do is it will
337:44 - take care of this particular issue it
337:47 - won't allow this class to be included in
337:49 - the memory multiple times now and here
337:51 - you just declare the skeleton so here if
337:54 - you see uh if you want to create this
337:56 - particular class again uh we'll just
337:58 - create a small version of that so it
338:01 - will just have a age let's say in age
338:05 - and in public you will have a Setter
338:08 - function you will just say uh set age or
338:12 - new interest directly use it inside over
338:14 - here so in page you can just say and
338:18 - private I prefer private to be in a
338:21 - beginning but it's up to you the order
338:24 - doesn't matter I just put private in the
338:26 - beginning and then public at the end
338:28 - protected in the middle so that's our I
338:31 - use classes but it doesn't matter you
338:33 - can use it the way you prefer
338:35 - and now you just need to Define this
338:38 - Constructor in the student.cpp file we
338:41 - don't need this virtual Constructor I
338:43 - just deleted that and here you just
338:45 - Define it normally so age is something
338:48 - private but you can access private
338:50 - variables inside a class so you can say
338:53 - something like
338:55 - this age
338:58 - equal to age
339:00 - and here if you want to use this class
339:02 - let us just remove this class because
339:04 - I've already defined it so remove this
339:09 - and if you want to include that student
339:11 - class you just say hash include and then
339:14 - student.h
339:16 - and now all these things work fine well
339:18 - we don't have everything over here so we
339:20 - need to redefine it so let's quickly do
339:23 - that student S10
339:26 - and if you execute this what do we have
339:29 - here it says yeah because we forgot to
339:32 - put the parameter over here it is int
339:35 - age
339:37 - and
339:39 - see we did not get any error so that's
339:41 - how we generally use classes if you want
339:45 - to create another class go here new and
339:47 - then class and you can create another
339:48 - class
339:50 - so people generally tend to use classes
339:52 - like this you have neatly structured
339:55 - thing over here so you have a main.cpp
339:57 - over here and here the student.cpp goes
340:00 - inside the source file so that you don't
340:03 - get confused so everything the header
340:05 - files which I talked about the student.h
340:08 - or anything class header files are
340:10 - basically class name dot h and all these
340:13 - things go inside this include folder and
340:16 - the definition file which is basically
340:19 - class name dot gpp all those things go
340:21 - inside the source folder and Main file
340:25 - will be outside and you can use that
340:28 - main file to execute the program
340:30 - everything starts from the main file
340:32 - generally name that as main.cpp where
340:35 - the execution starts and we include all
340:37 - our objects like this using this
340:40 - particular syntax that is you pass in
340:42 - the classname.h file using this
340:45 - particular quotes and the guide block
340:47 - which we just talked about
340:49 - this one this basically takes care of
340:52 - multiple allocations of memory of this
340:55 - particular class so that's all about
340:57 - classes in the next video we'll make
341:00 - another one of our projects so our
341:02 - previous project was the tic-tac-toe
341:04 - game well we'll again make another game
341:06 - in the next video because I think games
341:09 - are fun to make and then we can learn a
341:12 - lot from them in this video we'll be
341:14 - making our second programming project
341:16 - which is going to be this the snake game
341:18 - so I'm sure everybody knows how to play
341:20 - this game you have a snake which grows
341:22 - on eating the food and the objective is
341:24 - to grow the snake as long as possible
341:26 - without hitting yourself or hitting one
341:28 - of those so if you do any of those you
341:30 - lose this game
341:32 - well there are different variations of
341:34 - this game some have teleportable walls
341:36 - that is if you go through this wall you
341:38 - end up coming from there and some
341:41 - versions even have obstacles in between
341:43 - them instead of this free space but
341:45 - we're not going to do any of those we
341:47 - are just going to stick to the simple
341:48 - version with four concrete walls and uh
341:51 - empty space in between right so let's
341:54 - get started let's create a new project
341:56 - it's going to be a console application
342:00 - and the language is C plus plus project
342:03 - title let's say snake and these things
342:06 - remain as it is right
342:08 - and now let's first start by defining
342:12 - the board
342:14 - so if you remember from our previous
342:16 - project where we made our detector game
342:18 - we had defined a 2d array or a matrix to
342:22 - hold the board right but here if you see
342:24 - you don't need that why well in the
342:27 - previous game where we made the
342:29 - tic-tac-toe game the board only had nine
342:31 - elements and we were concerned about all
342:34 - the nine elements of the board right so
342:36 - we were concerned about what all the
342:38 - boat contained but here you don't have
342:41 - to actually be concerned about all the
342:44 - elements of the board here the boat just
342:46 - acts as a background the only things you
342:48 - are concerned about are the position of
342:50 - the snake uh the position of the fruit
342:53 - and the position of the wall so other
342:56 - than that you don't need to keep track
342:58 - of other things so here we are just
343:01 - going to print the board just like we
343:04 - print something on the console so let's
343:06 - define a function for that let's say
343:09 - avoid the board
343:11 - and here we are going to draw the board
343:13 - so uh let's first Define the dimensions
343:16 - of the board the width and height so
343:18 - let's say uh the width is going to be
343:21 - somewhere around the 50 characters so
343:23 - since we are working on the console you
343:25 - are going to see everything in terms of
343:27 - characters or this is basically a
343:29 - substitute for pixels if you are
343:31 - familiar with graphics and
343:33 - the height is going to be somewhere
343:35 - around let's say 25 characters
343:38 - now these two things are constant right
343:41 - so the these won't change throughout the
343:43 - project so if you want to make them as
343:45 - constant so you can just say const over
343:47 - here so this keyword will make these
343:50 - things as consonants and now I would
343:52 - like to introduce you the concepts of
343:55 - macros so macros let me write it down
343:59 - here macros these are nothing but one
344:01 - liner code right so let's say you want
344:05 - to Define
344:06 - a function to calculate the square so
344:09 - what you do typically is you write
344:10 - something like this right so in SQ and
344:13 - this will return X into X right so this
344:17 - is how you define a small function but
344:20 - what you can do is instead of defining
344:22 - it as a function you can Define it as a
344:25 - symbol
344:26 - so when I pinch symbol what I mean is if
344:29 - I type that particular symbol then this
344:31 - operation should be performed so that is
344:33 - what a macro does so the way you Define
344:35 - macro is you put hash Define and then
344:38 - you put the symbol so let's say SQ over
344:41 - here and inside this whatever parameters
344:43 - you want to pass without any data type
344:45 - so this is basically a symbol
344:47 - and here you want to define the
344:50 - operations so here uh our operation is X
344:54 - into X so that is basically going to
344:56 - return us the square of a number so here
344:59 - you don't have any assignment operators
345:01 - or written operators all this means is
345:04 - whenever I say SQ of X it should do this
345:07 - particular operation so if you say
345:09 - something like SQ of 5
345:13 - and here if you run this you should be
345:15 - getting the output as 25. so that's why
345:18 - we use macros and you can do the same
345:20 - with these two variables also so the way
345:24 - you define it as hash Define width is 50
345:28 - and
345:29 - hash Define
345:32 - height
345:34 - 25 so now whenever I say width I mean 50
345:38 - and whenever I say height I mean 25 so
345:41 - now we can remove this you don't need
345:43 - this anymore so now the board is going
345:45 - to be two Loops the first Loop or the
345:48 - outer loop is going to control the
345:49 - number of rows so here the number of
345:51 - rows is defined by height right because
345:53 - height is basically how down you go so
345:56 - that is how many rows you have in your
345:58 - board so I is less than the height of
346:01 - the board and I plus plus and inside
346:04 - this you will control the width so enter
346:06 - and let's say J equal to 0 J is less
346:10 - than the width J plus plus and inside
346:13 - this you are going to print something so
346:15 - Here If You observe this board for every
346:18 - row there are two wall pieces right so
346:20 - every row starts with one wall and then
346:22 - ends with one volt so since that default
346:25 - you can subtract 2 here and then put
346:27 - those two characters so you have one
346:29 - ball in the beginning
346:31 - of a row and one wall at the ending of
346:34 - the row
346:36 - and then you go to a new line
346:39 - and inside this
346:41 - basically if the row number is 1 or the
346:45 - row number is
346:47 - height minus 1 that is if you are
346:50 - printing this row or this row then you
346:54 - need to print all walls so here we are
346:56 - just going to print out these hashes
347:00 - or else you need to print out the empty
347:03 - space which is basically this space
347:05 - right so now if you call your board
347:08 - function that should print a board for
347:11 - us so here we have the board
347:15 - now this code looks pretty squished to
347:18 - the left so you can take care of that by
347:21 - adding a couple of tabs
347:23 - and that will Center the board
347:27 - so now let's see how to animate things
347:31 - on the console so if you are familiar
347:33 - with Graphics or even if you have heard
347:36 - about animation you might know that
347:38 - animation is nothing but just fast
347:41 - moving pictures right so here if you
347:43 - want to animate something on the board
347:45 - let's say you have some object on the
347:48 - board then the way your animators you
347:50 - will quickly move the position of that
347:52 - object and it will appear as moving so
347:55 - to move something on the board or to
347:57 - place something on the board you need to
347:59 - know about the coordinate system which
348:01 - the computer uses so let's talk about
348:03 - that quickly so you might have come
348:05 - across this Cartesian coordinate system
348:07 - in your math class right so you have a
348:10 - coordinate system where if you go right
348:12 - the x coordinate increases and if you go
348:15 - vertically upwards your y coordinate
348:18 - increases and this position basically
348:21 - which is the intersection of these two
348:24 - axis this is the origin which is defined
348:27 - by this 0 0 coordinate right so this is
348:30 - the coordinate system you all have come
348:32 - across in your math class now
348:35 - what happens in a computer is this
348:37 - origin is shifted to this top left
348:39 - corner so let me just clear this thing
348:44 - so in a computer your axis are defined
348:46 - as follows so
348:48 - if this is the top left corner of the
348:51 - screen that is this position where I am
348:53 - pointing my cursor that position is
348:56 - basically your zero zero position so
348:58 - this is your origin in a computer
349:00 - and I should go write your x coordinate
349:03 - increases and as you go down
349:06 - your y coordinate increases so basically
349:09 - your y-axis is flipped in case of a
349:12 - computer and X Remains the Same so as
349:15 - you go up your Y is decreasing and as
349:20 - you go left
349:22 - your x coordinate decreases so the
349:25 - coordinate system in a computer is
349:27 - defined you can use this coordinate
349:29 - system to move objects in your screen or
349:32 - even Place objects in your screen so
349:34 - every object is defined by x coordinate
349:37 - and y coordinate so if you put some
349:39 - point here so it has some
349:42 - x coordinate that is how much it has
349:45 - moved from the origin in the horizontal
349:47 - Direction and some y coordinate that is
349:50 - how much it has moved from the vertical
349:51 - direction right so this is how the
349:54 - coordinate system of a computer is
349:55 - defined and we will be using this system
349:57 - to operate on our board right so let's
350:01 - define an arbitrary object somewhere so
350:04 - let's say our int X which is the x
350:08 - coordinate is going to be somewhere
350:09 - around 10 characters and Y is also 10 so
350:12 - that means that this is 10 characters
350:15 - from the left and then 10 characters
350:17 - down so it it will be in some arbitrary
350:20 - position somewhere let's just see where
350:22 - it is so if I here if I print that
350:26 - particular object that is pretty simple
350:28 - to print so if the coordinates match you
350:30 - are going to print that object so how do
350:32 - you do that well I is controlling the
350:34 - height right so height defines how deep
350:36 - you are on the board so that is
350:38 - basically the y-axis so you need to
350:40 - compare I with Y and G okay with X so if
350:45 - you if these two coordinates are equal
350:46 - then you can say that your object is at
350:49 - that particular position and you can
350:51 - print something so let's go with this
350:53 - zero for now so that is going to be our
350:55 - object
350:57 - now if I try to print this code
350:59 - you will be getting your object here so
351:01 - and this is 10 characters from the left
351:04 - and 10 characters towards to bottom but
351:06 - if you see this position is exactly not
351:09 - as Square as expected uh that is because
351:12 - in console the next line has some Gap if
351:16 - you see over here so this Gap is much
351:19 - bigger than this Gap that is why it
351:22 - doesn't end up as a square but if you
351:24 - are using some graphics library then
351:26 - this will work so it will exactly be as
351:30 - a square so it it will end up somewhere
351:32 - over here so this could be the 10 comma
351:34 - 10 point but here since we are working
351:36 - on the console uh the y-axis is much
351:40 - wider or I should say much deeper than
351:43 - the x-axis so uh even when you animate
351:47 - your snake it's going to move faster on
351:49 - the vertical Direction than on the
351:51 - horizontal Direction that's actually not
351:53 - a logical error that's because of the
351:55 - property of console you cannot do
351:56 - anything about that right so if you are
351:58 - using any graph fix library then that
352:01 - problem won't be there so now let's see
352:03 - how to animate this animating is very
352:06 - easy you just need to move the board
352:07 - right so uh let's say
352:10 - I will create an infinite Loop here
352:13 - and inside this we will first call the
352:15 - board and every time
352:17 - this Loop runs we will just increment
352:19 - the x coordinate so when entrance x
352:22 - coordinate from this coordinate system
352:23 - your object is going to move towards the
352:25 - right right so now if you're on this
352:28 - program you should be getting some kind
352:29 - of movement so here you can see that
352:31 - this o is moving towards the right but
352:33 - you cannot actually see it as a movement
352:36 - this is basically it is just printing
352:38 - the board again and again so
352:40 - if you have somewhere to update the
352:43 - board then you can see the movement so
352:46 - one way you can update is you can use
352:48 - your console command so if I pull up my
352:51 - console over here this is basically a
352:52 - Powershell but uh in Windows or if
352:56 - you're using this code blocks in Windows
352:58 - it's going to use the use your CMD as
353:01 - your default console right so in CMD the
353:05 - command for clearing a screen is CLS so
353:08 - if I type something over here under type
353:10 - CLS that thing is cleared right and if
353:14 - you're a Linux the command for clearing
353:16 - is clar and the way you pass in such
353:19 - shell commands or such console commands
353:22 - are you include another Library called
353:27 - cstdlib which stands for C standard
353:30 - Library you might have come across this
353:31 - while making a tic-tac-toe game this is
353:34 - the library which had our random
353:36 - function and we will be using that
353:38 - random function in our code as well
353:39 - right
353:40 - so here to send commands to the console
353:44 - you use system and inside this you write
353:47 - the command so in in my case it is the
353:50 - Windows operating system so I write CLS
353:52 - and in case you're on Linux you need to
353:55 - write clear right so let me just comment
353:57 - this thing if you are in Linux you need
353:58 - to write clear and I forgot the
354:01 - semicolon and now if I run this I should
354:04 - be getting a moment but if you see here
354:07 - it kinds of flickers on my screen right
354:10 - so this board is getting updated but it
354:13 - is annoying to see so uh this you cannot
354:17 - actually control so more technically if
354:21 - you know about the FPS or the refresh
354:23 - rate so you cannot control these things
354:26 - of a console console is not a property
354:29 - of the language or this ID right it is a
354:32 - property of the operating system so you
354:36 - cannot control something from an
354:38 - external source which belongs to the
354:41 - operating system so one way you can take
354:44 - care of this flickering is instead of
354:46 - clearing the screen this is happening
354:48 - because it is doing two processes right
354:50 - first it is clearing the screen and then
354:52 - again it is drawing the board so if you
354:55 - just override the port as we used to do
354:57 - with our normal line so if you remember
355:00 - from our Escape sequences video we had
355:02 - talked about an escape sequence called
355:04 - slash R right so if you write something
355:07 - over here let's say
355:09 - hello world
355:11 - and here if I put slash R and I type
355:16 - something else so ASAS then the first
355:19 - four characters which are these four
355:21 - characters are going to be replaced by
355:23 - the word ASAS so now if I run this I
355:26 - should be seeing as ASO word so that is
355:29 - because HG LL has been refreshed by this
355:31 - that is because this slash R will take
355:34 - the cursor from the end of the line and
355:37 - place it in the beginning but we cannot
355:40 - use the slash R over here that is
355:42 - because we are using multiple lines
355:43 - right so you are printing around let's
355:46 - say 25 lines because the height is 25 so
355:48 - you are printing 25 lines and there is
355:51 - no escape sequence to get your cursor
355:53 - back a line so slash n will move your
355:56 - cursor down a line but you cannot go up
355:58 - a line right so for that I am going to
356:02 - tell you a solution but this is going to
356:04 - work only if you are on windows so let
356:06 - me write it down here this is only for
356:08 - Windows and if your Linux you need to
356:11 - find out Library which tested so
356:14 - basically what we are going to do is we
356:16 - are going to pick up this cursor from
356:18 - the end of the screen and we are going
356:20 - to go all the way up to the origin and
356:23 - place it back so if you do that instead
356:26 - of clearing the screen you are moving
356:27 - the cursor and when you print your data
356:30 - again it's going to be overwritten on
356:31 - the console so it looks like it has been
356:34 - cleared but actually it has been
356:36 - overwritten instead of clearing so this
356:39 - solution what I'm going to give you in
356:41 - this particular video will work only if
356:43 - you are on windows so if you are on
356:45 - Linux you need to find out some Library
356:46 - which will do that for you right so if
356:49 - you are in Windows you need to include a
356:50 - library called Windows starter which
356:52 - will basically allow you to control the
356:55 - cursors position on your console
356:57 - and here what you need to do is instead
357:00 - of system clear
357:02 - you can do set
357:05 - console cursor position and here you
357:09 - need to give some handle which is get
357:12 - STD handle Insider STD output handle so
357:18 - if you don't understand what this means
357:19 - it's okay it's just you can think of it
357:23 - as it's going to pick up the cursor from
357:25 - the end and it's going to put it back on
357:27 - the origin and to put it back on the
357:29 - origin or any specific chord that you
357:31 - need to pass in a coordinate data
357:35 - structure well coordinate is basically a
357:37 - simple data structure which is already
357:38 - defined in Windows dot h and we will be
357:40 - using this so if you're on Linux and
357:42 - you're using some other library to
357:44 - achieve this you need to Define this
357:46 - structure to follow along with this
357:48 - tutorial which is basically a simple
357:49 - structure it does something like paint X
357:53 - and Y so this is the structure which is
357:57 - defined in Windows so I'm not going to
357:58 - Define this again it's there in this
358:01 - Windows dot Edge and that's what we are
358:03 - using over here to send the position to
358:06 - our handle which will basically take the
358:10 - cursor from this position and then put
358:12 - it back to the origin so the origins
358:14 - coordinate are basically 0 0 so you need
358:17 - to pass that in and now if you see you
358:20 - won't have any flickering screen you
358:22 - will have a neat animation going on on
358:24 - your screen
358:25 - so as you can see there is no flickering
358:27 - although you can see that cursor updates
358:29 - somewhere but this is much better right
358:31 - instead of the flickering screen so
358:33 - again this solution is only for Windows
358:36 - user so if you're in Linux you have some
358:38 - other libraries like uh you have n
358:41 - cursors and many other libraries a
358:43 - simple Google search will get you what
358:45 - you want right now let us remove all
358:49 - these things we have now understood how
358:51 - to do animation and here
358:54 - what we're going to do is we are first
358:56 - going to Define our snake so go to file
359:00 - new and Clash
359:03 - and the name of the class is snake and
359:07 - you can remove all these things right it
359:09 - doesn't really matter you don't need
359:11 - Destructor on all these things we'll
359:14 - create if we want to right and here just
359:17 - click OK and
359:20 - in snake.h we have this template code so
359:23 - again I prefer private to be on the top
359:27 - so if you want that you can follow this
359:29 - or if you if you are okay with the
359:32 - structure it has given before you can
359:34 - follow that it doesn't really matter
359:36 - and here first of all we are going to
359:39 - decide what is going to be private and
359:41 - what is going to be public so what are
359:43 - the features that we need our snake to
359:45 - have first of all it will have a
359:47 - position right the position of the head
359:49 - to be precious and next it should have a
359:53 - length to Define how long the snake is
359:55 - and you also need a Direction
359:59 - and you also need a velocity or you can
360:02 - say speed of the snake so how fast it
360:05 - moves so here in case of velocity or
360:07 - speed we are going to talk
360:09 - in terms of number of characters so let
360:12 - me write it down here that is basically
360:14 - it is going to move two characters at a
360:16 - time three characters at a time and so
360:17 - on so in case you are working with some
360:19 - graphics Library that's the same thing
360:22 - you do with pixel so you say three
360:23 - pixels every time more five pixels at a
360:25 - time and since here we are on Console we
360:28 - are going to talk everything in terms of
360:31 - number of characters right so uh here
360:34 - let me Define the private variables
360:36 - first thing is you are having to have a
360:38 - position so it's going to be chord
360:40 - position so again if you are in line if
360:42 - you need to define the structure and uh
360:45 - for using this code you need to include
360:47 - uh windows startage okay so this is
360:49 - because this is a separate field Which
360:52 - snake cut HSS update file so even if you
360:54 - are included in main you need to include
360:57 - it again but you can exclude this over
360:59 - here because
361:00 - once we actually include this file you
361:03 - are going to include all these things it
361:04 - doesn't matter even if you keep it twice
361:07 - because of this guard block as I
361:09 - explained before this guard block what
361:11 - it does is it takes care of multiple
361:13 - initialization so here I have already
361:15 - included windows.h now I when I do hash
361:18 - include uh snake.h it will take care of
361:22 - the fact that I have already included
361:24 - Windows started so I don't need to
361:25 - include it again but here if you want to
361:28 - use these things you need to definitely
361:30 - specify that you are using windows.h or
361:32 - else you cannot use this and will throw
361:34 - you an error right
361:36 - and here you need a length of the snake
361:40 - and you have a velocity so and well and
361:44 - you have a Direction so let's say car
361:45 - Direction
361:46 - and in the public section we need to
361:49 - Define Constructor first and this is
361:51 - going to take a position that is the
361:53 - initial position and initial velocity
361:56 - for our snake so let's define this
361:59 - Constructor and snake.cpp
362:01 - and here we'll be talking specify those
362:05 - things so chord position and end
362:08 - velocity and here you don't have to
362:10 - include Windows attach that is because
362:12 - again you are including snake.h which
362:15 - comes with Windows started so you don't
362:17 - have to include it again and here
362:20 - you need to set the position and
362:22 - velocity so since I'm using the same
362:25 - name for both the variables I need to
362:27 - use this pointer so if you are not using
362:30 - the same name it's okay but if you are
362:32 - using the same name you need to use this
362:34 - pointer and the velocity also goes in
362:38 - the same way and initially the length is
362:41 - going to be 1 that is because you have
362:44 - one head right so without the length
362:47 - cannot be zero because you always have a
362:49 - head for this link so the length is
362:52 - going to be 1 initially and the
362:57 - direction so the direction you can say
362:59 - uh something like none right because the
363:02 - snake is not moving now and we'll have a
363:06 - method to change the direction of the
363:08 - snake so let's say uh change dir which
363:12 - will change the direction it will take
363:14 - some direction to change it and here
363:17 - let's define that method let's void
363:20 - snake
363:22 - change dir
363:24 - a and what you need to do is Direction
363:28 - equal to Dr and basically I'm just
363:30 - setting the direction of a snake and um
363:34 - for moving the snake let's create a move
363:37 - method or move snake well moose
363:40 - basically a defined method in C plus
363:42 - plus so uh it's not preferable to
363:44 - overwrite it you can overwrite it you
363:46 - can define something like this but it's
363:49 - preferable not to overwrite any default
363:52 - method so let's say move snake I'm just
363:55 - not going to take any parameters because
363:57 - it's just going to perform something so
363:59 - avoid the snake move snake
364:03 - and here what you need to do is you need
364:05 - to switch the direction that is
364:07 - basically you need to move the snake in
364:09 - that particular direction so switch
364:11 - Direction and here you need to put
364:14 - different things so in case it is going
364:16 - up then what you need to do refer to
364:19 - this coordinate system you need to
364:21 - decrease the y coordinate so what we're
364:23 - going to do is pause dot capital Y minus
364:27 - equal to the speed so basically if I say
364:30 - that my snake is moving two characters
364:32 - per second or two characters per
364:34 - iteration then I need to subtract those
364:37 - many characters right to move to appear
364:39 - to be moving in that much speed so that
364:42 - is why we are going to subtract the
364:43 - velocity over here or speed you can name
364:45 - it whatever you want and here the break
364:48 - is mandatory
364:50 - and this will be true for all the four
364:53 - directions so let me just copy it down
364:55 - four times and uh it's going to up down
364:58 - left and right right is you need to
365:01 - increase your velocity left test you
365:03 - need to decrease your velocity
365:05 - and um for down you need to increase
365:08 - your velocity on the y coordinate so
365:11 - this will move your snake in your
365:12 - preferred Direction and that should be
365:15 - it so now you have a snake you have
365:17 - initialized it with some initial
365:19 - position and velocity and you have a
365:22 - method to change the direction of a
365:24 - snake and now you even have a method to
365:27 - move the snake and here since we need
365:30 - the position of the snake to draw it on
365:33 - the board you also need a method to get
365:37 - the position so let's say uh
365:39 - or the get post which will return the
365:43 - position of the snake and this is going
365:47 - to be written first and I forgot to
365:51 - mention snake here this will be declared
365:54 - as normal function if I forgot to
365:55 - mention this this basically means that
365:58 - this get pass function is related only
366:01 - to the snake class right I'm sure
366:04 - everybody knows this and here
366:06 - we will quickly Define a prototype for
366:09 - that it's called Uh get pause
366:13 - and done so now you have four methods
366:16 - let's go over it quickly one is a
366:18 - Constructor which will initialize our
366:20 - variables one is a method to change our
366:23 - Direction so change
366:27 - the direction of the snake
366:30 - and one is to move the snake
366:34 - in that particular direction and one is
366:38 - to get the position of the snake or I
366:42 - should say get the current position of
366:44 - this name so now let's use this thing in
366:46 - our main file so you here as I told you
366:49 - you can remove this window startage
366:51 - because it is going to be included with
366:52 - sneak.h and uh here let us first create
366:55 - a snake so snake as all it's a snake and
366:59 - inside this let's say
367:02 - it's going to be initially in the middle
367:05 - of the board so that's basically 50 by 2
367:07 - and 25 by 2 or you can say bit by 2 and
367:10 - height by 2 that makes more sense right
367:12 - so width over 2 and uh height over 2
367:15 - that is basically the center of the
367:17 - board and velocity let's say it's going
367:19 - to be one that is one character at a
367:22 - time and here you instead of Y and X you
367:26 - need to capture the position of the
367:28 - snake so call the snake pause you can
367:30 - see equal to
367:32 - um snake dot get position
367:37 - and here
367:38 - instead of Y you need to say snake pause
367:41 - dot Y and instead of J you need to say
367:45 - snake pause dot X
367:48 - so so far so good we have created a
367:51 - snake which is going to be on the middle
367:53 - of the board and which is going to move
367:55 - at a speed of one character at a time
367:57 - and here
368:00 - um let us just clear all these comments
368:02 - and now let's see how to get input so
368:06 - that we can control the snake so you
368:08 - need to move the snake only when you
368:10 - press something right so here how do you
368:12 - capture that keystrokes well you have a
368:15 - library to do that so that is called
368:17 - conio or I should say console input
368:19 - output and here you can just do the
368:23 - following so if you say f k b h i t so
368:26 - kbhit stands for keyboard head so it
368:29 - will be true if you hit a key on your
368:31 - keyboard not necessarily Enter key you
368:34 - can hit any key on your keyboard and
368:36 - this is going to evaluate to true and to
368:38 - capture your key you need to say get
368:40 -  so get CH will basically give you
368:43 - the key which are just pressed so we
368:46 - will capture this and instead of
368:48 - capturing this we can switch this so
368:50 - that we don't have to write couple of if
368:53 - statements we can just say switch get ch
368:56 - which will basically give us the key and
368:59 - here you can control it so let's say up
369:02 - so I'm not going to do it for the arrow
369:06 - keys because I don't really remember the
369:08 - ASCII values of the arrow key so if you
369:10 - want arrow keys you need to give the
369:12 - ASCII value so let's say 132 is the
369:14 - highest key value of upper key it is not
369:16 - the case I'm just saying but if 132 is
369:19 - the ASCII value for the up key then you
369:22 - need to do something like this but I'm
369:24 - just going to go with wsd for now so
369:26 - case W then um what you need to do you
369:29 - need to move the snake upwards right so
369:31 - snake dot changed up sorry U
369:37 - and then break and you need to do this
369:40 - for all the four directions so Ctrl c v
369:42 - v v w a s d and uh
369:47 - D is basically go to right
369:50 - s is down and this is left for now this
369:55 - will more snake in our preferred
369:57 - Direction and to move the snake you just
369:59 - call snake dot move snake which will
370:01 - move our snake and now if you run this
370:03 - you will be getting a snake which can
370:07 - move on your command so now you can see
370:09 - that it is not moving because initially
370:12 - we had set the snakes direction to be n
370:14 - right so we did not have any case which
370:17 - will move the position for n so it
370:21 - doesn't move for any iteration and now
370:24 - once I press W you can see that it
370:25 - started moving up a it started moving
370:28 - left s it started moving down and D it
370:31 - started moving to the right so now I can
370:34 - control this little character and keeps
370:36 - moving right so that is how the snake
370:38 - game is defined so once you press a key
370:40 - it will keep moving in that particular
370:42 - direction until you change the direction
370:44 - so this is what we needed and we got a
370:47 - moving character on our board
370:50 - so now let's see how to first uh
370:54 - generate the food and calculate the
370:56 - points and then we will talk about how
370:57 - to increase the snake's length once it
371:00 - reach the food right so now let us just
371:03 - close this and talk about the food so
371:05 - again you need to create another
371:08 - flash for generating the food so it's
371:10 - going to be
371:12 - that's your food
371:14 - and again you don't need the getter
371:16 - Setter or the destructor
371:19 - created yes
371:21 - okay and uh here you have food.h
371:25 - and again I don't need these things so
371:29 - here the private section what we're
371:31 - going to do is we are going to have a
371:33 - position of the food right so that is
371:35 - mandatory you you cannot have any object
371:38 - without a position right so for the
371:40 - position you again need to include
371:42 - windows so windows dotage
371:45 - and it's going to be called boss and uh
371:49 - you do need a velocity well you don't
371:51 - need anything else you don't need
371:52 - velocity you don't need any uh direction
371:55 - for that put it's just going to be a
371:57 - point where if you go over to that point
372:00 - and then eat that food you are just
372:01 - going to generate another phone so
372:03 - basically you don't need anything else
372:05 - and uh
372:07 - in the public section the public section
372:10 - we have a Constructor basically well you
372:12 - don't have to pass anything to the
372:14 - Constructor it's basically going to
372:16 - initialize this position with some
372:18 - random value but if you see this game
372:21 - always this food starts at this position
372:23 - if you want something like that then you
372:27 - need to Define
372:28 - a initial starting position so as we did
372:31 - uh for our snakes you need to do
372:34 - something like that but we are going to
372:36 - go with random initialization right from
372:38 - the beginning itself so again for random
372:41 - function to work you need to include
372:44 - free STD lib and uh we are going to
372:47 - define a function called gen
372:50 - this is basically going to generate
372:52 - output and this is going to be avoid
372:55 - and we also need uh
372:57 - function to return as a position so it's
373:00 - going to be get us so this will return
373:02 - our position so let's define these
373:05 - functions
373:06 - inside this what we're going to do is
373:09 - just generate for hit first time it's
373:12 - just going to generate the food once you
373:14 - create it and uh for generating the food
373:18 - sorry snake sorry food
373:23 - junk food and uh what this is going to
373:26 - do is it's just going to generate two
373:29 - different random numbers in the in some
373:32 - range so if you remember the formula for
373:34 - generating a random numbers in the real
373:36 - that is U2 L it was basically
373:40 - Tran mod U minus L plus 1
373:45 - so U minus L plus 1 plus l so this was
373:49 - the formula for generating a random
373:51 - number in a Range so here our upper
373:54 - limit is going to be for the x axis is
373:56 - going to be width and the lower limit is
373:58 - zero right so uh here you just need to
374:02 - say
374:03 - ran mod and then U minus L plus 1 plus l
374:07 - so uh for uh us the U is basically with
374:11 - minus the lower limit now lower limit if
374:14 - you keep zero then the food will have a
374:17 - chance of getting generated on the walls
374:20 - of support so you don't want that to
374:22 - happen so it's going to be 1 and plus
374:24 - one so these two cancel out so you just
374:26 - need to say run mode width and then plus
374:29 - L which is 1.
374:31 - again for uh
374:34 - the y axis the upper limit is going to
374:38 - be height and the lower limit is again
374:39 - going to be one so this will generate a
374:43 - random position for our food which will
374:46 - be on the board and for getting position
374:50 - it's very simple you just need to say
374:53 - for the food
374:57 - good position so we did not Define that
375:00 - well we did quad grid position and here
375:03 - you need to say return first
375:06 - so this will return the position of the
375:08 - current foot
375:09 - and that's it for food so you need to
375:13 - include that also over here
375:15 - um in our main file
375:17 - so here we need to say hash include
375:21 - food.h and here we don't need cstdl
375:24 - application again because we have
375:27 - defined it inside this food.net so that
375:30 - gets included automatically and uh
375:33 - here we need to create a food object So
375:36 - Below the snake let's create a food so
375:40 - it's going to be food and uh as a
375:43 - Constructor doesn't need anything so you
375:45 - can just put it like this and
375:48 - here we need to check whether the snake
375:51 - has eaten the food or not so for that
375:54 - what you can do is you can have a
375:56 - function inside the snake which will
375:58 - check whether its coordinates have
376:01 - matched the coordinates of food or not
376:03 - so what you can do is you can insert the
376:06 - snake.h you can Define another function
376:08 - called Boolean let's say eaten this will
376:14 - basically say whether the food has been
376:17 - eaten by a snake or not so you can just
376:18 - pass in some coordinates inside this
376:21 - that is the coordinates of the food so
376:23 - coordinate food such a food cost
376:27 - and we'll Define it inside snake.cpp
376:30 - it's basically
376:33 - um bull snake eaten
376:37 - and uh this will return true if the
376:40 - coordinates match so if I say uh if
376:44 - would cost well I did not capture it
376:46 - over here so it's
376:48 - called
376:49 - could pause and if put pause dot X is
376:53 - equal to pause dot X and uh
376:59 - that is basically if for the position of
377:02 - the head and position of the food are
377:05 - equal then it means that the food has
377:08 - been eaten by the snake so then you need
377:09 - to return to
377:11 - else you just return false so this means
377:14 - that uh if you eat the food it will
377:16 - return true and if it didn't eat the
377:19 - different Falls and in main you can use
377:21 - that over here so if you can say snake
377:24 - dot E10 and you can get the fourth
377:27 - equation so food Dot
377:30 - um get pause
377:31 - and this will give you the position of
377:34 - the food which you can pass into the
377:36 - snake and if the snake has eaten then
377:39 - you need to generate another first so
377:41 - you can say full dot gen foot and you
377:45 - also need to increase the length so you
377:47 - you can say snake dot length well lunch
377:49 - is a private variable so let's say snake
377:51 - dot grow and we will Define a function
377:54 - to grow the snake so you can see void
377:57 - Pro
377:59 - and we Define it as
378:03 - void
378:05 - s snake
378:07 - grow
378:09 - which is length plus plus and this
378:12 - should grow our snake and that should be
378:14 - it so now you have the logic for eating
378:18 - a food and then growing the snake well
378:19 - we are not going to see the snake grow
378:22 - but it is just going to grow in numbers
378:24 - we won't be seeing that visually we'll
378:27 - see how to deal with showing that
378:30 - visually right and here we forgot to
378:34 - draw the food so here you need to put
378:36 - that I'll say for our I is equal to 4
378:41 - pause dot y
378:43 - and J is equal to
378:47 - put pause dot X well I did not capture
378:50 - that so called
378:54 - equal to good
378:57 - pass
378:59 - then for food the let's say the star
379:03 - right the star works well
379:07 - now if you run this
379:11 - it says that uh width and height were
379:15 - not declared in the scope now that is
379:18 - because in food.h we did not Define the
379:22 - width and height right we had defined it
379:23 - in the main.cpp so you need to copy
379:26 - these two lines here so Ctrl C and put
379:29 - it inside put dot h that is because we
379:32 - are using those two right we are not uh
379:34 - we did not Define it in full dot X that
379:36 - is why it must give me an error and now
379:38 - if you run this
379:43 - that is because this is a capital Y and
379:47 - um
379:49 - here you have the snake and the food so
379:52 - here you can see the food so if I eat
379:54 - that food it's going to generate another
379:56 - food in some random position so you can
379:58 - see that generated over there and uh
380:02 - here we did not write the logic for
380:05 - Collision so we'll take care of that
380:07 - afterwards well it's going to be in the
380:09 - same places that is because we did not
380:11 - seed the random function so if you uh
380:14 - have seen the previous video where we
380:16 - made the tic-tac-toe game you know what
380:18 - is serious well to see the random
380:21 - function what we are going to do here is
380:23 - we are just going to say in the main
380:26 - function so to see the random function
380:28 - what we are going to do is Hash include
380:30 - C time and
380:33 - here in the main function we will see s
380:36 - and
380:37 - time
380:39 - no okay so now when you run it you will
380:42 - have a snake and foot
380:44 - and this put will be generated once you
380:47 - eat it so here I eat that food now you
380:49 - can see that another one has been
380:51 - generated and then another one has been
380:53 - generated so we did not write the
380:55 - Collision project so if you go through
380:57 - the wall you will come you won't come
380:59 - back and that will take you now so to do
381:02 - that what we are going to do is we are
381:04 - going to write another function
381:07 - so it's going to save Full collided and
381:11 - its property of the snake so snake
381:13 - collided
381:15 - and then this is going to just return
381:17 - true or false so this is going to return
381:19 - true if our position of X is less than
381:24 - let's say one so that is because at the
381:27 - zeroth position you have the wall right
381:29 - so if it is less than one you mean it
381:32 - means that you have crossed the position
381:34 - of one
381:36 - and your cross the wall and uh in case
381:39 - your X is really greater than height
381:42 - that means the width then it means that
381:45 - the air cross the other wall also and
381:47 - similarly for the Y you need to say
381:50 - it is less than one or position dot Y is
381:54 - greater than the height then you need to
381:56 - return true it means that you have
381:58 - collided with a wall or else you return
382:00 - false over here
382:03 - so uh we forgot to define the Prototype
382:06 - so here it is going to be
382:08 - boole collided
382:12 - and in main function instead of true we
382:16 - are just going to maintain a variable
382:18 - called game over which will track
382:21 - whether the game is over or not so in
382:24 - the beginning game over is false and
382:26 - while true
382:28 - you will change it to while game over or
382:31 - while not game over
382:33 - you need to run all these things and if
382:36 - the snake collided so if the snare
382:38 - collided then you will just say game
382:42 - over equal to true and this will stop
382:45 - excreting the loop right
382:47 - now if you run this we got an error does
382:52 - it say again the width and height are
382:53 - not defined in snake dot h so you need
382:56 - to copy those two things
382:59 - from here and put it over here
383:04 - right now if you run this you don't have
383:08 - any errors hopefully and here you can
383:10 - see that the snake moves and if I go and
383:12 - hit the wall it ended the process so now
383:17 - the game ends successfully once I hit
383:19 - the wall and we have taken care of the
383:22 - food also so uh I think that the video
383:24 - has become long enough it has been an
383:26 - hour so the next video we'll see how to
383:30 - increase the snake's length and show it
383:32 - visually well we are including the
383:34 - snake's length over here but we are not
383:36 - showing the increase in its body right
383:39 - so we are just moving ahead and we are
383:41 - eating the food the previous video we
383:43 - were making our second project which was
383:45 - a snake game and and we made quite a
383:47 - progress right so let's see what we have
383:49 - made we have made this board and then we
383:52 - have updated the port without causing
383:54 - any flickering and that's a great
383:56 - Improvement and we also animated this
383:59 - character which can eat the food and we
384:01 - have also written the logic for the food
384:03 - to appear at different random locations
384:05 - right in this video we'll complete this
384:07 - game
384:08 - body for the snake well you know that
384:11 - the snake is growing while eating the
384:14 - food but it's just growing in numbers
384:15 - right we're not throwing it visually so
384:18 - we will be showing that and also before
384:20 - that let's fix some logical errors which
384:23 - are made right so let's see what are
384:26 - those errors so let's just try one of
384:29 - the other pops up I'm telling unlucky
384:31 - but just to save the time I'm just
384:33 - ending this game here and let's first
384:35 - talk about the most obvious logical unit
384:38 - so in the definition of food what we
384:42 - have said is once a food is created I
384:45 - want a random location on the board
384:48 - which will be the location where our
384:51 - food is placed right that's what we said
384:53 - when we are calling this generate food
384:56 - function inside the Constructor right
384:58 - but what is happening here if you run
385:00 - this program again and again so let's
385:02 - run just once again so here you will be
385:04 - seeing that the first code is over here
385:05 - and if I close that run that again you
385:09 - will be seeing that the second time also
385:10 - the food is over there but the
385:14 - consequent foods are getting randomized
385:16 - so if you see the second food is
385:17 - somewhere over there and we start this
385:19 - game again and try to eat that you see
385:23 - that the second food has been generated
385:25 - at some random location right the first
385:27 - one was somewhere over there so to fix
385:30 - this well you can go over there
385:33 - literally an iron it is actually not
385:35 - what we wanted right it's basically what
385:38 - I did not want but if you wanted that
385:40 - the first should be generated like that
385:42 - you can go ahead with this and keep this
385:45 - portion but
385:46 - since we wanted to generate the food at
385:51 - a random position right from the
385:52 - beginning what we are doing wrong is
385:55 - here first we are generating the food
385:57 - object and then we are setting the
385:59 - random function right so if we were
386:02 - introduced to the random function and
386:03 - the seeding function uh back in the
386:06 - tic-tac-toe video right so if you
386:08 - remember the seeding function is a kind
386:10 - of controller to the random number
386:12 - generator well the random number
386:14 - generator will generate some random
386:16 - number it will do some calculation give
386:18 - you a number when the program is loaded
386:21 - onto the memory right so if you want a
386:24 - different random number what you need to
386:25 - do is you need to close everything and
386:27 - then open it again well we don't want to
386:29 - do that right we want random numbers
386:31 - right when we are in the memory so what
386:33 - we do is we change the seed so seed is
386:36 - like a starting point of the algorithm
386:38 - and what we do is we see it with some
386:40 - number every time we want to generate a
386:42 - new number so what is the thing which is
386:45 - changing constantly when time is
386:47 - changing constantly so what we do is we
386:49 - just
386:54 - take the time which will take the time
386:56 - machine integer and then make the random
386:59 - number generator start from that
387:01 - particular type that is why you get
387:03 - different numbers after shading it but
387:06 - what is happening here is we are calling
387:08 - the random function before seeing it
387:10 - right for the first time from the next
387:12 - time onwards once the foot is written
387:14 - the logic is over here right which is
387:17 - after the seeding function that is why
387:19 - you are getting randomized locations for
387:21 - the consequent foods but not for the
387:23 - first one so to fix that it is very
387:25 - simple what you can do is you can get
387:27 - rid of the Constructor but I don't know
387:29 - why I Define this Constructor basically
387:31 - when we Define a Constructor what we
387:34 - actually see is we need the Constructor
387:36 - to do something which the default
387:38 - Constructor which are compiler will
387:41 - construct for this class can't do right
387:43 - but what the default Constructor does it
387:46 - will basically create the memory
387:48 - required for this particular class right
387:51 - for loading this class onto the memory
387:53 - you need some amount of memory which is
387:56 - calculated by The Constructor well we
387:59 - wanted the Constructor to do something
388:01 - extra that is called this function on
388:03 - the creation and it did not work out as
388:05 - we expected that is why we can just get
388:07 - rid of the Constructor and then call the
388:10 - function manually well if you want to
388:13 - keep the working of the program just
388:15 - like before then you can skip the step
388:17 - as it told you it's just preference
388:19 - right I prefer that the uh would be
388:23 - generated at a random location right
388:25 - from the starting
388:26 - so you can go there and after shading
388:30 - the function what we can do is we can
388:32 - now call the generate food method so
388:34 - this is the one line which we wanted to
388:36 - skip by using the Constructor which was
388:39 - actually worthless right so creating a
388:42 - Constructor was no good and at least for
388:46 - this kind of a game where we want the
388:48 - first element to be randomized so it
388:51 - basically get rid of the Constructor and
388:53 - that will solve the issue now if you run
388:55 - this you will be getting the foods at
388:57 - different locations so one is being
389:00 - generated over here close that open that
389:02 - again well if the other one has been
389:04 - generated and this is the problem
389:06 - actually which I wanted to show you in
389:08 - the beginning right well uh when I was
389:10 - eating the food I actually knew that at
389:13 - some point this will happen that if we
389:15 - won't see any food on the pool that is a
389:17 - major logical issue with this program
389:20 - which we made in the previous video and
389:22 - we'll be fixing that right now so here
389:24 - if you see there is no food on the boat
389:26 - but actually it has been generated we'll
389:28 - see why that happens okay so close that
389:31 - and now we fix the most obviously now
389:33 - let's go on to the issue which we just
389:35 - saw that the foot is not getting
389:37 - generated well
389:39 - what we're doing in the general food
389:42 - method but here we are saying that we
389:45 - want some random number in the range of
389:47 - 1 to width minus one why we told that uh
389:50 - one the first character is basically
389:52 - reserved for the First wall and the last
389:55 - character is reserved for the last one
389:57 - so basically you want numbers from 1 to
390:00 - width minus one leaving those two campus
390:02 - it sounds reasonable right but if you
390:04 - work on the path it is going to tell you
390:07 - a totally different story so let's see
390:08 - what the math is let me pull up my paint
390:11 - over here and now let's first talk about
390:14 - one of these so width or height both of
390:16 - them are going to go with the same logic
390:18 - so uh we can talk about only one of them
390:20 - right right so here uh let's say I draw
390:23 - the height so what is the height height
390:24 - was something like 25 right so the whole
390:28 - thing is actually 25 characters right
390:31 - and what we are saying we are saying
390:33 - that the first character and the last
390:35 - character are decision for the balls so
390:39 - from a computer's perspective what are
390:41 - these numbers going to be the computer
390:43 - starts counting from zero right so 25
390:46 - characters is basically 0 to 24 for a
390:49 - computer and what we are saying is we
390:52 - are saying that this 0 and this 24 is
390:56 - not required in a Range so basically we
390:58 - want numbers from 1 to 23 we don't point
391:02 - zero we don't want the last character
391:03 - which is 24 right so this range becomes
391:07 - 1 to 23
391:09 - well to get a number in the state what
391:11 - you can do is plug it into the formula
391:13 - so what is the formula for the random
391:16 - number generation it is if you want a
391:18 - number from sorry n that is the lower
391:22 - limit to U which is after limit and
391:25 - lower limit is included and upper limit
391:27 - is not included right so you will be
391:30 - getting some numbers till U minus 1 so
391:33 - if you want numbers in this range that
391:36 - is early inclusive and you not inclusive
391:38 - you won't get the U then the formula is
391:41 - you need to plug in Rand mod
391:44 - it was U minus L plus 1
391:51 - plus L right so this is the formula you
391:54 - can plug it into this folder you can
391:57 - even see logically but basically both of
392:00 - them are going to give you the same
392:01 - result and we'll just use the formula
392:04 - for Simplicity purposes over here
392:06 - modulus just
392:08 - what it becomes let me just write it as
392:11 - R this is basically the random function
392:13 - R naught and U is over here 24 right
392:16 - because we want 23 to be included right
392:19 - and in this formula this particular U is
392:22 - not included in this random number
392:25 - generation so we'll just increase this
392:28 - by one number that is 24 and that will
392:31 - become 24 minus L plus 1 so that is 1
392:34 - plus 1 lower limit is 1 which is
392:36 - included that's why we don't have to do
392:38 - anything to it and plus one so what this
392:42 - becomes is R naught 22
392:45 - plus 1 and what is 22 it is basically 25
392:48 - minus 3. right so this is the number
392:53 - which we wanted to generate actually but
392:56 - what we did is we basically went by our
392:59 - intuition and messed up the logic right
393:01 - so to
393:03 - correct this what we need to do is using
393:06 - this particular formula this becomes
393:08 - minus 3 and this will become plus three
393:10 - and the same will go with height also we
393:13 - talked about time same thing will go
393:15 - with the width also so if you draw a
393:18 - similar kind of analogy you will be
393:19 - seeing that the same logic will work for
393:22 - the width also right so let me just
393:24 - clear that and here it is minus 3 and
393:28 - this is plus 1 right now this will fix
393:31 - The Disappearance of the food and there
393:34 - is another major flaw in our looping
393:39 - right so where are we looping we are
393:41 - looping over here right the board where
393:43 - we are displaying there is a major flow
393:45 - in that and believe me if you have been
393:47 - able to identify that particular error
393:49 - you are going to be a great programmer
393:51 - right so let's see what the error is it
393:55 - is basically lying within the inner loop
393:57 - what we're doing well for the outer loop
394:00 - it is pretty straightforward we are
394:02 - going from I equal to 0 to I equal to
394:04 - height which is basically how the
394:06 - computer sees numbers from 0 to n minus
394:09 - 1 and for the fifth we are doing
394:11 - something different right so what we're
394:13 - doing here we are saying that
394:15 - we are going from 0 to width minus 2 and
394:19 - we had a reason that these two
394:21 - characters which are basically the walls
394:23 - are constant for all the rows so instead
394:25 - of including them inside the loop why
394:28 - not just exclude them and run the loop
394:30 - only for the width minus two number of
394:32 - characters so that's what we did and
394:34 - that sounded reasonable but here is the
394:37 - problem what happens is let's say my uh
394:41 - generated x axis which is basically the
394:44 - width is going to be sub 28 right sorry
394:49 - what is the maximum age is 50 right and
394:51 - what you can do if this is 50 the
394:54 - maximum number you can generate leaving
394:56 - 0 and 49 is 48 right so this is the
395:01 - maximum number you can generate and
395:03 - let's say that that is our x coordinate
395:06 - that is the value of our width now what
395:09 - happens here well if you're saying here
395:11 - J is running from 0
395:14 - 2 with minus 2 what is bit minus 2 it is
395:18 - basically 48 and it's not reaching 40 it
395:20 - is just going till 48 which means going
395:23 - till 47 only right now if you see this
395:27 - you don't have a way to actually display
395:30 - this coordinate and just loop at all
395:32 - because it is out of bonds of this
395:34 - particular Loop this Loop will run only
395:36 - till 47 and you are asking it to show
395:39 - something which is on the 48th
395:42 - coordinate which is not possible by this
395:43 - Loop right so
395:46 - how do we fix this well we can draw an
395:49 - analogy over here so if you draw the
395:52 - coordinates into J's perspective and the
395:55 - W specific two w is basically the
395:57 - original width of our port for say this
396:00 - when w 0 J is not only defined why is
396:04 - that well let me just clear this thing
396:06 - so that we can
396:07 - see it clearly but this is the leftmost
396:11 - corner of our board and this is 25 right
396:15 - 25 characters or 25 pixels and here what
396:18 - we are doing is we are saying this is
396:20 - our character the width character and we
396:24 - are
396:24 - saying that the inner loop should run
396:28 - from 0 to 47 and we are including
396:31 - another character and the total makes it
396:33 - 58 0 to 47 is 48 characters plus 1 plus
396:37 - 150 and this is the other one
396:40 - now what is happening is let's say my
396:43 - coordinate is zero right right then the
396:46 - x coordinate is 0 it basically means
396:48 - this particular position where the wall
396:51 - is there right but what is happening
396:52 - here our zero is starting from one step
396:55 - to the right because of this particular
396:57 - grouping and this particular character
396:59 - before so what is happening our Loop
397:02 - which is starting is starting one step
397:04 - towards the right and that is why we are
397:06 - missing out our
397:08 - coordinate so what happens is if J is
397:11 - sorry if W which is our original x axis
397:15 - is 0 J is not returned defined it is not
397:18 - there at all right when does J equal to
397:21 - 0 start
397:22 - to 1 and so on this will continue when
397:24 - Vector equal to 48 J equal to 47 as we
397:28 - just saw and with this 49 it is not
397:32 - presented right so this is the reason
397:35 - why we were not getting anything on the
397:37 - board not this is not the complete
397:39 - result the actual reason was because we
397:41 - were
397:44 - we were a generation and here this is
397:47 - another one of the major reasons why we
397:49 - both be getting even after fixing the
397:52 - random number
397:53 - that is because if you create any food
397:56 - at the extreme positions that won't be
397:58 - visible to you at all right so to fix
398:00 - this what we can do is while comparing
398:02 - the coordinates we need to add one
398:03 - purchase right so if zero pressure
398:07 - zero RG 4900 right if you don't want
398:10 - these two things because we are not
398:12 - going to generate food at those two
398:13 - things they have walls they have
398:15 - reserved for walls so in this range 1 to
398:18 - 48 what you need to do you need to
398:20 - compare only these things
398:22 - right you need to compare only uh these
398:26 - things and to compare that what we can
398:29 - do is we can add 1 to the J before
398:31 - comparing it with the X constitute so to
398:34 - fix this what we're going to do here is
398:36 - when we need the canvas let me just
398:38 - clear this
398:39 - and
398:41 - here
398:44 - uh in place of K it's going to be J Plus
398:47 - 1. and that should hopefully fix all the
398:50 - logical errors which are made so save
398:52 - that run that again and here we have our
398:56 - first word if you eat that the second
398:58 - food is getting generated and hopefully
399:00 - it should not stop generating it should
399:02 - be generating
399:03 - till we play this game and it should
399:05 - stay within the range of port and it
399:06 - should be visible to the player right so
399:09 - well if you say this is visible and
399:10 - trust me it's going to work and there
399:13 - are no uh kind of mistakes in this
399:15 - program and this is completely fixed now
399:17 - well we'll fix one more thing that is if
399:20 - I go to this particular wall I will
399:22 - crash before actually crashing so if you
399:24 - see this I have not crashed the phone
399:26 - but it's in that I have crashed this one
399:29 - that means I need to go inside the one
399:30 - so to fix that I mean it's the
399:33 - coordinate issue and also a placement of
399:35 - most with let's first fix a comment if
399:37 - you go there Snake dot Collide it I will
399:40 - have already fiction basically what we
399:42 - did was we had put something like this
399:45 - right position dot X is less than one
399:47 - and question X is greater than width
399:49 - minus one so going by the same logic
399:51 - with minus 1 is going to be 49 because
399:54 - width is 50 so with minus 1 is going to
399:57 - be 49 so what you want you want
400:00 - something greater than 48 not 49 so it's
400:03 - going to be with minus 2 and that should
400:05 - fix the issue and
400:08 - for the other wall which I just showed
400:10 - you there for the rightmost what is
400:12 - happening is we are first drawing the
400:14 - board we are moving we are actually
400:17 - changing the direction of the stick we
400:19 - are moving this need and then we are
400:23 - actually this movement is
400:26 - movement is not shown to the user this
400:29 - moment should actually happen after this
400:32 - Collision sectional so you what you can
400:35 - do is you can just move this to the end
400:36 - or you can even move it doesn't matter
400:39 - basically the port should be updated
400:41 - after the snake goes not before the
400:44 - snake moves that is what is happening
400:46 - over version the code is actually
400:48 - getting updated before the snake moves
400:50 - so that is why you have not seen whether
400:52 - the snake has been collided or not so
400:54 - you can just move this thing to the end
400:56 - or move this thing to start basically
400:58 - they both mean the same thing right go
400:59 - for the next Loop the starting point is
401:01 - going to the end of this move so they
401:04 - mean the same thing so you
401:08 - now this should fix that issue that
401:11 - you're not seeing the snake colliding
401:14 - and now you should see that a snake
401:16 - actually collides with a wall before
401:18 - editing this game right so it went
401:20 - inside the wall and the game ended and
401:22 - now everything is pretty much fixed and
401:24 - now let's proceed to making the Snake
401:27 - Game a real sneaking what is that we
401:30 - need to include the snake's body we are
401:33 - just growing the snake which is
401:34 - basically just increasing the length
401:35 - right so here you can see it's just
401:37 - increasing the length so how can we
401:40 - store the snake's body
401:42 - well what is your body it's just a
401:45 - collection of body parts and that
401:46 - collection must have triggered something
401:48 - inside you well they are going to use
401:50 - something like an array which is a
401:53 - collection
401:54 - a vector which is also a collection
401:56 - which was seen in the pointless video
401:58 - and the other thing is list right
402:02 - so these are three options available to
402:04 - us as of now I'm going to use one of
402:07 - this now let's unless what we need to
402:09 - use over here
402:12 - needs to have a fixed size while
402:15 - defining and uh how do we know the fixed
402:18 - size of the snake well if a player like
402:20 - me is going to play he's probably going
402:23 - to get defeated in let's say fire 10
402:26 - points at all but because I'm a very bad
402:28 - player and maybe a probe player comes in
402:31 - and he can make a score as big as 1000
402:35 - or 10 000 right well you cannot restrict
402:38 - the players or you cannot estimate the
402:40 - player's capacity by just uh keeping a
402:43 - fixed number what if the player is
402:45 - better than what you thought he should
402:47 - be right so here what you can do is well
402:50 - in this particular board you can
402:52 - actually fix it to some big number so
402:54 - let's say uh
402:55 - foreign
403:01 - height is 25 right so the maximum number
403:04 - of characters possible is this thing 50
403:06 - times 25 out of which you are using the
403:08 - borders so that is the only number of
403:10 - characters so if you make the snake as
403:13 - because that after that there is no
403:15 - possibility of meeting because
403:17 - the snake has to collide right because
403:19 - the maximum free space has been used
403:23 - has to connect with one of
403:25 - one of us and the game well that is a
403:28 - very cheap way you don't have to do that
403:30 - and by Define it with Graphics we
403:32 - generally what we do is we'll
403:35 - take off such limitations right so that
403:37 - is why you have such a tiny portable
403:41 - walls and all to take care of this issue
403:43 - but uh for this particular game uh we
403:45 - won't be talking about the teleportable
403:47 - ones well in the end I will show you how
403:49 - to create
403:51 - and here basically the array is a very
403:55 - bad option because you are restricting a
403:57 - player's capacity and if you talk about
404:00 - vectors well it is dynamic but again it
404:04 - is going to take up some extra space
404:06 - while defining so if you remember how
404:08 - Vector is first Define some amount of
404:11 - space and once it gets filled up it will
404:13 - Define a bigger space and then copy all
404:17 - the elements to this and get rid of this
404:18 - particular space so this one could be
404:21 - used just could work but again there is
404:24 - some extra space which is getting wasted
404:26 - so basically the best option here is
404:29 - going to be less so if you remember from
404:31 - our video on the pointers will be first
404:34 - discussed when to use vectors versus 20
404:37 - useless you saw that list can be used
404:40 - whenever you have a data structure where
404:44 - you won't be accessing the middle
404:46 - elements more frequently you are just
404:48 - going to access the first and last
404:49 - language that is the case here also
404:51 - right you are not going to access the
404:53 - middle Elements which is basically these
404:55 - body parts we are not quite access it we
404:57 - are just only concerned about the head
404:58 - which is on the front of the data sector
405:01 - and then 10 right so we will talk about
405:03 - how to uh actually manage the hydrogen
405:06 - tile in a short while but for now the
405:09 - head is at the beginning and the tail is
405:10 - at the end and they are only bothered
405:12 - about
405:15 - basically when we want to check the
405:17 - position we need to continue the middle
405:19 - element also but we can just do it and
405:21 - Progressive Loop right so basically it
405:23 - doesn't make any difference and we can't
405:26 - actually harvest the advantage of being
405:29 - able to pick some random element from in
405:31 - between
405:32 - well in a vector we can do that very
405:35 - simply because it is a continuous
405:37 - collection but in a list you if you
405:39 - remember it was something like this
405:40 - right your point you have pointed to
405:42 - something and then you have another
405:43 - pointer which points to this and so on
405:46 - right so if you want to pick this thing
405:48 - you need to travel all this way but then
405:50 - I
405:50 - vector or in an array you can just pick
405:53 - that up using the index it is basically
405:55 - the starting position plus the number of
405:57 - steps you need to travel so in this case
406:00 - a list would be the best thing to
406:03 - implement but to keep this tutorial
406:05 - simple I am using vectors for this
406:08 - particular demonstration so I would
406:10 - totally encourage you to go with list
406:12 - not with vectors as we are going to see
406:15 - in this video I am just showing you with
406:18 - vectors because it's easier to relate
406:19 - than this right but once you are
406:22 - comfortable by implementing this
406:24 - particular project in a vector please go
406:27 - on to try it with a list list is the
406:29 - most preferred option for such games
406:31 - where you don't have to control the
406:33 - capacity of the user right Vector is not
406:36 - going to control but basically the extra
406:37 - space is Generation right we don't want
406:39 - that so please try it with the list and
406:42 - let's now move on to the logic of
406:45 - creating the body you need to just clear
406:47 - that and
406:49 - how do we Define the body well it's
406:51 - really simple so let's say I have two
406:54 - body parts basically a tail and the head
406:56 - I have this head over here and the snake
406:59 - has to move to the right so what can I
407:01 - do well what if I just remove this tail
407:04 - and then put another head over here and
407:08 - make this as a tail so for tail let's
407:10 - just say this x mark over here that we
407:12 - know City now if you see that the
407:15 - sneakers put one step to the right right
407:16 - and if I do that again so I take out
407:19 - this tail I include the head
407:21 - and I made this head as the tail now
407:24 - let's take a smooth again and let's say
407:26 - we are eating the food at some location
407:28 - so we'll start with an angle snake so
407:30 - this is the snake we have and the food
407:33 - it is going to eat this particular food
407:35 - so it has eaten in the next iteration
407:37 - what I will do is I won't take off this
407:40 - tail right I will keep this day and this
407:43 - is what happened right so I add the head
407:47 - I won't remove the tape but I'll make
407:49 - this head as a thing right so now you
407:51 - have two tails and one head and that
407:54 - basically looks like the snake has grown
407:56 - right from two body parts it has grown
407:58 - to three body parts and that's what we
408:00 - want right so this is the logic we are
408:03 - going to implement and we are going to
408:04 - do that in factors again list is the
408:07 - most preferred option please try it with
408:09 - a list not with a vector after you are
408:11 - comfortable basically right so let's
408:13 - just go to our snake.h and quickly
408:15 - create a body definition so we need
408:18 - Vector obviously so hash include Vector
408:20 - which are going to do it to the list you
408:22 - know right as include list and uh well
408:25 - since Vector is a standard scope element
408:28 - you need to specify the scope so using
408:30 - namespace HTT like we did in the main
408:33 - function and here you can just say
408:36 - vector
408:38 - body
408:40 - sorry vector and what is the data type
408:42 - it's going to be coordinated basically
408:44 - so chord and then body
408:46 - and this defines the body of the vector
408:49 - now there are few changes we need to
408:50 - make what is that first of all we need
408:52 - to include the head to the body
408:54 - eventually create a new snake so in this
408:58 - snake called Constructor
409:00 - what we're going to do we are just going
409:03 - to say body dot pushback which is
409:05 - basically pushing back the elements
409:07 - inside a vector and what we need to push
409:09 - back we need to push back to position
409:11 - which is basically the position of the
409:13 - head of the snake right we can just body
409:15 - not push back that particular position
409:17 - and while moving the snake following
409:20 - that logic which we just discussed what
409:22 - we are going to do is first we are
409:23 - pushing the head of the snake to the end
409:25 - of the list or end of the vector so how
409:28 - we do that 4D dot pushback the new
409:31 - position which has been updated after
409:33 - all these things a new position and now
409:36 - what we'll do is
409:38 - if the body's size
409:41 - is greater than the length of the snake
409:44 - what is the length of the snake that is
409:45 - the thing we are growing when the snake
409:48 - is actually eating a food right so that
409:50 - is the thing we are manipulating over
409:51 - here so this length integer if the body
409:54 - is size which is basically a number of
409:57 - elements in the vector is greater than
409:59 - the length then what you do you just
410:01 - take out the element from the body so
410:04 - how do you do that you just say body Dot
410:07 - and if you're actually confused with
410:10 - what function you need to use the best
410:12 - thing I would suggest is not just
410:13 - memorize the function but just use the
410:15 - resources so you can just go to your web
410:18 - and then search something like CTP
410:21 - vectors
410:23 - documentation
410:25 - and you'll get a lot of resources and C
410:29 - plus plus.com is the
410:31 - best one among them well I feel that
410:33 - this is the best one where you can find
410:35 - short descriptions of all the functions
410:37 - right and here you should be
410:40 - a function like pop back
410:42 - what does it say it says it removes the
410:45 - last element in the vector effectively
410:46 - reducing the container size by one but
410:49 - we actually don't watch this and well
410:52 - why is that if you see
410:55 - but technically the tail should be at
410:57 - the end of the body but if you look at
411:00 - the structure what we are doing is we
411:02 - are actually pushing back the head one
411:04 - step to the right right so this is what
411:06 - pushback does so basically our head is
411:08 - over here and your tail is over here and
411:11 - what we need to do we need to remove the
411:13 - first element so how can we remove that
411:14 - you can just check out the functions
411:17 - over here but to save the time I'm just
411:19 - going to show you the function which is
411:22 - basically clear or Aries right so you
411:25 - will find this one this is basically
411:27 - going to remove from the vector either a
411:30 - single element or a range of elements
411:32 - right so here we just need to remove a
411:35 - single element at a position is not an
411:37 - integer it's a pointer so here you can
411:39 - see it says the definitions iterator
411:42 - position and iterator first and iterated
411:44 - last well you can go with any of this uh
411:47 - the only difference is that it has a
411:49 - concentrator with we don't have to know
411:52 - at this stage of it you can you can just
411:55 - go and search what these two things are
411:57 - basically they'll be the same thing and
412:00 - how to use that you can see an example
412:02 - over here it says dot erase my Vector
412:05 - dot begin plus five so plus 5 is
412:08 - basically going five steps away from the
412:11 - first element which is specifically the
412:13 - Sixth Element and that's uh how would
412:17 - you use this arrays function has also
412:19 - shown an example to delete a range well
412:22 - we are not quite interested in anything
412:23 - we just want to erase a single element
412:26 - which is going to be our first element
412:27 - because our first element is the tail
412:30 - and what we can do we can just change my
412:32 - Vector dot begin plus 0 that you stay at
412:35 - the first element or you can just omit
412:37 - the zero and just say my Vector dot
412:39 - begin that is going to erase the first
412:41 - element so let's Implement that what we
412:43 - are going to say we are going to say
412:45 - body dot erase and what we're going to
412:48 - erase we are going to erase the first
412:49 - table which we can get by Body dot pick
412:52 - and this is the pointer for the first
412:54 - right first position right so this will
412:58 - basically erase the first element from
413:00 - our list and
413:02 - well before proceeding let's first see
413:04 - whether this is working or not and we
413:07 - need to
413:08 - create another function will let us keep
413:11 - this function for now and then create
413:12 - another function just in case something
413:14 - goes wrong so vector and it is going to
413:17 - be coordinated you need a coordinate
413:20 - Vector to be written well basically you
413:22 - are going to return the snake's body so
413:24 - snake and then let's say get body
413:28 - and inside this we can say written body
413:33 - and in the snake.h you can just create
413:38 - that function definition which is
413:40 - basically vector
413:43 - chord oh sorry what is that dead body
413:46 - right so now we have update for this
413:49 - next definition now we'll just update
413:51 - the board and what we need we first need
413:54 - a Victor to capture the snake's body so
413:57 - Vector go on
413:59 - let's say snake body
414:02 - equal to snake dot get body
414:07 - and inside this what we are going to do
414:10 - well just remove this Edge and we'll
414:13 - place this afterwards what we're going
414:15 - to do is inside the edge we are first
414:17 - going to Loop through the snake's body
414:19 - and see whether any coordinate matches
414:21 - or not so what we can do is we can just
414:24 - say s body part
414:27 - which will stay false in the beginning
414:30 - right we'll change that in the loop now
414:31 - what we can say is for in well ijs your
414:35 - steps of k equal to zero
414:38 - um K is less than our body which is net
414:41 - body dot size
414:43 - and K plus plus what we are going to do
414:45 - here is inside this Loop we will say
414:49 - if I coordinate which is basically going
414:51 - to control the y coordinate is equal to
414:54 - the snake body of the kth index dot X
414:59 - sorry dot y and
415:02 - J plus 1 well remember that's the logic
415:06 - we were missing up equal to snake body
415:09 - dot sorry snake body of that particular
415:12 - index Dot X
415:15 - if these things match up then what we
415:18 - need to do you need to display a body
415:20 - part so let's just go with the small o
415:23 - for now this is our body part and this
415:26 - body part becomes true equal to true
415:29 - and what else well we don't want to run
415:32 - this still right because at at an
415:34 - instant a particular body part can stay
415:37 - only at a particular location so if that
415:39 - location is occupied it is pretty
415:41 - obvious that any other body part you
415:43 - want to occupy the location so you can
415:45 - safely break out of this Loop you can
415:47 - end this Loop and at the end what you
415:49 - can see is
415:56 - a empty space you know the empty area
415:59 - right and here another thing is here we
416:02 - are going to report it outside but
416:04 - remember body includes the head right so
416:07 - what you can do is we can just say body
416:09 - dot size minus one which will basically
416:11 - leave what the last element and now this
416:14 - should work and let's try to implement
416:17 - this so F9 and here you can see that the
416:21 - snake has grown so the other foot is
416:22 - over here so we will ID that and the
416:26 - third foot is over here well you can see
416:28 - that the snake is growing right so here
416:30 - you have four body parts of the snake
416:33 - and now if I eat that
416:34 - here now you have five right so now we
416:38 - have a working snake game right so now
416:41 - you have a working snake game and this
416:43 - works pretty fine right so now the you
416:45 - can see that the animation also works
416:47 - pretty fine the body part ship to follow
416:49 - the head and so on right so this
416:52 - concludes our game well I promise you
416:54 - that uh we'll be seeing how to uh create
416:58 - a teleportable wall and before that if
417:00 - you want to show us code that is also
417:03 - pretty simple what you do is you just
417:05 - say here
417:07 - end score
417:09 - I will just keep it Global so that you
417:11 - can use it on the port function also so
417:14 - here you can just say
417:16 - end score
417:17 - which is going to be 0 in the beginning
417:19 - and well you can just set this to zero
417:22 - in case you want to say play again
417:25 - something like that what you can do is
417:26 - instead of main you can just say game
417:28 - and this is going to provide game
417:30 - because I'm not going to do that you can
417:32 - do that right so if if I I want to play
417:35 - again you can ask a question do you want
417:37 - to play again or not something like that
417:39 - and if I press yes then you can call
417:42 - this function again and then you can set
417:44 - this thing as zero so core equal to 0
417:46 - before the beginning option you give and
417:49 - here what you can do is you can just say
417:51 - score plus plus very simple and if you
417:55 - want to give 10 points or something like
417:57 - that you can just do that score or equal
417:59 - to score plus 10 or any shorthands of
418:02 - Windows code plus equal to 10 or
418:03 - something like that you can do that over
418:05 - here and here before starting to print
418:08 - out the port what we can do is we can
418:10 - just say C out
418:12 - our score so score
418:17 - is our score current score and just add
418:21 - couple of new lines so it looks neat and
418:24 - that should take care well I have one
418:26 - return function over here that is this
418:28 - full oh sorry the snake pause which is
418:30 - actually getting the position of the
418:32 - head and we are also getting a position
418:34 - of the body right and we did not Define
418:36 - the Collision of the snake right so
418:38 - we'll do that those things first of all
418:40 - let's just see whether this thing works
418:42 - or not so now you have this particular
418:44 - snake and I ate that the square is 10
418:47 - now I hit that score is 20. I hate that
418:51 - score is 30 and so on so it's working
418:53 - pretty fine right so you can close that
418:55 - and to take care of the Collision when
418:58 - you might have figured it out by now
419:00 - what we need to do well what you need to
419:03 - do here is you need to say else
419:07 - and you need to check whether it
419:09 - collided or not how do I check that well
419:12 - you don't need else you can directly
419:14 - check it inside a loop and then return
419:15 - it so what you do is for paint I equal
419:19 - to 0
419:20 - I is less than the body dot size well
419:24 - it's inside the snake so I don't have to
419:26 - call that I can just say length minus 1
419:28 - because I don't want the head and it's
419:31 - going to be I plus plus right and what
419:34 - we need to check
419:35 - if our snakes have head is basically
419:38 - pause right so if POS dot X is equal to
419:42 - any of this need body will it is not
419:45 - straight body is just body body of I dot
419:49 - X and the y coordinate is also same
419:54 - constant Y is equal to bodies I not y if
419:59 - these two things match up just say
420:01 - return to yes you collided if these two
420:04 - things don't satisfy the rent just say
420:06 - return false
420:08 - so they should take care of the
420:09 - Collision so let's just try that out for
420:11 - F9 to build and compile this and here
420:14 - you have this snake and the foot and
420:17 - let's first go for our first food we
420:19 - have grown and the score has also
420:21 - increased and the second foot but it's
420:23 - going to take a while if I go like that
420:24 - let's just go in one body part every
420:26 - time right so what I can do is I'll just
420:28 - write a equivalent well how can I
420:29 - Collide well I'm going left now right so
420:32 - if I just press right I'm just going to
420:34 - collide with my neck so basically I
420:36 - collided and now you can see that the
420:38 - process has stopped basically all
420:40 - Collision algorithm is working
420:43 - so that basically ends this game and if
420:49 - you want to make it teleport all it's
420:51 - really simple what you need to do is I I
420:53 - am sure many of you must have figured it
420:55 - out right now
420:56 - well you just need to play with the
420:58 - coordinates so here if you see in the
421:01 - snake mostly what you do is if you want
421:04 - to change the location of the state you
421:07 - will just say
421:09 - here
421:10 - if this particular thing if position dot
421:14 - X is greater than the width minus 2.
421:19 - then what you do you just say position
421:21 - dot x equal to zero so simple and again
421:24 - what we do if you say if position dot y
421:28 - or sorry position dot X is less than 1
421:32 - then what you do you just say position
421:34 - dot x equal to the width
421:38 - minus 3 sorry about that it for random
421:41 - function we need to use with minus a
421:42 - because uh for generating the random
421:46 - numbers in that range so it's basically
421:47 - with minus two and this will make the
421:50 - side walls teleportable so if you just
421:52 - save that and now if you run this you
421:54 - should be going through the sidewall and
421:56 - coming from the other one
421:58 - and now if I go through my sidewall I
422:02 - should be appearing from the other wall
422:03 - so you can see that it has been kind of
422:06 - teleportation now if I eat that our
422:08 - table also follow our uh steps right so
422:11 - if you go from there you appear from
422:12 - there right so it works good please so
422:15 - that is how you make daily portable
422:17 - walls and uh once you get to know about
422:19 - file handling basically how to write
422:22 - files what you can do is you can even
422:24 - have a high score option so you can
422:26 - write down a particular high score on
422:29 - the file so let's say I opened this game
422:31 - right now and I scored about 10 points
422:33 - and you scored about 1000 points so
422:35 - that's pretty reasonable I'm not a very
422:37 - good player but yeah so you scored about
422:40 - 1000 points and that is a high score
422:42 - right so here if you run this program
422:44 - again that high score gets lost so
422:46 - instead of just writing it on the memory
422:48 - for that particular kind of run what you
422:52 - can do is you can have a file where you
422:54 - can write on all your high scores and
422:56 - then whenever you load this game you
422:58 - load it along with the file so inside
423:00 - that file you have all the high score
423:02 - relation if you want you can just have
423:04 - names also so some games provide that
423:06 - right so you have the name under the
423:09 - high school so other than that you can
423:10 - design everything and we'll come back to
423:13 - just while discussing files issue
423:15 - because traditionally what we do is we
423:18 - just write Files about students and all
423:20 - this stuff but we'll come back here and
423:22 - we'll try to work on this game more and
423:26 - trying to create a file and again
423:28 - this is the totally working game and if
423:31 - you want to implement this and if you're
423:34 - comfortable with implementing this with
423:36 - this kind of a vector well I have made
423:38 - some related functions like this is
423:40 - completely sorry this one is completely
423:41 - unnecessary because I'm getting the head
423:43 - along with the body so you can take care
423:46 - of that and again I will advise you not
423:48 - to use a vector user list and here if
423:51 - you uh want to include another
423:54 - teleportable wall there is a this one
423:56 - you can do that again with a similar
423:58 - kind of logic for y axis right so you
424:01 - make basically all four four of the
424:03 - walls teleportable so when I I had
424:06 - actually implemented this game in Python
424:09 - and if you use a graphics Library you
424:12 - will be getting results like that so if
424:14 - you go to
424:15 - our python one so here I have my game
424:19 - well it is basically written in two
424:21 - files one has the classes and one has
424:23 - the script and it has various images so
424:26 - what I have is the snake in part so here
424:29 - you can see body horizontal
424:31 - so whenever that snake is breaking that
424:35 - particular direction you show that image
424:37 - and now when you can run this thing
424:40 - right over here you can see
424:43 - this game this is what you can make with
424:46 - a graphics Library well this is pretty
424:48 - fast but this is what you can make with
424:50 - a graphics library and you can see how
424:52 - smooth it is and it doesn't have any uh
424:55 - kind of issues like moving down faster
424:58 - in the vertical Direction moving small
425:01 - in the horizontal Direction it has kind
425:04 - of same speed because you can control it
425:06 - right you can basically control the
425:07 - number of pixels and all and if you see
425:10 - it is teleportable on both sides if I go
425:12 - from the bottom it up from coming from
425:14 - the top and if I go from the sides I end
425:16 - up coming from there so this is how you
425:19 - can Implement your games and this is
425:21 - basically the same logic which I've
425:23 - implemented except that I have some
425:25 - additional functions handling the
425:26 - graphics of the screen right nothing
425:28 - more than that it is basically the same
425:30 - exact logic which we'll talk about in
425:32 - his console but when you use a graphics
425:35 - Library you get results like that so
425:37 - once you're comfortable when programming
425:40 - this particular game on the console I
425:42 - will advise you to uh look up some
425:44 - graphics Library which is available in C
425:46 - plus plus there are many so see what
425:49 - you're comfortable with and try to
425:51 - implement such games on Graphics even
425:53 - the tic-tac-toe game can be implemented
425:55 - on the graphics Network and that really
425:58 - looks good instead of the concerned
426:00 - right so well basically what we are
426:02 - learning here is how to think and
426:05 - console is the best way or the best
426:08 - platform to actually put down your ideas
426:10 - in a very fast way well if I want to do
426:13 - the same thing in a graphics Library it
426:15 - will take a really long time I need to
426:17 - ensure has a graphics Library I need to
426:19 - do a lot of things before getting all
426:21 - these things right so if you're coming
426:23 - up with an idea I'd rather recommend you
426:26 - not to go to a graphics library but
426:29 - first think and then put up a dirty kind
426:32 - of working prototype on your control and
426:35 - then you can beautify it on the graphics
426:36 - Library so that's it for this particular
426:39 - video hope you enjoyed this and I
426:42 - encourage you to build up your own game
426:44 - by changing the loss and then by you
426:48 - know making it faster on the X and
426:50 - slower on the y or something like that I
426:52 - didn't do that I just went with a very
426:54 - simple approach but I'm sure you can do
426:56 - that in this video we will be talking
426:58 - about inheritance
427:00 - with inheritance in C plus plus or any
427:05 - programming language it is no different
427:07 - from what we know about DNA items right
427:10 - so what do we know about inheritance a
427:12 - predecessor shares some of his
427:14 - properties with his successor so say a
427:17 - father has a green eye and maybe the sun
427:19 - will also have a green eye because of
427:21 - inheritance of genes right so that is
427:24 - what we know about inheritance when in
427:27 - programming tool there is no difference
427:29 - in the concept if there is a parent
427:31 - class and there are child classes which
427:34 - inherit some properties from the parent
427:36 - class that is what inheritance means in
427:38 - programming and we will see how to do
427:40 - that in C plus plus now why do we need
427:43 - inheritance well
427:45 - say I have a class so here I have an
427:48 - animal class so I have some properties
427:50 - in the private section and I have some
427:52 - properties in the public section and now
427:54 - I want to create 10 animals well it's
427:56 - pretty easy right so since we know but
427:58 - at least what we can do is we'll just
428:00 - say animals or animal 810 we have
428:04 - created 10 animals now let's say I want
428:07 - to create 10 tigers and 10 dogs also and
428:10 - all they all have these similar
428:13 - properties but the only difference is
428:14 - that a tiger will also have another
428:16 - method called Roar with this White Road
428:21 - which will print
428:23 - roaring on the control and similarly a
428:27 - dog will have bark right so how do we do
428:30 - that well if you think you're copying
428:34 - the clashes and then creating two
428:36 - different classes for tiger and dog and
428:39 - then creating two different arrays in a
428:41 - similar way they're not wrong it will
428:43 - work but in efficient way would be to
428:46 - inherit the properties from this animal
428:47 - molecular well if you see tiger and dog
428:51 - both are animals right so both have a
428:54 - species name both have an age both eat
428:57 - both sleep but the only difference is
428:59 - that a tiger Roars and the dog parks so
429:02 - if you can take advantage of all these
429:05 - properties from one class and add
429:08 - whatever extra features you want to add
429:10 - then that solves the problem of creating
429:13 - a separate nucleus right so
429:16 - what I mean is say I have a clash tiger
429:20 - and then
429:21 - I have some method like public World
429:24 - role and then this is just going to
429:27 - print out
429:28 - drawing on the console
429:30 - now say
429:32 - I want this tiger to have all the
429:35 - properties of an animal it should have a
429:38 - species name it should have some age and
429:40 - then it should eat it should sleep and
429:42 - all those things so you can just copy it
429:44 - down by an efficient way would be to
429:47 - inherit them and how do we inherit
429:49 - something well we'll just put this onion
429:51 - over here and then good public animal
429:55 - when we will talk about what this means
429:57 - right so for now this is how we can
430:00 - inherit the properties of an animal and
430:03 - now if you create a tiger you will have
430:05 - the properties of the animal as well as
430:08 - the tiger so I can do T dot e which is
430:12 - basically defined in this animal class
430:14 - it is not defined in this tiger clutch
430:16 - and I can also do T dot row that is also
430:18 - valid and now if I run that well
430:22 - string does not name a type yeah that's
430:24 - because I did not use using names with a
430:27 - studio above
430:28 - close that
430:33 - and now here you can see eating and
430:36 - closing so eating is from this thing
430:37 - from the animal class and drawing is
430:40 - from the tiger penis
430:43 - well if you want to create a dog it is
430:45 - very similar you can just do Clash talk
430:47 - and then public animal
430:53 - and here you can just shape public
430:59 - World Park
431:03 - which says button on the console
431:08 - then right so now if you run this well
431:11 - editor create a dog object so you can do
431:14 - that completely dog
431:16 - D and D dot eight data Park
431:21 - the question is right so you can say d
431:24 - dot Pi when after done this you will get
431:26 - similar results you will see eating and
431:28 - then biting
431:30 - so that is the advantage of the
431:32 - inheritance you can take advantage of
431:35 - all the features which are defined in
431:37 - the parent class or you have something
431:39 - called the base because there are
431:40 - different names for this so there's in
431:42 - some language it's called super Dash and
431:44 - then it's also called as a base class
431:46 - it's called the parent class and there
431:49 - are many names and then this one also
431:51 - has similar news so this is called a
431:52 - child class and then this is called
431:56 - an inherited class or something like
431:58 - that right so basically we'll just stick
432:00 - with parent child because that fits to
432:02 - analogy and uh that's how inheritance
432:05 - Works in C plus well it's that simple
432:07 - and now we'll just talk about these
432:10 - things and uh
432:12 - we'll also see how to take full
432:15 - advantage of inheritance in later videos
432:17 - because it's not a one video topic
432:19 - inheritance is very vast and then there
432:22 - are many advantages of inheritance so
432:24 - we'll see what these things are in this
432:26 - video we'll see how to do basic
432:29 - inheritance in this video and then we'll
432:31 - see how to do multiple inheritance and
432:35 - all those kinds of complex stuff in
432:38 - later videos right so first of all
432:40 - talking about this this will specify
432:42 - where to inherit and this class will
432:45 - specify from from there to inherit so
432:49 - this is to where and this is from there
432:51 - so let me just write it down
432:53 - this will specify where a tiger do I
432:57 - have to inherit and the other one will
432:59 - from there
433:01 - do I have to inhale
433:06 - so these are the things we are
433:08 - specifying what we are saying is you
433:10 - create a class title which will inherit
433:14 - all the properties which it can generate
433:16 - well there are some restrictions we'll
433:18 - talk about that but this statement this
433:22 - particular line means that create a
433:24 - class title which will inherit whatever
433:26 - it can generate from this class which is
433:28 - animal and put everything in the public
433:31 - section so that is what it means so
433:33 - public means it doesn't mean that
433:34 - everything is going to inherit is going
433:36 - to go into the public it means that
433:39 - whatever it inherits just inherit as a
433:42 - structure so if you see here you have
433:44 - private and public right so when you are
433:47 - inherited it as a public inheritance
433:49 - what you're doing is you are just
433:51 - maintaining the structure so a private
433:53 - anyway doesn't get inherited so if you
433:56 - have anything else that is going to give
433:57 - into that section and public things will
434:00 - go into the public section well you can
434:02 - do to drive it here too so you can do
434:04 - something like private what this will
434:06 - mean is it doesn't maintain the
434:08 - structure it will just put everything
434:09 - inside the private section so all
434:11 - everything it indones go to
434:15 - go to these methods are not not
434:17 - accessible from here so now if you run
434:19 - this
434:21 - okay I inherited in the
434:24 - tiger class so let's just make dog as
434:27 - private and now if I try to run this I
434:29 - will be getting it error why because I
434:31 - have made it private inheritance that
434:33 - means whatever I can generate I will put
434:35 - everything in the private section so
434:37 - something like this will be created
434:39 - inside the memory and these two things
434:41 - will go inside here the private doesn't
434:44 - fit indicated foreign
434:53 - to that particular class what gets
434:56 - inherited is public and protected so
434:59 - remember protected from all video on
435:02 - classes well we talked about protected
435:05 - very briefly over there because we told
435:07 - that protected is better understood in
435:09 - linear regions so we'll talk about that
435:11 - now well protected is basically when you
435:14 - have something which you don't want to
435:16 - share with objects but you want them to
435:18 - be inherited so something like this I
435:21 - don't want species and age to be
435:23 - accessed from objects of this class if I
435:26 - create an an email object I don't want
435:29 - the species and age to be accessed from
435:33 - that object but I want those things to
435:35 - be inherited so at that
435:37 - point of time I will make these two
435:40 - things as protected members so protected
435:43 - means I cannot access with an object but
435:45 - I can inherit them so so what I can do
435:48 - here is instead of private so let me
435:50 - just
435:52 - I can just protect it here so
435:54 - don't do it and now
435:57 - actually these two things go inside
436:00 - tiger and dog so if I do something like
436:03 - public here well I as I told you it
436:06 - maintains the structure right so if I do
436:09 - public here and then I'll just create
436:11 - another method right so avoid set the
436:14 - page which will basically set the heat
436:16 - so you so each
436:18 - and then this age you can see here age
436:22 - is actually coming here which is
436:24 - basically not defined in this tiger
436:26 - class but it got inherited from this
436:28 - protected class sorry this animal class
436:31 - so if I do this H equal to H it is going
436:34 - to work and uh what we can do here is
436:40 - T Dot Sony T dot set each to something
436:46 - like 10 and then we can also retrieve it
436:49 - so let's say in
436:51 - get H
436:54 - great damage
436:57 - and if we try to print that each so if I
437:00 - do c out
437:02 - T dot h sorry T dot get H
437:06 - and if I look in the console you will be
437:09 - seeing 10 which we have set here and
437:11 - that age is actually derived from this
437:14 - animal class right and now if I try to
437:16 - create something like animal or even
437:18 - tiger if I do Tiger DOT H I won't be
437:22 - able to access it so if I do T dot a is
437:25 - equal to 10 I'll be getting an error so
437:27 - it says if you look in the debug console
437:30 - it says that in animal age is protected
437:33 - so that means that I cannot change that
437:36 - it is like a private member to the
437:38 - objects but it's like a public member
437:40 - for the internet so that that's what
437:42 - protected means so this is for the
437:45 - private so this I did not change this
437:47 - method this is for the private team for
437:49 - protected it means that it can be
437:52 - inherited by cannot be accessed by
437:55 - objects public means that it can be
437:57 - accessed with objects as well as it can
437:59 - be inherited into other classes so
438:02 - that's all about basic inheritance in C
438:05 - plus so again as a recap this will
438:08 - specify where to inherit so if I do
438:10 - protect it here what is going to happen
438:12 - if I do protect it here everything is
438:15 - going to go inside the protected
438:16 - function so why do we want to do that so
438:19 - let's say I want to create another thing
438:20 - like uh for now let's say tired baby
438:23 - it's the baby of this tiger so if I want
438:26 - to inherit something from this I can do
438:28 - something like this public
438:30 - tiger which is completely allowed now
438:33 - what is happening something from here is
438:35 - going to get in his written inside the
438:37 - tiger and something from Tiger is going
438:39 - to get inherited inside this class which
438:41 - is called tiger baby and that is how
438:44 - inheritance works and that's how it
438:46 - boosts your programming in this video we
438:49 - will be looking at the different types
438:51 - of inheritances we can perform in C plus
438:54 - before beginning I would like to kind of
438:56 - put a note here that whatever we are
439:00 - going to discuss today are not to be
439:02 - taken as the only things available for
439:06 - you right so these types of inheritances
439:10 - or Frameworks as I call them these are
439:13 - to be used only to model your program so
439:17 - there are many kinds of problems which
439:19 - cannot be directly solved using the four
439:22 - or five types of inheritances we are
439:24 - going to discuss today so you need to
439:27 - kind of model the problem and use a
439:30 - combination of one or two and maybe
439:33 - sometimes even all four types of
439:36 - inheritances and then create one and
439:38 - actually that is mentioned as an
439:41 - inheritance
439:42 - a type of inheritance for you so the
439:45 - point is you need not remember all these
439:48 - things but as a computer programmer you
439:51 - are supposed to know that these things
439:53 - exist these Frameworks exist these are
439:56 - nothing but just to help you model your
439:59 - program and not to be used directly but
440:03 - to be used along with proper planning
440:06 - and then uh you know kind of modeling of
440:09 - your problem so
440:10 - The Inheritance problem has been there
440:13 - for decades and it's not completely
440:16 - solved even now
440:18 - there's no kind of hard and fast rule to
440:21 - say that this particular inheritance
440:23 - model will do better than that or for
440:26 - this particular problem only this model
440:29 - will work there's nothing like that you
440:31 - can try with different models of
440:34 - inheritances you can try to combine one
440:36 - or two types and then come up with your
440:38 - own custom type and all those things so
440:40 - these are just like a starting point for
440:43 - uh modeling your problems right so with
440:46 - that let's get started so here I have
440:49 - pulled up a website which which is
440:52 - student tonight.com so what we are going
440:55 - to do from this website is we're just
440:57 - going to refer the names from here and
441:00 - then the images so here they have
441:02 - beautifully provided kind of images here
441:04 - to visualize how The Inheritance would
441:07 - look like and then we will Implement
441:10 - that in code and we'll use the same
441:12 - notation here as here you can see they
441:15 - have used a as a superclass basically
441:17 - which is the parent class and B is the
441:20 - subclass which is the child class so
441:23 - we'll use the same naming in our code
441:25 - too so that you can relate with this
441:27 - right so let's get into it one by one so
441:31 - the first type of inheritance is single
441:34 - inheritance which I'm sure everybody is
441:37 - familiar by now so we have been doing
441:39 - this in the past video which is nothing
441:42 - but you have one single parent and one
441:44 - single child so to implement it quickly
441:46 - let's just create a pen
441:49 - a Class A
441:51 - and
441:53 - um we'll keep this simple we'll just
441:54 - have a Constructor and Destructor right
441:56 - so to create a Constructor you just put
441:59 - a function definition just like that
442:02 - without any return type and then
442:05 - um inside this you can pass in
442:07 - parameters but for now I'm just keeping
442:09 - it empty so here we'll just say once
442:13 - connecting a
442:16 - right we'll see in a moment why we are
442:19 - defining this concept is right so
442:22 - we again needed Destructor so for
442:25 - Destructor what you need to do is put a
442:27 - tied symbol
442:28 - T and Define the Constructor as it is
442:32 - but here the only difference between a
442:34 - Constructor and Destructor is that
442:36 - Destructor is meant only to destroy the
442:39 - object right it is only meant for
442:41 - distracting the object when it gets out
442:43 - of the scope so it doesn't take any
442:46 - arguments so you cannot pass anything
442:48 - here unlike in Constructor you could do
442:50 - something like int a in a Constructor it
442:52 - is allowed but in Destructor it is not
442:55 - right this is just to kind of debug your
442:57 - program when your object is getting out
442:59 - of the scope and all right so here we'll
443:02 - just see
443:09 - and that makes a now let's create
443:12 - another class simulator to this class B
443:14 - so copy that
443:17 - paste that and we just need to replace
443:20 - it so replace all a with b and you need
443:24 - to match case from the cursor right so
443:27 - replace that you don't need to replace
443:29 - these things you need to replace these
443:32 - things
443:34 - well now we have another class ready
443:37 - now to inherit a inside D I hope you
443:41 - remember that you just need to put a
443:43 - colon and then the access specifier
443:45 - where you want to inherit inside P will
443:48 - keep it public
443:49 - and you are going to specify which class
443:52 - you are going to inherit from which is a
443:54 - in our case so a
443:57 - right so here we have a single
443:59 - inheritance as shown in this picture
444:01 - right so you have one parent class which
444:04 - is getting inherited into a child class
444:06 - so here you can see parent classes a and
444:10 - a is getting inherited inside B so now
444:13 - if you create an object of Class B so if
444:16 - I say b obj obj stands for object so and
444:20 - run this thing
444:23 - so well I did not put any new lines here
444:26 - so just put that so that we can
444:28 - differentiate the output and you know
444:31 - kind of run through what it actually
444:34 - means right so
444:38 - putting the new line you have this
444:39 - output and let's break it down right so
444:43 - first you have constructing a and then
444:46 - constructing P so if You observe here we
444:48 - are not constructing a at all right but
444:51 - why is this statement coming this
444:53 - statement should only come when I create
444:55 - an object of a right and here I am again
444:58 - distracting a which I did not even
445:00 - create so what is happening here
445:03 - will object creation is called
445:06 - instantiation right so it's called
445:08 - something called
445:10 - instantiation so what it means is you're
445:14 - going to create a virtual object it
445:18 - doesn't actually exist it's actually not
445:20 - a physical object it doesn't exist in a
445:23 - memory what it means is since I am
445:25 - inheriting from a for a computer
445:28 - inheritance means you need something
445:31 - from a inside Class B and everything is
445:34 - not defined inside Class B so in our
445:36 - case there's nothing special about A and
445:39 - B right so a just has a Constructor and
445:41 - Destructor and B also has a Constructor
445:44 - and Destructor and practically there's
445:47 - nothing to inherit from a but for a
445:49 - computer it doesn't look at those things
445:51 - it just knows that it needs to inherit
445:54 - from a inside D so assuming that a has
445:57 - something which B doesn't it first
446:00 - creates the a kind of instance of an
446:04 - class instead of the parent class which
446:07 - on in our case is a and then it will
446:10 - pass on those properties to class B that
446:12 - is why in the console when you are
446:14 - creating an object B you're seeing
446:15 - constructing a first here that is
446:18 - because since a is the parent class it
446:20 - it assumes that there is something
446:22 - important inside the parent class which
446:24 - is not there in the child class so that
446:26 - is why you are inheriting right the main
446:28 - purpose of inheritance that is why the
446:30 - compiler is built to do that so first it
446:32 - will construct a then it will construct
446:34 - B and while destructing it will destruct
446:36 - in the reverse orders right so
446:38 - construction happens from A to B that is
446:41 - parent child and destruction happens
446:43 - from B to a that is child to parent and
446:46 - this will continue for any level of
446:47 - inheritance we will just see what levels
446:49 - are right so this is basically just
446:52 - simple inheritance or the single level
446:54 - inheritance in C plus plus right now
446:57 - let's move on you have multiple
446:59 - inheritance multiple inheritance
447:01 - basically means that you have multiple
447:03 - parents for a single so here it has
447:06 - demonstrated the two but there you can
447:08 - have as you have mentioned here you have
447:12 - classes which can inherit from more than
447:15 - two classes also it totally depends upon
447:17 - your problem
447:19 - now to do that it's almost similar you
447:22 - just need to take this out you need to
447:24 - duplicate this class B so
447:27 - take this
447:28 - copy that
447:31 - and
447:33 - replace this thing so you need to
447:35 - replace B with C so replace yes yes yes
447:40 - yes yes
447:41 - yes and uh well you can do this manually
447:47 - now I have a class C and also an object
447:51 - of Class C and to inherit multiple
447:54 - classes what you need to do is just put
447:57 - a comma right so if you just
448:01 - a this is just single level inheritance
448:03 - basically what it means is a is the
448:05 - parent C is the child and c as a child
448:08 - is inheriting everything from parent a
448:10 - right that is that and for B you just
448:14 - put a comma and then put the access
448:16 - specifier I'm just going to keep it
448:18 - public here you can do protected or
448:20 - private as your problem but for now
448:23 - let's just keep it simple we'll just use
448:26 - public for all our inheritances right so
448:29 - public a public B now you have
448:32 - multi-level inheritance sorry multiple
448:34 - inheritance right and now if you run
448:36 - this
448:37 - you have this kind of output now the
448:40 - thing to be noted here is it's almost
448:42 - similar right so first a is constructed
448:44 - B is constructed then C is constructed C
448:46 - is basically the actual class which you
448:49 - are working upon and then the
448:51 - destruction is just the reverse order of
448:53 - conception the thing to be noted here is
448:55 - if you change the order of inheritance
448:58 - over here it will be affecting the order
449:01 - of creation also so here I am first
449:03 - inheriting a then inheriting B it reads
449:06 - from left to right so basically first
449:08 - I'm inheriting a then I'm inheriting B
449:11 - now if I change this order if I make
449:13 - this B and if I change this as a and now
449:16 - if I run this that order will be swapped
449:18 - there too so if you see here first it
449:20 - has constructed B that is because it is
449:23 - appearing here first and then a is
449:25 - constructed then C and basically this
449:28 - order is just reversed while destruction
449:29 - right so destruction follows that same
449:32 - procedure the in the order construction
449:34 - happens destruction happens in the
449:36 - reverse order right so
449:39 - that is about multiple inheritance
449:41 - disorder matters and you can have as
449:44 - many classes as you want inside uh this
449:48 - particular class you can inherit from
449:49 - multiple parent classes right so if you
449:52 - had more financial class so say public
449:55 - some tea and private e all this is
450:00 - possible basically it will just
450:02 - construct the classes in this order
450:04 - first B will be constructed a will be
450:06 - constructed D will be constructed e will
450:08 - be constructed then C will be
450:10 - constructed right so that is about
450:13 - multiple inheritance now we can move on
450:17 - just take out this website and here you
450:20 - have something called hierarchical
450:22 - inheritance so in multiple inheritance
450:25 - you had multiple parents in hierarchical
450:27 - you have multiple children so that is
450:29 - the difference between multiple and
450:31 - hierarchical you have one single parent
450:33 - and
450:34 - that single parent is inherited by
450:37 - multiple children so we have already
450:39 - worked upon one of the examples on this
450:42 - particular hierarchical inheritance
450:44 - structure that is when we are discussing
450:46 - about the animal class so if you
450:48 - remember we had a class animal and both
450:51 - classes like the tiger class and the dog
450:54 - class inherited from the animal class so
450:56 - that was an example of hierarchical
450:58 - inheritance so to do that here we can
451:00 - just put something
451:03 - a and
451:07 - public a so here you can see that a is
451:10 - the parent Class B and C both are
451:13 - children of a so both are inheriting a
451:15 - so this is basically an example of
451:17 - hierarchical inheritance and uh it's
451:21 - basically if you just create an object
451:23 - of C it's just going to look like simple
451:25 - inheritance or single identity because
451:26 - uh if you just remove this B from here
451:29 - what you have you just have a parent
451:32 - class and then you have Charizards which
451:34 - is inheriting from the parent class
451:35 - which is nothing but an example of
451:37 - single level inheritance so basically it
451:40 - works in the same way so now
451:42 - it will output something similar to
451:45 - single level it just seek the parent
451:47 - class constructed the child class and
451:50 - the destruction is a reverse order right
451:52 - so that is about hierarchical
451:55 - inheritance and now the other thing is
451:58 - multi-level inheritance now the
452:01 - difference between multi-level and
452:03 - multiple inheritance is that in multiple
452:06 - you have multiple parents but in
452:09 - multi-level you have a tree kind of
452:11 - structure so a multi-level basically is
452:14 - kind of uh more generally used
452:18 - inheritance framework because um
452:21 - this basically transes from a more
452:24 - generic class to a more specific class
452:26 - so what I mean by that so let's say
452:29 - um an example for a general class could
452:32 - be animal so animal is more generic I
452:35 - could mean any animal by just saying
452:36 - animal right so if I have class animal
452:39 - and then I want to be somewhat more
452:42 - specific so I mean I'll just increase my
452:44 - specificity level and let's say I have a
452:48 - class doc so now I'm inheriting from
452:51 - animal inside dog so here uh if you see
452:54 - that
452:56 - chart here you have a which is animal
452:59 - and then B could be dog so now I am
453:02 - inheriting the properties of animal
453:03 - inside class dog and if I want to be
453:06 - even more specific like uh choose some
453:09 - breed of dog for example so that could
453:12 - be C so basically you are moving from a
453:15 - more generic class of objects to a more
453:17 - specific class of objects so that is why
453:19 - multi-level inheritance is basically uh
453:22 - used mostly but as I told you it doesn't
453:26 - have to be it totally depends upon your
453:28 - problem right so let's quickly implement
453:31 - this so the way you implement is you
453:33 - have a b is inheriting from a then C
453:37 - will inherit from P so
453:39 - this is multiple right multi-level is
453:42 - you have two or more parents and the
453:45 - child will inherit from them and in
453:47 - multi-level you have a kind a tree kind
453:50 - of structure right so now if you run
453:53 - this you will get a similar output for
453:56 - what you saw in multiple basically the
454:00 - order matters here so first the parent
454:02 - is constructed then the b b is basically
454:05 - the child of a then C which is nothing
454:07 - but a child of B and then the
454:10 - destruction will happen in the reverse
454:11 - order right
454:13 - so that is about
454:15 - multi-level inheritance and then in the
454:19 - end you have something called Hybrid
454:20 - inheritance so Hybrid inheritance is
454:23 - nothing special it's just uh you know
454:25 - it's just a kind of combination of all
454:28 - these kinds of it narratives here is
454:30 - this just said that it's a combination
454:32 - of highlight care and multi-level
454:34 - what I'm saying is it doesn't have to be
454:37 - so this particular framework it it
454:39 - doesn't have to look so neat so here you
454:42 - have two classes just directly
454:43 - inheriting from a and then you have one
454:46 - single class inheriting from B and C
454:48 - also so
454:50 - it it doesn't really have to be in such
454:55 - a clean format it totally depends upon
454:58 - the problem on the way you are going to
455:00 - solve your problem so high radical or
455:03 - sorry the Hybrid inheritance of the
455:05 - virtual inheritance basically means that
455:08 - you are going to create a custom model
455:10 - custom inheritance type by using these
455:13 - four types so the single multiple
455:15 - multi-level and then hierarchy we're
455:17 - just going to use a combination of these
455:20 - types and then create a custom model
455:21 - which may look like this so here if you
455:24 - see if we just close this D part what
455:27 - you have here is hierarchical and then
455:30 - here you have multiple
455:33 - right so that is basically uh the uh
455:38 - gist of Hybrid inheritance and
455:42 - now in Hybrid inheritance I just
455:45 - remembered by looking at this figure
455:46 - actually this figure is an example of a
455:50 - very famous problem called The Diamond
455:52 - problem so it's a very famous problem in
455:54 - inheritance basically the structure
455:57 - looks like a diamond right so here it is
455:59 - basically not drawn in that way
456:03 - open up paint and what you have is you
456:07 - have been in class okay so a for example
456:10 - you have multiple inheritances like this
456:13 - so you have B
456:15 - and then you have C
456:18 - so this example is
456:21 - from here the hierarchical inheritance
456:25 - right so okay we will start
456:31 - yeah so this example is from the
456:34 - hierarchy inheritance where you're a
456:35 - single parent and you have multiple
456:37 - children then what I'm going to do is
456:39 - combine these two children
456:41 - to another
456:43 - kind of child which is d and what is
456:47 - this example from so if we just remove
456:50 - these things don't consider this just
456:53 - consider BC and then you have D it is
456:55 - basically an example of Justin right
456:57 - multiple inheritance so here you have a
457:00 - hierarchical and then here you have
457:01 - multiple and this structure which looks
457:04 - like a diamond is a very famous problem
457:07 - because this doesn't know from where it
457:10 - should inherit so see if you are taking
457:12 - this particular path so from A to B B to
457:15 - D then you know that you just need to
457:18 - inherit a but if you're taking this part
457:20 - because it is also a part of the parent
457:23 - right so C should also be inherited and
457:25 - for C A should also be inherited so the
457:28 - problem is should this inheritance
457:29 - happen because it's already happened
457:31 - right in case of B so if we just search
457:34 - for that you will have a more concrete
457:36 - explanation of that so time and
457:39 - link
457:40 - okay especially it's not a language
457:42 - dependent problem it's a it's it's the
457:45 - problem of multiple inheritance okay so
457:48 - here you you will find a more clearer
457:50 - example basically it says the same thing
457:53 - which I said here so name and age needed
457:55 - only once that is basically the person
457:57 - class should be created only once but if
458:00 - I'm taking this path
458:02 - I should I will be creating this but
458:04 - since the this class which is faculty is
458:08 - also and a parent of ta which also has
458:12 - to be created so should I
458:15 - include the person class again or not so
458:18 - that is the main question and we will be
458:20 - solving that by using something called
458:22 - abstract classes so here you will be uh
458:26 - seeing some examples of that used here
458:28 - the abstract class methods but uh since
458:31 - we did not discuss it till now I'm not
458:33 - going to go into detail right now we'll
458:35 - be going into detail in the next video
458:37 - but this is the problem you can read
458:40 - this uh to get some more insight into
458:43 - this and um that's it for types of
458:46 - inheritance in C plus place in this
458:48 - video we'll solve the diamond problem
458:51 - which we discussed in the previous video
458:53 - so if you remember that I had referred
458:57 - you this particular website where the
459:01 - timing problem is beautifully
459:02 - Illustrated so the diamond problem is
459:04 - you have a base class or a parent class
459:07 - from which multiple classes are getting
459:10 - inherited and then you have another
459:13 - child class which are using the
459:15 - inherited classes as the pairing classes
459:17 - so let's quickly create a program
459:20 - version of this so let's see Class A
459:26 - and um
459:27 - we'll again keep this simple so we'll
459:30 - just we'll just have a Constructor and
459:32 - Destructor as we had in the previous
459:34 - example so you have
459:39 - a
459:41 - and you have a Destructor
459:44 - which is
459:47 - this truck okay
459:51 - destructing a
459:54 - and uh we need to create another class B
460:00 - so create that and we need to change the
460:04 - A to B so the a is going to change into
460:07 - B
460:09 - so replace
460:16 - and we again paste that
460:20 - change document also aim to C now so
460:24 - we press a with c
460:28 - so
460:30 - then and
460:35 - again create another class which is
460:36 - going to be T right so because we need
460:39 - four classes right
460:40 - um let me just quickly show you that
460:43 - picture so
460:44 - this class is being referred to as a you
460:48 - have B and C two more classes which are
460:51 - going to be inheriting from a and then
460:53 - you have another class called C which
460:56 - will inherit from both
460:58 - D and C sorry this class will be called
461:01 - T which is going to inherit from both B
461:04 - and C all right so
461:06 - um
461:08 - this is going to be D so replace that
461:11 - with d
461:16 - and then so now let's make the
461:19 - inheritance as quickly so Class B as I
461:22 - told you is going to inherit from a
461:23 - Class C is also going to inherit from a
461:27 - if you remember this
461:29 - inheritance is nothing but hierarchical
461:31 - inheritance and now we are going to
461:34 - inherit from both B
461:36 - B and C which is nothing but multiple
461:39 - inheritance so public B and public C
461:44 - right and now we'll create an object of
461:47 - D and we'll see what exactly the problem
461:49 - is so d uh say obj and now if you
461:54 - compile this what do you have okay I
461:56 - again forgot to put those new lines
461:59 - keep forgetting that so slash n
462:11 - over here
462:16 - and over here
462:21 - [Music]
462:22 - well now if you run this particular
462:25 - program
462:27 - what you have you have constructing a
462:30 - constructing P constructing a
462:32 - constructing C and then constructing D
462:35 - and that makes sense right because we
462:37 - are first inheriting from B and B is
462:40 - inter inverting from a so so first B is
462:42 - going to be created which basically
462:44 - means that a is first going to be
462:46 - created then B and that is going to get
462:48 - inherited into D then you have
462:51 - see which again inherits from a so first
462:55 - a is created and then C is created and
462:57 - then you have created the T right now
463:01 - the problem is if I try to touch a from
463:05 - which path should I go so I mean uh
463:08 - we'll just quickly draw that so
463:11 - go to the paint here
463:14 - and uh
463:16 - we have a
463:19 - you have two classes B and C
463:21 - this
463:28 - and then you have
463:30 - combination of these two classes which
463:32 - is basically the class D so this is T
463:37 - num
463:38 - if I create D in this part
463:42 - or in this path if I start creating that
463:44 - I'm again going to create a indefinitely
463:47 - right so as you saw in that output we
463:49 - had created it two times so here you can
463:51 - see constructing a1s and constructing a
463:54 - the second time so we need to avoid that
463:57 - by because say I want to access some
464:00 - properties of a right and B must have
464:03 - modified the properties of a we don't
464:05 - know right so suppose there's something
464:08 - called X here some variable and B what
464:12 - it did is it made X to 20 and C made X
464:17 - to 30.
464:18 - just take this as an example now at this
464:22 - level it's okay just forget about the D
464:24 - for a moment for this level it's okay
464:27 - there are two separate children and they
464:29 - are doing whatever they want with the
464:31 - inherited properties now the problem
464:33 - comes when D has to access X shoot it
464:36 - follow this point which is x equal to 20
464:40 - or should it follow this path which says
464:43 - x equal to 30 what it should do so uh to
464:46 - demonstrate that let's just create a
464:48 - kind of public variable just name it X
464:51 - so Index right for now and um here uh
464:55 - well we don't have to do anything we can
464:58 - just try to do something like since it's
465:00 - just public and we are just doing public
465:02 - inheritance we could do something like
465:04 - obj dot x equal to 10. I could do that
465:08 - right this is perfectly normal now if I
465:11 - try to run this but it run this
465:14 - I get an error what is
465:17 - it it says request for member X is
465:20 - ambiguous why is ambiguous that's the
465:23 - same thing I just told it's ambiguous
465:25 - because it doesn't know what to do so
465:28 - even if I try to change it over here or
465:30 - as I explained it in the picture if I
465:33 - try to change it in one of the inherited
465:35 - classes if I just change it in one of
465:37 - the inherited classes so if I just keep
465:39 - it x equal to 30 here and just leave it
465:42 - then also it's going to be a problem
465:43 - because it doesn't know whether to keep
465:45 - it the same or to change it right so
465:48 - this is the main problem which is called
465:50 - The Diamond problem the thing is it
465:52 - doesn't know which path to take should
465:54 - it change X through b or should it
465:57 - change X through C or
466:00 - basically should it change the X over
466:04 - here or not should two copies be created
466:07 - of X which will lead to ambiguity and um
466:11 - well if you don't create X at all then
466:14 - there is no ambiguity right but again
466:17 - why are you inheriting you are
466:19 - inheriting something because you want
466:21 - those properties inside the child right
466:23 - if the parent doesn't have anything
466:24 - useful for the child to inherit there's
466:27 - no point in inheritance at all right so
466:29 - this problem has to be solved and how do
466:32 - you solve that you solve that using
466:34 - something called virtual inheritance
466:37 - so what does that do well if you see
466:40 - here what we're doing we are just
466:42 - creating two copies of a right so what
466:45 - virtual inheritance does is while
466:48 - inheriting into these two classes I'm
466:50 - I'm I know that these two classes are
466:52 - going to be a parent of some other class
466:55 - so now my
466:57 - solution to this is I will keep this
467:00 - virtual that is even if I create even if
467:03 - I create multiple copies they will be
467:06 - pointing to the same object or the same
467:08 - instance which has been created in the
467:10 - memory so while creating a memory map
467:12 - for D say I first create a through b so
467:17 - a has been created once right now if I
467:20 - create it through C since I already have
467:23 - a a will not be created that is what is
467:26 - the advantage of having virtual
467:29 - inheritances so to do that what we do
467:32 - here is
467:34 - instead of directly inheriting a we just
467:38 - do something like virtual public a and
467:41 - we'll talk more about this virtual
467:42 - keyword right for now just keep it like
467:45 - this so you have virtual public a which
467:47 - is basically a virtual inheritance and
467:50 - then you have virtual public a over here
467:53 - now as I told you a will not be
467:58 - recreated again and again so if you have
468:00 - 10 classes like this
468:01 - if you just stop at those classes if I
468:04 - just access B and C there's no problem
468:07 - the problem arises only when I want to
468:10 - go up a level right so I want to
468:12 - directly access the x of a if I had some
468:16 - X of B over here and if I try to access
468:19 - that I won't be having a problem because
468:21 - B is a direct parent or C C is also a
468:24 - direct parent of D but a is basically
468:27 - one level higher right so that is where
468:29 - the problem arises and this is how you
468:31 - solve the problem you just virtually
468:33 - inherit those classes so so now
468:37 - you wouldn't be getting an error and it
468:40 - does run successfully and here you see a
468:42 - has been created then B then without
468:45 - creation of a it has directly created C
468:48 - why is that that's because while
468:50 - creating see it already saw that there
468:52 - exists a copy of a that is why it is not
468:55 - creating a again if it changes order
468:57 - first the a class for c will be created
469:03 - and then B will be created without a now
469:06 - if I change this now if I run this
469:08 - you can see here AC and this a is
469:11 - because of this inheritance and since
469:14 - it's virtual it knows that this should
469:16 - exist only one copy of this particular
469:19 - instance that is why while creating P it
469:22 - will see this statement and then uh look
469:25 - up that memory map and then find out
469:28 - that a has already been inherited so it
469:31 - won't inherit a again and this operation
469:33 - is totally valid so that's how you solve
469:36 - the diamond problem and about this
469:39 - virtual classes this this virtual
469:42 - keyword what it does is it will
469:45 - take care of the fact that
469:48 - there exists only one particular copy
469:51 - that that is what virtual means so uh
469:53 - for something called abstract classes
469:56 - which we are going to discuss in the
469:57 - next video the abstract classes are
470:00 - basically
470:01 - um a kind of base for creating newer
470:03 - classes now the abstract classes are
470:07 - need not be kind of virtual right so see
470:10 - a virtual methods of virtual
470:12 - inheritances these are useful only when
470:16 - you need a single uh kind of copy of the
470:20 - property so say I have a Constructor a
470:24 - over here and if I override this
470:25 - Constructor over here just saying so
470:27 - instead of B if I just say a this is
470:30 - also particularly valid rate so I'm just
470:33 - rewriting that function over here
470:36 - now I can access this a through a method
470:40 - which we'll discuss afterwards right so
470:42 - we can access the methods of the parent
470:45 - class methods or variables or anything
470:47 - of the parent class through a map we we
470:51 - do have a possibility for that now the
470:54 - point of virtual keyword is
470:57 - you shouldn't have multiple copies so
470:59 - basically this is creating multiple
471:00 - copies so through b if I'm accessing a
471:03 - it should be printing constructing B but
471:05 - through a if accessing this particular
471:07 - Constructor it should say constructing a
471:10 - so basically there are two copies of the
471:12 - same function this is called overloading
471:13 - and we'll talk about this in the next
471:15 - video also right so
471:18 - for this particular issue virtual
471:22 - keyword is there which basically means
471:24 - that you can have only one particular
471:25 - copy you cannot have overloading and all
471:28 - and so in abstract classes what you have
471:30 - is if you need only one feature one copy
471:32 - of that particular feature you will make
471:35 - it virtual so that
471:36 - in the inherited class where you have
471:40 - that virtual function inherited you need
471:44 - to Define that function indefinitely
471:46 - inside the class so in Virtual classes
471:49 - what you do is you just create a virtual
471:52 - method and then leave that you don't
471:54 - Define that virtual method so in the
471:57 - inherited class what you do is you
471:59 - inherit that method and then you need to
472:01 - Define that method indefinitely if you
472:04 - don't Define it you will get an error
472:05 - I'll do it so that solves a problem of
472:08 - you know maintaining multiple properties
472:10 - and we generally don't actually want
472:13 - multiple properties of the same thing
472:15 - unless in really rare cases right so in
472:18 - rare cases are you going to you know
472:21 - access the properties of A and B through
472:24 - D so it's very rare that you're going to
472:27 - access this but in case you want to
472:30 - access it this is the solution you need
472:32 - to make it virtual right in this video
472:35 - we'll talk about
472:37 - overloading and overriding in C plus
472:39 - plus so let me just write it down here
472:42 - it's overloading and overriding all
472:45 - right so let's first talk about
472:48 - functions for a moment right so when we
472:51 - learn functions we told that functions
472:55 - are nothing but a piece of code to be
472:57 - executed separately so that your program
473:00 - can be broken down into a set of
473:03 - functions which will do the work and
473:05 - then all the results can be integrated
473:07 - together to solve the problem right so
473:10 - now let's say you want a function which
473:14 - can do multiple things that is not
473:16 - possible right when we Define a function
473:18 - if we are defining a function we need to
473:21 - be sure that we pass the same number of
473:23 - arguments or the same kind of arguments
473:26 - to the function to make it work so let's
473:28 - say I do something like uh in terms add
473:32 - which is going to take in two integers
473:35 - so int a and in p and what it will do it
473:38 - will just return a plus b now I can use
473:42 - this function without any problem and I
473:45 - can even pass integers over here right
473:48 - sorry I can even pass characters over
473:50 - here because as you know characters are
473:52 - nothing but integers behind the scenes
473:55 - they have their ASCII values and when
473:57 - you pass a character as an integer it is
474:00 - considered as the characters ASCII value
474:03 - right so basically I can pass integers
474:06 - and characters and floats too because as
474:10 - you know because of the type casting the
474:12 - floats will be converted to integers and
474:14 - the operation will perform but what
474:17 - about strings I cannot add two strings
474:19 - using this function right
474:21 - so if I use this function I can only I
474:25 - had two numbers or two characters and
474:27 - get back an integer I cannot add two
474:30 - strings using this function it will give
474:31 - me an error right so
474:34 - how do we go about solving problems
474:37 - where you want to
474:40 - solve problems using the same function
474:43 - signature you don't want to write
474:45 - multiple different functions for the
474:47 - same thing but all the functions are
474:50 - actually similar in nature that means
474:53 - that these functions can be grouped
474:55 - together so that's when overloading
474:57 - comes into the picture so what you do is
475:00 - you keep the signature same all right
475:02 - you keep that same but you can alter the
475:05 - parameters over here and redefine the
475:07 - function and when you compile the
475:09 - program the compiler will see the inputs
475:12 - which are giving the parameters and then
475:14 - it will use the suitable function
475:17 - definition for that parameter all right
475:19 - so uh for an example let's quickly write
475:22 - a small program so let's write a
475:24 - function to determine whether something
475:28 - a given input is a palindrome or not all
475:31 - right so if you don't know what a
475:32 - palindrome is palindrome is nothing but
475:34 - anything which can be read the same way
475:38 - from right to left or left to right so
475:40 - if we take a word as Madam so m a d a m
475:43 - if you read it from left to right or
475:46 - right to left it Still Remains the Same
475:48 - right so these kinds of things are
475:50 - called palindromes it is the same with
475:53 - numbers too if I do one zero zero one
475:55 - this is also a palindrome right now
475:59 - our problem is to write a function so
476:02 - that the function can identify
476:04 - palindromes in both strings and numbers
476:08 - all right so this is our task so how do
476:11 - we go about this well uh writing for
476:13 - Strings is pretty easy right so let us
476:16 - first write a definition for that
476:18 - function so let's say Bool because we
476:22 - are going to return it true or false and
476:24 - it's called palindrome and uh it will
476:28 - take a string so let's call it Str for
476:31 - now
476:31 - right and uh to compare palindrome what
476:34 - we need to do is we need to uh well if
476:37 - you think about it the logic is very
476:39 - simple I will uh leave it to you to come
476:43 - up with um different methods to solve
476:45 - this particular problem but for now
476:46 - let's go with the simpler methods right
476:49 - so what we can do is we can just iterate
476:51 - over the strings and go on comparing the
476:54 - first and last character of the string
476:55 - and other way to do this is to reverse a
476:58 - string and then compare it well the
477:00 - first way is more efficient but uh I
477:03 - want to take this opportunity to show
477:05 - you that uh string data type has lots of
477:10 - methods in it and one of the method is a
477:13 - reverse right so basically what we are
477:15 - doing we are just when we are comparing
477:16 - whether our input is a palindrome or not
477:20 - what we are doing is we are checking
477:22 - whether the number or the string even if
477:25 - it is reversed reads the same thing or
477:28 - not right that is if it reads the same
477:30 - thing it's a parallel drug if it doesn't
477:32 - it is not a palindrome so
477:35 - to do that what we can do is this string
477:39 - class or the string data type does have
477:42 - lots of methods with it so if you check
477:45 - for
477:46 - string rivers in C plus plus you do have
477:51 - a function to reverse a string right so
477:55 - basically you you can do it manually as
477:59 - shown here you can use a for Loop or you
478:02 - even have a function to reverse a string
478:06 - all right so once again I'm just
478:08 - searching for that
478:10 - yeah this one so here if you see you can
478:13 - directly reverse this using this kind of
478:16 - a method right so I I'll just copy this
478:20 - thing so that uh I don't have to write
478:22 - it again but basically this is the way
478:24 - you can reverse a string and as I told
478:27 - you the other way would be to just
478:29 - compare the first and last characters
478:31 - and so on right so you compare the zero
478:34 - and the last character one and the last
478:36 - but one character two and the last but
478:39 - two character and so on so if you just
478:41 - compare that that will be more efficient
478:43 - so yeah so we can just copy this
478:48 - and paste it over here
478:51 - so that we get the reverse of the string
478:53 - and what I can do is I can just compare
478:56 - whether the string and reverse are equal
478:57 - or not so if the string is equal to the
479:00 - reverse
479:02 - then uh well I just need to return true
479:07 - else written false so let's quickly try
479:11 - some examples here so see out let's say
479:14 - palindrome
479:16 - of Madam all right and uh yeah did this
479:22 - method won't uh I mean allow you to
479:24 - compare strings with uh
479:27 - different cases right so if I if I do
479:30 - something like Madam this won't be
479:33 - considered as a parent normal right so
479:35 - I'm not taking that H case for now so
479:37 - let's just try to keep this simple but
479:40 - uh you're open to try out all the edge
479:42 - cases and then come up with a very
479:44 - efficient algorithm to find out whether
479:46 - a string is a palindrome or not all
479:48 - right so this the purpose of this video
479:50 - is not to explain you how to get a
479:54 - palindrome but uh it's basically to
479:55 - explain you overloading or overriding
479:57 - which we'll do in a moment all right so
480:00 - for now this is our program and if we
480:02 - run this using Ctrl F9
480:07 - what does it say palindrome is not
480:09 - declared in the scope
480:11 - okay I have written plain room so
480:15 - Talent room
480:19 - so here you get one right so one is
480:22 - basically true and zero is false so you
480:26 - know that right so now here if I try
480:29 - something else so let's just try the
480:30 - casing one so as I told you this should
480:33 - not be a palindrome compared by this
480:36 - method right so we are not comparing
480:38 - cases here sorry we are comparing
480:40 - different cases here so small m is
480:43 - different from capital M right so this
480:45 - will not be a palindrome to the compiler
480:48 - so it will say it's not a palindrome so
480:50 - you get a 0 over here which is false
480:52 - right so we have written
480:55 - string palindrome but what if I pass in
480:57 - a number over here so something like one
480:59 - zero zero one if I run this I'll be
481:03 - getting an error it says could not
481:04 - convert this from into a string so this
481:07 - this whole thing is nothing but this
481:08 - string all right so to to make this Pro
481:12 - this function work even for string
481:15 - either what I can either do is I can
481:18 - just say palindrome string and then
481:20 - Define an entirely different method for
481:23 - integer palindrome or what you can do is
481:27 - I can just say bull palindrome so notice
481:31 - that the signature is same the return
481:34 - type and the name of the function is
481:36 - same but here I'm just going to say in
481:39 - 10 all right
481:40 - and so here I am keeping the integer and
481:44 - to find the reverse of integer you have
481:47 - a small logic so I'm not going to go
481:50 - through a logic basically what you do is
481:52 - you have a multiple very well we can
481:54 - just copy and paste that logic from here
481:56 - since we're not discussing about
481:57 - palindrome so
481:58 - um let's say in Talent room C
482:03 - plus plus
482:05 - why do I keep writing play in Chrome
482:06 - over here so we yeah
482:11 - so this is what you do so basically uh
482:14 - the same thing is going on over here
482:16 - what what this program does is it will
482:19 - find the reverse of the number using
482:21 - this logic so basically reverse of a
482:23 - number is nothing but you extract every
482:24 - number every number is basically the
482:27 - reminder when you divide that number by
482:30 - 10 the r is nothing but the last digit
482:33 - all right so in mod 10 as I told you
482:35 - over here if I do mod 10 it will
482:38 - basically give me the last number and uh
482:41 - sorry about that and um here what you
482:45 - what you're doing is you're just adding
482:47 - that last number by a multiple of 10. so
482:50 - what basically happens is you have one
482:52 - and when you store it what you do is you
482:56 - just store it as 0 into 10 plus one so
482:59 - basically you first have sum equal to 0
483:02 - like this sum or anything reverse number
483:04 - anything you can call that it will be 0
483:07 - and you what you do is 0 into 10 plus 1
483:11 - and you put it inside the reverse number
483:14 - so basically now this has become 1 right
483:16 - 0 into 10 is 0 plus 1 is 1. now what you
483:20 - do is you divide this by 10 so 1 0 0 1
483:23 - by 10 which is basically 100 so next
483:26 - again you run this Loop so you do this
483:28 - reverse equal to
483:30 - reverse into 10 plus the last digit so
483:36 - let's call this last
483:39 - digit so this is what you do every time
483:42 - 100 so now what you do 1 into 10 which
483:45 - is 10 plus the last digit is 0 so you
483:48 - get 10 here so this is how you reverse
483:50 - the number so let's quickly write that I
483:53 - thought of copying it but since I
483:55 - explained it it's very simple so in
483:57 - Reverse equal to 0 what you have is
484:00 - while the number exists well we cannot
484:03 - directly use the number so you need to
484:05 - store the number somewhere for later
484:06 - comparison right so we'll just say in
484:09 - Num equal to n we'll store a copy of
484:11 - that and while n that means while the
484:15 - number is not 0 so as I told you in C
484:18 - plus plus the booleans and integers are
484:21 - related right so any number except 0 is
484:23 - true 0 is false so it will run until n
484:27 - becomes zero so till then what you do is
484:29 - we will say in the last digit equal to
484:33 - the number mod 10 this will give you the
484:37 - last digit and what you need to do 2 you
484:39 - need to say reverse equal to the reverse
484:43 - into 10 previous value of reverse into
484:45 - 10 plus the last digit
484:48 - and the number will become
484:53 - one tenth of itself so number equal to
484:55 - number by 10 right so this is what we'll
484:58 - do we'll be doing and let's just print
485:01 - out the reverse for now all right so
485:02 - let's just print out the reverse number
485:05 - so that we are sure that it's working
485:07 - and we'll just return uh something so we
485:10 - just return true for now all right so
485:12 - now if you see if I run this program I
485:16 - did not specify any different name for
485:18 - this right so basically both these
485:21 - functions have the same name but the
485:23 - parameters are different so when a
485:25 - compiler will see this it will see that
485:28 - I'm using an integer so automatically it
485:30 - will understand that I am calling this
485:32 - function all right so if I pass in a
485:35 - string here it will automatically call
485:37 - this function but uh here since we have
485:41 - overloaded this function this process is
485:43 - known as overloading basically all right
485:45 - so overloading is nothing but you just
485:48 - take the same function you don't change
485:50 - any word in that I mean any signature in
485:53 - that so the signature Remains the Same
485:55 - you cannot change this return type but
485:58 - you can change the number of variables
486:00 - and the variables nature itself so I can
486:03 - even add number of variables over here
486:05 - it doesn't matter all right so if I do
486:07 - that and now if I run this
486:10 - if I now compile and run this I will be
486:12 - getting 1 0 0 1 that is the reverse
486:15 - number and then the one so if you're
486:16 - confused let me just add a new line over
486:19 - here and we'll run this again
486:23 - and here you can see the reverse is one
486:26 - zero zero one which is what we required
486:28 - and the true part which came from this
486:31 - statement all right so now since we have
486:34 - the reverse it's pretty straightforward
486:36 - just like this one right so you can just
486:38 - do something like if the number which we
486:42 - saved this one
486:44 - is equal to the reverse number then it's
486:47 - basically a palindrome so written true
486:49 - else return false so you even if you
486:52 - write else it doesn't matter because if
486:54 - this is true it will directly return it
486:56 - so I'm skipping the else part so return
486:58 - false over here and this should do right
487:01 - so now if you run this program what you
487:04 - have is
487:06 - for both strings and integers so I can
487:09 - even pass integers over here and I can
487:12 - even pass strings over here so let's say
487:15 - um
487:17 - all right so this is also a palindrome
487:20 - so let's check whether the spelling is
487:22 - right or not yeah perfect so now if
487:26 - I run this I'll get one over here and if
487:29 - I try to run something else I won't be
487:31 - getting
487:32 - perfect result so if I do that and if I
487:35 - run this I will be getting 0 or even if
487:39 - I pass in numbers over here so if I do
487:41 - that this one so this is not a
487:44 - palindrome if I run this I will be
487:46 - getting zero so yeah this is the use of
487:49 - overloading when you have a same
487:51 - function
487:53 - I mean the same function signature but
487:55 - you want to use it for different kinds
487:57 - of variables and different number of
488:00 - variables this is how you can use the
488:03 - same function to achieve what you want
488:05 - right so here uh the advantage is that
488:08 - we are not maintaining multiple copies
488:10 - of the same function but what we are
488:12 - essentially doing is we are maintaining
488:15 - multiple signatures of the same function
488:17 - so this whole thing is called a
488:19 - signature and the return type and this
488:22 - one this should not change all right so
488:24 - only the parameter list can change so
488:26 - this one will only be maintained
488:29 - separately and these two function
488:30 - definitions will be maintained the
488:32 - advantage is that you don't have to
488:35 - remember or give you know informative
488:37 - big names to different functions so well
488:41 - I I don't have to worry about overlining
488:43 - if I'm doing something like this is for
488:45 - string like this paring drum Str and
488:48 - palindome int if I'm doing something
488:49 - like this I don't even have to worry
488:51 - about overloading but this basically the
488:54 - whole point of overloading is that you
488:56 - can have a single function doing
488:58 - multiple things that is the idea of
488:59 - overloading and when is this useful it
489:03 - is useful when we are doing inheritance
489:06 - and at that time this thing is called
489:09 - overlaiding right so basically these two
489:11 - are the same thing all right overloading
489:13 - or overriding just mean that you are
489:15 - using the same function with different
489:16 - parameter lists and different
489:18 - definitions all right but overriding is
489:21 - used when you're over when you're
489:23 - overloading a function
489:25 - in different classes when you overload a
489:28 - function from a base class inside a
489:31 - child class that is known as overriding
489:33 - and if you overload the same function
489:35 - inside the Base Class itself that is
489:37 - overloading so that is the only
489:39 - difference between overloading and
489:40 - overriding or else both are the same
489:43 - Concepts so to demonstrate overriding
489:45 - you can just use this one so what I can
489:48 - do is
489:49 - I can say class say a for now and this
489:54 - is going to be a public definition
489:56 - so that I can inherit it and uh I can
490:00 - just push all these things inside this a
490:05 - right and yeah take care of the
490:08 - indentation over here and we'll maintain
490:10 - another class B
490:14 - and inside this I'll just pass these
490:18 - things again so public
490:20 - and uh
490:27 - pass it over here
490:32 - right now if I do a public inheritance
490:36 - over here
490:37 - what will happen is as you know this
490:39 - palindrome will get inherited inside
490:41 - here but since I'm doing this it will
490:45 - get overrided all right so this method
490:48 - won't be won't act as a string
490:52 - palindrome checker for class B but it
490:56 - will act as a integer palindrome Checker
490:59 - inside Class B so for object of Class B
491:03 - if you call object.parent room if I do
491:05 - something like uh let's say obj equal
491:09 - sorry
491:11 - b o b j all right this is a new object
491:15 - of Class B and if I do
491:19 - obj dot palindrome all right so if I do
491:22 - this it will only be valid for a integer
491:25 - parent room all right so if I not do
491:28 - that you will be getting 0 over here of
491:30 - course it's not a palindrome but
491:33 - if I do that
491:36 - and run this I'll be getting an error it
491:38 - says it is not a integer so to take care
491:43 - of this issue
491:44 - there's something it is a method to
491:47 - actually use the functions of the super
491:51 - class super class is basically the
491:53 - parent class which I'll talk about in a
491:55 - later video because that is something
491:57 - very important and we will be using that
491:59 - very very much while using abstract
492:02 - classes so basically all this
492:04 - overloading and overriding all these
492:06 - Concepts come into play when we are
492:08 - using abstract classes well this is not
492:10 - limited only to the functions you can
492:12 - even overload the constructors also if
492:14 - you want to so that is the scope of
492:17 - overloading and overriding in the
492:19 - previous video we discussed about
492:21 - overloading and overriding and in this
492:23 - video we'll talk about abstraction all
492:26 - right so first of all why do we need
492:29 - abstraction or what is an abstract class
492:33 - basically well abstract classes are
492:36 - nothing but just a normal class with at
492:39 - least one of the methods as a pure
492:42 - virtual function now what does this mean
492:45 - it means that a pure virtual function is
492:47 - nothing but a function without any
492:49 - definition it's it's just a signature so
492:52 - why do we need an abstract class when we
492:55 - can just inherit we can just create a
492:57 - normal Base Class and do the inheritance
492:59 - like this well when you have a very big
493:03 - Clash or very big networks of classes
493:06 - where you're using multiple methods of
493:08 - inheritances and all these things what
493:10 - happens is you at some point you forget
493:13 - the structure of the class like let's
493:16 - say we take this function as an example
493:18 - you are using the palindrome function
493:20 - and these two methods just let's just
493:25 - suppose that these two methods are not
493:27 - methods of the string but you have
493:30 - written these methods inside this Base
493:32 - Class which is classic and now while
493:35 - inheriting you are just overriding the
493:37 - palindrome class now let's say I want to
493:40 - access the string class from class B
493:42 - because I I'm not going to I don't know
493:46 - that there exists a Class A which is the
493:49 - base class of uh this class B I just
493:53 - know that I created a method from class
493:55 - B because this definition won't be
493:58 - visible to me right so as I told you
494:00 - we'll be writing this Clash definitions
494:02 - into inside different files so when I
494:05 - use that function when I use that class
494:08 - to create an object so what I will be
494:10 - seeing is this thing so from here I
494:12 - cannot make out what is the base class
494:14 - or what is the super class or what is a
494:17 - parent class and all these things right
494:18 - so what I can tell is this function I
494:22 - cannot even tell whether this function
494:24 - overwrite something or not and for me
494:26 - this is a completely new class but
494:28 - inside let's say you're just overriding
494:31 - this function and uh suppose you forget
494:34 - to overwrite these two functions which
494:36 - may be a dependency for right now it is
494:39 - not a dependency at all but let's say
494:41 - that while overriding you do need these
494:44 - two functions not necessary for the
494:45 - palindrome function but for some other
494:47 - function these two functions are begin
494:49 - and RN are written by U inside the base
494:52 - class and they are necessary for the
494:55 - overrided function to perform so in that
494:58 - case you are going to get an error and
495:00 - you need to figure out what happened
495:02 - right so for this this particular
495:04 - problem for for this problem where you
495:07 - forget the structure of the class at
495:10 - some point abstract classes are
495:12 - introduced so abstract classes what they
495:14 - do is they have a
495:16 - tendency to just create function
495:19 - signatures they don't implement the
495:21 - functions they just create function
495:23 - signatures so that that you get the
495:27 - functions you need to write them you
495:30 - need to Define them indefinitely you you
495:33 - can't skip the definition so that kind
495:37 - of function is called a pure virtual
495:39 - function well virtual beat it here off
495:42 - in while discussing the diamond problem
495:45 - right so the virtual keyword what it
495:46 - does is it will take care of the fact
495:49 - that there exists only one instance of a
495:51 - class if multiple instances are coming
495:53 - so a virtual function will also do the
495:56 - same thing a pure virtual function but
495:58 - the only difference is that every time
496:01 - you implement it it will be considered
496:03 - as a new function it won't be considered
496:04 - as something coming from the base class
496:06 - right so let's see how to implement that
496:09 - what you do is you just write the
496:11 - function definition so let's say in test
496:13 - it can be anything right so maintain B
496:16 - for now and what I'm going to do is to
496:19 - make this pure virtual and to make this
496:22 - whole class as an abstract class I'll
496:24 - just do virtual interest
496:26 - equal to 0 and this
496:30 - statement this two extra statements will
496:34 - make this function as a pure virtual
496:36 - function and the whole class as an
496:39 - abstract class now what is the result of
496:41 - this now if I try to run this I will be
496:43 - getting an error what does the error say
496:45 - it's at the creation of the object from
496:48 - class B it says that it cannot declare a
496:51 - variable of an abstract type now what is
496:55 - the abstract type abstract type was a
496:57 - because B does not have any virtual pure
497:00 - virtual functions but still these
497:03 - considered abstract because this thing
497:05 - is getting inherited directly so I need
497:07 - to Define this I am forced to Define
497:09 - this function inside Class B while I'm
497:12 - shipping this class so that I maintain
497:14 - the structure now let's say palindrome
497:17 - depends on this test right so palindrome
497:20 - depends on this test function and it is
497:23 - very necessary for me to if I'm
497:25 - overriding this palindrome function
497:27 - inside the child's class is just very
497:29 - much required to override this test
497:31 - function also inside the
497:34 - inherited class or the child class so in
497:37 - that kind of a situation you maintain
497:39 - virtual classes you maintain pure
497:41 - virtual uh functions and you maintain
497:44 - abstract classes and when you inherit
497:46 - you can just Define the function just
497:49 - like that so it's basically the same
497:51 - definition you just need to say in uh A
497:53 - and B so these things are already there
497:57 - and B and you can do something like um
498:01 - return a plus b
498:03 - okay a simple function now since I've
498:06 - defined this function I'm not going to
498:08 - get that error so now if I've run this
498:10 - it will run smoothly and I'm getting one
498:12 - that is from this palindrome check which
498:15 - we performed in the last video right now
498:18 - the other thing is that what if we want
498:21 - to access the
498:23 - functions the defined functions from the
498:27 - superclass that is the pair interest so
498:29 - now I do have the function for uh the
498:32 - palindrome check for numbers now if
498:35 - we're passing a string here it is not
498:37 - supposed to work because string is
498:38 - something which is getting inherited
498:40 - from parent class so if I do this if I
498:43 - do this I'm not going to
498:45 - get a perfect output I'm going to get an
498:48 - error so to solve that what you can do
498:51 - is to access something from the parent
498:53 - class you just put the parent name and
498:56 - the scope operator so this is this two
498:58 - uh colons are called scope operator and
499:03 - if you combine it with the Base Class
499:05 - you will be getting the output run from
499:10 - the function which is inside the base
499:12 - class now this will run without any
499:15 - errors now if I try to run this
499:17 - I'll be getting one over here that is
499:19 - because of this one right that that's
499:22 - because of this
499:23 - little addition over here which will
499:25 - make it work for the base classes too so
499:28 - now if you try to do this for test so
499:31 - let's say it test
499:33 - and I don't want to
499:36 - so because test will take two numbers
499:38 - right in 1080P now if I try to run this
499:40 - what do I get I get an error and it says
499:43 - undefined reference to this function
499:46 - what it means is that this function does
499:49 - not exist in class A that is because we
499:53 - declared it as a pure virtual function
499:55 - so once you inherited it has to be
499:58 - defined inside the child classes or else
500:00 - the child classes are also going to be
500:02 - considered as abstract classes and once
500:05 - you implement that function inside the
500:07 - child's class they can be used just like
500:09 - that so if I just do object DOT test
500:12 - which will basically call this function
500:14 - from class B which does have a
500:16 - definition for test if I now try to run
500:19 - this code I will be getting the output
500:21 - and it returns 3 which is basically one
500:24 - plus two right so that is about
500:26 - abstraction and pure virtual functions
500:29 - so basically this whole concept will be
500:34 - used only this is required all right
500:37 - this is not a day-to-day used concept
500:40 - the abstraction and pure virtual
500:42 - function they are not used generally
500:44 - they are used very rarely when you have
500:47 - a situation where you need to do
500:49 - something like this or else a simple
500:51 - inheritance will do its job or not even
500:53 - in returns a very simple class can also
500:56 - do the job for you so these are highly
500:59 - advanced concepts which you may use or
501:02 - may not use in your whole career but it
501:04 - is always a good thing to know that
501:07 - these exist in case you come across a
501:09 - situation where you need to implement
501:10 - something like this so with that let's
501:12 - in this video and in the next video
501:15 - we'll move away from these class object
501:18 - Concepts and we'll do something exciting
501:21 - we'll learn how to interact with files
501:25 - on our hard drive using the file stream
501:27 - and with that we can also explore more
501:30 - about the vastness of object oriented
501:33 - programming Paradigm well as I told you
501:35 - object oriented programming is a
501:37 - paradigm it's a style it totally depends
501:40 - upon the problem whether you need to use
501:43 - object oriented programming or not this
501:45 - this is not a part of C plus plus but
501:47 - this is a part of programming itself so
501:50 - with that let's uh close the object
501:54 - oriented programming for now let's
501:55 - deviate from that and let's talk more
501:59 - about General programming dealing with
502:02 - files how to read files how to write the
502:04 - files and all these things in this video
502:06 - we'll see how to handle files using C
502:09 - plus plus now what is file handling why
502:12 - do we need to handle files well
502:15 - whenever we are running a program where
502:18 - if we are taking some input from the
502:20 - user or let's say we are even generating
502:22 - something which is really important and
502:24 - we need to store those things like uh
502:27 - let's say in our snake game we when we
502:30 - made that we had no provision to give a
502:34 - high score right because every time you
502:35 - run the game the score starts from zero
502:38 - and there's no way to know what was the
502:40 - highest score made till date using this
502:43 - game right so to counter such problems
502:47 - where you need to store data to a hard
502:50 - disk not in the ram because whatever
502:52 - you're doing in the program in its run
502:55 - time it's everything is getting into the
502:57 - ram right nothing is going to be stored
502:58 - onto the disk but you do need something
503:01 - on the disk so that whenever you uh want
503:05 - the data back whenever you want to read
503:07 - the data back you have a way to read it
503:09 - back you don't have to you know again
503:11 - Ask the user to enter everything or you
503:15 - know Miss out some important things and
503:17 - all those things that is why we actually
503:19 - handle files we write files to store
503:21 - data so that it will be useful in the
503:24 - long term
503:25 - now everything in C plus plus as we know
503:28 - runs on streams so whatever we are doing
503:31 - with the operating system with the
503:34 - hardware everything runs on stream so
503:35 - you're already familiar with one of the
503:37 - stream known as IO stream right input
503:40 - output stream which allows you to access
503:42 - your keyboard and mouse using C plus
503:45 - now for files you have another stream
503:49 - similar to this IO stream which is known
503:51 - as the file stream so what will file
503:54 - stream allow you to do it will allow you
503:56 - to access the hard disk of a computer so
503:59 - that you can write files there so you
504:02 - can write many types of files using file
504:05 - stream which we'll be discussing in a
504:07 - later video but today we will start with
504:10 - something really simple which is nothing
504:12 - but the ASCII files SK files are nothing
504:14 - but what you see every day the dot txt
504:17 - files right so we will be writing ASCII
504:21 - files today using file stream so let's
504:23 - quickly import that hash and include app
504:26 - stream
504:27 - and here in F stream you have a class
504:31 - called f streams right so if stream is a
504:34 - class and there are two other classes so
504:36 - let's quickly talk about them one is
504:38 - known as the ox stream and one is known
504:40 - as the if stream
504:43 - now what is Upstream fstream is nothing
504:46 - but a class it will give you it will
504:48 - allow you to create a file object with
504:51 - which you can read write files right but
504:53 - of stream and if streams are nothing but
504:56 - inherited classes so these are nothing
504:58 - but children of this parent class and
505:01 - the use of them is pretty straight
505:02 - forward over stream is nothing but the
505:04 - output file Stream So you use this
505:06 - whenever you want to write out files and
505:09 - if stream is nothing but the input file
505:11 - stream which you will use when you want
505:13 - to read files even you want to take
505:16 - input from the file right so these are
505:19 - the two classes well these are useful
505:22 - for fasting because in the f f stream
505:25 - what you need to do is you need to
505:26 - provide something known as Flags so let
505:29 - me just write it down here you have
505:31 - something known as flag which you need
505:34 - to provide to the F stream class to read
505:36 - to get a particular functionality of the
505:39 - file so when you want to read in a file
505:41 - you put a particular flag when you want
505:43 - to write out a file you put a particular
505:45 - flag and all those things we'll be
505:47 - talking about that later but today we'll
505:49 - be seeing one of such Flags so basically
505:52 - all these flags start with something
505:53 - like iOS you have two uh colons and then
505:57 - you have a string over here so we'll be
506:00 - talking about this flag today which is
506:02 - IOS app which is nothing but a pending
506:06 - flag and we'll see what append means in
506:08 - a short wheel right so the this is about
506:11 - the classes this is just an overview
506:13 - we'll dig deep into it in the future
506:15 - videos but today we will see how to
506:18 - quickly write a file how to read a file
506:20 - and what are the different ways to read
506:22 - from a file right so let's start with
506:25 - writing out to a file so uh for that
506:28 - what we need to do is create an object
506:30 - of of stream output file Stream So of
506:34 - stream and our object is known going to
506:37 - be file right now to open a file what
506:40 - you can do is you can just say file Dot
506:43 - pin and inside this you can pass in
506:46 - the file's name so I'm just going to do
506:48 - test.txt well this file doesn't exist
506:51 - I'll just explain you in a moment what
506:53 - this does but basically for now you can
506:56 - say that this file doesn't exist on my
506:59 - computer it will be created by this of
507:01 - stream class
507:03 - now you can either use this method the
507:06 - dot open method or what you can do is
507:08 - you can directly call The Constructor so
507:10 - you can just uh you know use this
507:13 - Constructor you can just pass in the
507:15 - name of the file over here and that will
507:18 - do the same job as file.open so this is
507:21 - about opening a file opening is nothing
507:24 - but if if that file exists on your hard
507:27 - drive what will do is it will just load
507:29 - it into the ram so whatever
507:33 - changes you make to that file everything
507:35 - will be affecting the original file in
507:38 - the hard disk and once you close it it
507:40 - will be removed from the ram so that's
507:42 - how of stream works and another
507:45 - important thing is you need to always
507:47 - close the file so once you open a file
507:50 - it's really important that you close the
507:52 - file well this should be in the last
507:55 - technically but I'm just putting this
507:57 - right now so that you guys remember that
508:00 - whenever you need to whenever you open a
508:02 - file you always close the file this is a
508:06 - must right so it won't affect your
508:08 - program much but what it's going to do
508:10 - is it's going to clean up the ram so you
508:12 - don't want your files dangling around
508:14 - the ram right so if you don't if you
508:16 - forget to close this file it will be
508:18 - present in the RAM and it will be
508:21 - removed only when you restart your
508:23 - computer so that is the reason uh it's
508:25 - always better to close a file once you
508:27 - open it and
508:29 - and that's about creating a file or
508:32 - opening a file so if if this file exists
508:34 - if this exists where does this file go
508:37 - it just goes in the same directory as
508:39 - this main file so I have this project
508:42 - saved in my desktop so if I go to my
508:44 - desktop and open that project it's
508:46 - YouTube so here you can see main.cpp and
508:50 - uh well I had created this file before
508:52 - so let me just remove that
508:55 - so here you have main.cpp right so this
508:58 - is the directory where the file is going
509:00 - to come now if I just run this program
509:02 - if I just run this
509:04 - I'll be getting a successful run and if
509:07 - I go there I'll be seeing test dot txt
509:10 - over here so this has been created right
509:12 - now once I run this program and it will
509:14 - be created whenever you run this program
509:15 - basically what happens is even if it
509:18 - exists it will just overwrite every
509:20 - everything in that file so if if I write
509:23 - something over here so if I write
509:24 - something like this is a test
509:27 - save that close that and again run this
509:30 - so let's just run this again
509:34 - go back here open up test and you can
509:37 - see it's blank it's gone right so that
509:40 - is what happens when you open a file I
509:43 - will tell you how to save the previous
509:44 - contents but for now let's just talk
509:46 - about creating a file what happens is
509:48 - even if it exists it will be overwritten
509:51 - and a new file will be created in the
509:53 - same name right and it's just like
509:55 - you're just deleting it and creating it
509:57 - again with the same name and it will be
510:00 - always created in the same directory
510:01 - from where you run the program so since
510:03 - I'm running it from main.cpp so here I
510:06 - am at main.cpp I'm running it from here
510:08 - it's creating in this directory and if
510:11 - you go to bin debug here you will have
510:13 - the exe file right so I've told you how
510:15 - to distribute your programs so this exe
510:18 - file will be created every time you
510:19 - compile your program and if I not double
510:22 - click on this the test.txt will be
510:24 - created in this directory now this is
510:26 - different from this one right so when I
510:29 - run main.cpp it will be created in this
510:31 - directory when I run this debug it will
510:33 - be created in this directory so
510:35 - basically if you don't provide directory
510:37 - what is going to happen is it's just
510:38 - going to create it in the same directory
510:40 - and if you want to create it in some
510:43 - other location so let's say um
510:46 - um let's create it inside this obj so
510:49 - here you have a folder called debug
510:50 - right so I'll create one over here so
510:53 - you'll just need to provide this folders
510:56 - name so all you need to do here is I'll
510:58 - just say obj slash test.txt and if I run
511:02 - this
511:04 - and I'll be getting it over here so obj
511:08 - test.txt right so that's how you create
511:11 - files in different locations and
511:13 - whatever it suggests is that you don't
511:15 - worry much about the locations you just
511:17 - create the files and then move it to
511:19 - wherever you want right that's going to
511:21 - be really easy so that's one way or else
511:23 - you can just create it in the exact
511:25 - location you want and work with them
511:27 - it's up to you but for now this is how
511:30 - you create a file and now let's see how
511:32 - to write to the file where open this in
511:35 - of strip mode right so you can write to
511:37 - this file so how do I write this well
511:40 - how do I write something to the console
511:42 - you do something the like this right so
511:44 - CR this is attached this is how you
511:46 - write to the console and let's say new
511:48 - line and this is on another line This is
511:53 - how you write to the console and if I
511:55 - run this what I will be getting is I
511:57 - will be getting those lines onto my
511:59 - console
512:00 - now the way you write to a file is
512:04 - really simple what you need to do is you
512:06 - just need to remove this C out and place
512:08 - file over here so that's how you write
512:10 - something to the file this operator is
512:13 - all that matters because both of the
512:15 - them are streams right and this is
512:16 - nothing but a stream operator this
512:18 - output stream operator that is why what
512:21 - you can do is you can just use this
512:22 - operator to write something to the file
512:24 - and now I just close this file if I run
512:27 - this I'll be creating a file of the name
512:30 - test.txt inside obj well I did not
512:32 - remove this well basically it will be
512:35 - created inside object you will have
512:37 - these content so if I go here so this is
512:39 - not the file so here you can see it's
512:41 - empty it's inside obj
512:44 - and here you have test which has those
512:47 - contents so this is how you write the
512:49 - file right so this is how simple it is
512:52 - to write to a file you just use the
512:54 - stream operator to write to the file and
512:56 - you must have guessed it reading a file
512:58 - is almost similar so now let's move on
513:01 - to reading files I'll just delete this I
513:03 - don't want my structure of the project
513:05 - to be messed up so just keep this inside
513:08 - the same directory and um now to read
513:12 - from a file what I can do will before
513:15 - going to reading from a file let's talk
513:19 - about appending to file what is
513:20 - appending well if I not change this
513:23 - content will be overwritten right so you
513:25 - just seen that whenever I use of stream
513:27 - our file will be deleted and a new file
513:30 - will be created in its place with the
513:32 - same name right so if I now remove this
513:34 - so let's say I remove this so this is on
513:36 - another line is the only content if I
513:39 - now run this I'll be getting that thing
513:42 - inside this file test.txt which has only
513:46 - one line now how do I add something to
513:49 - this I cannot add something right so if
513:51 - I just remove this and add something
513:52 - else over here so if I just remove this
513:55 - I'll just keep this the word this over
513:58 - here and I run this you you know that
514:01 - it's just going to be overwritten over
514:03 - here everything else would be gone I
514:05 - just have this over here now now how do
514:07 - I tackle this well there is a flag as I
514:10 - told you in the beginning it's the
514:12 - appending fight how to add flag is that
514:15 - you just put a comma in the Constructor
514:18 - or in the open statement so if you are
514:20 - using the
514:21 - function to open it you just do the same
514:23 - thing over here so you just do test.txt
514:25 - put a comma and write whatever I'm going
514:28 - to write here right so here what I'm
514:31 - going to do is add the appending fact so
514:33 - iOS these two colons and then you do app
514:37 - which will enable the file in append
514:41 - mode so what happens is that it is not
514:43 - going to whitewash the file the things
514:45 - are going to remain but whatever I'm
514:47 - going to add now are also going to be
514:50 - written over there now if I do something
514:52 - like
514:53 - this is some new content being added and
514:59 - uh just to differentiate let's skip it
515:01 - on a new line because if you don't keep
515:03 - it on new light just works like shared
515:05 - operator right if we don't keep a new
515:07 - line it's just going to write it beside
515:10 - that so that's the thing so if I just
515:12 - write this save this run this build and
515:15 - run this sorry and now if I go to my
515:19 - test.txt so that that is the file I have
515:22 - been writing to right so if I now open
515:24 - this here you can see that the new
515:26 - content has been added and the old one
515:27 - is being preserved so that is about
515:30 - appending files and now let's talk about
515:32 - reading grammar file
515:34 - well to reading to read from a file it's
515:37 - almost straight forward what you need to
515:39 - do is just remove of stream and replace
515:41 - it to if Stream So if stream is nothing
515:44 - but input file stream and how do you
515:47 - read from the console you do this right
515:49 - so you have variables called string s
515:51 - and you just read from the console like
515:54 - this and to read from a file just
515:57 - replace scene with file and that's going
516:00 - to allow you to read the file and now
516:02 - since I have a string here what is going
516:04 - to happen is it's going to read word by
516:07 - word now if I do c out S I will be
516:10 - getting the first word so what is the
516:12 - first word over here in my file the
516:14 - first word is this right so I'll be
516:16 - getting this over here so by renders
516:18 - I'll be getting this and now if I change
516:21 - this to a character if I do care and now
516:24 - if I run this I'll be getting the First
516:26 - characters which is T right now how do I
516:30 - read the whole file
516:32 - so basically what happens is that
516:33 - whenever you write a file whenever you
516:35 - do file Dot close what's going to happen
516:37 - is that the newly added content after
516:40 - that at the end of the file you have a
516:43 - special character which is not visible
516:44 - known as the end of the file character
516:46 - or the eof so eof is nothing but end of
516:50 - file and this is a character and while
516:53 - this is not reached we can just keep on
516:56 - looping so what we'll do is we'll run a
516:58 - loop and after every time we get a
517:01 - character we'll check whether it is the
517:03 - end of the file character or not once
517:05 - you reach the end of the file character
517:07 - you will just terminate the loop so how
517:09 - do I do that it's really simple
517:12 - I just do well let's just keep a string
517:15 - uh variable on the outside of the loop
517:18 - so that we don't create it every time so
517:20 - here what I'm going to do is while let
517:22 - me just put it on new line while
517:25 - file dot EOS so while file.f while
517:29 - file.of has not been Rich so for that I
517:32 - need to put not so while not file.orf
517:35 - while not file.elf has been reached what
517:37 - I can do is I'll just read the con word
517:41 - inside string and I'll just print out
517:44 - this string on a new line
517:47 - right straight forward now if I don't
517:50 - run this what I'll be getting is I'll be
517:53 - getting all the wet so this this is some
517:55 - new content being added so all these
517:57 - other words in my file so that's how get
518:00 - word by word if I need character by
518:01 - character it's almost the same thing I
518:04 - just change this to KR run this again
518:06 - and I'll be getting every character in
518:10 - my file so this is how you create
518:12 - character by character and if you want
518:14 - to read line by line it's little bit
518:16 - different you don't reach to the end of
518:19 - the file what you will do is you will
518:21 - just read the lines one by one and read
518:23 - till you reach the end of the file so
518:25 - what you do is I'll just show you it's
518:28 - just string s and here what I do is get
518:31 - line from the file inside as and while
518:34 - you can get the line if you don't get
518:36 - the line it's going to return false if
518:38 - you can get the line it's going to
518:40 - return true and I don't need this
518:42 - operator too so I'll just remove that
518:44 - and now if I run this
518:46 - I will be getting the lines so this this
518:49 - is some new content added and then a new
518:51 - line that's because of this one right so
518:54 - here you can see it's just reading line
518:56 - by line so if I want to stop at
518:58 - somewhere so basically what this does is
519:00 - it's it's called a delimiter so what it
519:04 - does is you you have a line right so you
519:06 - have this line and you have this line so
519:08 - how is it stored in the memory you have
519:10 - this special character which you know
519:12 - about right this is the slash n so this
519:14 - is how it's going to be stored so this
519:16 - when this character is reached it will
519:19 - consider this whole sequence as a new
519:20 - line but what if you want to consider
519:23 - this so if I just put this character in
519:25 - between I want to consider this one as
519:27 - an one line and this whole thing as
519:29 - another line so that can also be done
519:32 - using a delimiter so what you do is you
519:34 - just put a delimited like I just put a
519:38 - space over here so that's going to be
519:40 - considered as the delimiter for stopping
519:42 - when uh and considering that whole
519:45 - sequence is a line basically really the
519:48 - default is that slash in because that's
519:50 - what you consider the line right so
519:52 - whatever if if you write something like
519:54 - this and then you move to the next line
519:56 - so when you press enter that slash n is
519:58 - getting added so that is what you
520:00 - consider as a new light but basically if
520:02 - you want to consider something else as a
520:03 - new line this is how you do it and now
520:05 - if you just run this I'll be getting
520:07 - every word that is because after every
520:09 - word I've given a space right so and
520:10 - this is the uh delimiter I've given and
520:13 - if I put something else which is not
520:15 - there so if I put this thing it is not
520:17 - there in my file right so that character
520:19 - is not there anywhere so the whole thing
520:21 - is just going to be considered as a
520:23 - sequence now if I run this
520:26 - here you can see the whole thing has
520:27 - been considered as one single line right
520:30 - so that's how you can read from files
520:33 - you can write to files and
520:36 - it's all about the text file so you can
520:39 - do many operations like you can read uh
520:42 - you can count how many words are there
520:44 - or uh what you can do is you can read
520:47 - the files and see if some data is
520:50 - getting stored over there or some
520:52 - specific word is appearing in that file
520:54 - or not so all these things you can do
520:56 - let's quickly write a small program to
520:58 - do that what you can do is I'll just
521:01 - stream file file Dot close never forget
521:05 - these two things
521:06 - when you open a file you need to close
521:08 - it and let's say we'll just say let's
521:12 - see out
521:13 - enter your name
521:16 - and I'll get a name here so string name
521:22 - C name so this is just like I'm just
521:24 - showing you how you can use the files
521:26 - this is just a simple example and here I
521:30 - will do another thing like see how enter
521:33 - your
521:34 - each
521:36 - and I'll just say in each
521:40 - chain eight
521:41 - and now what I'll do is
521:44 - I have already opened the file right so
521:46 - let me just move this down here I don't
521:48 - want to put this file in the memory
521:51 - right now so once I have all this
521:54 - information entered I'll open the file I
521:57 - will write this information to the file
521:58 - how do I write it I'll just say a name
522:02 - and the name
522:04 - new line it's just like this your
522:07 - operator right um I hope that you're
522:09 - getting the similarity over here and
522:11 - then it's h
522:13 - and the age
522:15 - that's it I'll just do file.close and
522:18 - well I did not give any name to the file
522:20 - so let's say
522:22 - details.txt I'll use this name
522:26 - I'll build and run this I'll be getting
522:28 - audition name it's Tony oh sorry I'll
522:32 - say okay it's too much let's say 12 and
522:35 - enter that
522:37 - I run that program now I go here I have
522:41 - this details.txt I open that and here I
522:44 - have my details so whenever I need this
522:46 - information again I will be having that
522:47 - information and I can just read from
522:49 - this well basically for these kinds of
522:52 - information these are nothing but
522:53 - details right so you have uh name Tony
522:56 - age stuff and something like that so you
522:58 - you can maintain a table like that so
523:00 - will that kind of stuff that this is
523:03 - just to store text Data this is just
523:06 - stored ASCII data there is actually
523:08 - another way another a better way to you
523:11 - know store information like this it's
523:13 - it's nothing like SQL if you are
523:15 - familiar with SQL SQL is nothing but a
523:17 - database language but for now what we
523:21 - can do is we have something called
523:22 - binary files so what you can do is you
523:24 - have to go dot that files where you can
523:27 - write classes now why do we need to
523:30 - write a class well all these things if
523:32 - you want you can just create a class and
523:34 - then you can assign particular variables
523:37 - for that once you have a object of the
523:40 - class you can directly write that object
523:42 - inside the dot that file and you can
523:44 - access them this details thing that's
523:47 - how people do it because it's really
523:50 - easy to access in that way because once
523:53 - you have this one line you need to strip
523:55 - that line you need to you know get that
523:59 - last character and all this thing so
524:00 - that kind of things won't be necessary
524:03 - right so that is the only reason people
524:05 - use dot that files because once you have
524:08 - a class once you read it inside a class
524:10 - you can just do well it's just like you
524:13 - have something like person p and once I
524:16 - read this inside this what I will do is
524:18 - I will just do p dot name I will get the
524:21 - name p dot age I'll get the age and
524:23 - something like that so P dot age will
524:25 - give me the age so that's how people do
524:27 - it and we'll see how to do that hey guys
524:30 - welcome to programming knowledge in this
524:32 - video we'll see how to deal with binary
524:34 - files using C plus plus
524:36 - now binary files are something which are
524:39 - different they are not as simple as
524:41 - ASCII files so uh in the previous video
524:44 - we saw how to deal with ASCII files so
524:47 - basically what are ASCII files ASCII
524:49 - files are nothing but the files which
524:50 - you see right so whatever you can see on
524:53 - your computer using some application or
524:55 - the other so using notepad or using
524:58 - something like this code blocks editor
525:00 - or something if you can see the file if
525:02 - you can read the contents of a file then
525:05 - it's ASCII if you cannot then it's
525:08 - something else and that is binary file
525:10 - right so here if you see this main.cpp I
525:13 - can read this using any notepad or
525:15 - something or they see all these contents
525:17 - right but if I go and open up something
525:19 - so let's say I open up a game so here I
525:22 - have the Watchdogs 2 game open and if I
525:25 - go to this folder
525:27 - I see a lot of files here with extension
525:31 - dot that and Dot fat right so these are
525:33 - all the extensions which are commonly
525:36 - used for binary file so dot bin dot that
525:39 - and all these things so
525:40 - what happens is you cannot read things
525:43 - which are inside this thing right so if
525:45 - I do even if I force to open this using
525:48 - my notepad so if I do something like uh
525:50 - notepad
525:52 - comment.dat so I will be seeing lots of
525:55 - characters but none of them will make
525:57 - any sense to me right so let's just wait
526:01 - for a moment it's going to load
526:03 - everything and here you see there are so
526:05 - many characters which doesn't make any
526:07 - sense so I do have some ASCII characters
526:09 - over here so basically it's a slash
526:11 - three nine something like that so maybe
526:13 - these are some Escape sequences or
526:15 - something but basically the whole file
526:18 - almost 99 of the file is data which you
526:22 - cannot understand so that is why you use
526:26 - binary files you don't use it to you
526:29 - know save your data from from where but
526:31 - basically what happens is this dot for
526:33 - that file or dot bin file whatever they
526:36 - contain objects they do not contain
526:39 - plain data they contain objects so if
526:42 - you remember so if I write something
526:44 - over here so whatever I write here these
526:47 - are all characters right so you know
526:48 - that and now if I write any number over
526:50 - here this is not a number so that's what
526:54 - I wanted to tell here but if I write
526:57 - something over here if I write uh this
527:00 - number inside a DOT txt file it is not
527:03 - stored as a number but it is stored as a
527:06 - character list or you can just call it a
527:08 - string it's just stored as a string it
527:10 - is not a number but I want to store it
527:13 - as a number
527:15 - I want to store it as an actual object
527:17 - how do I do that so that is when binary
527:20 - files come into play right so now in
527:23 - this video we'll just see how to
527:25 - basically read and write a binary file
527:27 - it's a very big topic so we'll be
527:29 - dividing it into videos and in the
527:31 - upcoming video we'll see how to do
527:34 - operations using binary files but in
527:36 - this video we'll just see we'll just
527:38 - understand what binary files are and how
527:42 - to write them how to read from them
527:43 - right
527:44 - so let's start firstly uh reading and
527:48 - writing are almost same you the
527:50 - constructors are almost same right so
527:52 - use over 3 Ministry and all these things
527:54 - the difference comes when you are using
527:57 - the methods and the way you operate the
528:00 - files right so let's see how to do that
528:02 - so of Sim file and I'm using the
528:05 - Constructor to open the file so let's
528:06 - say test dot that so this is basically a
528:10 - common extension for binary file you can
528:11 - use dot pin or something like that and
528:13 - uh yeah one more thing I wanted to
528:15 - mention here is that this extension
528:18 - doesn't matter right so even if you use
528:20 - dot txt it's going to work but
528:22 - basically it is recommended that you use
528:26 - extensions which convey the nature of
528:28 - the file so
528:29 - um what I mean is if I go back here in
528:32 - inside this game folder
528:34 - um
528:35 - yeah let's go to this folder you see
528:37 - lots of these dll files right so if you
528:40 - see this dll files you uh see this gear
528:43 - kind of Icon right so that is basically
528:46 - because the Windows operating system
528:49 - knows that this is a dll file it knows
528:52 - how to interpret that so for dll file it
528:54 - has assigned this kind of Icon so that's
528:56 - why it's showing you for images it has
528:58 - it must have assigned some kind of Icon
529:00 - and for C plus plus it must have
529:02 - assigned some kind of Icon and so on
529:05 - right so basically this
529:08 - file icons are dependent on the type of
529:12 - extension you give it it's not dependent
529:14 - on the data right so that the extension
529:17 - is for the operating system to identify
529:19 - the kind of file and to give it a
529:21 - suitable icon but even if you mess up
529:23 - the extensions it doesn't really matter
529:25 - right because the way the computer is
529:28 - going to store the data is controlled by
529:30 - the data itself and not by the extension
529:33 - so even if you put dot THD for a binary
529:35 - file or dot bin for an ASCII file it
529:39 - doesn't really matter you can still uh
529:41 - you know operate on those two files in
529:43 - their native way right so we'll see that
529:47 - so for now let's go with the recommended
529:49 - way so test dot bin and here if you just
529:53 - leave it like this it's going to be
529:55 - interpreted as an ASCII file as I told
529:57 - you extension doesn't matter but here
530:00 - you need to put it
530:02 - nice I I use binary to interpret this
530:05 - file as a binary file right so this will
530:08 - open this file in binary mode and of
530:11 - course uh it's an output stream mode so
530:13 - I can write to this file and another
530:15 - thing I need to close this so all these
530:18 - things are the same thing which I
530:20 - mentioned in the previous video you open
530:22 - a file you close the file and in between
530:24 - whatever you do that will depend on
530:27 - different file types and ASCII files we
530:30 - saw how to write we just do this the
530:33 - most simplest way to write to ask a file
530:34 - you just do this you write all your data
530:37 - here you just put this operator what it
530:40 - will do is it will direct everything
530:41 - inside this file and it won't store it
530:44 - as a specific object it will store
530:46 - everything as a string so where if I do
530:48 - this this will go and set as a string
530:51 - right now to write an integer let's say
530:54 - we create an integer in P equal to 1023
530:58 - so this is our integer and I want to
531:00 - write this integer to this test dot pin
531:03 - how do I write this well the way you
531:06 - write it is file dot write so this is a
531:09 - method and here you have two parameters
531:12 - so one is conch CAD type star on this
531:15 - thing and another thing is the stream
531:17 - size so let's see what they are right so
531:20 - basically what happens is in binary
531:23 - files you convert your data into Strings
531:26 - of bytes and the way you do that is you
531:29 - go to the address so if you remember the
531:31 - address is given by and right so this
531:33 - Ampersand symbol will give you the
531:35 - address so and P is my address of P I'll
531:38 - take this address convert it into a
531:42 - character string right so string you can
531:46 - this string is a class but character is
531:50 - a data type so basically what I will do
531:52 - is I'll this is a character Ari which is
531:56 - nothing but the string so basically this
531:58 - is equal to a string right so this is
532:01 - almost equal to a string but string has
532:03 - some additional functionalities it is a
532:04 - class in C plus plus you don't have a
532:07 - string data type in single distance but
532:09 - anyway you just convert this into a
532:12 - character array because it's the
532:14 - primitive data type and you take the
532:17 - pointer of the first element and you
532:20 - give it to the writing object so this
532:22 - this thing it has file pointers inside
532:25 - that and we'll go and see uh we'll
532:28 - explore file pointers in more depth in
532:31 - the upcoming video but for this video
532:33 - you have file pointers which will take
532:36 - the pointer of this first object and in
532:40 - the second thing where in the second
532:41 - argument where you mentioned the stream
532:44 - size so if you remember you had two
532:46 - arguments here right the first one was
532:47 - this thing the second one is basically
532:50 - the stream size which will tell the
532:53 - pointers how many bytes of data to take
532:55 - so here you have a memory right so if I
532:58 - just open up my paint
533:00 - and I have this whole memory so this is
533:03 - all my memory I have in my computer so
533:06 - let's say 16 GB or 32GB whatever it is I
533:09 - have I specify the first so let's say
533:13 - the integer is stored in this 4 bits I
533:15 - know that integer size is four bits
533:17 - let's let's just consider a realistic
533:19 - scenario so I have four bytes over here
533:22 - what I will do is
533:24 - if I do and P sorry
533:27 - What's Happening Here undo so here I
533:31 - have this and P
533:33 - which is this thing
533:35 - which will give me the address of the
533:38 - first point right so this is what the
533:40 - and operator does it will give me the
533:42 - address in hexadecimal format I'll take
533:45 - that give it to the file pointer and say
533:47 - that I from this address read four bytes
533:50 - of data so what we'll do it will take
533:53 - this it will read four bytes of data
533:55 - from here and it will store that data
533:58 - inside the file so that's how it works
534:00 - so if I if I do 10 bytes it will do the
534:02 - four bytes and whatever is remaining it
534:04 - will read from that too and try to store
534:06 - it and it you know it messes up the data
534:09 - right so
534:11 - that's how you store files here
534:13 - you read four bytes you read the size of
534:17 - the object you take the you take an
534:21 - instance of the object read the size and
534:24 - then save this memory thing inside a
534:28 - file so that's how binary files work you
534:30 - directly don't write data you go to the
534:32 - address you take four bytes or whatever
534:34 - the size of the object is you take those
534:37 - things convert it to bytes and then
534:39 - write it store it right so that's what
534:41 - we're going to do here so here what you
534:44 - need to do is first of all get the
534:46 - address so which is given by Ampersand P
534:49 - which will give you the address
534:51 - convert it to
534:53 - a character array
535:03 - and here I need to specify the number of
535:06 - bytes so it's just 4 I can just write 4
535:08 - or if you are not sure just use the size
535:11 - of operator right so size of P
535:14 - right
535:16 - this will write this thing this one zero
535:19 - two three as a number inside my file
535:22 - known as test dot pin so now let's let
535:26 - me just run this thing I did not get any
535:29 - errors and let me just open up my
535:33 - folder and here you see test.pin and if
535:36 - I now go and look at the properties it
535:39 - is exactly four bytes right so four
535:42 - bytes is because one integer is four
535:44 - bits you know that now if I try to open
535:46 - this if I try to open this using some
535:49 - notepad or something or let's just use
535:51 - notepad here notepad test dot bin enter
535:55 - so here you see some weird character
535:58 - right so this is some character but it's
536:00 - not one zero what did I write 1023 it's
536:04 - not one zero two three right
536:06 - so that is how you write binary files
536:08 - they are files they are written there
536:11 - but you cannot see them they are written
536:14 - as objects if you want to write two
536:17 - numbers that's the same thing if you
536:18 - just write this and I have another
536:21 - integer Q which is one zero two
536:24 - uh let's just keep it a thousand I do
536:27 - the same thing again
536:29 - right
536:32 - c b and instead of p i just write Q
536:38 - right run this
536:41 - it's written I go back here
536:44 - okay why am I closing this again again
536:47 - just open and keep this right so here I
536:50 - have test dot bin go and look at the
536:52 - properties it is 8 bytes because two
536:54 - integers right
536:56 - so that's how you write binary files and
536:59 - for now we are not going to write
537:00 - multiple objects because uh it's a
537:03 - little bit different how you iterate our
537:05 - objects so we'll see that in the next
537:07 - video but for now we'll just stick with
537:09 - one object right so you just write one
537:11 - object run this and it again as you know
537:15 - I'm not using any appending right so I'm
537:17 - not using iOS append so it will just
537:19 - write it from the beginning so if I go
537:22 - and look at it over here it's four bytes
537:26 - no the other thing is
537:29 - um reading from this binary file how do
537:31 - I read this it's really similar just
537:34 - replace this with if stream and
537:38 - take out this definition let's say in
537:41 - let's just keep it in pay for now this
537:44 - is read and these things remain the same
537:46 - so what does this say you read something
537:49 - to this address it is not from this
537:52 - address this time it is to this address
537:54 - and how much should I read I should read
537:56 - this much bytes right so I know it's
538:00 - kind of confusing but uh you need to get
538:02 - used to it while dealing with binary
538:04 - files so basically everything runs on
538:06 - sizes and byte strings so here what
538:09 - you're saying you are giving the address
538:11 - and you are saying read to this address
538:13 - and how much should I read I should read
538:15 - these many bytes right
538:17 - and after that you can just close the
538:19 - file and you can even see what is the
538:21 - thing over here so if I do um you know
538:24 - the value in B is
538:28 - and I just show p and if I do this in
538:31 - the beginning I won't say anything
538:33 - so if I just copy this and ask as soon
538:37 - as I create a variable if I do this oh
538:39 - I'll just do value
538:41 - in P before reading this and value in P
538:47 - after reading s
538:51 - right so if I do this and if I run this
538:54 - program now if I run this
538:56 - so here if you see the value in P before
538:59 - reading is this big number which is
539:02 - completely
539:03 - um you know it is garbage right so it it
539:06 - doesn't have any sense but the value in
539:08 - P after reading is one zero two three
539:10 - which we stored in the file before right
539:12 - so why this happened this is because the
539:14 - you know if you take those four bytes
539:17 - before reading in this location and if
539:19 - you convert it to an integer this is the
539:20 - number you will get so it doesn't have
539:22 - any meaning it's just a number right so
539:24 - yeah that that's all it is and here this
539:28 - one zero two three is after taking the
539:31 - bytes from the file converting it to
539:33 - integer and giving it to this location
539:35 - so that's about reading from binary
539:38 - files and the other figures I mentioned
539:40 - about the extensions right so if I do
539:43 - something like text Dot tht and I put
539:47 - this iOS binary flag and if I try to
539:50 - read something from that so I'll just
539:52 - comment this thing out so I did comment
539:54 - this
539:55 - right
539:58 - and here I just commented this section
540:00 - and if I open a file of that name
540:04 - test.txt and I write something so in P
540:07 - equal to 10 and I write file dot right
540:16 - cash star and P
540:21 - size of P
540:23 - and I close the file
540:27 - under run this program
540:30 - right it ran without any failures and if
540:33 - I go here I will have a test.txt file so
540:36 - if you look at this this is a txt file
540:38 - so it can be opened with notepad but if
540:42 - I try to open this thing using a notepad
540:45 - right so if I try to open this thing
540:47 - using a notepad I'll again see uh well
540:51 - there is a character here which you
540:53 - cannot see but so basically what happens
540:55 - is the computer will try to interpret
540:57 - the data every time you open it but
540:59 - basically sometimes uh you know the
541:01 - character which it interprets is
541:03 - something which you can see and
541:04 - sometimes there are some characters
541:06 - which you cannot see so this is one of
541:08 - the examples where you cannot see the
541:10 - character but there is a character here
541:12 - which has been interpreted right so that
541:14 - is what happens when you you know mess
541:17 - up the file type you can see that the
541:19 - extension here is of a notepad right so
541:21 - if I use dot kxt I'll get this extension
541:23 - but if I use dot bin it doesn't know so
541:25 - it just gives me this kind of extension
541:27 - but if you see here the icon which has
541:31 - been generated is of a notepad right it
541:35 - dot txt file a text file but if I open
541:38 - it it's actually a binary file I cannot
541:40 - see anything over here so
541:42 - that's why I told the extension the file
541:45 - extension doesn't really matter you can
541:47 - you know change the file extension and
541:49 - it's the same thing while reading too so
541:51 - even if I put dot txt over here and I
541:54 - tried to read this as a DOT txt file
541:57 - that will also work so if I just
542:00 - copy the selection uncomment this
542:03 - and I try to run this
542:06 - so here if you see uh the value of Peep
542:09 - before reading is this number which is
542:10 - garbage and the value of P after reading
542:13 - is 10 which I stored just now right so
542:17 - that is
542:18 - the reason for using dot bin dot that or
542:22 - all these things that the only reason is
542:24 - that it is for you that for the
542:26 - operating system to show you the correct
542:29 - file icon right so if you mess up the
542:31 - extension don't worry it will work as
542:35 - long as this thing is there because if
542:36 - you if you take out this it's not going
542:39 - to interpret anything so this will now
542:40 - be interpreted as a ASCII file and if
542:43 - you try reading and writing from this
542:45 - file it will fail because everything is
542:47 - in binary format right so that's about
542:51 - simple reading and writing of binary
542:53 - files in the next video we'll definitely
542:55 - see how to uh do operations on binary
542:58 - files but basically it is not restricted
543:00 - to integers only right so I just wanted
543:02 - to show that so if you just create a
543:05 - class let's just create a quick class
543:07 - now student right and we'll just put
543:11 - everything in public section you have a
543:14 - name sorry age you have a name
543:18 - and let's say you have a roll number
543:22 - and here you create
543:24 - um a Constructor of student
543:27 - and you just put um age name role and uh
543:33 - well because these two variables are
543:35 - same I need to use the this pointer I'm
543:38 - sure you remember that
543:40 - and this this dot name equal to name
543:44 - and that's not true number well I need
543:47 - not use that but still it just looks
543:49 - nice right so it is uniform over here
543:53 - so that does it now if I want to write
543:57 - this thing to a student file what I will
543:59 - do here is I will create an of stream
544:04 - with the name of the file as student
544:08 - let's say student data.tat or dot pin
544:11 - let's go dot bin we already saw that
544:13 - right and here I need to put the flag as
544:16 - binary so iOS binary
544:20 - and after that is done
544:22 - now I need to create a new student so
544:25 - student s and I can just pass in the age
544:28 - rule number and all these things so it's
544:30 - name uh something and roll number which
544:34 - is
544:35 - one let's keep it one and uh to write
544:39 - this thing to this file I just do the
544:41 - same thing which I did before so file
544:43 - that right what do we need to do
544:46 - let us
544:47 - care star
544:50 - it just becomes bi-hearted right so if
544:52 - you do this couple of times you'll just
544:54 - type it out without much thinking but
544:56 - basically the meaning is the thing which
544:58 - I explained before we are just
545:00 - converting the address into like
545:02 - character array so character and S size
545:06 - of s
545:07 - four characters or a b c d i just close
545:11 - this file Dot close
545:13 - and now I run this thing I get an error
545:16 - what does it say expected this before
545:19 - okay I wrote this as python sorry I need
545:23 - to specify that data type over here
545:29 - right so okay this is good run this
545:34 - again get which is
545:38 - these are considered as pointers why is
545:41 - that okay let's just do that oh yeah
545:44 - that's because this is a pointer right
545:45 - so I totally sorry about this I I I've
545:48 - been coding in other languages lately so
545:50 - I completely lost the touch of three
545:52 - people it's sorry
545:54 - well I'm sure you won't run into these
545:56 - kinds of Errors right so yeah very well
545:59 - it worked here and if you go to that
546:03 - location where you stored the files
546:07 - so here you have student data.pin so
546:10 - here you have 32 bytes basically you
546:13 - just store data like that and now if you
546:16 - try to open this thing so if you now try
546:18 - to open this thing you won't see
546:20 - anything I'm just saying that again and
546:22 - again but basically uh this is to
546:26 - make you familiar with binary file so
546:29 - that you don't you know run into an
546:31 - issue when you don't see anything over
546:32 - there so this is what you see and ABCD
546:35 - is a string that's why you're saying
546:36 - string but other things are all numbers
546:39 - and pipes that's why you are not saying
546:42 - anything you're just seeing this weird
546:43 - characters over here right so
546:46 - that's how you write to binary file you
546:50 - write data into binary file to read it
546:52 - from a binary file you just you know
546:54 - it's the same thing as you did with the
546:56 - integer just that this is nothing but
546:58 - not a common object but it's something
547:00 - which is made by you it's a use a
547:03 - different object so you do that let us
547:05 - find this is if stream let's do that and
547:11 - you can always show these things right
547:14 - so see out
547:15 - s dot name
547:19 - a new line
547:22 - H dot h
547:24 - new line
547:27 - s dot roll number
547:29 - right run this
547:32 - I'll get another error what does it say
547:35 - okay that's because I don't have this
547:38 - kind of thing I don't have this concept
547:40 - I'll just Define an empty Constructor
547:42 - then
547:43 - right you can have as many Constructors
547:46 - as you want just just overloading right
547:48 - so I'm sure you remember that so do that
547:52 - run this and here you have
547:56 - um there are some errors over here but
547:58 - basically has a string is a class that's
548:01 - why I had to use this is not a you know
548:04 - it's not a data type as such right
548:07 - string is something which has been made
548:10 - on top of characters so you need to use
548:13 - characters the string is actually a
548:16 - class we'll I thought we'll talk about
548:18 - this later but after seeing this I think
548:20 - that we need to discuss about the string
548:22 - class uh very soon but basically string
548:25 - is a class it's not a data type so it
548:28 - doesn't work like other data types
548:30 - that's why you're seeing this thing but
548:31 - basically if you use characters if you
548:34 - use character arrays or something like
548:36 - that that will work right so instead of
548:39 - name I'll just do something like cash
548:41 - Star right and here cash star and again
548:46 - you need to use you know string Methods
548:48 - like you have a string class here hash
548:51 - include uh C string
548:55 - so you have this class you need to use
548:57 - this class right to uh copy name and all
549:01 - these things so strings are something
549:02 - it's a whole different topic we'll talk
549:04 - about that it's not as simple as just
549:07 - defining it as a string but basically
549:10 - you have a whole set of operations on
549:13 - the string but if you do that this is
549:15 - how we store data inside a file so
549:17 - that's why you got this 32 bytes and all
549:19 - those things I thought I did not you
549:22 - know uh tell that right now but yeah in
549:25 - the next video we'll discuss about that
549:27 - and also we'll discuss about how to
549:30 - read how to search how to write multiple
549:34 - records and do all these things how to
549:37 - delete things and all these things right
549:39 - so binary files not about uh
549:43 - direct ASCII value writing it's not
549:45 - really simple as just writing something
549:48 - as we did in the previous video it deals
549:51 - with pointers it deals with memory
549:53 - addresses and all these things so if
549:55 - you're not comfortable watch this video
549:56 - you know a couple of times and then try
549:58 - this on your own so that you get
550:00 - familiar with this statement so this
550:03 - statement you need to understand because
550:04 - in the next video when we talk about the
550:07 - file pointers these State this thing is
550:10 - going to be really really important so
550:13 - make sure that you understand this
550:14 - before going on to the next video so hey
550:17 - guys welcome to programming knowledge in
550:20 - this video we will be dealing with a
550:21 - credit operations in C plus so if you
550:25 - are a web developer you might be already
550:26 - familiar with this term current which
550:29 - just stands for create read update until
550:32 - it so these are the operations you do on
550:35 - a database right so now what does this
550:39 - have to do what this database have to do
550:41 - with binary files well
550:43 - if you see in the last video I just
550:47 - talked about how we use binary files
550:49 - right so binary files we write objects
550:52 - inside binary files and what's a
550:54 - database database is nothing but a
550:56 - collection of Records right so how does
550:58 - those two relate so let's say I have a
551:00 - database of employees so they might have
551:02 - a ID name and what else they might have
551:06 - an address phone number etc etc so it's
551:09 - all this information and then you just
551:10 - store it as a tables two three four and
551:14 - so on so ID number one all the
551:16 - information two all the information
551:17 - three all the information all the
551:19 - information and so on so this is what a
551:22 - database would look like and what we're
551:24 - doing in binary files we're doing the
551:26 - same thing we're just making new
551:29 - employees so employee one is basically
551:32 - all this information employee two is all
551:34 - this information and employee towards an
551:36 - object and employs three is an object
551:38 - which has all this information and then
551:40 - we are just writing this object so
551:42 - basically you can think of binary files
551:44 - as nothing but a database right so
551:48 - if we are making a database it should be
551:50 - able to do all this operation it should
551:52 - be able to do credit operations which is
551:54 - nothing but these things create read
551:56 - update and delete and I will update and
552:00 - delete will also include searching a
552:02 - record right so how will you update
552:04 - without searching right so these
552:07 - operations are something which are
552:09 - really important if you are maintaining
552:11 - a database so database you can just if
552:13 - not a very technical database you can
552:16 - just think of database as just a
552:18 - collection of Records that's it right so
552:21 - to do that in this video we'll see how
552:23 - to do these operations on a database
552:27 - and before that we need to know how a
552:29 - binary file stores data right we already
552:32 - know that binary files just stores uh
552:35 - everything in binary format but we need
552:37 - to know how it actually stores right so
552:40 - let's say I have these four records the
552:42 - same thing and it it is not stored in
552:44 - such a neat table format what it does is
552:47 - it just dumps all the data in one single
552:49 - line so you just get one all the data to
552:52 - all the data three all the data for all
552:54 - the return whatever you if you have
552:56 - hundred data you just get all the 100
552:59 - things in one single line so that's how
553:02 - binary files work and now uh let's say I
553:05 - want to do operations on this third
553:07 - record so I want to update or delete or
553:10 - something or I want to insert a new
553:12 - record in between these two records or
553:13 - something like that if I want to do any
553:15 - operation of that kind I need to First
553:17 - find this record so how am I going to
553:19 - find I need to move to this record right
553:21 - so for that you have something known as
553:24 - file pointers so
553:27 - just write it down here you have five
553:30 - pointers which are getting put so get
553:33 - and put a two pointers well both are
553:36 - exactly the same thing so if you talk
553:37 - about a file pointer it's just like
553:39 - cursor so if you think about this whole
553:41 - thing as a file in the memory this
553:44 - cursor which is blinking over here that
553:46 - is the file pointer and getting put are
553:49 - exactly the same thing like the task may
553:52 - be different but basically the pointer
553:54 - is the same so when you use a get
553:56 - pointer you actually use it when you
553:58 - want to read data and put this when you
554:01 - want to write data and if you are doing
554:03 - both it doesn't really matter whether
554:05 - you use get output it's just for
554:07 - convention right so get uh is used with
554:11 - um
554:12 - if stream why because I have stream just
554:17 - opens a file in read mode and put works
554:20 - with of stream because it opens a file
554:24 - in right mode so these are the two
554:26 - pointers and you have functions to use
554:29 - these pointers right right so you have
554:31 - the stealth function and then a seek
554:34 - function because we just need these two
554:37 - information so we're never working with
554:39 - a cursor what do we need I just want to
554:41 - know where this cluster is linking and I
554:43 - want to move this cursor to some place
554:45 - right so as these two functions are
554:47 - there the variation so tell G is for the
554:49 - get pointer tell P is for the put
554:51 - monitor similarly you have c g is for
554:53 - the get pointer and seek piece for the
554:55 - put pointer and what tell does it will
554:58 - just tell you where the cursoriation C
555:00 - will move the cursor for you so you can
555:02 - just pass in uh like 10 bytes and remove
555:05 - the cursor 10 bytes right so that is all
555:10 - about the file pointers and we'll be
555:12 - using this in code which will
555:15 - be more clarifying for you because
555:18 - these things are something which you
555:20 - need to understand when you are working
555:22 - with binary file so that is why in the
555:25 - previous video told that we need to
555:26 - understand how that read and write
555:28 - statement works the chain text you
555:30 - remember that right so stare star
555:32 - address of object and then size of
555:34 - object
555:36 - now these things are basically
555:39 - interacting with these functions inside
555:41 - right so this this whole thing tells
555:44 - that I need to write this whole array of
555:46 - bytes and this is the crucial thing
555:50 - which tells how many bytes to write so
555:52 - if you say uh if if let's say my file is
555:55 - over here and I use write method what it
555:58 - will do is it will just write down and
556:00 - then it will seek the pointer to let's
556:04 - say 10 bytes forward or whatever the
556:06 - size of the object is so I I am here I
556:09 - write a new object I write everything
556:10 - and then get the cursor and put it over
556:12 - here for the next record to write so
556:15 - that's our file pointers work and we'll
556:17 - see how to use that in a short way so
556:20 - well we have already run create and read
556:22 - so we'll do update and delete in this
556:26 - video and uh just for a boost I just
556:30 - have created a very simple class so I
556:33 - have this employee plus which all the
556:35 - attributes are uh public so I have ID
556:38 - name address and then I have a simple
556:42 - Constructor which does nothing so this
556:44 - is just to initialize an object and this
556:46 - is one useful Constructor to actually
556:49 - create an object without uh assigning
556:51 - one by one right and I have this info
556:54 - method so that I can just see what this
556:56 - object is so what are these things so it
556:58 - will be useful while reading the object
557:00 - right so this is the class and to write
557:03 - this class as I told you in the previous
557:06 - video we could not use string right
557:07 - because when we use string we could not
557:09 - write properly it's because string is a
557:12 - class it's not a data type so what you
557:14 - need to do here is I'll tell you what to
557:17 - do here but we'll talk about strings in
557:19 - a later video but for now the fix is
557:21 - that
557:22 - the first of all let's talk about the
557:24 - reason the reason that that uh writing
557:27 - produced some garbage inside the
557:29 - particular file is because string is a
557:32 - class and you cannot write objects
557:34 - inside objects so what you need to do is
557:36 - you need to change this to something
557:38 - which is primitive so you have primitive
557:41 - data types as uh flow double and you
557:45 - have integer
557:47 - [Music]
557:51 - primitive data types right so you can
557:53 - write all these things inside the binary
557:56 - file but you cannot write a class so
557:58 - well you can write a class but the class
558:00 - should consist of primitive data types
558:02 - it should not consist of some other
558:04 - classes right that is not allowed in CPS
558:07 - plus so to do that what you do here is
558:10 - you change this to primitive data types
558:12 - now so what is a string string is
558:15 - nothing but a collection of character so
558:17 - what you can tell is string is nothing
558:18 - but a character array so let's say name
558:21 - is of 30 characters long so this is just
558:24 - like they just name it and if you know
558:26 - SQL this is the same thing as doing
558:29 - something like where care right so you
558:32 - have something called Bearcat which does
558:33 - the same thing you just uh specify the
558:36 - number of uh characters you give and
558:38 - this will create a character field for
558:40 - you this is basically SQL so don't if
558:43 - you don't know about this don't worry
558:45 - but basically the same thing you are
558:47 - going to do over here too the only
558:49 - reason we use string is because when the
558:52 - string class makes it easy to handle uh
558:54 - these operations so I'll just talk about
558:57 - what it is but basically string class
558:59 - will allow you to work with strings
559:01 - really really easily right so that's one
559:04 - thing but for writing you need primitive
559:07 - data type so we're going to use arrays
559:10 - right so address of 50 characters and
559:13 - now I can just say string name and
559:15 - string address and now to actually copy
559:19 - the string inside the character array
559:21 - what I'm going to do here is I am going
559:23 - to include one another the header file
559:25 - which is known as C string
559:28 - so what this has is this has lots of
559:32 - functions dealing with the string
559:34 - operations right which are not included
559:38 - directly so if if you talk about this so
559:42 - if I want to copy this name inside this
559:44 - uh particular array what I have to do is
559:48 - I need to run a loop get one one
559:50 - character and paste one one inside that
559:51 - so that is not required you could just
559:53 - use a function called strcpy which will
559:56 - just copy a string right so strcpy this
560:00 - takes the source sorry this destination
560:02 - which is name and then the source and
560:04 - Source here is a string it's what
560:06 - requires is a const carry it const
560:09 - Caster so you can just cache style is
560:11 - nothing but you can just think of it as
560:13 - an array right so because see when we
560:16 - talked about this when we are talking
560:18 - about the arrays in the in our previous
560:21 - videos which we talked about terrorists
560:22 - we saw that if we declare a pointer to
560:24 - an array it will point to the first
560:26 - element so if you are declaring a
560:28 - pointer it's as good as you are just
560:30 - saying that this is the first element of
560:32 - an array so that's why generally people
560:35 - used pointers to specify the arrays
560:38 - whenever you are dealing with the
560:41 - variable sized arrays because if we
560:43 - don't know the length of the array it's
560:45 - very easy to just show that this is the
560:47 - first element and then go these many
560:48 - buds to get all the limits so that
560:50 - that's how we work generally right so
560:53 - that is one thing and here to get the
560:54 - character representation what we do is
560:57 - you have function called dot C
560:59 - underscore Str what this will do is it
561:02 - will give the C string representation of
561:04 - this string so a literally string is a
561:07 - class so this is an object and there is
561:09 - a method inside the string class which
561:11 - is C underscore Str which will give you
561:13 - an array of these characters so that's
561:15 - how you copy a name uh sorry copy a
561:18 - string in uh primitive data types right
561:21 - so same thing goes with address so
561:23 - address and then you have addl dot C
561:25 - underscore string
561:28 - so that will copy the things and that
561:30 - should do it so now you have
561:32 - successfully changed this thing and you
561:35 - can just try it out so employee a
561:39 - and uh let's say id1 name
561:43 - Tony
561:45 - address NYC
561:48 - and you can go with
561:51 - well um well let's go Captain America
561:54 - now so Steep and then let's see Brooklyn
562:03 - so you have these two objects created
562:06 - and let's just make sure that everything
562:08 - is working fine so yeah there's no
562:10 - address so everything works fine
562:12 - now let's go with the creation part so
562:16 - let's quickly create a function for that
562:18 - avoid create what you need you need an
562:20 - employee object create is nothing but
562:22 - right so it's just create all right this
562:25 - is just call create because we create a
562:27 - new record right so basically it's just
562:29 - you can think of it as writing something
562:31 - inside a file so employee OBC
562:34 - what you do you just open a file in ofc
562:37 - mode do it and let's say details for
562:42 - that
562:44 - how do you open it you open it in binary
562:46 - mode
562:49 - and here what you do after right
562:52 - the same tags the most important one
562:55 - garage star and OBG
562:58 - size of OBG
563:01 - and then you close the file
563:03 - so that should write an object okay so
563:06 - now you can just say create
563:11 - e Grade B
563:14 - and if I just run this
563:17 - I have created this file and you can
563:19 - just go and check in your directory you
563:21 - will have this details.tag file all
563:23 - right now
563:25 - moving on let's go to the read operation
563:27 - well these are the things you already
563:28 - know so it's just going to be quick
563:31 - right so yeah just don't take anything
563:34 - because you're going to read the entire
563:36 - document so just say if stream
563:39 - file which is details.tag
563:44 - iOS binary
563:48 - and you need an object of employee so
563:51 - employee obj and then while you can read
563:56 - so after three
563:59 - cash style and OBG size of OBG
564:05 - you just say obj.info so this is the
564:07 - reason I had this method defined over
564:09 - here right so yeah
564:11 - appetite what to do is just close the
564:14 - file
564:17 - foreign
564:19 - [Music]
564:23 - thing I forgot to do is I had to create
564:26 - it in append mode right because once I
564:29 - close the file and once I again open it
564:31 - without the IOS app and it's just going
564:33 - to replace things so I forgot about that
564:35 - so we need to add the IOS app print file
564:37 - because you don't want to just keep on
564:39 - creating new ones and just keep deleting
564:41 - the old ones right so that is one thing
564:43 - so just create these two things it just
564:45 - run again
564:47 - uh well now it would have appended there
564:50 - so I'll just delete this and run this
564:52 - again
564:55 - run it I have created two new employees
564:58 - and then just comment these things out
565:00 - now
565:02 - thank you just do read
565:05 - run this I'll be getting those two
565:07 - things so
565:09 - id1 name Tony address is this id2 and
565:12 - all the information right so we did CR
565:16 - now U and T are remaining so U is
565:19 - basically what you do is you need to
565:22 - update and how do you update you first
565:25 - need to search for something so first of
565:28 - all uh we need to
565:30 - uh make sure that we have a unique
565:33 - identifier for every object so this if
565:36 - you are talking in the language of
565:38 - database this is known as a primary key
565:41 - right so you have a primary key which is
565:44 - unique to identify an object because if
565:46 - you take in this case you have just name
565:48 - it addressed this right so name can be
565:50 - same addresses can be same but the iot
565:52 - cannot be same ID is unique so here the
565:56 - primary key for our class is ID and
565:59 - that's how you choose a primary key
566:01 - primary key should be unique and that
566:03 - goes same with databases and also this
566:06 - one right but here we're just hard
566:10 - coding that ID is what we want right so
566:13 - in update I'm just going to take in the
566:15 - ID which I want to search and then what
566:17 - I want to update so
566:19 - you can update a whole object that's
566:21 - also possible but since uh well I did
566:24 - not try to copy Constructor over here
566:26 - let's just keep it simple the concept
566:28 - Remains the Same right the concept
566:30 - remains exactly the same the only
566:32 - difference being that you you just
566:35 - update a whole object instead of
566:37 - updating a part of the object I'm just
566:40 - going to update the address of the
566:41 - object so I just says string HDR
566:44 - right and here
566:46 - now what I'm going to do here is I want
566:49 - to open the file and read and write mode
566:51 - simultaneously why
566:53 - because once I get to an object I need
566:56 - to first of all I need to search for a
566:58 - particular object which involves reading
567:00 - the object right whichever let's say I
567:03 - have these two records first of all I
567:05 - need to search whether This Record is
567:07 - what I want so let's say I want to
567:08 - update this uh employee 2 and I want to
567:12 - update this address so first of all I
567:14 - need to read through the entire records
567:17 - I have I want to first of all find out
567:19 - whether this thing exists or not and
567:22 - then if this exists what I will do is
567:24 - I'll just go back and record and then
567:26 - overwrite it so that's how it works you
567:29 - know a b c t e five records in a line as
567:32 - I told you what I'll do is first read a
567:35 - check it it's not the thing I want to
567:37 - update right check B it's not the thing
567:40 - I want to update let's say I want to
567:41 - update C I'll read C and check it it's
567:45 - the thing I want update I'll go back
567:48 - update see with the new record so C
567:51 - becomes F and then break out of the loop
567:53 - or even go ahead so it it basically
567:56 - depends on the operation you want to do
567:57 - so let's say I want to update all the
568:00 - addresses of people whose name start
568:02 - with s something like that so that that
568:04 - kind of thing you don't break out of the
568:06 - loop but if you just want to update a
568:08 - unique thing you just do that you just
568:10 - break out of the loop because it's not
568:12 - worth going forward right so
568:15 - that was a quick explanation of how
568:17 - update works so first of all we need a
568:19 - Boolean variable
568:21 - which is false in the beginning right
568:24 - and I will just return this Boolean
568:27 - billable so that we know whether an
568:29 - update Works successfully or not
568:31 - and uh what else you need you need to
568:33 - open a file in both read and write mode
568:36 - simultaneously because as I told you you
568:39 - need to search and then you need to
568:40 - write
568:41 - so this is Extreme details dot that
568:46 - and here you need to pass a file so I
568:48 - use in iOS out and also iOS
568:53 - binary
568:55 - right so I opened this file in both read
568:57 - and write mode and then in the binary
569:00 - flag right and uh other thing is I need
569:04 - a temporary employee object so that I
569:07 - could just put it in the memory and read
569:10 - the information inside the class right
569:13 - now what I do I just do the same thing
569:15 - as reading a file so after tweet
569:21 - [Music]
569:24 - size of OPG
569:27 - now inside this what we're going to do
569:30 - here is first of all I need to search
569:32 - right so this is a searching part so if
569:36 - the ID which I'm searching for well if
569:40 - the object which we read
569:42 - with the ID of that object whether it's
569:45 - equal to the ID which you are searching
569:47 - for or not that's what we need to check
569:48 - and that is searching so if it is equal
569:51 - we perform the operation else we don't
569:53 - we just move on right so let's say it it
569:56 - is equal
569:57 - we got the object what we need to do
569:59 - first of all we need to say that we
570:01 - found the object so it is true and then
570:04 - what we do we just update whatever we
570:06 - want to update so here in this case I'm
570:08 - just updating the address so strc p y
570:12 - string copy
570:14 - obj address and then the new address I
570:18 - just specified so HDD r dot
570:22 - C underscore Str
570:26 - en okay so I'll do that
570:28 - and then where do I have to write this I
570:31 - need to rewrite this right I need to
570:33 - open it so now if I just do dot right so
570:36 - if I just do F dot right
570:39 - so same thing cached all
570:43 - objects size of object I could write a
570:46 - macro for this I'm just writing it again
570:49 - and again right so yeah anyway if I just
570:52 - do that what will happen is let's say I
570:54 - wrote A B C D E I want to change e so
570:57 - first I did a checked a check did it B
571:01 - check B red C check C and I want to
571:04 - change C and now if I try to update see
571:07 - what will happen if I just write I'll
571:10 - just override T that's what is going to
571:12 - happen now that's because I have not
571:14 - gone backwards right so
571:17 - what happens here is that I am just
571:20 - overwritting the next record not the
571:21 - record I'm at so I need to go back that
571:24 - record how do I go back remember the
571:26 - file pointers we talked about in the
571:28 - beginning I have them no I deleted those
571:31 - comments but basically I'll just get and
571:33 - put pointers right so what you do is you
571:35 - take the pointer take the put pointer
571:39 - backwards how much backwards first of
571:42 - all get the position where it is so tell
571:45 - tell the position and go back how much
571:50 - how many bytes should I go back just go
571:52 - back those many bytes which this object
571:54 - occupies the size of obj from here you
571:58 - need to go you need to travel that
572:00 - position from the beginning of the file
572:02 - so that will take care of a moment so
572:05 - what will happen is what you are saying
572:07 - in the saline essentially is let's say I
572:09 - am at I'm at this position I'll just say
572:12 - 10g is something minus the size of
572:15 - object so minus here from where from the
572:18 - beginning so from here I'll just go to
572:20 - this much positions right so that is how
572:23 - this seek P works and you just write off
572:26 - that object and here in the end you can
572:29 - just return that object so return phone
572:32 - so that you know that you have found
572:34 - something or not and when you can also
572:37 - break out of this Loop that's also
572:38 - possible you can do that so first we
572:41 - will just read it
572:43 - right we'll first read the initial data
572:45 - I'll just remove these things
572:49 - read the initial data we have these data
572:52 - we'll just change this address so what
572:54 - I'll do is I'll just say
572:59 - update
573:02 - id2 and then address to let's say baker
573:05 - should be
573:07 - I'm just changing the address over here
573:09 - I'll do that run this
573:12 - and it works successfully well it did
573:14 - not show it over here so I'll just do c
573:17 - out that will also work I will get a one
573:19 - or zero right so here I got one that's
573:21 - because this ID exists if I do something
573:23 - with where this ID does not exist I'll
573:26 - get in 0 and I'll show the message to
573:29 - the user that here the ID you're
573:31 - searching for doesn't exist in my
573:33 - database create a new ID something like
573:35 - that so we updated that now what we are
573:38 - going to do is is read again
573:43 - what do I get
573:46 - see that address has been changed and
573:49 - this is not from the upgrade thing right
573:52 - so it has been changed directly inside
573:54 - the file so that's how you update things
573:56 - inside a binary file so the same way you
573:59 - could also object the whole object right
574:01 - but I did not do that here because I
574:05 - need to create another file and I take
574:07 - time but I'll encourage you to try it on
574:10 - your own so instead of string you just
574:12 - have a whole new employee object and
574:14 - here you just instead of copying that
574:16 - you just
574:17 - create a copy Constructor over here so I
574:20 - think you all know what a copy
574:22 - Constructor is and you just need to find
574:24 - a copy Constructor so that this uh IDs
574:27 - get copied and then you just paste and
574:29 - then you just do the same thing you just
574:31 - go back and then write out the new
574:33 - modified object right so that's about
574:36 - application and now comes the deletion
574:39 - which is little bit different so this is
574:41 - delete
574:43 - and again this also involves searching
574:45 - so let's just say pull delete
574:47 - our deleted keyword we'll just keep it
574:49 - adjusted and then you have a ID
574:53 - now what you are going to do here is
574:55 - we will push uh the the
575:00 - process Remains the Same you first
575:02 - search for the object so these things
575:03 - remain the same you just copy and paste
575:06 - this thing instead of f stream you could
575:08 - just say if stream because it's just
575:09 - going to read it
575:16 - all right and uh
575:20 - here I'm just going to search for that
575:22 - file so the whole thing you will just
575:24 - copy and paste well you don't need the
575:27 - whole thing uh the inside is going to
575:30 - change the the if condition is going to
575:32 - change and then just say return form
575:39 - right now how are they going to delete
575:41 - something well we cannot directly delete
575:44 - from a file just like what we do like
575:46 - let's say I want to delete this I just
575:48 - if I just press backspace this this line
575:50 - goes away but this action cannot be
575:53 - performed using C plus plus binary file
575:57 - objects you don't have a delete method
576:00 - inside the object so how do you delete
576:02 - it well the way you delete it is you
576:05 - don't you just create a copy of this
576:08 - whatever database you have the all the
576:11 - records you just create a copy but you
576:13 - don't include the thing which you want
576:15 - to
576:16 - uh Delete right so I will I'll just
576:19 - explain you it again so if I have a b c
576:22 - d e and let's say I want to delete D
576:24 - it's always deleted I create another
576:27 - file called temp so this is all inside
576:30 - our
576:32 - details.tag file so these are the
576:34 - contents or in temp file I want to
576:36 - delete T so I'll just copy a b c e
576:41 - right so if you see here I skip D
576:44 - because that's the thing I wanted to
576:46 - delete and then now I have successfully
576:49 - deleted now what I'll do is I'll delete
576:51 - this file and rename this as details
576:53 - right so if I do that it will look like
576:55 - I have deleted this thing so that's how
576:57 - you delete files in C plus plus delete
577:00 - records in C plus plus and to do that
577:02 - you need another Library which is
577:04 - standard input output
577:06 - because you are going to work with the
577:08 - standard stuff inside the Hard dish you
577:10 - want to rename remove and all those
577:12 - things so those things are available in
577:14 - the standard input output side right so
577:16 - here what I'm going to do here is I'm
577:18 - going to create a new file which is
577:19 - called ofc and then this is a temporary
577:22 - file and this is just going to be some
577:24 - temp DOT type
577:27 - I'll do the same thing iOS binary
577:30 - and here what I will do is if the ID
577:33 - matches what I'm going to do here is
577:35 - I'll just well if the IDT does not match
577:40 - well if the ID measures we don't have to
577:42 - do anything we'll just skip that but if
577:44 - the ID does not match what we'll do here
577:47 - is
577:49 - [Music]
577:49 - um
577:50 - well you don't even need this form you
577:53 - don't have to search for this if you
577:55 - think about it you just we are just
577:57 - trying to delete something which does
577:59 - not exist so basically just skip it if
578:01 - it does not exist you're not going to
578:03 - delete anything so yeah you can skip
578:05 - that this phone can be scared it's not
578:08 - required
578:10 - on this return statement too
578:12 - it's not required
578:14 - now if it is not equal what you're going
578:16 - to do you are just going to see it temp
578:19 - dot right that whole thing so
578:22 - same thing
578:27 - [Music]
578:31 - you write that that's it that's how you
578:34 - delete a file now you have written that
578:36 - now whatever what you're going to do is
578:39 - just close those both files
578:42 - attempt to close
578:44 - now you just
578:47 - remove
578:50 - details.tag
578:53 - and then you rename
578:57 - attempt to that to details
579:01 - not that
579:03 - said
579:05 - see how simple it is to delete something
579:07 - it's just a work around you don't have a
579:10 - delete method in binary files and this
579:12 - is how you delete it just create a copy
579:14 - without this uh record which you want to
579:17 - delete and then you just rename it and
579:19 - then so if if let's say I want to delete
579:23 - this first of all read that delete
579:28 - ID number one and then read again
579:31 - do that if I just run this thing
579:35 - uh well everything came at once was
579:37 - because there's no new line but yeah if
579:40 - I just comment these two things out
579:41 - because it's already deleted you don't
579:43 - have that so if I just to read
579:46 - you will be seeing that I just have ID
579:48 - number two I don't have ID number one
579:49 - right so that's how you do the credit
579:53 - operations in C plus plus you have
579:56 - create read update and delete delete is
579:59 - something which is kind of different you
580:01 - just create a new file with all the data
580:03 - except the thing you want to delete and
580:05 - updater you write it you read the object
580:09 - you find the object where you want to
580:12 - cheat and then you update it go back a
580:15 - record and then overrated so that's how
580:17 - operation works and it's the only place
580:20 - where you're going to need to use input
580:23 - and output at the same time right and
580:26 - other things are pretty normal the
580:28 - create and read or something which is uh
580:31 - we already know about and this is how
580:34 - you do the credit operations in C plus
580:36 - plus so that's it in this video and in
580:39 - the next video with
580:41 - move forward and then we'll first talk
580:44 - about uh things like static which will
580:47 - make this uh I will ID independent of
580:51 - you know initialization that means I
580:54 - could if I want to I could just save one
580:56 - one so what we'll do is it will just
580:58 - delete all the ones if this this Loop
581:01 - runs it will just delete all the ones
581:03 - right if I just print id1 so I don't
581:06 - want this to happen I want the ID to be
581:08 - generated on its own so how to do that
581:11 - that will see in the next video and also
581:14 - we'll talk a little bit about the
581:16 - strength because slowly we'll understand
581:18 - how to work with the string class so
581:19 - this is one function you learned today
581:21 - and this is one address pack which you
581:23 - learned today C string which basically
581:26 - contains all the functions we need for
581:28 - string so you have lots of functions in
581:30 - that we have strcpy which is for copy
581:33 - you have this compare so CMP is for
581:36 - compare cmpi is for comparing without
581:39 - the case comparison is it doesn't ignore
581:44 - the case of the strings right and then
581:46 - you have all these um functions so HDR
581:49 - cat is for concatenating Strings
581:51 - basically why we use string classes
581:54 - because we want to directly use uh
581:57 - operator so let's have string A and B I
582:01 - could do something like a equal to B
582:03 - using the shrink class but this is not
582:05 - possible when using something like a
582:07 - primitive data type if I use array or
582:09 - something I cannot do this right I need
582:11 - to compare character by character so
582:13 - these things are the reasons why we use
582:16 - string but when you are dealing with
582:18 - something where you want to write into
582:20 - the files or something like that you do
582:24 - have to use the primitive data right
582:27 - hey guys welcome to programming
582:29 - knowledge in the previous video we saw
582:31 - how to do file operations in binary
582:35 - files using C plus plus you can also
582:37 - call it credit operations so we saw that
582:40 - by taking an example of an employee
582:42 - class right so that class hidden ID
582:47 - attribute which we used to identify each
582:49 - employee uniquely and we were performing
582:52 - our operations on that so
582:55 - the problem is that in that particular
582:57 - program the ID was not being generated
583:01 - automatically it was unique because I
583:04 - kept it unique right when we were
583:05 - writing the program we had to keep it
583:08 - unique so that there were no conflicts
583:10 - in that program but what happens is that
583:13 - generally you don't want to do it on a
583:15 - very large scale because you may forget
583:18 - what was the last ID or you may forget
583:20 - something else right so it's best that
583:23 - these kinds of things be automated and
583:26 - how do we automate that thing well you
583:28 - can use a global variable that's a
583:30 - solution but the best solution is to
583:33 - maintain something known as a static
583:34 - variable and that's what we will be
583:36 - talking about now so with static
583:40 - variable is nothing but that variable
583:43 - gets created and will stay until the
583:46 - program's life cycle ends so what do I
583:48 - mean by that let's say I have a function
583:50 - here
583:51 - so this is some function and I have say
583:54 - three variables inside this and I even
583:57 - have some other variables so let's say t
584:00 - e over here now what happens is that
584:03 - this main function is going to run
584:05 - indefinitely right so I'll be creating
584:07 - these two variables on start of this
584:09 - program and let's say I even have some
584:11 - Global variables so let's see um
584:14 - uh G and H are Global variables right so
584:18 - let's these two are the global variables
584:20 - these three are the uh function
584:24 - variables of this particular function
584:26 - called fuency and this two other
584:30 - variables which are there inside the
584:32 - main function now what happens is that
584:34 - once I run this program first these two
584:36 - variables will be created and then
584:38 - because main will run indefinitely these
584:41 - also be created and since I did not call
584:44 - this function these variables won't be
584:46 - created right
584:48 - so now there's some times we do need
584:51 - variables to be created and stay even
584:55 - after their role ends or let's say you
584:58 - want a variable which acts like a global
585:01 - variable but it is not a global variable
585:04 - because it's not useful anywhere else so
585:06 - uh this kinds of requirements usually
585:10 - addresses when you're using recursive
585:12 - functions so let's say I create a
585:15 - function for calculating uh sum of
585:19 - numbers from 1 to n which calculates it
585:22 - recursively so let's quickly make a
585:24 - definition for that so max
585:27 - um
585:28 - well uh we'll just take the maximum
585:31 - element of an array it's not sum of N
585:33 - numbers let's say the maximum element of
585:35 - an array so you could just say Max
585:36 - element which takes an array and
585:40 - uh it takes an index so that it can
585:43 - recursively do that right
585:46 - recursively calculate the maximum
585:48 - element which is present inside the
585:49 - array so now what happens is that let's
585:52 - say I maintain a variable called Max
585:55 - well Max is a keyword so let's say
585:57 - underscore Max which is basically in the
586:00 - beginning it's in uh Min so if you do
586:03 - intman you're basically getting the
586:05 - least value an integer can hold so sorry
586:08 - minus intman is same as Maxwell by the
586:12 - way solve for confusingly on that but
586:15 - basically in Max and Main are the
586:17 - extremes you can store inside an integer
586:21 - right so now I get this maximum element
586:25 - and now let's say I recursively find out
586:28 - the maximum element inside this array by
586:31 - using this index now what happens is
586:33 - that I don't want to create this maximum
586:35 - element again and again so one solution
586:38 - is to keep the global maximum millimeter
586:40 - I could just do anything Max over here
586:42 - and I could start out with this well I
586:46 - could just start off with this overview
586:48 - so I could just say anything Max and
586:51 - every time this function recurses I can
586:53 - just update this maximum element so that
586:54 - I can get this um
586:58 - maximum element inside this array
587:00 - um well it's not going to be matched
587:02 - technically it's going to be in Min
587:04 - because I'm taking the maximum element
587:06 - if you are taking the minimum element it
587:08 - should have been Max so what anyway
587:11 - um well we are going to just follow this
587:13 - logic but the problem here is that this
587:16 - Max is actually accessible by
587:19 - any function and any class which is
587:23 - inside this program right and we don't
587:25 - want that because we're not going to use
587:26 - maths anywhere else except this function
587:29 - so the solution for such kinds of
587:31 - problem is to use something known as
587:34 - static variables and that's what we're
587:35 - going to discuss today so let me just
587:37 - quickly quickly clean this using
587:40 - namespace standard
587:43 - in me
587:45 - right so the way we use static variables
587:49 - inside functions are like this so you
587:52 - say in maximum element of an array and
587:57 - you pass in an index
587:59 - and then instead of declaring it as end
588:02 - you can say static and Max and that's
588:04 - going to be the minimum value right
588:07 - so now what happens is that if this Max
588:10 - has not been initialized it could be
588:12 - initialized with this ink mail which is
588:14 - the minimum value an integer can hold
588:16 - and then subsequently it won't it will
588:19 - be updated well the same variable will
588:21 - be updated even if it recurs through the
588:24 - function so let's say uh we'll just
588:27 - quickly write this function so what's
588:28 - the base case base case is when index is
588:30 - equal to zero right so when index equal
588:33 - to 0 you just update Max so max becomes
588:37 - um well we can just use a tinary
588:39 - operator here
588:40 - so array of 0 is greater than the
588:44 - current Max then Max become side of 0
588:47 - else
588:48 - is just this right and then you will
588:51 - just return the maximum
588:53 - and then
588:55 - since this is a base case or else what
588:58 - you do is you just do the same operation
589:00 - with the current index so max equal to
589:03 - the array of uh let's say
589:08 - well I took 0 over here so I'll be
589:11 - starting with the last Index right so
589:13 - index n
589:14 - uh or n minus 1 right the array of index
589:18 - is greater than the max
589:21 - then you just say area
589:23 - index or else and Max
589:26 - and then uh what to do is it recurs
589:29 - through the same function so max element
589:31 - of the same array but index minus one
589:35 - and in the end you just return the
589:37 - maximum area
589:39 - so this function is quite clear as a
589:41 - recursive function the only difference
589:43 - being that instead of declaring this Max
589:45 - as a global variable you have declared
589:47 - it kind of inside the function but the
589:50 - variable will be created in the global
589:52 - score but we cannot access it we can
589:55 - only access it inside this function
589:57 - now if you uh just want to test this out
590:00 - you can just create an ID
590:02 - um
590:03 - you can just call it one two three four
590:06 - five
590:07 - and then um well this is quite obvious
590:10 - let's check what 10 over here and then
590:13 - you could just say Max element
590:16 - of this array and start with index 4 or
590:20 - uh well you can just take take out the
590:23 - size from here but since I mentioned
590:25 - index it's just the last Index right I'm
590:28 - going backwards so if I do this run this
590:31 - particular program I'll be getting a
590:33 - maximum test 10 which is correct one so
590:36 - that's how we
590:39 - uh use static variables the main thing
590:43 - is that we don't want to create it as
590:45 - Global that is because we don't want
590:47 - this variable to be accessed by
590:49 - everything but at the same time it
590:51 - should act like a global it should not
590:53 - change right so if I just remove the
590:56 - static well the result is quite obvious
590:59 - because every time this function
591:00 - recurses you will be creating a new Max
591:02 - right so if I just run this
591:04 - you will see that I have been creating a
591:07 - new Max every time and once I reach Pi
591:10 - Max is basically The Fifth Element
591:12 - that's because this at the last
591:14 - iteration what happens is that I'm just
591:17 - reassigning max to inch main so 5 is
591:20 - basically the maximum element possible
591:22 - right so that is something which we
591:25 - don't want we want to store the maximum
591:27 - uh of the previous array elements also
591:31 - so in that cases you just need to make
591:34 - it a static and use it well static
591:37 - variables inside functions are not
591:39 - really exciting we generally use static
591:42 - in case of classes and that's because we
591:45 - don't have to create an object of a
591:47 - class or we don't have to create an
591:48 - instance of a class to use those static
591:50 - members or member functions so let's
591:53 - quickly see how to do that
591:55 - let's take a
591:57 - case of the employee
591:58 - right so
592:00 - let's put everything as public for now
592:04 - right so now what we're going to do here
592:07 - is I'm going to see static int ID
592:12 - and I cannot actually
592:15 - assign it over here I'll be getting an
592:17 - error so if I if I try to do that so
592:20 - let's see
592:21 - employee
592:23 - a
592:24 - great if I try to run that I'll be
592:27 - getting an error that's because I cannot
592:28 - uh initialize a static member right
592:32 - inside the definition of the class I
592:33 - used to do it outside so how do I do
592:35 - that I just need to do something like
592:38 - int
592:39 - employee ID equal to whatever ID you
592:43 - want to start with so let's say I want
592:46 - to start with one
592:47 - right or you can just start with 0 and
592:49 - in the Constructor you can increment
592:51 - this ID so uh we'll create the ID I will
592:55 - keep the Ida private so that uh we don't
592:58 - get into issues or well it doesn't
593:01 - really matter right you can keep it
593:03 - anywhere so for this demonstration I'll
593:05 - just keep it private because we are just
593:08 - going to have this ID a static and no
593:11 - other members for this example right so
593:14 - you can just play around with this but
593:16 - basically the concept Remains the C it's
593:18 - a global variable but not completely
593:21 - Googled it's just it acts like a global
593:24 - variable but only for that scope right
593:26 - so now you have the static ID well it's
593:30 - static unit ID
593:32 - and then in the public section I'm just
593:35 - going to define a Constructor
593:39 - employee right which will Auto increment
593:42 - this ID so that's what we wanted it we
593:45 - don't want to set the idea again and
593:46 - again so I just say ID plus plus right
593:50 - and I can also keep a public variable
593:54 - which is going to be the ID let ID of
593:58 - this current instance so I could just
594:00 - say int
594:02 - and ID notes the difference between
594:05 - these two things this is basically a
594:07 - global ID which will keep incrementing
594:10 - itself but this is going to be the idea
594:12 - of my employee which is using like
594:14 - basically the particular instance which
594:17 - were targeted so there are just to
594:19 - employee ID
594:22 - equal to the ID which we incremented so
594:25 - that actually
594:28 - solves our problem of having to manually
594:31 - increment this IDs right and we also
594:34 - have in uh initialize the static
594:37 - variable now what I can do is I can just
594:39 - create a b c d
594:41 - and if I do let's say B dot employee ID
594:48 - and uh
594:50 - let's say d dot employee ID
594:54 - now if I run this
594:56 - I get 2 and 4. but I do not assign any
595:00 - employee IDs over there right so
595:02 - basically I auto incremented the IDS now
595:04 - every employee I create will be uniquely
595:07 - identified and if you want to see how
595:08 - many employees I created you could just
595:10 - access this video to it right since this
595:12 - is private I would have kept it public
595:14 - will uh generally we don't keep such
595:16 - things as public we don't want to give
595:18 - it access right so uh well you can just
595:21 - do a small function so get count right
595:25 - and get count is basically going to
595:28 - return you the ID so uh it's going to be
595:32 - white or architis return that so they
595:35 - need to get com which is basically
595:37 - return the ID
595:40 - and I could just say here
595:45 - you get come
595:47 - uh sorry I could just say a DOT get com
595:51 - right and I'll just keep a new line here
595:54 - for
595:55 - separation
595:57 - and if I run this I will be getting two
595:59 - four and four that's basically the four
596:01 - uh employees we created right if I
596:04 - create another one I'll be getting five
596:06 - there so if I just say a b c d e
596:08 - and uh well I need to stop this run it
596:11 - again
596:13 - now here you can see two four and five
596:15 - which is basically the number of Empires
596:17 - but this isn't very intuitive right
596:19 - you're just saying a DOT get coin a DOT
596:22 - get con doesn't mean anything get count
596:24 - is basically for the employee class not
596:28 - for the object not for a particularly
596:31 - right so the way we can do that is we
596:34 - can also make this function as static so
596:36 - how do we do that we just say static
596:38 - create get count and now what you can do
596:41 - here is instead of accessing it to a you
596:44 - can just do employee and then the scope
596:46 - resolution operator and get con now what
596:49 - this means is that how many employee
596:52 - Optics have I created you just get me
596:54 - the count of that and this is more
596:55 - intuitive than actually calling get
596:58 - conflicted right so generally when
597:00 - whenever we want to use static variables
597:03 - or whenever we want to use static
597:05 - variables you generally put it as static
597:07 - functions because
597:09 - they belong to the Flash not the
597:12 - function sorry not the instance right so
597:15 - if you see get com there is actually a
597:18 - function which belongs to employee class
597:20 - not to a or not to P or not to D
597:23 - predictively
597:25 - so now if I run this
597:27 - I'll be getting the same output so 2 4
597:30 - and number of employees I have created
597:32 - this five and you could use it uh in the
597:35 - other way if you wanted to so I could
597:37 - just see uh let's say B dot get com so
597:40 - this will also work right if you you
597:43 - could access static variables directly
597:45 - but it's this is not generally
597:47 - recommended as as this is not very
597:50 - intuitive right so that's about static
597:53 - variables uh in the next video we'll do
597:55 - something exciting we'll talk about
597:58 - genetics right we'll talk about
598:00 - templates and how we can make generic
598:04 - functions so that we don't have to
598:06 - overwrite them again so if you remember
598:09 - about the vector right so if I do hash
598:12 - include vector
598:14 - and here
598:17 - if I do something like vector and then I
598:21 - need to put int over here so this kind
598:24 - of thing that's basically because
598:26 - I have only one vector class but I can
598:29 - use it for any data type I want so if I
598:31 - wanted for string I could just do string
598:33 - over here so we'll see how to do this
598:36 - thing for our own class and
598:39 - that's all for this video so in the next
598:41 - video we'll see how to do all these
598:43 - things and it's going to be really
598:45 - exciting from now on right so yeah
598:47 - that's all for this video thanks for
598:49 - watching happy coding

Cleaned transcript:

hey guys welcome to programming knowledge in this video we will be looking at some basic concepts of computer programming and we will also be installing tools to help us code in C plus plus this video is going to be the first video in the tutorial series on CPS Plus for beginners let's get started the first thing we need to address before learning how to program is what is programming so programming is basically a way to instruct the computer to perform specific tasks and by specific tasks I mean those tasks which you typical human will find it difficult to perform within a limited time frame so these tasks are generally a huge scientific computation for monitoring minor changes in the data but we can make the computer perform any tasks of our choice by programming it to do so so we need a way to communicate with the computer right we need to communicate with the computer to make it perform the task so we do that by using special languages known as programming languages so you might have heard of famous programming languages like C C plus plus Java python so there are tons of languages out there and in this tutorial series we will be exploring CPS Plus the next question comes is why learn programming so the first obvious reason is that computers are extremely fast if you know how to utilize the power of computer programming you can do wonders with it for a typical computer of today's time an addition of two numbers which could be as big as a billion is just going to take a nanosecond so just imagine how fast a computer is it can perform billions of additions in one second that that's the power of computers and it is extremely fast in performing the task next thing is that computers are cheap so nowadays any electronic Gadget which is released in our Market comes with embedded CPU so everything is basically a computer in itself you are you have microcontrollers also so you can basically turn anything I mean any electronic Gadget into a Computing device and you can make it perform the task next thing is that computers can work 24 7. so if you are a beginner of task you can without any worries delegate it to a computer and then computer is going to finish the task for you and keep it ready so next question which comes is why out of all the languages should we learn C plus plus so C plus plus is very close to the hardware by learning C plus plus we can actually relate the concept to the hardware programming so uh it's really a plus point for beginners who are willing to take out application development directly from scratch next thing is that C plus plus gives a clear understanding of object oriented programming for beginners we will discuss about object oriented programming at a later stage but for no we can understand object oriented programming is um essential competitive programming concept with C plus plus will make it easier to understand next thing is that C plus plus has a huge fan base if you have a Hindi query there are tons of people out there who help you with it next thing it is used in application and system programming as I told so if you are a software engineer you can choose your career between application and System Program next thing is that it teaches you the difference between compiler Linker loader and other programming Concepts this is the main reason C plus plus is recommended for a beginner I do agree that python is much easier to learn and it can perform way more tasks than C plus plus but in C plus plus we will be dealing with everything from scratch even though there are libraries there is a way to actually Implement each and every concept from scratch by using that methodology we can actually learn everything to the core if you are a person who is interested in the core concept and the origin of every algorithm or any other concept C plus plus is the best language for you next thing is that it is widely used in application CPS plus can be found in any many applications like games animations web browsers you have databases and compilers operating systems run on C plus plus C plus plus has a white scope next thing is that it is extremely fast so if you have an idea of competitive programming it is basically a competition where our programming skills are tested within a limited time frame and uh there are there is a constraint so at that point many programmers use C plus plus so 99 percent use C plus plus has their language in computer programming because C plus plus is extremely fast in passing the data and working with the data so if you're a person who needs immediate results you press this language for you these are some of the reasons for the learning CPS Plus so now we'll start by installing the tools which will require to code in C plus plus so first thing we require is a software which can make the computer understand our CPS Plus Code that software is called a compiler so there is a difference between interpreter and compiler we will be talking about that in a later video but for now we can understand compiler as a software which can convert C plus plus code into binary code so that the computer can understand so some of the available C plus compilers are Apple export export is an IDE comes with an integrated C plus plus compiler you have Del C plus plus C language plus if you're on Linux you have the gno C plus plus preinstalled wizard in any distribution of Linux you can type GPS plus minus minus version and you'll see the version of the compiler which came with your distribution and if Windows you can directly go to control panel you can go to the programs programs and features and here if you scroll down you will see something called Microsoft Visual CPS plus so this is actually a c plus compiler provided by the Microsoft itself if you if you are a gamer and if you have installed any heavy game before you might have noticed that the game asks you to install the latest version of visual C plus plus or update the Microsoft Visual CPS plus component in your computer that is because as I told you C plus plus is used for building games and then those games require the latest version of the C plus plus compiler to be installed in a computer so Microsoft Visual C plus plus as both a platform and a compiler and if to use it we need Microsoft products you cannot directly use this visual C plus plus compiler uh these are open source compilers okay some of these the Min GW SQL and gnu are all open source compiler next thing we need is an IDE from what an IDE is basically ID is an integrated development environment so if we go by the definition of Wikipedia it says an integrated in development environment is a software application that provides comprehensive facilities to computer programmers so basically what it means is that IDE is a tool which is going to help you write your program you can actually write your programs in notepad also for actually for writing C plus plus codes you just need a compiler and you can even use your notepad to write C plus plus code so what you need to do is just type your code in and then you save it with a DOT CPP extension so C plus files Global extension dot CPP and then the when you run it through the compiler the binary file will be generated and the computer is going to execute it but why we need an ID is ID is know what our code is IDs know our language so while coding what we need to do is we need to concentrate more on the logic than the syntax and semantics of the language we need to concentrate on the logic and the grammar so IDs are great tool because they have a feature of correcting the grammatical mistakes you make the syntactical errors which we call technically those errors are identified by the IDE and ID is actually sometimes the corrected some ID is corrected basically and some ideas ask you to correct it before compilation itself so that's a great feature in idea and it also contains many other features like it provides you a debugging environment we will look at debugging when we are testing our application the best I leave for Microsoft is visual studio so you might have heard about this Visual Studio is the best ID you can find on for Windows development you also get it with game development and many Visual Studio is a best idea for Microsoft it's also available for Mac but xcode is better for Mac so visual studio you can actually download it because you can download the community version display but this uh this ID is actually a heavy software it is going to take about 10 GB of space so if if you are running low on computer specs you need to consider other IDs there are a couple of other IDs as well their famous IDs like Eclipse neck bins Etc but for a beginner I would recommend code blocks as your ID so code blocks is a lightweight ID you can go you can search code blocks on your favorite browser open the first link which is codeblocks.org so this is the website here for code block this is a open source ID and it is really a lightweight idea you can make intermediate projects in code blocks you can use it for heavy projects but for learning the language and working on intermediate level projects code blocks works the best for you and it is not even bigger it just takes about 500 MB of space in our tutorial series we'll be using the code blocks ID you can download the source code or download the binary source code is for the people who are in Linux environment if you are familiar with Linux you will be finding yourself compiling everything from scratch for that the source code is also provided but uh if you just need a straightforward installation you can go to the download the binary list here you will find different files for different platforms so in Windows I'm here and then you'll find it for Linux and the Mac as well you can download your version and here we need to understand something so core blocks is just an ID okay the IDE software is only going to be installed we need a compiler as it will compiler is first required generally we can compile our code and we can ID we can only write the code you can download any of these compilers out here you have segment or Dev C plus plus or main GW but the thing is it is going to be a bit complicated once you download the compiler you need to actually integrate it with the I integrated development environment that is IDE then only our code will be compiled and run by the ID for that you can actually go go to a favorite browser and then type for sigvin or you can even install main GW the problem here is that once you download the compiler you need to add it to the path this is a complicated process and for a beginner I'm I would not recommend adding adding compilers to the path and then integrating it with IDE so what I recommend is just directly download this file which says code block 17.1 to Min GW setup.dxe what this is is code blocks provides a inbuilt ngw compiler along with the environment this setup will contain the imagew compiler and then by installing itself you install the compiler also in the environment so the compiler is not said to work in the path I mean the compiler won't work in a whole computer but it will only work in the environment in which code blocks is installed so once you download this setup file you will be having a compiler but that compiler will work only in the code blocks environment so so that is actually recommended for a beginner but if you like to explore more we'll have a separate video on how to download addition external compilers and Link it with our ID so visual studio doesn't need a linking because it directly uses the Microsoft Visual C plus compiler other compilers we need to integrate it with the ID so for now we are directly going to download this one you can choose any of these mirrors I'm going to go with fossil so once you are in fossil you need to wait for few seconds to download get started and you need to start the download so I'm going to pause the video till it gets downloaded okay guys so my download is completed so I'm going to close it I'm going to open the downloads folder and in the programs I'm going to find the code block setup file so this is a very straightforward installation in Windows you just have to click next and then you need to agree the terms and conditions I'll leave it as it is we need all these plugins and uh you can actually change the destination folder I'm going to leave it uh as default I'm just going to click on install so this extraction process is going to take about a minute and once it's ready we can launch our code box ID so it is basically extracting the files and the compiler so the compiler comes with the idea itself so you can just click on yes and then it's going to open and we can close this wizard we can just click finish and finish over here and here uh it says that a compilation detoxes the dnu GCC compiler that is the mean GW compiler you need to just click on this and then click ok now that is inside the code block so it just comes with it so you can once you hover over the most you can see the path of the minty W compile it's inside the code blocks environment So eventually okay so uh you can just click OK and this is the interface of code block for now we are just going to go create a simple application just click on create a new project go to the console application so all these are different kinds of applications we can develop with C plus plus but uh for now we are going to just go with console application so you can just click on go and then we can skip this page we need to select the language so just select C plus plus click next and then we need to give a project title so I'm just going to say cpp1 and then uh the folder to create project 10 I'm going to browse it I'm just going to put it in my desktop you can choose any location of your choice and then just click ok so here uh the file name will be created so the dot CBP extension stands for code blocks per project file that file is directly accessed by the code blocks IDE and inside that you will find a sources folder in which your CPP file will be there CPAP is the C plus file and you see BP is a code block style you can just click on next and then you can leave everything as it is it is just a compiler configuration and then you are ready to code so here in the left hand side you can see in the workspace uh you have CPP and then inside that you have subfolder known as sources you can just click on us and he inside that you will find a main.cpp file so if you double click it you will have the basic program over here so this program just prints hello world to the console okay if you want to run it you can just press F9 or this button over here which says build and run if you just click on this it is going to build the application it is going to run it and here on the console we see hello good so congratulations guys we just compiled our first C plus plus program so as I told you these are some of the lines provided by the compile weather IDE so it just returns it with the return code and then there's the execution time it just took 0.022 seconds to execute this code and uh these are some of the features of the ID so what we wrote is just District you can uh you can actually Tinker on with that you can actually change this line you can make it as a welcome welcome to programming knowledge welcome to programming language in this video we'll discuss about computers do and what are the differences between them for a recap this is the program provided by the code blocks IDE I just change the default hello world statement to this statement and then once you press this button or the F9 button you are going to execute this call and the console is going to pop which is going to print welcome the programming knowledge on both the world statement you typed inside the double code and then it is going to return the execution time and all these things let us see what is actually happening in the background foreign language Assembly Language machine language is a fundamental language of the computers process computer is not able to understand any other language than the machine language all programs are converted into machine language before they can be executed and machine language is just a series that represents low and high voltage language but the difference is that assembly languages use symbolic population represent the machine operation code both the Assembly Language in the machine language are all more similar to C but the only difference is that Assembly Language are built available kind of machine language on High level languages let's look at an example so this is a single program to do a mathematical computation definition to understand is that the computation which is going to be performed as B into H by 2 that is the contents of B is going to be multiplied with the content of H and then the result is going to be divided by 2 and that is the value we are going to get of what happens in the background is that polished a memory location with the size of memory required for this particular object is loaded into the memory and then the guidance of B are transferred into the location Army same thing happens with R2 then multiply the contents of R1 and R2 are multiplied and then the result is stored back in R1 next step and here divides the patterns of R1 by the number two and then the result is given back in our query location which is requesting the computation all this temporary memory locations which have been created and then unloaded from the memory so this is what happens background of this simple computation so in case of our hello world program here all the welcome to programming knowledge this one what happens is that first link is established between the console and our program and then there's a process which will generate machine code from this particular code and then that is going to be executed and what we see as a result is this statement on our function so there's a lot of problems going behind let's see what a compiler is so as I told you compiler is a piece of software that translates the high level language to the Machine level the compiler basically takes the source code and then it converts it into the executable code this type is known as a reprocessing step and then the executable code which is the zeros and one or sometimes assembly code are converted into the machine code which is purely 0 seconds and then this code is executed by the machine so compilation step consists of two steps reprocessing and the processing so a compiler takes a lot of free processing time it is going to go through the whole of your program it is going to be reach at every statement it is on the errors and then it is going to ask you to correct the errors it is again going to register your program and then it is going to finally generate the executable reports in your program at a later stage so once it's loaded into the compiler it is going to generate the lower level code that is the object code so what an interpreter is interpreter is same as a component there is not much difference the only thing is that in interpreter the preprocessing step is faster than the case of compiling in interpreter The Interpreter is going to go through each and every line of the core it is going to execute that particular plan in a virtual environment and then once you television error it is going to stop right there around the interpretation process continues from that particular point to the end that's why The Interpreter is faster at 3 processing and then it doesn't generate an object file object files are generated in the runtime itself that is why the processing type is Big because while executing the same program multiple times every time at every education an object will need to be generated on the runtime unlike the case of compiler and only one object file is generated at the first time compilation and the same object is used to run the program that's why if we see this if we change anything here if I make welcome programming knowledge as the default hello world hello world and if I just run this program I am just going to get welcome to programming knowledge why did this happen because the object file is the same in this case in case of an interpreter that is going to change if you directly change this code here and then run the program you are going to get where hello world inclusion welcome to programming knowledge always it is going to work on the previously generated object file so once we create this build and run the vehicle is built and run button we are going to get a logo here and now again if you click on this button we just press run you will get hello because the object file has been replaced now and then because if we make any changes now if we just type hello here and then again type again click on run it is just going to say hello that's how a optin file works and it is not Hardware dependent so if you are checking the efficiency of a program we need to check the runtime of the program not the compilation because if in a computer with higher specifications mobile time will be much faster than a computer with lower specification but the Run type of both the program is going to be same foreign first takes the code line by line and then it is going to execute it in a virtual environment immediately then but look at the result and only that particular line is correct it is going to go for the compilation next in object code is generated and compiler layers in interpreter is not generated it is generated during the runtime itself the thing which is the most important thing is that the runtime of combined languages are much faster than interpreted diabetes this is because compile over makes only one obj file only one object code which is used to compile it again and again is generated in the runtime and that is going to be executed we are comparing the performance of C plus plus and python python is an interpreted language C plus plus will perform much faster than python because of the obj file in which it is going to save on the disk python is not going to save the obj file and it is going to generate the obj file every time it is executed so that is the difference between interpreter and compiler in this video we'll be looking at this template code which code blocks had provided us while creating a project and also we will be learning how to perform simple output in C plus plus let's get started so the first line here says hash include IO stream Ash include is known as a preprocessor directive so hash include is used to load files which are already present in the compiler Q plus plus compiler comes with many files which are which have predefined functions to help us code with so higher stream is one of them and by using this preprocessor directive by using hash include we are actually invoking this file from the compiler so without this file you cannot perform any input or output in CPS plus there are many other header files we will be coming across in the run but for now let us explore IO stream IO stream contains all the functions which we need to perform console input or output so IO stream basically stands for input and output Stream So by name itself we can say every every function we need for performing input or output is present in IO stream next with this line it says using namespace STD so STD is known as a scope hope we can understand like a region so every function inside this IO stream Works only in a certain region so for now we are not going to deal with any other course rather than the standard scope but just for information there other scope also that we will be learning when we are already good in C plus plus that comes at an advanced stage but for now we can see uh only use the standard scope standard scope is nothing but the console so if if I just remove this line you will be seeing that this all these functions go out of the scope so now if I build and run this by hitting F9 so now you can see that it shows an error what does the error say it says that 3 out was not declared in the scope this just means that this line or this particular function cannot be executed because it is out of the scope scope is nothing but the standard scope the way we Define standard scope is by using the scope resolution operation cooperation is nothing but this just write the scope and then the function and in between the scope and the function you just specify the scope by putting two columns so this is how you specify the scope so if I now execute it uh yeah I'm getting another error because this ended this angle is also uh from the io stream so it does not have that uh scope so I need to provide the scope for this also now if I build and run this I will be getting the output so here you can see welcome to programming knowledge so that is the importance of scope then why do we need using namespace also well you cannot do this for every statement right it is going to be lot of it is going to take a lot of time to actually do this and sometimes we may also forget to do this so suppose I am writing 10 coed statements this is a sealed statement here there's nothing but the output statement this one what I'm printing onto the console is known as coord statement so this statement if I writing 10 times I need to specify the scope 10 times so every time I use this function or not on only this function you if I use any function from this IO stream Library I need to actually specify this particular standard scope that is why to avoid that C plus plus provides a way to globalize that by using the namespace statement so by writing using namespace STD you are actually globalizing the statement and it is going to take care of any other standard so you if you don't write the standard it is automatically taken care of by the compiler because it just encountered this line this line just means that wherever standard scope needs to be used you just use it that is what this line means so the next line says Ink Main is actually a function every program has a main function main is like a triggering function so every program has this without main there is no program because all the execution starts only from the main function so suppose you write a 100 file program or even say thousand file program they may contain n number of functions but there is only one main function and that main function cannot be replaced and without this main function this program is not going to run so if I simply just type a capital M over here well C plus plus is case sensitive so capital M mean and a small M main are different so now if I try to build and run this I will be getting an error it says undefined reference to this win main at the rate 16 this is actually something which is inside the compare it is a compiler issue that is because it did not encounter the main function so only if you write the main function you are going to execute it so so bursting any scene plus plus program looks for is this for this function it needs to be Main and with a small M and it should be empty you can actually put void over here so all that also doesn't matter but just it just makes it look complex so it's best to leave it empty so if you put like this and then it has to be int the reason we'll be looking at it later and the meaning of this end and this return 0 will be understanding only when we are dealing with functions so for now we can ignore them so just remember that you need to write in any other main doesn't work so suppose if I put while or some in let's say float main all these are not going to work only in plane is going to work and for now you can actually remove this return 0. so without this also the program is going to run and it's going to give you uh there is a lot of significance for the return statement and we will be discussing about that when we are discussing functions so this as I told you is the coat statement just stands for the console output so CH stands for console output and whatever you write here goes to the screen and this operator is known as the stream operator stream operators are very important you will be looking at it while we are dealing with other streams also like file stream or something like that but for now while we are using the io stream that is the console stream we need to have these two functions in a pair so the this is a this is the stream function that is the co then this is the stream operator and this is the stream operand uh this is a statement but technically in computer programming this is called a string string is nothing but a collection of character it is called a string so that is a data type we'll be talking about that in the next video so for now this is what the program was and yeah I forgot to tell you this one uh this is actually appending another function in the same here so see how it actually operates on only one operand so if you want to operate on multiple operands you need to separate that with this stream operator so you see this is a string and this is a function angle is actually a function so uh the way it works is it is going to first do the it is going to first operate on this and then it is going to encounter this and then it is like adding another third statement that's it so if I just put a semicolon here and then put a c out over here it is going to work the same way just that it is not to get you confused these are two separate Church statements if you are wanting to put multiple statements in a single statement then that is how this is how you do it you just put a operator in between and then put the next operand over here and this semicolon is very important no matter which is a semicolon over here also semicolon is known as a Terminator so in C plus plus you can write multiple commands in the same line so Terminator what it does is it is going to separate each and every command so that the compiler knows what comment execute after executing the previous command so that is why we use a Terminator it is very important so if we remove this it is going to result to an error because it doesn't terminate and it says expected the semicolon before this particular end of a statement before this one that is why we put a semicolon and this curly pressure just signify the body of the main so whatever code you write you are going to write between these two braces for some time until we are we get familiar with functions so once we are familiar with functions we will be writing multiple functions and we will be invoking the functions within this main method we will be looking at that later but for now let us talk about the output so we all know how to put output right this is how we put output we just put them inside the two double quotes well this is a string uh we can also put numbers also so for numbers you can either put it as a stream so you can put something like this right and then execute it you will be getting Phi over there or integers are separate in programming so even if you put a file like this you are directly going to see file in the console so here you can see and now comes the major difference if I put 5 plus 5 over here and then executed I will be getting 10 over here that is the value of 5 plus 5 but if I just enclose it within a code uh within a double code what will I get I'll just get the same thing I'll just get 5 plus 5 because this is treated as a constitution what this double quote means is that whatever you put inside this double quotes is just going to be replicated as it is on the screen and if you don't put a double quote it has to be either memory location or some operand so memory location or variable will be looking at the next video while we are discussing input but for now and output we need we need to bother about memory location let's just talk about the integer part of it so if I just put uh let's say let's try another one let's put something like this 5 plus 5. let us try this one these are two different strings and now you know used a plus operator between these things so what we expect is actually 10 but let us now execute this and look at that it says invalid operands of types const care and constant what this means is you cannot add two constant characters or constant string or const care in this square bracket is square bracket is actually called an IA okay so we will be looking all of these things when we are discussing data types but for now we can uh you can understand that you cannot add two strings you can only add two numbers so if I just put 5 plus 5 I'm going to get the answer so here so this is same with real numbers also you can even put 0.5 plus uh 1.5 so that makes it two so here you will be getting 2.2 over here so and you can even work with decimals also even if I put 1.45 you're going to get the answer so you will be getting 1.95 so that is the major difference between strings and numbers so if you are working with numbers you can directly add them you can multiply you can double multiply here is the star symbol which you will be finding on the 8 on number eight on your keyboard so that is a multiply symbol and then divide as the normal forward slide symbol so this is the divide and multiply and there is another one also there is another operator that is called the modular operator what this does is it gives sorry it gives the remainder of the two numbers right so what what it means is if you just put 5 modulo 2 what this does is it gives a reminder so if you divide 5 with 2 what is the remainder you are going to get you are going to get one because uh well it is uh 2 into 2 plus 1 which makes it 5 right so this is the operation so that is why so 2 goes two times in 5 and then one is the remainder that is why you are getting one so you can verify that you can do that by simply putting 2 in uh well you can directly put 5 mod 2 right you're going to get one over here so if I just run this here you can see one there are many other operators will be looking at them later when these are the uh this is how you can perform output in CPS plus well there are other things also like instead of using this we have something called Escape sequences let me talk about them quickly it is escape sequences what these are is basically there are some keyboard tools which we cannot perform during runtime right so suppose we wanted to perform a backspace during the runtime it is not possible I am talking about the runtime so suppose I wanted to hello world over here suppose and then I wanted to perform a backspace for this extra space I have provided over here I cannot do that in the runtime right now I can do anything I can even put this I can change this character I can do anything but what about during the run time for that there are some special keystrokes that are actually treated as Escape sequences so the way we Define a script sequences are you actually put a backslash and then a special character so here there will be a special character and then this is going to actually give you a special meaning so this is going to execute that particular keystroke so there's there are some of the Escape sequences like slash a it's going to bring you a bill so you might have noticed that there will be a notification Bell that will come and then there is a slash B which is for backspace and then slash T and slash n we'll be using these things more often blast is for a horizontal tab and then slashing is for a new line wait we did see this one somewhere right this one so ndel is actually a function this is actually a significant difference between using slash and an Intel so I'm just going to delete these things let us first try slash in so first slash a I'm going to run this so you might have heard that uh song right that Bell song that is the function of Slash a so let us look at slash T that is just it's going to put it down so let me put a tab between hello and world so if I put slash D over here and then execute it here you will be seeing hello and then this space and then a word so this is what the function of Slash D and then slash n is what going to do the same thing what this function does it is just going to put the contents in the next line so if I just execute it there will be a new line so hello and then a new line and then the word so that is the function of Slash n in this video we'll be looking more about the Escape sequences which we have talked about in the previous video and we will be learning how to perform input in C plus plus so before getting started with the input let's talk more about the Escape sequences so the Escape sequences which I talked about in the previous video are slash a slash B 12 slash T and then once again slash d slash n okay there are actually many other Escape sequences also you do have a slash V but all these things we won't be using much flash is for a vertical tab we won't use that much but you can always go up into the internet and then check for the list of Escape sequences there so what do we need Escape sequences for is it just to perform these actions or do they have other purpose also so let us say I wanted to print something like this so let us say I wanted to print uh Escape sequences uh let me just put it without a brace so that this this is what this is the exact sentence I will be needing on the screen right so just try to print this Escape sequences start with a slash and uh have a character and have a uh let's say single code single or have a single character in them something like this I wanted to print this particular statement as it is onto the console you might think it's very easy right just cut it uh well I'm just going to cut it and then put it in pair of double quotes and then paste it over there and then let's just run it it says it's an error why it is expecting a semicolon before single well keto I have a semicolon right what's the problem with this well the problem is when you are putting a backslash in the in a string it is going to consider a backslash and the subsequent character as a escape sequence itself and here once you put a double quote over here it it means that this is a separate string and then this is a separate string and this is actually something in between right so it doesn't have any meaning at all so what we actually wanted was we wanted this double code to appear onto the screen right but we cannot do that we have a way yes we do that is by using Escape sequences so here I am wanted a backslash to appear right so how do we make a backslash up your backslatch itself is a Escape character when the worker wonders you put another backslash so this what it means is it means that this is a escape sequence and it this particular escape sequence just means that you need to put backslash on screen so that that is why your you you were getting an error back then and now you will be getting a backslash perfectly as you wanted it and here instead of this course you actually put a backslash before the code right so what they says is if you put a Escape Port over here if you put a code as a skip sequence it means that this code is not a part of this code which is actually uh indicating the start or end of a string but it's Escape character itself and it needs to be printed onto the screen that is what means if you use a code with it escape sequence so the same thing goes over here also if I just put the backslash it is going to go away this is now entirely highlighted in blue that just means that this and this entire thing is now a string and now if I execute it I'll be getting the output so here you can see Escape sequences start with the backslash and have a single character in them and single is enclosed within double quotes now exactly what we wanted so that is the importance of Escape sequences so there are many other so there are many places where you will be needing them so something like you wanted to enclose something using double quotes or you wanted to put a backslash over in some some place or suppose you wanted backslash n to appear but you can't directly print like this right you know what this is backslash n is actually a new line so if you put something like this and if you try to execute it you will be getting something like this thing sequences start with a and then a new line and then a space and then have a single character in them so that becomes a problem how do we do that same thing you just put double backslashes and then so now this actually this backslash and this backslash n are now different this backslash only corresponds to this backslash and then this n is now is greater as a separate character so now if I run this you will be getting your output so escape sequence will start with the backslash and you just got what you wanted and have a single character in them so this is how you use Escape sequences in your strength now let's talk about the input before not talking about input let us talk about something called data types the people that is done here data types why do we need to know about this well you can't just take input right you need to store the input at some place so that you can use it at a later stage so where we store the data is actually defined by the memory location and how will allocate memory that depends on the type of data we are going to get so we need to know what kind of data we need to we are going to get as an input so that we can store that data so what kind of data can we get we can either get numbers or characters right we can't get anything else well we do have other types of data also something like you have graphs or you have images videos but all that are ultimately broken down into it into numbers only that's a different story we are not going to talk about that at this stage but for now we can say that data is fundamentally consists of only numbers and characters we can't get anything else other than that so the way we data types are broken down is to satisfy either numbers or characters so in numbers what do we have we have integers or we do have real numbers so real numbers are nothing but decimals fraction all these things so the way we take integer cells by end so in this data type which is for integers so this is the data type and this is what it means so integers it's going to take so anything any integer is going to say minus 12 or 20 or 20 000 all these are integers only so can it take anything can you take even Infinity well no integer do have a range value and that ranges so let me write it separately here that ranges from minus 2 power 31 2 2 power 31 minus 1. well it's not 2 into 31 it's 2 power 31 minus 1. so this is the range of the integers it is going to take up to this big numbers so you do have something called short and unsigned signed ends all these things we will be talking about that at a later stage for now this is the range of integers so you can store as small as minus 2 power 31 and as big as 2.31 2 power 31 is nothing but it's around 4 billion so that is the number you can store in so what if we need a bigger number than 4 billion let's say 6 billion or 8 billion for that we do have a solution we are going to use long so long as another data type so long is actually a type modifier it is not a data type long you can use it within so this makes it this actually makes it pretty readable so it's just nothing but a big integer so what it does is it's going to store bigger numbers than int so this will take about eight bites just this is going to take only four bytes so this is whole bytes of memory we'll be looking at how this 4 bytes right now there's such a way to check how how much memory this takes so this is going to take eight bytes of memory and its range is uh approximately up to 64 2.64 approximately it goes up to this so this is a huge number right you won't practically need much bigger than this 2 or 64 is very big you've got 32 itself is Big right 2.31 2.32 they almost go up to 4 billion so you don't need bigger numbers than that but uh in case you need you have long integers same goes to the real numbers also if you are working with smaller decimals or realtime decimals which are not so big you have float which is for decimal numbers so you got minus two or sorry 0.2 or you got something like 0.0003 or all these things so 12.0 also if you just put a point zero it becomes a load and these are all floats and then if you want bigger floats you do have double double is for bigger float bigger floats this again is for 8 bytes and this is the range of double so in C plus plus if you if you did not specify the data type if it is if just a number if it's just an integer it is always going to default to integer only and uh if it is a decimal number it is always going to default to double so what I did here is just added a comment so comments are those statements are not executed by the compiler I'll be showing a demo shortly so for regarding data types these are the data types for storing numbers and for characters you don't need much you would have only two types of character inputs that is you'll get only one character or you get a collection of characters so for one character you have cat but if for one character and for multiple characters you have strings so strings is actually more than just collection of characters there is much more to talk about strings we'll be doing that at a later video so now uh for characters the way we Define characters is by using single quotes so you have if you put anything inside a single code something like a or if you put B over here or exclamation mark anything inside a single code but only one character strictly only one character you cannot put multiple characters inside a single that will cause an error and the fun fact is if you put something like this this will also become even though one is integer if you put it inside a single code it becomes a character the same goes with decimals also you cannot put decimals inside single quotes because it contains more than one character right so even if you put 1.0 something like that one is a character this period is a character and then 0 is also a character so you cannot put more than one character inside string so that will come under string so strings how do we Define like we did here so using double quotes string is just a collection of characters collection collection of characters that's it and it is going to be n plus within double quotes so anything you put inside even if you put even if you don't put anything inside double quotes this is also a string this is called a null string we'll talk about null and all these things at a later stage but for now just for your information purpose I'm just telling about the null string and you do even if you put something like this this is going to be a string it is just a space and even one one character also it is going to be considered assisting so this is also a string and now you can put something like 1.0 or 1.00 2 all these are now considered as strings the way you represent data is very very important if you just take numbers if you just put one it is going to be end if you put 1.0 it is going to be double remember that here if if you put if you do not specify the data type it is going to be defaulted to double only in C plus plus and if you want to floor if you want the data type to be float you can just add an F over there so if you just put F over here it is going to be float the same goes here also if you want this one to be considered as long you just put an L over there so this is considered as long and how do you define a character put like this this is going to be a care and if you put it like this this is going to be a string so see how how how differently it is interpreted if we type the data in a different way so this is the importance of data test here anything we get from the character is categorized only into these data type so we don't have to worry about any other data whatever we type is just going to be a subset of all all of these things now now let us work on some real input we forgot to mention about the comments so let us know well we can actually show the comment over here only so suppose I want this data but this is something for you to understand right so these are not part of C plus plus command these are something I typed right so these don't make any sense in C plus plus but I don't want to delete it because I'll be using it to explain to you guys so how can I do that without and also run this program without actually going into an error I cannot write another another program and use a separate file right I don't want to do that I can but I don't want to do that well for that we have something called comments I need this data but I don't want the computer to execute it so what I do is I'm going to hide this data from the compiler so the way we do that is by using these clients as comments so comments are actually used to uh explain some lines of code and also they are generally used to actually debug the program so if you are developing a big program and you don't want some of the lines to execute and you directly want to see what is the result of two or three lines you can actually comment on the other lines and you can see the result that is going to be very useful when you're testing your program so for that comments are there so there are two types of commands one is the single line comment which I did over here so this is just going to comment on this entire line so whatever I'll write after this pair of forward slashes is considered a comment comment so all these are commented out and then if I need to commit at multiple lines the way I do that is by putting a forward slash and putting a star over there so you can see all these are grayed out now and the thing is it is completely graying out my program so even this thing is grayed out and now if I try to execute I will be getting another it says that this unterminated comment is here that is this one see this one has been started but it is not terminated at any point so I want to terminate my comment over this length because these are these are the lines I don't want the compiler to exhibit right so to terminate I'm just going to do the reverse software I'm going to put a star and then slash so this is actually going to comment out all these lines these lines change my program code these are not going to be executed by the compiler so now I can run my program without any issues and I'm going to get the output so that is the importance of comments we will be commenting out many things at a later stage when we are working with bigger programs comments are very important so now let us write some useful code let us now write a program to add two numbers so it is always wise to actually put a comment on what you are doing and also put some authorization so you can put something like I did it on on it for now I'm just going to write the name of the program what I'm going to do is I am going to write a program for add two numbers it is always advised to put comments before your program code you don't have to put it over there only I am just putting it there you can put it anywhere you like I I even you I can put it inside here also I can put comments anywhere I like now let us write a program to add two numbers so first thing is I need to ask the user to enter because obviously we need to ask the user something generally is going to know what your program Ming so let us say enter the first number simple enter the first number and now how do we uh now we need to create a memory location I told you right we need to create a memory location to actually store our input the way we do that is we need to First specify what kind of data we are going to get what we can because it's a number it is actually going to be um Floats or doubles right we can we can add any number but for Simplicity purpose I'm just going to go with int you can actually go forwards or doubles also uh it is completely up to you I'm just going to go with paint or in this tutorial so I'm just going to type int and then I need to name the location we need to give some meaningful name so this is also known as a variable declaration uh we are just creating a variable to store something so this can be understood as a mathematical function right so we are just going to put x equal to 5 it just means the variable access storing the value 5 but in computer this is what is happening you if you are declaring a variable it is it means that you are actually creating a memory block and then assigning a name to that so it's just like an alias for the memory block so here I'm just going to name it num1 just to keep it simple and here you can I you can do two things you can either specify the value which is going to go inside the memory location or else you can even uh keep that so here since I don't know what is going to go inside this location I'm just going to skip it and enter a semicolon this means that this command is terminated so I'll executing this command the compiler will know that it has to just print a memory location and now how do you get the input it is just the reverse of it you guys should try it if it is C orb it is going to be C in and then if it is this side this is going to be on the opposite side well this is how we take input and then in where do we need to store the input we need to store it in this location so just write num1 and then put a semicolon so we got our input inside number same thing we need to do for the next number also it's going to copy paste that and here instead of first number I'm just going to write second number and then instead of num2 I'm just going to store uh sorry instead of number I'm going to store it in num2 location and now I'm I need the sum of these two numbers right so remember that I can directly put numbers so you can directly show the sum like this so you can write sum is and this one and then what was that num1 plus num2 you can directly put like this but this actually makes it little bit confusing and it is always advised to keep your code very very understandable so if somebody is reading your code they should understand what is going on so this is not always a best practice unless you are in into competitive programming you need to consider all memory and all those things but uh we are now learning so it is always advice to use as many variables we want so for storing the sum I'm just going to go with an integer so because if we add two integers you are only going to get an integer right well I'm not talking about the Border cases where you go with very big numbers like 2 power 32 plus 2 power 32 that is obviously going to go out of the range of integers but I'm just talking about normal cases so I'm just going to store it inside this location sum and what it is going to store it is going to store the value of num1 plus num2 and then I am going to invoke the sum over here so remember in the previous video I told that memory locations and numbers can be accessed without this double quotes that is why I put some without double quote and now if I executed here we have our first program of audition this is our first useful program it is not just printing something on the discrete it is actually doing something for us so here I am going to enter the first number it is 12 um second number let's say something like 24 and then if I enter it the sum is 36 perfect 12 plus 24 is 36 we got our answer yeah I forgot to mention the way we check size of the data type is by an operator called size of so how we do that we just put size and then put an off and inside the brackets you are going to name your data type you can either put the data type or you can put the data itself so if I just put one over here and let me put an angle so that you don't get that compiler statements so here you are going to get four why because one is an integer as I told you it's just going to be treated as an integer only and if I just put 1.0 as I told you it is going to be defaulted to double that is why the size is 8 and now if I put 1.0 f it is going to be plus a float and you will be getting only four bytes so that is how size of works and now if I just put a character it is going to take only one byte so if I just put like this you are going to save one over here and then even for a null character that is I'm not putting any character these are just two codes side by side even if I run this I will be good I'll be getting an error it says empty character constant that cannot be done another thing is if you just put one character in the inside double quotes let's see what happens in single code this written one right so what will happen in the double quote well as she told you this thing is nothing but a collection of characters so maybe it will be the count of the characters right so something like hello if I just put hello then this is actually five characters right h e l l o makes five characters so the side should be five right but you'll be surprised that the size will be six so that is why I told you strings are something more than just collection of characters there is something called a concept of terminating character or a null character we'll be talking about that in the when we are discussing strings so that's all for this video in the next video we'll be talking about strings and how to use them in our program so till then I I would like you to actually meddle around with the code I would like you to do as many errors as possible and try to read these errors the errors are very very important so you just try to do something like this and then compile you know that this is going to result in an error but what is important is this message because every time it is not going to give you a perfect message for General or something if I have something like this if I just forgot the semicolon over here and then put something like uh let's say hi over here and then put a semicolon and if I try to compile it it is going to show an error in this line it says in line number eight it is expected uh it expected a semicolon before c out statement but there is a semicolon statement where is the error it is actually in the previous line I forgot to put the semicolon in this line so that is why you make as many errors as possible and try to understand these lines these are very very important it is going to help you to write better code you you won't find yourself trying to figure out where the error happened in this video we'll be talking about ASCII or American Standard code for information exchange so what is this this is basically a number which is associated with every character let me give you an example the previous video we wrote a program for adding two numbers right so same thing we are going to repeat over here so let's say enter foreign and I'm going to create a memory location and take an input inside that location let's say a right so instead of A1 I'm just going to name it a and same thing is going to happen enter second number okay let me give a space over here so that looks nice and in b c n b and In Sum equal to a plus b and we are going to just say the sum is and the sum right we wrote this program in the previous video right so we you all know what it is going to do it is just going to ask for two numbers we are going to input that and it is going to process those two numbers it's going to add those two numbers and then it's going to store the value inside this memory location that is sum and then here the memory location is invoked and the value inside that memory location is going to be displayed onto the screen here now what if I just change this end to some other data let's say care and here also let us see here now let us run and check this out so here it did not show any error and it is working perfectly so now if I just save one over here enter first number that is 1 and the second number two and now the sum is going to be something different so you might think it's going to throw an error because we are trying to add two characters but as you told you characters are actually a form of integers only computer stores character in form of integers so this addition is completely valid and the value of the sum is going to store which is actually the sum of the ASCII values of those characters so one whose ASCII value of 49 then 2 whole is asking value of 50 so once you press enter you are going to get the sum as 99 that is 49 plus 50 that is 99 right that is why I told you that representing data in different forms is very important so if you write one like this it is going to be let me write it separately somewhere in the bottom so if I just type 1 this is an integer and if I I put it like this this is a character so that is why I told you the way you represent data is very important so instead of size that is four bytes and one one byte so that is also there but here this integer is actually processed as one only so it is processed as well and this thing it is processed as 49 so this is the number it is going to process when you just say a character one right so every character in your keyboard has a high speed value so to look at that just go into your favorite browser and check for ask you over there and here you might see many links so just click any of them so they are going to give you a table of ASCII values so this is the ASCII value and this is actually the decimal and this is the hexadecimal representation you don't need to bother over the hexadecimal representation what is important is this decimal representation and the symbol associated with it so you can see the knowledge associated with ASCII value is 0 and there are many other characters so 13 is actually the carriage return that is the enter key and 27 is a Escape key so here you can see 27 is the Escape key so what is important is our numbers and characters so those ASCII ranges are only very important to us we will be using them interchangeably while dealing with data right so mostly data consists of only numbers and characters that is why we need to remember the range of numbers and characters as Q values so here number starts from 48 so here you can see 48 is 0 so it starts from 0 and goes up to 57 that is 9 so this is the range of ASCII values so 48 to 57 that is the range of numbers and capital A starts from 65 and goes up to 90 90 is Captain said likewise small a starts at 97 and then it goes up to 122 so 122 is small Z so these are the ranges so let me write that down here so let me put a comment so this multiline comment so 0 starts at 48 and 1 is 49 in likewise right okay I'll put underscore here same way capital A is 65 capital B is 66 likewise and small a is 97 small B is 98 and it goes on so these are some of the important aspiranges we will be dealing with this while we are working with the conditions and all those things we will be looking at that in a later video but these are some of the ASCII values which will be using very frequently so it is better that you remember the starting value because the other values you can directly derive from the first value so 0 is 48 capital is 65 and all a is 97 so these are some of the values uh that would be very helpful if you remember these steps so now you know how to predict the output right so let us try with some other characters Also let's just put this as a character only so instead of end I'm just calling it a scare now if I try to build and run this so here it is asking for the first number let's say some random character I'm just putting this question mark and this apostrophe so let us look at the table so question mark As 39 is the apostrophe and 63 is question mark So 63 plus 39 so now if I just put it the sum is f that is over here 102 right so that is how ASCII version just work so they were just like numbers just that the character is associated with a special number and you need to know the number to actually correctly predict the output so sometimes human basis out right so sometimes you may put a character and try to add two character and see absurd answers those are not upset just that your logic is wrong so here if I just put an intent character sometimes this happens so if I just put a hint over here and Cat over here and then try to build and run this so first I'll put one and then put an A so now the output is going to be B Because 65 plus 1 that is 66 and the character value of 66 is B so you can check that from this table so here you can see capital B is 66. right so ask device are just like numbers so you're just going to operate them as you are going to operate on numbers so you can put uh you can add one or you can multiply it so into two that is also possible so this is only character so let's just make character and then once I try to run this here it is 1 and 2 so here the sum is B Because 48 into 2 that is sorry 49 into 2 that is small B right that is 98 so here you can check that out so 40 49 into 2 that is 98 so 98 is B so you can do that you can divide those things in this video we will be looking at conditional statements so what are conditional statements what are conditions basically conditions are those set of rules which Define a particular procedure to be followed so what do I mean by that let's take an example suppose you want to sort out all those files which you created yesterday from the C drive or from the desktop so the way we do that is we take all the files we look at the date when it was created and then if it matches yesterday's date we put that inside separate folder or else you leave it or you put it inside another folder that doesn't matter so our only focus is we are putting those files which were created yesterday into a separate folder so when you're checking whether the date matches or not you are actually performing a conditional operation so that is what conditional operators or conditional statements do so conditional operators work like if something is there and you need follow some procedure or else you need to follow some other procedure which may or may not be defined if it is not defined you need need not do anything if it is defined you need to follow that procedure so it is like if something then you do something so do procedure one suppose and then else what you need to do do is do a procedure to or you can leave it right this does not need to be defined so this is not important what is important is this condition this condition if that something is satisfied then only you need to do procedure one or else you need not do anything or you need to do some other set of statements which are defined so that is how conditional statement work and the same goes with C plus plus also so the way you define condition statement is you put an if and then inside a pair of parenthesis you put a conditional statement and here you have a block so this block is different from this block here I'm writing it so this is if block so this executes only when that condition is satisfied and then if this condition fails in our example suppose some other file came up which was created one year ago so what you need to do you need not do anything or else if you want you can put it inside another block that is up to you so do that as else if that condition fails you have another block you need to follow this particular procedure so this set of statements or this set of rules execute only when this rule is true or this conditional statements evaluate to true or else it follows this else block so the way you define conditions is by using operators called relational operator relational operator is just give the relation between two operands so these are same as the mathematical relations you have a greater than you have a less than you have a greater than or equal to less than or equal to and then you have an is equal to this is is equal to so do not get confused with a single equal to sign we use so by declaring variables I told that in k equal to 10 means a holds the value of 10. so this single equal to operator is known as the assignment operator and this double equal to is the is equal to operator so the difference is when you tell a equal to 10 and a equal to equal to 10 this means that assign the value 10 to 8 so this is what this statement means and this statement means compare a and 10 and check its equality so this is what it means so this double equal to means that you you will take the value of a you will take 10 you compare it and if they both are equal then you say it's true or else you you tell that it's false so this single equal to Operator just means that you put this 10 inside this memory location a that's what it means here under Point node is 10 equal to a is an error so here even though it mathematically both the statements are same then equal to a cannot be processed because the computer always wants the left hand side to be Memory location whatever the right hand side is it can be a memory location it can be a constant value it can be anything so whatever it is it has to go into the left hand memory location by using this operator which is the assignment operator and this double equal to operator can work either way so even if you put n equal to equal to a this is the same meaning it takes 10 it takes a value of 8 Compares it and if they are equal it's going going to tell yes what else it's going to tell no so these are the operators and you have another operator this is double equal to which is is equal to and then you have a not equal to not is basically this exclamation mark over here this is not equal to so these are the operators you use to check the conditions so let us look at a quick program let us make some program let's say uh to check whether the person is eligible to let's say drive a vehicle or not so for the legal age for driving Vehicles is 18 years so let's check whether a person is eligible to drive the vehicle around or else put an oath or not whether is an eligible voter or not we can do that so let's start by writing the input statement so first we ask the name enter the name is going to enter the name you know name is going to be a string so string name I don't know the name that's why I'm going to leave it blank and I'm going to take in the name over here so CN name and now I'm going to take the age of that person so let's say uh CR enter okay enter your age or here now I'm going to take the edges here so let us mention that also over here in in years something like that so I'm going to get the age in years number of years is going to be in integer so I'm just going to took an INT age and then I'm going to get the age also good but now I need to check in condition so what is going to be the condition I want to tell that the user can drive the vehicle or put the oat only if it's above 18 years of age so baby do a test you put an if and then inside this pair of brackets you put the condition the conditioners if his age is greater than or equal to 18 or not we are going to check that and then if his age is greater than 18 then you put the statement right let's say you are eligible to Vote or Private Car something like that right this eligible if it's greater than or equal to 8 in his eligible else you can just print sorry okay sorry you are not eligible something like that what we have done we have just taken the name we have taken the age your complete the age and we are checking whether the age is greater than or equal to 18 or not so if he is greater than or equal to 18 or if it's a major you are going to tell that he is eligible to vote or drive a car or any vehicle or else you are going to say that you are not eligible so that's how you do that let's try and execute this program so here let's say enter the name something like John and enter your age 12 so here it says sorry or not eligible let me put a new line after this health statement so that you don't get confused with the compiler's output and here so let's say some other name um uh let's say Harry and uh enter your age he is going to be 21 so here you can see you are eligible to vote or drive a car right so this is a simple program we have written so here you can also do another check right so suppose the person who is using a program is a notify wants to I'll check the validity of your program suppose you want to do something like he wants to put negative integers or something so age is always positive right the way you do that is first you check whether the age is positive or not so the way you do that is if age is greater than zero if it is a positive number then only check it so all these statements go inside this right if the his particular age is legal then only you can check that right if he is providing some negative number you cannot check that so here I'm just going to indent distance so that looks nice uh you also try to indent your program so that you can understand what you are writing so this if is this uh from this block to this block this is another if this is else inside this if block so all these statements are inside this statement or else you see um Shield please enter a valid age right so it is not valid minus Pi is not a valid age right so you take only positive integers as ages and you are checking whether that age is 18 or not so if it is equal to or greater than 18 your your saying that you are eligible to watch a driving card or else you are telling that you are not eligible so here now you can execute and try out this program it is better to execute after every uh condition you write right because when you are writing a bigger program it is it will be a good practice to actually check when you are putting a condition so that validates your program even more faster and you will be able to easily debug your program so here let's say enter the name let's think of some other name let's say Jack and enter the age let's try the hunting not you know let's type minus 120 and enter so here it says please enter a validate so you can have many checks like that so you can have also maybe he's going to enter some weird is a thousand years or two thousand years you can check that also the age should be less than 1000 or less than two thousand something like that for that we are going to need another set of operators which I will be talking in the next video but you can do that inside this if also so I can check over here also if age is less than let's say what's the maximum 800 right so let's say one or five or one or two maximum one or two so if it is less than one or two then only you need to execute these statements so Ctrl X and it goes inside this and let me intend this properly right so if H is pleasure Mark to this or else you are again going to say the same thing so just Ctrl C and then over here inside this if you're putting is this else so that is how simple conditional statements are you are just going to play with conditions so here I am checking if it is a positive number and here I am checking whether it's too big if it is too big I am telling that please enter a valid age and if it's too small also I'm telling that please enter valid age and here if it lies between the range of 1 to 101 because 102 is the maximum wage so I put less than 102 which goes up to 101 and greater than zero starts from one so from 1 to 101 it's going to check and if that age is greater than or equal to 18 it's it's going to say that you are eligible to vote or else it's going to say if you are not eligible so that is how you perform a conditional check so this statements which are written inside and if so I have written a if inside if so this if is the main F inside this I have written this and inside this I have written this if else statement so this concept is actually known as us let me write somewhere over here okay on the top I'll write this is known as Mr if so nested conditional statements so this is what this is called as now if I enter a bigger value than a hundred and one let's say 105 or 200 so that will say you are not uh you're not entering a valid age and even if I enter some negative numbers also your it's going to tell that you're not entering a value range so that is how you play with conditional statements you try writing a program which will segregate whether a number is order even or not I know this is a very simple program you will find it in the internet but just try it on your own so let me give you a hint and even number um then divided by 2 gives remainder 0. and that's it we'll need another condition so this is the only condition you're going to give you are going to take a number and then you are going to determine whether it's an even number on or an odd number and this is the hint so if an even number is divided by 2 it it will given remainder as 0 and then if it is an odd number it's going to be some other remainder remainder is going to be one so you can try that you can try writing that program in this video we will be talking about logical operators in the previous video we wrote a program to validate the age the user enters right so we are giving a condition like if it's check whether it's a positive number or not and if it's a positive number we were again checking whether it's too great or not if it was too great uh we were telling something like your age is not valid and if it was okay if it was in a Range then we were checking whether he's 18 years or younger we were considering that the age was valid or else we are telling that it was a North valid age right Here If You observe this condition and this condition go together so if a number is positive and if a number is too great then it's not a valid number or if you look at the larger scope here you can combine these three two statements if a number is positive and it's too great or if a number is negative then it's not validate or else it's going to be valid so the way you group these conditions are by using logical operators these are just like the cut connecting words are used in the English statement so here if I talk about the condition when the age is not going to be valid let me write it down here and number is a valid age or a number is not a valid age if it is positive and if it is too great or the number is negative so this was the condition right so if a number is positive and too great so these two conditions go together or the number is negative then the age is not valid so this was the condition if you write it down in this manner it is much easier to write it down than these group of Master different else statements so the way to achieve these things to validate these conditions and to join the result of these two these results are joined right you need to check whether the number is positive and whether it's too great and you need to combine these two results and you are going to get a result also you are going to check whether the number is negative or not what if it's not positive you need to check whether it's negative or not and then you are going to check these two conditions if one of them is true then you are going to say it is not valid so this is basically the function of logical operators so there are three logical operators in C plus plus or in any language these are same as The Logical gates in physics you might have come across it so these are and you have an r and a not so not symbol you might have guessed it while I was talking about the relational operators I was talking about this operator right so if this one stands for not equal to so this exclamation stands for or not so this is not and for R we are going to put two vertical bars which are which you will see on on top of the enter key and here for and you have two ampersands the very important point to note here is that you need to use two Ampersand symbols for and two vertical bars for R because a single version also exists so in C plus plus there is also an uh operator which is this one which is a single and a single or so these are actually bitwise operators we need to dig deep into these operators because they deal with a binary representation of the data but just for your information I'm telling these things we will talk about that in a later video for now we don't need these bitwise operators or bit manipulators we are only going to need the logical operators which are just going to tell the relation between two conditions so and this basically if two or any kind any number of condition if all are true then the result is true so and this basically uh if all the conditions are true then it's going to be true and for R you have if any one of the condition is true right if any one of the condition is true then the result is going to be true that is the specialty of all so you if you have any number of conditions even if one condition validates should true then the result is going to be true and for and if n number of conditions are there all the number of conditions should be satisfied then only you are going to get the true value or else you are going to get false so this is the basically the and and our operator not is just it's going to turn the value so not is it is going to uh change true to false and vice versa so the function of not is just to change true to false and false to true or text n number of conditions and if any one of the condition is true then the result is true and for and it is going to check all n number of conditions and if any one of them is false then the result is false every condition should be true then only and is going to give you a true so that is basically The Logical operators so here another thing is that if you are writing a logical operator let's say some condition one and condition two that's how you represent and for all it is the same thing if condition 1 or condition 2 and not basically doesn't need two conditions just going to reverse the condition so first you put an exclamation mark and you put the condition so here if you are using an and operator if this condition evaluates to true this first condition then only it's going to check the second condition so even if the second condition is true who is the first condition is false it is not going to check the second condition at all it is not going to perform anything over here so the thing with r is it is going to check every every condition and here if this one is true it is not going to check other condition so in the condition for R is that if any one of them is true right so you if it forms any one of the condition is true then it's going to evaluate it as true and this whole condition becomes a true condition so this part is going to be executed that is with the all so those are the condition those are The Logical operators let's take a quick example we are going to deal with the same example we took yesterday so here I'm directly going to take the 8 so enter your age and I'm going to take that inside a variable so end 8C in H and here I'm going to validate the age so if if age is greater than 0 and H is greater than 102 right so this was the condition we gave yesterday or 101 something like that so let's stick with 102 now and if this condition if this age is greater than 0 and the H is greater than 1 0 2 so this condition is basically not required because if it is greater than 0 then only it's going to be greater than 102 right so I'm just going to take out this particular condition so if the age is greater than 102 or if the age is less than zero right so if an age is greater than 100 something like 101 102 something like that or if the age is less than zero what we are going to say you have not entered uh a valid age right and or else we are just going to perform the check so if age is greater than or equal to 18 which is ah let me tell you over here I forgot yesterday we were talking about the block right so here if you have only one statement execute then you know need not use a block so here I have only one statement X good this is going to be the same thing as uh this one here if I put a block inside this and then put the C out statement it's going to be the same thing but block is totally used to hold two or more statements if I am going to use only one statement I don't need a block so I can just directly put the statement beside the if conditioner itself so this is also valid but if you write any other statement over here so let's say statement two if I write something over here this is actually not considered a part of this if statement unless and until I have a block something like this so here inside this block whatever right inside this block all the statements belong to this else statement but here since I have not put in Block over here this particular statements goes to the if this statement stays to the else part only unless and until I specify another block and mention these two things over here so if I put these two things over here now these two have become a part of this if statement and this whole if statement becomes a part of the else statement and here I have put only one statement that is why I don't need a block and here if an age is greater than or equal to 18 I am going to say that you are eligible so whatever for eligible to watch something like that or else we are going to see uh sorry you are not eligible something so this is the program we have written this is going to do the same thing which we had done in the previous video but see how small the program now looks so if you consider taking out these braces then it's going to look much much smaller because uh you have only one statement execute inside the if block but because it many people tend to forget putting these braces for multiple statements also it is always advisable to put the braces for even one condition but generally I don't do that I just if there's only one condition I put it beside the condition itself so if one statement execute I put it beside the condition itself it's up to you either way it's going to work so the here now let us execute it we are going to get the same output so here it's going to ask for the age so enter your age let's say 12 so here it says sorry you are not eligible and that's it we have created the same program but here it's a much smaller program than the previous program in this video we'll be talking about switch case statements so before talking about the switch case statement I would like to talk about the if else if else ladder so that is nothing very simple implementation of the if else ladder itself so let me give an example suppose you have a little commit it down here you have a question like the McQ kind of thing so you have a question and you have four options uh like this and you have a choice so I just say you your choice sorry your choice and here the user can enter whatever number he wants and you can check whether his answer is correct or not so you just check whether the choice whether the choice is one or else you again go for another check you check whether the choice is who or not right and if it is not two you go and check for another set of conditions so if Choi is equal to 3 you have something to do uh or else again you check whether his choice is four or not so if Chi is equal to 4 and if none of these are two then you say uh that it is an invalid option so you do something like this right so this is the kind of implementation where you are not using the if else if else ladder so here you are using the if else ladder so how do I make and make it as an if else if else ladder so what is else if basically it is the same implementation just that it is using a rule that the else statement always goes with the inner Motif so let me write it down here it's a very important rule so the rule is always the else statement goes with the innermost if so this is a rule you need to remember always this is always true that the L statement goes with the innermost F so if if you write some a program like if and then you have a else for that sorry else for that and you have and if you have another if and you have an else so the hierarchy of this particular program is derision if condition and for that you have an else condition so these three statements belong to this else condition so let me write it down neatly so if you have an if condition like this and suppose this phase the else is there right so inside this else actually so even if you write something like if if and else so what is going to happen is these three statements go with this L statement and this is if and this else are what are the actual if and else the actual contrary part that is this one so if Choice equal to 1 or else you going to perform any of these operations right or else you are not even going to look at them if charge equal to 1 you won't consider these options so here again so Here If You observe there are two ifs right so this if is evaluated so this L this LS always will go with the inner Motif so what is the innermost step right so here if I have a condition 1 and here if I have condition 2 condition 1 is evaluated and condition 2 is also evaluated and only if the condition 2 fails so if this fails then this else is activated right so this else always goes with this particular if not the condition 2 1 but always with the innermost step so this is your rule that is what is used while uh using the if lcfl slider the thing you do is you don't actually put the braces but you just put a word like else if so that has the same meaning instead of this braces you are just minimizing it so it increases the readability so here if I put else if and here also the same thing so this if I just remove this and this is goes here and you have final Edge so you see I did not add any word just that the same program the same braces I just removed the braces so now the program is much more readable right so if Choice equal to 1 or else if charge equal to 2 or else if charge is equal to 3 or will shift charge equal to 4 or else if none of these are true it's an invalid option that is the use of L shift so now let us talk about the switch case statement so switch key statements are not always used for all kinds of comparison they are actually a kind of alternative for the conditional statements but they are always not used switch cases are used only when we need to compare the equality of two operands so let me write it on here which cases okay sorry switch cases only compare equality so you cannot compare whether something is greater than or less than equal to or something like that you can just compare whether they are equal to or not equal to so the way you define switch case statement is for same thing I am going to do so let us write a complete program we will understand like that so let me put this here um so let us ask by asking something so see out or not you can add any kind of input for of your choice so just I'm just saying enter your choice and I'm going to uh put my choices one down the other so I'll start with number one and again another one so let's say two and you have three and you have four and you have new line and here I'll just put enter your choice so let me give another new line so that we can differentiate between our choice and the question so now our choice is going to be an end so in choice and see how sorry see in choice so I got a chance now in the previous case how we did that we just checked whether the choice is one or two or three you can do that actually if else if else if else if and else so Suppose there are 10 conditions you have nine L shapes and one if and then you have an else part where it is none of the choices so that's how it works in case of switch case it becomes much more easier so the way you do that is you just switch sorry spelling of songs which you put your variable in there so what is your variable in its choice right so sweet choice you have a brace and here you are just going to Define your cases so you have a case and then this is just like comparing charge equal to some number so I just say short case one and then you need to do something so let's just print uh you chose one something like that and then the most important thing in switch case is that you need to do something called break so we'll talk about this keyword this break is a keyword we'll talk about that in the next video but for now you just remember after every case after performing every statement for a case you need to break out of that case I generally do that without the basis but you can even put a brace over here so this is also correct but I generally don't use a brace it's okay if even if you don't so this is the same thing we are going to do for every case so case one case two case three case four that's all right so we have only four choices and then uh let me first do that afterwards we'll look at the other condition so you have you chose two you chose three you chose four now let's suppose you did not choose any or not any one of them now what is going to happen is you are going to use something called the default case so the way you do like this you put a default and then you just print um the invalid whatever the exception you wanted to print so invalid Choice something like that so that is how you use switch case it is very easy to read and this is mostly used in case of such menu based program so you have menus or you want to choose something or something like that so generally we use which cases because they are much easier to implement than the if well so you need to write if else again and again and again so this one is much more easier than writing the if else if else ladder so you can even compare strings you can compare characters so characters are nothing but integers and you can compare Boolean values also you cannot compare something relational right so you cannot compare whether it's some in some range or not if you want to compare that you need to go with the efl statement or else which case is going to work for you so let us quickly execute this program so F9 so here it's asking enter your choice let me just put 2 and enter so here it says you chose to so let us now look at what will happen if I just remove this break so let me just remove these three bricks right now once I try to execute it just see what happens now it's again asking for my choice now if I enter something like let's have one what it should print it should print you choose one right it was working in the previous time so now if I just put enter it says you chose one you chose two you chose three you chose four why did that happen because of the break statement so now if I don't have the break statement what is going to happen is it is going to evaluate from this order only it is going to from top to bottom so now if first it takes the first case and then if this phase it goes to the second one if this case it goes to the third one and whenever it finds a match it is just going to drop down just like that so the break prevents the drop down if you don't have a break it is going to fit everything in that order so if I just remove this break also and suppose I tried to execute this again so now here if I uh put some case like let's say some arbitrary number so three so here here if I press 3 now observe that there is no break right so it is going to go from 3 4 and invalid charge there's no break in between so it's just going to drop down to the whole switch statement so just press enter it's going to say you chose three you chose four and then invalid choice so that is why you need to put the break statement so that's all for the switch case in this video we'll be looking at Loops so what are Loops let's take an example so here I have sample program uh this does nothing but just taking name and age of a person and then print it onto the console so what if you ask you to take the date of 10 people so what you will do is you either execute it 10 times or you just copy the whole thing and then paste it 10 times and just change the name like the name one name to name three and so on so that those are two ways so what happens when the user decides how many number of times you need to ask him so what if in the runtime I am the user and I and I tell you that I want to store the data of let's say 100 people and you just wrote the program for 10 people so at that time your program fails right so to counter such type of situations and the counter such redundant code so you are not doing anything practically useful right you're just copying and pasting the whole code again and again so to counter those type of limitations we have something called Loops so today we are going to look at for loops so for loops work like a counter based Loop so you have a counter you have starting value and then you have an ending value so the loop goes from the starting value to the ending value that's all for Loop works so the syntax is you write for and then you have a starting value of a counter and then you put a semicolon and in between you put a condition so this condition is actually the loop condition so what happens is the counter is actually checked with a condition before going ahead so for every time the counter value is checked is compared with some value so that it stays true so this condition should straight through for the whole Loop to execute if it fails the loop is going to break and then the control goes over to the next statement which is also of the loop so for the loop to execute this condition it needs to be true and the way you grow this starting energy you cannot stay over there right so if you just put the starting condition in the loop this is also a for Loop only but what happens is there is no growth condition right so the starting value stays the same and this condition also is always true so this Loop will be going on forever so that type of loop is called an infinite Loop so the easiest way to create an infinite Loop is you just put two semicolons this becomes an infinite Loop so because there is no starting value there is no condition so this becomes any value what you do is you just Define some value over here so this makes it as an infinite Loop so infinite Loops are bad you don't want your program to keep executing the same set of statements again and again and again the user gets bored right so you want to end it after a certain number of times so what you do is you put a counter and then you put a condition and you put an increment value so you increment the counter or you you basically increase the value of the counter so that at some point this condition becomes false and the loop breaks so that's what you are going to do so let me write a small for Loop over here so what we're going to do is fall and then for the counter variable I'm going to initialize it inside this so there is something called scope so what happens is I can even do it like this also I can put an i over here and I put I equal to 0 something like that that also works but what happens is this particular I will be used in the whole program I mean in the whole scope of the main so we'll talk about scope in a separate video for now it is best to use counters inside the loops itself because once the loop end the counter gets out of the scope and it is deleted automatically from the memory so it's best to use counters as a local variable we'll talk about what are local variables Global variables when you are talking about scope we'll definitely do that in in another video so for now we are just going to write for I equal to 0 so that is the starting value and I want to execute it 10 times right so for how for 10 times I am going to check so let me start from one that becomes easier so many times you will be starting your your counter from zero there's a reason for that that you will understand when we are dealing with arrays or something generally computers counting starts from zero so for now we'll start from one and then suppose we want to go till 10. so when will the condition fail when we go for a number we are growing this number right so let me not write the condition right now I'll just put the growth rate so I equal to 1 so I will just do an i plus plus I talked about this increment operator right so what this does is it just increments the value of I from by one unit so if it is 1 it becomes 2 and then it becomes 3 and so on so now this I will go on increment it will go till the range of uh the integer that is sum 2 power 32 something like that and then it again Cycles back it again goes to minus two per something so this Loop won't end at all because there's no ending condition for this so to end this loop I want to execute it 10 times so that condition will fail only if I becomes greater than 10 so till the value of I is less than or equal to 10 execute the slope once it is greater just break out of it so here you put a brace so this braces as I told you signify a block of commands so this block represents the for Block inside just whatever you write is going to be executed these many number of times it depends on this condition in this set of conditions so here instead of writing all this I'm just going to put the number itself so let's just put an i over there because uh you don't want the whole set of statements getting confused so let's just put I over here and then I'll just put a new line so endl and a semicolon so let's now execute this F9 so here if you see you have all the numbers from 1 to 10. so that is because of this so what if I put less than 10 less than 10 is when it goes to 10 it's going to break right so now you know the output it's going to come till nine so F9 so here you have numbers from 1 to 9. um what happens if I remove this condition as I told you you will be going into an infinite Loop so what it feels like it it feels like something like this so you can see it's just going on increasing it went to four thousand five thousand six thousand it won't stop it's just going on just printing the numbers just because I don't have a stopping condition it doesn't know where to stop it's just going on going on it goes up to that whatever that value is it's 2 go into 10 power 9 or something and then it's eventually going to cycle back and this process will continue it's we're never going to stop so to stop such a loop you can either directly close this or press Ctrl C it's going to stop so those are used for Loop and C plus plus uh there are other type of usages as well so instead of putting the counter here as I told you you can put it over here so if entire equal to 0 and then here I will just put a semicolon and then I'll just put the condition over here and then I plus plus so what this will do is it is automatically understood that I am using is my counter and once it goes up to 10 it's going to stop so it's just going to give me the same output it's going to give me 1 to 10. and what if I you cannot remove this condition because once you remove this condition uh the loop is going to be infinite and one other thing you can do is you can put this thing inside here so this also does the same thing only thing is that this statement becomes this uh statement of the loop these statements are executed in an order so what happens is first this statement is executed let me number them down so first this statement is executed then this statement is executed so all these statements whatever is inside the block then this statement is executed let me number it as 3 and then it is checked over here so this check is performed at the last so once if it is true it is going to again go there and again this condition this statement will execute then this check will happen and then again if it is true this Loop will continue that's how it goes another thing you can do is you can actually omit the condition also there is a way to actually stop the look without the condition also what you do is you just put two blank semicolons and then to stop I will write if that particular eye is greater than or equal to 10 so or sorry greater than 10 because once it is greater than 10 I mean once the I goes to the value of 11 the look should stop right so what you do is you just break remember this break we use in switch case statements that's the same break this is actually a jump statement so this is how it is used for breaking out of an infinite Loop for braiding breaking out of a loop at a particular point of time so we will be talking about these jump statements in our next video so this is how break works you can you also have continue so that we will be talking about in the next video and now I will just increment the value so here this is the same exact Loop so if you just execute it you will be getting the output so here you have one to ten numbers so here I see because I have 0 over here so I'll just change it to 1 here you have numbers from 1 to 11. now why did this happen that's because I checked after printing this so that's a logical mistake that's not the fault of the loop I just forgot to put it before printing it so once it goes to the value of 11 it should break right so if it is less than uh sorry if it is less than or equal to 10 then only I should print so first I need to check if it is not greater than 10 if it is less than or equal to 10 then only I need to print so this Loop will execute expected in this video we'll be looking at while loops and also we'll be learning how to work on patterns so by patterns I mean we'll be printing some text in some fancy way like we'll be making shapes like squares or rectangles so we will be taking those shapes from the internet and we'll try to replicate the same onto our console so first let's look at while Loops in the previous video we saw four Loops right so the only difference between for Loop and while loop is the condition so in while loop the condition is must in for Loop if you skip the condition it goes as an infinite Loop but in while loop you cannot skip the condition the way you write a while loop is you put while and inside a pair of parentheses you define the condition and then you have a body where the body is defined by the two early presses and inside the body whatever statements you write belong to the while loop again if you want to execute only one condition you can skip this braces and you can directly write the statement beside this Loop so now how do you make an infinite Loop if the condition is so much whether you can put a condition which always stays true so something like 1 equal to 1 so this condition will always stay true and this will become an infinite Loop or you can either use the Boolean true that is t r u e the word true or you can use directly integers also so this is a possible only languages like C C plus plus Python and all so in Java integers and booleans are separate so you need to be sure whether the particular programming language supports integers as booleans so in C plus plus integers are supported as booleans so 0 is considered to be Boolean false and any other number except 0 is true so you can click any number from the integer range but generally people tend to use one as true because uh 0 and 1 make the binary numbers so generally people use one as true zero is false but you can basically use any number X Sub 0 for making it as true so let me give you an example over here so let me put some number so minus 120 which is not 0 and if I try to print some message like welcome to program knowledge and let me put an end line after that statement so now if I try to execute it if I print F9 so here you see it's going as an infinite Loop so you can put any number over here but if I put 0 and try to execute it you will see that nothing happened because 0 is false so this whole Loop is not executed so to make it execute a finite number of times what you do is you put a value over here something like int let's say steps equal to 10 or you can start the steps from one you can go either way you can go from bottom top or from top to bottom you can do it either way and inside the condition let us print it 10 times so while step is less than or equal to 10 that is while uh this particular value stays less than or equal to 10 that is I wanted to print 10 times and then I'll increase the value of tips every time so steps plus plus or you can either do steps equal to steps plus one so both are same you are going to do either of them so now this will increase the value of the steps one by one so I will be getting this uh message 10 times so here you can see the message has been printed 10 times you can do this either other way also so that is basically a common approach used by competitive programmer so I think competitive programming the number of test cases are defined so they will tell the number of test cases like they'll be telling that I will be asking 10 queries and your program needs to answer those 10 queries so generally people tend to use that so let's say this is the 10 queries so what I will do is I'll just write step minus minus so here this operation is getting performed right over here and since this is an integer which is not 0 it is going to be considered as true so this a shortcut kind of thing so this will also make the loop Run 10 times so generally while Loops are used at places where you don't know how many times the loop needs to be executed so generally people use this kind of statements to run the loop till the condition stays true or you can do it with a for Loop also you put an infinite Loop and then break out of the loop when time come so either way you can do it so that's all for while Loops let's not talk about the patterns so let me go into my browser and search for some patterns let's say see programming pattern uh let's go to images let's pick up some simple ones first so here you have this half pyramid so the way it goes is one one two one two three one two three four one two three four five so first let us replace these numbers which just starts so first we'll be making this particular triangle with all stars over there so you have one star two stars three stars four stars five stars and this will continue up to how many hour rows the user wants so this is the first row second row third row fourth row fifth row so now let us try to code this one so let me just uh put what we are going to do here so we don't need this let me put a multiline comment and we'll be printing something like this we will have one and then two stars three stars four stars and then five stars so first we will try to print this and then the user can decide how many stars he wants to put it so now if you consider this one what we will be doing is first we will be talking about this one so Here If You observe we are going for first row we are going to print only one star for the second row we are going to print two stars for the third row of these stars and so on so here the way you identify the row and the column there you need to identify a relation between the row and the column so here relation between the rows and the columns here so columns is basically the number of stars the relation is that the number of stars in every row is equal to the row number itself so the way you do that is we are we we will be using nested Loop so the nested Loops are nothing but a loop inside loop so let me show you as an example so here let's first take the number of rows so let me call the variable as row itself so intro equal to let's say 1 and then flow is less than or equal to five let's first make it for five rows and then we will extend it for n rows row is less than or equal to Phi and then rho plus plus so now you know that this particular Loop is going to run n times so whatever is there inside this block it's going to run for n times so now what I'm going to do is I'm going to run another loop inside this Loop so now I have the loop right so now I will be printing one line two line three line so just consider this as every separate line so now I need to determine how many stars I want to print so those number of stars are going to depend on the row number right so I'll print another I'll give another loop so for INT let's say Stars equal to let's start from 1 and then the number of starts is going to be the row number right so star is less than or equal to rho right so if if we are in the third row we are going to print one two and three right so less than or equal to row and then you are going to give Stars plus plus or Stars equal to Star Plus One whatever is convenient for you then what we are going to do is inside this particular Loop we are going to print the Stars right so see out uh we need to print the star and you know you don't need the space or any new line right so the number of stars will be printed one beside the other so what this will happen when the first row is one you will start from one and then we will check the condition one is less than or equal to one that is true so it will print one star again this this will get activated so one will become two now and this condition will be checked so 2 is not less than or equal to one so because the row is one so this particular Loop will break and then it will go to the next row so before going to the next row let us just print and end the line so that we get to the next line so now what is happening when this particular first iteration is finished it will just go to the next line and then the row will become 2 because of this condition so 2 is less than or equal to 5 that condition is checked and then here it will start from one so one is less than or equal to two one star is printed again it will go so 2 is less than or equal to 2 so again another star is printed and then this condition will be make it three so three is not less than or equal to 2 so this particular Loop is broken and it will go to the next line so if you just execute it you will be getting your output so here you have one star two stars three stars four stars five star for n Stars you are just going to ask the user so that's pretty simple right so you can just ask enter how many rows you want something like that so the end user will enter so in let's say number of rules and then see in number of rows so here I have number of rows so here what will happen for rho 1 to row five now I'll just print number of rows now let's execute this program it's asking how many rows you want I want 10 rows so if I just print it so here I have row 10 where there are 10 Stars so this is what is a basic pattern thing now we'll extend the pattern we'll extend the difficulty so let us try to print this one so what is happening over here you are getting one one two one two three something like that right so why is that happening that is because of this particular Loop right as I told you the number of stars which are getting printed in each row is because of this inner for Loop so outer for Loop just manages the row so this particular rows which is one two three four five these rows are managed by the author follow and then the content inside each row like just one two and three so these contents are printed by the inner for Loop so for printing these things what we need to do here we just need to print instead of star we just have to print starts over here because stars is directly an integer so we're directly printing the integers we don't have to do anything so first the stars is one so it will print one then it will print two or two point three let's look at that I want five rows so here you have the outputs right so one one two one two three one two three four one two three four five like just the number of iterations were just printed that is why it came like that so let me close this so let's try the second one now so it is going from five to one it is just a reverse of it so what we need to do is we need to go from a five to one so what we are going to do we are going to start the row at five right so let's start it 25 or let's make it generic let's just print the number of rows over here and row is greater than or equal to 1 that is I'm going from five to one uh well the first Loop doesn't make any difference because from one to five or five to one there are only five iterations so these are acetone for number of rows so inside the rows you need to manage the content right so because of this statement I wrote Because if it was something like five four three two one the inner loop should start from the highest number right so since it is one two three four five I am starting from one so if it was five or three to one this particular Loop would have started from five because uh it just the value which is getting printed over here only depends on this particular inner for Loop so here uh this Remains the Same and now if I just try to execute it I am getting an error what is that okay it is not star it is Stars and F9 so enter how many rows you want I want five rows so here you have that output you have one two three four five one two three four one two three one two one so this is how you print basic patterns let's take one difficult one um let's say this one right so this one is you can try out this one this is nothing but just printing spaces till the next number so suppose this is the second row so you have no space over here and then you got the third row so there are two spaces and then fourth row so you have three spaces on the fifth row you don't have anything for the last row you are just going to print all the numbers as it is so you can try this one and this one is a similar one as this one so we'll be talking about this one so here what is happening is there is a space actually so what you do is for any kind of pattern you're just going to divide it into a matrix kind of fitting so if we just put a matrix or whatever managed you can divide these things into rows and columns so if you just put rows and columns you will be seeing that this first row there are uh let's say step now one two three four spaces right so after four spaces the number is getting printed that is if there are five rows so there are one two three four five rows right so the if there are five rows what is happening is after five rows for every five rows uh there are n minus one uh spaces uh before the first element right so if n is pi you have four spaces before the first element and then the number of spaces are decreasing so n minus two spaces that is four three spaces for the second element two spaces for the first element one space for the uh fourth element and then zero spaces for The Fifth Element so Fifth Element is directly starting from the edge so let's first uh manage the spaces so here uh we won't be requiring this so okay we need the a two Loops but this one this particular logic will change so what will happen is Let's uh first deal with the spaces so let me name it as spaces so now when I have um the first row my spaces should be four right so I need to start from the highest number that is I need to start from the number of rows and this row number uh it it could be either way so I prefer going from the please to the highest so lowest num less than number of rows and then row plus plus so for the spaces what we are going to do is let me clear this down here for the first row we have four spaces that is for taking ns5 that is number of rows as five we are going to take uh five rows as our example so we will be printing the same thing and then you can extend it so what is going to happen is for for number of rows you are going to give number of rows minus one spaces so if it is pyros you are going to give four spaces for the first element if it was seven rows you would have given six spaces for the first element something like that so now let us print this thing what we are going to do is for number of rows we need to run a loop from one to number of rows minus one so here when space is equal to 1 and then spaces is less than or equal to uh number of rows minus 1 and then spaces plus plus and then since I have only one statement I'm just going to write it over here I'll just print a space without a new line because once it's a new line it's going to go to the next line we don't want that to happen we are just dealing with the values right now and then after printing this what do we need to print as the number so here we are just starting with the row number and then we are going till the ah so we are going till this middle value right so we are just going like one two three and then three four five and then four five six seven basically what is happening is the first and last values are a bit uh similar and then this middle value is just the progression of this so for every row this particular value that is the maximum value these elements go up to and then decrease will depend on the row number so here if you see for the first row uh I'm not going any further for the second row I'm just going one and one number further for the third row I am going two numbers further for the fourth row I am going three numbers further but fifth one I am going four numbers so five plus four nine four plus three seven three plus two is five two plus one is three and then one plus zero is one that's why I'm staying here so for that we again need a loop so for uh let's call it something else now uh let's say the number right so for end number equal to let's start from the row number because it's starting from the row number right so the first row is for starting from one second row starting from two something like that so for low number equal to the row number and where should it go it should go till row minus one right so number is less than or equal to rho minus 1 and then again number plus plus and then here since I have only one statement I'm not using that Curly braces so see out what number right so till where did we do we did till here right so we did not print these statements so we did not print any of these statements we just printed this particular triangle in this fashion so we just have a space and then one then space and then two numbers space then three numbers something like that so now to deal with this numbers we need to print these numbers also right we cannot just omit this so we need to start from this particular number and go till there so how do I know what is this number we don't know that right we we know that it is rho minus 1 so if it is sorry it is rho plus rho minus 1 what I am saying is this particular highest number till where it gets to is rho plus rho minus 1. so this particular equation you can get that right it's just from observation that let's take this row this is the fourth row so that is row equal to 4 4 plus 4 minus 1 that is 3 so 4 plus 3 that is seven so this is the highest number we will get so from there we need to go till there go right so for first row we are not going to go anywhere so row plus rho minus 1 is just one so we need to go from 1 to the highest number uh sorry 1 to the row number which is one so we don't have to print anything over here so we are already at one so we just break out of the loop so here what we'll do we'll we'll be at 3 and then from 3 we need to go to the row number so from 3 we need to go to 2 so we need to print this particular two and then again for from fry we need to go to 3 from 7 we need to go to four so just we are just subtracting 1 1 over here so we'll like write that Loop uh we'll call it back number something like that so let's say um that second triangle let's just call it second triangle uh let's start it from that highest number what is that highest number uh let's start it from highest number minus one because uh you don't have to print that highest number again right so if we are at 3 you need to start from two we are going in this fashion we don't have to print the Spy again right so we have already printed this 13579 already we just need to print these lines so how do we do that we just start from uh as I told you the equation for that rho plus rho minus 1 and minus 1. right so this is this so if you can uh actually simplify it it comes as 2 into rho minus 2 so you can write that also or 2 into rho minus 1 that is also correct so you can directly write it as 2 into row minus 1 or uh I'll leave it just like that so that you understand so this row into rho minus 1 is actually the highest number we'll get to at every row so rho into rho minus 1 and then the second triangle goes up to that particular row number right so greater than or equal to rho and then second triangle minus minus and since I'm writing only one statement I don't have to use that Loop or that braces so I'm just going to print that second triangle element whatever it is and then I am going to go to the next line so these three Loops inside this particular Loop uh is just makes a complex kind of a loop but it isn't complex if we just break this down so let me comment it down here these are for the spaces or for the starting spaces and these are for the starting 10 numbers right for every row they are if you take the nth row there are n numbers right so here for the first row there are only one number and then for second row your two numbers third row your three numbers so I'm talking about this particular triangle so this uh let me just call it the N numbers or n row numbers something like that and this will make the last n minus 1 numbers so here if you see for the first row you have only one uh for the second row you have only one element for the third row you have two elements I'm talking about this particular triangle now so this should give us the expected output let's run and see this uh so till where did he go he went up to five right so he he took five rows let's type with five rows and uh okay something is wrong over here we did not get the output tax expected so what happened um yeah so here what happened is I just took rho minus 1 so this particular look never ran what I should have taken is I had taken this particular expression so that's a mistake I did so it is not row minus 1 it is rho plus rho minus 1 and then now if you execute it you will be getting the output okay I did not close this so 5 and then uh here you have the output so it is one two three two three four five four three five four five six seven six five four now uh the numbers are correct but if you see the placement is wrong that is we messed up the spaces so let's see where we messed it up when the row is one it will go from number of rows minus one to one so now what is happening is if the row is one only then this condition is satisfied what about the next row and the next row so this should be number of rows minus rho and then spaces should be greater than or equal to one what I did is if number of rows is 5 and I'm in the first row so 5 minus 1 is 4 I'll be going from 4 to 1 and if I go from if I go to the next row that is second row so 5 minus 2 that is 3 I'll be going from 3 to 1 that makes it three spaces so like when it will continue so now we should be getting our expected output if I just put 5 yes so here you can see the exact same output we got over here so so this one we made one two three two three four five four three so there's a space between the numbers we can do that very easily what we are going to do is we are just going to add a space between over here and uh over here also whenever we are printing the numbers we are just going to add one space over here and if we execute this 5 so here you are going to get the output as expected so here you are having the same thing so one two three two three four five four three so now this one looks better than this that is because of the num spacing over here since I gave spaces over here I need to give two spaces over here for every uh thing so now what I mean is since uh there's a space between the numbers also so for every row suppose I'm going for the first row I should give 2 into those number of spaces so Suppose there are four spaces in between I I if I give eight spaces it will have been better so let me show that uh there's only one slide modification to make it look like that what we need to do is instead of number of rows minus row I am going to just go from 2 into this particular value number of rows minus low and now if execute it let's say 5 so here you are getting that particular equilateral triangle kind of a thing so here if you see so what I meant was in the last uh when the last time when we did not have a space between these numbers what was happening was uh since there are no spaces it was looking good but once we have spacers we are having a space between every number right so we need to increase the number of spaces over here also so I just made it two times so that it looks exactly like this so you can try these ones also this is tested uh implementation of this what is that is for every row you're just omitting the middle numbers you're going from the one to that particular the highest number of the true that is the row number and you are just omitting the in between numbers on this one also so and uh for complex patterns such as this one so this solid diamond or you can try this one also that is this number printing so one one two one two three one two three four so this one is just a implementation of these two triangles so what we did was this particular triangle is first printed so like one one two three one two three four something like that and then this whole Loop is just inverted again so you need to break the problem down into simpler so simpler problem so here if you you see this particular Diamond you can break it down into this particular triangle that is the upper triangle and then lower triangle if you just see it you will be able to understand you will be able to differentiate between those two shapes so you need to break down the complex shapes into simpler ones and simpler ones you pretty much can try all these shapes so these are just implementations so you can try it just like this so these are the number of so this is how you work with pattern so again for a review this particular first for Loop that is the outer for Loop let me write it down here um or let me go so outer for Loop controls number of lines or rows so the number of lines or rows are controlled by this outer for Loop and the content is always controlled by the inner for Loop or Loops it depends like in this one it took three Loops for controlling the data but uh if uh it was a simpler Loop such as the first one it was only one Loop so whatever it is the inner or Loops always control the data and the outer loop will control the row or the number of lines so here if you will need to actually kind of form a relation between the row number and the data so every time there will be a relation so that is why it's called a patent every time there is a relation between the row and data you need to identify that particular one and you need to work up on your logic to form such patterns in this video we'll be looking at do while loop and also the jump statements in C plus let's get started in the previous video we looked at for loops and while Loops right so let me just write down their basic structure so you have a counter you have a condition and then you have a growth rate of for the counter so that this particular condition becomes false at some point of time right and for while loop you define the condition inside a pair of parenthesis and then you have the body of the loop where you define the growth rate of that particular cut counter right so now if You observe if this particular condition is false at the beginning itself this whole Loop is not going to run right so what I'm talking about is if I declare some variable like enter equal to 0 and in place of this condition if I give I is less than 0 and this growth can be anything so let's say I equal to I plus 10 something like that so now if you see the starting value of I is 0 so once this condition is checked it is false so this whole Loop is not going to execute itself so if I write something like uh this is the for Loop statement so this whole statement is not going to be executed at all let me just add a new line also so this is the escape sequence of the new line so now the same will happen with the while loop also so if I just say in J equal to 0 let me just write down the same set of conditions so J is less than 0 and the growth will be J equal to J Plus 10. right and let me write on that particular statement so see out let me just copy this thing foreign and this one will be the while loop statement so if I execute this particular program I won't be getting anything so now if I just try to execute it you will be seeing that I have a blank output right I don't have anything over here so what if I want to execute this particular statement on what is a particular set of statements inside the loop at least once right so sometimes you are given a menu and then you are asked to choose something from that right so you uh you have something like this you have choose your option and then you have first one second one third one and uh so on so this will continue and then you will be given a choice where you can enter your choice so in programs like this these are called menu driven programs these are called menu driven programs and in programs like this what happens is you need to execute this whole set of operations at least once if I directly press 3 over here let's say 3 means exit right so you have some functions in one and two and three is equal so if I press three I should exit out of the program but for that to happen this whole set of code should execute at least once right so in this kind of loop that doesn't happen it will directly stop uh when this particular condition is false so in the beginning itself if the condition is false it is going to break out of the loop so in uh such kind of situations what we are going to do is we are going to use the do while loop well you can do that with these Loops also by using the jump statements but since I have not talked about the jump statements till now I'll be talking about them shortly so now we will be using the do while loop do a loop is relatively easier to use than jump statements so what we are going to do is you are going to write do and inside this you will be defining the body of the loop so this is actually a loop right so here inside you will be defining the loops body and then you will write while and then the condition right so what happens here is first you check the condition and execute the statements in these Loops right in this Loop what happens is first you execute the statements and then check for the condition that is the only difference between these four and while loops and this do while loop uh let us execute this particular same program so let's take int k equal to 0 and the same condition which is case less than 0 and let me just copy on this particular statement inside the loops body right and this is the do value now if I execute this particular program you will be seeing that this has executed once this is the doway look what happened is before checking for case less than 0 it first executed whatever is there inside this and then it went for this particular condition check which it turned out to be false that's why it broke out of the loop so in places where you need to execute the loop at least once in such cases where you have this kind of menu kind of thing you you are going to use the do while loop it is going to be very useful and very easy to use so let us quickly write a small menu driven program I will show you what I'm talking about uh so this one is going to be a menu driven program for uh choosing between addition and subtraction so let's say I'll do and then inside this I'm going to ask for your choice so uh choose one for addition and two for subtraction and I'll be getting a number so in Choice let's call it and then C in choice and then now I can switch the choices as I told you so I can use either switch case or if else I will go tape files because I have only two numbers to compare so if Choice equal to 1 then what you are going to do is you are going to ask for two numbers so enter number one and I'll get a number in n1c in N1 and the same thing goes for number two also and 2 and 2 and over here number two uh well we can actually put this thing outside because for both addition and subtraction since we are dealing with only two numbers I'm just going to put these things outside because it really doesn't matter whether the choice is one or two right we are anyway going to ask for the two numbers for age of addition or for subtraction only thing is the which is going to changes our print statement so I'm just putting it outside the conditions over here and then if charge equal to 1 what we need to print is we need to print the addition or the sum so since I have only one statement I'm going to skip those curly basis and then uh the sum is we can directly print the sum or you can even store it inside one of the variables and then print it I'm not going to do that and the same goes for the difference also right so if Choice equal to 2 then you print the difference so difference is N1 minus N2 and over here charge equal to 2 and you can use else if over here so instead of checking if you put two if what will happen is it will first check for this and again check for this but if you put an else if what will happen is if this condition is satisfied it won't check for this one so or if you have a hierarchy of conditions so if you have 10 conditions if the second one is satisfied it will directly skip to the next iteration so what what happens over here is if you put all ifs or all 10 ifs even if the second condition is satisfied this is going to check for all the 10 conditions so else if it's a better choice when you have two distinct choices right so now after printing this what we are going to do is we are going to ask for the user whether he wants to continue or not so do you want to continue foreign so now once you take the character what will happen is it will be limited to the scope so if I write something like care let's say can and then scan stands for Content I cannot use the word continue because it's a keyword I will be talking about that shortly let's just say Khan means continue right so now if I just taken Khan what will happen is this particular variable will be limited only to this scope the highlighted braces which you are seeing here so if you want uh to compare that that is not possible right because the while which we are riding is outside this one right so while we write outside this body of the loop so we need this variable to be accessible outside the body of the loop so we don't want to access it outside everything else right we don't want to uh access this variable outside everything so what we are going to do is we are just going to put this Con over here inside the main function so what will happen is it will be limited to this main function but since we are not dealing with other functions we are just uh using this particular one as a function variable that is it belongs to this particular function and then it can be accessed from anywhere in the function since this y also is inside the function it can access this continue variable now if you return it over here it could not have access to it so now we are going to do it until he says no or till he keeps saying yes both are equivalent statement you can do either con is not equal to s or you can say or sorry con is not equal to no till then you need to continue or else you need to continue till he keeps saying this so both of them are right you can do either one of them and now if I execute this so he's asking for the choice I'm going to say one enter number 1 12 12 so the sum is 24. I want to continue yes if I put 2 and then 12 12 so the difference is 0 and now if I press n it is going to stop so now you see uh how the do I look can be used so in if you are using the four or while loop that is also possible but it's quite clumsy to implement uh as compared to this particular do while loop so now let's talk about the jump statements I clear this we don't need this so the first jump statement we are going to look at is continue so what continue does is it will skip a particular iteration so let me show you an example so for entire equal to 1 is less than less than or equal to 10 and I plus plus and inside this loop I am going to print something let's say let's just print type right and then a new line also now you know the output right it's just going to print all the numbers from 1 to 10. so now what I need is I don't want the value of Phi to be printed in the output I want all the numbers except 5 so one way you can do is you can do something like if I is not equal to 5 then you print all these things so this is also one of the ways to get the output what I actually uh said so here you can see all the numbers are getting printed except file but in some scenarios where uh what we need to do is when instead of writing everything in an if else Loop we can directly skip the statements if that number is not 5 right sorry if the number is 5 we what the mean is if I have some set of statements over here so let's say um we have this one uh statement one and then I have another statement over here so statement two uh let me add a new line over here so that you can differentiate so after every uh I there is going to be a statement one in statement though but if I want that all to be executed only when I is not equal to Phi what I need to do is I need to put everything inside a particular inside the body of if Loop right so I need to do something like this and then here so inside this body of the if loop I am going to get all these statements printed only if the number is not fine the easier way to do is what we can do is we can skip those statements right so if I is 5 we can skip those treatments so the way you skip the statements is this stage as it is but once I equal to 5 what I am going to do is I'm just going to hit continue so what this will do is if I is equal to 5 it won't care about the next statements it won't care about any other statements inside it is just going to skip the iteration and go over to the next one so this is true with every Loop so even if you have the continue inside the if and then you have some statement over here let's say uh continue is triggered something like this so this statement won't be executed at all the once the continue is encountered it is directly going to skip everything and just going to the next iteration so now if I execute this you will be getting the same output okay I did not put this yeah now if you see I have one two three four and then Phi did not print anything at all and then six seven eight nine ten right so that is the use of continuous statement it's just going to skip the statements once it's not required so every statement is skip so next thing we are going to learn about is break break is almost same like continue what it does is just going to break or continue it's just going to skip the iteration it is just a break is going to completely skip the loop itself so once break is encountered it's just going to come outside the loop so if I write something like um the loop has executed this is outside the loop right so this particular statement is outside the loop and now if I execute it you will be seeing that all the statements are printed only up to five once Phi is encoded it has directly broken out of the loop and then it says loop as executed so that is the use of break statements so you you have encountered the break already right and switch case so this is what happens once a case is satisfied you are just going to break out of the whole switch case if you don't break out what is going to happen is it's going to follow all the statements which are associated with every switch case below that order so the next statement we're going to learn is about the go to statement so what go to is it's basically a connecting kind of a thing so you have a label so let's call something like let's call it label and then you have a set of statements inside this label so you have C out uh hello and then see how so you have these two statements right uh let me just add a space over here so these two statements are going to be printed side by side I don't have a new line over here so now what will happen is I want to execute these statements again and again when I press something so remember the do value we can do the same thing with the go to statement also it's not exactly a loop but it can act like a loop so let's say I have some variable over here let's call it int I so I so I'm going to take in I and then if I is equal to let's say some number let's say 12 or 7 something like this so if I use this particular number I want the whole thing to be executed again right so what I will do is go to this particular label what this does is it will directly switch the control from here to directly over here it will directly go from here to here or you can go from here to bottom also it can go from this particular place to any place in the whole program or in the whole function you can uh directly skip all the statements you can either go backwards or even forwards it completely depends upon your program but here what will happen is till I press some other number except seven this whole statements are going to be repeated again and again so once I press enter you are saying welcome to programming knowledge I press 9 enter so here you see it stopped now if I press 7 it's going to continue again and again so let's say 7 enter you see the same set of statements have executed seven seven till I press seven it's going to repeat and then if I press something else it's going to stop so that is about the go to statement and then you have another statement called exit statement so what exit does is it directly breaks the whole program your program is going to end but it's not a function directly so you need to have another header file to execute it so that header file is known as the standard Library header file so it is stdlib which stands for sandal library but it's a c header file so it's a name and C plus plus is cstrb so you need to type cstdlib so this is a header file and inside this you have the exit function so let's say I want to exit right after this one so I'll just press in exit one means exit with an error and Exit 0 means it's just going to exit without any error so let me show that if I execute this you can see it just ended with return 0 that is the exit code which I passed over here so it went on without any errors but now if I press one and exit so here you can see process returned one that is the exit code so one main sum error right so here you can see it's terminated with a status one that is red color it means that it Terminator are normally from this video on which we'll be looking at functions in C plus plus so till now we have been using only one function right that is this particular main function whatever we have been writing we have been writing inside this function and then we have been executing it so from now onwards we will be understanding how to work with multiple such functions and how you make your program much more efficient and readable so first things first what is a function so if you remember your basic math classes you have come across something like y equal to sine X or Y equal to X Cube x squared so all these things are functions right so if you look at the mathematical definition of a function what it says is it will take in a set of numbers and then it will map every element in that set with exactly one element in the other set so if that is confusing what it basically means is it it can take n number of things inside this uh definition that is if I am defining a function as y equal to some f so inside this I can take as many elements as possible but the Y is going to be only one value so it can only compute something it can work on the mathematical operations and then it will give you exactly one single output for y so if you look over here so y equal to sine X there is a series of sine X right so it will it will be something like 1 minus 1 1 factorial something like that so that computation is done on this particular X and then that only one value which is in the range of minus one to one right so minus one to one inclusive that particular value is written to Y so if you take an x square it is going to take some number X and then it is going to do some computation that is it is going to multiply itself and then it will return back your y so this is again only a single number so again if you take the equation of a line let's say y equal to MX plus C where m is the slope so here again I can define y and two or three different ways also so one first base let me write it down here first way is that it can it is going to take only one input that is y equal to f of x so where uh let's say f of x is going to return MX plus c and the other way is you can say y equal to F of let's say G of M comma X where it's going to take in the value of M and X where C is already defined inside the function and it's going to return you MX plus C right the other way is y equal to H of let's say m comma X comma C I'm going to take all the values and I'm just going to compute that so that is why where uh sorry over here it is G of X and H of this particular sorry this is M comma x h of M comma X comma C is going to be MX plus C so uh don't worry if it is really mathematical what I am trying to say is it is it can take multiple inputs but it is going to give you exactly one output so in this case it's going to give you exactly one number right that that is the y coordinate of this particular line if you're given the x coordinate it's going to give you the y coordinate or vice versa you can and Define it the other way too so that is exactly how functions work in programming also so let me write it down here in programming a function can take multiple inputs but it can give you only one single output input is basically it could be 0 as well as n number of input you can either give it something or it can perform independently also that will depend upon the function you are writing so enough of the definition of the function now let us look at why do we need functions so here I have a basic program we don't need this I'm just going to delete this and here we have a basic program to add two numbers right so what if I say that I want to ask the user for you know adding these two numbers let's say some 10 times at first you would say you need to copy and paste this thing 10 times now as you are well versed with loops what you are going to do is you will be putting these things inside the loop but if you look at this this is about let's say it's a nine liner code right so if you make a loop the loops body will contain nine lines of code so let's just imagine it's not such a simple program of adding two numbers it's something more than that and what if you are going to solve a particular problem which say which contains let's say 100 lines of code so if you're giving that code to me I won't understand what you're doing right so at the first glance I won't understand what you are doing and then I need to spend some time and then I need to understand everything I need to understand how you are using the variable bills and all and then I will be able to develop on that and the second thing is you will be writing a lot of redundant codes let me put this inside a loop next menu so let's say is less than 10 and I plus plus and this is a loop body right so it starts from here and uh ends over here so here this things are getting reinitialized again and again and again highly inefficient and then this particular competition is going on so basically this looks clumsy and it decreases the readability and then it will drastically increase the redundancy of the code so by using functions what you will be doing is you will be asking these 10 lines to be executed in a separate kind of environment where once the job is done you will return back to this particular environment so it's not exactly an environment but it's actually switching your control to some other thing right so it's like working in a team so instead of doing everything by yourself you will ask your team member to do something else for you right so that is how you use functions over here so let's now talk about how to work with functions how to define functions in CPS plus so in this video we will be just looking at one definition of a function the subsequent videos will be exploring more on these so a very basic implementation of function is that it won't take any inputs and then it won't give any output right so that is a very basic implementation of function so how you represent number of inputs and number of outputs and how you define a function as in this way so first thing is you write the return type of the function so what is a return type return type is basically what data it is going to give out after performing the job so if in case it's not giving anything you have a data type for that also right so remember from the data type video it is void so if you don't have anything to return you are just going to mention it as world and if you have anything to return you are going to put it as it so here now if you have a question why this particular main function is end if we execute this code you will be getting some code over there right so if you remember let me just quickly execute this code if I build and run this so let's say 12 12 and then 24 okay I'm executing this for 12 times 10 times let me just remove this particular Loop and then this one also I'll equal so here if you see it it returned with some code right that is zero so that is from this particular main function so that is why you were first writing return zero remember when the code block gave you the template code it had this return 0 over here so in case some anomaly happens while execution it will give different return codes that is 1 or something like that so those codes mean that your program did not end correctly if it successfully reached return 0 it means that your code run successfully and then 0 means no errors so that is why we uh use this written zero so even if we omit it from this particular main function it it does not matter because main is designed to return 0 when it's successfully executed for our functions we need to definitely return something if we put some other variable type I mean the return type except void so if you write something like int let's say add or float add or whatever it is if you write some other data type over here you need to return a data of that particular type to the function which is calling it right so that will be looking later so first we will understand how to work with functions which takes zero inputs and then zero outputs so let me write it over here it takes zero inputs and then oh zero input and zero outputs right so output I mean the returns so it it is going to give some output I'm just going to put everything inside the function so it is going to give you some output output as something on the screen return is something where you get back something right so like y equal to f of x you are going to get some value of y right so I'm what I'm doing here is I'm just calling f of x I'm not giving any y to that so I won't get any value back but I will get the job done over here so here for zero inputs I need to put y because I'm not going sorry for zero returns I need to put void because I'm not going to give out anything to the function and then for inputs I'm just going to leave it blank right so you need to put the parenthesis this parenthesis is exactly the same thing as your mathematical parenthesis inside that course all the arguments you are going to pass in through arguments or the inputs you are going to pass through the particular function for which you need a particular output right so I'm not going to pass in any input for now and then the way you Define function is you put this block right so notice that I'm writing the function outside this main function because this is a separate function and this becomes another function so if you can write inside this particular main function also but that is a bit clumsier and it has its own problems we will be talking about that at a later stage so for now we are going to write all our functions outside the main function right so you need to give a meaningful name to the function right so I forgot to mention about this this is the function name so you need to give some name which says what the function is doing you can't just give something like let's say x y z so something like that so you you yourself won't understand what you are going to do with that particular function so you need to give some value name so that you understand what that function is doing and it has some meaning related to what it's actually doing right so now what I'm going to do is I'm going to just cut everything from here and then put it inside this right so what it means is if I call add all this function all these statements are going to get executed right so how do we call that function we don't have any output right so I can't call something like y equal to add right because I'm not giving any return types I'm just uh putting it as white void means once the job is done it will go come back over here without returning anything returning this it's just going to give you some value right so it's not going to do that it is just going to continue with the flow so I'm not going to mention anything over here but just call add and then put a semicolon over here so notice this is the this is called the definition of the function so that is uh let me write it over here function definition and this one is called the function call right let us look at the execution it's going to do the same exact thing it is going to ask for two numbers and then it's going to return with the output so now if you look at the main function it's much more readable right you understand that you are actually adding two numbers so if we just look at this particular code it will be easier for you to understand as well as debug let's say you are writing a very big program where a particular part had a mistake and then instead of tracing the whole program you could actually trace the only this particular part of the program right suppose let's say I did not write the logic properly I put minus over here and once I execute I will get to know that instead of adding it is actually subtracting so I'll come back over here I'll just change this particular thing and then the job is done it is error free right so that is why we use functions and this particular approach is actually called procedural programming so what we are doing is we are dividing um our particular problem into procedures so procedures are nothing but functions and then we are actually solving everything on its own and then we are actually combining everything and then giving out the result so that is what procedure programming is and that is how we use functions in C plus plus so now if I just remove this particular thing and then put it over here right after the main function now what will happen is if I try to execute it you will be seeing that I have an error so what is that it says add was not declared in the scope what it means is that this particular ad it doesn't know that there is something called add in the particular program because add is defined by us right it is not a property of the compiler it doesn't know what address we actually mentioned that we are going to use something called add and add means you need to do all these things right so actually tells something like that you can either Define the functions before the main so that is as I executed right now another thing is that you have something called the Prototype process function so what a prototype message you put the return type of the functions and then the function name and then inside a pair of pencils the parameters list whatever you are going to use as the parameters for the vertical function and then you put a semicolon so it's just like uh popping this particular thing and then pasting it over here so one thing is that is of parameters you don't have to write the variable names to but since I have not discussed about the parameters I will be discussing about them in the next video so at that time we will be seeing that in the Prototype of a function we don't have to actually put in the variable names too we just have to put in the data type so for now we are not going to have any inputs right so we're just going to put this over here and then put a semicolon over here so what this does is it is called the Prototype and it will tell the compiler that hey I have a function called add so whenever you have an ad over here you need to refer to this particular add function so whenever I have uh something called add over here I need to refer back to this particular function which is actually the body of that function the definition of that function so whenever ad is called you need to execute all the statements line by line if I now execute it I will be getting an error free program so I can write something and then I'll be getting the output in the previous video we saw how to create an independent function right so this add function right here this is an independent function all it means is it is not going to take any inputs and it is not going to return you anything it just performs the task which it has to do when called that's it so in this video we will learn how to create dependent functions most of the time we'll be using dependent functions we will be using these kinds of functions also but these are very rare we will mostly use dependent functions we just pass it some parameters we ask the function to do something and then get back the value which we intended to so uh how to make this particular function dependent that is I need to pass in some parameters over here let's say 2 comma 3 and then it should only add these two numbers it should not ask the user to enter two numbers and then only work on those two numbers I want to work on these two numbers which I passed in as parameters so how do we get these two numbers inside this function so the way we do that is we Define the parameters the way we Define parameters is we first put the data type of the parameter and then the name right so in this case uh the data type would be end and then the name of the parameter let's just say num1 right and then we have another integer so if you do like this like you declare variables sometimes you do this right so int a comma B well this is going to work only if you are declaring variables here you are not declaring variables here you are specifying the parameters right so while specifying the parameters it is compulsory that every parameter be mentioned along with its data type so you need to mention the data type of the second parameter also even though both the parameters belong to the same data type you cannot omit the data type of the second because it's just a continuation of the variable declaration now what we are going to do is we got the two numbers inside this and we don't need any of this right I'm just going to take out these things and then here instead of a plus pu those two numbers are number and num2 so you take num1 over here and then num2 over here and then it is just going to print out the sum so let us execute this and see so 2 plus 3 is 5 so we should be getting the sum is 5 as our output so here you can see the submissive right so another thing you can do is if you want to save this particular value that is if I want to add these two numbers and then keep the result there is no way to keep the result right well C contains the result of num1 plus num2 but C is not accessible outside this function right and is one function and then main is another function well if you want to access this particular variable you need to make it Global that is you want you have to put it outside all the functions and then access it if you remove this then now C is accessible over here you could just say CLC over here and then if you executed here you can see it has printed the value of C but what happens is we don't prefer this kind of global variables the reason is that when whenever the program is getting executed everything is inside the ram that is the random access memory so once variables are out of scope they are automatically deleted and then again created whenever the time comes you need to free up the memory so that other tasks can go on right you cannot just keep this particular variable in the memory all the time so if it is compulsory that you need to keep it then you can but if there are other ways to do that without occupying that particular memory you need not do this because it takes up memory right so the way we do that is we return this particular value back to the calling function so what is written how do you return something to the calling function well the way you do that is you just need to put the return statement over here so you just say return C now instead of creating a global variable like I did before you don't have to actually create something and put it in a memory once you have executed it you can just return that particular value over here so that is the main objective of this add function right you need to take in two numbers add it and you are going to get one integer unit just return it so if I say something like a equal to or let's say sum equal to add 2 comma 3 uh what to expect is these two numbers are added on the sum is coming to this particular variable that is sum right so here if I return it I'll be getting a problem so if I now execute it uh you will see that I have got a problem it says Okay C is not that's because I have written over here uh now let's again run it so here you can see that it says return statement with a value in a function containing void right returning void so as I told you before if you are not returning anything then only you need to use the void keyword or else you have to specify the data type what you are going to return so since I'm returning something I need to specify the data type and in my case it's going to be it because if you add two integers it's going to be integer right so I'm just going to return that particular integer and then here I need to capture that value so let's say In Sum equal to 2 comma 3 and then now I can do this thing inside the main function also so here I will just paste it and sumness in my case sum right now if I execute it we'll be getting the output as the sum S5 so another thing is what if we want to make one of the variable optional so let's say I have another field Also let's say in num3 this is another parameter so here if I just omit that parameter I'll be getting an error so here you can see that too few arguments to this function that is because I have specified three arguments and then here I'm giving only two arguments so what you need to do is if you are having an optional variable you can just put a default value over there so for addition if the default value is 0 if you add those three numbers there's no there's not going to be any difference right so if you just put 0 over here and then I don't pass anything so it will just do six plus two so let me just add the number over here so so num3 also so I'm just going to store c equal to num1 plus num2 plus num3 and then I'm going going to return C so now if I execute it you will won't be getting any error and you will be getting the sum perfectly and if I want to use that variable I don't have to do anything I just pass the number and I will be getting the output so 9 8 is 17 so here you can this sum is 17. so that's how you use default parameters and regarding the Prototype so what is a prototype it is just mentioning the compiler that I do have a function like that in case you did not write the functions definition before calling it so whatever means I have already called this function over here so if I write the definition after calling it I need to specify it or it says that this particular function does not exist so to do that the for the Prototype as I told you you can directly copy paste this thing so Ctrl C and Ctrl V and then put a semicolon this is going to work but what you can do is in case of parameters function you don't have to write the variable names also so you can just skip these things well it's going to work with the variable names also but uh you don't have to put them and you should not pull default values over here so that is there in the function definition in the Prototype you just need to define the structure of the function and you don't have to put the default values and all you just need to put what the function is and what it's going to take and now if I execute it I won't be getting that any error and I will be getting the output so that's how you use dependent functions in C plus plus in the next video we will talk about recursion and different types of passing arguments so here I just pass some numbers right so these are direct numbers so what if I want to pass some variables also so let's say a equal to 2 well in this particular case you can just pass it over here it is going to work well it's int a equal to 2 it is going to work but actually there is a meaning for passing like this there are two methods of passing variables that is passing by value and passing by reference in this video we'll be looking at different methods to call functions in C plus plus so now the question is why do we need different methods to call functions why calling function simply like this won't work always so to answer that question let us take another problem so let's say this time we need to write a function to swap the values of two numbers so what I mean is if I now print a and then B like this what I will be getting as my output is to comma 8 right because a value of a is 2 and value of piece 8. now what you want to do is I want to call a function so let's call that function something let's say uh swap nums so I want to call this vapnams function by passing in a and b i and then here if I then print this particular A and B's value what I should be getting is I should be getting 8 comma 2 that is a is holding the value of B now and then B should be holding the value of a now so let us first try to solve this without a function so to do that first of all we need a temporary variable because once we overwrite a value uh it's gone right so I want to preserve both the values so that I can reassign them so let's say uh pin temp will hold the value of a and then I'm going to reassign the value of a to B and then now since I need the value of a it is already stored in temp the previous value of a so that I can just put it inside the B right so now if I now execute this particular code I will be getting my desired output so now a has become 8 and then B has become 2. now what if I want to Define this as a function so since we are not returning anything it's going to be void right and then uh those two parameters remain the same the name of the function is web nums so swap underscore nums and then this is the logic which goes inside that so control X and then return goes away and then here we have that particular logic so now if I now call this particular function and then try to execute this particular code you will be surprised that nothing happened over here it still is to commit a s value did not change neither did B's so now why did that happen that is because this A and B are not the same ones as this A and B these two are different variables actually even though the name of the variable is same but this particular variable which I have defined over here all the set of variables these belongs to this particular function that is the swap nums function and these two variables belong to this main function so I cannot use this particular variable here or this particular variable here so if if I try to print the values inside this that is uh if I print out a and b inside this particular function it will be swapped over here that is these two A and B are actually so I am not this A and B so to differentiate that let me just put a function over here so that we can differentiate the output of our function from the main and then I will even add an end line over here now if I execute this code so here you can see that in inside the function A and B got swapped correctly that uh a got the value of 8 and then B got the value of 2 but I'll check the function in the main function it did not happen so how do we solve that particular problem well to change these numbers directly or one way is that we can declare declare this as Global variables that is outside all the functions so that this will be always present in the memory but that is as I told in the previous video it is completely uh waste of memory so another way is to do that is we can directly change this particular variable by referencing it that is by going into the address of that variable every variable has addressed in the memory right we are just creating a location inside the memory and then renaming it to A and B over here so if we can access the address of this A and B we can go to that particular address and then change that particular value so in that way we won't be actually copying down this values inside new values over here and then working on those new values that is what is happening over here right once we pass in two numbers what is happening is these two variables are dynamically created in a member query and then these values are getting copied inside these values and whatever happens inside the functions happens on this particular local variables so variables which are actually called from the main function are not going to be affected by this function so whatever you do inside this function that remains local to those two variables only or those set of variables so to actually access the address of a location we need to understand a particular operator called the address operator or the reference operator or the Ampersand operator they are called in different ways so what it is is you just need to put an ampersand over here to access a address of a particular variable so now if I just execute it what you will be seeing is the address of that particular variable so here you can see 0x CD whatever it is that is the hexadecimal address of this particular variable that is a now B will have another address so if I now put B over here let me just close this and then if I now execute it so here you will be seeing 0 x 6 D whatever it is it is another address right both are at different locations so now what we are going to do is instead of passing the values inside this we are going to pass the address over here so that it knows that it needs to work on those addresses only so here instead of declaring variables like int a and then end B what I'm going to do is I am going to specify that we are going to get the address of a and b or any variable you can put X and Y over here it doesn't matter what what it specifically means is that you are going to get variables address and you need to work on that particular address only you don't have to create a new variable that's what this particular and means you can put any name over here it doesn't matter so now what happens is if I now call the uh function and then here if I just put this particular uh line over here so let me just replace this line and then uh let's say main right now if I now execute this particular code you will be seeing that in the function it got swapped and now in the main function also it got swept now a is holding the value of 8 and then B is holding the value of 2. so this is why we need different methods to call functions and basically there are only two methods to call functions one which we do always that is simply passing the values and then the other one is by passing the address so those are the two methods to call functions and they are actually named in that way only so one is called by value in which you just call using the normal method that is you just pass in the values over here and then the values get copied and then you get all the output which you required so this particular method is used only when you don't really care about changing the values in the main method or whatever it is the main particular value which are going to pass inside the function if you don't don't want to change that particular value but only want to do some computation with that value such uh functions are better to use that is called by value functions and when you want to change the value what you do is called by a reference so reference means address and the way you call by reference is in this way so you need to pass the ampersion symbol to specify that you are going to work with the address of that particular variable and not with the value of that variable so it knows that it doesn't have to create another variable and then copy that function but what it will do is it will directly go to that address and then carry out all the operations which is specified right so now instead of putting B and B over here I can even put B you can use combinations it totally depends upon the work of the particular function so since I had to change both the variables that is why I had to put and in both the variables if I want to change only a and not B now if you execute this function you will be seeing that a has changed to 8 and then B remains 8 inside the main function that is because I did not pass in b as an address but I passed in b as a value so that is how calling functions in different methods work and those two methods are called by value and call by reference in this video we will be looking at the equation so what is Recreation well the recursion is nothing but a method which we use to solve problems where if you manage to break that particular problem down into a set of simpler problems what you will observe is that those set of simpler problems are nothing but a simplified version or you can say miniature version of the main problem itself so let's take an example to understand it better so recursion so let's say we want to write a function called sum of N which will return us let's say the sum of natural numbers up to n so what you need is 1 plus 2 plus 3 uh up to n so this is the value which we intend to return When sum of N is called now there are different methods to solve this problem one is a pretty naive approach so method one is nothing but by using looping right so everybody is familiar with this kind of approach what we have is we have some variable to handle the overall sum and then we will loop from the starting value till the ending value that is from 1 to n and while going through each value we'll just add that value to the overall sum and in the end we'll just return the value of sum so this is one of the method to solve this particular problem and the other method is by using a concept of mathematics called arithmetic progression or AP well I'm not going to go into the details of arithmetic progression that's a very beautiful concept and I encourage you to look that up in the internet but for now what we are interested in is how we can get the sum of N terms in an arithmetic progression or in AP well uh the formula for getting sum of N terms in an AP is n by 2 times 2 into a plus n minus 1 times D so this is the formula for getting the sum of N terms in an AP again I'm not going to go into the details of this formula you can again go and look that up now a is nothing but the first term of the series so in here the first term is nothing but 1 so 2 into 1 and then D is nothing but the dormant difference between two consecutive terms in the series so we need to constitute the terms you can take and then you can see that the difference is one so we can just substitute it over here and if you solve this if you simplify this you will be getting this particular result n into n plus 1 over 2 so this is the result we will be getting after simplifying this equation now if you just plug in the value of N and you can just return this particular value you don't have to loop around and then keep another variable and all this stuff this is the most efficient way to solve this particular problem now we'll be looking at another approach to solve this particular problem no let me just clear this thing let's say we want to calculate the sum of uh some number let's say 10 so sum of 10. now what is sum of 10 it is nothing but 1 plus 2 plus 3 all the way up to 10. now we can also write this as 10 plus 9 plus 8 plus all the way up to one I just reverse this particular order now if You observe what if you upload this particular value what is this this is nothing but sum of 9 because sum of then when it goes from 10 to 1 sum of 9 should go from 9 to 1 so this is nothing but 10 less sum of 9 now again if You observe this particular value this is nothing but sum of 8 so this is nothing but 10 plus 9 plus sum of 8 so in a nutshell if you want to uh just generalize this you can say that sum of N is nothing but n plus sum of N minus 1. right and now this particular relation If You observe you are broken down this particular problem into a set of simpler problems and this problem is nothing but a simplified version of this problem so this is what is called recursion now before trying to code this thing we need to understand that recursion should have a limit now if you reach 1 so what will happen is it will try to find the sum of uh one and then here when it goes it will try to find the sum of 0 and it will go on up to negative Infinity right it will just go on and then once it reaches a stage where it has reached the extreme of the integer range or any data type you have kept over here it's going to stop and then it's going to throw you an error so the question should always have a limit so that limit is called as the recursion limit and it is really important that you should mention a requestion limit when you are using a recursive function the trigger shouldn't call or what you are doing is here you are just calling that function again right so this call should end somewhere so that somewhere is nothing but the recursion limit so now in this particular problem when you reach one you don't have to again call this particular value right because you have reached a saturation stage where sum of 1 is nothing but one so once you reach one you can just return one over there so the recursion limit for this particular problem is nothing but one so now let us code this so the return type is end and then the function's name is sum and then you have variable called n and here we what we need to return is return n plus sum of N minus 1 as I've just discussed before and before that we need to check whether we have reached a recursion limit or not so what is the recursion limit if n equal to 1 then what we need to do we just need to return one or else we need to return this so else written n plus sum of N minus 1 so that's all now we can just test this function C out sum of 10 and once you run this you will be getting 55 Sr output so that is the correct value of sum of N and that's how Recreation works now this is a very bad example to actually explain recursion because recursion is not generally used where it is not needed so the question actually takes up lots of memory so Here If You observe if I just call it with a value 10 it is going to again call this particular function with the value 9 and again 8 again 7 and so on so every time it calls a new value of n is created so what is happening is effectively if you calculate the space of a space required for running this particular problem uh so for n equal to 10 it is taking 4 into 10 bytes right 4 is nothing but 4 bytes which is the size of an integer and then 10 is because it's getting called 10 times so this is effectively 40 bytes of memory right and if you take the first case let me write this this is the third case right this is by using recursion now first case if You observe just by using looping what we are doing is we have three variables that is sum n and then I so it is nothing but 3 into 4 which is 12 bytes now that has drastically reduce the num size right and then if you now look at 2 it is nothing but only four bytes of memory because we are not having any extra variable we are just using n and then we are just plugging it into an equation to get the result so this is the most effective way and this is a better way and this is the worst way to solve this problem but since this particular approach is easier to understand I had taken this example mostly requestion is used where you can't figure out a generalized looping solution to solve a particular problem so that particular example includes uh something like finding let's say paternal ancestor of a guy so let's just take a family tree example well no just search for family trees in the internet and then uh let's take an example let's say okay this one so this one is like a tree so here you can see that uh this is let's say uh Tom and then Tom has a mother and a father and his father again has a father and mother and mother again as a father and mother and again that hierarchy continues now if you want to find the paternal ancestor of the storm what you need to do is I need to find the father or father or father or father that's what you need to find right now to find that what we can do is we can just reduce this problem to just look at this particular generation that is only one generation if you take this one generation what we need to do is we just need to move to the father so let's say we need to move to left side of this particular hierarchy because right side is Mother Let's just assume like that for now right side is always mother and then left side is always father so here if we just take this particular generation we need to move to the left side and again if you just break this problem down here if you take this particular generation we again need to move the left and this particular generation we again need to move to left and once we have reached a stage where uh that particular guy doesn't have a father then he's the ancestor right so this fellow let's say John is the ancestor of Kim so though in such cases the question will be useful so that's all for recreation in this video we'll be looking at a race so till now we have been working with programs where we already knew the number of inputs right so we knew the space required for our programs to work and all the stuff so let's consider a program where we don't know how many inputs we need to store so something like this this is a code snippet which is basically taking in record let's say Student Records so every student has a name and age and then the user gets to enter how many records he wants to enter and then we are going to take in the records now if you run this program uh you can see that the program doesn't crash right so if I say I want to enter three records it's going to take in three records so A1 B2 C3 so you can see that the records are taken successfully but if you look at this more closely you see that those records are not getting saved anywhere right those things are just getting overwritten every time now there is no way that we know how many records the user is going to enter right it completely depends on the user so how are we actually going to store all the records we can only store the last record in this way but all the previous records are getting lost right so how can we store all the data so that no data is lost and also we don't limit the number of records and the user gets to enter as many records as you want so it turns out that you cannot Define the number of variables or not the space you want at runtime but you can define a collection of space in one time so let me illustrate to you what I mean so let's say the user wants to enter some number of Records let's say uh five records so if you consider this white space as the computer's memory so what will be effectively doing is we will be creating collections of variables so we have two variables over here right so we have one name and then you have an age right so what you will be doing is instead of creating different variables like name one name two and so on we'll be creating a collection of variables something like this and then inside this collection what we will be doing is we will be separating this collection I mean we'll be creating partitions inside this collection so let's say the user wants to enter file record so what we do is we create a collection and then make five partitions into it so you have five partitions over here so all of them are obviously they are of the same size and then age also you will be giving five partitions so like this right so now what happens is once the user gets to enter the records you will be entering into that particular area which is assigned for every particular record so let's say for the first record you entered the data into the first box and then for the second record you enter it into the second partition so the third because you enter it in the third partition so and so on so this particular kind of process you will continue so that you can enter all the records and then you can also access this records by just accessing the partitions right so this is how arrays work well Iris literally mean collection of objects and that is what it means in programming too so what you are basically doing is instead of creating any number of variables you will just create this memory space which is capable of holding any number of variables and then create partitions into it so once you create partitions you can add data into it and then it you can retrieve it you can perform operations on it just like variables so basically you can think of array as a collection of variables but it's not actually a collection of variables it's just a collection of memory so if you take this particular array if you take the size of this particular array you will see that it is nothing but the number of elements inside it so in this case 5 into the size of each element it inside this so the size of each integer is four bytes so the size of this particular array is going to be 20 bytes so you can see that array is nothing but just a collection of memory or you can say collection of variables and then you can add and retrieve it as you like so let's see how to implement this particular ideology in programming so to implement an array what you need to do is you need to declare an array so how do we declare an array and see questions we don't have to do anything we just need to put square brackets so that this particular variable is addressed as an array by the compiler and then inside this particular brackets you need to specify the number of items the array should be capable of holding so in our case we are going to get the number of Records right so if you give n request you are going to have n names and N edges so the size of our array is nothing but the number of Records right so what you do is you just mention the size inside the square brackets so for the ah2 you are going to do the same thing so age records and then over here what we'll be doing is instead of name we will be accessing the partition now how do we access the partition of an array so for accessing the ith partition or the ith segment of the na or you can say the ith variable which is stored inside the collection you need to access it as the name of the array so array name and then inside pair of square brackets you need to specify the index where this particular index is nothing but I minus 1 so let's say you want to access the first partition of the array so for the first partition you need to give index as I minus 1 which is equal to zero so for the second one you need to give the index of 1 and so on so for the nth partition you will be effectively giving n minus 1 as your index so that is why if you remember I generally start Loops from 0 because it it becomes easier to work with arrays if you are working with Loops which are starting from zero because of this particular rule because the index of an array starts from 0 so I don't have to subtract one from the counter every time I can directly in Access the Partition by just calling the counter now to access this particular partition you don't have to do anything you just need to put the square bracket over here and then access the partition so since I am using a counter over here I'm directly going to access it by the counter and the same thing over here too okay now how do I retrieve it while retrieving also follows the same rule so you need to pass the arrays name and then the index which is nothing but I minus 1 if you want to access the ith partition so let's say we ask the user to retrieve some record let's say which record or do you want three and then the user enters your code so let's say nth record so he wants to retrieve the nth record so we'll be getting the nth record as our input and then what you need to do is you just need to access the nth record as n minus 1 is the same Rule and then for the name and then that goes same for the H2 so we just need to access it by n minus 1. and then if you run it so let me just put the N line over here so here you can see that if I enter some records let's say A1 B2 C3 and then if I want to retrieve the second record you see that the name is B and then the age is two so that's how arrays work that's a recap arrays are nothing but a collection of memory or you can say collection of variables where you can store and retrieve variables as you wish so now what all variations can you do with an array well it turns out that you not only can store collection of variables but you can store collections of collections too so that is basically the dimensions of an area so Dimension basically means collection of collections so basically if I'm saying that an array is one dimension so if I say that array is one dimension it basically means this thing that it it holds the collection now if I see that an array is two dimensional then what it means it it holds a collection of collections so how do we Define this we just put another pair of square brackets over here and then Define the second dimension so this is nothing but a matrix if you have to so if you are familiar with matrices you have some array of numbers right so one two three four four eight nine so if You observe this this whole thing is a collection and three such collections form this particular Matrix so how can you define this you can just Define this acid 3 cross 3 array right so if you say this particular thing as a matrix so let's say this this Matrix M which is equal to this thing so if this particular Matrix is this one then it is nothing but a three cross three Matrix right and the way it is defined in the memory is you have this particular collection where inside each collection you have three items so one two three is one collection four five six is another collection and then seven eight nine is another collection and all three form the overall collection so this is how your variable mat is actually defined in the memory well you don't have to always take in input inside an array from the user you can even Define the inputs so how do we Define it well to Define inputs you just need to put a pair of curly brushes and then Define your data so let me just clear this and we'll take some generic examples so let's say our array is a three cross three array so let's just Define that Matrix which we talked about so how do we Define the first we find an overall collection and inside this collection there are going to be three collections so one collection is one two three and then you have the second collection as four five six and then the third collection as seven eight nine so this overall makes three by three Matrix so if you want to access it you can access it using Loops so for end I equal to 0 I is less than three I plus plus and then you need to run another loop for accessing the inner collection so for n j equal to 0 J is less than 3 J plus plus you can just show that element so a of I comma J right let's just give a space over here and then a new line of flow so that it looks like a matrix now if I run this so I forgot to put a come over here yeah so here you can see how 3 cross 3 Matrix is defined well you can have collections of collections of collection so that is basically a three dimensional array you can go up to any dimension in a little small limit you can have as many collections of Collections and it completely depends upon your problem so mostly we tend to use this kind of collection which is the Matrix and then the single dimensional array which is nothing but just a collection of data well another point to note that is these collections cannot contain mixed data that is you cannot have both integers and strings in one array so in an array what happens is that particular array will contain data or will contain a collection of data of only that particular data type you cannot change the data type or you cannot have mixed data inside one particular collection so that's how you work with aeration C plus plus you can also pass in arrays to a function but always Aries will be passed as a reference not accept value so if you create a function over here let's say in funk um which just takes in the array so int a and then you need not Define the dimensions if it's just a single Dimension you can just leave it as a square bridge and if it is multidimensional then you need to define the last dimension of battery so let's say you are passing a threedimensional array so then you need to Define the last Dimension which is a third dimension compulsively you cannot omit this Dimension and if you are passing this particular array which is a two dimensional array you need to pass the second dimension which is three you can leave this or you can Define this it really doesn't matter but if you are passing some array which is not single dimensional then you need to pass the last dimension of that particular array so now let us just Define this function let's say uh we don't have to do anything we just uh print the first element of the array so a is 0 0 this is the first element and then what we'll do is we will change that element so we'll change a 0 0 equal to 5. right and then uh I'll just return uh some things let's say it will skip this return we'll just make this void so this avoid function right now if we call this function so if I just say func and then passion a and then we when printing the first element after running this particular function so let's just put n lens over here so that we can differentiate between the output so one over here and then one over here and now if I run this particular program you will see that the value of array 0 0 was 1 which is nothing but this particular element and then if I change that value over here I could change it over here too so in the main thing also it changed so that explains that arrays are not passed by value but they are passed by reference so arrays don't get copied when you pass them to a function but that changed in the memory itself so what you are essentially doing is you're just passing a pointer we will be discussing pointer at a later stage but uh what pointers basically mean is they are nothing but those are variables which carry addresses we will discuss more about pointers at the latest age but for now this is how we use arrays and C plus plus in this video we'll be making our first programming project which is essentially going to be a console based tictactoe game so in case you're not familiar with the game let me just quickly walk you through the game the game has a 3 costly port and two players who play alternatively so the objectives of the players is that they need to fill one of the roles or columns or the diagonals with their marker so if I just start the game with a computer you can see that we are playing alternatively and our goal is to just fill up one of the rows or columns or diagonals with our marker so here if you see the computer has managed to fill the row with its marker so it gets to win the game so we are going to implement this game on the console and well we won't be implementing such a sophisticated system where the computer can play although I will be giving the intuition required for building such a system towards the end but what we will be implementing is a two player game so if you go over here and then change this mode to play against a friend you can see that you make both the moves by yourself so we'll be implementing this but I will also be giving you the intuition required to implement a system which can and think and then make moves towards the end all right so let's get started so first uh create a new project naming Tic Tac Toe so the project title is Tick type 2 and let me just save it in my desktop and then click next finish so now we have our project with our source file all right so let me just uh make the text a little bit bigger now we'll start off by creating the board so there are different ways to implement this board you can think of this as an array of nine elements and then three of them are stacked together as a row or you can even think of this as a three cross three Matrix well I will be implementing this particular board as a three cross three Matrix because we can understand rows and columns better by looking at the indexes rather than the slots but you're free to implement it as a 1D array also that is uh by creating nine elements and then stacking three three vertically all right so I have managed to draw this implementation over here so what will be essentially building is a three cross three array like this and then these are the indexes and since we cannot uh detect Mouse clicks on our console we will be numbering our slots so let's say the user wants to enter his marker over here so the user can press 5 and then we will remove this five and then put marker over here let's say x so the 5 goes and then we put X over here so that's how we are going to implement it but there are other libraries which I encourage you to look up which support Mouse clicks on consoles too so in case you are interested to implement such a system where you can click on the area and then your marker appear so you can check out those libraries well discussing those libraries are well beyond the scope of this course so we are not going to do that so for now we will be implementing this particular system right so let's start off by creating the bowl which is a twodimensional character id so let's call this Arias board and then this is going to be two dimensional and every Dimension will have three three elements so this is a three cross three board let me just put it over here so even if you don't put it doesn't matter I'm just putting it so that uh we be clear with our implementation so let me just name the slot so one two three and then four five six seven eight nine so notice that I am numbering the slots as characters because if you put characters over there it will take it as an ASCII value I'm sure you know this right now let us quickly make a function to draw the board so let's say avoid the draw board and what this function is going to do is that it is going to draw the board neatly for us so something like this so uh these two vertical lines and then these two horizontal lines separate the rows and columns will be drawing that over here so you can use a loop but since there are only nine elements let's just hard code it so uh both 0 0 let us give a space before about 0 0 so that it doesn't get squashed up to the left all right both zero zero and then we have a space vertical line and then board a zero one space vertical line and then board zero two and then we have the next line because we just completed the row what we did is we just printed this row with these two vertical bars now we need to put a horizontal bar so uh let us just put that see how the horizontal wire is just going to be lines this is all completely designing you can do it as you want right and these steps continue for the next two rows two so Ctrl c b b and for the last row we don't need the horizontal lines and here you just need to change the road number so this becomes 2 this becomes one one over here two and two so now if we call this particular function let's just remove this and call drop board now if you run this we will be getting our boot so uh well the horizontal lines become extra how many characters are these three characters or more so let's just remove those three characters foreign so this board looks much better right so we have our Port ready now uh how do we put data inside this board so let's make another function to do that let's say void place marker which is going to take a slot number right because the user is going to enter the slot number now it asks us to convert the slot number into the row and column number right if you are using a onedimensional array that is pretty easy you just need to do slot minus one to answer insert that into the particular position right so suppose you want to insert it into this particular position and if you are using a one dimensional array this is the fourth position right because array indexes start from 0 so 0 1 2 3 4 and you just need to do slot minus one but since we are using a two dimensional array we need to find out a way by which we can convert this slot number into a row and column number so what we can do to find the row number is that we can use an observation that all the rows start from a number which is just one greater than the previous multiple of three so if You observe over here one is nothing but 0 times 3 plus 1 4 is 1 times 3 plus 1 and then 7 is 2 times 3 plus 1. so what you can do is you can get the row number by dividing the slot number by 3 but then again if the slot number itself is a multiple of three then you need to subtract one from the slot number that is if you take example of 6 so if you do six over three it is 2 right but we need it in slot number one so we need to subtract one from that so what I mean is if this particular slot foreign that is if the slot is a multiple of 3 then slot equal to slot over 3 so this is this and then minus 1 so this will give us the slot number else slot is directly slot over 3. so this should give us the particular row number sorry let us take a variable just at least changing the slot so if slot percentile 3 is 0 then rho is going to be this particular value or else rho is going to be this value now let us just see whether our row works correctly or not and let us just call it with Place marker let's say 8 right now if you run this you should be getting 2 which is correct right because 8 is in row number two now to get the column number you can do something similar to that so to observe the columns these are nothing but reminders which you get after dividing by three right so you can do the same thing so let's take another variable to store the column and column is nothing but slot modulus 3 so this should give us the reminder so if you look over here let me just pull up that image now if you say three then our row is going to be 3 over 3 and since 3 is a multiple of 3 so it is going to be 3 over 3 minus 1 which is equal to 0 and then um our column is going to be 3 modulus 3 which is going to be 0 but that is not our column we need two so what essentially we need to do is if it is a multiple of 3 if the slot is a multiple of 3 we need to put it in the end or else that particular logic will work all right over here what you need to do is if at this particular slot is again a multiple of three then our column is going to be two all right or every time when the value is a multiple of 3 you are going to put that in the last column and then you can divide this slot number by 3 and then get the reminder that is going to be your column number get the reminder and then subtract one from that that is because we are not considering the multiples of three right we are leaving the multiples of three so we need to subtract one let's say four so four divided by 3 you get a reminder one and then one minus zero is zero which is the column number of four okay so this is how you get the column number so uh let me let us just quickly uh rewrite this with uh fewer conditions so row is going to be uh this particular value right irrespective of whether slot is going to be a multiple of 3 or not if it is multiple of 3 we can just subtract 1 from this value so a slot modulus 3 is equal to 0 then rho becomes rho minus 1 and then column becomes 2 right this is only when the slot which you're giving is a multiple of three or else or let us Define the column before using it or else what happens is columns become slot modulus 3 minus one so first we perform slot modulus 3 and then we subtract one from that all right so this is how we can get the row and column from our slot number if you know check out the row and it will come over here and then column and then let us call with a so we should be getting 2 comma 1 which is what we got right because 8 is in the second row First Column we can try it with some multiple of three let's say nine and then try to run this we should be getting 2 comma minus one now why did that happen well that is because we are trying to modify the column even after it is getting modified over here right we are modifying the column when slot modulus 3 is equal to 0 and then again we are modifying it over here so we need to put it in the else part all right now it should work fine now let us just close this and try again uh if I press F9 so here you can see it gave us 2 comma 2 which is correct so now we know that our Logic for getting the row and column is correct so we can proceed by putting our marker into the board so how do we track which Market to put so let us create a global variable for tracking a marker let's say current marker and let us set this to some value or else we'll set it while we are asking we will set it while we are asking the user to choose the marker right and we will also have a current layer right so we need to even track the current layer to check which player is playing right so we have one marker and one player now what we are going to do is we need to just put Board of this particular row and then this particular column is going to be the current marker so now we have successfully placed it let's place a marker over here and then try to draw the board I'll we'll draw a board over here too so draw board uh and then we'll put a new line so that we don't get converted between the two boats so let's uh just uh say that current marker is X for now and if we try to run this you will be seeing that in place of nine now there is an X right so now we know that this particular function works we can place our marker on the board now let us make a function to determine who won the game right so let's call this function win or winner something like this and we will put the data type to care I will just explain why we are putting the data type to care right now so this this is not going to take anything this is going to work on the global board variable which is this which is an array right so what we're going to do is we are going to check all the rows the columns and the diagonals and see whether those have the same value of marker right so in case there are numbers they are going to be different so nobody won and in case they have this excess or Os stacked up horizontally vertically or diagonally it means that that particular layer 1 right so now since we are getting the winner we can either put it true or false to determine whether the game is one or not but to determine who won the game we need to again check whether that particular marker is an X or o right so what we are going to do in this function is instead of checking twice we will directly return the marker of the winner so by marker we can identify which player one and then we can congratulate him or her right that is pretty easy now so to do that let us quickly run a for Loop so in time equal to 0 I is less than 3 I plus plus and inside this we are going to check for rows first so uh if this particular Board of I and then 0 is equal to board i1 and board i1 is equal to board I2 then return the current marker right because uh we are going to check whether the player wins immediately after he places the marker so if this particular condition is satisfied then it means that one of the rules has been occupied by this current player so he's the winner and you can also check for the columns in the same Loop so what you need to do for the columns is the same thing but just the eyes get shifted to the second dimension so since I am checking the rows I am just putting I in the First Dimension for columns what we need to do is we need to remove the eye and place it over here so let me just cut and paste it and this goes over here and this goes over here so now we have successfully checked whether uh the rows or columns are filled for diagonals you can just hard code it since there are only two diagonals so if Board of zero zero is equal to board of 1 1 and board of 1 1 is equal to code of one two so what we are doing is we are essentially checking whether this value is equal to this value and then this value equal to this value if these two conditions are true it means that these three values are equal and it means that the player has one so if these three if this condition turns out true then the current layer as one current player or Mark oh since I'm using the player as a integer I need to return in not CAD so over here it is not current marker but current player you can return either of them right you can return current marker or current player it just depends upon you right so now we need to check this condition for the second diagonal so this goes and then for the second diagonal so coordinates are 0 2 1 1 and 2 0 so 0 2 one man Remains the Same and one one is equal to two zero then you return the current player right so now what if nobody won so you need to return something so what will return is we'll just return 0 0 means nobody won and if it is either one or two it means that player one is one or player 2 S1 so now we have the winner uh let's just create a arbitrary board and then check who won right so uh let's uh place these markers right place marker at nine eight and seven so it means that X is one so nine seven and then Place marker at eight and our current player is going to be one right now if you run this okay the spelling is wrong current player and if I try to run this so here you can see I have placed three x's over here now if I try to call this function which is uh winner and try to print the data over here so you can see that it has outputted one one is the current player who I just put three x's in a row so it works for row let's just check for column column is um let's say zero sorry one and then four and seven so this is the first column and we'll run this so it has returned one again and let's check for the diagonal so that is 159 so now you see that doesn't work for diagonal that is because we messed up the logic somewhere let's take that out oh it is not one two it is 2 2 over this right so that's a small mistake I made oh now if you again run this this should work now so here you can see it has outputted one and let's keep some arbitrary uh Place let's say 169 so this shouldn't result in a win so this should give us 0 which it gives so now we can say that our winner function is pretty much validated and it works right so now let us quickly make the interface we need so let's call this interface game all right and in this let us Define our current player and marker so we will give a choice for the player one to choose a smart girl and player to automatically gets the other marker so what we are basically trying to do is if the player the first player has a choice of playing X or an O right so that's what we're going to do so uh player one uh let's say choose your marker now you can come up with your own sentences over here it doesn't really matter so this will enter our current marker all right or uh let's just keep a player one marker uh let's create a character which says marker marker of player one so we are going to get this particular marker so marker here one now our current player is going to be one and then the current marker is going to be the marker which appear when choose right now if You observe this game right they can be at most nine moves for this game to end up in a tie right so in case somebody wins it's going to be less than 9 moves but if it is going for a tie it's going to be 9 most important so what you can do is you can run a loop till nine moves so enter equal to zero I is less than nine and then I plus plus and inside this what you need to do is let's first draw the board or what we can do is we can First Take input from the user and then draw a good so for the first time let us just draw the board outside Loop and then for the subsequent moves we'll draw the board after the slot is entered so we'll ask the player to enter the slot so see how it's clear and then which player is that current player current players um let's say turn so enter your slot now we are going to get a slot so in slot C in slot and you know what to do you just need to place the marker so Place marker in this particular slot and then we will draw the board to draw board so now if we run this particular board we'll just call the function game to play a game right so we'll just remove all this and then just say game over here so now if you run this what you will be uh getting is player one choose a marker is going to be X and then uh it's my turn so let's sit two now you see that the player is not changing that's because we did not write code to change the player and the marker we need to swap the players and markers right because the players and marketers are going to change alternatively and here you can see that the slot has been accepted perfectly and then the X has come in place of two so here you can see that it works and then if I win somewhere it is not going to stop and then it's again going to continue right so this game is never going to stop so we need to fix all these issues so we'll do that one by one first let's take care of the issue where the player and markers are not changing so let's create function quickly which swaps a player in marker so let's avoid uh swap player and uh marker so this is the name of our function so what it does is pretty simple if the current player the current marker is X then change the marker to O current marker becomes o or else you just change the current marker to X and this is just swapping the markers and the same goes with players so if the current player this one then current player becomes 2 or else Uh current player remains one so here we have successfully swapped the player in marker so once uh everything is done what we do is before drawing the board we just swap the player right so swap player and marker and this should do the job now let's test this so if I run this uh let's choose X now it's asking player Once you turn enter your slot let's say one and now player two Stern enter your slot if I enter two you can see that 2 is occupied by an O now so now I we have successfully created a system where the players are changing and the markers are also changing and now we need to take care of the issue that once we are winning it is not stopping right so we need to check whether somebody won or not so over here what we can do is we can create a variable for storing the value which this particular function returns right this winner function returns it's going to return a value in the range of 0 1 2 right it's not going to return any other value so let's just create a variable which shows the winners so let's say uh layer 1 this is the integer value and what we need to do is after placing the marker we need to check whether he won or not so player one equal to this particular winner okay and now here if this particular value which is player one is equal to 1 which means that player one one right so see how the player one one and then let's say congratulations and what you need to do is just break out of the loop because we don't need to continue the game after somebody F1 right so you can just break out of this Loop and over here the same thing goes with player two three right you if player one is equal to 2 then you says uh see out the same message just we need to change the player to and all these things remain the same so Ctrl C and Ctrl V and over here instead of one we just need to put two so in case nobody won it either means that the game can go on or if it has reached 9 moves it means that it's a tie right automatically if you're playing for nine moves and you make the ninth move and still nobody wins it's going to be a tie so what you need is if this particular winner condition which is player one is equal to 0 after completing this game then we need to say that nobody wins or let's say uh that is a tie game right so uh what this will do is if in case nobody wins even after nine moves and this comes out of the loop it will then say that it is a tie game right so suppose player one one and then it broke out of the loop then if you just put this particular thing without this if condition what will happen is it will print both the messages at once right so it will say player one one and then again it will say that that is a tie game we don't want that to happen that's why we have put a if condition to check whether it's a tie or not and then we will say it's versatile again right that will take care of all the issues hopefully so let's just try with o this time and its player once done so let's enter one two three so you can see it's filling alternatively and four five six seven and it says player one one congratulations but uh we cannot see what happened over here that is because we are not drawing the board immediately right so what we'll do is we'll shift this drawboard function before uh this particular winning condition right so what will happen is once I place this marker I will just draw the board so now if I run this uh let's say x and then one two three four five six seven and now you see that player one has one that is because this particular diagonal which I'm highlighting has been filled up by axis so player one one in case you fill it up with o it means that player two S1 and in case you don't fill it up let's take a draw keys uh let's say uh we play for nine moves so x uh let's just quickly put the numbers one two three so in case to draw we need to put five and then four six and eight seven nine right so now you can see that nobody has one even after nine moves so it says that is a tie game and the board is filled up so our game works perfectly for now right so there is a minor bug in this game for what what we did is so let's say I put my marker in the first slot right and now it is player two strand and what I will do is I will again press one so what will happen now is if You observe the X has gone and then o has taken its place it means I've just overwritten it right so we won't we don't want that to happen we don't want to move the markers away from the places so to fix that what we need to do is we need to check whether that slot is empty or not that is if that slot contains some character which is not an integer it means that it is a marker right and we don't want to change the smartphone so what we do is where we are placing the marker here what we need to do is we need to put this only when that particular row and column is not filled up so if that board and column a board of this row and then column is not equal to an X and it is also not equal to an O So Board of uh row and column is not equal to an o then you will be filling it up with this particular marker or else you won't fill it up right so let us return true or false over here and then we'll print the message over there so uh we'll make this Boolean or Bool and over here if this is the case then you first place the marker and then return true saying that this operation was completed successfully or else what you need to do is you return false over here and here once you are placing the marker where did we place it before placing it over here right so let's say Boolean status or you can directly put this in the if statement also right so if this particular condition is true then we don't have to do anything we want to print a message only when it is false so let's put a not over here so if not Place marker of slot that is if this condition is not true then we need to say um something so let's say that slot is occupied Tandon or try another slot so this particular message will print and then we need to decrease I by one that is because we need to uh give the player another chance right we can't just switch the players right there so we just decrease I by one and then we just put continue so that all these statements are skipped and then it goes back to the execution so let us just uh neatly against this indent this code so we print the message we decrease I so that the value of I remains same once continuous encountered right because if it is decreed decreased over here it will go back and it will increase over here so effectively the value of I remains same and it should work now and another thing is let's say the player entered some pretty big slot right let's say 100 or something so we need to take care of that too so if slot is less than nine less than one and if slot is sorry or if slot is greater than 9 we should not accept it so we need to do the same thing just the message changes Ctrl C and then Ctrl V and here you need to share that is an invalid slot right so that slot is invalid and then you try another slot and we just put continue so that the player doesn't change so this should do for us now if you execute this you will be having a functional tictactoe game over here so it's asking player one choose your marker it's going to pay X and now it's player one stone so one two three four five six seven so now player one one that's because of this particular diagonal and let's make player 2 also again so let's try it once again so let's say x again so now it is going to be one two three and then five four and then what is that state now you can see player 2 1 congratulation that is because I have filled up this particular column with OS right so uh in case you wanted to implement AI kind of a thing where the computer place you can do that well uh we are just going to implement a pseudo AI not the original one so this is not going to think much it is just going to randomly place it so in case you want to Generate random slot what you need to do is you need to include another header file called STD lib which is standard Library you can include this one or three stdi Library which is the C plus plus version of this C standard Library so these libraries are nothing but they are from C language so in case you're using it in C plus plus you just add a c over here to indicate that that this is C library right now to Generate random numbers what you have is you have a function called rank which will directly give you a random number right Sprint Rand over here and here you can see it just printed 41 onto the screen now if I execute it again you will see that the same 41 is over here if you close this whole program and then uh rerun it it is going to give you a different number but again uh till you don't remove this whole code from the memory it's going to be the same number again and again and again so to take care of that what you have is something called as a seed so for seeding the random functions reading is basically you will be giving different starting points to that random function to generate different numbers every time you call it so to feed the random number you call the function s Rand and inside this you put some number which constantly keeps changing right so let's say 1 over so let's say 10 over here and then if I try to run this you will be getting some other number let's say 71 over here and if I put some other number let's say 1 over here now and then try to run it you will be getting another number which is 41 but we can't change this again and again right we need a way to change this particular number which will generate different numbers every time so to do that we can use time right so time is constantly changing it is not constant so what you can do is if you pass in time over here as an integer it will give you different random numbers without you having to change this manually so to do that we need to include another header file which is called time right so see time right so same reason why we are using over here it is time.h or C time both the same and you go over here and then what you do is instead of one you just pass in time and then pass in null as a parameter we'll talk about this null when we are discussing pointers but for now just remember this is the syntax and this is how we call the function for time right for getting time as an integer now if we run this you will be getting different uh numbers over here every time so this is 9170 if I execute it again you will be getting some other number 9187 right so to Generate random numbers in a Range we want it in a range right we want random numbers between one and nine so to do that what you can do is you have to use a formula there is no direct way to get random numbers in C plus plus in a particular range but what you can do is you can use a formula which states that if you want random numbers in the range of U to L right which is sorry L to you which is nothing but lower range to Upper range what if you want random numbers in this range what you do is run mod U minus L plus 1 and then the whole thing plus L well this formula does look pretty clumsy I know that but if you try to reduce this you will see that it mathematically means the same that the lowest number will be L and then the highest number will be you right so you just remember this formula to Generate random numbers within a range so in our case what it's going to be is upper range is 10 and then the lower range is one right upper range is not included so value for this notation it is mathematically this which means that the last number is not included but the number till the previous one is included so it becomes 10 minus 1 plus 1 and over here the upper radius one right so now if you do this over here if I try to print this value over here you will be getting numbers which are in the range of one to nine right let us put a semicolon in the end and we don't need this so we'll just remove this so every time we execute we'll be getting some random numbers which is uh in the range of one to nine right so here you can see that it's giving us different numbers in the range of one to nine so now what we can do is we can use this and instead of the second player what we'll do is we'll just uh ask the computer to generate some random slot number and then place our marker over there and then instead of 9 now the loop will run only for four times well just because uh the number of times the loop should run is halved right we are not going to take in inputs for nine times we are going to take it in input for four times so we need to just run it for 9 over 2 times which is 4 that's an integer Division if you want to implement a really sophisticated system like the one which Google uses right this one which can think so if you take this impossible level in this particular game and then try to play with Google you can see that you can never win right it will either end up in a draw or you lose right now there is no other outcome in this particular you cannot win that is for sure so to implement such a system there is an algorithm called as min max algorithm so you can try to study about this min max algorithm so sorry it is min max algorithm right so you have this particular algorithm so what this essentially does is it will take combinations of games right it will play the game with itself and it will score every game so let's say we have an arbitrary game so let us just clear this let's say we have an arbitrary boot so I have an X over here and over here and then another X over here and over here and then the computer is playing X so it has to make the next move so what it will do is it will try out all the possible boxes which are unfilled right and there are different outcomes for that so one of the outcomes is let's say I start off with this board so let's change the color so let's say I put an X over here now there are different ways to put oh I can either put one over here one over here it is up to me right so every possibility will generate a new set of boards which the computer will play itself right in the memory and then it will score its outcomes so let's say in in case it put X over here and then uh for the first case you put over here and then it turns out that after playing such combinations it turns out that if you put X over here you have uh let's say 10 combinations out of which you won five combinations right so this is one of the slots now what what it will do is it will keep the statistics and Again Play it with the next lot which is empty so what we'll do is it will just remove these things and then it will play with let's say this particular column so it will put an X over here and then again repeat the same process it will see all the combinations possible and then let's say in this particular column which I marked with red there are again let's say 10 possible outcomes and then it one or seven of them right and let's say it played over here let's take some other color let's say this one so it played over here and then in this again there are 10 possible outcomes and out of which it could win only two right and you have another possible to over here or in which 10 possible outcomes it could not win any one right it lost all of them so it won zero now what we'll do is it will see all these scores so here it has 70 probability right so if you are winning seven games out of 10 it means you have seventy percent probability of winning and here you have 50 here you have zero percent probability and here you have twenty percent probability so it will check the one with the most probability or the most score so if you take into if you talk in terms of numbers here you have Phi here you have seven zero and two right so it will take the number which is maximum that is this one so it will say that if I put my marker in this particular place I have more chances of winning so it will place it over there so for every move it will calculate all the possibilities and then place the best move and that is how this particular Google is using that particular algorithm to make its decision so that algorithm even though it is called something else it is actually requestion so if you look at the implementation it is basically recursion which is being implemented right so tictactoe if you just search for that you will have many uh different uh resources to check that out so you uh check that from one of these resources so what you will see is it is basically implementing requestion it will just go over the boards and then try to implement and then you have a scoring method so uh I think they have used plus 10 as a score we have used plus one over here right where if we one you just put one over here if you don't win you just put minus one it means that you one and 1 means that you do so and you don't want negative scores right we just want positive scores so this is a bit of complicated stuff if you don't understand uh I don't expect you to understand at this stage but I would definitely recommend you to check that out and try to implement and this one you can try to implement by reducing the number of Loops over here and then creating another function so that the AI chooses what slot to put the marker in so in this video we'll be looking at pointers so now water pointers well as I had mentioned before pointers are variables that store addresses now why do we need a variable to store an address well if you have looked at the address by using the Ampersand symbol let's say we have variable called where and if we want to check the address of this variable then we do an ampersand where so that we get the address and once you run this you will be seeing some hexadecimal value right so this doesn't really make sense and why do we actually need to store these addresses what is the point of that so to answer this question let us take the problem which we were solving while discussing arrays right so the user has some records let's say n records and then the user gets to enter these records and we need to store all these records now let's say the user doesn't really know how many records he has now our program will terminate after taking number of Records right so that number depends on the user if he says he is going to enter 10 records we will create a collection something like this in a memory which will have the capacity to hold only 10 records we cannot increase the number of Records once memory space is defined so how do we solve this kind of a problem where the user is going to enter data and he doesn't know how much data is going to enter but we are expected to store that so to solve this issue what we use is called dynamic memory so what we do to solve this problem is we have a special data type defined and this data type does not belong to any one of the primitive data types right this is not an in float care or something this is a collection of data types combined as one data type we will discuss about how to generate these kind of data types in the upcoming videos but for now let's just focus on how this works so you have a data type like this where one of the data which this data type holds is a pointer now what we do is we will put data or we will generate a data which contains the records and then we will just randomly throw it in a memory so let's say this is one of them and we just randomly put all the data somewhere the memory and to keep a track of the records what we do is we will just keep a track of this particular record or this particular data now what we do is we will just link all these data with the pointers now this pointer will hold the address of this particular data and this will hold the address of the next one and this will hold the address of next one and so on so what I've discussed till now is nothing but an implementation of something called as a linked list right so or more specifically this is called a single linked list so we won't be implementing this particular data type in our programming right now because you don't have the intuition to Define such a data structure which can hold multiple data types we will be discussing about them later but I will definitely show you how to implement a preimplemented data structure called list in C plus plus in this video so first let's discuss about pointers and how to use them and then we'll look at this particular implementation the implementation doesn't really have anything to do with pointers but this is how this particular data type is working in the memory so if you want to implement something like this from scratch you need to understand how pointers work right so let's get back to pointers so to create pointers what we do is we just name the data type of the pointer and then the name of the pointer let's say PTR and then before the pointer we put a star so so the star indicates this this particular variable doesn't hold a value but will hold the address so this is how we declare pointer and we can just store the address of this particular variable over here so you can either do it like this so you can say PTR equal to and where so PTR is the pointer and then and where is going to be the address so you can store the value of and where inside PTR or what you can do is you can even directly do it from here so note that this thing it is not equal to something like start PTR you just did install PTR and then in the next line you did star PTR equal to and where this is incorrect y see in Star PTR is going to be a pointer and a pointer Can Only Hold addresses now star PTR what it does is if you see star before accessing something it means that this values address and then star means it will reference to that address that means you will get the value to this so star Peter is actually the value which is stored inside the address which is pointed by PTR and here you are trying to store an address so this is incorrect so what you do is you either do PTR equal to and where to get the address of wire inside PTR or if you want the value of where inside PTR what you do is star PTR equal to where so you do either of this but not something like start PTR equal to Android that is incorrect right so now if you want to check what we have inside PTR you can just do c out PTR and we will see that yeah that is because I did not put a Ampersand over here now so now you can see that this shows uh okay this these are essentially the same addresses just that it is not separated with a new line so if I separate them with a new line you will see that both the addresses are same so let me just close this and open this again so here you can see the address of where and then the value of PTR are same now if you want the value which is stored inside PTR what you do is you put a star before PTR and you will get back the value so if I run this now so here you can see that 10 is the value which is stored inside PTR now what happens if you if you change the value inside PTR so let's say star PTR equal to 20. now what happens is since this PTR holds the value of this particular variable called where what happens is if we change the value which is inside this particular address it changes everywhere right so if you change it over here this value is going to be overwritten with 20 it will change over there too that is because you are not using a copy but you are directly changing the value inside this particular address now if you try to print the value of where and we don't need this so here you see that the value of where has become 20 now that is because of this particular statement and you can have multiple pointers and pointers to pointers also let's say we have another pointer enter P PTR which is pointed to point here and for defining a pointer to pointer you just put two stars so there so this part means that this is a pointer and the whole part means that this is a pointer to pointer you can essentially have as many pointer to pointer to pointers as you want but for now we will just go with two and uh to access this what you do do is so P PTR is going to be the address of PTR so if you do and PTR you will get the address of PTR inside this pointer to pointer so let's call it something else this is pptr is pretty confusing let's say um pointer PTR so this is pretty good so pointer PTR will have the address of PTR so now if you try to run this what we'll be getting is the address of PTR so this is not the address of this wire but it is the address of PTR so if you try to print this so we'll just print all things at once so that we can compare them see out uh where first and then we have the address of where and where and then we'll put a new line over here so that we can differentiate the output so and and then we have the pointer which is PTR the value of uh PTR and we have the value which is stored inside PTR so star PTR right and we have this pointer PTR we have the star pointer PTR and star star pointer PTR and I forgot the end lines over here so handle handle and and so here you can see the value of where is 20 the address of where is this thing now the value inside PTR is this under value which is inside this particular address is 20. and value inside pointer PTR is this which is nothing but the address of this particular value which is PTR and this is nothing but the value which is inside this address so now this address is a pointer right this address will contain another address which is nothing but this one so essentially if you are doing a star PTR which is to a pointer to pointer it just means that you are accessing the value which is stored inside the value of another thing so star PTR is nothing but this thing which is the address stored in this particular address now star star PTR is nothing but the value which is stored inside the address which is stored inside this particular address so that is basically the hierarchy so if you don't understand let me just put it as a image so that you can understand better we'll just clear these things so now let's say this is PTR which will hold the address of some variable called where so now this is this variable called where which is nothing but a memory location and this will hold the address of this now pointed to PTR what you can do is when you define pointer to PTR as a pointer to pointer like this what it means is that it will hold this particular value it will essentially hold the address of the speed and now the PTR itself will be in some location right so let's say this is the location of PTR and that is the location of where now what happens is this address is stored inside this and you have another thing called pointer to PTR which will store this particular address now once you are accessing the value which is stored inside pointer to PTR that is nothing but this particular value right now the value inside this is nothing but an address which is the address of this bar so that is why we were getting the address of this pointer that is PTR when we are doing star PTR and then when we did star star PTR what happened is it it wanted the value which was pointed by the value which is inside this so that is why it is called pointer to pointer now what is the value inside this that is nothing but this particular value which is PTR so this is PTR and since you have another star it will go to the value which is pointed by this thing what is the value pointed by this thing it is nothing but this value so it will take out this value and then put it on the screen so that is where we were getting 20 when we did star star pointed to PTR now you can even use pointers and functions so let's say we created a function um avoid let's say swap numbers which we did when we were discussing about call by reference and call by values now instead of call by reference so when we're doing call by reference we were doing something like inter in B right so we are passing this Ampersand to mention that we are going to get an address but to get a pointer you can do the same thing you can just put a star over here and the way you swap numbers is we will have an intemp which is going to have the value of the first one so value is accessed by star a and we will change the value of a with b and Then star b equal to 10 and here while calling this particular function what we do is we can just pass the address correctly so let's say in terms a equal to 10 and b equal to 20. now to pass this what we do is we just call swap numbers and percentage and then Ampersand B why this Ampersand that is because this is a pointer and pointer needs addresses not just values and now if you put if you try to print a and b onto the console you will be seeing that they have indeed swapped over here so now the value of a is 20 and then the value of Base 10. so this is another worker on for call by reference where you want to change the actual parameters but we generally don't use such pointers we generally use the call by reference method which was directly passing address over here and then working with the addresses inside the function now what is the relation between a pointer and an array remember that when I told we were passing array to a function we are actually passing a pointer to the array now what does pointer have to do with an array so Ida is nothing but a collection right so this particular collection has a starting point and that starting point is defined by the pointer which is going over there so let's say we create an array uh int a equal to some foreign now let's just say C out a and what you will see is okay we don't need this we'll just remove this now what you will see is this particular address now why did an address come when we are calling an array that is because this first element or if you just say a0 and then put an and over here that is going to be the same thing as this thing so let us just print both of them together so that we can compare so C out a and then a new line and and is zero right so if you run this particular program what you will be getting is these addresses which are essentially the same thing so this particular a which you are referencing here is nothing but a pointer to the first element in the collection so that is the reason when you pass an array to a function it is essentially passing a pointer to the first element and you can increment pointers right so once you increment a pointer let's say some pointer n star PTR is going to be the first element in the array so this is you can do it uh either way you can just pass in a or you can even pass a zero both of them mean the same thing right now if I do PTR plus plus or BTR plus equal to 1 or PTR equal to PTR plus 1 what happens is this will not increment the value over here it will increment the address now the address incrementation totally depends on what data type you are using so if it's an INT it will go forward by four bytes so if it's a float it will to move forward by four by two put your character it will go forward only by one byte so it totally depends on what data type you are using but if you're incrementing a pointer the data doesn't change but the pointers location changes now if you try to print just being pointed by this particular pointer then you will see that it is pointing to two that is because you are just incrementing the pointer from the first element to the second element now you can even run a loop through the pointer so what you can do is uh let's say to access all the elements what we are doing before is we were doing something like this entire equal to 0 and I is less than the length which is 5 I plus plus and here we were doing C out a i and this right so we're doing something like this now let's see the pointer implementation how to do this so we have a pointer so inch r i equal to a and then I will go till the length of this array now how do we determine the length now what we do is I is less than or equal to a plus 5 what you're doing is you're incrementing the pointer over here not the value of array or the array you are just incrementing the pointer which is nothing but this pointer plus 5 is nothing but till here so what you are essentially going to get is the pointer or the address to this particular location and that address you will compare with the address which are right now and if it goes till here it needs to stop so you can directly do I plus plus over here and here you just need to put star I so this is the pointer implementation of getting the elements from an array now if you run this you will be getting the same thing but here you have a weird value now why did that happen that is because this particular value is the value stored in the collection outside the array now every memory location has some default value and this is the value which is stored in the collection which is just beside that we just went one further that is because I have put I is less than or equal to a plus 5 if I had put I is less than a plus 5 then it would have been correct but what happened is since I put is less than or equal to a plus 5 it went to one location further so this is the location which is just beside this collection and that is why the value inside that location got printed and this is some garbage which it doesn't have any meaning it's just there right so now since I changed this if you now execute this you will be getting the same output right so something like this now another very important implementation of pointers is the void pointer now let's say I create a integer pointer style PTR and will have an integer variable let's say I wire equal to 10 and we make the pointer point to this particular eye Wire by giving the address now if I just do PTR then I will be getting the address of this particular i1 right now let's say I create another variable called F1 which is float variable which stores some variable right 3.1415 no if I try to change the location of pointer it won't permit me to do so it says cannot convert float start to install that is because I had implemented the pointer as an integer now to change such locations what we do is we have a void pointer now what void pointer does is it cannot print the value but it can change the location so this particular operation is permitted by void pointer so if I now do PTR and then we will see two different addresses on our screen so these are the two addresses uh it's not separated by new line just just do that and we'll run it again so here you can see there are two different addresses that is this is the address of this particular eye where and this is the address of the float variable now uh the only drawback is that you cannot get back the value so if I do star PTR over here you will see that it will put an error over here it says that void star is not a pointer to object type so if you just want to store the address of different variables or different types of variables you can do that but you cannot get the value to get the value it has to be the same data type as the data you are going to point to so this is how we use pointers in C plus plus now let's just quickly talk about how to implement such a dynamic collection which I just discussed before so in C plus plus you have something called a STL so STL is nothing but standard template Library let me just write it down here standard template Library so what it has is it has previously implemented readymade functions for you so it has functions it has classes and we'll talk about water classes and how to use this particular STL at a later stage we will just discuss uh how to create such Dynamic containers or dynamic collections in our memory just like what we had discussed before so to do that in C plus plus there are two implementations these two implementations totally differ by the use cases one is nothing but a vector and the second one is the list so previously we had discussed about this particular implementation which is called a list right so the one let me just open this paint so uh this is the one which we had just discussed right we have different memory locations randomly put in the memory and then we will connect all these locations with a pointer like this now the difference between this implementation and the one we have over here is that this is called a single linked list as a previously discussed but this implementation which is there in the standard template library or the STL is nothing but a double linked list what a double linked list basically means is that you have links from here to here too so it is just like forward link and a backward link you have links in both directions so let's say this link points to here so you have another link which points from the previous element to the next element like this also so you can go either forward or backward as you wish so this is how the the list data type in STL is defined so this is called a double linked list or a dll for short so if you want to implement such data types in scratch we will discuss about how to do that in the next few videos but for now I had explained how this works to explain the importance of pointers right and the vector is nothing but a dynamic array so what it has is a normal arraylex structure it will store data in continuous memory location just like an array but what it does says it will have some extra spaces implemented so it does some calculations and then creates Extra Spaces for future elements and once the sketch filled it will search for another bigger sized location in the memory and then copy all the elements over here and then destroy this from the movie so all this gets copied over here and then you destroyed this completely so this doesn't exist now and this this becomes our new vector and this will keep changing and this process will go on till you stop inserting elements inside the vector now when to use a list and then when to use a vector so let us talk about that now vectors are used when you don't delete element often so in this implementation let's say we delete some two elements from the middle so let's just change the color and we deleted these two elements and then you have some ton of elements over here let's say you have 500 elements over here and then you have let's say 10 elements over here and let's just say that this is the size now if you want to delete these two elements what you do is you create another memory location somewhere and you copy this you just leave these two elements and then copy all these things again then you destroy this memory location so that's how vectors do it and in list it's pretty simple so let's just clear this now to do is deletion in a list what you do is you directly just remove this link that's it this is gone now what you do is you just create another link directly over here and the other link to in case of double linked list and this will go in the memory so once you're not using it it's gone right it is completely Disturbed from my memory so what you need to do is you just need to change the link so that is how simple it is to delete elements in list so in case you have a problem where you want to delete elements often from the middle that is more important you need to implement less right so if you want to delete elements from the middle or uh you are going to perform frequent deletions then you need to use a list or else Vector is a better choice because in list if you want to go to the third element you need to Traverse all this way right you need to find the first element in the second element and then third element but in case you are using a vector what will happen is it's a continuous memory location like an array so if you want to go to the Third location you just in increment the pointer with 3 and then you will get to the Third location that's how simple it is to access elements in a vector or in Array both are almost same so that's the thing if you are using a vector you need to use it when um you are mostly going to access the data right and you need to use a list if you are going to perform frequent deletions so these are the two points to remember and to implement it it's very simple you just include the list first so let's talk about the list and so to create a list what you do is you just put list and then in pair of such angular braces you put the data type what you want so let's say integer list for now so let's call it l and then to add elements you just say l dot push back push underscore back and then you put the image so let push back let's say 20 and then l dot push back 30. so by doing this you will be pushing back all this element so you have created a list which has three elements which look something like this and then if you want to access the elements it's a pretty clumsy way but this is how you need to do it what you do is you create a pointer for this list and for creating a pointer or such a STL data types you have something called an iterator so to do that what you do is you create an iterator for this list so you put this and then you put two search colons and you type iterator so this is how you create an pointer for this list for any such data type which is inside sdn and to move this you do the same thing so it will start from let's say or let's say just I it is going to start from the beginning so l dot begin begin returns a pointer to the beginning and then it has to go to the end so I is not equal to l dot n you can do that so end will again return a pointer to the ending element and then you can do I plus plus just like all we did with pointers and then to get the data you just do star I and then space so this will return us the data so if we now run this you will be getting the data which you entered so 10 20 30 is the data you will be looking how to implement this thing from scratch afterwards but for now this is how you implement in case you wanted to implement a dynamic list and to implement a dynamic array you need to input vector and Vector almost works like this but you have some feasibility right you can work with this like an array so Vector int let's say with and to add elements you do the same thing Big Dot pushback and then add the elements and to access the elements you do same thing like an array so in time equal to 0 and then I is less than the size which you can get by weight dot size and then I plus plus and you can directly access the elements just like you would do in Array you put a square brace and then put in the index so this is how you can access elements in a vector and this will give you the same result so that's how you use Dynamic containers or dynamic collections in C plus plus and that's how pointers play a very important role in designing such containers we will be talking about how to design our own data types and then go to design such collections at a later stage in this video we'll learn how to create our own data types using structures but before that let's first understand what objectoriented programming is now objectoriented programming or objectoriented programming structure as it's upgraded as oops it's nothing but a way of programming so what we have been doing till now is all procedural programming where you create procedures well procedures are nothing but functions and what we have been doing till now is we have been analyzing a problem we have been breaking down the problem into set of simpler problems solving them and then combining the result to give the output now procedural programming works for almost in every problem but when we want to generalize our Solutions procedure programming won't work so let's take an example let's say I want to create a student registration program now for student registration I Define a name I Define an age I Define IES or let's say vectors when the user doesn't know how many records is going to enter and then I will accept all the records and then save them so that does the student registration process now let's say I want to create a program where it the student registration but also it will give us some additional information let's say it's going to say um who is the highest scorer of the class right now what we do is we do all the same steps required for the student registration or the registration to happen and then we write additional functions so that we can compute the highest score or whatever it is now to overcome this problem or to generalize this particular kind of problem solving methods what we do is we create General objects so objects are nothing but collections of similarly grouped features now Here If You observe student is an object right so student has all these features of registration and then students has marks age name and all the features which are required by student and now what you do is you create such an object or you create a class where all the features are grouped together and then you use that particular class whenever you want so if you remember from our pointers video we have been doing something like hash include Vector where we include our vector class this is a class where you have all the features defined inside this now when you want to use it you just create a variable of the vector so you just say vector and where now what we have done is we have created an object of this particular class it's just like creating a variable or a memory location of this particular data type but in object oriented programming we refer to them as objects and classes now what we do is in case you want to add some item into this you just say vector.pushback so although you have so many methods inside this particular Vector but what you are interested in is just storing so you just say push back and then you just put them number you want to insert inside this so this is how objects work you don't know what is going on over here you just know that if you do pushback it's going to go inside the memory and you're seeing that so there's a whole lot of code implemented behind this but you can understand that this particular function is pretty much complicated to implement and it has been implemented for us you just need to use it so you you have a readymade implementation and you whenever you want to use it you just say dot push and then you can get the function to work so that's how object oriented programming helps us to overcome such redundancy and when we create objects we generally generalize the object so that it can be used for any type of problem where it involves that particular object so that's about object oriented programming now there are some technical terms you need to understand bonus data encapsulation the second one is abstraction or data abstraction and then third one is polymorphism we'll be talking about these things in a great depth at a later stage but for now you can understand encapsulation as combining the features so when you combine all the features which are required by a particular object that is known as encapsulation and abstraction is you show only what is required so here if you see the pushback function is actually an implementation of abstraction so you don't know how this works but what you can do is you can just put in a number and then it goes and sits in the memory and to use such a function it is not required to know how it works so that is abstraction and polymorphism is nothing but able to use the same thing in different ways we'll be talking about this later stage when we are discussing about classes but for now this should do and we'll now get to defining our own data types or as an objectoriented programming we should be calling them as classes well classes and structures are actually different things in C plus plus also they both are literally the same thing so in the implementation of classes and structures you won't find any difference between them but we'll just stick to the Convention of using structures only to Define smaller objects and then use classes to Define somewhat bigger objects why these two things are there but when these two things mean the same thing well C was not an object oriented programming language when C was introduced it did not have this kind of capability to create objects as I've just discussed before so what it had is it had a capability to combine two or three data types and then store it as a collective data type that's what it had and that's what structure was for so when C plus plus was introduced it was made to be object oriented programming language so what they did is they just extended this implementation so that it could hold collections of data types and also it could perform features which I just discussed before you can hold functions related to that particular object or it can undergo inheritance and all those things we'll be discussing about that later that is how structure was designed but when programmers were shifting from C to C plus plus they did not like this idea of using structures in different ways and moreover many objectoriented programming languages which were introduced they had the process known as classes so for that C plus plus introduced another thing called flash but this is just a history it's just a convention but you can use both of them in a similar way in C plus plus right so now let's talk about structures how to use them well do you create a structure you just say strength and then a name of the structure and will call this something let's say student now this is student class or structure you can just call it whatever you want now this particular class that is the student class or student structure this can hold features now what are features does a student have let's say the student is a name a student has an age so end age and what all can a student have let's say marks so let's say a vector in marks now this particular structure or this particular class is just like a data type you can create variables from that so let's say we want to create a student variable you just say student and then let's say S1 now you have created a student if you want to assign a name what you do is dot name and then you assign name so let's say Tony and then to assign an age it's the same way age equal to 10 and then if you want to assign the marks it's just like putting it into a vector so S1 dot marks dot pushback sorry push back 10 and then S1 dot marks Dot pushback 20 and all those things you can almost use it just like you're using but the thing is these variables are dedicated only to this particular student or S1 if you create any other student let's say S2 this is a completely different object and all these things don't work here so if I just say C out S1 dot name you should be getting Tony Asha output that's because s1's name is Tony and now if you change this to S2 you will be seeing that it is blank so as you see here nothing has been printed so that's how objects come handy now if you want to just use the name of the student you can just use the name from here and then you just neglect all these things you don't have to just Define the name Define the age and everything you will have this file somewhere and then whenever you want to do it you just say hash include and then student in double close we will be seeing how to implement this the next video but you can have this in a different file and then you can include this like this and then you don't need all these things you can just say a student S1 S2 and then S1 dot name equal to Tony and this thing will work so that's how you can Define your own data type in structures or as I told you this is nothing but a class and you can have functions associated with it too so let's say I want to create a function which will give me the average marks of this particular student so what we do is I will create a function just like I create normally so avoid average and this doesn't take anything because everything is defined inside and to work on this particular function what I do is I just say In Sum equal to 0 and then calculate the sum first so oriented equal to 0 is less than this marks dot size and now this marks are for the particular student this is not the class marks but it's called this whatever student I'm accessing so that marks will be considered over here and then I plus plus what they do is sum equal to sum plus that marks I and in the end I just returned sum over total now the total is nothing but three total in the sense the total number of marks so marks dot size will give me the total number of marks now here I can just call that function and get the marks so if I just say S1 dot marks Dot pushback something so let's say 10 and then 20 0 marks Dot pushback 40 and now if I call dashman Dot marks sorry sman dot average which is which was a function now this should return us this average okay that's because there's no student file okay what does this say yeah that's because I have put void over here so int and then now if we run this we will be getting 23 as our average marks that's correct because what we have entered is 40 2010 which is 70 and 70 over 3 is 53 so that's correct so that's how you use objects in C plus plus and that's how you create your own data type using structures and here if you see this particular implementation is actually the example of abstraction so here the user actually doesn't know what is the actual computation which is going on behind the screens but he will be getting the average and this is how you implement abstraction and the whole thing is actually encapsulation so here you combined all the features this average is a feature of student and the marks age name all these things these are just features of a student and then you combine all the features so this whole thing is nothing but in capsulation so in the next video we will be understanding how to use classes and when to use classes and structures well you can use them interchangeably there is no restriction on that it's just by Convention as I told you before classes and structures are literally the same thing in C plus plus but it's just that convention matters over here when you're giving your code to somebody else to develop more you need to strictly follow the conventions right in this video we will be looking at classes in C plus plus but before that let's first discuss a small concept which I had missed in the previous video that is how to use pointers when using such Collective data types here if you see we have the student structure which we had defined in our previous video I have just added one single function to print the details of storage and here I have created a student with the name Tony age 10 and then the marks of these things now if you want to create a pointer it's just similar to the way you do for a primitive data type you just put style PTR and then you put PTR equal to the address of the student now if you want to access a particular feature because in primitive data types we did not have features right we just had data so if we did start PTR this was enough but in case of a object we have so many features we have two functions and then we have three variables how do we access these things separately well star won't work here and we have a special operator known as the arrow operator well what this does this basically allows us to access separate features of an object and the way you define our Arrow operator is by using a minus sign and this greater than symbol together so if you combine them that looks like an arrow so that's from where the name comes well if you want to use it you just say PTR that is the name of the pointer the arrow symbol and then the feature you want to access so let's say I want to access the name so if I just put name and then execute this I will be getting a name over here so age also works the same way if I just put age and then try to execute this I'll be getting the age and if I want to access some function let's say the average function I can just do that from here so if I put average and then call that function I'll be getting the average over here so that's how you use pointers the only difference is that instead of star you are now you're going to use this arrow symbol and this is a very important concept as we will see in a minute this is we'll be using a lot when using classes so now let's dive into classes well the way you'd work with classes and structures remain the same so if you want to change this definition to a class definition you just remove the structural keyword and then put class over here so this now becomes a class well the dot operator and then the way you work with pointers this arrow symbol all these things remain the same so you don't have to do anything so now let's do something like then dot print details now if we try to execute this particular function we will be getting an error so let's see what that is it says that this particular name is private well if at all there is any difference between a class and structure that is this thing a structure is public in nature and then class is private well this is not a big deal we can change public to private and private to public we will just talk about that in a minute but what is public and private well in object oriented programming when you are creating objects or when you are creating such Collective data types we don't want everything to be accessed by the outside agent or the user let's say so if we are creating a student data structure and the purpose of this particular data structure or this particular object is just to store the details and then show the details then you don't want the user to manipulate the details right so if I give the access of this marks to the particular user he can manipulate the values inside right so same with the name and age also so if you don't want some of your features to be public in nature that is you don't want some of the features to be accessible by the user you can put them in the private section so how do you put that you just need to put private over here and put a colon over here so in a class everything by default is in this particular definition so if you if you want to make a structure into a class you just need to remove this class and put structure over here now this particular entity is just like a class you will be getting the same error when you executed a class and if you want to create a class into a structure if you want to change a class into a structure what you just need to do is you need to change everything to public now if you change it you will be getting the output just like we got in case of a structure so that's why I told there is no difference between a class instructor although we don't use access specifiers these are called access specifies because they are specifying the access of this features right so we don't use them in structures that's just by convention you can use them there is no restriction on that but we generally don't use them we just use them with glasses so can you have multiple access specifier inside a class well you can so these just Define different features to be either public private so there's one more thing called protected which we won't be seeing in this particular video because uh we'll better understand it when discussing about inheritance but for now we'll just discuss about public and private so as I told you these things become private and I want only the print details function to be public so I'll put public over here so whatever is below private becomes private and whatever is below public becomes public in nature now I can access print details without any issues but I cannot access all these things then how can I actually create an object with these features that is I want the object's name to be Tony H to be 10 and marks to be these things how do we do that if I don't have the access of this variable itself well for that you can Define another function in the public section you can say something like void set detail something like that these are more specifically called Setters these are called Setters but Setters are used only for a single variable so if you want to assign variables at a time when creating the object itself you generally use something called Constructor well Constructor is basically a special function which is used to create the memory when you are creating an object of this type so let's say you are creating an object of this class student you need memory to hold these three variables so Constructor takes care of that particular memory requirement and you don't have to explicitly Define the Constructor although you can and many people use Constructor to assign variables when you are declaring them so in our case we are declaring these variables right which are private in nature so in case you want to declare them while creating you can either use a Setter function or many people just use Constructors for that so the way you define Constructor is it doesn't have a return type so you just need to omit the return type it you should not give any return type and then the name should be the same name as the student so over here you have student as our class name so that should be there and then you will just Define it just like a normal function and here you can pass in parameters and all you have different names for that so if you have a normal constructed definition like this this is called a general Constructor and then if you have parameters inside that let's say string name and then int age so this is called a parameters Constructor there are different names I encourage you to look that up but for now we'll use this particular parameters Constructor and here we will pass in another variable the marks variable and now there is an issue if you see the objects attribute or the object's feature called name is clashing with this particular name well you can change it so that you don't have an issue like this but as I told you when discussing the pointer just now that that's going to play a very important role in classes and that says where this comes into play this is is basically pointer it is called this pointer only so if you just put this you can see that it is bold it indicates that it's a property of the compiler it's a reserved keyword this is basically a pointer which will point to the current object itself so let's say I have 10 students and then I'm working on the seventh student so if I use this pointer then I will be accessing the seven student details not any other student details so this basically points to the current object which is getting used and then we use it just like we did in case of our own pointer so this and then this particular arrow symbol which is called the arrow operator and then the variable name so name equal to name you could say this age equal to age and then this marks equal to Marks well if you don't want to use this particular definition you can always rename this and this won't be a issue but just explain the importance of this particular pointer and this Arrow operator I just took this particular example but you're free to use whatever way is convenient for you many people tend to use this particular definition and here when we are creating you just need to pass in when creating itself so here if you put parenthesis and then pass in your variables so name equal to Tony and then the age is something 10 and then the marks well you need to create another variable for marks or marks and we'll push back all these things inside this particular new variable you don't need s over here because this is an independent variable now we just created a new variable in our memory and here you just need to pass in marks and now if you just remove all these things this should work as expected so if we now run this you will be getting the output just like we got in a case of structures and now you have successfully implemented an object oriented design so something is private something is public you are not giving access to everything and all these are basically features of object oriented programming so now let us see another very important function which is a special function called the destructor well this is not used much but since it's the part of object oriented programming we'll discuss it quickly it's basically the same thing as a Constructor it is defined by the compiler itself it's a default thing it Destructor what it does is it will scrape out the object from the memory so if you are running out of scope so let's say we had defined this object inside an if block so once the block has been executed that variable is out of the scope right so once everything gets out of the scope it's going to be scraped out of the memory so that's when a Destructor is called so if you want the destructor to do something else you can just do that by putting this tight symbol and then you define the destructor with the same name as a class and again you don't put any return type for the destructor and it does not even take any parameters so you cannot pass any parameters to Destructor you cannot call the destructor from anywhere you can just see what it does so if you just call this descriptor let's say uh I'm being scraped something like that you will be seeing this when the object gets out of the scope so um we'll just put something over here if some condition 10 equal to 10 this is going to be true so all these things will be executed and over here we will put something like done we'll put a new line also so that we can differentiate so if you know execute this you will see all this details and then it says I'm being scrapped and then done that is because once the F block has been executed that particular object has been removed after the scope that then it should be ready to be removed or to memory two so just remove that thing from the memory that's why this message is printed and then you have this done which is outside the if block which indicates that this has been scraped before coming over to this statement so that's the use of Destructor if you want to see when the object is getting removed from the memory you can use Destructor we will again talk about this when we are discussing about inheritance but Constructor is mostly used to actually pass in parameters when we are declaring a particular object something like this so now how do most people use classes in C plus plus well mostly people don't use classes in the way we used over here we wrote the class definition and the main function everything in a single file right so people generally don't tend to do that people generally use multiple files in their program so you have one particular file only executing the main program and then you have multiple objects so you don't put all the objects in a single file you create multiple files for holding the objects and then if you want to use this particular class let's say the student class you just include it just like this particular Vector so what you do include and then you put the student over here student dot h that's an extension we'll be seeing how to create this and here instead of angular braces you need to put this coach so this indicates that this is something from this particular directory and not from the compiler so these things are available in the compiler that's why we are putting this angular braces and here you are putting this to indicate that this is from from this particular directory or this particular project so you have two files when declaring such classes so what you do is you have one header file where you declared the skeleton of The Flash and then you have one CPP file which is just like this one which will hold the definition of this class so how do you substrate that so let's say I want a particular function to diff to be defined in a separate file so let's just say this particular function uh called to be defined a different file so how do we do that you just need to put a semicolon over here so this is just like a function prototype which we had discussed and let's assume that this is another file so this class is in some other file you just did something like hash include student.h and then if you want to Define this particular function the way you do that is you just Define this function normally as with this is just a normal function it it doesn't have anything to do with this class You just defined it so let's say uh I'm called and something like that you just Define it like this and then over here to Define that this particular function is specifically designed to display particular class or this function should be available only to this particular class what you do is you just put in this particular class name and then you put two columns over here so this will indicate that this particular function is to be used only with this class that is the student class now you cannot use call directly you need to call it using the student class so if you want to use that so you can say something like s dot called and it will work normally so that's okay we don't have the student.h right now we don't need these things also so if you run this okay there's another type over here okay so here you can see I am called that is from this particular function which we just defined that this called function over here and uh here this is the message from the destructor that is I am being script so that's how we actually use classes but this particular ID which is the code blocks ID provides an easier way to create classes you don't have to Define all these texts that is you don't have to create two files and then put them it will neatly organize everything and give it to you so how do you use that well go to file you go to new and then you create a class over here so you have class name so you just give some name let's say student and then here in place of arguments you just leave it so it has hash Destructor virtual Destructor all these things you don't have to understand all these things right now you can just ignore them but I will understand what all these things are in later videos and now if you just click on create you can see that the new class has been created do you want to add it to the current project if you just say yes and then you just put OK over here and then you will see that in headers you will have an include folder inside which you will have student.h so here if you see it just has the definition it just increase the font size uh here you can see it just has some definition you don't need this this is basically the virtual distractor we'll talk about that later and here you have a Constructor and you have protected and private you don't need protected also as I told you we'll be discussing about that when we are discussing inheritance and you have some special comments over here so what this roughly means is that once a particular class has been included in a memory and if it's again trying to include it you don't do that because we are using two files so let's say I'm using a function from this particular file so when I don't want this particular function to again include it so here you can see hash include student.h so when I'm doing it multiple times I don't want this particular class to be loaded into my memory multiple times so this particular guard block will as it's called This is called a guard block card block what this will do is it will take care of this particular issue it won't allow this class to be included in the memory multiple times now and here you just declare the skeleton so here if you see uh if you want to create this particular class again uh we'll just create a small version of that so it will just have a age let's say in age and in public you will have a Setter function you will just say uh set age or new interest directly use it inside over here so in page you can just say and private I prefer private to be in a beginning but it's up to you the order doesn't matter I just put private in the beginning and then public at the end protected in the middle so that's our I use classes but it doesn't matter you can use it the way you prefer and now you just need to Define this Constructor in the student.cpp file we don't need this virtual Constructor I just deleted that and here you just Define it normally so age is something private but you can access private variables inside a class so you can say something like this age equal to age and here if you want to use this class let us just remove this class because I've already defined it so remove this and if you want to include that student class you just say hash include and then student.h and now all these things work fine well we don't have everything over here so we need to redefine it so let's quickly do that student S10 and if you execute this what do we have here it says yeah because we forgot to put the parameter over here it is int age and see we did not get any error so that's how we generally use classes if you want to create another class go here new and then class and you can create another class so people generally tend to use classes like this you have neatly structured thing over here so you have a main.cpp over here and here the student.cpp goes inside the source file so that you don't get confused so everything the header files which I talked about the student.h or anything class header files are basically class name dot h and all these things go inside this include folder and the definition file which is basically class name dot gpp all those things go inside the source folder and Main file will be outside and you can use that main file to execute the program everything starts from the main file generally name that as main.cpp where the execution starts and we include all our objects like this using this particular syntax that is you pass in the classname.h file using this particular quotes and the guide block which we just talked about this one this basically takes care of multiple allocations of memory of this particular class so that's all about classes in the next video we'll make another one of our projects so our previous project was the tictactoe game well we'll again make another game in the next video because I think games are fun to make and then we can learn a lot from them in this video we'll be making our second programming project which is going to be this the snake game so I'm sure everybody knows how to play this game you have a snake which grows on eating the food and the objective is to grow the snake as long as possible without hitting yourself or hitting one of those so if you do any of those you lose this game well there are different variations of this game some have teleportable walls that is if you go through this wall you end up coming from there and some versions even have obstacles in between them instead of this free space but we're not going to do any of those we are just going to stick to the simple version with four concrete walls and uh empty space in between right so let's get started let's create a new project it's going to be a console application and the language is C plus plus project title let's say snake and these things remain as it is right and now let's first start by defining the board so if you remember from our previous project where we made our detector game we had defined a 2d array or a matrix to hold the board right but here if you see you don't need that why well in the previous game where we made the tictactoe game the board only had nine elements and we were concerned about all the nine elements of the board right so we were concerned about what all the boat contained but here you don't have to actually be concerned about all the elements of the board here the boat just acts as a background the only things you are concerned about are the position of the snake uh the position of the fruit and the position of the wall so other than that you don't need to keep track of other things so here we are just going to print the board just like we print something on the console so let's define a function for that let's say avoid the board and here we are going to draw the board so uh let's first Define the dimensions of the board the width and height so let's say uh the width is going to be somewhere around the 50 characters so since we are working on the console you are going to see everything in terms of characters or this is basically a substitute for pixels if you are familiar with graphics and the height is going to be somewhere around let's say 25 characters now these two things are constant right so the these won't change throughout the project so if you want to make them as constant so you can just say const over here so this keyword will make these things as consonants and now I would like to introduce you the concepts of macros so macros let me write it down here macros these are nothing but one liner code right so let's say you want to Define a function to calculate the square so what you do typically is you write something like this right so in SQ and this will return X into X right so this is how you define a small function but what you can do is instead of defining it as a function you can Define it as a symbol so when I pinch symbol what I mean is if I type that particular symbol then this operation should be performed so that is what a macro does so the way you Define macro is you put hash Define and then you put the symbol so let's say SQ over here and inside this whatever parameters you want to pass without any data type so this is basically a symbol and here you want to define the operations so here uh our operation is X into X so that is basically going to return us the square of a number so here you don't have any assignment operators or written operators all this means is whenever I say SQ of X it should do this particular operation so if you say something like SQ of 5 and here if you run this you should be getting the output as 25. so that's why we use macros and you can do the same with these two variables also so the way you define it as hash Define width is 50 and hash Define height 25 so now whenever I say width I mean 50 and whenever I say height I mean 25 so now we can remove this you don't need this anymore so now the board is going to be two Loops the first Loop or the outer loop is going to control the number of rows so here the number of rows is defined by height right because height is basically how down you go so that is how many rows you have in your board so I is less than the height of the board and I plus plus and inside this you will control the width so enter and let's say J equal to 0 J is less than the width J plus plus and inside this you are going to print something so Here If You observe this board for every row there are two wall pieces right so every row starts with one wall and then ends with one volt so since that default you can subtract 2 here and then put those two characters so you have one ball in the beginning of a row and one wall at the ending of the row and then you go to a new line and inside this basically if the row number is 1 or the row number is height minus 1 that is if you are printing this row or this row then you need to print all walls so here we are just going to print out these hashes or else you need to print out the empty space which is basically this space right so now if you call your board function that should print a board for us so here we have the board now this code looks pretty squished to the left so you can take care of that by adding a couple of tabs and that will Center the board so now let's see how to animate things on the console so if you are familiar with Graphics or even if you have heard about animation you might know that animation is nothing but just fast moving pictures right so here if you want to animate something on the board let's say you have some object on the board then the way your animators you will quickly move the position of that object and it will appear as moving so to move something on the board or to place something on the board you need to know about the coordinate system which the computer uses so let's talk about that quickly so you might have come across this Cartesian coordinate system in your math class right so you have a coordinate system where if you go right the x coordinate increases and if you go vertically upwards your y coordinate increases and this position basically which is the intersection of these two axis this is the origin which is defined by this 0 0 coordinate right so this is the coordinate system you all have come across in your math class now what happens in a computer is this origin is shifted to this top left corner so let me just clear this thing so in a computer your axis are defined as follows so if this is the top left corner of the screen that is this position where I am pointing my cursor that position is basically your zero zero position so this is your origin in a computer and I should go write your x coordinate increases and as you go down your y coordinate increases so basically your yaxis is flipped in case of a computer and X Remains the Same so as you go up your Y is decreasing and as you go left your x coordinate decreases so the coordinate system in a computer is defined you can use this coordinate system to move objects in your screen or even Place objects in your screen so every object is defined by x coordinate and y coordinate so if you put some point here so it has some x coordinate that is how much it has moved from the origin in the horizontal Direction and some y coordinate that is how much it has moved from the vertical direction right so this is how the coordinate system of a computer is defined and we will be using this system to operate on our board right so let's define an arbitrary object somewhere so let's say our int X which is the x coordinate is going to be somewhere around 10 characters and Y is also 10 so that means that this is 10 characters from the left and then 10 characters down so it it will be in some arbitrary position somewhere let's just see where it is so if I here if I print that particular object that is pretty simple to print so if the coordinates match you are going to print that object so how do you do that well I is controlling the height right so height defines how deep you are on the board so that is basically the yaxis so you need to compare I with Y and G okay with X so if you if these two coordinates are equal then you can say that your object is at that particular position and you can print something so let's go with this zero for now so that is going to be our object now if I try to print this code you will be getting your object here so and this is 10 characters from the left and 10 characters towards to bottom but if you see this position is exactly not as Square as expected uh that is because in console the next line has some Gap if you see over here so this Gap is much bigger than this Gap that is why it doesn't end up as a square but if you are using some graphics library then this will work so it will exactly be as a square so it it will end up somewhere over here so this could be the 10 comma 10 point but here since we are working on the console uh the yaxis is much wider or I should say much deeper than the xaxis so uh even when you animate your snake it's going to move faster on the vertical Direction than on the horizontal Direction that's actually not a logical error that's because of the property of console you cannot do anything about that right so if you are using any graph fix library then that problem won't be there so now let's see how to animate this animating is very easy you just need to move the board right so uh let's say I will create an infinite Loop here and inside this we will first call the board and every time this Loop runs we will just increment the x coordinate so when entrance x coordinate from this coordinate system your object is going to move towards the right right so now if you're on this program you should be getting some kind of movement so here you can see that this o is moving towards the right but you cannot actually see it as a movement this is basically it is just printing the board again and again so if you have somewhere to update the board then you can see the movement so one way you can update is you can use your console command so if I pull up my console over here this is basically a Powershell but uh in Windows or if you're using this code blocks in Windows it's going to use the use your CMD as your default console right so in CMD the command for clearing a screen is CLS so if I type something over here under type CLS that thing is cleared right and if you're a Linux the command for clearing is clar and the way you pass in such shell commands or such console commands are you include another Library called cstdlib which stands for C standard Library you might have come across this while making a tictactoe game this is the library which had our random function and we will be using that random function in our code as well right so here to send commands to the console you use system and inside this you write the command so in in my case it is the Windows operating system so I write CLS and in case you're on Linux you need to write clear right so let me just comment this thing if you are in Linux you need to write clear and I forgot the semicolon and now if I run this I should be getting a moment but if you see here it kinds of flickers on my screen right so this board is getting updated but it is annoying to see so uh this you cannot actually control so more technically if you know about the FPS or the refresh rate so you cannot control these things of a console console is not a property of the language or this ID right it is a property of the operating system so you cannot control something from an external source which belongs to the operating system so one way you can take care of this flickering is instead of clearing the screen this is happening because it is doing two processes right first it is clearing the screen and then again it is drawing the board so if you just override the port as we used to do with our normal line so if you remember from our Escape sequences video we had talked about an escape sequence called slash R right so if you write something over here let's say hello world and here if I put slash R and I type something else so ASAS then the first four characters which are these four characters are going to be replaced by the word ASAS so now if I run this I should be seeing as ASO word so that is because HG LL has been refreshed by this that is because this slash R will take the cursor from the end of the line and place it in the beginning but we cannot use the slash R over here that is because we are using multiple lines right so you are printing around let's say 25 lines because the height is 25 so you are printing 25 lines and there is no escape sequence to get your cursor back a line so slash n will move your cursor down a line but you cannot go up a line right so for that I am going to tell you a solution but this is going to work only if you are on windows so let me write it down here this is only for Windows and if your Linux you need to find out Library which tested so basically what we are going to do is we are going to pick up this cursor from the end of the screen and we are going to go all the way up to the origin and place it back so if you do that instead of clearing the screen you are moving the cursor and when you print your data again it's going to be overwritten on the console so it looks like it has been cleared but actually it has been overwritten instead of clearing so this solution what I'm going to give you in this particular video will work only if you are on windows so if you are on Linux you need to find out some Library which will do that for you right so if you are in Windows you need to include a library called Windows starter which will basically allow you to control the cursors position on your console and here what you need to do is instead of system clear you can do set console cursor position and here you need to give some handle which is get STD handle Insider STD output handle so if you don't understand what this means it's okay it's just you can think of it as it's going to pick up the cursor from the end and it's going to put it back on the origin and to put it back on the origin or any specific chord that you need to pass in a coordinate data structure well coordinate is basically a simple data structure which is already defined in Windows dot h and we will be using this so if you're on Linux and you're using some other library to achieve this you need to Define this structure to follow along with this tutorial which is basically a simple structure it does something like paint X and Y so this is the structure which is defined in Windows so I'm not going to Define this again it's there in this Windows dot Edge and that's what we are using over here to send the position to our handle which will basically take the cursor from this position and then put it back to the origin so the origins coordinate are basically 0 0 so you need to pass that in and now if you see you won't have any flickering screen you will have a neat animation going on on your screen so as you can see there is no flickering although you can see that cursor updates somewhere but this is much better right instead of the flickering screen so again this solution is only for Windows user so if you're in Linux you have some other libraries like uh you have n cursors and many other libraries a simple Google search will get you what you want right now let us remove all these things we have now understood how to do animation and here what we're going to do is we are first going to Define our snake so go to file new and Clash and the name of the class is snake and you can remove all these things right it doesn't really matter you don't need Destructor on all these things we'll create if we want to right and here just click OK and in snake.h we have this template code so again I prefer private to be on the top so if you want that you can follow this or if you if you are okay with the structure it has given before you can follow that it doesn't really matter and here first of all we are going to decide what is going to be private and what is going to be public so what are the features that we need our snake to have first of all it will have a position right the position of the head to be precious and next it should have a length to Define how long the snake is and you also need a Direction and you also need a velocity or you can say speed of the snake so how fast it moves so here in case of velocity or speed we are going to talk in terms of number of characters so let me write it down here that is basically it is going to move two characters at a time three characters at a time and so on so in case you are working with some graphics Library that's the same thing you do with pixel so you say three pixels every time more five pixels at a time and since here we are on Console we are going to talk everything in terms of number of characters right so uh here let me Define the private variables first thing is you are having to have a position so it's going to be chord position so again if you are in line if you need to define the structure and uh for using this code you need to include uh windows startage okay so this is because this is a separate field Which snake cut HSS update file so even if you are included in main you need to include it again but you can exclude this over here because once we actually include this file you are going to include all these things it doesn't matter even if you keep it twice because of this guard block as I explained before this guard block what it does is it takes care of multiple initialization so here I have already included windows.h now I when I do hash include uh snake.h it will take care of the fact that I have already included Windows started so I don't need to include it again but here if you want to use these things you need to definitely specify that you are using windows.h or else you cannot use this and will throw you an error right and here you need a length of the snake and you have a velocity so and well and you have a Direction so let's say car Direction and in the public section we need to Define Constructor first and this is going to take a position that is the initial position and initial velocity for our snake so let's define this Constructor and snake.cpp and here we'll be talking specify those things so chord position and end velocity and here you don't have to include Windows attach that is because again you are including snake.h which comes with Windows started so you don't have to include it again and here you need to set the position and velocity so since I'm using the same name for both the variables I need to use this pointer so if you are not using the same name it's okay but if you are using the same name you need to use this pointer and the velocity also goes in the same way and initially the length is going to be 1 that is because you have one head right so without the length cannot be zero because you always have a head for this link so the length is going to be 1 initially and the direction so the direction you can say uh something like none right because the snake is not moving now and we'll have a method to change the direction of the snake so let's say uh change dir which will change the direction it will take some direction to change it and here let's define that method let's void snake change dir a and what you need to do is Direction equal to Dr and basically I'm just setting the direction of a snake and um for moving the snake let's create a move method or move snake well moose basically a defined method in C plus plus so uh it's not preferable to overwrite it you can overwrite it you can define something like this but it's preferable not to overwrite any default method so let's say move snake I'm just not going to take any parameters because it's just going to perform something so avoid the snake move snake and here what you need to do is you need to switch the direction that is basically you need to move the snake in that particular direction so switch Direction and here you need to put different things so in case it is going up then what you need to do refer to this coordinate system you need to decrease the y coordinate so what we're going to do is pause dot capital Y minus equal to the speed so basically if I say that my snake is moving two characters per second or two characters per iteration then I need to subtract those many characters right to move to appear to be moving in that much speed so that is why we are going to subtract the velocity over here or speed you can name it whatever you want and here the break is mandatory and this will be true for all the four directions so let me just copy it down four times and uh it's going to up down left and right right is you need to increase your velocity left test you need to decrease your velocity and um for down you need to increase your velocity on the y coordinate so this will move your snake in your preferred Direction and that should be it so now you have a snake you have initialized it with some initial position and velocity and you have a method to change the direction of a snake and now you even have a method to move the snake and here since we need the position of the snake to draw it on the board you also need a method to get the position so let's say uh or the get post which will return the position of the snake and this is going to be written first and I forgot to mention snake here this will be declared as normal function if I forgot to mention this this basically means that this get pass function is related only to the snake class right I'm sure everybody knows this and here we will quickly Define a prototype for that it's called Uh get pause and done so now you have four methods let's go over it quickly one is a Constructor which will initialize our variables one is a method to change our Direction so change the direction of the snake and one is to move the snake in that particular direction and one is to get the position of the snake or I should say get the current position of this name so now let's use this thing in our main file so you here as I told you you can remove this window startage because it is going to be included with sneak.h and uh here let us first create a snake so snake as all it's a snake and inside this let's say it's going to be initially in the middle of the board so that's basically 50 by 2 and 25 by 2 or you can say bit by 2 and height by 2 that makes more sense right so width over 2 and uh height over 2 that is basically the center of the board and velocity let's say it's going to be one that is one character at a time and here you instead of Y and X you need to capture the position of the snake so call the snake pause you can see equal to um snake dot get position and here instead of Y you need to say snake pause dot Y and instead of J you need to say snake pause dot X so so far so good we have created a snake which is going to be on the middle of the board and which is going to move at a speed of one character at a time and here um let us just clear all these comments and now let's see how to get input so that we can control the snake so you need to move the snake only when you press something right so here how do you capture that keystrokes well you have a library to do that so that is called conio or I should say console input output and here you can just do the following so if you say f k b h i t so kbhit stands for keyboard head so it will be true if you hit a key on your keyboard not necessarily Enter key you can hit any key on your keyboard and this is going to evaluate to true and to capture your key you need to say get so get CH will basically give you the key which are just pressed so we will capture this and instead of capturing this we can switch this so that we don't have to write couple of if statements we can just say switch get ch which will basically give us the key and here you can control it so let's say up so I'm not going to do it for the arrow keys because I don't really remember the ASCII values of the arrow key so if you want arrow keys you need to give the ASCII value so let's say 132 is the highest key value of upper key it is not the case I'm just saying but if 132 is the ASCII value for the up key then you need to do something like this but I'm just going to go with wsd for now so case W then um what you need to do you need to move the snake upwards right so snake dot changed up sorry U and then break and you need to do this for all the four directions so Ctrl c v v v w a s d and uh D is basically go to right s is down and this is left for now this will more snake in our preferred Direction and to move the snake you just call snake dot move snake which will move our snake and now if you run this you will be getting a snake which can move on your command so now you can see that it is not moving because initially we had set the snakes direction to be n right so we did not have any case which will move the position for n so it doesn't move for any iteration and now once I press W you can see that it started moving up a it started moving left s it started moving down and D it started moving to the right so now I can control this little character and keeps moving right so that is how the snake game is defined so once you press a key it will keep moving in that particular direction until you change the direction so this is what we needed and we got a moving character on our board so now let's see how to first uh generate the food and calculate the points and then we will talk about how to increase the snake's length once it reach the food right so now let us just close this and talk about the food so again you need to create another flash for generating the food so it's going to be that's your food and again you don't need the getter Setter or the destructor created yes okay and uh here you have food.h and again I don't need these things so here the private section what we're going to do is we are going to have a position of the food right so that is mandatory you you cannot have any object without a position right so for the position you again need to include windows so windows dotage and it's going to be called boss and uh you do need a velocity well you don't need anything else you don't need velocity you don't need any uh direction for that put it's just going to be a point where if you go over to that point and then eat that food you are just going to generate another phone so basically you don't need anything else and uh in the public section the public section we have a Constructor basically well you don't have to pass anything to the Constructor it's basically going to initialize this position with some random value but if you see this game always this food starts at this position if you want something like that then you need to Define a initial starting position so as we did uh for our snakes you need to do something like that but we are going to go with random initialization right from the beginning itself so again for random function to work you need to include free STD lib and uh we are going to define a function called gen this is basically going to generate output and this is going to be avoid and we also need uh function to return as a position so it's going to be get us so this will return our position so let's define these functions inside this what we're going to do is just generate for hit first time it's just going to generate the food once you create it and uh for generating the food sorry snake sorry food junk food and uh what this is going to do is it's just going to generate two different random numbers in the in some range so if you remember the formula for generating a random numbers in the real that is U2 L it was basically Tran mod U minus L plus 1 so U minus L plus 1 plus l so this was the formula for generating a random number in a Range so here our upper limit is going to be for the x axis is going to be width and the lower limit is zero right so uh here you just need to say ran mod and then U minus L plus 1 plus l so uh for uh us the U is basically with minus the lower limit now lower limit if you keep zero then the food will have a chance of getting generated on the walls of support so you don't want that to happen so it's going to be 1 and plus one so these two cancel out so you just need to say run mode width and then plus L which is 1. again for uh the y axis the upper limit is going to be height and the lower limit is again going to be one so this will generate a random position for our food which will be on the board and for getting position it's very simple you just need to say for the food good position so we did not Define that well we did quad grid position and here you need to say return first so this will return the position of the current foot and that's it for food so you need to include that also over here um in our main file so here we need to say hash include food.h and here we don't need cstdl application again because we have defined it inside this food.net so that gets included automatically and uh here we need to create a food object So Below the snake let's create a food so it's going to be food and uh as a Constructor doesn't need anything so you can just put it like this and here we need to check whether the snake has eaten the food or not so for that what you can do is you can have a function inside the snake which will check whether its coordinates have matched the coordinates of food or not so what you can do is you can insert the snake.h you can Define another function called Boolean let's say eaten this will basically say whether the food has been eaten by a snake or not so you can just pass in some coordinates inside this that is the coordinates of the food so coordinate food such a food cost and we'll Define it inside snake.cpp it's basically um bull snake eaten and uh this will return true if the coordinates match so if I say uh if would cost well I did not capture it over here so it's called could pause and if put pause dot X is equal to pause dot X and uh that is basically if for the position of the head and position of the food are equal then it means that the food has been eaten by the snake so then you need to return to else you just return false so this means that uh if you eat the food it will return true and if it didn't eat the different Falls and in main you can use that over here so if you can say snake dot E10 and you can get the fourth equation so food Dot um get pause and this will give you the position of the food which you can pass into the snake and if the snake has eaten then you need to generate another first so you can say full dot gen foot and you also need to increase the length so you you can say snake dot length well lunch is a private variable so let's say snake dot grow and we will Define a function to grow the snake so you can see void Pro and we Define it as void s snake grow which is length plus plus and this should grow our snake and that should be it so now you have the logic for eating a food and then growing the snake well we are not going to see the snake grow but it is just going to grow in numbers we won't be seeing that visually we'll see how to deal with showing that visually right and here we forgot to draw the food so here you need to put that I'll say for our I is equal to 4 pause dot y and J is equal to put pause dot X well I did not capture that so called equal to good pass then for food the let's say the star right the star works well now if you run this it says that uh width and height were not declared in the scope now that is because in food.h we did not Define the width and height right we had defined it in the main.cpp so you need to copy these two lines here so Ctrl C and put it inside put dot h that is because we are using those two right we are not uh we did not Define it in full dot X that is why it must give me an error and now if you run this that is because this is a capital Y and um here you have the snake and the food so here you can see the food so if I eat that food it's going to generate another food in some random position so you can see that generated over there and uh here we did not write the logic for Collision so we'll take care of that afterwards well it's going to be in the same places that is because we did not seed the random function so if you uh have seen the previous video where we made the tictactoe game you know what is serious well to see the random function what we are going to do here is we are just going to say in the main function so to see the random function what we are going to do is Hash include C time and here in the main function we will see s and time no okay so now when you run it you will have a snake and foot and this put will be generated once you eat it so here I eat that food now you can see that another one has been generated and then another one has been generated so we did not write the Collision project so if you go through the wall you will come you won't come back and that will take you now so to do that what we are going to do is we are going to write another function so it's going to save Full collided and its property of the snake so snake collided and then this is going to just return true or false so this is going to return true if our position of X is less than let's say one so that is because at the zeroth position you have the wall right so if it is less than one you mean it means that you have crossed the position of one and your cross the wall and uh in case your X is really greater than height that means the width then it means that the air cross the other wall also and similarly for the Y you need to say it is less than one or position dot Y is greater than the height then you need to return true it means that you have collided with a wall or else you return false over here so uh we forgot to define the Prototype so here it is going to be boole collided and in main function instead of true we are just going to maintain a variable called game over which will track whether the game is over or not so in the beginning game over is false and while true you will change it to while game over or while not game over you need to run all these things and if the snake collided so if the snare collided then you will just say game over equal to true and this will stop excreting the loop right now if you run this we got an error does it say again the width and height are not defined in snake dot h so you need to copy those two things from here and put it over here right now if you run this you don't have any errors hopefully and here you can see that the snake moves and if I go and hit the wall it ended the process so now the game ends successfully once I hit the wall and we have taken care of the food also so uh I think that the video has become long enough it has been an hour so the next video we'll see how to increase the snake's length and show it visually well we are including the snake's length over here but we are not showing the increase in its body right so we are just moving ahead and we are eating the food the previous video we were making our second project which was a snake game and and we made quite a progress right so let's see what we have made we have made this board and then we have updated the port without causing any flickering and that's a great Improvement and we also animated this character which can eat the food and we have also written the logic for the food to appear at different random locations right in this video we'll complete this game body for the snake well you know that the snake is growing while eating the food but it's just growing in numbers right we're not throwing it visually so we will be showing that and also before that let's fix some logical errors which are made right so let's see what are those errors so let's just try one of the other pops up I'm telling unlucky but just to save the time I'm just ending this game here and let's first talk about the most obvious logical unit so in the definition of food what we have said is once a food is created I want a random location on the board which will be the location where our food is placed right that's what we said when we are calling this generate food function inside the Constructor right but what is happening here if you run this program again and again so let's run just once again so here you will be seeing that the first code is over here and if I close that run that again you will be seeing that the second time also the food is over there but the consequent foods are getting randomized so if you see the second food is somewhere over there and we start this game again and try to eat that you see that the second food has been generated at some random location right the first one was somewhere over there so to fix this well you can go over there literally an iron it is actually not what we wanted right it's basically what I did not want but if you wanted that the first should be generated like that you can go ahead with this and keep this portion but since we wanted to generate the food at a random position right from the beginning what we are doing wrong is here first we are generating the food object and then we are setting the random function right so if we were introduced to the random function and the seeding function uh back in the tictactoe video right so if you remember the seeding function is a kind of controller to the random number generator well the random number generator will generate some random number it will do some calculation give you a number when the program is loaded onto the memory right so if you want a different random number what you need to do is you need to close everything and then open it again well we don't want to do that right we want random numbers right when we are in the memory so what we do is we change the seed so seed is like a starting point of the algorithm and what we do is we see it with some number every time we want to generate a new number so what is the thing which is changing constantly when time is changing constantly so what we do is we just take the time which will take the time machine integer and then make the random number generator start from that particular type that is why you get different numbers after shading it but what is happening here is we are calling the random function before seeing it right for the first time from the next time onwards once the foot is written the logic is over here right which is after the seeding function that is why you are getting randomized locations for the consequent foods but not for the first one so to fix that it is very simple what you can do is you can get rid of the Constructor but I don't know why I Define this Constructor basically when we Define a Constructor what we actually see is we need the Constructor to do something which the default Constructor which are compiler will construct for this class can't do right but what the default Constructor does it will basically create the memory required for this particular class right for loading this class onto the memory you need some amount of memory which is calculated by The Constructor well we wanted the Constructor to do something extra that is called this function on the creation and it did not work out as we expected that is why we can just get rid of the Constructor and then call the function manually well if you want to keep the working of the program just like before then you can skip the step as it told you it's just preference right I prefer that the uh would be generated at a random location right from the starting so you can go there and after shading the function what we can do is we can now call the generate food method so this is the one line which we wanted to skip by using the Constructor which was actually worthless right so creating a Constructor was no good and at least for this kind of a game where we want the first element to be randomized so it basically get rid of the Constructor and that will solve the issue now if you run this you will be getting the foods at different locations so one is being generated over here close that open that again well if the other one has been generated and this is the problem actually which I wanted to show you in the beginning right well uh when I was eating the food I actually knew that at some point this will happen that if we won't see any food on the pool that is a major logical issue with this program which we made in the previous video and we'll be fixing that right now so here if you see there is no food on the boat but actually it has been generated we'll see why that happens okay so close that and now we fix the most obviously now let's go on to the issue which we just saw that the foot is not getting generated well what we're doing in the general food method but here we are saying that we want some random number in the range of 1 to width minus one why we told that uh one the first character is basically reserved for the First wall and the last character is reserved for the last one so basically you want numbers from 1 to width minus one leaving those two campus it sounds reasonable right but if you work on the path it is going to tell you a totally different story so let's see what the math is let me pull up my paint over here and now let's first talk about one of these so width or height both of them are going to go with the same logic so uh we can talk about only one of them right right so here uh let's say I draw the height so what is the height height was something like 25 right so the whole thing is actually 25 characters right and what we are saying we are saying that the first character and the last character are decision for the balls so from a computer's perspective what are these numbers going to be the computer starts counting from zero right so 25 characters is basically 0 to 24 for a computer and what we are saying is we are saying that this 0 and this 24 is not required in a Range so basically we want numbers from 1 to 23 we don't point zero we don't want the last character which is 24 right so this range becomes 1 to 23 well to get a number in the state what you can do is plug it into the formula so what is the formula for the random number generation it is if you want a number from sorry n that is the lower limit to U which is after limit and lower limit is included and upper limit is not included right so you will be getting some numbers till U minus 1 so if you want numbers in this range that is early inclusive and you not inclusive you won't get the U then the formula is you need to plug in Rand mod it was U minus L plus 1 plus L right so this is the formula you can plug it into this folder you can even see logically but basically both of them are going to give you the same result and we'll just use the formula for Simplicity purposes over here modulus just what it becomes let me just write it as R this is basically the random function R naught and U is over here 24 right because we want 23 to be included right and in this formula this particular U is not included in this random number generation so we'll just increase this by one number that is 24 and that will become 24 minus L plus 1 so that is 1 plus 1 lower limit is 1 which is included that's why we don't have to do anything to it and plus one so what this becomes is R naught 22 plus 1 and what is 22 it is basically 25 minus 3. right so this is the number which we wanted to generate actually but what we did is we basically went by our intuition and messed up the logic right so to correct this what we need to do is using this particular formula this becomes minus 3 and this will become plus three and the same will go with height also we talked about time same thing will go with the width also so if you draw a similar kind of analogy you will be seeing that the same logic will work for the width also right so let me just clear that and here it is minus 3 and this is plus 1 right now this will fix The Disappearance of the food and there is another major flaw in our looping right so where are we looping we are looping over here right the board where we are displaying there is a major flow in that and believe me if you have been able to identify that particular error you are going to be a great programmer right so let's see what the error is it is basically lying within the inner loop what we're doing well for the outer loop it is pretty straightforward we are going from I equal to 0 to I equal to height which is basically how the computer sees numbers from 0 to n minus 1 and for the fifth we are doing something different right so what we're doing here we are saying that we are going from 0 to width minus 2 and we had a reason that these two characters which are basically the walls are constant for all the rows so instead of including them inside the loop why not just exclude them and run the loop only for the width minus two number of characters so that's what we did and that sounded reasonable but here is the problem what happens is let's say my uh generated x axis which is basically the width is going to be sub 28 right sorry what is the maximum age is 50 right and what you can do if this is 50 the maximum number you can generate leaving 0 and 49 is 48 right so this is the maximum number you can generate and let's say that that is our x coordinate that is the value of our width now what happens here well if you're saying here J is running from 0 2 with minus 2 what is bit minus 2 it is basically 48 and it's not reaching 40 it is just going till 48 which means going till 47 only right now if you see this you don't have a way to actually display this coordinate and just loop at all because it is out of bonds of this particular Loop this Loop will run only till 47 and you are asking it to show something which is on the 48th coordinate which is not possible by this Loop right so how do we fix this well we can draw an analogy over here so if you draw the coordinates into J's perspective and the W specific two w is basically the original width of our port for say this when w 0 J is not only defined why is that well let me just clear this thing so that we can see it clearly but this is the leftmost corner of our board and this is 25 right 25 characters or 25 pixels and here what we are doing is we are saying this is our character the width character and we are saying that the inner loop should run from 0 to 47 and we are including another character and the total makes it 58 0 to 47 is 48 characters plus 1 plus 150 and this is the other one now what is happening is let's say my coordinate is zero right right then the x coordinate is 0 it basically means this particular position where the wall is there right but what is happening here our zero is starting from one step to the right because of this particular grouping and this particular character before so what is happening our Loop which is starting is starting one step towards the right and that is why we are missing out our coordinate so what happens is if J is sorry if W which is our original x axis is 0 J is not returned defined it is not there at all right when does J equal to 0 start to 1 and so on this will continue when Vector equal to 48 J equal to 47 as we just saw and with this 49 it is not presented right so this is the reason why we were not getting anything on the board not this is not the complete result the actual reason was because we were we were a generation and here this is another one of the major reasons why we both be getting even after fixing the random number that is because if you create any food at the extreme positions that won't be visible to you at all right so to fix this what we can do is while comparing the coordinates we need to add one purchase right so if zero pressure zero RG 4900 right if you don't want these two things because we are not going to generate food at those two things they have walls they have reserved for walls so in this range 1 to 48 what you need to do you need to compare only these things right you need to compare only uh these things and to compare that what we can do is we can add 1 to the J before comparing it with the X constitute so to fix this what we're going to do here is when we need the canvas let me just clear this and here uh in place of K it's going to be J Plus 1. and that should hopefully fix all the logical errors which are made so save that run that again and here we have our first word if you eat that the second food is getting generated and hopefully it should not stop generating it should be generating till we play this game and it should stay within the range of port and it should be visible to the player right so well if you say this is visible and trust me it's going to work and there are no uh kind of mistakes in this program and this is completely fixed now well we'll fix one more thing that is if I go to this particular wall I will crash before actually crashing so if you see this I have not crashed the phone but it's in that I have crashed this one that means I need to go inside the one so to fix that I mean it's the coordinate issue and also a placement of most with let's first fix a comment if you go there Snake dot Collide it I will have already fiction basically what we did was we had put something like this right position dot X is less than one and question X is greater than width minus one so going by the same logic with minus 1 is going to be 49 because width is 50 so with minus 1 is going to be 49 so what you want you want something greater than 48 not 49 so it's going to be with minus 2 and that should fix the issue and for the other wall which I just showed you there for the rightmost what is happening is we are first drawing the board we are moving we are actually changing the direction of the stick we are moving this need and then we are actually this movement is movement is not shown to the user this moment should actually happen after this Collision sectional so you what you can do is you can just move this to the end or you can even move it doesn't matter basically the port should be updated after the snake goes not before the snake moves that is what is happening over version the code is actually getting updated before the snake moves so that is why you have not seen whether the snake has been collided or not so you can just move this thing to the end or move this thing to start basically they both mean the same thing right go for the next Loop the starting point is going to the end of this move so they mean the same thing so you now this should fix that issue that you're not seeing the snake colliding and now you should see that a snake actually collides with a wall before editing this game right so it went inside the wall and the game ended and now everything is pretty much fixed and now let's proceed to making the Snake Game a real sneaking what is that we need to include the snake's body we are just growing the snake which is basically just increasing the length right so here you can see it's just increasing the length so how can we store the snake's body well what is your body it's just a collection of body parts and that collection must have triggered something inside you well they are going to use something like an array which is a collection a vector which is also a collection which was seen in the pointless video and the other thing is list right so these are three options available to us as of now I'm going to use one of this now let's unless what we need to use over here needs to have a fixed size while defining and uh how do we know the fixed size of the snake well if a player like me is going to play he's probably going to get defeated in let's say fire 10 points at all but because I'm a very bad player and maybe a probe player comes in and he can make a score as big as 1000 or 10 000 right well you cannot restrict the players or you cannot estimate the player's capacity by just uh keeping a fixed number what if the player is better than what you thought he should be right so here what you can do is well in this particular board you can actually fix it to some big number so let's say uh foreign height is 25 right so the maximum number of characters possible is this thing 50 times 25 out of which you are using the borders so that is the only number of characters so if you make the snake as because that after that there is no possibility of meeting because the snake has to collide right because the maximum free space has been used has to connect with one of one of us and the game well that is a very cheap way you don't have to do that and by Define it with Graphics we generally what we do is we'll take off such limitations right so that is why you have such a tiny portable walls and all to take care of this issue but uh for this particular game uh we won't be talking about the teleportable ones well in the end I will show you how to create and here basically the array is a very bad option because you are restricting a player's capacity and if you talk about vectors well it is dynamic but again it is going to take up some extra space while defining so if you remember how Vector is first Define some amount of space and once it gets filled up it will Define a bigger space and then copy all the elements to this and get rid of this particular space so this one could be used just could work but again there is some extra space which is getting wasted so basically the best option here is going to be less so if you remember from our video on the pointers will be first discussed when to use vectors versus 20 useless you saw that list can be used whenever you have a data structure where you won't be accessing the middle elements more frequently you are just going to access the first and last language that is the case here also right you are not going to access the middle Elements which is basically these body parts we are not quite access it we are just only concerned about the head which is on the front of the data sector and then 10 right so we will talk about how to uh actually manage the hydrogen tile in a short while but for now the head is at the beginning and the tail is at the end and they are only bothered about basically when we want to check the position we need to continue the middle element also but we can just do it and Progressive Loop right so basically it doesn't make any difference and we can't actually harvest the advantage of being able to pick some random element from in between well in a vector we can do that very simply because it is a continuous collection but in a list you if you remember it was something like this right your point you have pointed to something and then you have another pointer which points to this and so on right so if you want to pick this thing you need to travel all this way but then I vector or in an array you can just pick that up using the index it is basically the starting position plus the number of steps you need to travel so in this case a list would be the best thing to implement but to keep this tutorial simple I am using vectors for this particular demonstration so I would totally encourage you to go with list not with vectors as we are going to see in this video I am just showing you with vectors because it's easier to relate than this right but once you are comfortable by implementing this particular project in a vector please go on to try it with a list list is the most preferred option for such games where you don't have to control the capacity of the user right Vector is not going to control but basically the extra space is Generation right we don't want that so please try it with the list and let's now move on to the logic of creating the body you need to just clear that and how do we Define the body well it's really simple so let's say I have two body parts basically a tail and the head I have this head over here and the snake has to move to the right so what can I do well what if I just remove this tail and then put another head over here and make this as a tail so for tail let's just say this x mark over here that we know City now if you see that the sneakers put one step to the right right and if I do that again so I take out this tail I include the head and I made this head as the tail now let's take a smooth again and let's say we are eating the food at some location so we'll start with an angle snake so this is the snake we have and the food it is going to eat this particular food so it has eaten in the next iteration what I will do is I won't take off this tail right I will keep this day and this is what happened right so I add the head I won't remove the tape but I'll make this head as a thing right so now you have two tails and one head and that basically looks like the snake has grown right from two body parts it has grown to three body parts and that's what we want right so this is the logic we are going to implement and we are going to do that in factors again list is the most preferred option please try it with a list not with a vector after you are comfortable basically right so let's just go to our snake.h and quickly create a body definition so we need Vector obviously so hash include Vector which are going to do it to the list you know right as include list and uh well since Vector is a standard scope element you need to specify the scope so using namespace HTT like we did in the main function and here you can just say vector body sorry vector and what is the data type it's going to be coordinated basically so chord and then body and this defines the body of the vector now there are few changes we need to make what is that first of all we need to include the head to the body eventually create a new snake so in this snake called Constructor what we're going to do we are just going to say body dot pushback which is basically pushing back the elements inside a vector and what we need to push back we need to push back to position which is basically the position of the head of the snake right we can just body not push back that particular position and while moving the snake following that logic which we just discussed what we are going to do is first we are pushing the head of the snake to the end of the list or end of the vector so how we do that 4D dot pushback the new position which has been updated after all these things a new position and now what we'll do is if the body's size is greater than the length of the snake what is the length of the snake that is the thing we are growing when the snake is actually eating a food right so that is the thing we are manipulating over here so this length integer if the body is size which is basically a number of elements in the vector is greater than the length then what you do you just take out the element from the body so how do you do that you just say body Dot and if you're actually confused with what function you need to use the best thing I would suggest is not just memorize the function but just use the resources so you can just go to your web and then search something like CTP vectors documentation and you'll get a lot of resources and C plus plus.com is the best one among them well I feel that this is the best one where you can find short descriptions of all the functions right and here you should be a function like pop back what does it say it says it removes the last element in the vector effectively reducing the container size by one but we actually don't watch this and well why is that if you see but technically the tail should be at the end of the body but if you look at the structure what we are doing is we are actually pushing back the head one step to the right right so this is what pushback does so basically our head is over here and your tail is over here and what we need to do we need to remove the first element so how can we remove that you can just check out the functions over here but to save the time I'm just going to show you the function which is basically clear or Aries right so you will find this one this is basically going to remove from the vector either a single element or a range of elements right so here we just need to remove a single element at a position is not an integer it's a pointer so here you can see it says the definitions iterator position and iterator first and iterated last well you can go with any of this uh the only difference is that it has a concentrator with we don't have to know at this stage of it you can you can just go and search what these two things are basically they'll be the same thing and how to use that you can see an example over here it says dot erase my Vector dot begin plus five so plus 5 is basically going five steps away from the first element which is specifically the Sixth Element and that's uh how would you use this arrays function has also shown an example to delete a range well we are not quite interested in anything we just want to erase a single element which is going to be our first element because our first element is the tail and what we can do we can just change my Vector dot begin plus 0 that you stay at the first element or you can just omit the zero and just say my Vector dot begin that is going to erase the first element so let's Implement that what we are going to say we are going to say body dot erase and what we're going to erase we are going to erase the first table which we can get by Body dot pick and this is the pointer for the first right first position right so this will basically erase the first element from our list and well before proceeding let's first see whether this is working or not and we need to create another function will let us keep this function for now and then create another function just in case something goes wrong so vector and it is going to be coordinated you need a coordinate Vector to be written well basically you are going to return the snake's body so snake and then let's say get body and inside this we can say written body and in the snake.h you can just create that function definition which is basically vector chord oh sorry what is that dead body right so now we have update for this next definition now we'll just update the board and what we need we first need a Victor to capture the snake's body so Vector go on let's say snake body equal to snake dot get body and inside this what we are going to do well just remove this Edge and we'll place this afterwards what we're going to do is inside the edge we are first going to Loop through the snake's body and see whether any coordinate matches or not so what we can do is we can just say s body part which will stay false in the beginning right we'll change that in the loop now what we can say is for in well ijs your steps of k equal to zero um K is less than our body which is net body dot size and K plus plus what we are going to do here is inside this Loop we will say if I coordinate which is basically going to control the y coordinate is equal to the snake body of the kth index dot X sorry dot y and J plus 1 well remember that's the logic we were missing up equal to snake body dot sorry snake body of that particular index Dot X if these things match up then what we need to do you need to display a body part so let's just go with the small o for now this is our body part and this body part becomes true equal to true and what else well we don't want to run this still right because at at an instant a particular body part can stay only at a particular location so if that location is occupied it is pretty obvious that any other body part you want to occupy the location so you can safely break out of this Loop you can end this Loop and at the end what you can see is a empty space you know the empty area right and here another thing is here we are going to report it outside but remember body includes the head right so what you can do is we can just say body dot size minus one which will basically leave what the last element and now this should work and let's try to implement this so F9 and here you can see that the snake has grown so the other foot is over here so we will ID that and the third foot is over here well you can see that the snake is growing right so here you have four body parts of the snake and now if I eat that here now you have five right so now we have a working snake game right so now you have a working snake game and this works pretty fine right so now the you can see that the animation also works pretty fine the body part ship to follow the head and so on right so this concludes our game well I promise you that uh we'll be seeing how to uh create a teleportable wall and before that if you want to show us code that is also pretty simple what you do is you just say here end score I will just keep it Global so that you can use it on the port function also so here you can just say end score which is going to be 0 in the beginning and well you can just set this to zero in case you want to say play again something like that what you can do is instead of main you can just say game and this is going to provide game because I'm not going to do that you can do that right so if if I I want to play again you can ask a question do you want to play again or not something like that and if I press yes then you can call this function again and then you can set this thing as zero so core equal to 0 before the beginning option you give and here what you can do is you can just say score plus plus very simple and if you want to give 10 points or something like that you can just do that score or equal to score plus 10 or any shorthands of Windows code plus equal to 10 or something like that you can do that over here and here before starting to print out the port what we can do is we can just say C out our score so score is our score current score and just add couple of new lines so it looks neat and that should take care well I have one return function over here that is this full oh sorry the snake pause which is actually getting the position of the head and we are also getting a position of the body right and we did not Define the Collision of the snake right so we'll do that those things first of all let's just see whether this thing works or not so now you have this particular snake and I ate that the square is 10 now I hit that score is 20. I hate that score is 30 and so on so it's working pretty fine right so you can close that and to take care of the Collision when you might have figured it out by now what we need to do well what you need to do here is you need to say else and you need to check whether it collided or not how do I check that well you don't need else you can directly check it inside a loop and then return it so what you do is for paint I equal to 0 I is less than the body dot size well it's inside the snake so I don't have to call that I can just say length minus 1 because I don't want the head and it's going to be I plus plus right and what we need to check if our snakes have head is basically pause right so if POS dot X is equal to any of this need body will it is not straight body is just body body of I dot X and the y coordinate is also same constant Y is equal to bodies I not y if these two things match up just say return to yes you collided if these two things don't satisfy the rent just say return false so they should take care of the Collision so let's just try that out for F9 to build and compile this and here you have this snake and the foot and let's first go for our first food we have grown and the score has also increased and the second foot but it's going to take a while if I go like that let's just go in one body part every time right so what I can do is I'll just write a equivalent well how can I Collide well I'm going left now right so if I just press right I'm just going to collide with my neck so basically I collided and now you can see that the process has stopped basically all Collision algorithm is working so that basically ends this game and if you want to make it teleport all it's really simple what you need to do is I I am sure many of you must have figured it out right now well you just need to play with the coordinates so here if you see in the snake mostly what you do is if you want to change the location of the state you will just say here if this particular thing if position dot X is greater than the width minus 2. then what you do you just say position dot x equal to zero so simple and again what we do if you say if position dot y or sorry position dot X is less than 1 then what you do you just say position dot x equal to the width minus 3 sorry about that it for random function we need to use with minus a because uh for generating the random numbers in that range so it's basically with minus two and this will make the side walls teleportable so if you just save that and now if you run this you should be going through the sidewall and coming from the other one and now if I go through my sidewall I should be appearing from the other wall so you can see that it has been kind of teleportation now if I eat that our table also follow our uh steps right so if you go from there you appear from there right so it works good please so that is how you make daily portable walls and uh once you get to know about file handling basically how to write files what you can do is you can even have a high score option so you can write down a particular high score on the file so let's say I opened this game right now and I scored about 10 points and you scored about 1000 points so that's pretty reasonable I'm not a very good player but yeah so you scored about 1000 points and that is a high score right so here if you run this program again that high score gets lost so instead of just writing it on the memory for that particular kind of run what you can do is you can have a file where you can write on all your high scores and then whenever you load this game you load it along with the file so inside that file you have all the high score relation if you want you can just have names also so some games provide that right so you have the name under the high school so other than that you can design everything and we'll come back to just while discussing files issue because traditionally what we do is we just write Files about students and all this stuff but we'll come back here and we'll try to work on this game more and trying to create a file and again this is the totally working game and if you want to implement this and if you're comfortable with implementing this with this kind of a vector well I have made some related functions like this is completely sorry this one is completely unnecessary because I'm getting the head along with the body so you can take care of that and again I will advise you not to use a vector user list and here if you uh want to include another teleportable wall there is a this one you can do that again with a similar kind of logic for y axis right so you make basically all four four of the walls teleportable so when I I had actually implemented this game in Python and if you use a graphics Library you will be getting results like that so if you go to our python one so here I have my game well it is basically written in two files one has the classes and one has the script and it has various images so what I have is the snake in part so here you can see body horizontal so whenever that snake is breaking that particular direction you show that image and now when you can run this thing right over here you can see this game this is what you can make with a graphics Library well this is pretty fast but this is what you can make with a graphics library and you can see how smooth it is and it doesn't have any uh kind of issues like moving down faster in the vertical Direction moving small in the horizontal Direction it has kind of same speed because you can control it right you can basically control the number of pixels and all and if you see it is teleportable on both sides if I go from the bottom it up from coming from the top and if I go from the sides I end up coming from there so this is how you can Implement your games and this is basically the same logic which I've implemented except that I have some additional functions handling the graphics of the screen right nothing more than that it is basically the same exact logic which we'll talk about in his console but when you use a graphics Library you get results like that so once you're comfortable when programming this particular game on the console I will advise you to uh look up some graphics Library which is available in C plus plus there are many so see what you're comfortable with and try to implement such games on Graphics even the tictactoe game can be implemented on the graphics Network and that really looks good instead of the concerned right so well basically what we are learning here is how to think and console is the best way or the best platform to actually put down your ideas in a very fast way well if I want to do the same thing in a graphics Library it will take a really long time I need to ensure has a graphics Library I need to do a lot of things before getting all these things right so if you're coming up with an idea I'd rather recommend you not to go to a graphics library but first think and then put up a dirty kind of working prototype on your control and then you can beautify it on the graphics Library so that's it for this particular video hope you enjoyed this and I encourage you to build up your own game by changing the loss and then by you know making it faster on the X and slower on the y or something like that I didn't do that I just went with a very simple approach but I'm sure you can do that in this video we will be talking about inheritance with inheritance in C plus plus or any programming language it is no different from what we know about DNA items right so what do we know about inheritance a predecessor shares some of his properties with his successor so say a father has a green eye and maybe the sun will also have a green eye because of inheritance of genes right so that is what we know about inheritance when in programming tool there is no difference in the concept if there is a parent class and there are child classes which inherit some properties from the parent class that is what inheritance means in programming and we will see how to do that in C plus plus now why do we need inheritance well say I have a class so here I have an animal class so I have some properties in the private section and I have some properties in the public section and now I want to create 10 animals well it's pretty easy right so since we know but at least what we can do is we'll just say animals or animal 810 we have created 10 animals now let's say I want to create 10 tigers and 10 dogs also and all they all have these similar properties but the only difference is that a tiger will also have another method called Roar with this White Road which will print roaring on the control and similarly a dog will have bark right so how do we do that well if you think you're copying the clashes and then creating two different classes for tiger and dog and then creating two different arrays in a similar way they're not wrong it will work but in efficient way would be to inherit the properties from this animal molecular well if you see tiger and dog both are animals right so both have a species name both have an age both eat both sleep but the only difference is that a tiger Roars and the dog parks so if you can take advantage of all these properties from one class and add whatever extra features you want to add then that solves the problem of creating a separate nucleus right so what I mean is say I have a clash tiger and then I have some method like public World role and then this is just going to print out drawing on the console now say I want this tiger to have all the properties of an animal it should have a species name it should have some age and then it should eat it should sleep and all those things so you can just copy it down by an efficient way would be to inherit them and how do we inherit something well we'll just put this onion over here and then good public animal when we will talk about what this means right so for now this is how we can inherit the properties of an animal and now if you create a tiger you will have the properties of the animal as well as the tiger so I can do T dot e which is basically defined in this animal class it is not defined in this tiger clutch and I can also do T dot row that is also valid and now if I run that well string does not name a type yeah that's because I did not use using names with a studio above close that and now here you can see eating and closing so eating is from this thing from the animal class and drawing is from the tiger penis well if you want to create a dog it is very similar you can just do Clash talk and then public animal and here you can just shape public World Park which says button on the console then right so now if you run this well editor create a dog object so you can do that completely dog D and D dot eight data Park the question is right so you can say d dot Pi when after done this you will get similar results you will see eating and then biting so that is the advantage of the inheritance you can take advantage of all the features which are defined in the parent class or you have something called the base because there are different names for this so there's in some language it's called super Dash and then it's also called as a base class it's called the parent class and there are many names and then this one also has similar news so this is called a child class and then this is called an inherited class or something like that right so basically we'll just stick with parent child because that fits to analogy and uh that's how inheritance Works in C plus well it's that simple and now we'll just talk about these things and uh we'll also see how to take full advantage of inheritance in later videos because it's not a one video topic inheritance is very vast and then there are many advantages of inheritance so we'll see what these things are in this video we'll see how to do basic inheritance in this video and then we'll see how to do multiple inheritance and all those kinds of complex stuff in later videos right so first of all talking about this this will specify where to inherit and this class will specify from from there to inherit so this is to where and this is from there so let me just write it down this will specify where a tiger do I have to inherit and the other one will from there do I have to inhale so these are the things we are specifying what we are saying is you create a class title which will inherit all the properties which it can generate well there are some restrictions we'll talk about that but this statement this particular line means that create a class title which will inherit whatever it can generate from this class which is animal and put everything in the public section so that is what it means so public means it doesn't mean that everything is going to inherit is going to go into the public it means that whatever it inherits just inherit as a structure so if you see here you have private and public right so when you are inherited it as a public inheritance what you're doing is you are just maintaining the structure so a private anyway doesn't get inherited so if you have anything else that is going to give into that section and public things will go into the public section well you can do to drive it here too so you can do something like private what this will mean is it doesn't maintain the structure it will just put everything inside the private section so all everything it indones go to go to these methods are not not accessible from here so now if you run this okay I inherited in the tiger class so let's just make dog as private and now if I try to run this I will be getting it error why because I have made it private inheritance that means whatever I can generate I will put everything in the private section so something like this will be created inside the memory and these two things will go inside here the private doesn't fit indicated foreign to that particular class what gets inherited is public and protected so remember protected from all video on classes well we talked about protected very briefly over there because we told that protected is better understood in linear regions so we'll talk about that now well protected is basically when you have something which you don't want to share with objects but you want them to be inherited so something like this I don't want species and age to be accessed from objects of this class if I create an an email object I don't want the species and age to be accessed from that object but I want those things to be inherited so at that point of time I will make these two things as protected members so protected means I cannot access with an object but I can inherit them so so what I can do here is instead of private so let me just I can just protect it here so don't do it and now actually these two things go inside tiger and dog so if I do something like public here well I as I told you it maintains the structure right so if I do public here and then I'll just create another method right so avoid set the page which will basically set the heat so you so each and then this age you can see here age is actually coming here which is basically not defined in this tiger class but it got inherited from this protected class sorry this animal class so if I do this H equal to H it is going to work and uh what we can do here is T Dot Sony T dot set each to something like 10 and then we can also retrieve it so let's say in get H great damage and if we try to print that each so if I do c out T dot h sorry T dot get H and if I look in the console you will be seeing 10 which we have set here and that age is actually derived from this animal class right and now if I try to create something like animal or even tiger if I do Tiger DOT H I won't be able to access it so if I do T dot a is equal to 10 I'll be getting an error so it says if you look in the debug console it says that in animal age is protected so that means that I cannot change that it is like a private member to the objects but it's like a public member for the internet so that that's what protected means so this is for the private so this I did not change this method this is for the private team for protected it means that it can be inherited by cannot be accessed by objects public means that it can be accessed with objects as well as it can be inherited into other classes so that's all about basic inheritance in C plus so again as a recap this will specify where to inherit so if I do protect it here what is going to happen if I do protect it here everything is going to go inside the protected function so why do we want to do that so let's say I want to create another thing like uh for now let's say tired baby it's the baby of this tiger so if I want to inherit something from this I can do something like this public tiger which is completely allowed now what is happening something from here is going to get in his written inside the tiger and something from Tiger is going to get inherited inside this class which is called tiger baby and that is how inheritance works and that's how it boosts your programming in this video we will be looking at the different types of inheritances we can perform in C plus before beginning I would like to kind of put a note here that whatever we are going to discuss today are not to be taken as the only things available for you right so these types of inheritances or Frameworks as I call them these are to be used only to model your program so there are many kinds of problems which cannot be directly solved using the four or five types of inheritances we are going to discuss today so you need to kind of model the problem and use a combination of one or two and maybe sometimes even all four types of inheritances and then create one and actually that is mentioned as an inheritance a type of inheritance for you so the point is you need not remember all these things but as a computer programmer you are supposed to know that these things exist these Frameworks exist these are nothing but just to help you model your program and not to be used directly but to be used along with proper planning and then uh you know kind of modeling of your problem so The Inheritance problem has been there for decades and it's not completely solved even now there's no kind of hard and fast rule to say that this particular inheritance model will do better than that or for this particular problem only this model will work there's nothing like that you can try with different models of inheritances you can try to combine one or two types and then come up with your own custom type and all those things so these are just like a starting point for uh modeling your problems right so with that let's get started so here I have pulled up a website which which is student tonight.com so what we are going to do from this website is we're just going to refer the names from here and then the images so here they have beautifully provided kind of images here to visualize how The Inheritance would look like and then we will Implement that in code and we'll use the same notation here as here you can see they have used a as a superclass basically which is the parent class and B is the subclass which is the child class so we'll use the same naming in our code too so that you can relate with this right so let's get into it one by one so the first type of inheritance is single inheritance which I'm sure everybody is familiar by now so we have been doing this in the past video which is nothing but you have one single parent and one single child so to implement it quickly let's just create a pen a Class A and um we'll keep this simple we'll just have a Constructor and Destructor right so to create a Constructor you just put a function definition just like that without any return type and then um inside this you can pass in parameters but for now I'm just keeping it empty so here we'll just say once connecting a right we'll see in a moment why we are defining this concept is right so we again needed Destructor so for Destructor what you need to do is put a tied symbol T and Define the Constructor as it is but here the only difference between a Constructor and Destructor is that Destructor is meant only to destroy the object right it is only meant for distracting the object when it gets out of the scope so it doesn't take any arguments so you cannot pass anything here unlike in Constructor you could do something like int a in a Constructor it is allowed but in Destructor it is not right this is just to kind of debug your program when your object is getting out of the scope and all right so here we'll just see and that makes a now let's create another class simulator to this class B so copy that paste that and we just need to replace it so replace all a with b and you need to match case from the cursor right so replace that you don't need to replace these things you need to replace these things well now we have another class ready now to inherit a inside D I hope you remember that you just need to put a colon and then the access specifier where you want to inherit inside P will keep it public and you are going to specify which class you are going to inherit from which is a in our case so a right so here we have a single inheritance as shown in this picture right so you have one parent class which is getting inherited into a child class so here you can see parent classes a and a is getting inherited inside B so now if you create an object of Class B so if I say b obj obj stands for object so and run this thing so well I did not put any new lines here so just put that so that we can differentiate the output and you know kind of run through what it actually means right so putting the new line you have this output and let's break it down right so first you have constructing a and then constructing P so if You observe here we are not constructing a at all right but why is this statement coming this statement should only come when I create an object of a right and here I am again distracting a which I did not even create so what is happening here will object creation is called instantiation right so it's called something called instantiation so what it means is you're going to create a virtual object it doesn't actually exist it's actually not a physical object it doesn't exist in a memory what it means is since I am inheriting from a for a computer inheritance means you need something from a inside Class B and everything is not defined inside Class B so in our case there's nothing special about A and B right so a just has a Constructor and Destructor and B also has a Constructor and Destructor and practically there's nothing to inherit from a but for a computer it doesn't look at those things it just knows that it needs to inherit from a inside D so assuming that a has something which B doesn't it first creates the a kind of instance of an class instead of the parent class which on in our case is a and then it will pass on those properties to class B that is why in the console when you are creating an object B you're seeing constructing a first here that is because since a is the parent class it it assumes that there is something important inside the parent class which is not there in the child class so that is why you are inheriting right the main purpose of inheritance that is why the compiler is built to do that so first it will construct a then it will construct B and while destructing it will destruct in the reverse orders right so construction happens from A to B that is parent child and destruction happens from B to a that is child to parent and this will continue for any level of inheritance we will just see what levels are right so this is basically just simple inheritance or the single level inheritance in C plus plus right now let's move on you have multiple inheritance multiple inheritance basically means that you have multiple parents for a single so here it has demonstrated the two but there you can have as you have mentioned here you have classes which can inherit from more than two classes also it totally depends upon your problem now to do that it's almost similar you just need to take this out you need to duplicate this class B so take this copy that and replace this thing so you need to replace B with C so replace yes yes yes yes yes yes and uh well you can do this manually now I have a class C and also an object of Class C and to inherit multiple classes what you need to do is just put a comma right so if you just a this is just single level inheritance basically what it means is a is the parent C is the child and c as a child is inheriting everything from parent a right that is that and for B you just put a comma and then put the access specifier I'm just going to keep it public here you can do protected or private as your problem but for now let's just keep it simple we'll just use public for all our inheritances right so public a public B now you have multilevel inheritance sorry multiple inheritance right and now if you run this you have this kind of output now the thing to be noted here is it's almost similar right so first a is constructed B is constructed then C is constructed C is basically the actual class which you are working upon and then the destruction is just the reverse order of conception the thing to be noted here is if you change the order of inheritance over here it will be affecting the order of creation also so here I am first inheriting a then inheriting B it reads from left to right so basically first I'm inheriting a then I'm inheriting B now if I change this order if I make this B and if I change this as a and now if I run this that order will be swapped there too so if you see here first it has constructed B that is because it is appearing here first and then a is constructed then C and basically this order is just reversed while destruction right so destruction follows that same procedure the in the order construction happens destruction happens in the reverse order right so that is about multiple inheritance disorder matters and you can have as many classes as you want inside uh this particular class you can inherit from multiple parent classes right so if you had more financial class so say public some tea and private e all this is possible basically it will just construct the classes in this order first B will be constructed a will be constructed D will be constructed e will be constructed then C will be constructed right so that is about multiple inheritance now we can move on just take out this website and here you have something called hierarchical inheritance so in multiple inheritance you had multiple parents in hierarchical you have multiple children so that is the difference between multiple and hierarchical you have one single parent and that single parent is inherited by multiple children so we have already worked upon one of the examples on this particular hierarchical inheritance structure that is when we are discussing about the animal class so if you remember we had a class animal and both classes like the tiger class and the dog class inherited from the animal class so that was an example of hierarchical inheritance so to do that here we can just put something a and public a so here you can see that a is the parent Class B and C both are children of a so both are inheriting a so this is basically an example of hierarchical inheritance and uh it's basically if you just create an object of C it's just going to look like simple inheritance or single identity because uh if you just remove this B from here what you have you just have a parent class and then you have Charizards which is inheriting from the parent class which is nothing but an example of single level inheritance so basically it works in the same way so now it will output something similar to single level it just seek the parent class constructed the child class and the destruction is a reverse order right so that is about hierarchical inheritance and now the other thing is multilevel inheritance now the difference between multilevel and multiple inheritance is that in multiple you have multiple parents but in multilevel you have a tree kind of structure so a multilevel basically is kind of uh more generally used inheritance framework because um this basically transes from a more generic class to a more specific class so what I mean by that so let's say um an example for a general class could be animal so animal is more generic I could mean any animal by just saying animal right so if I have class animal and then I want to be somewhat more specific so I mean I'll just increase my specificity level and let's say I have a class doc so now I'm inheriting from animal inside dog so here uh if you see that chart here you have a which is animal and then B could be dog so now I am inheriting the properties of animal inside class dog and if I want to be even more specific like uh choose some breed of dog for example so that could be C so basically you are moving from a more generic class of objects to a more specific class of objects so that is why multilevel inheritance is basically uh used mostly but as I told you it doesn't have to be it totally depends upon your problem right so let's quickly implement this so the way you implement is you have a b is inheriting from a then C will inherit from P so this is multiple right multilevel is you have two or more parents and the child will inherit from them and in multilevel you have a kind a tree kind of structure right so now if you run this you will get a similar output for what you saw in multiple basically the order matters here so first the parent is constructed then the b b is basically the child of a then C which is nothing but a child of B and then the destruction will happen in the reverse order right so that is about multilevel inheritance and then in the end you have something called Hybrid inheritance so Hybrid inheritance is nothing special it's just uh you know it's just a kind of combination of all these kinds of it narratives here is this just said that it's a combination of highlight care and multilevel what I'm saying is it doesn't have to be so this particular framework it it doesn't have to look so neat so here you have two classes just directly inheriting from a and then you have one single class inheriting from B and C also so it it doesn't really have to be in such a clean format it totally depends upon the problem on the way you are going to solve your problem so high radical or sorry the Hybrid inheritance of the virtual inheritance basically means that you are going to create a custom model custom inheritance type by using these four types so the single multiple multilevel and then hierarchy we're just going to use a combination of these types and then create a custom model which may look like this so here if you see if we just close this D part what you have here is hierarchical and then here you have multiple right so that is basically uh the uh gist of Hybrid inheritance and now in Hybrid inheritance I just remembered by looking at this figure actually this figure is an example of a very famous problem called The Diamond problem so it's a very famous problem in inheritance basically the structure looks like a diamond right so here it is basically not drawn in that way open up paint and what you have is you have been in class okay so a for example you have multiple inheritances like this so you have B and then you have C so this example is from here the hierarchical inheritance right so okay we will start yeah so this example is from the hierarchy inheritance where you're a single parent and you have multiple children then what I'm going to do is combine these two children to another kind of child which is d and what is this example from so if we just remove these things don't consider this just consider BC and then you have D it is basically an example of Justin right multiple inheritance so here you have a hierarchical and then here you have multiple and this structure which looks like a diamond is a very famous problem because this doesn't know from where it should inherit so see if you are taking this particular path so from A to B B to D then you know that you just need to inherit a but if you're taking this part because it is also a part of the parent right so C should also be inherited and for C A should also be inherited so the problem is should this inheritance happen because it's already happened right in case of B so if we just search for that you will have a more concrete explanation of that so time and link okay especially it's not a language dependent problem it's a it's it's the problem of multiple inheritance okay so here you you will find a more clearer example basically it says the same thing which I said here so name and age needed only once that is basically the person class should be created only once but if I'm taking this path I should I will be creating this but since the this class which is faculty is also and a parent of ta which also has to be created so should I include the person class again or not so that is the main question and we will be solving that by using something called abstract classes so here you will be uh seeing some examples of that used here the abstract class methods but uh since we did not discuss it till now I'm not going to go into detail right now we'll be going into detail in the next video but this is the problem you can read this uh to get some more insight into this and um that's it for types of inheritance in C plus place in this video we'll solve the diamond problem which we discussed in the previous video so if you remember that I had referred you this particular website where the timing problem is beautifully Illustrated so the diamond problem is you have a base class or a parent class from which multiple classes are getting inherited and then you have another child class which are using the inherited classes as the pairing classes so let's quickly create a program version of this so let's see Class A and um we'll again keep this simple so we'll just we'll just have a Constructor and Destructor as we had in the previous example so you have a and you have a Destructor which is this truck okay destructing a and uh we need to create another class B so create that and we need to change the A to B so the a is going to change into B so replace and we again paste that change document also aim to C now so we press a with c so then and again create another class which is going to be T right so because we need four classes right um let me just quickly show you that picture so this class is being referred to as a you have B and C two more classes which are going to be inheriting from a and then you have another class called C which will inherit from both D and C sorry this class will be called T which is going to inherit from both B and C all right so um this is going to be D so replace that with d and then so now let's make the inheritance as quickly so Class B as I told you is going to inherit from a Class C is also going to inherit from a if you remember this inheritance is nothing but hierarchical inheritance and now we are going to inherit from both B B and C which is nothing but multiple inheritance so public B and public C right and now we'll create an object of D and we'll see what exactly the problem is so d uh say obj and now if you compile this what do you have okay I again forgot to put those new lines keep forgetting that so slash n over here and over here well now if you run this particular program what you have you have constructing a constructing P constructing a constructing C and then constructing D and that makes sense right because we are first inheriting from B and B is inter inverting from a so so first B is going to be created which basically means that a is first going to be created then B and that is going to get inherited into D then you have see which again inherits from a so first a is created and then C is created and then you have created the T right now the problem is if I try to touch a from which path should I go so I mean uh we'll just quickly draw that so go to the paint here and uh we have a you have two classes B and C this and then you have combination of these two classes which is basically the class D so this is T num if I create D in this part or in this path if I start creating that I'm again going to create a indefinitely right so as you saw in that output we had created it two times so here you can see constructing a1s and constructing a the second time so we need to avoid that by because say I want to access some properties of a right and B must have modified the properties of a we don't know right so suppose there's something called X here some variable and B what it did is it made X to 20 and C made X to 30. just take this as an example now at this level it's okay just forget about the D for a moment for this level it's okay there are two separate children and they are doing whatever they want with the inherited properties now the problem comes when D has to access X shoot it follow this point which is x equal to 20 or should it follow this path which says x equal to 30 what it should do so uh to demonstrate that let's just create a kind of public variable just name it X so Index right for now and um here uh well we don't have to do anything we can just try to do something like since it's just public and we are just doing public inheritance we could do something like obj dot x equal to 10. I could do that right this is perfectly normal now if I try to run this but it run this I get an error what is it it says request for member X is ambiguous why is ambiguous that's the same thing I just told it's ambiguous because it doesn't know what to do so even if I try to change it over here or as I explained it in the picture if I try to change it in one of the inherited classes if I just change it in one of the inherited classes so if I just keep it x equal to 30 here and just leave it then also it's going to be a problem because it doesn't know whether to keep it the same or to change it right so this is the main problem which is called The Diamond problem the thing is it doesn't know which path to take should it change X through b or should it change X through C or basically should it change the X over here or not should two copies be created of X which will lead to ambiguity and um well if you don't create X at all then there is no ambiguity right but again why are you inheriting you are inheriting something because you want those properties inside the child right if the parent doesn't have anything useful for the child to inherit there's no point in inheritance at all right so this problem has to be solved and how do you solve that you solve that using something called virtual inheritance so what does that do well if you see here what we're doing we are just creating two copies of a right so what virtual inheritance does is while inheriting into these two classes I'm I'm I know that these two classes are going to be a parent of some other class so now my solution to this is I will keep this virtual that is even if I create even if I create multiple copies they will be pointing to the same object or the same instance which has been created in the memory so while creating a memory map for D say I first create a through b so a has been created once right now if I create it through C since I already have a a will not be created that is what is the advantage of having virtual inheritances so to do that what we do here is instead of directly inheriting a we just do something like virtual public a and we'll talk more about this virtual keyword right for now just keep it like this so you have virtual public a which is basically a virtual inheritance and then you have virtual public a over here now as I told you a will not be recreated again and again so if you have 10 classes like this if you just stop at those classes if I just access B and C there's no problem the problem arises only when I want to go up a level right so I want to directly access the x of a if I had some X of B over here and if I try to access that I won't be having a problem because B is a direct parent or C C is also a direct parent of D but a is basically one level higher right so that is where the problem arises and this is how you solve the problem you just virtually inherit those classes so so now you wouldn't be getting an error and it does run successfully and here you see a has been created then B then without creation of a it has directly created C why is that that's because while creating see it already saw that there exists a copy of a that is why it is not creating a again if it changes order first the a class for c will be created and then B will be created without a now if I change this now if I run this you can see here AC and this a is because of this inheritance and since it's virtual it knows that this should exist only one copy of this particular instance that is why while creating P it will see this statement and then uh look up that memory map and then find out that a has already been inherited so it won't inherit a again and this operation is totally valid so that's how you solve the diamond problem and about this virtual classes this this virtual keyword what it does is it will take care of the fact that there exists only one particular copy that that is what virtual means so uh for something called abstract classes which we are going to discuss in the next video the abstract classes are basically um a kind of base for creating newer classes now the abstract classes are need not be kind of virtual right so see a virtual methods of virtual inheritances these are useful only when you need a single uh kind of copy of the property so say I have a Constructor a over here and if I override this Constructor over here just saying so instead of B if I just say a this is also particularly valid rate so I'm just rewriting that function over here now I can access this a through a method which we'll discuss afterwards right so we can access the methods of the parent class methods or variables or anything of the parent class through a map we we do have a possibility for that now the point of virtual keyword is you shouldn't have multiple copies so basically this is creating multiple copies so through b if I'm accessing a it should be printing constructing B but through a if accessing this particular Constructor it should say constructing a so basically there are two copies of the same function this is called overloading and we'll talk about this in the next video also right so for this particular issue virtual keyword is there which basically means that you can have only one particular copy you cannot have overloading and all and so in abstract classes what you have is if you need only one feature one copy of that particular feature you will make it virtual so that in the inherited class where you have that virtual function inherited you need to Define that function indefinitely inside the class so in Virtual classes what you do is you just create a virtual method and then leave that you don't Define that virtual method so in the inherited class what you do is you inherit that method and then you need to Define that method indefinitely if you don't Define it you will get an error I'll do it so that solves a problem of you know maintaining multiple properties and we generally don't actually want multiple properties of the same thing unless in really rare cases right so in rare cases are you going to you know access the properties of A and B through D so it's very rare that you're going to access this but in case you want to access it this is the solution you need to make it virtual right in this video we'll talk about overloading and overriding in C plus plus so let me just write it down here it's overloading and overriding all right so let's first talk about functions for a moment right so when we learn functions we told that functions are nothing but a piece of code to be executed separately so that your program can be broken down into a set of functions which will do the work and then all the results can be integrated together to solve the problem right so now let's say you want a function which can do multiple things that is not possible right when we Define a function if we are defining a function we need to be sure that we pass the same number of arguments or the same kind of arguments to the function to make it work so let's say I do something like uh in terms add which is going to take in two integers so int a and in p and what it will do it will just return a plus b now I can use this function without any problem and I can even pass integers over here right sorry I can even pass characters over here because as you know characters are nothing but integers behind the scenes they have their ASCII values and when you pass a character as an integer it is considered as the characters ASCII value right so basically I can pass integers and characters and floats too because as you know because of the type casting the floats will be converted to integers and the operation will perform but what about strings I cannot add two strings using this function right so if I use this function I can only I had two numbers or two characters and get back an integer I cannot add two strings using this function it will give me an error right so how do we go about solving problems where you want to solve problems using the same function signature you don't want to write multiple different functions for the same thing but all the functions are actually similar in nature that means that these functions can be grouped together so that's when overloading comes into the picture so what you do is you keep the signature same all right you keep that same but you can alter the parameters over here and redefine the function and when you compile the program the compiler will see the inputs which are giving the parameters and then it will use the suitable function definition for that parameter all right so uh for an example let's quickly write a small program so let's write a function to determine whether something a given input is a palindrome or not all right so if you don't know what a palindrome is palindrome is nothing but anything which can be read the same way from right to left or left to right so if we take a word as Madam so m a d a m if you read it from left to right or right to left it Still Remains the Same right so these kinds of things are called palindromes it is the same with numbers too if I do one zero zero one this is also a palindrome right now our problem is to write a function so that the function can identify palindromes in both strings and numbers all right so this is our task so how do we go about this well uh writing for Strings is pretty easy right so let us first write a definition for that function so let's say Bool because we are going to return it true or false and it's called palindrome and uh it will take a string so let's call it Str for now right and uh to compare palindrome what we need to do is we need to uh well if you think about it the logic is very simple I will uh leave it to you to come up with um different methods to solve this particular problem but for now let's go with the simpler methods right so what we can do is we can just iterate over the strings and go on comparing the first and last character of the string and other way to do this is to reverse a string and then compare it well the first way is more efficient but uh I want to take this opportunity to show you that uh string data type has lots of methods in it and one of the method is a reverse right so basically what we are doing we are just when we are comparing whether our input is a palindrome or not what we are doing is we are checking whether the number or the string even if it is reversed reads the same thing or not right that is if it reads the same thing it's a parallel drug if it doesn't it is not a palindrome so to do that what we can do is this string class or the string data type does have lots of methods with it so if you check for string rivers in C plus plus you do have a function to reverse a string right so basically you you can do it manually as shown here you can use a for Loop or you even have a function to reverse a string all right so once again I'm just searching for that yeah this one so here if you see you can directly reverse this using this kind of a method right so I I'll just copy this thing so that uh I don't have to write it again but basically this is the way you can reverse a string and as I told you the other way would be to just compare the first and last characters and so on right so you compare the zero and the last character one and the last but one character two and the last but two character and so on so if you just compare that that will be more efficient so yeah so we can just copy this and paste it over here so that we get the reverse of the string and what I can do is I can just compare whether the string and reverse are equal or not so if the string is equal to the reverse then uh well I just need to return true else written false so let's quickly try some examples here so see out let's say palindrome of Madam all right and uh yeah did this method won't uh I mean allow you to compare strings with uh different cases right so if I if I do something like Madam this won't be considered as a parent normal right so I'm not taking that H case for now so let's just try to keep this simple but uh you're open to try out all the edge cases and then come up with a very efficient algorithm to find out whether a string is a palindrome or not all right so this the purpose of this video is not to explain you how to get a palindrome but uh it's basically to explain you overloading or overriding which we'll do in a moment all right so for now this is our program and if we run this using Ctrl F9 what does it say palindrome is not declared in the scope okay I have written plain room so Talent room so here you get one right so one is basically true and zero is false so you know that right so now here if I try something else so let's just try the casing one so as I told you this should not be a palindrome compared by this method right so we are not comparing cases here sorry we are comparing different cases here so small m is different from capital M right so this will not be a palindrome to the compiler so it will say it's not a palindrome so you get a 0 over here which is false right so we have written string palindrome but what if I pass in a number over here so something like one zero zero one if I run this I'll be getting an error it says could not convert this from into a string so this this whole thing is nothing but this string all right so to to make this Pro this function work even for string either what I can either do is I can just say palindrome string and then Define an entirely different method for integer palindrome or what you can do is I can just say bull palindrome so notice that the signature is same the return type and the name of the function is same but here I'm just going to say in 10 all right and so here I am keeping the integer and to find the reverse of integer you have a small logic so I'm not going to go through a logic basically what you do is you have a multiple very well we can just copy and paste that logic from here since we're not discussing about palindrome so um let's say in Talent room C plus plus why do I keep writing play in Chrome over here so we yeah so this is what you do so basically uh the same thing is going on over here what what this program does is it will find the reverse of the number using this logic so basically reverse of a number is nothing but you extract every number every number is basically the reminder when you divide that number by 10 the r is nothing but the last digit all right so in mod 10 as I told you over here if I do mod 10 it will basically give me the last number and uh sorry about that and um here what you what you're doing is you're just adding that last number by a multiple of 10. so what basically happens is you have one and when you store it what you do is you just store it as 0 into 10 plus one so basically you first have sum equal to 0 like this sum or anything reverse number anything you can call that it will be 0 and you what you do is 0 into 10 plus 1 and you put it inside the reverse number so basically now this has become 1 right 0 into 10 is 0 plus 1 is 1. now what you do is you divide this by 10 so 1 0 0 1 by 10 which is basically 100 so next again you run this Loop so you do this reverse equal to reverse into 10 plus the last digit so let's call this last digit so this is what you do every time 100 so now what you do 1 into 10 which is 10 plus the last digit is 0 so you get 10 here so this is how you reverse the number so let's quickly write that I thought of copying it but since I explained it it's very simple so in Reverse equal to 0 what you have is while the number exists well we cannot directly use the number so you need to store the number somewhere for later comparison right so we'll just say in Num equal to n we'll store a copy of that and while n that means while the number is not 0 so as I told you in C plus plus the booleans and integers are related right so any number except 0 is true 0 is false so it will run until n becomes zero so till then what you do is we will say in the last digit equal to the number mod 10 this will give you the last digit and what you need to do 2 you need to say reverse equal to the reverse into 10 previous value of reverse into 10 plus the last digit and the number will become one tenth of itself so number equal to number by 10 right so this is what we'll do we'll be doing and let's just print out the reverse for now all right so let's just print out the reverse number so that we are sure that it's working and we'll just return uh something so we just return true for now all right so now if you see if I run this program I did not specify any different name for this right so basically both these functions have the same name but the parameters are different so when a compiler will see this it will see that I'm using an integer so automatically it will understand that I am calling this function all right so if I pass in a string here it will automatically call this function but uh here since we have overloaded this function this process is known as overloading basically all right so overloading is nothing but you just take the same function you don't change any word in that I mean any signature in that so the signature Remains the Same you cannot change this return type but you can change the number of variables and the variables nature itself so I can even add number of variables over here it doesn't matter all right so if I do that and now if I run this if I now compile and run this I will be getting 1 0 0 1 that is the reverse number and then the one so if you're confused let me just add a new line over here and we'll run this again and here you can see the reverse is one zero zero one which is what we required and the true part which came from this statement all right so now since we have the reverse it's pretty straightforward just like this one right so you can just do something like if the number which we saved this one is equal to the reverse number then it's basically a palindrome so written true else return false so you even if you write else it doesn't matter because if this is true it will directly return it so I'm skipping the else part so return false over here and this should do right so now if you run this program what you have is for both strings and integers so I can even pass integers over here and I can even pass strings over here so let's say um all right so this is also a palindrome so let's check whether the spelling is right or not yeah perfect so now if I run this I'll get one over here and if I try to run something else I won't be getting perfect result so if I do that and if I run this I will be getting 0 or even if I pass in numbers over here so if I do that this one so this is not a palindrome if I run this I will be getting zero so yeah this is the use of overloading when you have a same function I mean the same function signature but you want to use it for different kinds of variables and different number of variables this is how you can use the same function to achieve what you want right so here uh the advantage is that we are not maintaining multiple copies of the same function but what we are essentially doing is we are maintaining multiple signatures of the same function so this whole thing is called a signature and the return type and this one this should not change all right so only the parameter list can change so this one will only be maintained separately and these two function definitions will be maintained the advantage is that you don't have to remember or give you know informative big names to different functions so well I I don't have to worry about overlining if I'm doing something like this is for string like this paring drum Str and palindome int if I'm doing something like this I don't even have to worry about overloading but this basically the whole point of overloading is that you can have a single function doing multiple things that is the idea of overloading and when is this useful it is useful when we are doing inheritance and at that time this thing is called overlaiding right so basically these two are the same thing all right overloading or overriding just mean that you are using the same function with different parameter lists and different definitions all right but overriding is used when you're over when you're overloading a function in different classes when you overload a function from a base class inside a child class that is known as overriding and if you overload the same function inside the Base Class itself that is overloading so that is the only difference between overloading and overriding or else both are the same Concepts so to demonstrate overriding you can just use this one so what I can do is I can say class say a for now and this is going to be a public definition so that I can inherit it and uh I can just push all these things inside this a right and yeah take care of the indentation over here and we'll maintain another class B and inside this I'll just pass these things again so public and uh pass it over here right now if I do a public inheritance over here what will happen is as you know this palindrome will get inherited inside here but since I'm doing this it will get overrided all right so this method won't be won't act as a string palindrome checker for class B but it will act as a integer palindrome Checker inside Class B so for object of Class B if you call object.parent room if I do something like uh let's say obj equal sorry b o b j all right this is a new object of Class B and if I do obj dot palindrome all right so if I do this it will only be valid for a integer parent room all right so if I not do that you will be getting 0 over here of course it's not a palindrome but if I do that and run this I'll be getting an error it says it is not a integer so to take care of this issue there's something it is a method to actually use the functions of the super class super class is basically the parent class which I'll talk about in a later video because that is something very important and we will be using that very very much while using abstract classes so basically all this overloading and overriding all these Concepts come into play when we are using abstract classes well this is not limited only to the functions you can even overload the constructors also if you want to so that is the scope of overloading and overriding in the previous video we discussed about overloading and overriding and in this video we'll talk about abstraction all right so first of all why do we need abstraction or what is an abstract class basically well abstract classes are nothing but just a normal class with at least one of the methods as a pure virtual function now what does this mean it means that a pure virtual function is nothing but a function without any definition it's it's just a signature so why do we need an abstract class when we can just inherit we can just create a normal Base Class and do the inheritance like this well when you have a very big Clash or very big networks of classes where you're using multiple methods of inheritances and all these things what happens is you at some point you forget the structure of the class like let's say we take this function as an example you are using the palindrome function and these two methods just let's just suppose that these two methods are not methods of the string but you have written these methods inside this Base Class which is classic and now while inheriting you are just overriding the palindrome class now let's say I want to access the string class from class B because I I'm not going to I don't know that there exists a Class A which is the base class of uh this class B I just know that I created a method from class B because this definition won't be visible to me right so as I told you we'll be writing this Clash definitions into inside different files so when I use that function when I use that class to create an object so what I will be seeing is this thing so from here I cannot make out what is the base class or what is the super class or what is a parent class and all these things right so what I can tell is this function I cannot even tell whether this function overwrite something or not and for me this is a completely new class but inside let's say you're just overriding this function and uh suppose you forget to overwrite these two functions which may be a dependency for right now it is not a dependency at all but let's say that while overriding you do need these two functions not necessary for the palindrome function but for some other function these two functions are begin and RN are written by U inside the base class and they are necessary for the overrided function to perform so in that case you are going to get an error and you need to figure out what happened right so for this this particular problem for for this problem where you forget the structure of the class at some point abstract classes are introduced so abstract classes what they do is they have a tendency to just create function signatures they don't implement the functions they just create function signatures so that that you get the functions you need to write them you need to Define them indefinitely you you can't skip the definition so that kind of function is called a pure virtual function well virtual beat it here off in while discussing the diamond problem right so the virtual keyword what it does is it will take care of the fact that there exists only one instance of a class if multiple instances are coming so a virtual function will also do the same thing a pure virtual function but the only difference is that every time you implement it it will be considered as a new function it won't be considered as something coming from the base class right so let's see how to implement that what you do is you just write the function definition so let's say in test it can be anything right so maintain B for now and what I'm going to do is to make this pure virtual and to make this whole class as an abstract class I'll just do virtual interest equal to 0 and this statement this two extra statements will make this function as a pure virtual function and the whole class as an abstract class now what is the result of this now if I try to run this I will be getting an error what does the error say it's at the creation of the object from class B it says that it cannot declare a variable of an abstract type now what is the abstract type abstract type was a because B does not have any virtual pure virtual functions but still these considered abstract because this thing is getting inherited directly so I need to Define this I am forced to Define this function inside Class B while I'm shipping this class so that I maintain the structure now let's say palindrome depends on this test right so palindrome depends on this test function and it is very necessary for me to if I'm overriding this palindrome function inside the child's class is just very much required to override this test function also inside the inherited class or the child class so in that kind of a situation you maintain virtual classes you maintain pure virtual uh functions and you maintain abstract classes and when you inherit you can just Define the function just like that so it's basically the same definition you just need to say in uh A and B so these things are already there and B and you can do something like um return a plus b okay a simple function now since I've defined this function I'm not going to get that error so now if I've run this it will run smoothly and I'm getting one that is from this palindrome check which we performed in the last video right now the other thing is that what if we want to access the functions the defined functions from the superclass that is the pair interest so now I do have the function for uh the palindrome check for numbers now if we're passing a string here it is not supposed to work because string is something which is getting inherited from parent class so if I do this if I do this I'm not going to get a perfect output I'm going to get an error so to solve that what you can do is to access something from the parent class you just put the parent name and the scope operator so this is this two uh colons are called scope operator and if you combine it with the Base Class you will be getting the output run from the function which is inside the base class now this will run without any errors now if I try to run this I'll be getting one over here that is because of this one right that that's because of this little addition over here which will make it work for the base classes too so now if you try to do this for test so let's say it test and I don't want to so because test will take two numbers right in 1080P now if I try to run this what do I get I get an error and it says undefined reference to this function what it means is that this function does not exist in class A that is because we declared it as a pure virtual function so once you inherited it has to be defined inside the child classes or else the child classes are also going to be considered as abstract classes and once you implement that function inside the child's class they can be used just like that so if I just do object DOT test which will basically call this function from class B which does have a definition for test if I now try to run this code I will be getting the output and it returns 3 which is basically one plus two right so that is about abstraction and pure virtual functions so basically this whole concept will be used only this is required all right this is not a daytoday used concept the abstraction and pure virtual function they are not used generally they are used very rarely when you have a situation where you need to do something like this or else a simple inheritance will do its job or not even in returns a very simple class can also do the job for you so these are highly advanced concepts which you may use or may not use in your whole career but it is always a good thing to know that these exist in case you come across a situation where you need to implement something like this so with that let's in this video and in the next video we'll move away from these class object Concepts and we'll do something exciting we'll learn how to interact with files on our hard drive using the file stream and with that we can also explore more about the vastness of object oriented programming Paradigm well as I told you object oriented programming is a paradigm it's a style it totally depends upon the problem whether you need to use object oriented programming or not this this is not a part of C plus plus but this is a part of programming itself so with that let's uh close the object oriented programming for now let's deviate from that and let's talk more about General programming dealing with files how to read files how to write the files and all these things in this video we'll see how to handle files using C plus plus now what is file handling why do we need to handle files well whenever we are running a program where if we are taking some input from the user or let's say we are even generating something which is really important and we need to store those things like uh let's say in our snake game we when we made that we had no provision to give a high score right because every time you run the game the score starts from zero and there's no way to know what was the highest score made till date using this game right so to counter such problems where you need to store data to a hard disk not in the ram because whatever you're doing in the program in its run time it's everything is getting into the ram right nothing is going to be stored onto the disk but you do need something on the disk so that whenever you uh want the data back whenever you want to read the data back you have a way to read it back you don't have to you know again Ask the user to enter everything or you know Miss out some important things and all those things that is why we actually handle files we write files to store data so that it will be useful in the long term now everything in C plus plus as we know runs on streams so whatever we are doing with the operating system with the hardware everything runs on stream so you're already familiar with one of the stream known as IO stream right input output stream which allows you to access your keyboard and mouse using C plus now for files you have another stream similar to this IO stream which is known as the file stream so what will file stream allow you to do it will allow you to access the hard disk of a computer so that you can write files there so you can write many types of files using file stream which we'll be discussing in a later video but today we will start with something really simple which is nothing but the ASCII files SK files are nothing but what you see every day the dot txt files right so we will be writing ASCII files today using file stream so let's quickly import that hash and include app stream and here in F stream you have a class called f streams right so if stream is a class and there are two other classes so let's quickly talk about them one is known as the ox stream and one is known as the if stream now what is Upstream fstream is nothing but a class it will give you it will allow you to create a file object with which you can read write files right but of stream and if streams are nothing but inherited classes so these are nothing but children of this parent class and the use of them is pretty straight forward over stream is nothing but the output file Stream So you use this whenever you want to write out files and if stream is nothing but the input file stream which you will use when you want to read files even you want to take input from the file right so these are the two classes well these are useful for fasting because in the f f stream what you need to do is you need to provide something known as Flags so let me just write it down here you have something known as flag which you need to provide to the F stream class to read to get a particular functionality of the file so when you want to read in a file you put a particular flag when you want to write out a file you put a particular flag and all those things we'll be talking about that later but today we'll be seeing one of such Flags so basically all these flags start with something like iOS you have two uh colons and then you have a string over here so we'll be talking about this flag today which is IOS app which is nothing but a pending flag and we'll see what append means in a short wheel right so the this is about the classes this is just an overview we'll dig deep into it in the future videos but today we will see how to quickly write a file how to read a file and what are the different ways to read from a file right so let's start with writing out to a file so uh for that what we need to do is create an object of of stream output file Stream So of stream and our object is known going to be file right now to open a file what you can do is you can just say file Dot pin and inside this you can pass in the file's name so I'm just going to do test.txt well this file doesn't exist I'll just explain you in a moment what this does but basically for now you can say that this file doesn't exist on my computer it will be created by this of stream class now you can either use this method the dot open method or what you can do is you can directly call The Constructor so you can just uh you know use this Constructor you can just pass in the name of the file over here and that will do the same job as file.open so this is about opening a file opening is nothing but if if that file exists on your hard drive what will do is it will just load it into the ram so whatever changes you make to that file everything will be affecting the original file in the hard disk and once you close it it will be removed from the ram so that's how of stream works and another important thing is you need to always close the file so once you open a file it's really important that you close the file well this should be in the last technically but I'm just putting this right now so that you guys remember that whenever you need to whenever you open a file you always close the file this is a must right so it won't affect your program much but what it's going to do is it's going to clean up the ram so you don't want your files dangling around the ram right so if you don't if you forget to close this file it will be present in the RAM and it will be removed only when you restart your computer so that is the reason uh it's always better to close a file once you open it and and that's about creating a file or opening a file so if if this file exists if this exists where does this file go it just goes in the same directory as this main file so I have this project saved in my desktop so if I go to my desktop and open that project it's YouTube so here you can see main.cpp and uh well I had created this file before so let me just remove that so here you have main.cpp right so this is the directory where the file is going to come now if I just run this program if I just run this I'll be getting a successful run and if I go there I'll be seeing test dot txt over here so this has been created right now once I run this program and it will be created whenever you run this program basically what happens is even if it exists it will just overwrite every everything in that file so if if I write something over here so if I write something like this is a test save that close that and again run this so let's just run this again go back here open up test and you can see it's blank it's gone right so that is what happens when you open a file I will tell you how to save the previous contents but for now let's just talk about creating a file what happens is even if it exists it will be overwritten and a new file will be created in the same name right and it's just like you're just deleting it and creating it again with the same name and it will be always created in the same directory from where you run the program so since I'm running it from main.cpp so here I am at main.cpp I'm running it from here it's creating in this directory and if you go to bin debug here you will have the exe file right so I've told you how to distribute your programs so this exe file will be created every time you compile your program and if I not double click on this the test.txt will be created in this directory now this is different from this one right so when I run main.cpp it will be created in this directory when I run this debug it will be created in this directory so basically if you don't provide directory what is going to happen is it's just going to create it in the same directory and if you want to create it in some other location so let's say um um let's create it inside this obj so here you have a folder called debug right so I'll create one over here so you'll just need to provide this folders name so all you need to do here is I'll just say obj slash test.txt and if I run this and I'll be getting it over here so obj test.txt right so that's how you create files in different locations and whatever it suggests is that you don't worry much about the locations you just create the files and then move it to wherever you want right that's going to be really easy so that's one way or else you can just create it in the exact location you want and work with them it's up to you but for now this is how you create a file and now let's see how to write to the file where open this in of strip mode right so you can write to this file so how do I write this well how do I write something to the console you do something the like this right so CR this is attached this is how you write to the console and let's say new line and this is on another line This is how you write to the console and if I run this what I will be getting is I will be getting those lines onto my console now the way you write to a file is really simple what you need to do is you just need to remove this C out and place file over here so that's how you write something to the file this operator is all that matters because both of the them are streams right and this is nothing but a stream operator this output stream operator that is why what you can do is you can just use this operator to write something to the file and now I just close this file if I run this I'll be creating a file of the name test.txt inside obj well I did not remove this well basically it will be created inside object you will have these content so if I go here so this is not the file so here you can see it's empty it's inside obj and here you have test which has those contents so this is how you write the file right so this is how simple it is to write to a file you just use the stream operator to write to the file and you must have guessed it reading a file is almost similar so now let's move on to reading files I'll just delete this I don't want my structure of the project to be messed up so just keep this inside the same directory and um now to read from a file what I can do will before going to reading from a file let's talk about appending to file what is appending well if I not change this content will be overwritten right so you just seen that whenever I use of stream our file will be deleted and a new file will be created in its place with the same name right so if I now remove this so let's say I remove this so this is on another line is the only content if I now run this I'll be getting that thing inside this file test.txt which has only one line now how do I add something to this I cannot add something right so if I just remove this and add something else over here so if I just remove this I'll just keep this the word this over here and I run this you you know that it's just going to be overwritten over here everything else would be gone I just have this over here now now how do I tackle this well there is a flag as I told you in the beginning it's the appending fight how to add flag is that you just put a comma in the Constructor or in the open statement so if you are using the function to open it you just do the same thing over here so you just do test.txt put a comma and write whatever I'm going to write here right so here what I'm going to do is add the appending fact so iOS these two colons and then you do app which will enable the file in append mode so what happens is that it is not going to whitewash the file the things are going to remain but whatever I'm going to add now are also going to be written over there now if I do something like this is some new content being added and uh just to differentiate let's skip it on a new line because if you don't keep it on new light just works like shared operator right if we don't keep a new line it's just going to write it beside that so that's the thing so if I just write this save this run this build and run this sorry and now if I go to my test.txt so that that is the file I have been writing to right so if I now open this here you can see that the new content has been added and the old one is being preserved so that is about appending files and now let's talk about reading grammar file well to reading to read from a file it's almost straight forward what you need to do is just remove of stream and replace it to if Stream So if stream is nothing but input file stream and how do you read from the console you do this right so you have variables called string s and you just read from the console like this and to read from a file just replace scene with file and that's going to allow you to read the file and now since I have a string here what is going to happen is it's going to read word by word now if I do c out S I will be getting the first word so what is the first word over here in my file the first word is this right so I'll be getting this over here so by renders I'll be getting this and now if I change this to a character if I do care and now if I run this I'll be getting the First characters which is T right now how do I read the whole file so basically what happens is that whenever you write a file whenever you do file Dot close what's going to happen is that the newly added content after that at the end of the file you have a special character which is not visible known as the end of the file character or the eof so eof is nothing but end of file and this is a character and while this is not reached we can just keep on looping so what we'll do is we'll run a loop and after every time we get a character we'll check whether it is the end of the file character or not once you reach the end of the file character you will just terminate the loop so how do I do that it's really simple I just do well let's just keep a string uh variable on the outside of the loop so that we don't create it every time so here what I'm going to do is while let me just put it on new line while file dot EOS so while file.f while file.of has not been Rich so for that I need to put not so while not file.orf while not file.elf has been reached what I can do is I'll just read the con word inside string and I'll just print out this string on a new line right straight forward now if I don't run this what I'll be getting is I'll be getting all the wet so this this is some new content being added so all these other words in my file so that's how get word by word if I need character by character it's almost the same thing I just change this to KR run this again and I'll be getting every character in my file so this is how you create character by character and if you want to read line by line it's little bit different you don't reach to the end of the file what you will do is you will just read the lines one by one and read till you reach the end of the file so what you do is I'll just show you it's just string s and here what I do is get line from the file inside as and while you can get the line if you don't get the line it's going to return false if you can get the line it's going to return true and I don't need this operator too so I'll just remove that and now if I run this I will be getting the lines so this this is some new content added and then a new line that's because of this one right so here you can see it's just reading line by line so if I want to stop at somewhere so basically what this does is it's it's called a delimiter so what it does is you you have a line right so you have this line and you have this line so how is it stored in the memory you have this special character which you know about right this is the slash n so this is how it's going to be stored so this when this character is reached it will consider this whole sequence as a new line but what if you want to consider this so if I just put this character in between I want to consider this one as an one line and this whole thing as another line so that can also be done using a delimiter so what you do is you just put a delimited like I just put a space over here so that's going to be considered as the delimiter for stopping when uh and considering that whole sequence is a line basically really the default is that slash in because that's what you consider the line right so whatever if if you write something like this and then you move to the next line so when you press enter that slash n is getting added so that is what you consider as a new light but basically if you want to consider something else as a new line this is how you do it and now if you just run this I'll be getting every word that is because after every word I've given a space right so and this is the uh delimiter I've given and if I put something else which is not there so if I put this thing it is not there in my file right so that character is not there anywhere so the whole thing is just going to be considered as a sequence now if I run this here you can see the whole thing has been considered as one single line right so that's how you can read from files you can write to files and it's all about the text file so you can do many operations like you can read uh you can count how many words are there or uh what you can do is you can read the files and see if some data is getting stored over there or some specific word is appearing in that file or not so all these things you can do let's quickly write a small program to do that what you can do is I'll just stream file file Dot close never forget these two things when you open a file you need to close it and let's say we'll just say let's see out enter your name and I'll get a name here so string name C name so this is just like I'm just showing you how you can use the files this is just a simple example and here I will do another thing like see how enter your each and I'll just say in each chain eight and now what I'll do is I have already opened the file right so let me just move this down here I don't want to put this file in the memory right now so once I have all this information entered I'll open the file I will write this information to the file how do I write it I'll just say a name and the name new line it's just like this your operator right um I hope that you're getting the similarity over here and then it's h and the age that's it I'll just do file.close and well I did not give any name to the file so let's say details.txt I'll use this name I'll build and run this I'll be getting audition name it's Tony oh sorry I'll say okay it's too much let's say 12 and enter that I run that program now I go here I have this details.txt I open that and here I have my details so whenever I need this information again I will be having that information and I can just read from this well basically for these kinds of information these are nothing but details right so you have uh name Tony age stuff and something like that so you you can maintain a table like that so will that kind of stuff that this is just to store text Data this is just stored ASCII data there is actually another way another a better way to you know store information like this it's it's nothing like SQL if you are familiar with SQL SQL is nothing but a database language but for now what we can do is we have something called binary files so what you can do is you have to go dot that files where you can write classes now why do we need to write a class well all these things if you want you can just create a class and then you can assign particular variables for that once you have a object of the class you can directly write that object inside the dot that file and you can access them this details thing that's how people do it because it's really easy to access in that way because once you have this one line you need to strip that line you need to you know get that last character and all this thing so that kind of things won't be necessary right so that is the only reason people use dot that files because once you have a class once you read it inside a class you can just do well it's just like you have something like person p and once I read this inside this what I will do is I will just do p dot name I will get the name p dot age I'll get the age and something like that so P dot age will give me the age so that's how people do it and we'll see how to do that hey guys welcome to programming knowledge in this video we'll see how to deal with binary files using C plus plus now binary files are something which are different they are not as simple as ASCII files so uh in the previous video we saw how to deal with ASCII files so basically what are ASCII files ASCII files are nothing but the files which you see right so whatever you can see on your computer using some application or the other so using notepad or using something like this code blocks editor or something if you can see the file if you can read the contents of a file then it's ASCII if you cannot then it's something else and that is binary file right so here if you see this main.cpp I can read this using any notepad or something or they see all these contents right but if I go and open up something so let's say I open up a game so here I have the Watchdogs 2 game open and if I go to this folder I see a lot of files here with extension dot that and Dot fat right so these are all the extensions which are commonly used for binary file so dot bin dot that and all these things so what happens is you cannot read things which are inside this thing right so if I do even if I force to open this using my notepad so if I do something like uh notepad comment.dat so I will be seeing lots of characters but none of them will make any sense to me right so let's just wait for a moment it's going to load everything and here you see there are so many characters which doesn't make any sense so I do have some ASCII characters over here so basically it's a slash three nine something like that so maybe these are some Escape sequences or something but basically the whole file almost 99 of the file is data which you cannot understand so that is why you use binary files you don't use it to you know save your data from from where but basically what happens is this dot for that file or dot bin file whatever they contain objects they do not contain plain data they contain objects so if you remember so if I write something over here so whatever I write here these are all characters right so you know that and now if I write any number over here this is not a number so that's what I wanted to tell here but if I write something over here if I write uh this number inside a DOT txt file it is not stored as a number but it is stored as a character list or you can just call it a string it's just stored as a string it is not a number but I want to store it as a number I want to store it as an actual object how do I do that so that is when binary files come into play right so now in this video we'll just see how to basically read and write a binary file it's a very big topic so we'll be dividing it into videos and in the upcoming video we'll see how to do operations using binary files but in this video we'll just see we'll just understand what binary files are and how to write them how to read from them right so let's start firstly uh reading and writing are almost same you the constructors are almost same right so use over 3 Ministry and all these things the difference comes when you are using the methods and the way you operate the files right so let's see how to do that so of Sim file and I'm using the Constructor to open the file so let's say test dot that so this is basically a common extension for binary file you can use dot pin or something like that and uh yeah one more thing I wanted to mention here is that this extension doesn't matter right so even if you use dot txt it's going to work but basically it is recommended that you use extensions which convey the nature of the file so um what I mean is if I go back here in inside this game folder um yeah let's go to this folder you see lots of these dll files right so if you see this dll files you uh see this gear kind of Icon right so that is basically because the Windows operating system knows that this is a dll file it knows how to interpret that so for dll file it has assigned this kind of Icon so that's why it's showing you for images it has it must have assigned some kind of Icon and for C plus plus it must have assigned some kind of Icon and so on right so basically this file icons are dependent on the type of extension you give it it's not dependent on the data right so that the extension is for the operating system to identify the kind of file and to give it a suitable icon but even if you mess up the extensions it doesn't really matter right because the way the computer is going to store the data is controlled by the data itself and not by the extension so even if you put dot THD for a binary file or dot bin for an ASCII file it doesn't really matter you can still uh you know operate on those two files in their native way right so we'll see that so for now let's go with the recommended way so test dot bin and here if you just leave it like this it's going to be interpreted as an ASCII file as I told you extension doesn't matter but here you need to put it nice I I use binary to interpret this file as a binary file right so this will open this file in binary mode and of course uh it's an output stream mode so I can write to this file and another thing I need to close this so all these things are the same thing which I mentioned in the previous video you open a file you close the file and in between whatever you do that will depend on different file types and ASCII files we saw how to write we just do this the most simplest way to write to ask a file you just do this you write all your data here you just put this operator what it will do is it will direct everything inside this file and it won't store it as a specific object it will store everything as a string so where if I do this this will go and set as a string right now to write an integer let's say we create an integer in P equal to 1023 so this is our integer and I want to write this integer to this test dot pin how do I write this well the way you write it is file dot write so this is a method and here you have two parameters so one is conch CAD type star on this thing and another thing is the stream size so let's see what they are right so basically what happens is in binary files you convert your data into Strings of bytes and the way you do that is you go to the address so if you remember the address is given by and right so this Ampersand symbol will give you the address so and P is my address of P I'll take this address convert it into a character string right so string you can this string is a class but character is a data type so basically what I will do is I'll this is a character Ari which is nothing but the string so basically this is equal to a string right so this is almost equal to a string but string has some additional functionalities it is a class in C plus plus you don't have a string data type in single distance but anyway you just convert this into a character array because it's the primitive data type and you take the pointer of the first element and you give it to the writing object so this this thing it has file pointers inside that and we'll go and see uh we'll explore file pointers in more depth in the upcoming video but for this video you have file pointers which will take the pointer of this first object and in the second thing where in the second argument where you mentioned the stream size so if you remember you had two arguments here right the first one was this thing the second one is basically the stream size which will tell the pointers how many bytes of data to take so here you have a memory right so if I just open up my paint and I have this whole memory so this is all my memory I have in my computer so let's say 16 GB or 32GB whatever it is I have I specify the first so let's say the integer is stored in this 4 bits I know that integer size is four bits let's let's just consider a realistic scenario so I have four bytes over here what I will do is if I do and P sorry What's Happening Here undo so here I have this and P which is this thing which will give me the address of the first point right so this is what the and operator does it will give me the address in hexadecimal format I'll take that give it to the file pointer and say that I from this address read four bytes of data so what we'll do it will take this it will read four bytes of data from here and it will store that data inside the file so that's how it works so if I if I do 10 bytes it will do the four bytes and whatever is remaining it will read from that too and try to store it and it you know it messes up the data right so that's how you store files here you read four bytes you read the size of the object you take the you take an instance of the object read the size and then save this memory thing inside a file so that's how binary files work you directly don't write data you go to the address you take four bytes or whatever the size of the object is you take those things convert it to bytes and then write it store it right so that's what we're going to do here so here what you need to do is first of all get the address so which is given by Ampersand P which will give you the address convert it to a character array and here I need to specify the number of bytes so it's just 4 I can just write 4 or if you are not sure just use the size of operator right so size of P right this will write this thing this one zero two three as a number inside my file known as test dot pin so now let's let me just run this thing I did not get any errors and let me just open up my folder and here you see test.pin and if I now go and look at the properties it is exactly four bytes right so four bytes is because one integer is four bits you know that now if I try to open this if I try to open this using some notepad or something or let's just use notepad here notepad test dot bin enter so here you see some weird character right so this is some character but it's not one zero what did I write 1023 it's not one zero two three right so that is how you write binary files they are files they are written there but you cannot see them they are written as objects if you want to write two numbers that's the same thing if you just write this and I have another integer Q which is one zero two uh let's just keep it a thousand I do the same thing again right c b and instead of p i just write Q right run this it's written I go back here okay why am I closing this again again just open and keep this right so here I have test dot bin go and look at the properties it is 8 bytes because two integers right so that's how you write binary files and for now we are not going to write multiple objects because uh it's a little bit different how you iterate our objects so we'll see that in the next video but for now we'll just stick with one object right so you just write one object run this and it again as you know I'm not using any appending right so I'm not using iOS append so it will just write it from the beginning so if I go and look at it over here it's four bytes no the other thing is um reading from this binary file how do I read this it's really similar just replace this with if stream and take out this definition let's say in let's just keep it in pay for now this is read and these things remain the same so what does this say you read something to this address it is not from this address this time it is to this address and how much should I read I should read this much bytes right so I know it's kind of confusing but uh you need to get used to it while dealing with binary files so basically everything runs on sizes and byte strings so here what you're saying you are giving the address and you are saying read to this address and how much should I read I should read these many bytes right and after that you can just close the file and you can even see what is the thing over here so if I do um you know the value in B is and I just show p and if I do this in the beginning I won't say anything so if I just copy this and ask as soon as I create a variable if I do this oh I'll just do value in P before reading this and value in P after reading s right so if I do this and if I run this program now if I run this so here if you see the value in P before reading is this big number which is completely um you know it is garbage right so it it doesn't have any sense but the value in P after reading is one zero two three which we stored in the file before right so why this happened this is because the you know if you take those four bytes before reading in this location and if you convert it to an integer this is the number you will get so it doesn't have any meaning it's just a number right so yeah that that's all it is and here this one zero two three is after taking the bytes from the file converting it to integer and giving it to this location so that's about reading from binary files and the other figures I mentioned about the extensions right so if I do something like text Dot tht and I put this iOS binary flag and if I try to read something from that so I'll just comment this thing out so I did comment this right and here I just commented this section and if I open a file of that name test.txt and I write something so in P equal to 10 and I write file dot right cash star and P size of P and I close the file under run this program right it ran without any failures and if I go here I will have a test.txt file so if you look at this this is a txt file so it can be opened with notepad but if I try to open this thing using a notepad right so if I try to open this thing using a notepad I'll again see uh well there is a character here which you cannot see but so basically what happens is the computer will try to interpret the data every time you open it but basically sometimes uh you know the character which it interprets is something which you can see and sometimes there are some characters which you cannot see so this is one of the examples where you cannot see the character but there is a character here which has been interpreted right so that is what happens when you you know mess up the file type you can see that the extension here is of a notepad right so if I use dot kxt I'll get this extension but if I use dot bin it doesn't know so it just gives me this kind of extension but if you see here the icon which has been generated is of a notepad right it dot txt file a text file but if I open it it's actually a binary file I cannot see anything over here so that's why I told the extension the file extension doesn't really matter you can you know change the file extension and it's the same thing while reading too so even if I put dot txt over here and I tried to read this as a DOT txt file that will also work so if I just copy the selection uncomment this and I try to run this so here if you see uh the value of Peep before reading is this number which is garbage and the value of P after reading is 10 which I stored just now right so that is the reason for using dot bin dot that or all these things that the only reason is that it is for you that for the operating system to show you the correct file icon right so if you mess up the extension don't worry it will work as long as this thing is there because if you if you take out this it's not going to interpret anything so this will now be interpreted as a ASCII file and if you try reading and writing from this file it will fail because everything is in binary format right so that's about simple reading and writing of binary files in the next video we'll definitely see how to uh do operations on binary files but basically it is not restricted to integers only right so I just wanted to show that so if you just create a class let's just create a quick class now student right and we'll just put everything in public section you have a name sorry age you have a name and let's say you have a roll number and here you create um a Constructor of student and you just put um age name role and uh well because these two variables are same I need to use the this pointer I'm sure you remember that and this this dot name equal to name and that's not true number well I need not use that but still it just looks nice right so it is uniform over here so that does it now if I want to write this thing to a student file what I will do here is I will create an of stream with the name of the file as student let's say student data.tat or dot pin let's go dot bin we already saw that right and here I need to put the flag as binary so iOS binary and after that is done now I need to create a new student so student s and I can just pass in the age rule number and all these things so it's name uh something and roll number which is one let's keep it one and uh to write this thing to this file I just do the same thing which I did before so file that right what do we need to do let us care star it just becomes bihearted right so if you do this couple of times you'll just type it out without much thinking but basically the meaning is the thing which I explained before we are just converting the address into like character array so character and S size of s four characters or a b c d i just close this file Dot close and now I run this thing I get an error what does it say expected this before okay I wrote this as python sorry I need to specify that data type over here right so okay this is good run this again get which is these are considered as pointers why is that okay let's just do that oh yeah that's because this is a pointer right so I totally sorry about this I I I've been coding in other languages lately so I completely lost the touch of three people it's sorry well I'm sure you won't run into these kinds of Errors right so yeah very well it worked here and if you go to that location where you stored the files so here you have student data.pin so here you have 32 bytes basically you just store data like that and now if you try to open this thing so if you now try to open this thing you won't see anything I'm just saying that again and again but basically uh this is to make you familiar with binary file so that you don't you know run into an issue when you don't see anything over there so this is what you see and ABCD is a string that's why you're saying string but other things are all numbers and pipes that's why you are not saying anything you're just seeing this weird characters over here right so that's how you write to binary file you write data into binary file to read it from a binary file you just you know it's the same thing as you did with the integer just that this is nothing but not a common object but it's something which is made by you it's a use a different object so you do that let us find this is if stream let's do that and you can always show these things right so see out s dot name a new line H dot h new line s dot roll number right run this I'll get another error what does it say okay that's because I don't have this kind of thing I don't have this concept I'll just Define an empty Constructor then right you can have as many Constructors as you want just just overloading right so I'm sure you remember that so do that run this and here you have um there are some errors over here but basically has a string is a class that's why I had to use this is not a you know it's not a data type as such right string is something which has been made on top of characters so you need to use characters the string is actually a class we'll I thought we'll talk about this later but after seeing this I think that we need to discuss about the string class uh very soon but basically string is a class it's not a data type so it doesn't work like other data types that's why you're seeing this thing but basically if you use characters if you use character arrays or something like that that will work right so instead of name I'll just do something like cash Star right and here cash star and again you need to use you know string Methods like you have a string class here hash include uh C string so you have this class you need to use this class right to uh copy name and all these things so strings are something it's a whole different topic we'll talk about that it's not as simple as just defining it as a string but basically you have a whole set of operations on the string but if you do that this is how we store data inside a file so that's why you got this 32 bytes and all those things I thought I did not you know uh tell that right now but yeah in the next video we'll discuss about that and also we'll discuss about how to read how to search how to write multiple records and do all these things how to delete things and all these things right so binary files not about uh direct ASCII value writing it's not really simple as just writing something as we did in the previous video it deals with pointers it deals with memory addresses and all these things so if you're not comfortable watch this video you know a couple of times and then try this on your own so that you get familiar with this statement so this statement you need to understand because in the next video when we talk about the file pointers these State this thing is going to be really really important so make sure that you understand this before going on to the next video so hey guys welcome to programming knowledge in this video we will be dealing with a credit operations in C plus so if you are a web developer you might be already familiar with this term current which just stands for create read update until it so these are the operations you do on a database right so now what does this have to do what this database have to do with binary files well if you see in the last video I just talked about how we use binary files right so binary files we write objects inside binary files and what's a database database is nothing but a collection of Records right so how does those two relate so let's say I have a database of employees so they might have a ID name and what else they might have an address phone number etc etc so it's all this information and then you just store it as a tables two three four and so on so ID number one all the information two all the information three all the information all the information and so on so this is what a database would look like and what we're doing in binary files we're doing the same thing we're just making new employees so employee one is basically all this information employee two is all this information and employee towards an object and employs three is an object which has all this information and then we are just writing this object so basically you can think of binary files as nothing but a database right so if we are making a database it should be able to do all this operation it should be able to do credit operations which is nothing but these things create read update and delete and I will update and delete will also include searching a record right so how will you update without searching right so these operations are something which are really important if you are maintaining a database so database you can just if not a very technical database you can just think of database as just a collection of Records that's it right so to do that in this video we'll see how to do these operations on a database and before that we need to know how a binary file stores data right we already know that binary files just stores uh everything in binary format but we need to know how it actually stores right so let's say I have these four records the same thing and it it is not stored in such a neat table format what it does is it just dumps all the data in one single line so you just get one all the data to all the data three all the data for all the return whatever you if you have hundred data you just get all the 100 things in one single line so that's how binary files work and now uh let's say I want to do operations on this third record so I want to update or delete or something or I want to insert a new record in between these two records or something like that if I want to do any operation of that kind I need to First find this record so how am I going to find I need to move to this record right so for that you have something known as file pointers so just write it down here you have five pointers which are getting put so get and put a two pointers well both are exactly the same thing so if you talk about a file pointer it's just like cursor so if you think about this whole thing as a file in the memory this cursor which is blinking over here that is the file pointer and getting put are exactly the same thing like the task may be different but basically the pointer is the same so when you use a get pointer you actually use it when you want to read data and put this when you want to write data and if you are doing both it doesn't really matter whether you use get output it's just for convention right so get uh is used with um if stream why because I have stream just opens a file in read mode and put works with of stream because it opens a file in right mode so these are the two pointers and you have functions to use these pointers right right so you have the stealth function and then a seek function because we just need these two information so we're never working with a cursor what do we need I just want to know where this cluster is linking and I want to move this cursor to some place right so as these two functions are there the variation so tell G is for the get pointer tell P is for the put monitor similarly you have c g is for the get pointer and seek piece for the put pointer and what tell does it will just tell you where the cursoriation C will move the cursor for you so you can just pass in uh like 10 bytes and remove the cursor 10 bytes right so that is all about the file pointers and we'll be using this in code which will be more clarifying for you because these things are something which you need to understand when you are working with binary file so that is why in the previous video told that we need to understand how that read and write statement works the chain text you remember that right so stare star address of object and then size of object now these things are basically interacting with these functions inside right so this this whole thing tells that I need to write this whole array of bytes and this is the crucial thing which tells how many bytes to write so if you say uh if if let's say my file is over here and I use write method what it will do is it will just write down and then it will seek the pointer to let's say 10 bytes forward or whatever the size of the object is so I I am here I write a new object I write everything and then get the cursor and put it over here for the next record to write so that's our file pointers work and we'll see how to use that in a short way so well we have already run create and read so we'll do update and delete in this video and uh just for a boost I just have created a very simple class so I have this employee plus which all the attributes are uh public so I have ID name address and then I have a simple Constructor which does nothing so this is just to initialize an object and this is one useful Constructor to actually create an object without uh assigning one by one right and I have this info method so that I can just see what this object is so what are these things so it will be useful while reading the object right so this is the class and to write this class as I told you in the previous video we could not use string right because when we use string we could not write properly it's because string is a class it's not a data type so what you need to do here is I'll tell you what to do here but we'll talk about strings in a later video but for now the fix is that the first of all let's talk about the reason the reason that that uh writing produced some garbage inside the particular file is because string is a class and you cannot write objects inside objects so what you need to do is you need to change this to something which is primitive so you have primitive data types as uh flow double and you have integer primitive data types right so you can write all these things inside the binary file but you cannot write a class so well you can write a class but the class should consist of primitive data types it should not consist of some other classes right that is not allowed in CPS plus so to do that what you do here is you change this to primitive data types now so what is a string string is nothing but a collection of character so what you can tell is string is nothing but a character array so let's say name is of 30 characters long so this is just like they just name it and if you know SQL this is the same thing as doing something like where care right so you have something called Bearcat which does the same thing you just uh specify the number of uh characters you give and this will create a character field for you this is basically SQL so don't if you don't know about this don't worry but basically the same thing you are going to do over here too the only reason we use string is because when the string class makes it easy to handle uh these operations so I'll just talk about what it is but basically string class will allow you to work with strings really really easily right so that's one thing but for writing you need primitive data type so we're going to use arrays right so address of 50 characters and now I can just say string name and string address and now to actually copy the string inside the character array what I'm going to do here is I am going to include one another the header file which is known as C string so what this has is this has lots of functions dealing with the string operations right which are not included directly so if if you talk about this so if I want to copy this name inside this uh particular array what I have to do is I need to run a loop get one one character and paste one one inside that so that is not required you could just use a function called strcpy which will just copy a string right so strcpy this takes the source sorry this destination which is name and then the source and Source here is a string it's what requires is a const carry it const Caster so you can just cache style is nothing but you can just think of it as an array right so because see when we talked about this when we are talking about the arrays in the in our previous videos which we talked about terrorists we saw that if we declare a pointer to an array it will point to the first element so if you are declaring a pointer it's as good as you are just saying that this is the first element of an array so that's why generally people used pointers to specify the arrays whenever you are dealing with the variable sized arrays because if we don't know the length of the array it's very easy to just show that this is the first element and then go these many buds to get all the limits so that that's how we work generally right so that is one thing and here to get the character representation what we do is you have function called dot C underscore Str what this will do is it will give the C string representation of this string so a literally string is a class so this is an object and there is a method inside the string class which is C underscore Str which will give you an array of these characters so that's how you copy a name uh sorry copy a string in uh primitive data types right so same thing goes with address so address and then you have addl dot C underscore string so that will copy the things and that should do it so now you have successfully changed this thing and you can just try it out so employee a and uh let's say id1 name Tony address NYC and you can go with well um well let's go Captain America now so Steep and then let's see Brooklyn so you have these two objects created and let's just make sure that everything is working fine so yeah there's no address so everything works fine now let's go with the creation part so let's quickly create a function for that avoid create what you need you need an employee object create is nothing but right so it's just create all right this is just call create because we create a new record right so basically it's just you can think of it as writing something inside a file so employee OBC what you do you just open a file in ofc mode do it and let's say details for that how do you open it you open it in binary mode and here what you do after right the same tags the most important one garage star and OBG size of OBG and then you close the file so that should write an object okay so now you can just say create e Grade B and if I just run this I have created this file and you can just go and check in your directory you will have this details.tag file all right now moving on let's go to the read operation well these are the things you already know so it's just going to be quick right so yeah just don't take anything because you're going to read the entire document so just say if stream file which is details.tag iOS binary and you need an object of employee so employee obj and then while you can read so after three cash style and OBG size of OBG you just say obj.info so this is the reason I had this method defined over here right so yeah appetite what to do is just close the file foreign thing I forgot to do is I had to create it in append mode right because once I close the file and once I again open it without the IOS app and it's just going to replace things so I forgot about that so we need to add the IOS app print file because you don't want to just keep on creating new ones and just keep deleting the old ones right so that is one thing so just create these two things it just run again uh well now it would have appended there so I'll just delete this and run this again run it I have created two new employees and then just comment these things out now thank you just do read run this I'll be getting those two things so id1 name Tony address is this id2 and all the information right so we did CR now U and T are remaining so U is basically what you do is you need to update and how do you update you first need to search for something so first of all uh we need to uh make sure that we have a unique identifier for every object so this if you are talking in the language of database this is known as a primary key right so you have a primary key which is unique to identify an object because if you take in this case you have just name it addressed this right so name can be same addresses can be same but the iot cannot be same ID is unique so here the primary key for our class is ID and that's how you choose a primary key primary key should be unique and that goes same with databases and also this one right but here we're just hard coding that ID is what we want right so in update I'm just going to take in the ID which I want to search and then what I want to update so you can update a whole object that's also possible but since uh well I did not try to copy Constructor over here let's just keep it simple the concept Remains the Same right the concept remains exactly the same the only difference being that you you just update a whole object instead of updating a part of the object I'm just going to update the address of the object so I just says string HDR right and here now what I'm going to do here is I want to open the file and read and write mode simultaneously why because once I get to an object I need to first of all I need to search for a particular object which involves reading the object right whichever let's say I have these two records first of all I need to search whether This Record is what I want so let's say I want to update this uh employee 2 and I want to update this address so first of all I need to read through the entire records I have I want to first of all find out whether this thing exists or not and then if this exists what I will do is I'll just go back and record and then overwrite it so that's how it works you know a b c t e five records in a line as I told you what I'll do is first read a check it it's not the thing I want to update right check B it's not the thing I want to update let's say I want to update C I'll read C and check it it's the thing I want update I'll go back update see with the new record so C becomes F and then break out of the loop or even go ahead so it it basically depends on the operation you want to do so let's say I want to update all the addresses of people whose name start with s something like that so that that kind of thing you don't break out of the loop but if you just want to update a unique thing you just do that you just break out of the loop because it's not worth going forward right so that was a quick explanation of how update works so first of all we need a Boolean variable which is false in the beginning right and I will just return this Boolean billable so that we know whether an update Works successfully or not and uh what else you need you need to open a file in both read and write mode simultaneously because as I told you you need to search and then you need to write so this is Extreme details dot that and here you need to pass a file so I use in iOS out and also iOS binary right so I opened this file in both read and write mode and then in the binary flag right and uh other thing is I need a temporary employee object so that I could just put it in the memory and read the information inside the class right now what I do I just do the same thing as reading a file so after tweet size of OPG now inside this what we're going to do here is first of all I need to search right so this is a searching part so if the ID which I'm searching for well if the object which we read with the ID of that object whether it's equal to the ID which you are searching for or not that's what we need to check and that is searching so if it is equal we perform the operation else we don't we just move on right so let's say it it is equal we got the object what we need to do first of all we need to say that we found the object so it is true and then what we do we just update whatever we want to update so here in this case I'm just updating the address so strc p y string copy obj address and then the new address I just specified so HDD r dot C underscore Str en okay so I'll do that and then where do I have to write this I need to rewrite this right I need to open it so now if I just do dot right so if I just do F dot right so same thing cached all objects size of object I could write a macro for this I'm just writing it again and again right so yeah anyway if I just do that what will happen is let's say I wrote A B C D E I want to change e so first I did a checked a check did it B check B red C check C and I want to change C and now if I try to update see what will happen if I just write I'll just override T that's what is going to happen now that's because I have not gone backwards right so what happens here is that I am just overwritting the next record not the record I'm at so I need to go back that record how do I go back remember the file pointers we talked about in the beginning I have them no I deleted those comments but basically I'll just get and put pointers right so what you do is you take the pointer take the put pointer backwards how much backwards first of all get the position where it is so tell tell the position and go back how much how many bytes should I go back just go back those many bytes which this object occupies the size of obj from here you need to go you need to travel that position from the beginning of the file so that will take care of a moment so what will happen is what you are saying in the saline essentially is let's say I am at I'm at this position I'll just say 10g is something minus the size of object so minus here from where from the beginning so from here I'll just go to this much positions right so that is how this seek P works and you just write off that object and here in the end you can just return that object so return phone so that you know that you have found something or not and when you can also break out of this Loop that's also possible you can do that so first we will just read it right we'll first read the initial data I'll just remove these things read the initial data we have these data we'll just change this address so what I'll do is I'll just say update id2 and then address to let's say baker should be I'm just changing the address over here I'll do that run this and it works successfully well it did not show it over here so I'll just do c out that will also work I will get a one or zero right so here I got one that's because this ID exists if I do something with where this ID does not exist I'll get in 0 and I'll show the message to the user that here the ID you're searching for doesn't exist in my database create a new ID something like that so we updated that now what we are going to do is is read again what do I get see that address has been changed and this is not from the upgrade thing right so it has been changed directly inside the file so that's how you update things inside a binary file so the same way you could also object the whole object right but I did not do that here because I need to create another file and I take time but I'll encourage you to try it on your own so instead of string you just have a whole new employee object and here you just instead of copying that you just create a copy Constructor over here so I think you all know what a copy Constructor is and you just need to find a copy Constructor so that this uh IDs get copied and then you just paste and then you just do the same thing you just go back and then write out the new modified object right so that's about application and now comes the deletion which is little bit different so this is delete and again this also involves searching so let's just say pull delete our deleted keyword we'll just keep it adjusted and then you have a ID now what you are going to do here is we will push uh the the process Remains the Same you first search for the object so these things remain the same you just copy and paste this thing instead of f stream you could just say if stream because it's just going to read it all right and uh here I'm just going to search for that file so the whole thing you will just copy and paste well you don't need the whole thing uh the inside is going to change the the if condition is going to change and then just say return form right now how are they going to delete something well we cannot directly delete from a file just like what we do like let's say I want to delete this I just if I just press backspace this this line goes away but this action cannot be performed using C plus plus binary file objects you don't have a delete method inside the object so how do you delete it well the way you delete it is you don't you just create a copy of this whatever database you have the all the records you just create a copy but you don't include the thing which you want to uh Delete right so I will I'll just explain you it again so if I have a b c d e and let's say I want to delete D it's always deleted I create another file called temp so this is all inside our details.tag file so these are the contents or in temp file I want to delete T so I'll just copy a b c e right so if you see here I skip D because that's the thing I wanted to delete and then now I have successfully deleted now what I'll do is I'll delete this file and rename this as details right so if I do that it will look like I have deleted this thing so that's how you delete files in C plus plus delete records in C plus plus and to do that you need another Library which is standard input output because you are going to work with the standard stuff inside the Hard dish you want to rename remove and all those things so those things are available in the standard input output side right so here what I'm going to do here is I'm going to create a new file which is called ofc and then this is a temporary file and this is just going to be some temp DOT type I'll do the same thing iOS binary and here what I will do is if the ID matches what I'm going to do here is I'll just well if the IDT does not match well if the ID measures we don't have to do anything we'll just skip that but if the ID does not match what we'll do here is um well you don't even need this form you don't have to search for this if you think about it you just we are just trying to delete something which does not exist so basically just skip it if it does not exist you're not going to delete anything so yeah you can skip that this phone can be scared it's not required on this return statement too it's not required now if it is not equal what you're going to do you are just going to see it temp dot right that whole thing so same thing you write that that's it that's how you delete a file now you have written that now whatever what you're going to do is just close those both files attempt to close now you just remove details.tag and then you rename attempt to that to details not that said see how simple it is to delete something it's just a work around you don't have a delete method in binary files and this is how you delete it just create a copy without this uh record which you want to delete and then you just rename it and then so if if let's say I want to delete this first of all read that delete ID number one and then read again do that if I just run this thing uh well everything came at once was because there's no new line but yeah if I just comment these two things out because it's already deleted you don't have that so if I just to read you will be seeing that I just have ID number two I don't have ID number one right so that's how you do the credit operations in C plus plus you have create read update and delete delete is something which is kind of different you just create a new file with all the data except the thing you want to delete and updater you write it you read the object you find the object where you want to cheat and then you update it go back a record and then overrated so that's how operation works and it's the only place where you're going to need to use input and output at the same time right and other things are pretty normal the create and read or something which is uh we already know about and this is how you do the credit operations in C plus plus so that's it in this video and in the next video with move forward and then we'll first talk about uh things like static which will make this uh I will ID independent of you know initialization that means I could if I want to I could just save one one so what we'll do is it will just delete all the ones if this this Loop runs it will just delete all the ones right if I just print id1 so I don't want this to happen I want the ID to be generated on its own so how to do that that will see in the next video and also we'll talk a little bit about the strength because slowly we'll understand how to work with the string class so this is one function you learned today and this is one address pack which you learned today C string which basically contains all the functions we need for string so you have lots of functions in that we have strcpy which is for copy you have this compare so CMP is for compare cmpi is for comparing without the case comparison is it doesn't ignore the case of the strings right and then you have all these um functions so HDR cat is for concatenating Strings basically why we use string classes because we want to directly use uh operator so let's have string A and B I could do something like a equal to B using the shrink class but this is not possible when using something like a primitive data type if I use array or something I cannot do this right I need to compare character by character so these things are the reasons why we use string but when you are dealing with something where you want to write into the files or something like that you do have to use the primitive data right hey guys welcome to programming knowledge in the previous video we saw how to do file operations in binary files using C plus plus you can also call it credit operations so we saw that by taking an example of an employee class right so that class hidden ID attribute which we used to identify each employee uniquely and we were performing our operations on that so the problem is that in that particular program the ID was not being generated automatically it was unique because I kept it unique right when we were writing the program we had to keep it unique so that there were no conflicts in that program but what happens is that generally you don't want to do it on a very large scale because you may forget what was the last ID or you may forget something else right so it's best that these kinds of things be automated and how do we automate that thing well you can use a global variable that's a solution but the best solution is to maintain something known as a static variable and that's what we will be talking about now so with static variable is nothing but that variable gets created and will stay until the program's life cycle ends so what do I mean by that let's say I have a function here so this is some function and I have say three variables inside this and I even have some other variables so let's say t e over here now what happens is that this main function is going to run indefinitely right so I'll be creating these two variables on start of this program and let's say I even have some Global variables so let's see um uh G and H are Global variables right so let's these two are the global variables these three are the uh function variables of this particular function called fuency and this two other variables which are there inside the main function now what happens is that once I run this program first these two variables will be created and then because main will run indefinitely these also be created and since I did not call this function these variables won't be created right so now there's some times we do need variables to be created and stay even after their role ends or let's say you want a variable which acts like a global variable but it is not a global variable because it's not useful anywhere else so uh this kinds of requirements usually addresses when you're using recursive functions so let's say I create a function for calculating uh sum of numbers from 1 to n which calculates it recursively so let's quickly make a definition for that so max um well uh we'll just take the maximum element of an array it's not sum of N numbers let's say the maximum element of an array so you could just say Max element which takes an array and uh it takes an index so that it can recursively do that right recursively calculate the maximum element which is present inside the array so now what happens is that let's say I maintain a variable called Max well Max is a keyword so let's say underscore Max which is basically in the beginning it's in uh Min so if you do intman you're basically getting the least value an integer can hold so sorry minus intman is same as Maxwell by the way solve for confusingly on that but basically in Max and Main are the extremes you can store inside an integer right so now I get this maximum element and now let's say I recursively find out the maximum element inside this array by using this index now what happens is that I don't want to create this maximum element again and again so one solution is to keep the global maximum millimeter I could just do anything Max over here and I could start out with this well I could just start off with this overview so I could just say anything Max and every time this function recurses I can just update this maximum element so that I can get this um maximum element inside this array um well it's not going to be matched technically it's going to be in Min because I'm taking the maximum element if you are taking the minimum element it should have been Max so what anyway um well we are going to just follow this logic but the problem here is that this Max is actually accessible by any function and any class which is inside this program right and we don't want that because we're not going to use maths anywhere else except this function so the solution for such kinds of problem is to use something known as static variables and that's what we're going to discuss today so let me just quickly quickly clean this using namespace standard in me right so the way we use static variables inside functions are like this so you say in maximum element of an array and you pass in an index and then instead of declaring it as end you can say static and Max and that's going to be the minimum value right so now what happens is that if this Max has not been initialized it could be initialized with this ink mail which is the minimum value an integer can hold and then subsequently it won't it will be updated well the same variable will be updated even if it recurs through the function so let's say uh we'll just quickly write this function so what's the base case base case is when index is equal to zero right so when index equal to 0 you just update Max so max becomes um well we can just use a tinary operator here so array of 0 is greater than the current Max then Max become side of 0 else is just this right and then you will just return the maximum and then since this is a base case or else what you do is you just do the same operation with the current index so max equal to the array of uh let's say well I took 0 over here so I'll be starting with the last Index right so index n uh or n minus 1 right the array of index is greater than the max then you just say area index or else and Max and then uh what to do is it recurs through the same function so max element of the same array but index minus one and in the end you just return the maximum area so this function is quite clear as a recursive function the only difference being that instead of declaring this Max as a global variable you have declared it kind of inside the function but the variable will be created in the global score but we cannot access it we can only access it inside this function now if you uh just want to test this out you can just create an ID um you can just call it one two three four five and then um well this is quite obvious let's check what 10 over here and then you could just say Max element of this array and start with index 4 or uh well you can just take take out the size from here but since I mentioned index it's just the last Index right I'm going backwards so if I do this run this particular program I'll be getting a maximum test 10 which is correct one so that's how we uh use static variables the main thing is that we don't want to create it as Global that is because we don't want this variable to be accessed by everything but at the same time it should act like a global it should not change right so if I just remove the static well the result is quite obvious because every time this function recurses you will be creating a new Max right so if I just run this you will see that I have been creating a new Max every time and once I reach Pi Max is basically The Fifth Element that's because this at the last iteration what happens is that I'm just reassigning max to inch main so 5 is basically the maximum element possible right so that is something which we don't want we want to store the maximum uh of the previous array elements also so in that cases you just need to make it a static and use it well static variables inside functions are not really exciting we generally use static in case of classes and that's because we don't have to create an object of a class or we don't have to create an instance of a class to use those static members or member functions so let's quickly see how to do that let's take a case of the employee right so let's put everything as public for now right so now what we're going to do here is I'm going to see static int ID and I cannot actually assign it over here I'll be getting an error so if I if I try to do that so let's see employee a great if I try to run that I'll be getting an error that's because I cannot uh initialize a static member right inside the definition of the class I used to do it outside so how do I do that I just need to do something like int employee ID equal to whatever ID you want to start with so let's say I want to start with one right or you can just start with 0 and in the Constructor you can increment this ID so uh we'll create the ID I will keep the Ida private so that uh we don't get into issues or well it doesn't really matter right you can keep it anywhere so for this demonstration I'll just keep it private because we are just going to have this ID a static and no other members for this example right so you can just play around with this but basically the concept Remains the C it's a global variable but not completely Googled it's just it acts like a global variable but only for that scope right so now you have the static ID well it's static unit ID and then in the public section I'm just going to define a Constructor employee right which will Auto increment this ID so that's what we wanted it we don't want to set the idea again and again so I just say ID plus plus right and I can also keep a public variable which is going to be the ID let ID of this current instance so I could just say int and ID notes the difference between these two things this is basically a global ID which will keep incrementing itself but this is going to be the idea of my employee which is using like basically the particular instance which were targeted so there are just to employee ID equal to the ID which we incremented so that actually solves our problem of having to manually increment this IDs right and we also have in uh initialize the static variable now what I can do is I can just create a b c d and if I do let's say B dot employee ID and uh let's say d dot employee ID now if I run this I get 2 and 4. but I do not assign any employee IDs over there right so basically I auto incremented the IDS now every employee I create will be uniquely identified and if you want to see how many employees I created you could just access this video to it right since this is private I would have kept it public will uh generally we don't keep such things as public we don't want to give it access right so uh well you can just do a small function so get count right and get count is basically going to return you the ID so uh it's going to be white or architis return that so they need to get com which is basically return the ID and I could just say here you get come uh sorry I could just say a DOT get com right and I'll just keep a new line here for separation and if I run this I will be getting two four and four that's basically the four uh employees we created right if I create another one I'll be getting five there so if I just say a b c d e and uh well I need to stop this run it again now here you can see two four and five which is basically the number of Empires but this isn't very intuitive right you're just saying a DOT get coin a DOT get con doesn't mean anything get count is basically for the employee class not for the object not for a particularly right so the way we can do that is we can also make this function as static so how do we do that we just say static create get count and now what you can do here is instead of accessing it to a you can just do employee and then the scope resolution operator and get con now what this means is that how many employee Optics have I created you just get me the count of that and this is more intuitive than actually calling get conflicted right so generally when whenever we want to use static variables or whenever we want to use static variables you generally put it as static functions because they belong to the Flash not the function sorry not the instance right so if you see get com there is actually a function which belongs to employee class not to a or not to P or not to D predictively so now if I run this I'll be getting the same output so 2 4 and number of employees I have created this five and you could use it uh in the other way if you wanted to so I could just see uh let's say B dot get com so this will also work right if you you could access static variables directly but it's this is not generally recommended as as this is not very intuitive right so that's about static variables uh in the next video we'll do something exciting we'll talk about genetics right we'll talk about templates and how we can make generic functions so that we don't have to overwrite them again so if you remember about the vector right so if I do hash include vector and here if I do something like vector and then I need to put int over here so this kind of thing that's basically because I have only one vector class but I can use it for any data type I want so if I wanted for string I could just do string over here so we'll see how to do this thing for our own class and that's all for this video so in the next video we'll see how to do all these things and it's going to be really exciting from now on right so yeah that's all for this video thanks for watching happy coding
