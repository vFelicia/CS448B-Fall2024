With timestamps:

00:00 - in this video we'll be making our second
00:02 - programming project which is going to be
00:03 - this
00:04 - the snake game so i'm sure everybody
00:06 - knows how to play this game you have a
00:08 - snake which grows on eating the food
00:10 - and the objective is to grow the snake
00:12 - as long as possible without hurting
00:14 - yourself or hitting one of them so if
00:16 - you do any of those you lose this game
00:19 - well there are different variations of
00:20 - this game some have teleportable walls
00:22 - that is
00:23 - if you go through this wall you end up
00:25 - coming from there
00:26 - and some versions even have obstacles in
00:29 - between them
00:30 - instead of this free space but we're not
00:32 - going to do any of those we are just
00:34 - going to stick to the simple version
00:35 - with four concrete walls
00:37 - and uh empty space in between right
00:40 - so let's get started let's create a new
00:43 - project it's going to be a console
00:44 - application
00:46 - and the language is c plus plus project
00:50 - title let's say snake
00:52 - and these things remain as it is right
00:55 - and now let's first start by defining
00:59 - the board
01:01 - so if you remember from our previous
01:03 - project where we made our detector game
01:05 - we had defined a 2d array or a matrix to
01:08 - hold the board right
01:09 - but here if you see you don't need that
01:12 - why
01:13 - well in the previous game where we made
01:15 - a tic-tac-toe game the board only had
01:17 - nine elements
01:18 - and we were concerned about all the nine
01:21 - elements of the board right so we were
01:23 - concerned about what all the board
01:25 - contained
01:26 - but here you don't have to actually be
01:29 - concerned about all the elements of the
01:31 - board
01:32 - here the board just acts as a background
01:34 - the only things you are concerned about
01:36 - are the position of the snake the
01:38 - position of the fruit
01:40 - and the position of the wall so other
01:43 - than that you don't need to
01:44 - keep track of other things so here we
01:47 - are just going to print the board just
01:49 - like
01:50 - we print something on the console so
01:52 - let's define a function for that
01:55 - let's say void board
01:58 - and here we are going to draw the board
02:00 - so uh let's first define the dimensions
02:03 - of the board the width and height
02:04 - so let's say uh the width is going to be
02:07 - somewhere around
02:08 - 50 characters so since we are working on
02:11 - the console you are going to see
02:12 - everything in terms of
02:13 - characters or this is basically a
02:16 - substitute for pixels if you are
02:17 - familiar with graphics
02:19 - and the height is going to be somewhere
02:22 - around let's say 25 characters
02:25 - now these two things are constant right
02:28 - so the these won't change throughout the
02:30 - project
02:30 - so if you want to make them as constant
02:32 - so you can just say
02:33 - const over here so this keyword will
02:36 - make these things as constant
02:38 - and now i would like to introduce you
02:41 - the concepts of
02:42 - macros so macros let me write it down
02:46 - here
02:46 - macros these are nothing but one-liner
02:49 - code
02:50 - right so let's say you want to define
02:53 - a function to calculate the square so
02:55 - what you do typically is you write
02:57 - something like this right so in
02:59 - skew and this will return x into x right
03:03 - so
03:03 - this is how you define a small function
03:06 - but what you can do is instead of
03:08 - defining it as a function you can define
03:11 - it
03:11 - as a symbol so when i pin symbol
03:15 - what i mean is if i type that particular
03:17 - symbol then this operation should be
03:19 - performed so that is what a macro does
03:21 - so
03:21 - the way you define macro is you put hash
03:24 - define
03:25 - and then you put the symbol so let's say
03:27 - sq over here and inside this whatever
03:29 - parameters you want to pass without any
03:31 - data type so this is basically a symbol
03:34 - and here you want to uh define the
03:37 - operations
03:38 - so here our operation is x into x so
03:41 - that is basically going to return as the
03:43 - square of a number
03:44 - so here you don't have any assignment
03:48 - operators or written operators
03:49 - all this means is whenever i say sq of x
03:53 - it should do this particular operation
03:55 - so if you say something like
03:57 - sq of 5 and here
04:00 - if you run this you should be getting
04:02 - the output as 25
04:04 - so that's how you use macros and you can
04:06 - do the same with
04:08 - these two variables also so the way you
04:10 - define it as
04:11 - hash defined width is 50
04:15 - and hash define
04:19 - height 25 so
04:22 - now whenever i save width i mean 50 and
04:25 - whenever i say height
04:26 - i mean 25 so now you can remove this you
04:29 - don't need this anymore
04:30 - so now the board is going to be two
04:32 - loops the first
04:34 - loop or the outer loop is going to
04:36 - control the number of rows
04:37 - so here the number of rows is defined by
04:39 - height right because height is basically
04:41 - how down you go
04:42 - so that is how many rows you have in
04:45 - your board
04:46 - so i is less than the height of the
04:48 - board
04:49 - and i plus plus and inside this you will
04:51 - control the width so
04:53 - enter in let's say j
04:59 - and inside this you are going to print
05:01 - something so here if you observe this
05:03 - board
05:04 - for every row there are two wall pieces
05:06 - right so every row starts with one wall
05:09 - and then ends with
05:10 - one bolt so since that default you can
05:12 - subtract two here and then put those two
05:14 - characters so you have one ball
05:16 - in the beginning of a row and
05:20 - one wall at the end of the row
05:23 - and then you go to the new line
05:26 - and inside this basically if the
05:29 - row number is 1 or the row number
05:33 - is height minus 1 that is
05:36 - if you are printing this row or this row
05:40 - then you need to print all walls so here
05:42 - we are just going to print out
05:44 - these hashes or else
05:48 - you need to print out the empty space
05:50 - which is basically this
05:51 - space right so now if you call
05:54 - your board function that should print a
05:57 - board for us
05:59 - so here we have the bowl
06:02 - now this board looks pretty squished to
06:05 - the left so
06:06 - you can take care of that by adding a
06:08 - couple of tabs
06:10 - and that will center the board
06:14 - so now let's see how to animate things
06:18 - on the console
06:19 - so if you are familiar with graphics or
06:22 - even if you have heard about animation
06:24 - you might know that animation is nothing
06:26 - but just
06:27 - fast moving pictures right so here if
06:30 - you want to animate something on the
06:31 - board
06:32 - let's say you have some object on the
06:34 - board
06:35 - then the video animators you will
06:37 - quickly move the position of that object
06:39 - and it will appear as moving
06:41 - so to move something on the board or to
06:44 - place something on the board you need to
06:46 - know about the coordinate system which
06:47 - the computer uses
06:49 - so let's talk about that quickly so you
06:51 - might have come across this cartesian
06:53 - coordinate system in your math class
06:54 - right so you have
06:56 - a coordinate system where if you go
06:59 - right the x
07:00 - coordinate increases and if you go
07:02 - vertically upwards
07:03 - your y coordinate increases and this
07:06 - will
07:07 - position basically which is the
07:09 - intersection of these two
07:11 - axis this is the origin which is defined
07:14 - by this
07:14 - zero zero coordinate right so this is
07:17 - the coordinate system you all have come
07:19 - across in your math class
07:21 - now what happens in a computer is this
07:24 - origin is shifted to this top left
07:26 - corner so let me just clear this thing
07:31 - so in a computer your access are defined
07:33 - as follows so
07:35 - if this is the top left corner of the
07:37 - screen that is
07:38 - this position where i'm pointing my
07:40 - cursor that position
07:42 - is basically your zero zero position so
07:44 - this is your origin in a computer
07:47 - and as you go right your x coordinate
07:50 - increases
07:51 - and as you go down your y coordinate
07:54 - increases
07:55 - so basically your y is flipped in case
07:58 - of a computer and
07:59 - x remains the same so as you go up
08:03 - your y is decreasing
08:07 - and as you go left your x-coordinate
08:10 - decreases
08:11 - so that's how the coordinate system in a
08:13 - computer is defined
08:14 - you can use this coordinate system to
08:16 - move objects in your
08:18 - screen or even place objects in your
08:20 - screen so
08:21 - every object is defined by x coordinate
08:24 - and y coordinate so if you
08:26 - put some point here so it has some
08:29 - x coordinate that is how much it has
08:31 - moved from the origin in the horizontal
08:34 - direction
08:35 - and some y coordinate that is how much
08:37 - it has moved from the vertical direction
08:39 - right so this is how the coordinate
08:41 - system of the computer is defined and we
08:43 - will be using this system
08:44 - to operate on our board right so
08:47 - let's define an arbitrary object
08:50 - somewhere so let's say
08:52 - our int x which is the x coordinate is
08:55 - going to be somewhere around 10
08:57 - characters
08:58 - and y is also 10 so that means that this
09:01 - is
09:01 - 10 characters from the left and then 10
09:04 - characters down
09:05 - so it it will be in some arbitrary
09:07 - position somewhere let
09:08 - let's just see where it is so if i here
09:11 - if i
09:12 - print that particular object that is
09:14 - pretty simple to print so if the
09:16 - coordinates match you are going to print
09:17 - that object
09:18 - so how do you do that well i is
09:20 - controlling the height right so height
09:22 - defines how
09:23 - deep you are on the board so that is
09:25 - basically the y axis so you need to
09:27 - compare i
09:27 - with y and j with x so
09:31 - if you if these two coordinates are
09:33 - equal then
09:34 - you can say that your object is at that
09:36 - particular position and you can print
09:38 - something so let's
09:39 - go with this zero for now so that is
09:42 - going to be our object
09:44 - now if i try to print this board you
09:46 - will be getting your object here so
09:49 - and this is 10 characters from the left
09:51 - and 10 characters towards
09:52 - the bottom but if you see this position
09:55 - is exactly
09:55 - not as square as expected uh that is
09:58 - because in console the
10:01 - next line has some gap if you see over
10:04 - here so
10:04 - this gap is much bigger than this gap
10:07 - that is why
10:08 - it doesn't end up as a square but if
10:11 - you're using some graphics library
10:13 - then this will work so it will exactly
10:16 - be as a square so
10:18 - it will end up somewhere over here so
10:19 - this could be the 10 comma 10 point
10:22 - but here since we are working on the
10:24 - console uh
10:25 - the y-axis is much wider or i should say
10:29 - much
10:29 - deeper than the x-axis so uh even when
10:33 - you animate your snake
10:34 - it's going to move faster on the
10:36 - vertical direction than on the
10:37 - horizontal direction
10:38 - that's actually not a logical error
10:40 - that's because of the property of
10:42 - console you cannot do anything about
10:43 - that right
10:44 - so if you're using any graphics library
10:47 - then
10:47 - that problem won't be there so now let's
10:50 - see how to animate this
10:51 - animating is very easy you just need to
10:53 - move the board right
10:55 - so uh let's say i will create an
10:58 - infinite loop here
11:00 - and inside this we will first call the
11:02 - board and every time
11:04 - this loop runs we will just increment
11:06 - the x coordinate so
11:07 - when you increase the x coordinate from
11:09 - this coordinate system your object is
11:11 - going to move towards the right right so
11:14 - now if you run this program you should
11:15 - be getting some kind of movement
11:17 - so here you can see that this o is
11:19 - moving towards the right but
11:20 - uh you cannot actually see it as a
11:22 - movement this is basically it
11:24 - is just printing the board again and
11:25 - again so if you have some way
11:29 - to update the board then you can see the
11:32 - movement
11:33 - so one way you can update us you can use
11:35 - your console command so if i pull up my
11:37 - console over here this is basically a
11:39 - powershell
11:40 - but in windows or if you're using this
11:44 - code blocks in windows it's going to
11:46 - use the use your cmd as your default
11:49 - console right
11:50 - so in cmd the command for clearing the
11:53 - screen
11:54 - is cls so if i type something over here
11:56 - under type cls
11:57 - that thing is cleared right
12:00 - and if i were linux the command for
12:03 - clearing the cler
12:04 - and the way you pass in such shell
12:07 - commands or such console commands are
12:09 - you include another library called
12:14 - cstdlib which stands for c standard
12:16 - library you might have come across this
12:18 - while making a tic-tac-toe game this is
12:21 - the library which had our random
12:22 - function
12:23 - and we will be using that random
12:25 - function in our code as well
12:26 - right so here to send commands to the
12:30 - console you use
12:32 - system and inside this you write the
12:34 - command so
12:35 - in in my case it is the windows
12:37 - operating system so i write cls
12:39 - and in case you're on linux you need to
12:41 - write clear
12:42 - right so let me just comment distance if
12:44 - you're on linux you need to write clear
12:46 - and i forgot the semicolon and now if i
12:50 - run this
12:51 - i should be getting a movement but if
12:53 - you see here
12:54 - it kind of flickers on my screen right
12:56 - so this
12:57 - board is up getting updated but it is
13:00 - annoying to see so uh this you
13:04 - cannot actually control so more
13:06 - technically
13:07 - if you know about the fps or the refresh
13:10 - rate
13:11 - so you cannot control these things of a
13:14 - console console is not a property of the
13:16 - language or just
13:17 - id right it is a property of the
13:20 - operating system so you cannot control
13:24 - something
13:24 - from an external source which belongs to
13:28 - the operating system
13:29 - so one way you can take care of this
13:31 - flickering
13:32 - is instead of clearing the screen this
13:35 - is happening because
13:36 - it is doing two processes right first it
13:38 - is clearing the screen and then again it
13:40 - is drawing the board
13:41 - so if you just overwrite the board as we
13:44 - used to do
13:44 - with our normal line so if you remember
13:47 - from our escape sequences video
13:49 - we had talked about an escape sequence
13:51 - called slash
13:52 - r right so if you write something over
13:54 - here let's say
13:56 - hello world and um here if i put slash
14:01 - r and i type something else so as is
14:05 - then the first four characters which are
14:07 - these four characters are going to be
14:09 - replaced by the word asas
14:11 - so now if i run this i should be saying
14:13 - iso over
14:15 - so that is because he ll has been
14:17 - replaced by this
14:18 - that is because this slash r will take
14:21 - the
14:22 - cursor from the end of the line and
14:24 - place it in the beginning
14:25 - but we cannot use the slash r over here
14:28 - that is because we are using multiple
14:30 - lines right so
14:31 - you are printing around let's say 25
14:33 - lines because the height is 25 so you're
14:35 - printing 25 lines
14:37 - and there is no escape sequence to get
14:39 - your cursor back a line so
14:41 - slash n will move your cursor down a
14:44 - line but you cannot go up a line
14:46 - right so for that i'm going to
14:49 - tell you a solution but this is going to
14:51 - work only if you're on windows so let me
14:53 - write it down here
14:54 - this is only for windows and for linux
14:57 - you need to find out a library which
14:59 - tested
15:00 - so basically what we are going to do is
15:03 - we are going to pick up this cursor
15:05 - from the end of the screen and we are
15:07 - going to go all the way
15:09 - up to the origin and place it back so if
15:11 - you do that instead of clearing the
15:13 - screen you are moving the cursor and
15:15 - when you print your data again
15:17 - it's going to be overwritten on the
15:18 - console so it looks like
15:20 - it has been cleared but actually it has
15:23 - been overwritten instead of clearing
15:25 - so this solution what i am going to give
15:28 - you in this particular video will work
15:30 - only if you are on windows so if you are
15:31 - on linux you need to find out some
15:33 - library which will do that for you
15:35 - right so if you are on windows you need
15:36 - to include a library called windows
15:38 - starter which will basically allow you
15:40 - to control the cursor's position on your
15:43 - console
15:44 - and here what you need to do is instead
15:46 - of system clear
15:49 - you can do set
15:52 - console cursor position
15:55 - and here you need to give some handle
15:57 - which is
15:58 - get htd handle inserted
16:02 - std output handle so if you don't
16:05 - understand what this means it's okay
16:08 - it's just you can think of it as it's
16:10 - going to pick up the cursor from the end
16:12 - and it's going to put it back on the
16:14 - origin
16:14 - and to put it back on the origin or any
16:17 - specific coordinate you need to
16:19 - pass in a coordinate data structure
16:22 - well coordinate is basically a simple
16:24 - data structure which is already defined
16:26 - in windows.h and we'll be using this so
16:28 - if you're on linux and you're using some
16:30 - other library to achieve this you need
16:31 - to define this
16:33 - uh structure to follow along with this
16:35 - tutorial which is basically a simple
16:36 - structure
16:37 - it is something like in x and
16:41 - y so this is the structure which is
16:44 - defined in windows so i'm not going to
16:45 - define this again
16:46 - it's there in this windows.h and that's
16:49 - what we are using over here to
16:51 - send the position to our handle
16:55 - which will basically take the cursor
16:58 - from this position and then put it back
16:59 - to the origin
17:00 - so the origins coordinate are basically
17:02 - 0 zero so you need to pass that
17:04 - in and now if you see you won't have any
17:08 - flickering screen you will have a
17:09 - neat animation going on on your screen
17:12 - so as you can see there is no flickering
17:14 - although you can see that
17:15 - cursor update somewhere but this is much
17:17 - better right
17:18 - instead of the flickering screen so
17:20 - again this
17:21 - solution is only for windows users so if
17:23 - you're in linux you have some
17:25 - other libraries like you have n cursors
17:29 - and
17:29 - many other libraries simple google
17:31 - search will get you what you want
17:33 - right now uh let us remove all these
17:36 - things
17:37 - we have now understood how to do
17:38 - animation and here
17:41 - what we are going to do is we are first
17:43 - going to define our snake
17:45 - so go to file new and clash
17:51 - and the name of the class is snake and
17:54 - you can remove all these things right it
17:56 - doesn't really matter
17:57 - you don't need destructor on all these
18:00 - things we'll create
18:01 - if we want to right and here just click
18:05 - ok and in snake dot h
18:08 - we have this template code so again i
18:11 - prefer
18:12 - private to be on the top so if you want
18:15 - that you can follow this
18:16 - or if you if you're okay with the
18:18 - structure it has given
18:20 - before you can follow that it doesn't
18:22 - really matter
18:24 - and here first of all we are going to
18:26 - decide what is going to be private and
18:28 - what is going to be public
18:29 - so what are the features that we need
18:32 - our snake to have
18:33 - first of all it will have a position
18:35 - right the position of the head to be
18:36 - places
18:37 - and next it should have a length
18:41 - to define how long the snake is and
18:44 - you also need a direction and
18:47 - you also need a velocity or you can say
18:50 - speed of the snake so how fast it goes
18:52 - so here in case of velocity or speed we
18:54 - are going to talk
18:56 - in terms of number of characters so let
18:59 - me write it down here
19:00 - that is basically it is going to move
19:02 - two characters at a time three
19:03 - characters at a time and so on
19:05 - so in case you are working with some
19:06 - graphics library that
19:08 - the same thing you do with pixels so you
19:10 - say three pixels at the time or five
19:12 - pixels at a time
19:13 - and since here we are on console we are
19:15 - going to
19:16 - talk everything in terms of number of
19:18 - characters
19:19 - right so uh here let me define the
19:22 - private variables first in this you are
19:24 - having
19:24 - to have a position so it's going to be
19:27 - quad position so again
19:28 - if you are in linux you need to define
19:30 - the structure and uh
19:32 - for using the squad you need to include
19:34 - windows started
19:35 - right so this is because this is a
19:37 - separate file that snake.h is a separate
19:40 - file so even if you are
19:41 - included in main you need to include it
19:44 - again but you can
19:45 - exclude this over here because once we
19:48 - actually include this file you are going
19:50 - to include all these things it doesn't
19:52 - matter even if you keep it
19:54 - twice because of this guard block as i
19:55 - had explained before
19:57 - this guard block what it does is it
19:59 - takes care of
20:00 - multiple initialization so here i have
20:02 - already included windows.h
20:04 - now i when i do hash include snake dot h
20:08 - it will take care of the fact that i
20:10 - have already included windows started so
20:12 - i don't need to include it again
20:13 - but here if you want to use these things
20:16 - you need to definitely specify that you
20:18 - are using windows. or else you cannot
20:20 - use this and will throw you an
20:21 - error right and here you need
20:25 - a length of the snake and you have a
20:28 - velocity so
20:29 - in well and you have a direction so
20:31 - let's say card direction
20:34 - and in the public section we need to
20:36 - define constructor first and this
20:38 - is going to take a position that is the
20:40 - initial position
20:42 - and uh initial velocity for our snake so
20:45 - let's define this constructor and
20:47 - dot cpp and um here
20:50 - we talk and specify those things so
20:53 - called
20:54 - position and velocity and here you don't
20:57 - have to include windows attached that is
20:59 - because again you are including snake
21:01 - dot h which
21:02 - comes with windows started so you don't
21:04 - have to include it again
21:05 - and uh here you need to set the position
21:09 - and velocity so
21:10 - since i'm using the same name for both
21:12 - the variables
21:13 - i need to use this pointer so if you are
21:16 - not using the same name it's okay
21:18 - but if you are using the same name you
21:20 - need to use this pointer and
21:22 - the velocity also goes the same way
21:26 - and initially the length is going to be
21:29 - one
21:29 - that is because you have one head right
21:32 - so
21:32 - without the length cannot be zero
21:34 - because you always have a head
21:36 - for the snake so the length is going to
21:40 - be
21:40 - one initially and the direction
21:44 - so the direction you can say uh
21:47 - something like
21:48 - none right because the snake is not
21:50 - moving now
21:51 - and um we'll have a method to
21:54 - change the direction of the snake so
21:56 - let's say on
21:58 - change dir which will change the
22:00 - direction it will take some
22:01 - direction to change and here
22:05 - let's define that method it's void snake
22:09 - change dir
22:13 - and what you need to do is direction
22:15 - equal to there
22:16 - basically i'm just setting the direction
22:18 - of a snake and um
22:21 - for moving the snake let's create a move
22:24 - method
22:25 - or move snake well move is basically a
22:28 - defined method in c
22:29 - so it's not preferable to overwrite it
22:32 - you can overwrite it you can define
22:34 - something like this but
22:35 - it's preferable not to overwrite any
22:39 - default method so let's say move snake
22:42 - and this is not going to take any
22:43 - parameter
22:44 - because it's just going to perform
22:45 - something so void does
22:47 - make more snake and here what you need
22:51 - to do is you need to switch
22:53 - the direction that is basically you need
22:55 - to move the snake in that particular
22:56 - direction
22:57 - so switch direction and here you need to
23:00 - put different cases so
23:02 - in case it is going up then what you
23:05 - need to do refer to this coordinate
23:06 - system
23:07 - you need to decrease the y coordinate so
23:10 - what we're going to do is
23:11 - cos dot capital y minus
23:14 - equal to the speed so basically if i say
23:17 - that my snake is moving two characters
23:19 - per second or two characters per
23:21 - iteration then
23:23 - i need to subtract those many characters
23:24 - right to move to appear to be moving in
23:27 - that
23:27 - much speed so that is why we are going
23:29 - to subtract the velocity over here or
23:31 - speed you can name it whatever you want
23:34 - and here the break is mandatory
23:37 - and this will be true for all the four
23:40 - directions so let me just copy it down
23:42 - four times and uh
23:43 - it's going to up down left and right
23:46 - right is you need to increase your
23:48 - velocity left test you need to decrease
23:51 - your velocity
23:53 - and um for down you need to increase
23:55 - your velocity on the y
23:57 - coordinate so this will move your snake
23:59 - in your preferred direction
24:00 - and that should be it so now you have a
24:03 - snake you have initialized it with some
24:06 - initial position and velocity and you
24:09 - have a method to change the direction of
24:11 - a snake
24:11 - and now you even have a method to move
24:14 - the snake
24:15 - and here since we need the position of
24:18 - the snake to
24:19 - draw it on the board you also need
24:22 - a method to get the position so let's
24:25 - say
24:26 - uh get
24:29 - pause which will return the position of
24:30 - the snake
24:32 - and uh this is going to be return
24:36 - first and uh i forgot to mention slate
24:39 - here this
24:39 - will be declared as normal function if i
24:42 - forgot to
24:43 - mention this this basically means that
24:45 - uh
24:46 - this get pass function is related only
24:48 - to the snake class right
24:50 - i'm sure everybody knows this and uh
24:52 - here
24:54 - we'll quickly define a prototype for
24:55 - that let's quad
24:57 - uh get pause and done
25:01 - so now you have four methods let's go
25:04 - very quickly one is a constructor which
25:06 - will initialize our variables
25:08 - one is a method to change our direction
25:11 - so change
25:15 - direction of the snake and one
25:18 - is to move the snake
25:21 - in that particular direction and one
25:25 - is to get the position of the snake
25:28 - or i should say get the current position
25:31 - so now let's
25:32 - use this thing in our main file so you
25:35 - here as i told you you can remove this
25:37 - windows storage because it is going to
25:39 - be included with snake dot h
25:41 - and uh here let us first create a snake
25:43 - so snake s
25:44 - and let's sneak and inside this let's
25:47 - see
25:49 - it's going to be initially in the middle
25:52 - of the board
25:52 - so that's basically 50 by 2 and 25 by 2
25:55 - or
25:56 - you can say bit by 2 and height by 2
25:57 - that makes more sense right
25:59 - so width over 2 and height over 2 that
26:02 - is basically the center of the board
26:04 - and velocity let's say it's going to be
26:06 - 1 that is one character
26:08 - at a time and here you instead of y
26:12 - and x you need to capture the position
26:15 - of the snake so
26:15 - called the snake boss you can see equal
26:19 - to
26:19 - um snake dot get position
26:24 - and here instead of why you need to say
26:27 - snake
26:28 - pause dot y and instead of j
26:31 - you need to say snake poss dot
26:34 - x so so far so good we have created a
26:38 - snake which
26:39 - is going to be on the middle of the
26:40 - board and which is going to
26:42 - move at a speed of one character at a
26:44 - time
26:45 - and here um let us just clear all these
26:48 - comments
26:49 - and now let's see how to get input so
26:53 - that
26:54 - we can control the snake so you need to
26:56 - move the snake only when you press
26:57 - something right
26:58 - so here how do you capture that
27:00 - keystrokes well you have a library to do
27:03 - that
27:03 - so that is called corneo or i should say
27:06 - console input output
27:08 - and here you can just do the following
27:11 - so if you say
27:12 - if kb hid so kb hit stands for keyboard
27:15 - hit so
27:16 - it will be true if you hit a key on your
27:18 - keyboard
27:19 - not necessarily enter key you can hit
27:21 - any key on your keyboard and this is
27:23 - going to evaluate to true
27:24 - and to capture your key you need to say
27:27 - gets yet so
27:28 - get ch will basically give you the key
27:30 - which you
27:32 - just pressed so uh we will capture this
27:35 - and instead of capturing this we can
27:36 - switch this so that
27:38 - we don't have to write a couple of if
27:40 - statements we can just say switch
27:42 - get ch which will basically give us the
27:45 - key
27:46 - and here you can control it so let's say
27:48 - up
27:50 - so i'm not going to do it for the arrow
27:53 - keys because i don't
27:54 - really remember the ascii values of the
27:56 - arrow keys so if you want
27:58 - arrow keys you need to give the ascii
27:59 - value so let's say 132 is the ascii
28:02 - value of upper key it is not the case
28:03 - i'm just saying
28:05 - but if 132 is the ascii value for the up
28:08 - key then you need to give something like
28:09 - this but uh i'm just going to go with
28:12 - wsd for now
28:13 - so case w then um what you need to do
28:16 - you need to move the snake
28:17 - upwards right so snake dog change their
28:21 - double up sorry u
28:24 - and then break and you need to do this
28:27 - for
28:27 - all the four directions so control c v b
28:30 - w a s d and uh
28:35 - d is basically go to right s is
28:38 - down and this is left for now
28:42 - this will more snake in our preferred
28:44 - direction and to move the snake you just
28:46 - call snake dot move
28:47 - snake which will move a snake and now if
28:50 - you run this you will be getting
28:52 - a snake which can move on your command
28:55 - so now you can see that it is not moving
28:58 - because initially we had set
29:00 - the snake's direction to be n right so
29:02 - we did not
29:03 - have any case which will uh move the
29:06 - position for
29:07 - n so it doesn't move for any iteration
29:10 - and now once i press w you can see that
29:12 - it started moving up
29:14 - a it started moving left yes it started
29:16 - moving down
29:17 - and d it started moving to the right so
29:20 - now i can control this little character
29:22 - and
29:23 - keeps moving right so that is how the
29:25 - snake game is different
29:26 - so once you press a key it will keep
29:28 - moving in that particular direction
29:30 - until you change the direction
29:31 - so this is what we needed and we got a
29:34 - moving
29:35 - character on our board so now let's see
29:39 - how to first uh generate the food and
29:42 - calculate the points and then we will
29:44 - talk about how to increase the
29:45 - snakes length once it eats the food
29:47 - right so
29:49 - now let us just close this and talk
29:51 - about the food so again you need to
29:53 - create another
29:55 - class for generating the food so it's
29:57 - going to be
29:59 - it's a food and again you don't need the
30:03 - getter center
30:04 - or the destructor created yes
30:09 - okay and uh here you have food dot h
30:13 - and again i don't need these things so
30:16 - here in the private section what we're
30:18 - going to do is we are going to have a
30:20 - position of the full
30:22 - right so that is mandatory you you
30:24 - cannot have any object without a
30:25 - position right
30:26 - so for the position you again need to
30:28 - include windows
30:30 - windows.h and uh
30:33 - it's going to be called pause and uh you
30:36 - do need a velocity well you don't need
30:38 - anything else you don't need velocity
30:40 - you don't need any
30:41 - uh direction for that foot it's just
30:43 - going to be a point
30:45 - where if you go over to that point and
30:47 - then eat that fool you're just going to
30:49 - generate another form
30:50 - so basically you don't need anything
30:52 - else and uh
30:54 - in the public section the public section
30:57 - we have a constructor basically
30:59 - well you don't have to pass anything to
31:01 - the constructor it's basically going to
31:03 - initialize this position with some
31:05 - random value but
31:06 - if you see this game always this would
31:09 - start at this possible position
31:11 - if you want something like that then you
31:14 - need to define
31:16 - a initial starting position so as we did
31:19 - for our snakes you need to do something
31:21 - like this but we are going to
31:23 - go with random initialization right from
31:25 - beginning itself
31:26 - so again for random function to work you
31:29 - need to
31:30 - include cstdlib and
31:34 - we are going to define a function called
31:36 - gen
31:37 - this is basically going to generate
31:39 - output and this is going to be void
31:42 - and we also need a function to return a
31:46 - supposition so it's going to be get
31:49 - so this will return our position so
31:51 - let's define these functions
31:53 - uh inside this what we're going to do is
31:56 - just generate food it first time it's
31:59 - just going to
32:00 - generate the food once you create it and
32:03 - uh for generating the food
32:05 - sorry snake sorry food
32:10 - gentle and what this is going to do is
32:14 - it's just going to generate two
32:16 - different
32:17 - random numbers in the in some range so
32:19 - if you remember the
32:21 - formula for generating a random numbers
32:23 - in the ring that is u2l
32:25 - it was basically rand mod
32:29 - u minus l plus 1
32:32 - u minus l plus 1 plus l
32:36 - so this was the formula for generating a
32:38 - random number in a range
32:39 - so here our upper limit is going to be
32:42 - for the x axis is going to be width
32:44 - and the lower limit is zero right so uh
32:48 - here you just need to say rand
32:51 - mod and then u minus l plus one plus l
32:54 - so
32:55 - for us the u is basically with
32:59 - minus the lower limit now lower limit if
33:01 - you keep zero then the food
33:03 - will have a chance of getting generated
33:06 - on the walls of support
33:08 - so you don't want that to happen so it's
33:09 - going to be one and plus one so these
33:12 - two cancel out so you just need to say
33:13 - random
33:14 - width and then plus l which is one
33:19 - again for uh the y
33:22 - axis the upper limit is going to be
33:25 - height and the lower limit is again
33:27 - going to be one
33:28 - so this will generate a random position
33:31 - for our food
33:32 - which will be on the board
33:36 - and for getting position it's very
33:38 - simple you just need to say
33:40 - for the word
33:44 - get position so we did not define that
33:48 - well we did quad get position and here
33:50 - you
33:51 - need to say return pause so this will
33:54 - return the
33:54 - position of the current flow and
33:58 - that's it for food so you need to
34:00 - include that also over here
34:02 - um now main file so here we need to say
34:06 - hash include food dot h
34:09 - and here we don't need cst database
34:12 - again because
34:13 - we have defined it inside this food dot
34:16 - it so that gets included automatically
34:19 - and here we need to create a food object
34:23 - so
34:24 - below the snake let's create a food so
34:27 - it's going to be good
34:28 - and as a constructor doesn't need
34:31 - anything so you can just put it like
34:33 - this
34:34 - and here we need to
34:37 - check whether the snake has eaten the
34:39 - food or not so
34:40 - for that what you can do is you can have
34:43 - a
34:43 - function inside the snake which will
34:46 - check whether
34:47 - its coordinates have matched the
34:49 - coordinates of food or not
34:50 - so what you can do is you can inside the
34:53 - snake dot h you can define another
34:55 - function
34:56 - called boolean let's say
35:00 - eaton this will basically say whether
35:03 - the food has been eaten by the snake or
35:05 - not so you can just pass in some
35:06 - coordinates
35:07 - inside this that is the coordinates of
35:09 - the food so coordinate food
35:12 - it's a food pass and we'll define it
35:16 - inside snake dot cpp it's basically
35:19 - um snake
35:22 - eaten and this will return true
35:27 - if the coordinates match so if i say uh
35:30 - if
35:31 - put password i did not capture it over
35:33 - here so it's
35:35 - called put pause and if
35:38 - put pause dot x is equal to pause dot x
35:42 - and uh put pause dot y
35:45 - is equal to positive y that is basically
35:48 - if
35:48 - the position of the head and position of
35:51 - the
35:52 - food are equal then it means that the
35:54 - food has been eaten by the snake so then
35:56 - you need to return
35:57 - to else you just return false so this
36:01 - means that
36:01 - uh if you eat the food it will return
36:03 - true and if it didn't eat
36:06 - return false and in main you can use
36:09 - that over here so if you can say snake
36:11 - dot eaten
36:13 - and you can get the foods equations of
36:15 - food dot
36:16 - um get pause and this will
36:20 - give you the position of the food which
36:22 - you can pass into the snake
36:24 - and if the snake has eaten then you need
36:27 - to generate another force so you can say
36:28 - full
36:29 - dot gen food and
36:32 - you also need to increase the length so
36:34 - you you can say snake dot length
36:36 - well length is a private variable so
36:37 - let's say snake dot grow and we will
36:40 - define a function
36:41 - to grow the snake so you can see void
36:45 - grow and we define it
36:48 - as a void
36:55 - bro which is landlessness
36:58 - and this should grow our snake and that
37:01 - should be it so now
37:02 - you have the logic for eating a food
37:05 - and then growing the snake well we are
37:07 - not going to see the snake grow but
37:10 - it is just going to grow in numbers we
37:12 - won't be seeing that visually
37:14 - we will see how to deal with showing
37:17 - that
37:18 - visually right and here we forgot to
37:21 - draw the food so here you need to
37:23 - put that else if our i is equal to food
37:28 - cos dot y and
37:31 - uh j is equal to
37:34 - food pause dot x well i did not capture
37:37 - that
37:38 - so quad foot
37:41 - cos equal to four dot
37:44 - get pass then
37:47 - for for the let's say the star
37:51 - right the star works well
37:54 - now if you run this
37:57 - um we have an error what does it say it
37:59 - says that
38:01 - width and height were not declared in
38:03 - the scope now that is because in
38:06 - food.hedge we did not define the width
38:09 - and height right we had defined it in
38:10 - the main.cpp
38:12 - so you need to copy these two lines here
38:14 - so ctrl
38:15 - c and put it inside food.h that is
38:18 - because we are using those two right
38:20 - we're not
38:20 - uh we did not define it in food dot x
38:23 - that is why it was give me an error
38:25 - and now if you run this you have another
38:28 - it says has no member y that is because
38:32 - this is
38:32 - a capital y and um
38:36 - here you have the snake and the food so
38:39 - here you can see the food so if i eat
38:41 - that food
38:42 - it's going to generate another food in
38:44 - some random position so you can see that
38:46 - generated over there
38:47 - and here we did not write the
38:51 - logic for collision so we'll take care
38:53 - of that afterwards
38:55 - well it's going to be in the same places
38:57 - that is because we did not
38:59 - see the random function so if you uh
39:01 - have seen the
39:02 - previous video where we made the
39:04 - tic-tac-toe game you know what is
39:05 - serious
39:06 - well to see the random function what we
39:09 - are going to do here is
39:11 - we are just going to say the main
39:13 - function so to see
39:14 - the random function what we are going to
39:16 - do is hash include
39:17 - c time and here in the main function we
39:22 - will see
39:22 - is time
39:27 - right so now when you run it you will
39:29 - have a snake
39:30 - and food and uh this food will be
39:33 - generated once you eat it so here
39:35 - i ate that food now you can see that
39:37 - another one has been generated and then
39:39 - another one has been generated
39:41 - so we did not write the collision logic
39:43 - so if you go through the wall you will
39:45 - come
39:45 - you won't come back and that will take
39:48 - care now so
39:49 - to do that what we are going to do is we
39:51 - are going to write another function
39:54 - so its going to save cool collided
39:58 - and it's property of the snake so snake
40:00 - collided
40:02 - and then this is going to just return to
40:05 - our fall so this is going to return true
40:07 - if our position of x is
40:11 - less than let's say one that is because
40:14 - at the zeroth position you have the wall
40:16 - right so if it is
40:17 - less than one you mean it means that you
40:20 - cross
40:21 - the position of one and you cross the
40:24 - wall
40:25 - and uh in case your x is really greater
40:28 - than height
40:29 - then it means the width then it means
40:31 - that
40:32 - you have crossed the other wall also and
40:34 - similarly for the y you need to say
40:37 - it is less than one or position dot y
40:40 - is greater than the height then you need
40:43 - to return
40:44 - true it means that you have collided
40:46 - with the wall or else you return
40:48 - false all here so
40:51 - uh we forgot to define the prototype so
40:54 - here it is going to be
40:56 - bool collided
41:00 - and in main function instead of true we
41:03 - are just going to maintain a
41:04 - variable called game over
41:07 - which will track whether the game is
41:09 - over or not so
41:11 - in the beginning game over is false and
41:14 - while true you will change it to while
41:17 - game over
41:18 - or while not game over you need to run
41:21 - all these things
41:22 - and if the snake collided so if the
41:24 - snare
41:26 - collided then you will just say game
41:29 - over equal to true and this will stop
41:32 - executing the loop
41:33 - right now if you run this
41:37 - we got an error does it say again the
41:40 - width and height are not defined in
41:41 - snake dot h
41:43 - so we need to copy those two things
41:46 - from here and put it over here
41:52 - right now if you run this you don't have
41:55 - any errors hopefully
41:56 - and here you can see that the snake
41:58 - moves and if i
41:59 - go and hit the wall it ended the process
42:03 - so
42:04 - now the game ends successfully once i
42:06 - hit the wall
42:07 - and uh we have taken care of the food
42:09 - also so
42:10 - i think that the video has become long
42:12 - enough it has been an hour
42:14 - so the next video will see how to
42:17 - increase the snake's length and show it
42:19 - visually well we are increasing the
42:21 - snakes length over here
42:22 - but we are not showing the increase in
42:25 - its body right so if we are just moving
42:27 - the head and we are eating
42:28 - and we made quite a progress right so
42:30 - let's see what we have made
42:32 - we have made this board and then we
42:35 - have updated the port without causing
42:37 - any flickering and that's a great
42:39 - improvement
42:40 - and we also animated this character
42:42 - which can eat the food and we also
42:44 - written the
42:45 - logic for the food to appear at
42:46 - different random locations right
42:48 - in this video we will complete this game
42:50 - by adding the body for the snake
42:53 - well you know that the snake is growing
42:56 - by letting the food but it's just
42:57 - growing in numbers right we're not
42:59 - showing it visually
43:00 - so we will be showing that and also
43:02 - before that let's
43:04 - just fix some logical errors
43:07 - so let's see what are those errors so
43:10 - let's just drive
43:11 - one of the other pops up but i'm telling
43:13 - you i'm lucky but just to
43:14 - save the time and just ending this game
43:16 - here and let's first talk about the
43:19 - most obvious logical order so
43:22 - in the definition of food what we have
43:25 - said is
43:26 - once a food is created i want the random
43:29 - location on the board
43:31 - which will be the location where all
43:34 - food is placed right that's what we said
43:36 - when we
43:37 - are calling this generate food function
43:39 - inside the constructor
43:40 - right but what is happening here if you
43:42 - run this program again and again so
43:44 - let's
43:44 - run this once again so here you will be
43:46 - seeing that the first code is over here
43:49 - and if i close that again you will be
43:51 - seeing that the second time also
43:53 - the food is over there but the
43:56 - consequent foods are getting randomized
43:59 - so if you say the second food is
44:00 - somewhere over there
44:01 - and if we start this game again and try
44:04 - to eat that
44:05 - you see that the second food has been
44:07 - generated at some random location right
44:09 - the first one was somewhere over there
44:11 - so to fix this well you can go with
44:14 - it it's not actually an error it is
44:17 - actually not what we wanted right
44:19 - it's basically what i did not want but
44:21 - if you wanted that the first
44:23 - should be generated like that you can go
44:26 - ahead with this and
44:27 - skip this portion but since we
44:30 - wanted to generate the food at a random
44:34 - position right from the beginning
44:36 - what we are doing wrong is here first we
44:38 - are generating the food object
44:40 - and then we are shading the random
44:42 - function right
44:43 - so if we were introduced to the random
44:45 - function and the seeding function
44:48 - or back in the detector video right so
44:50 - if you remember the seeding function is
44:52 - a kind of
44:53 - controller to the random number
44:55 - generator well the random number
44:57 - generator
44:57 - will generate some random number it will
44:59 - do some calculation give you a number
45:02 - when the program is loaded onto the
45:04 - memory right
45:05 - so if you want a different random number
45:07 - what you need to do is you need to close
45:09 - everything and then open it again
45:11 - but we don't want to do that right we
45:13 - want random numbers right when we are in
45:15 - the memory so what we do is we change
45:17 - the seed
45:18 - so seed is like a starting point of the
45:20 - algorithm
45:21 - and what we do is we seed it with some
45:23 - number every time we want to generate a
45:25 - new number
45:26 - so what is the thing which is changing
45:28 - constantly well
45:29 - time is changing constantly so what we
45:31 - do is we just
45:32 - seed it with the time so this one will
45:37 - take the time it will take the time as
45:39 - an integer
45:40 - and then make the random number
45:42 - generated start from that particular
45:44 - term
45:45 - that is why you get different numbers
45:47 - after feeding
45:48 - it but what is happening here is we are
45:50 - calling the random function
45:52 - before seeding it right for the first
45:54 - time from the next time onwards one
45:56 - the food is heated the logic is over
45:58 - here right which is after the seeding
46:00 - function
46:01 - that is why you are getting randomized
46:02 - locations for the consequent foods
46:04 - but not for the first one so to fix that
46:07 - it is very simple what you can do is
46:09 - you can get rid of the constructor well
46:11 - i don't know why i define this
46:12 - constructive basically when we define a
46:15 - constructor
46:16 - what we actually see is we need the
46:18 - constructor to do something
46:20 - which the default constructor with a
46:22 - compiler will construct for this class
46:25 - can't do it but what the default
46:27 - constructor does it will basically
46:29 - create the memory required for this
46:32 - particular class right for loading this
46:35 - class onto the memory you need
46:37 - some amount of memory which is
46:38 - calculated by the constructor
46:40 - well we wanted the constructor to do
46:43 - something extra that is called this
46:45 - function on the creation
46:46 - and it did not work out as we expected
46:48 - that is why we can just get rid of the
46:50 - constructor and then call the function
46:52 - manually
46:53 - well if you want to keep the working of
46:57 - the program
46:58 - just like before then you can skip this
47:00 - step as i told you it's just preference
47:02 - right i prefer that
47:04 - would be generated at a random location
47:07 - right from the starting
47:09 - so you can go there and after seeding
47:12 - the function
47:13 - what we can do is we can now call the
47:15 - generate food method
47:16 - so this is the one line which we wanted
47:19 - to skip
47:20 - by using the constructor which was
47:22 - actually worthless right
47:24 - so creating a constructor was more good
47:27 - and at least for this kind of a game
47:30 - where we want the first element to be
47:32 - randomized so
47:33 - it basically get rid of the constructor
47:36 - and that will solve the issue now if you
47:37 - run this you will be getting
47:39 - the foods at different locations so one
47:42 - has been generated over here
47:44 - close that open that again so the other
47:46 - one has been generated but this is the
47:48 - problem actually which i wanted to show
47:51 - you in the beginning right
47:52 - well uh when i was eating the food i
47:54 - actually knew that at some point this
47:56 - would happen that is we won't see any
47:58 - food on the pool
47:59 - that is a major logical issue with this
48:03 - program which we made in the previous
48:04 - video and we will be fixing that right
48:06 - now
48:07 - so here if you see there is no food on
48:08 - the board but actually it has been
48:10 - generated we will see why that's
48:11 - happening
48:12 - okay so close that and now we fix the
48:15 - most obvious now let's go on to the
48:17 - issue which we just saw
48:18 - that the food is not yet getting
48:20 - generated well
48:22 - what we're doing in the generate food
48:24 - method
48:25 - here we are saying that we want some
48:28 - random number
48:29 - in the range of one to with minus one
48:31 - why uh we told that uh
48:33 - one the first character is basically
48:35 - reserved for the first wall
48:37 - and the last character is reserved for
48:39 - the last one so basically you want
48:41 - numbers from one to with minus one
48:44 - leaving those two characters
48:45 - it sounds reasonable right but if you
48:47 - forgot the math it is going to tell you
48:49 - a totally different story so let's see
48:51 - what the math is let me pull up my
48:53 - paint over here and now let's first talk
48:56 - about one of these
48:57 - width or height both of them are going
48:59 - to go with the same logic so
49:01 - we can talk about only one of them right
49:03 - so here
49:04 - let's say i draw the height so what is
49:06 - the height height was something like 25
49:09 - right
49:09 - so the whole thing is actually 25
49:12 - characters right
49:14 - and what we're saying we are saying that
49:15 - the first character
49:17 - and the last character are designed
49:20 - for the calls so from a computer's
49:23 - perspective what are these numbers going
49:25 - to be
49:25 - the computer starts complete from zero
49:28 - right so 25 characters
49:30 - is basically 0 to 24 for the computer
49:33 - and what we are saying is we are saying
49:36 - that
49:36 - this 0 and this 24 is not required in
49:39 - our range
49:40 - so basically we want numbers from 1 to
49:43 - 23
49:44 - we don't want 0 we don't want the last
49:46 - character which is 24
49:48 - right so this range becomes 1 to
49:51 - 23 well to get a number in the state
49:54 - what you can do is plug it into the
49:55 - formula so
49:56 - what is the formula for random number
49:58 - generation it is
50:00 - if you want a number from sorry n
50:03 - that is a lower limit to u which is the
50:06 - upper limit
50:07 - and lower limit is included and upper
50:10 - limit
50:10 - is not included right so you will be
50:12 - getting some
50:14 - numbers till u minus 1 so if you want
50:17 - numbers in this range that is l
50:19 - inclusive and u not inclusive you won't
50:21 - get the u
50:22 - then the formula is you need to plug in
50:25 - rand mod
50:27 - it was u minus
50:31 - l plus 1
50:34 - plus l right so this is a formula you
50:37 - can plug it
50:38 - into this formula you can even see
50:40 - logically
50:42 - basically both of them are going to give
50:43 - you the same result and
50:45 - we'll just use the formula for
50:47 - simplicity purposes over here what we
50:49 - can do is just plug it into this formula
50:51 - so what it becomes let me just write it
50:54 - as r
50:54 - this is basically the random function r
50:56 - 1
50:57 - and u is over here 24 right because we
51:00 - want 23 to be included
51:02 - and in this formula this particular u is
51:05 - not included
51:06 - in this random number generation
51:09 - so we'll just increase this by one
51:11 - number that is 24
51:12 - and that will become 24 minus l plus one
51:16 - that is one plus one the lower limit is
51:18 - one which is included that's why we
51:20 - don't have to do anything to it
51:22 - and a plus one so what this becomes is
51:25 - i mod 22
51:28 - plus one and what is 22 it is basically
51:31 - 25
51:31 - minus 3 right so this is the
51:35 - number which we wanted to generate
51:38 - actually
51:38 - but what we did is we basically went by
51:41 - our intuition
51:42 - and messed up the logic right so to
51:46 - correct this what we need to do is using
51:49 - this particular
51:50 - formula this becomes minus three and
51:52 - this will become plus three and the same
51:54 - will
51:54 - go with height also we talked about
51:56 - height the same thing will go with the
51:58 - width also
51:59 - so if you draw a similar kind of analogy
52:02 - you will be seeing that
52:03 - the same logic will work for the width
52:05 - also right
52:06 - so let me just clear that and here it is
52:09 - minus three and
52:10 - this is plus one now this will
52:14 - fix the disappearance of the foot and
52:17 - there is another
52:19 - major flaw in our looping right so
52:22 - where are we looking we are looking over
52:24 - here with the board where we are
52:26 - displaying
52:26 - there is a major flaw in that and
52:28 - believe me if you have been able to
52:30 - identify that particular error you are
52:32 - going to be a great programmer
52:34 - right so let's see what the error is
52:37 - it is basically lying within the inner
52:40 - loop
52:40 - what we are doing well for the outer
52:43 - loop it is pretty straightforward we are
52:44 - going
52:47 - which is basically how the computer sees
52:49 - numbers from zero
52:50 - to n minus one and for the fifth we are
52:54 - doing something different right
52:55 - so what are we doing here we are saying
52:57 - that
52:58 - we are going from zero to with minus two
53:01 - and we had a reason that
53:03 - these two characters which are basically
53:05 - the walls are constant for all the rows
53:07 - so instead of including them
53:09 - inside the loop why not just explode
53:11 - them and run the loop only for the width
53:13 - minus two number of
53:15 - characters so that's what we did and
53:17 - that sounded reasonable
53:19 - but here is the problem what happens is
53:21 - let's say
53:22 - my uh generated x-axis which is
53:26 - basically the width
53:28 - is going to be 28 right sorry what is
53:32 - the maximum range is 50 right and what
53:34 - you can do
53:35 - if this is 50 the maximum number you can
53:38 - generate
53:38 - leaving 0 and 49
53:41 - is 48 right so this is the maximum
53:45 - number you can generate and let's say
53:46 - that that is our x coordinate that is
53:49 - the value of your width
53:51 - now what happens here well if you see
53:54 - here
53:54 - j is running from zero to
53:58 - which minus two what is with minus two
54:00 - it is basically forty eight and it's not
54:02 - reaching forty it's just
54:03 - going till forty eight which means going
54:05 - till forty seven only
54:07 - right now if you see this you
54:10 - don't have a way to actually display
54:13 - this coordinate in this loop at all
54:15 - because it is out of
54:16 - bounds of this particular loop this loop
54:18 - will run only till
54:20 - 47 and you are asking it to show
54:23 - something which is on the 48th
54:24 - coordinate which is not possible by this
54:26 - loop right
54:27 - so how do i fix this
54:30 - well we can draw an analogy over here so
54:34 - if you draw the quantity which is js
54:36 - perspective
54:39 - w is basically the original width of
54:41 - output so say this
54:43 - when w is 0 j is not undefined
54:46 - why is that well let me just create this
54:49 - thing so that we can
54:50 - see this is the leftmost corner of our
54:55 - board
54:56 - and this is 25 right 25 characters or 25
54:59 - pixels
55:00 - and here what we're doing is we are
55:02 - saying this is our character
55:04 - the width character and we are
55:07 - saying that the inner loop should run
55:10 - from 0 to 47
55:12 - and we are including another character
55:14 - and that total makes it
55:16 - 50 it's 0 to 47 is 48 characters plus 1
55:19 - plus 150
55:20 - and this is the other one now what is
55:23 - happening is
55:24 - let's say my coordinate is 0 right
55:28 - when the x coordinate is 0 it basically
55:31 - means
55:31 - this particular position where the wall
55:33 - is there right but what is happening
55:35 - here
55:36 - our zero is starting from one step to
55:38 - the right because of
55:39 - this particular looping and this
55:41 - particular character before the loop so
55:43 - what is happening
55:44 - our loop which is starting is starting
55:46 - one step towards the right
55:48 - and that is why we are missing out our
55:51 - coordinates so what happens is if j is
55:55 - sorry if w which is our original x axis
55:58 - is zero j is not returned defined it is
56:01 - not there at all
56:02 - and when does j equal to zero start when
56:04 - with equal to one
56:06 - and so on this will continue when 50
56:08 - equal to 48
56:09 - j equal to 47 as we just saw and with
56:12 - just 49
56:14 - it is not present right so
56:17 - this is the reason why we were not
56:19 - getting anything on the board not
56:21 - this is not the complete reason the
56:22 - actual reason was because we were
56:25 - messing up the formula the random number
56:27 - generation i feel
56:42 - to fix this what we can do is by
56:44 - comparing the coordinates we need to add
56:46 - one to this right so if 0 we don't
56:49 - care about the zero or the 49th
56:52 - coordinate right we don't want these two
56:54 - things
56:54 - because we're not going to generate
56:56 - those two they
57:03 - you need to compare only these things
57:06 - right
57:06 - you need to compare only these things
57:09 - and to compare that what we can do is we
57:12 - can add
57:13 - one to the j before comparing it with
57:15 - the x coordinate
57:16 - so to fix this what we are going to do
57:18 - here is when we need to
57:20 - canvas let me just leave this and
57:24 - here uh in
57:28 - place of k it's going to be j plus 1
57:31 - and that should hopefully fix all the
57:33 - logical errors which you'll need so save
57:35 - that run that again
57:37 - and here we have our first fruit if you
57:39 - eat that the second food is getting
57:41 - generated
57:42 - and hopefully it should not stop
57:44 - generating it should be generating
57:46 - till we play this game and it should
57:48 - stay within the range of board and it
57:49 - should be visible to the player
57:51 - right so when if you say this is visible
57:53 - and trust me it's going to work
57:55 - and there are no kind of mistakes in
57:58 - this program
57:59 - and this is completely fixed now well
58:01 - we'll fix one more thing that is if i
58:03 - go to this particular wall i will crash
58:05 - before actually crashing so if you see
58:07 - this i
58:07 - i have not yet crashed the one but it's
58:09 - in that uh i have crashed this one
58:11 - that means i need to go inside the one
58:13 - so to fix that i mean
58:15 - it's the coordinate issue and also a
58:17 - placement of movement so let's first fix
58:19 - the coordinate if you go
58:31 - greater than with -1 so going by the
58:33 - same logic
58:34 - with minus 1 is going to be 49 because
58:37 - with this 15
58:39 - so with minus 1 is going to be 49 so
58:41 - what you want you want
58:43 - something greater than 48 not 49
58:46 - so it's going to be with -2 and that
58:48 - should fix the
58:49 - issue and um for the other one which i
58:52 - just showed you there for the
58:54 - rightmost one what is happening is we
58:56 - are first drawing the board
58:58 - we are moving we are actually changing
59:00 - the direction of this tape
59:01 - we are moving the snake
59:31 - getting updated before the speed so that
59:34 - is why you are not seeing
59:35 - whether the snake has been collided or
59:36 - not so you can just move this thing to
59:38 - the end of
59:39 - this thing to start basically the same
59:42 - thing right before the
59:43 - next loop the starting point is to the
59:45 - end of this one so
59:47 - they mean the same thing so just move
59:49 - this to the end of that
59:51 - now this should fix that issue that
59:54 - you're not seeing the snake colliding
59:57 - and now you should see that the snake
59:59 - actually collides with the wall
60:01 - before playing this game right so it
60:03 - went inside the wall and the game needed
60:05 - and now everything is pretty much fixed
60:07 - and now let's
60:08 - proceed to making this game real sneaky
60:12 - what is that we need to include the
60:14 - snake's body we are just growing the
60:16 - snake which is basically just increasing
60:18 - the length right so
60:19 - here you can see it's just increasing in
60:21 - length so how can we store this
60:23 - neat volume well what is your body
60:27 - it's just a collection of body parts and
60:29 - that collection must have triggered
60:30 - something inside you
60:32 - well they are going to use something
60:34 - like an array
60:35 - which is a collection a vector which is
60:38 - also a collection which was
60:40 - seen in the pointless video and the
60:42 - other thing is
60:43 - list right so these are three options
60:46 - available
60:47 - to us as of now and we'll use one of
60:50 - this
60:50 - now let's unless what we need to use
60:52 - over here so i think
60:54 - when
60:59 - and how do we know the fixed size of
61:01 - this name
61:02 - well if a player like me is going to
61:04 - play he's probably going to get defeated
61:07 - in let's say 5 or ten points right
61:10 - because i have a very bad player
61:12 - and maybe a pro player comes in and
61:15 - he can make a score as big as 1000 or 10
61:19 - 000 right well you cannot restrict the
61:21 - players or you cannot estimate the
61:23 - player's capacity by just
61:25 - uh keeping a fixed number what if the
61:27 - player is better than what you thought
61:29 - he should be
61:30 - right so here what you can do is well
61:33 - in this particular board you can
61:34 - actually fix it to some big number so
61:36 - let's say
61:43 - see that it is 50 and height is 25 right
61:46 - so the maximum number of characters
61:47 - possible is this thing 50 times 25 out
61:50 - of which you're
61:51 - using the borders so that is the only
61:53 - number of characters so if you
61:55 - make the snake as big as that after that
61:58 - there is no possibility of waiting
61:59 - because
62:00 - the snake has to collide right because
62:02 - the maximum free space has been
62:19 - limitations right so that is why you
62:21 - have uh such uh
62:23 - teleportable walls and all to take care
62:25 - of this issue but
62:26 - uh for this particular game uh we won't
62:28 - be talking about the teleportable ones
62:30 - but in the end i'll show you how to
62:32 - create teleportable walls if you want to
62:34 - and
62:35 - here basically the array is a very bad
62:38 - option because you are restricting the
62:40 - player's capacity
62:41 - and if you talk about vectors well it is
62:45 - dynamic but again it is going to take up
62:48 - some more
62:49 - extra space by defining so if you
62:51 - remember how vector work is first define
62:53 - some
62:53 - amount of space and once it gets filled
62:56 - up it will define a bigger space
62:58 - and then copy all the elements to this
63:00 - and get rid of this particular space
63:02 - so this one could be used this could
63:05 - work
63:06 - but again there is some extra space
63:08 - which is getting wasted
63:09 - so basically the best option here is
63:12 - going to be list so
63:13 - if you remember from our video on the
63:16 - pointers where we first discussed when
63:18 - to use vectors versus 20 useless
63:21 - you saw that list can be used whenever
63:24 - you have
63:25 - a data structure where you won't be
63:28 - accessing the middle elements more
63:29 - frequently you are just going to access
63:31 - the first and last image
63:32 - that is the case here also right we are
63:34 - not going to access the middle elements
63:37 - which is basically
63:37 - these body parts we are not going to
63:39 - access it we are just only concerned
63:41 - about the head which is on the front of
63:42 - the
63:43 - data structure and then right so we will
63:45 - talk about how to
63:47 - uh actually manage the head and tie with
63:49 - the short one but for now
63:51 - the head is at the beginning and the
63:53 - tail is at the end and they're only
63:54 - bothered about these two things we're
63:56 - not causing a protective
64:11 - of being able to pick some random
64:13 - element from
64:14 - in between well in a vector we can do
64:17 - that very simply because
64:18 - it is a continuous collection but in a
64:20 - list you if you remember it was
64:22 - something like this right your pointer
64:24 - you have pointed to something and then
64:25 - you have another pointer which points to
64:27 - this
64:28 - and so on if you want to pick this thing
64:31 - you need to power all this way but in a
64:34 - vector or in an array you can just pick
64:36 - that up using the index
64:37 - it is basically the starting position
64:39 - plus the number of steps you need to
64:40 - determine
64:41 - so in this case a list would be
64:45 - the best implement but to keep this
64:47 - tutorial simple
64:49 - i'm using vectors for this particular
64:51 - demonstration
64:52 - so i would totally encourage you to go
64:54 - with
64:55 - list not with vectors as we are going to
64:58 - see in this video
64:59 - and just showing with vectors because
65:01 - it's easier to relate than this right
65:03 - but once you're comfortable by
65:05 - implementing this
65:07 - particular project in a vector please go
65:09 - on to try it with a list
65:11 - list is the most preferred option for
65:13 - such games where
65:14 - you don't have to control the capacity
65:16 - of the user
65:18 - vector is not going to control but
65:19 - basically the extra space
65:28 - [Music]
65:31 - and how do we define the body well it's
65:34 - really simple so let's say i have two
65:37 - body parts
65:37 - basically a tail and the head i have
65:40 - this head over here
65:41 - and the snake has to move to the right
65:43 - so what can i do
65:44 - well what if i just remove this tail
65:48 - and then put another head over here and
65:50 - make this as a tail so for the let's
65:53 - just say this
65:53 - x mark over here that dino city now if
65:56 - you see that
65:57 - the snake has pulled one step to the
65:59 - right right and if i do that again so i
66:01 - take out this tail i include the head
66:04 - and i'm doing this head as the tail
66:07 - let's take a smooth again
66:08 - and let's say we are eating the food at
66:10 - some location so let's start with
66:12 - another snake so this is the snake we
66:14 - have
66:15 - and the food it is going to eat this
66:17 - particular food
66:18 - so it has eaten in the next iteration
66:20 - what i will do is
66:22 - i won't take off this table i will keep
66:24 - the stain
66:25 - and this is what happened right so i
66:29 - add the head i want to remove
66:36 - and that basically looks like the snake
66:38 - has grown right
66:39 - from two body parts it has grown into
66:41 - three body parts and that's what we want
66:43 - right
66:44 - so this is the logic we are going to
66:46 - implement and we are going to do that
66:48 - in vectors again list is the most
66:50 - preferred option
66:51 - please try it with the list not with the
66:53 - vector after you're comfortable
66:54 - basically
66:55 - so let's let's go to our sneak.h and
66:58 - quickly create a body definition
67:00 - so we need vector obviously so hash will
67:02 - close vector
67:03 - which is going to do it with the list
67:05 - you know right as include list
67:07 - and well since vector is a standard
67:10 - scope element you need to specify the
67:12 - scope so using name space
67:14 - std like we did in the main function and
67:17 - here you can just say vector
67:21 - body sorry vector and what is the data
67:25 - depth it's going to be coordinates
67:26 - basically so chord and then body
67:29 - and this defines the body of the victim
67:32 - now they have two changes we need to
67:33 - make what is that
67:34 - first of all we need to include the head
67:36 - to the body
67:38 - once we create a new snake so in this
67:41 - snake point
67:42 - constructed what we're going to do we're
67:45 - just going to say
67:46 - body dot push back which is basically
67:49 - pushing back the elements inside a
67:50 - vector and what we need to push back we
67:52 - need to push back the position which is
67:54 - basically the
67:55 - position of the head of the snake right
67:57 - we can just body not push back that
67:59 - particular position
68:00 - and while moving the snake following
68:03 - that logic which we just discussed what
68:04 - we're going to do is
68:05 - first pushing the head of the snake to
68:08 - the end of the list
68:09 - or end of the vector so how we do that
68:12 - we do not push back the new position
68:15 - which has been updated after all these
68:16 - things
68:17 - a new position and now what we'll do is
68:21 - if the body size
68:24 - is greater than the length of the snake
68:26 - what is the length of the snake that is
68:28 - the
68:28 - thing we are growing when the snake is
68:31 - actually eating the food right so that
68:32 - is the thing we are manipulating over
68:34 - here
68:34 - so this length integer if the body is
68:38 - size which basically the number of
68:40 - elements in the vector
68:41 - is greater than the length then what you
68:43 - do you just
68:44 - take out the element from the body so
68:47 - how do you do that you just say body dot
68:50 - and if i actually confused with what
68:53 - function you need to use
68:54 - the best thing i would suggest is not
68:56 - just eliminate the function but just use
68:58 - the resources so
68:59 - uh you can just go to your web and then
69:02 - search something like ctp vectors
69:06 - documentation and you'll
69:09 - get a lot of resources and c plus plus
69:12 - dot com
69:13 - is the best one among them well i think
69:16 - that
69:16 - this is the best one where you can find
69:18 - short descriptions of all the functions
69:21 - and here you should be seeing some
69:23 - function like pop
69:24 - back what does it say it says that
69:27 - removes the last element in the vector
69:29 - effectively reducing the container size
69:31 - by one but we actually don't
69:33 - want this well why is that
69:36 - if you see but technically the tail
69:39 - should be at the end of the body
69:41 - but if you look at the structure what
69:44 - we're doing is
69:44 - we're actually pushing back the head one
69:47 - step to the
69:48 - right right so this is what two step
69:50 - does so basically our head is over here
69:52 - and your tail is over here
69:54 - and what we need to do we need to remove
69:55 - the first element so how can we remove
69:57 - that
69:58 - you can just check out the functions
70:00 - over here but
70:01 - to save the time i'm just going to show
70:04 - you the function which is basically
70:06 - clear or areas right so you will find
70:08 - this one
70:09 - this is basically going to remove from
70:12 - the vector
70:13 - either a single element or a range of
70:15 - elements so here we just need to
70:17 - remove a single element but the position
70:20 - is not an integer
70:21 - it's a pointer so here you can see it
70:23 - says the definitions
70:24 - iterator position and iterate to first
70:26 - unit
70:27 - well you can go with any of this
70:31 - the only difference is that it has a
70:32 - quantity but you don't have to know at
70:35 - this stage right
70:36 - you can you can just go and search what
70:39 - these two things are
70:40 - basically the same thing and how they
70:43 - use that
70:44 - you can see an example over here it says
70:47 - dot is
70:48 - my vector dot begin plus five so plus y
70:50 - is basically
70:52 - going five steps away from the first
70:54 - element which is basically the sixth
70:56 - element
70:57 - and that's uh how you use this areas
71:00 - function has also
71:02 - shown an example to delete a range well
71:05 - we are not quite interested in the
71:06 - regime we just want to erase a single
71:08 - element which is going to be our first
71:10 - element because our first element is the
71:12 - tail
71:13 - and what we can do we can just say my
71:15 - vector and begin plus 0
71:17 - that is the first implement or we can
71:20 - just omit the zero and just say my
71:21 - vector
71:22 - that is going to erase the first angle
71:24 - so let's implement that what we're going
71:27 - to say
71:27 - i'm going to say body dot it is and what
71:30 - we're
71:31 - going to do is we're going to erase the
71:32 - first element which we can get from body
71:34 - dots again this is the pointer for the
71:36 - first
71:37 - item first position right so this
71:40 - will basically erase the first element
71:43 - from our list
71:44 - and before proceeding let's first see
71:47 - whether this is working or not
71:49 - and we need to create another function
71:53 - let us keep this function alone then
71:55 - create another function just in case
71:57 - something goes wrong
71:58 - so vector and it is going to be
72:01 - coordinated
72:02 - you need a coordinate vector to be
72:03 - written well basically you are going to
72:05 - return this next body
72:06 - so snake and then let's say get body
72:11 - and inside this we can say return body
72:16 - and in the snake dot h
72:20 - you can just create that function
72:22 - definition which is basically the
72:24 - vector sorry
72:27 - what does that get body right so
72:31 - now we have different snakes definition
72:33 - now we'll just update the board
72:35 - and what we need we first need a vector
72:37 - to capture the
72:39 - snake's body so vector quant
72:42 - let's say snake body
72:45 - equal to snake dot get body
72:50 - and inside this what we're going to do
72:53 - we'll
72:53 - just remove this else and we'll place
72:56 - this
72:56 - afterwards what we're going to do is
72:58 - inside the edge we are first going to
73:01 - loop through snake's body and see
73:03 - whether any coordinate matches or not
73:05 - so uh what we can do is we can just say
73:08 - this
73:08 - body part which will stay
73:12 - false in the beginning right we'll
73:13 - change that in the loop and what you can
73:15 - say is
73:15 - for in
73:26 - and k plus plus what we are going to do
73:28 - here is inside this loop
73:30 - we will say if i coordinate which is
73:34 - basically going to control the y
73:35 - coordinate
73:36 - is equal to the snake body of the kth
73:40 - index
73:41 - dot x sorry dot y
73:44 - and j plus one well remember that's the
73:49 - logic we were missing up
73:50 - equal to snake body dot solution
73:54 - body of that particular index dot
73:57 - x if these things match up
74:01 - then what we need to do you need to
74:03 - display a body part so
74:04 - let's just go with the small o for now
74:06 - this is our body part
74:08 - and this body part becomes true equal to
74:11 - true
74:13 - and what else well we don't want to run
74:15 - this thing right because
74:17 - at an instant a particular body part can
74:20 - stay on there at a particular location
74:22 - so if that location is occupied
74:24 - it is pretty obvious that any other body
74:26 - part won't occupy the location
74:27 - so you can safely break out of this loop
74:29 - you can end this loop
74:31 - and in the end what you can say is if it
74:33 - is not body part
74:35 - if not body part then obviously it is
74:38 - going to be
74:39 - just an empty space
74:43 - and here another thing is here we are
74:45 - going to report it on size but remember
74:47 - body includes the head right so what we
74:50 - can do is we can just say body dot size
74:52 - -1
74:53 - which will basically leave at the last
74:55 - input and now
74:56 - this should work i mean let's try to
75:00 - implement this so f9 and here you can
75:03 - see that the snake has grown so the
75:05 - other fold is over here
75:06 - so well i ate that and the third food is
75:09 - over here
75:10 - well you can see that the snake is
75:11 - growing right so here
75:13 - you have four body parts of the snake
75:16 - and now if i eat that
75:18 - here now you have five right so now we
75:21 - have
75:21 - a working snake game right so now you
75:24 - have working snake game and this works
75:26 - pretty fine right so
75:27 - now the you can see that the animation
75:29 - also works pretty fine the body
75:31 - parts seem to follow the head and so on
75:34 - right
75:34 - so this concludes our game well
75:52 - i will just keep it global so that you
75:54 - can use it on the board function also
75:56 - so here you can just see in score
76:00 - which is going to be zero in the
76:02 - beginning and uh well you can just set
76:04 - this to zero
76:05 - in case you want to uh say play again
76:08 - something like that what you can do is
76:10 - instead of main you can just say
76:11 - game and this is going to avoid game
76:13 - because i'm not going to do that
76:15 - you can do that right so if if i want to
76:18 - play again
76:18 - you can ask a question do you want to
76:20 - play again or not
76:22 - something like that and if i press yes
76:24 - then you can call this function again
76:26 - and then you can set this thing as zero
76:28 - so
76:28 - equal to zero before the beginning of
76:30 - the new game and
76:32 - here what you can do is you can just say
76:34 - score
76:36 - plus plus very simple and if you want to
76:38 - give 10 points or something like that
76:40 - you can just do that score
76:42 - equal to square plus 10 or any short
76:44 - hands if you know scored plus equal to
76:46 - 10 or something like that
76:47 - you can do that over here and here
76:50 - before
76:50 - starting to print out the board what we
76:52 - can do is we can just say c
76:54 - out our score so score
77:00 - is our school current school and just
77:04 - add a couple of new lines so that looks
77:06 - neat and that should equal well
77:08 - now i have one redundant function over
77:10 - here that is this food
77:12 - sorry the snake pause which is actually
77:14 - getting the position of the head and we
77:16 - are also getting the position of the
77:17 - body
77:18 - right and we did not define the
77:19 - collision of the sleeve right
77:21 - so we'll do that those things first of
77:23 - all let's just see whether this thing
77:25 - works or not so now you have this
77:26 - particular snake
77:28 - and i hate that the school is 10 now i
77:30 - hate that school is 20
77:33 - i ate that school is 30 and so on so
77:35 - it's working pretty fine
77:37 - so you can close that and
77:40 - to take care of the collision where you
77:42 - might have figured it out by now
77:43 - what we need to do well what you need to
77:46 - do here is
77:47 - you need to say else
77:50 - and you need to check whether it
77:52 - collided or not
77:53 - how do i check that well you don't need
77:55 - an electron you can directly
78:04 - is less than the body dot size well it's
78:07 - inside this nature i don't have to call
78:09 - that again just
78:10 - length minus 1 because i don't want the
78:12 - head
78:13 - and it's going to be i plus plus right
78:16 - and what we need to check
78:18 - if our snake's head head is basically
78:21 - positive right
78:22 - so if cos dot x is equal to
78:26 - any of this new body will be the
78:27 - substrate body is just body
78:30 - body of i dot x
78:33 - and the y coordinate is also same
78:37 - positive y is equal to
78:38 - bodies i don't
78:41 - y if these two thing match up just say
78:44 - return true yes you collided
78:46 - if these two things don't satisfy the
78:48 - end just say written false
78:51 - so they should take care of the
78:52 - collision so let's just try that out
78:54 - f9 to build and combine this and here
78:57 - you have this
78:58 - snake and the food and let's first go
79:01 - for our first food we have grown
79:03 - and the score has also increased and the
79:05 - second fruit but it's going to take a
79:06 - while if i go like that
79:08 - it's just going one body particularly so
79:10 - what i can do is i'll just write up
79:11 - equivalent
79:12 - well how can i collect well i'm going
79:14 - left now right so if i just press
79:16 - right i'm just going to pull it with my
79:17 - neck so basically i collected and
79:20 - now you can see that the process has
79:22 - stopped basically all
79:23 - collision algorithm is working so
79:27 - that basically ends this game
79:30 - and if you want to make a teleportable
79:33 - wall it's
79:34 - really simple what you need to do is i
79:36 - i'm sure many of you must have figured
79:38 - it out right now
79:40 - well you just need to play with the
79:41 - coordinates so if here if you see
79:44 - in the snake moves me what you do is
79:47 - if you want to change the location of
79:49 - this wave you will just say
79:52 - here if this particular thing
79:56 - if position dot x is greater than
79:59 - the width minus 2
80:02 - then what you do you just say position
80:04 - dot x equal to zero
80:06 - so simple and again what you do if you
80:08 - say
80:09 - if position dot y or position dot x
80:13 - is less than one then what you do is
80:16 - just have position dot
80:18 - x equal to the width
80:21 - minus three sorry about that it for
80:23 - random function we need to use with
80:25 - minus three because
80:26 - uh for generating the random numbers in
80:29 - that range
80:30 - it's basically with minus two and this
80:32 - will make the side walls teleportable so
80:34 - if you just save that
80:36 - and now if you run this you should be
80:38 - going through the sidewall and coming
80:40 - from the other one
80:42 - and now if i go through my side wall i
80:45 - should be appearing from the other one
80:46 - so you can see that
80:47 - it has been kind of teleportation now if
80:50 - i eat that our tray will also follow
80:52 - our steps right so if it goes from there
80:55 - you appear from there
80:56 - right so it works good that is how you
80:59 - make data portable walls
81:00 - and uh once you get to know about file
81:03 - handling basically how to
81:05 - write files what you can do is you can
81:07 - even have a high score option
81:08 - so you can write down a particular high
81:11 - score on the
81:12 - file so let's say i open this game right
81:14 - now and i scored about 10 points and you
81:17 - scored about thousand points
81:18 - that's pretty reasonable i'm not a very
81:20 - good player but yeah
81:22 - so uh you scored a thousand points and
81:24 - that is a high score right
81:25 - so here if you run this program again
81:27 - that high school gets lost
81:29 - so instead of just writing it on the
81:31 - memory for that particular
81:33 - kind of run what you can do is you can
81:36 - have a file where you can write down all
81:38 - your high scores
81:39 - and then whenever you load this game you
81:41 - don't get along with the file
81:43 - so inside that file you have all the
81:45 - high school lists and if you want you
81:46 - can just
81:47 - have names also so some games provide
81:49 - that right so you have the name
81:51 - and the high school sometimes you can
81:53 - design everything
81:55 - and we'll come back to this by
81:57 - discussing files right so because
81:59 - uh traditionally what we do is we just
82:01 - write files about students and all the
82:03 - stuff but
82:04 - we'll come back here and then try to
82:07 - work on this game
82:08 - more and trying to create a file and
82:10 - again
82:12 - this is the total working game and if
82:14 - you want to
82:16 - implement this and if you are
82:17 - comfortable with implementing this with
82:19 - this kind of vector well i have made
82:21 - some rejected functions like this is
82:23 - completely solid this one is completely
82:25 - unnecessary because i'm getting the head
82:26 - along with the body
82:28 - so you can take care of that and again i
82:31 - will advise you
82:31 - not to use a vector using this and here
82:34 - if you
82:36 - want to include another teleportable
82:38 - wall inside this one
82:40 - you can do that again with a similar
82:42 - kind of logic for y-axis right so you
82:44 - make
82:44 - basically all four four of them all
82:46 - still reportable
82:48 - so uh when i i had actually implemented
82:50 - this game
82:52 - in python and if you use a graphics
82:54 - library you will be getting results like
82:56 - that
82:56 - so if we go to our
83:00 - python one so here i have my game
83:03 - it is basically written in two files one
83:05 - has the classes and one has the script
83:07 - and it has various images so what i have
83:10 - is the snake
83:11 - in patch so here you can see body
83:13 - horizontal
83:14 - tail up so whenever that snake is going
83:17 - in that particular direction you
83:19 - show that image and now where you can
83:22 - run this thing
83:23 - right over here you can see
83:26 - this game this is what you can make with
83:29 - a graphics library well this is pretty
83:31 - far
83:31 - but this is what you can make with the
83:33 - graphics library and you can see how
83:35 - smooth it is
83:36 - and it doesn't have any uh kind of
83:38 - issues like
83:39 - moving down faster in the vertical
83:43 - direction moving slower in the
83:44 - horizontal direction
83:46 - it has kind of same speed because you
83:48 - can control it
83:49 - you can basically control the number of
83:51 - pixels and all and if you see it is
83:53 - really portable on both sides if i go
83:55 - from
83:55 - the bottom from coming from the top and
83:58 - if i go from the sides i end up coming
84:00 - from there
84:01 - so this is how you can implement your
84:03 - games
84:04 - and this is basically the same project
84:06 - which i've implemented except that i
84:07 - have some additional functions handling
84:09 - the graphics of this game right
84:11 - nothing more than that it is basically
84:12 - the same exact logic which were talked
84:16 - but when you use a graphics library you
84:18 - get results like that
84:20 - so once you're comfortable when
84:22 - programming this
84:23 - particular game on the console i would
84:25 - advise you to
84:26 - look up some graphics library which is
84:29 - available in safe space there are many
84:31 - so see what you're comfortable with and
84:34 - try to implement
84:35 - such games on graphics even the tick
84:37 - factor game can be implemented on the
84:39 - graphics network
84:40 - and that really looks good instead of
84:42 - the concern
84:49 - is the best way or the best platform to
84:52 - actually
84:52 - put down our ideas in a very fast way
84:55 - well if i want to do
84:56 - the same thing in a graphics library it
84:58 - will take a really
84:59 - long time i need to initiate the
85:01 - graphics library i need to do a lot of
85:03 - things before getting all these things
85:04 - right
85:05 - so if you're coming up with an idea i
85:07 - would
85:08 - rather recommend you not to go to a
85:11 - graphics library but
85:12 - first thing and then put up a dirty kind
85:15 - of
85:15 - working prototype on your console and
85:18 - then you can beautify it on the graphics
85:20 - library
85:20 - so that's it for this particular video
85:22 - hope you enjoyed this
85:24 - and
85:30 - you know making it faster on the x and
85:33 - slower on the way or something like that
85:34 - i didn't do that i just
85:36 - went with a very simple approach but i'm
85:39 - sure you can do that
85:40 - and in the next video we'll start with
85:42 - inheritance
85:43 - till then happy coding

Cleaned transcript:

in this video we'll be making our second programming project which is going to be this the snake game so i'm sure everybody knows how to play this game you have a snake which grows on eating the food and the objective is to grow the snake as long as possible without hurting yourself or hitting one of them so if you do any of those you lose this game well there are different variations of this game some have teleportable walls that is if you go through this wall you end up coming from there and some versions even have obstacles in between them instead of this free space but we're not going to do any of those we are just going to stick to the simple version with four concrete walls and uh empty space in between right so let's get started let's create a new project it's going to be a console application and the language is c plus plus project title let's say snake and these things remain as it is right and now let's first start by defining the board so if you remember from our previous project where we made our detector game we had defined a 2d array or a matrix to hold the board right but here if you see you don't need that why well in the previous game where we made a tictactoe game the board only had nine elements and we were concerned about all the nine elements of the board right so we were concerned about what all the board contained but here you don't have to actually be concerned about all the elements of the board here the board just acts as a background the only things you are concerned about are the position of the snake the position of the fruit and the position of the wall so other than that you don't need to keep track of other things so here we are just going to print the board just like we print something on the console so let's define a function for that let's say void board and here we are going to draw the board so uh let's first define the dimensions of the board the width and height so let's say uh the width is going to be somewhere around 50 characters so since we are working on the console you are going to see everything in terms of characters or this is basically a substitute for pixels if you are familiar with graphics and the height is going to be somewhere around let's say 25 characters now these two things are constant right so the these won't change throughout the project so if you want to make them as constant so you can just say const over here so this keyword will make these things as constant and now i would like to introduce you the concepts of macros so macros let me write it down here macros these are nothing but oneliner code right so let's say you want to define a function to calculate the square so what you do typically is you write something like this right so in skew and this will return x into x right so this is how you define a small function but what you can do is instead of defining it as a function you can define it as a symbol so when i pin symbol what i mean is if i type that particular symbol then this operation should be performed so that is what a macro does so the way you define macro is you put hash define and then you put the symbol so let's say sq over here and inside this whatever parameters you want to pass without any data type so this is basically a symbol and here you want to uh define the operations so here our operation is x into x so that is basically going to return as the square of a number so here you don't have any assignment operators or written operators all this means is whenever i say sq of x it should do this particular operation so if you say something like sq of 5 and here if you run this you should be getting the output as 25 so that's how you use macros and you can do the same with these two variables also so the way you define it as hash defined width is 50 and hash define height 25 so now whenever i save width i mean 50 and whenever i say height i mean 25 so now you can remove this you don't need this anymore so now the board is going to be two loops the first loop or the outer loop is going to control the number of rows so here the number of rows is defined by height right because height is basically how down you go so that is how many rows you have in your board so i is less than the height of the board and i plus plus and inside this you will control the width so enter in let's say j and inside this you are going to print something so here if you observe this board for every row there are two wall pieces right so every row starts with one wall and then ends with one bolt so since that default you can subtract two here and then put those two characters so you have one ball in the beginning of a row and one wall at the end of the row and then you go to the new line and inside this basically if the row number is 1 or the row number is height minus 1 that is if you are printing this row or this row then you need to print all walls so here we are just going to print out these hashes or else you need to print out the empty space which is basically this space right so now if you call your board function that should print a board for us so here we have the bowl now this board looks pretty squished to the left so you can take care of that by adding a couple of tabs and that will center the board so now let's see how to animate things on the console so if you are familiar with graphics or even if you have heard about animation you might know that animation is nothing but just fast moving pictures right so here if you want to animate something on the board let's say you have some object on the board then the video animators you will quickly move the position of that object and it will appear as moving so to move something on the board or to place something on the board you need to know about the coordinate system which the computer uses so let's talk about that quickly so you might have come across this cartesian coordinate system in your math class right so you have a coordinate system where if you go right the x coordinate increases and if you go vertically upwards your y coordinate increases and this will position basically which is the intersection of these two axis this is the origin which is defined by this zero zero coordinate right so this is the coordinate system you all have come across in your math class now what happens in a computer is this origin is shifted to this top left corner so let me just clear this thing so in a computer your access are defined as follows so if this is the top left corner of the screen that is this position where i'm pointing my cursor that position is basically your zero zero position so this is your origin in a computer and as you go right your x coordinate increases and as you go down your y coordinate increases so basically your y is flipped in case of a computer and x remains the same so as you go up your y is decreasing and as you go left your xcoordinate decreases so that's how the coordinate system in a computer is defined you can use this coordinate system to move objects in your screen or even place objects in your screen so every object is defined by x coordinate and y coordinate so if you put some point here so it has some x coordinate that is how much it has moved from the origin in the horizontal direction and some y coordinate that is how much it has moved from the vertical direction right so this is how the coordinate system of the computer is defined and we will be using this system to operate on our board right so let's define an arbitrary object somewhere so let's say our int x which is the x coordinate is going to be somewhere around 10 characters and y is also 10 so that means that this is 10 characters from the left and then 10 characters down so it it will be in some arbitrary position somewhere let let's just see where it is so if i here if i print that particular object that is pretty simple to print so if the coordinates match you are going to print that object so how do you do that well i is controlling the height right so height defines how deep you are on the board so that is basically the y axis so you need to compare i with y and j with x so if you if these two coordinates are equal then you can say that your object is at that particular position and you can print something so let's go with this zero for now so that is going to be our object now if i try to print this board you will be getting your object here so and this is 10 characters from the left and 10 characters towards the bottom but if you see this position is exactly not as square as expected uh that is because in console the next line has some gap if you see over here so this gap is much bigger than this gap that is why it doesn't end up as a square but if you're using some graphics library then this will work so it will exactly be as a square so it will end up somewhere over here so this could be the 10 comma 10 point but here since we are working on the console uh the yaxis is much wider or i should say much deeper than the xaxis so uh even when you animate your snake it's going to move faster on the vertical direction than on the horizontal direction that's actually not a logical error that's because of the property of console you cannot do anything about that right so if you're using any graphics library then that problem won't be there so now let's see how to animate this animating is very easy you just need to move the board right so uh let's say i will create an infinite loop here and inside this we will first call the board and every time this loop runs we will just increment the x coordinate so when you increase the x coordinate from this coordinate system your object is going to move towards the right right so now if you run this program you should be getting some kind of movement so here you can see that this o is moving towards the right but uh you cannot actually see it as a movement this is basically it is just printing the board again and again so if you have some way to update the board then you can see the movement so one way you can update us you can use your console command so if i pull up my console over here this is basically a powershell but in windows or if you're using this code blocks in windows it's going to use the use your cmd as your default console right so in cmd the command for clearing the screen is cls so if i type something over here under type cls that thing is cleared right and if i were linux the command for clearing the cler and the way you pass in such shell commands or such console commands are you include another library called cstdlib which stands for c standard library you might have come across this while making a tictactoe game this is the library which had our random function and we will be using that random function in our code as well right so here to send commands to the console you use system and inside this you write the command so in in my case it is the windows operating system so i write cls and in case you're on linux you need to write clear right so let me just comment distance if you're on linux you need to write clear and i forgot the semicolon and now if i run this i should be getting a movement but if you see here it kind of flickers on my screen right so this board is up getting updated but it is annoying to see so uh this you cannot actually control so more technically if you know about the fps or the refresh rate so you cannot control these things of a console console is not a property of the language or just id right it is a property of the operating system so you cannot control something from an external source which belongs to the operating system so one way you can take care of this flickering is instead of clearing the screen this is happening because it is doing two processes right first it is clearing the screen and then again it is drawing the board so if you just overwrite the board as we used to do with our normal line so if you remember from our escape sequences video we had talked about an escape sequence called slash r right so if you write something over here let's say hello world and um here if i put slash r and i type something else so as is then the first four characters which are these four characters are going to be replaced by the word asas so now if i run this i should be saying iso over so that is because he ll has been replaced by this that is because this slash r will take the cursor from the end of the line and place it in the beginning but we cannot use the slash r over here that is because we are using multiple lines right so you are printing around let's say 25 lines because the height is 25 so you're printing 25 lines and there is no escape sequence to get your cursor back a line so slash n will move your cursor down a line but you cannot go up a line right so for that i'm going to tell you a solution but this is going to work only if you're on windows so let me write it down here this is only for windows and for linux you need to find out a library which tested so basically what we are going to do is we are going to pick up this cursor from the end of the screen and we are going to go all the way up to the origin and place it back so if you do that instead of clearing the screen you are moving the cursor and when you print your data again it's going to be overwritten on the console so it looks like it has been cleared but actually it has been overwritten instead of clearing so this solution what i am going to give you in this particular video will work only if you are on windows so if you are on linux you need to find out some library which will do that for you right so if you are on windows you need to include a library called windows starter which will basically allow you to control the cursor's position on your console and here what you need to do is instead of system clear you can do set console cursor position and here you need to give some handle which is get htd handle inserted std output handle so if you don't understand what this means it's okay it's just you can think of it as it's going to pick up the cursor from the end and it's going to put it back on the origin and to put it back on the origin or any specific coordinate you need to pass in a coordinate data structure well coordinate is basically a simple data structure which is already defined in windows.h and we'll be using this so if you're on linux and you're using some other library to achieve this you need to define this uh structure to follow along with this tutorial which is basically a simple structure it is something like in x and y so this is the structure which is defined in windows so i'm not going to define this again it's there in this windows.h and that's what we are using over here to send the position to our handle which will basically take the cursor from this position and then put it back to the origin so the origins coordinate are basically 0 zero so you need to pass that in and now if you see you won't have any flickering screen you will have a neat animation going on on your screen so as you can see there is no flickering although you can see that cursor update somewhere but this is much better right instead of the flickering screen so again this solution is only for windows users so if you're in linux you have some other libraries like you have n cursors and many other libraries simple google search will get you what you want right now uh let us remove all these things we have now understood how to do animation and here what we are going to do is we are first going to define our snake so go to file new and clash and the name of the class is snake and you can remove all these things right it doesn't really matter you don't need destructor on all these things we'll create if we want to right and here just click ok and in snake dot h we have this template code so again i prefer private to be on the top so if you want that you can follow this or if you if you're okay with the structure it has given before you can follow that it doesn't really matter and here first of all we are going to decide what is going to be private and what is going to be public so what are the features that we need our snake to have first of all it will have a position right the position of the head to be places and next it should have a length to define how long the snake is and you also need a direction and you also need a velocity or you can say speed of the snake so how fast it goes so here in case of velocity or speed we are going to talk in terms of number of characters so let me write it down here that is basically it is going to move two characters at a time three characters at a time and so on so in case you are working with some graphics library that the same thing you do with pixels so you say three pixels at the time or five pixels at a time and since here we are on console we are going to talk everything in terms of number of characters right so uh here let me define the private variables first in this you are having to have a position so it's going to be quad position so again if you are in linux you need to define the structure and uh for using the squad you need to include windows started right so this is because this is a separate file that snake.h is a separate file so even if you are included in main you need to include it again but you can exclude this over here because once we actually include this file you are going to include all these things it doesn't matter even if you keep it twice because of this guard block as i had explained before this guard block what it does is it takes care of multiple initialization so here i have already included windows.h now i when i do hash include snake dot h it will take care of the fact that i have already included windows started so i don't need to include it again but here if you want to use these things you need to definitely specify that you are using windows. or else you cannot use this and will throw you an error right and here you need a length of the snake and you have a velocity so in well and you have a direction so let's say card direction and in the public section we need to define constructor first and this is going to take a position that is the initial position and uh initial velocity for our snake so let's define this constructor and dot cpp and um here we talk and specify those things so called position and velocity and here you don't have to include windows attached that is because again you are including snake dot h which comes with windows started so you don't have to include it again and uh here you need to set the position and velocity so since i'm using the same name for both the variables i need to use this pointer so if you are not using the same name it's okay but if you are using the same name you need to use this pointer and the velocity also goes the same way and initially the length is going to be one that is because you have one head right so without the length cannot be zero because you always have a head for the snake so the length is going to be one initially and the direction so the direction you can say uh something like none right because the snake is not moving now and um we'll have a method to change the direction of the snake so let's say on change dir which will change the direction it will take some direction to change and here let's define that method it's void snake change dir and what you need to do is direction equal to there basically i'm just setting the direction of a snake and um for moving the snake let's create a move method or move snake well move is basically a defined method in c so it's not preferable to overwrite it you can overwrite it you can define something like this but it's preferable not to overwrite any default method so let's say move snake and this is not going to take any parameter because it's just going to perform something so void does make more snake and here what you need to do is you need to switch the direction that is basically you need to move the snake in that particular direction so switch direction and here you need to put different cases so in case it is going up then what you need to do refer to this coordinate system you need to decrease the y coordinate so what we're going to do is cos dot capital y minus equal to the speed so basically if i say that my snake is moving two characters per second or two characters per iteration then i need to subtract those many characters right to move to appear to be moving in that much speed so that is why we are going to subtract the velocity over here or speed you can name it whatever you want and here the break is mandatory and this will be true for all the four directions so let me just copy it down four times and uh it's going to up down left and right right is you need to increase your velocity left test you need to decrease your velocity and um for down you need to increase your velocity on the y coordinate so this will move your snake in your preferred direction and that should be it so now you have a snake you have initialized it with some initial position and velocity and you have a method to change the direction of a snake and now you even have a method to move the snake and here since we need the position of the snake to draw it on the board you also need a method to get the position so let's say uh get pause which will return the position of the snake and uh this is going to be return first and uh i forgot to mention slate here this will be declared as normal function if i forgot to mention this this basically means that uh this get pass function is related only to the snake class right i'm sure everybody knows this and uh here we'll quickly define a prototype for that let's quad uh get pause and done so now you have four methods let's go very quickly one is a constructor which will initialize our variables one is a method to change our direction so change direction of the snake and one is to move the snake in that particular direction and one is to get the position of the snake or i should say get the current position so now let's use this thing in our main file so you here as i told you you can remove this windows storage because it is going to be included with snake dot h and uh here let us first create a snake so snake s and let's sneak and inside this let's see it's going to be initially in the middle of the board so that's basically 50 by 2 and 25 by 2 or you can say bit by 2 and height by 2 that makes more sense right so width over 2 and height over 2 that is basically the center of the board and velocity let's say it's going to be 1 that is one character at a time and here you instead of y and x you need to capture the position of the snake so called the snake boss you can see equal to um snake dot get position and here instead of why you need to say snake pause dot y and instead of j you need to say snake poss dot x so so far so good we have created a snake which is going to be on the middle of the board and which is going to move at a speed of one character at a time and here um let us just clear all these comments and now let's see how to get input so that we can control the snake so you need to move the snake only when you press something right so here how do you capture that keystrokes well you have a library to do that so that is called corneo or i should say console input output and here you can just do the following so if you say if kb hid so kb hit stands for keyboard hit so it will be true if you hit a key on your keyboard not necessarily enter key you can hit any key on your keyboard and this is going to evaluate to true and to capture your key you need to say gets yet so get ch will basically give you the key which you just pressed so uh we will capture this and instead of capturing this we can switch this so that we don't have to write a couple of if statements we can just say switch get ch which will basically give us the key and here you can control it so let's say up so i'm not going to do it for the arrow keys because i don't really remember the ascii values of the arrow keys so if you want arrow keys you need to give the ascii value so let's say 132 is the ascii value of upper key it is not the case i'm just saying but if 132 is the ascii value for the up key then you need to give something like this but uh i'm just going to go with wsd for now so case w then um what you need to do you need to move the snake upwards right so snake dog change their double up sorry u and then break and you need to do this for all the four directions so control c v b w a s d and uh d is basically go to right s is down and this is left for now this will more snake in our preferred direction and to move the snake you just call snake dot move snake which will move a snake and now if you run this you will be getting a snake which can move on your command so now you can see that it is not moving because initially we had set the snake's direction to be n right so we did not have any case which will uh move the position for n so it doesn't move for any iteration and now once i press w you can see that it started moving up a it started moving left yes it started moving down and d it started moving to the right so now i can control this little character and keeps moving right so that is how the snake game is different so once you press a key it will keep moving in that particular direction until you change the direction so this is what we needed and we got a moving character on our board so now let's see how to first uh generate the food and calculate the points and then we will talk about how to increase the snakes length once it eats the food right so now let us just close this and talk about the food so again you need to create another class for generating the food so it's going to be it's a food and again you don't need the getter center or the destructor created yes okay and uh here you have food dot h and again i don't need these things so here in the private section what we're going to do is we are going to have a position of the full right so that is mandatory you you cannot have any object without a position right so for the position you again need to include windows windows.h and uh it's going to be called pause and uh you do need a velocity well you don't need anything else you don't need velocity you don't need any uh direction for that foot it's just going to be a point where if you go over to that point and then eat that fool you're just going to generate another form so basically you don't need anything else and uh in the public section the public section we have a constructor basically well you don't have to pass anything to the constructor it's basically going to initialize this position with some random value but if you see this game always this would start at this possible position if you want something like that then you need to define a initial starting position so as we did for our snakes you need to do something like this but we are going to go with random initialization right from beginning itself so again for random function to work you need to include cstdlib and we are going to define a function called gen this is basically going to generate output and this is going to be void and we also need a function to return a supposition so it's going to be get so this will return our position so let's define these functions uh inside this what we're going to do is just generate food it first time it's just going to generate the food once you create it and uh for generating the food sorry snake sorry food gentle and what this is going to do is it's just going to generate two different random numbers in the in some range so if you remember the formula for generating a random numbers in the ring that is u2l it was basically rand mod u minus l plus 1 u minus l plus 1 plus l so this was the formula for generating a random number in a range so here our upper limit is going to be for the x axis is going to be width and the lower limit is zero right so uh here you just need to say rand mod and then u minus l plus one plus l so for us the u is basically with minus the lower limit now lower limit if you keep zero then the food will have a chance of getting generated on the walls of support so you don't want that to happen so it's going to be one and plus one so these two cancel out so you just need to say random width and then plus l which is one again for uh the y axis the upper limit is going to be height and the lower limit is again going to be one so this will generate a random position for our food which will be on the board and for getting position it's very simple you just need to say for the word get position so we did not define that well we did quad get position and here you need to say return pause so this will return the position of the current flow and that's it for food so you need to include that also over here um now main file so here we need to say hash include food dot h and here we don't need cst database again because we have defined it inside this food dot it so that gets included automatically and here we need to create a food object so below the snake let's create a food so it's going to be good and as a constructor doesn't need anything so you can just put it like this and here we need to check whether the snake has eaten the food or not so for that what you can do is you can have a function inside the snake which will check whether its coordinates have matched the coordinates of food or not so what you can do is you can inside the snake dot h you can define another function called boolean let's say eaton this will basically say whether the food has been eaten by the snake or not so you can just pass in some coordinates inside this that is the coordinates of the food so coordinate food it's a food pass and we'll define it inside snake dot cpp it's basically um snake eaten and this will return true if the coordinates match so if i say uh if put password i did not capture it over here so it's called put pause and if put pause dot x is equal to pause dot x and uh put pause dot y is equal to positive y that is basically if the position of the head and position of the food are equal then it means that the food has been eaten by the snake so then you need to return to else you just return false so this means that uh if you eat the food it will return true and if it didn't eat return false and in main you can use that over here so if you can say snake dot eaten and you can get the foods equations of food dot um get pause and this will give you the position of the food which you can pass into the snake and if the snake has eaten then you need to generate another force so you can say full dot gen food and you also need to increase the length so you you can say snake dot length well length is a private variable so let's say snake dot grow and we will define a function to grow the snake so you can see void grow and we define it as a void bro which is landlessness and this should grow our snake and that should be it so now you have the logic for eating a food and then growing the snake well we are not going to see the snake grow but it is just going to grow in numbers we won't be seeing that visually we will see how to deal with showing that visually right and here we forgot to draw the food so here you need to put that else if our i is equal to food cos dot y and uh j is equal to food pause dot x well i did not capture that so quad foot cos equal to four dot get pass then for for the let's say the star right the star works well now if you run this um we have an error what does it say it says that width and height were not declared in the scope now that is because in food.hedge we did not define the width and height right we had defined it in the main.cpp so you need to copy these two lines here so ctrl c and put it inside food.h that is because we are using those two right we're not uh we did not define it in food dot x that is why it was give me an error and now if you run this you have another it says has no member y that is because this is a capital y and um here you have the snake and the food so here you can see the food so if i eat that food it's going to generate another food in some random position so you can see that generated over there and here we did not write the logic for collision so we'll take care of that afterwards well it's going to be in the same places that is because we did not see the random function so if you uh have seen the previous video where we made the tictactoe game you know what is serious well to see the random function what we are going to do here is we are just going to say the main function so to see the random function what we are going to do is hash include c time and here in the main function we will see is time right so now when you run it you will have a snake and food and uh this food will be generated once you eat it so here i ate that food now you can see that another one has been generated and then another one has been generated so we did not write the collision logic so if you go through the wall you will come you won't come back and that will take care now so to do that what we are going to do is we are going to write another function so its going to save cool collided and it's property of the snake so snake collided and then this is going to just return to our fall so this is going to return true if our position of x is less than let's say one that is because at the zeroth position you have the wall right so if it is less than one you mean it means that you cross the position of one and you cross the wall and uh in case your x is really greater than height then it means the width then it means that you have crossed the other wall also and similarly for the y you need to say it is less than one or position dot y is greater than the height then you need to return true it means that you have collided with the wall or else you return false all here so uh we forgot to define the prototype so here it is going to be bool collided and in main function instead of true we are just going to maintain a variable called game over which will track whether the game is over or not so in the beginning game over is false and while true you will change it to while game over or while not game over you need to run all these things and if the snake collided so if the snare collided then you will just say game over equal to true and this will stop executing the loop right now if you run this we got an error does it say again the width and height are not defined in snake dot h so we need to copy those two things from here and put it over here right now if you run this you don't have any errors hopefully and here you can see that the snake moves and if i go and hit the wall it ended the process so now the game ends successfully once i hit the wall and uh we have taken care of the food also so i think that the video has become long enough it has been an hour so the next video will see how to increase the snake's length and show it visually well we are increasing the snakes length over here but we are not showing the increase in its body right so if we are just moving the head and we are eating and we made quite a progress right so let's see what we have made we have made this board and then we have updated the port without causing any flickering and that's a great improvement and we also animated this character which can eat the food and we also written the logic for the food to appear at different random locations right in this video we will complete this game by adding the body for the snake well you know that the snake is growing by letting the food but it's just growing in numbers right we're not showing it visually so we will be showing that and also before that let's just fix some logical errors so let's see what are those errors so let's just drive one of the other pops up but i'm telling you i'm lucky but just to save the time and just ending this game here and let's first talk about the most obvious logical order so in the definition of food what we have said is once a food is created i want the random location on the board which will be the location where all food is placed right that's what we said when we are calling this generate food function inside the constructor right but what is happening here if you run this program again and again so let's run this once again so here you will be seeing that the first code is over here and if i close that again you will be seeing that the second time also the food is over there but the consequent foods are getting randomized so if you say the second food is somewhere over there and if we start this game again and try to eat that you see that the second food has been generated at some random location right the first one was somewhere over there so to fix this well you can go with it it's not actually an error it is actually not what we wanted right it's basically what i did not want but if you wanted that the first should be generated like that you can go ahead with this and skip this portion but since we wanted to generate the food at a random position right from the beginning what we are doing wrong is here first we are generating the food object and then we are shading the random function right so if we were introduced to the random function and the seeding function or back in the detector video right so if you remember the seeding function is a kind of controller to the random number generator well the random number generator will generate some random number it will do some calculation give you a number when the program is loaded onto the memory right so if you want a different random number what you need to do is you need to close everything and then open it again but we don't want to do that right we want random numbers right when we are in the memory so what we do is we change the seed so seed is like a starting point of the algorithm and what we do is we seed it with some number every time we want to generate a new number so what is the thing which is changing constantly well time is changing constantly so what we do is we just seed it with the time so this one will take the time it will take the time as an integer and then make the random number generated start from that particular term that is why you get different numbers after feeding it but what is happening here is we are calling the random function before seeding it right for the first time from the next time onwards one the food is heated the logic is over here right which is after the seeding function that is why you are getting randomized locations for the consequent foods but not for the first one so to fix that it is very simple what you can do is you can get rid of the constructor well i don't know why i define this constructive basically when we define a constructor what we actually see is we need the constructor to do something which the default constructor with a compiler will construct for this class can't do it but what the default constructor does it will basically create the memory required for this particular class right for loading this class onto the memory you need some amount of memory which is calculated by the constructor well we wanted the constructor to do something extra that is called this function on the creation and it did not work out as we expected that is why we can just get rid of the constructor and then call the function manually well if you want to keep the working of the program just like before then you can skip this step as i told you it's just preference right i prefer that would be generated at a random location right from the starting so you can go there and after seeding the function what we can do is we can now call the generate food method so this is the one line which we wanted to skip by using the constructor which was actually worthless right so creating a constructor was more good and at least for this kind of a game where we want the first element to be randomized so it basically get rid of the constructor and that will solve the issue now if you run this you will be getting the foods at different locations so one has been generated over here close that open that again so the other one has been generated but this is the problem actually which i wanted to show you in the beginning right well uh when i was eating the food i actually knew that at some point this would happen that is we won't see any food on the pool that is a major logical issue with this program which we made in the previous video and we will be fixing that right now so here if you see there is no food on the board but actually it has been generated we will see why that's happening okay so close that and now we fix the most obvious now let's go on to the issue which we just saw that the food is not yet getting generated well what we're doing in the generate food method here we are saying that we want some random number in the range of one to with minus one why uh we told that uh one the first character is basically reserved for the first wall and the last character is reserved for the last one so basically you want numbers from one to with minus one leaving those two characters it sounds reasonable right but if you forgot the math it is going to tell you a totally different story so let's see what the math is let me pull up my paint over here and now let's first talk about one of these width or height both of them are going to go with the same logic so we can talk about only one of them right so here let's say i draw the height so what is the height height was something like 25 right so the whole thing is actually 25 characters right and what we're saying we are saying that the first character and the last character are designed for the calls so from a computer's perspective what are these numbers going to be the computer starts complete from zero right so 25 characters is basically 0 to 24 for the computer and what we are saying is we are saying that this 0 and this 24 is not required in our range so basically we want numbers from 1 to 23 we don't want 0 we don't want the last character which is 24 right so this range becomes 1 to 23 well to get a number in the state what you can do is plug it into the formula so what is the formula for random number generation it is if you want a number from sorry n that is a lower limit to u which is the upper limit and lower limit is included and upper limit is not included right so you will be getting some numbers till u minus 1 so if you want numbers in this range that is l inclusive and u not inclusive you won't get the u then the formula is you need to plug in rand mod it was u minus l plus 1 plus l right so this is a formula you can plug it into this formula you can even see logically basically both of them are going to give you the same result and we'll just use the formula for simplicity purposes over here what we can do is just plug it into this formula so what it becomes let me just write it as r this is basically the random function r 1 and u is over here 24 right because we want 23 to be included and in this formula this particular u is not included in this random number generation so we'll just increase this by one number that is 24 and that will become 24 minus l plus one that is one plus one the lower limit is one which is included that's why we don't have to do anything to it and a plus one so what this becomes is i mod 22 plus one and what is 22 it is basically 25 minus 3 right so this is the number which we wanted to generate actually but what we did is we basically went by our intuition and messed up the logic right so to correct this what we need to do is using this particular formula this becomes minus three and this will become plus three and the same will go with height also we talked about height the same thing will go with the width also so if you draw a similar kind of analogy you will be seeing that the same logic will work for the width also right so let me just clear that and here it is minus three and this is plus one now this will fix the disappearance of the foot and there is another major flaw in our looping right so where are we looking we are looking over here with the board where we are displaying there is a major flaw in that and believe me if you have been able to identify that particular error you are going to be a great programmer right so let's see what the error is it is basically lying within the inner loop what we are doing well for the outer loop it is pretty straightforward we are going which is basically how the computer sees numbers from zero to n minus one and for the fifth we are doing something different right so what are we doing here we are saying that we are going from zero to with minus two and we had a reason that these two characters which are basically the walls are constant for all the rows so instead of including them inside the loop why not just explode them and run the loop only for the width minus two number of characters so that's what we did and that sounded reasonable but here is the problem what happens is let's say my uh generated xaxis which is basically the width is going to be 28 right sorry what is the maximum range is 50 right and what you can do if this is 50 the maximum number you can generate leaving 0 and 49 is 48 right so this is the maximum number you can generate and let's say that that is our x coordinate that is the value of your width now what happens here well if you see here j is running from zero to which minus two what is with minus two it is basically forty eight and it's not reaching forty it's just going till forty eight which means going till forty seven only right now if you see this you don't have a way to actually display this coordinate in this loop at all because it is out of bounds of this particular loop this loop will run only till 47 and you are asking it to show something which is on the 48th coordinate which is not possible by this loop right so how do i fix this well we can draw an analogy over here so if you draw the quantity which is js perspective w is basically the original width of output so say this when w is 0 j is not undefined why is that well let me just create this thing so that we can see this is the leftmost corner of our board and this is 25 right 25 characters or 25 pixels and here what we're doing is we are saying this is our character the width character and we are saying that the inner loop should run from 0 to 47 and we are including another character and that total makes it 50 it's 0 to 47 is 48 characters plus 1 plus 150 and this is the other one now what is happening is let's say my coordinate is 0 right when the x coordinate is 0 it basically means this particular position where the wall is there right but what is happening here our zero is starting from one step to the right because of this particular looping and this particular character before the loop so what is happening our loop which is starting is starting one step towards the right and that is why we are missing out our coordinates so what happens is if j is sorry if w which is our original x axis is zero j is not returned defined it is not there at all and when does j equal to zero start when with equal to one and so on this will continue when 50 equal to 48 j equal to 47 as we just saw and with just 49 it is not present right so this is the reason why we were not getting anything on the board not this is not the complete reason the actual reason was because we were messing up the formula the random number generation i feel to fix this what we can do is by comparing the coordinates we need to add one to this right so if 0 we don't care about the zero or the 49th coordinate right we don't want these two things because we're not going to generate those two they you need to compare only these things right you need to compare only these things and to compare that what we can do is we can add one to the j before comparing it with the x coordinate so to fix this what we are going to do here is when we need to canvas let me just leave this and here uh in place of k it's going to be j plus 1 and that should hopefully fix all the logical errors which you'll need so save that run that again and here we have our first fruit if you eat that the second food is getting generated and hopefully it should not stop generating it should be generating till we play this game and it should stay within the range of board and it should be visible to the player right so when if you say this is visible and trust me it's going to work and there are no kind of mistakes in this program and this is completely fixed now well we'll fix one more thing that is if i go to this particular wall i will crash before actually crashing so if you see this i i have not yet crashed the one but it's in that uh i have crashed this one that means i need to go inside the one so to fix that i mean it's the coordinate issue and also a placement of movement so let's first fix the coordinate if you go greater than with 1 so going by the same logic with minus 1 is going to be 49 because with this 15 so with minus 1 is going to be 49 so what you want you want something greater than 48 not 49 so it's going to be with 2 and that should fix the issue and um for the other one which i just showed you there for the rightmost one what is happening is we are first drawing the board we are moving we are actually changing the direction of this tape we are moving the snake getting updated before the speed so that is why you are not seeing whether the snake has been collided or not so you can just move this thing to the end of this thing to start basically the same thing right before the next loop the starting point is to the end of this one so they mean the same thing so just move this to the end of that now this should fix that issue that you're not seeing the snake colliding and now you should see that the snake actually collides with the wall before playing this game right so it went inside the wall and the game needed and now everything is pretty much fixed and now let's proceed to making this game real sneaky what is that we need to include the snake's body we are just growing the snake which is basically just increasing the length right so here you can see it's just increasing in length so how can we store this neat volume well what is your body it's just a collection of body parts and that collection must have triggered something inside you well they are going to use something like an array which is a collection a vector which is also a collection which was seen in the pointless video and the other thing is list right so these are three options available to us as of now and we'll use one of this now let's unless what we need to use over here so i think when and how do we know the fixed size of this name well if a player like me is going to play he's probably going to get defeated in let's say 5 or ten points right because i have a very bad player and maybe a pro player comes in and he can make a score as big as 1000 or 10 000 right well you cannot restrict the players or you cannot estimate the player's capacity by just uh keeping a fixed number what if the player is better than what you thought he should be right so here what you can do is well in this particular board you can actually fix it to some big number so let's say see that it is 50 and height is 25 right so the maximum number of characters possible is this thing 50 times 25 out of which you're using the borders so that is the only number of characters so if you make the snake as big as that after that there is no possibility of waiting because the snake has to collide right because the maximum free space has been limitations right so that is why you have uh such uh teleportable walls and all to take care of this issue but uh for this particular game uh we won't be talking about the teleportable ones but in the end i'll show you how to create teleportable walls if you want to and here basically the array is a very bad option because you are restricting the player's capacity and if you talk about vectors well it is dynamic but again it is going to take up some more extra space by defining so if you remember how vector work is first define some amount of space and once it gets filled up it will define a bigger space and then copy all the elements to this and get rid of this particular space so this one could be used this could work but again there is some extra space which is getting wasted so basically the best option here is going to be list so if you remember from our video on the pointers where we first discussed when to use vectors versus 20 useless you saw that list can be used whenever you have a data structure where you won't be accessing the middle elements more frequently you are just going to access the first and last image that is the case here also right we are not going to access the middle elements which is basically these body parts we are not going to access it we are just only concerned about the head which is on the front of the data structure and then right so we will talk about how to uh actually manage the head and tie with the short one but for now the head is at the beginning and the tail is at the end and they're only bothered about these two things we're not causing a protective of being able to pick some random element from in between well in a vector we can do that very simply because it is a continuous collection but in a list you if you remember it was something like this right your pointer you have pointed to something and then you have another pointer which points to this and so on if you want to pick this thing you need to power all this way but in a vector or in an array you can just pick that up using the index it is basically the starting position plus the number of steps you need to determine so in this case a list would be the best implement but to keep this tutorial simple i'm using vectors for this particular demonstration so i would totally encourage you to go with list not with vectors as we are going to see in this video and just showing with vectors because it's easier to relate than this right but once you're comfortable by implementing this particular project in a vector please go on to try it with a list list is the most preferred option for such games where you don't have to control the capacity of the user vector is not going to control but basically the extra space and how do we define the body well it's really simple so let's say i have two body parts basically a tail and the head i have this head over here and the snake has to move to the right so what can i do well what if i just remove this tail and then put another head over here and make this as a tail so for the let's just say this x mark over here that dino city now if you see that the snake has pulled one step to the right right and if i do that again so i take out this tail i include the head and i'm doing this head as the tail let's take a smooth again and let's say we are eating the food at some location so let's start with another snake so this is the snake we have and the food it is going to eat this particular food so it has eaten in the next iteration what i will do is i won't take off this table i will keep the stain and this is what happened right so i add the head i want to remove and that basically looks like the snake has grown right from two body parts it has grown into three body parts and that's what we want right so this is the logic we are going to implement and we are going to do that in vectors again list is the most preferred option please try it with the list not with the vector after you're comfortable basically so let's let's go to our sneak.h and quickly create a body definition so we need vector obviously so hash will close vector which is going to do it with the list you know right as include list and well since vector is a standard scope element you need to specify the scope so using name space std like we did in the main function and here you can just say vector body sorry vector and what is the data depth it's going to be coordinates basically so chord and then body and this defines the body of the victim now they have two changes we need to make what is that first of all we need to include the head to the body once we create a new snake so in this snake point constructed what we're going to do we're just going to say body dot push back which is basically pushing back the elements inside a vector and what we need to push back we need to push back the position which is basically the position of the head of the snake right we can just body not push back that particular position and while moving the snake following that logic which we just discussed what we're going to do is first pushing the head of the snake to the end of the list or end of the vector so how we do that we do not push back the new position which has been updated after all these things a new position and now what we'll do is if the body size is greater than the length of the snake what is the length of the snake that is the thing we are growing when the snake is actually eating the food right so that is the thing we are manipulating over here so this length integer if the body is size which basically the number of elements in the vector is greater than the length then what you do you just take out the element from the body so how do you do that you just say body dot and if i actually confused with what function you need to use the best thing i would suggest is not just eliminate the function but just use the resources so uh you can just go to your web and then search something like ctp vectors documentation and you'll get a lot of resources and c plus plus dot com is the best one among them well i think that this is the best one where you can find short descriptions of all the functions and here you should be seeing some function like pop back what does it say it says that removes the last element in the vector effectively reducing the container size by one but we actually don't want this well why is that if you see but technically the tail should be at the end of the body but if you look at the structure what we're doing is we're actually pushing back the head one step to the right right so this is what two step does so basically our head is over here and your tail is over here and what we need to do we need to remove the first element so how can we remove that you can just check out the functions over here but to save the time i'm just going to show you the function which is basically clear or areas right so you will find this one this is basically going to remove from the vector either a single element or a range of elements so here we just need to remove a single element but the position is not an integer it's a pointer so here you can see it says the definitions iterator position and iterate to first unit well you can go with any of this the only difference is that it has a quantity but you don't have to know at this stage right you can you can just go and search what these two things are basically the same thing and how they use that you can see an example over here it says dot is my vector dot begin plus five so plus y is basically going five steps away from the first element which is basically the sixth element and that's uh how you use this areas function has also shown an example to delete a range well we are not quite interested in the regime we just want to erase a single element which is going to be our first element because our first element is the tail and what we can do we can just say my vector and begin plus 0 that is the first implement or we can just omit the zero and just say my vector that is going to erase the first angle so let's implement that what we're going to say i'm going to say body dot it is and what we're going to do is we're going to erase the first element which we can get from body dots again this is the pointer for the first item first position right so this will basically erase the first element from our list and before proceeding let's first see whether this is working or not and we need to create another function let us keep this function alone then create another function just in case something goes wrong so vector and it is going to be coordinated you need a coordinate vector to be written well basically you are going to return this next body so snake and then let's say get body and inside this we can say return body and in the snake dot h you can just create that function definition which is basically the vector sorry what does that get body right so now we have different snakes definition now we'll just update the board and what we need we first need a vector to capture the snake's body so vector quant let's say snake body equal to snake dot get body and inside this what we're going to do we'll just remove this else and we'll place this afterwards what we're going to do is inside the edge we are first going to loop through snake's body and see whether any coordinate matches or not so uh what we can do is we can just say this body part which will stay false in the beginning right we'll change that in the loop and what you can say is for in and k plus plus what we are going to do here is inside this loop we will say if i coordinate which is basically going to control the y coordinate is equal to the snake body of the kth index dot x sorry dot y and j plus one well remember that's the logic we were missing up equal to snake body dot solution body of that particular index dot x if these things match up then what we need to do you need to display a body part so let's just go with the small o for now this is our body part and this body part becomes true equal to true and what else well we don't want to run this thing right because at an instant a particular body part can stay on there at a particular location so if that location is occupied it is pretty obvious that any other body part won't occupy the location so you can safely break out of this loop you can end this loop and in the end what you can say is if it is not body part if not body part then obviously it is going to be just an empty space and here another thing is here we are going to report it on size but remember body includes the head right so what we can do is we can just say body dot size 1 which will basically leave at the last input and now this should work i mean let's try to implement this so f9 and here you can see that the snake has grown so the other fold is over here so well i ate that and the third food is over here well you can see that the snake is growing right so here you have four body parts of the snake and now if i eat that here now you have five right so now we have a working snake game right so now you have working snake game and this works pretty fine right so now the you can see that the animation also works pretty fine the body parts seem to follow the head and so on right so this concludes our game well i will just keep it global so that you can use it on the board function also so here you can just see in score which is going to be zero in the beginning and uh well you can just set this to zero in case you want to uh say play again something like that what you can do is instead of main you can just say game and this is going to avoid game because i'm not going to do that you can do that right so if if i want to play again you can ask a question do you want to play again or not something like that and if i press yes then you can call this function again and then you can set this thing as zero so equal to zero before the beginning of the new game and here what you can do is you can just say score plus plus very simple and if you want to give 10 points or something like that you can just do that score equal to square plus 10 or any short hands if you know scored plus equal to 10 or something like that you can do that over here and here before starting to print out the board what we can do is we can just say c out our score so score is our school current school and just add a couple of new lines so that looks neat and that should equal well now i have one redundant function over here that is this food sorry the snake pause which is actually getting the position of the head and we are also getting the position of the body right and we did not define the collision of the sleeve right so we'll do that those things first of all let's just see whether this thing works or not so now you have this particular snake and i hate that the school is 10 now i hate that school is 20 i ate that school is 30 and so on so it's working pretty fine so you can close that and to take care of the collision where you might have figured it out by now what we need to do well what you need to do here is you need to say else and you need to check whether it collided or not how do i check that well you don't need an electron you can directly is less than the body dot size well it's inside this nature i don't have to call that again just length minus 1 because i don't want the head and it's going to be i plus plus right and what we need to check if our snake's head head is basically positive right so if cos dot x is equal to any of this new body will be the substrate body is just body body of i dot x and the y coordinate is also same positive y is equal to bodies i don't y if these two thing match up just say return true yes you collided if these two things don't satisfy the end just say written false so they should take care of the collision so let's just try that out f9 to build and combine this and here you have this snake and the food and let's first go for our first food we have grown and the score has also increased and the second fruit but it's going to take a while if i go like that it's just going one body particularly so what i can do is i'll just write up equivalent well how can i collect well i'm going left now right so if i just press right i'm just going to pull it with my neck so basically i collected and now you can see that the process has stopped basically all collision algorithm is working so that basically ends this game and if you want to make a teleportable wall it's really simple what you need to do is i i'm sure many of you must have figured it out right now well you just need to play with the coordinates so if here if you see in the snake moves me what you do is if you want to change the location of this wave you will just say here if this particular thing if position dot x is greater than the width minus 2 then what you do you just say position dot x equal to zero so simple and again what you do if you say if position dot y or position dot x is less than one then what you do is just have position dot x equal to the width minus three sorry about that it for random function we need to use with minus three because uh for generating the random numbers in that range it's basically with minus two and this will make the side walls teleportable so if you just save that and now if you run this you should be going through the sidewall and coming from the other one and now if i go through my side wall i should be appearing from the other one so you can see that it has been kind of teleportation now if i eat that our tray will also follow our steps right so if it goes from there you appear from there right so it works good that is how you make data portable walls and uh once you get to know about file handling basically how to write files what you can do is you can even have a high score option so you can write down a particular high score on the file so let's say i open this game right now and i scored about 10 points and you scored about thousand points that's pretty reasonable i'm not a very good player but yeah so uh you scored a thousand points and that is a high score right so here if you run this program again that high school gets lost so instead of just writing it on the memory for that particular kind of run what you can do is you can have a file where you can write down all your high scores and then whenever you load this game you don't get along with the file so inside that file you have all the high school lists and if you want you can just have names also so some games provide that right so you have the name and the high school sometimes you can design everything and we'll come back to this by discussing files right so because uh traditionally what we do is we just write files about students and all the stuff but we'll come back here and then try to work on this game more and trying to create a file and again this is the total working game and if you want to implement this and if you are comfortable with implementing this with this kind of vector well i have made some rejected functions like this is completely solid this one is completely unnecessary because i'm getting the head along with the body so you can take care of that and again i will advise you not to use a vector using this and here if you want to include another teleportable wall inside this one you can do that again with a similar kind of logic for yaxis right so you make basically all four four of them all still reportable so uh when i i had actually implemented this game in python and if you use a graphics library you will be getting results like that so if we go to our python one so here i have my game it is basically written in two files one has the classes and one has the script and it has various images so what i have is the snake in patch so here you can see body horizontal tail up so whenever that snake is going in that particular direction you show that image and now where you can run this thing right over here you can see this game this is what you can make with a graphics library well this is pretty far but this is what you can make with the graphics library and you can see how smooth it is and it doesn't have any uh kind of issues like moving down faster in the vertical direction moving slower in the horizontal direction it has kind of same speed because you can control it you can basically control the number of pixels and all and if you see it is really portable on both sides if i go from the bottom from coming from the top and if i go from the sides i end up coming from there so this is how you can implement your games and this is basically the same project which i've implemented except that i have some additional functions handling the graphics of this game right nothing more than that it is basically the same exact logic which were talked but when you use a graphics library you get results like that so once you're comfortable when programming this particular game on the console i would advise you to look up some graphics library which is available in safe space there are many so see what you're comfortable with and try to implement such games on graphics even the tick factor game can be implemented on the graphics network and that really looks good instead of the concern is the best way or the best platform to actually put down our ideas in a very fast way well if i want to do the same thing in a graphics library it will take a really long time i need to initiate the graphics library i need to do a lot of things before getting all these things right so if you're coming up with an idea i would rather recommend you not to go to a graphics library but first thing and then put up a dirty kind of working prototype on your console and then you can beautify it on the graphics library so that's it for this particular video hope you enjoyed this and you know making it faster on the x and slower on the way or something like that i didn't do that i just went with a very simple approach but i'm sure you can do that and in the next video we'll start with inheritance till then happy coding
